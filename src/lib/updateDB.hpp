#ifndef UPDATE_INFO
#define UPDATE_INFO

#include <sqlite3.h>
#include <string>
#include <filesystem>
#include <iostream>
#include <ctime>
#include <iomanip>
#include <chrono>
#include <sstream>

#include "env.hpp"
#include "utilities.hpp"

namespace UPDATE_INFO {
    
    /**
     * @brief Get the last write time of a file in epoch time format (seconds since January 1, 1970, 00:00:00 UTC)
     * 
     * @param path The path to the file
     * @return The last write time of the file in epoch time format
     */
    int get_epoch_time(const std::filesystem::path& path) {
        try {
            // Get the last write time of the file
            auto ftime = std::filesystem::last_write_time(path);

            // Convert file time to system time
            auto sctp = std::chrono::time_point_cast<std::chrono::system_clock::duration>(
                ftime - decltype(ftime)::clock::now() + std::chrono::system_clock::now()
            );

            // Get the epoch time in seconds
            auto epoch_time = std::chrono::system_clock::to_time_t(sctp);

            return static_cast<int>(epoch_time);
        } catch (const std::filesystem::filesystem_error& e) {
            std::cerr << "Error getting last write time for file: " << e.what() << std::endl;
            return -1; // Return -1 to indicate an error occurred
        }
    }

    /**
     * @brief Create a unique ID from a file path, epoch time, chunk count, and starting ID
     * 
     * @param path The path to the file
     * @param epoch_time The last write time of the file in epoch time format (seconds since January 1, 1970, 00:00:00 UTC)
     * @param chunk_count The number of chunks in the file
     * @param starting_id The starting ID of the first chunk in the file
     * @return A unique ID string that can be used to identify the file
     * 
     * The unique ID is generated by encoding the path, epoch time, chunk count, and starting ID, and then computing a redundancy code.
     * The redundancy code is used to detect errors in the unique ID.
     * The resulting unique ID is a 32-character string in hexadecimal format.
     */
    std::string create_unique_id(const std::filesystem::path& path, const int& epoch_time, const int& chunk_count, const int& starting_id) {
        // Encode the path
        uint32_t encoded_path = 0;
        for (const auto& c : path.u8string()) {
            encoded_path += static_cast<uint32_t> ((c%2) ? c + 10 : c + 21) << 1;
        }
        encoded_path &= 0xFFFFFFFF; // Truncate the epoch time to 32 bits
        // Encode the epoch time
        uint32_t encoded_time = epoch_time & 0xFFFFFFFF; // Truncate the epoch time to 32 bits

        // Encode the chunk count
        uint16_t encoded_chunk_count = chunk_count & 0xFFFF;

        // Encode the starting ID
        uint16_t encoded_starting_id = ((chunk_count == 0) ? (epoch_time) : starting_id) & 0xFFFF;

        // Generate a redundancy code
        uint16_t redundancy_code = (encoded_path ^ encoded_time ^ encoded_chunk_count ^ encoded_starting_id) & 0xFFFF;

        // Create the unique ID
        std::stringstream ss;
        ss << std::hex << std::setw(8) << std::setfill('0') << encoded_path << encoded_time << encoded_chunk_count << encoded_starting_id << redundancy_code;
        return ss.str();
    }

    /**
     * @brief Count the number of chunks for a given file name in the pdf_chunks table
     * 
     * @param db The database connection
     * @param file_name The file name to search for
     * @return The number of chunks if found, otherwise 0
     * 
     * This function executes a SELECT query on the pdf_chunks table, binding the given file_name to the ? placeholder.
     * If a row is returned, the chunk_count column is retrieved and returned as an int. Otherwise, 0 is returned.
     */
    int count_chunk_for_each_title(sqlite3* db, const std::string& file_name) {
        sqlite3_stmt* stmt;
        sqlite3_prepare_v2(db, "SELECT COUNT(chunk_index) FROM pdf_chunks WHERE file_name = ?;", -1, &stmt, NULL);
        sqlite3_bind_text(stmt, 1, file_name.c_str(), -1, SQLITE_STATIC);
        int chunk_count = 0;
        if (sqlite3_step(stmt) == SQLITE_ROW) {
            chunk_count = sqlite3_column_int(stmt, 0);
        }
        sqlite3_finalize(stmt);
        return chunk_count;
    }

    /**
     * @brief Get the starting ID for a given file name from the pdf_chunks table
     * 
     * @param db The database connection
     * @param file_name The file name to search for
     * @return The starting ID if found, otherwise 0
     * 
     * This function executes a SELECT query on the pdf_chunks table, binding the given file_name to the ? placeholder.
     * If a row is returned, the starting_id column is retrieved and returned as an int. Otherwise, 0 is returned.
     */
    int get_starting_id(sqlite3* db, const std::string& file_name) {
        sqlite3_stmt* stmt;
        sqlite3_prepare_v2(db, "SELECT MIN(id) FROM pdf_chunks WHERE file_name = ?;", -1, &stmt, NULL);
        sqlite3_bind_text(stmt, 1, file_name.c_str(), -1, SQLITE_STATIC);
        int starting_id = 0;
        if (sqlite3_step(stmt) == SQLITE_ROW) {
            starting_id = sqlite3_column_int(stmt, 0);
        }
        sqlite3_finalize(stmt);
        return starting_id;
    }

    /**
     * @brief Get the ending ID for a given file name from the pdf_chunks table
     * 
     * @param db The database connection
     * @param file_name The file name to search for
     * @return The ending ID if found, otherwise 0
     * 
     * This function executes a SELECT query on the pdf_chunks table, binding the given file_name to the ? placeholder.
     * If a row is returned, the ending_id column is retrieved and returned as an int. Otherwise, 0 is returned.
     */
    int get_ending_id(sqlite3* db, const std::string& file_name) {
        sqlite3_stmt* stmt;
        sqlite3_prepare_v2(db, "SELECT MAX(id) FROM pdf_chunks WHERE file_name = ?;", -1, &stmt, NULL);
        sqlite3_bind_text(stmt, 1, file_name.c_str(), -1, SQLITE_STATIC);
        int ending_id = 0;
        if (sqlite3_step(stmt) == SQLITE_ROW) {
            ending_id = sqlite3_column_int(stmt, 0);
        }
        sqlite3_finalize(stmt);
        return ending_id;
    }
}

#endif // UPDATE_INFO
Numerical Methods in 
Chemical Engineering Using 
Python® and Simulink®
Numerical methods are vital to the practice of chemical engineering, allowing for 
the solution of real-world problems. Written in a concise and practical format, this 
textbook introduces readers to the numerical methods required in the discipline of 
chemical engineering and enables them to validate their solutions using both Python 
and Simulink.
• Introduces numerical methods, followed by the solution of linear and non￾linear algebraic equations.
• Deals with the numerical integration of a definite function and solves initial 
and boundary value ordinary differential equations with different orders.
• Weaves in examples of various numerical methods and validates solutions 
to each with Python and Simulink graphical programming.
• Features appendices on how to use Python and Simulink.
Aimed at advanced undergraduate and graduate chemical engineering students, as 
well as practicing chemical engineers, this textbook offers a guide to the use of two 
of the most widely used programs in the discipline.
The textbook features numerous video lectures of applications and a solutions 
manual for qualifying instructors.Numerical Methods in 
Chemical Engineering Using 
Python® and Simulink®
Nayef GhasemMATLAB® is a trademark of The MathWorks, Inc. and is used with permission. The MathWorks 
does not warrant the accuracy of the text or exercises in this book. This book’s use or discussion 
of MATLAB® software or related products does not constitute endorsement or sponsorship by The 
MathWorks of a particular pedagogical approach or particular use of the MATLAB® software.
First edition published 2024
by CRC Press
6000 Broken Sound Parkway NW, Suite 300, Boca Raton, FL 33487-2742
and by CRC Press
4 Park Square, Milton Park, Abingdon, Oxon, OX14 4RN
CRC Press is an imprint of Taylor & Francis Group, LLC
© 2024 Nayef Ghasem
Reasonable efforts have been made to publish reliable data and information, but the author and 
publisher cannot assume responsibility for the validity of all materials or the consequences of 
their use. The authors and publishers have attempted to trace the copyright holders of all material 
reproduced in this publication and apologize to copyright holders if permission to publish in this 
form has not been obtained. If any copyright material has not been acknowledged please write and 
let us know so we may rectify in any future reprint.
Except as permitted under U.S. Copyright Law, no part of this book may be reprinted, reproduced, 
transmitted, or utilized in any form by any electronic, mechanical, or other means, now known 
or hereafter invented, including photocopying, microfilming, and recording, or in any information 
storage or retrieval system, without written permission from the publishers.
For permission to photocopy or use material electronically from this work, access www.copyright.
com or contact the Copyright Clearance Center, Inc. (CCC), 222 Rosewood Drive, Danvers, MA 01923, 
978-750-8400. For works that are not available on CCC please contact mpkbookspermissions@
tandf.co.uk
Trademark notice: Product or corporate names may be trademarks or registered trademarks and are 
used only for identification and explanation without intent to infringe.
ISBN: 978-1-032-41946-6 (hbk)
ISBN: 978-1-032-41951-0 (pbk)
ISBN: 978-1-003-36054-4 (ebk)
ISBN: 978-1-032-52408-5 (eBook+)
DOI: 10.1201/9781003360544
Typeset in Times
by codeMantra
Access the Instructor and Student Resources/Support Material: 
http://www.routledge.com/9781032419466v
Contents
Acknowledgment ......................................................................................................ix
Author .......................................................................................................................xi
Chapter 1 Introduction ..........................................................................................1
1.1 Background................................................................................1
1.1.1 What Is the Numerical Method....................................2
1.1.2 Why Are Numerical Methods Necessary ....................2
1.1.3 When to Use Numerical Methods................................3
1.2 Types of Numerical Methods....................................................3
1.2.1 Direct Method ..............................................................3
1.2.2 Indirect Numerical Methods (Iterative Method)..........3
1.3 Linear and Nonlinear Systems of Algebraic Equations............4
1.3.1 Linear Algebraic Equation...........................................4
1.3.2 Nonlinear Algebraic Equations....................................7
1.4 Ordinary Differential Equations ............................................. 13
1.4.1 Order of Differential Equation................................... 14
1.4.2 Analytical Solution of First-Order Differential 
Equation ..................................................................... 15
1.5 Boundary Value Problems....................................................... 19
1.6 Summary .................................................................................28
1.7 Problems..................................................................................28
Reference............................................................................................29
Chapter 2 Numerical Solutions of Linear Systems............................................. 31
2.1 Introduction ............................................................................. 31
2.1.1 Definition of a Linear System of Algebraic 
Equations.................................................................... 31
2.1.2 Properties of a Matrix and Operation ........................ 33
2.1.3 Inverse of Matrix [A]–1 ...............................................34
2.1.4 Transpose a Matrix..................................................... 35
2.2 Cramer’s Rule ..........................................................................36
2.2.1 Solving Two Linear Equations Using 
Cramer’s Rule.............................................................36
2.2.2 Solving Three Linear Equations Using 
Cramer’s Rule.............................................................37
2.3 Gauss Elimination Method...................................................... 51
2.4 Gauss-Jordan Elimination ....................................................... 58
2.5 The Gauss-Jacobi and Gauss-Seidel Iterative Methods........... 62
2.5.1 The Gauss-Jacobi Method..........................................63
2.5.2 Gauss-Seidel Iterative Methods..................................66vi Contents
2.6 Summary .................................................................................70
2.7 Problems..................................................................................70
Reference............................................................................................72
Chapter 3 Bracketing Numerical Methods for Solving Systems of 
Nonlinear Equations...........................................................................73
3.1 Introduction .............................................................................73
3.2 Graphical Method.................................................................... 74
3.3 Roots Solution with Bracketing Method .................................88
3.3.1 Bisection Method .......................................................90
3.3.2 False-Position Method................................................93
3.3.3 Ridders’ Method.........................................................97
3.4 Summary ............................................................................... 101
3.5 Problems................................................................................ 101
Reference.......................................................................................... 102
Chapter 4 Open Numerical Methods for Solving Systems of Nonlinear 
Equations.......................................................................................... 103
4.1 Introduction ........................................................................... 103
4.2 Method of Substitution .......................................................... 104
4.3 Fixed-Point Iteration Method ................................................ 108
4.4 NR Method............................................................................ 116
4.5 NR Multivariable................................................................... 123
4.6 Secant Method.......................................................................126
4.6.1 Secant Method Advantages...................................... 128
4.6.2 Secant Method Drawbacks.......................................128
4.7 Muller’s Method .................................................................... 134
4.8 Summary ............................................................................... 139
4.9 Problems................................................................................ 139
References........................................................................................ 141
Chapter 5 Initial Value Problem Differential Equations................................... 143
5.1 Introduction ........................................................................... 143
5.2 Eigenvalue and Eigenvector................................................... 144
5.3 Elimination Methods............................................................. 163
5.4 Summary ............................................................................... 172
5.5 Problems................................................................................ 172
Reference.......................................................................................... 175
Chapter 6 Numerical Integration of Definite Functions................................... 177
6.1 Introduction ........................................................................... 177
6.2 Simpson’s Rule ...................................................................... 178Contents vii
6.3 Trapezoidal Rule.................................................................... 187
6.4 Rectangle Rule (Midpoint Rule)............................................ 190
6.5 Boole’s Rule........................................................................... 193
6.6 Romberg Integration and Richardson Extrapolation............. 196
6.7 Summary ...............................................................................203
6.8 Problem..................................................................................203
References........................................................................................205
Chapter 7 Numerical Solution of Ordinary Differential Equations..................207
7.1 Introduction ...........................................................................207
7.2 Euler Method (Explicit Method) ...........................................208
7.3 Backward Euler Method (Implicit Method).......................... 217
7.4 Midpoint Method...................................................................222
7.5 Heun’s Method.......................................................................226
7.6 Runge-Kutta Method ............................................................. 231
7.7 Picard’s Iterative Method.......................................................240
7.8 Summary ...............................................................................244
7.9 Problems................................................................................244
References........................................................................................246
Chapter 8 Simultaneous Systems of Differential Equations.............................247
8.1 Introduction ...........................................................................247
8.2 Simultaneous Numerical Solution of Two ODEs..................248
8.2.1 Euler Method............................................................248
8.2.2 Midpoint Method......................................................254
8.2.3 Fourth-Order Runge-Kutta.......................................260
8.2.4 Picard’s Iterative Method ......................................... 270
8.3 Summary ...............................................................................277
8.4 Problems................................................................................277
References........................................................................................ 278
Chapter 9 Boundary Value Problems of Ordinary Differential Equations....... 279
9.1 Introduction ........................................................................... 279
9.2 Boundary Conditions.............................................................280
9.2.1 Initial Value Problems.............................................. 281
9.2.2 Boundary Value Problem......................................... 281
9.3 Solution of BVPs ...................................................................282
9.3.1 Finite Difference Method.........................................282
9.3.2 Thomas Algorithm...................................................283
9.3.3 Shooting Method for BVPs......................................302
9.4 Summary ............................................................................... 314
9.5 Problems................................................................................ 314
References........................................................................................ 316viii Contents
Appendix A: Python Programming Code ......................................................... 317
Appendix B: Introduction to Simulink.............................................................. 335
Index...................................................................................................................... 353ix
Acknowledgment
The author would like to thank Allison Shatkin, acquiring editor for this book, and 
Hannah Warfel, editorial assistant, for their help and cooperation. The author would 
also like to thank the Matlab engineers for their help and kind cooperation. The com￾ments and suggestions of the reviewers were highly appreciated.xi
Author
Nayef Ghasem is a professor of chemical engineering at the United Arab Emirates 
University. He teaches mainly process modeling and simulation, natural gas process￾ing, and reactor design in chemical engineering, as well as other graduate and under￾graduate courses in chemical engineering. He has published primarily in modeling 
and simulation, bifurcation theory, polymer reaction engineering, advanced con￾trol, and CO2 absorption in gas–liquid membrane contactors. He has also authored 
Principles of Chemical Engineering Processes (CRC Press, 2012), Modeling and 
Simulation of Process Systems (CRC Press, 2019), and Computer Methods in 
Chemical Engineering, 2nd Edition (CRC Press, 2021). He is a senior member of 
American Institute of Chemical Engineers (AIChE).1
1 Introduction
Numerical methods attempt to find approximate solutions to problems rather than 
exact solutions. Numerical methods are procedures used to estimate mathematical 
procedures. We need an approximation because either we cannot solve the system 
analytically or the analytical method is difficult. This chapter explains the sources 
of mathematical equations that are derived from chemical engineering subjects. This 
chapter offers an advanced introduction to numerical method.
LEARNING OBJECTIVES
1. Realize what a numerical method is.
2. Know when to use numerical methods.
3. Find roots of equations.
4. Identify systems of linear and nonlinear algebraic equations. 
5. Detect ordinary differential equations.
6. Identify boundary value problems.
1.1 BACKGROUND
The numerical method is a mathematical implement intended to solve numeri￾cal problems. The numerical method is an approximate computational method for 
solving a mathematical problem that is often complex or has no analytic solution. 
Numerical methods use computers to solve problems by incremental, repetitive, and 
iteration methods, which may be dull or unsolvable by manual calculations. This 
chapter intends to give scientists and engineers an overview of numerical methods 
of interest.
We can distinguish several distinct stages in the numerical method problem￾solving process. While formulating a mathematical model of a physical system, 
engineers must consider that they expect to solve a problem on a computer. It will 
therefore provide specific objectives, appropriate input data, adequate checks, and 
the type and quantity of output. Once the problem has been formulated, numerical 
methods and the initial error analysis must be developed to solve the problem. A 
numerical method used to solve a problem is called an algorithm. An algorithm is a 
complete set of procedures to solve a mathematical problem. The programmer should 
convert the proposed algorithm into a step-by-step instruction for the computer. The 
numerical analysts consider all sources of error that might affect the results and how 
much precision is required to determine the appropriate step size or the number of 
repetitions required.
DOI: 10.1201/9781003360544-12 Numerical Methods in Chemical Engineering Using Python® and Simulink®
1.1.1 What Is the NumerIcal method
Defining analytical and numerical methods helps understand the difference between 
them. Analytical means we apply a set of logical steps to solve our problem that is 
proven to find the exact answer to the problem. For example, if we had x    + = 1   0,
we could easily find what x is equal to one by adding minus one to both sides; this 
works for many derivatives, integrals, and everything else you learned at school so 
far. However, what if finding that exact answer took, say, 20 hours or even after all 
that work, you find out it is not even possible to find an answer when you know there 
should be one? Well, that is where numerical methods come in.
Numerical methods are mathematical ways to solve specific problems. They allow 
us to approximately solve math problems, specifically those we cannot solve analyti￾cally. In contrast, analytical solutions apply a set of logical steps to solve a problem 
that are proven to find the exact answer to the problem. It studies numerical meth￾ods that try to find approximate solutions to problems rather than exact solutions. 
Numerical analysis is a branch of mathematics that solves ongoing problems using 
numerical approximation. The numerical method used to solve a problem is called an 
algorithm. An algorithm is a procedure that solves a mathematical problem or selects 
or constructs an appropriate set of rules that correctly fall within the scope of numeri￾cal analysis. After deciding on an algorithm or group of algorithms to solve a numeri￾cal problem, the analyst must consider all sources of error that may affect the results. 
Given the amount of precision required, calculate the magnitude of the estimated 
error and select the appropriate step size or number of repetitions required. Adequate 
checks for accuracy and corrective measures operate in cases of non-convergence. 
The process of digital computing involves building a mathematical model and an 
appropriate numerical system. Finally, implement and check the solution.
1.1.2 Why are NumerIcal methods Necessary
Numerical methods essentially plug in inputs to a problem, check how close the out￾put is to a solution, change our input, and repeat this process until we get as close as 
we desire to our approximated solution. How long our computer takes to plug in as 
many numbers as it needs versus accuracy? How close are we to the solution to the 
problem? So to make this clear, let us go back to our x    + = 1   0 problem and begin 
with, say, a guess of 1/2; well, we plug in 1/2 for x and find that 1.5 does not equal 0, 
so we would try a new guess and so on until our left side gets close to our right side. 
This may sound like more work in this simple example, but using computers and 
working with more complicated problems using numerical methods are a rescuer.
The use of numerical methods is more efficient and faster than the use of analyti￾cal methods. Many engineering problems are too complex to be solved manually, so 
numerical methods are needed. Examples include distillation column design (linear 
algebra), differential equations, and statistics. Many tools are available to reduce the 
complexity of solving complex differential equations. Very few things have an exact 
analytic solution, and more have approximate solutions. Many things have no solu￾tion but are only numerical. Any modern problem in engineering has to be solved to 
a large extent numerically or by doing a lot of costly experiments [1].Introduction 3
1.1.3 WheN to use NumerIcal methods
Numerical methods should be used if the problem is multidimensional (e.g., three￾dimensional flow in complex mixing or extrusion elements, temperature fields, rheol￾ogy) and if the geometry of the flow area is very complex. They need a high degree 
of mathematical drafting and programming. The main advantage of the numerical 
method is that a numerical solution to problems can be obtained since there is no 
analytic solution. We generally prefer the analytical method because it is faster and 
because the solution is accurate. However, sometimes we recourse to a numerical 
method due to time or hardware limitations.
1.2 TYPES OF NUMERICAL METHODS
Numerical analysts and mathematicians use a variety of tools to develop numeri￾cal methods for solving mathematical problems. The most crucial idea mentioned 
earlier, which includes all mathematical problems, is to change a particular problem 
into one that can be easily solved. Other ideas vary about the type of mathematical 
problem that was solved. There are two numerical methods.
1.2.1 dIrect method
This method solves a problem in a limited number of steps and gives an accurate 
answer if performed with precise arithmetic operations, such as the Gaussian elimi￾nation method. In practice, maximum accuracy is used, and the result is close to the 
solution. Without rounding errors, the direct method provides an accurate solution.
In conclusion, direct numerical methods are ways of solving problems in a finite 
number of steps. The method solves any non-singular matrix. When solving a system 
of linear equations using these direct methods, we take a set number of steps, such as 
converting a system of linear equations to an augmented matrix, then trying to con￾vert it to an upper-triangular matrix, and then solving. After a set number of steps, 
we arrive at a final solution.
1.2.2 INdIrect NumerIcal methods (IteratIve method)
Iterative numerical methods are different from direct numerical methods in that they 
do not necessarily stop after a certain number of steps; they will continue to iterate, 
which means to do again or repeat with a better guess, until they get enough error. 
Some examples of iterative numerical methods are the Bisection method, Newton’s 
method, and Jacoby iteration. Additionally, when using iterative solvers, begin with 
an initial guess.
In actual computation, direct methods are much more computationally heavy, as 
everything in the matrix is solved in one computational step, which requires a whole 
matrix that is actively used continually. The problem is broken down into a set of 
small steps in an iterative manner, which is why iterative methods are usually pre￾ferred for larger arrays.4 Numerical Methods in Chemical Engineering Using Python® and Simulink®
In summary, for the indirect numerical methods, one cannot stop after a certain 
number of steps and say that it is good enough because what we will have is an 
unfinished problem and no answer, and will need to complete the set of steps to 
achieve any answer that makes any sense. By contrast, in the direct numerical meth￾ods, before we begin, we can find out how many steps we need to get to an answer, 
and one must complete that number of steps to achieve that answer. Consider solving 
the following matrix,
 1 2 3    4 5 6  
 7 8 9   
We need to turn these three elements (4,7,8) to zero and then use backward substitu￾tion, and then we will have to solve a system of linear equations; otherwise, it is not 
invertible and has no unique solution. However, with iterative numerical methods, 
setting the number of steps is not required; stop whenever needed. The longer the 
computation period, the more accurate the solution becomes, which offsets computa￾tion time versus accuracy. In conclusion, direct numerical methods use a set number 
of steps to achieve a final solution; however, iterative numerical methods use an ini￾tial guess to approximate a final solution.
1.3 LINEAR AND NONLINEAR SYSTEMS 
OF ALGEBRAIC EQUATIONS
A linear equation can take the form
Ax + + By C = 0 (1.1)
Any equation not written in this form is considered a nonlinear one. The substitution 
method we used for linear systems is the same as the one we will use for nonlinear 
systems. We solve one equation for one variable and then substitute the result into the 
second equation to find another variable, and so on. However, there is a variance in 
the possible outcomes. Table 1.1 shows examples of linear and nonlinear equations.
Understanding the difference between linear and nonlinear equations is extremely 
important. Table 1.2 shows linear and nonlinear equations.
1.3.1 lINear algebraIc equatIoN
A system of linear equations is just a collection of independent equations that cannot 
derive from one another, which means we cannot say we have two equations if both 
of our equations are y    + = 3   0 and also y    = − 3; they are the same thing, just three 
is subtracted from both sides. Linear equations must be related and share the same 
set of variables. An equation is linear if each term is simply a constant or a constant 
multiplied by a variable, similar to the equation of a line y a     = +x b, which is a con￾stant time a variable plus b, which is simply a constant. If we know that our equation Introduction 5
is linear, you may ask what it would mean to solve a system of linear equations. 
Accordingly, solving a system of linear equations essentially means finding and thus 
assigning a value to each of your unknown variables because there is sometimes more 
than one solution to a system of linear equations. The total set of solutions that can 
solve our system of linear equations is called the solution set. In general, a linear alge￾braic equation (LAE) is one in which the highest power of the variables is always 1. 
The standard form of a LAE is one variable of the form
ax b + = 0 (1.2)
where a and b are constants and x is a variable, a is a coefficient of the variable x, and 
b is a constant. A system of linear equations is a collection of more than one equa￾tion. The linear equation is an algebraic equation where each term has an exponent 
of 1, and when this equation is plotted, it always results in a straight line; that is why 
it is called a ‘linear equation’. There are linear equations in one variable and linear 
equations in two variables. Let us learn how to define linear and nonlinear equations 
with the help of the following examples. To solve the system of linear equations, the 
minimum number of unknowns should be equal to or less than the number of equa￾tions we have. If the number of unknowns is more than the number of independent 
equations, then we cannot solve the system of equations.
Example 1.1 A Linear Equation in One Variable
Linear equations in one variable are expressed as ax b + = 0, where a and b are 
integers, and x is a variable with only one solution. For example, 2 3 x + = 8 is a 
linear equation with one variable; calculate the value of x.
TABLE 1.2
Differences between Linear and Nonlinear Equations
Linear Equations Nonlinear Equations
The equation has a maximum order of one degree. The equation has the maximum degrees of two or 
more.
A straight line is formed on the graph. The equation forms a curve on the graph.
The general form of linear equation is y m= +x c
where x any y are the variables, m is the slope of 
The general form of nonlinear equations is 2 2 ax + by = c where x and y are the variables and 
the line, and c is a constant value. a, b, and c are the constant values.
TABLE 1.1
Examples of Linear and Nonlinear Equations 
Linear Equations Nonlinear Equations
y = 8x − 9 2 y x = − 7
y + 3x = 1 y x + = 6
y x + = 7 2 y x − = 96 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solution
The equation is organized as follows by putting the variable x on one side
2 8 x = − 3
Divide both sides of two
8 3 − x = = 2.5
2
Example 1.2 Linear Equation of One Variable
Solve the linear equation in one variable:
3   x + =  6   18
Solution
To solve the given equation, we put the numbers on the right side of the equation 
and keep the variable on the left side. This means:
3   x = −  18   6
Then, when we find the value of x, we get
3   x = 12
Finally, the value of x:
12 x    = =   4
3
Example 1.3 Sum of Two Numbers
The sum of the two numbers is 44. Find the numbers by forming a linear equation 
if one number is ten times more than the other.
Solution
Suppose the number is x, so the other is x    + 10.
We know that the sum of both numbers is 44.
Therefore, the linear equation can be outlined as follows:
x    + + ( ) x  10  = 44Introduction 7
The result is
2   x = −  44 10
Simplifying the right-hand side,
2   x = 34
so the value of x is 17.
This means that one of the numbers is 17, and the other is 17 + 10 = 27.
1.3.2 NoNlINear algebraIc equatIoNs
Nonlinear algebraic equations involve multiple variables; an equation includes non￾linear terms such as polynomials of degree 2 or more, exponential, logarithm, or 
other terms. All other types of equations where f ( ) x = 0, when f ( ) x is not a linear 
function of x, are called nonlinear. A typical way to learn about a nonlinear equation 
is to note that x is ‘not alone’ as in ax, but shares a product with itself, as in
x3 2
    + − 2   x 9 = 0 (1.3)
We can see that x3
 and 2x 2
 are nonlinear terms
Example 1.4 System of linear Equation
Solve the following system of linear equations
3 6 x y + = 12
5x y − = 8 2
Solution
From the first equation,
3 1 x y = −2 6 →→ x y = −4 2
Substitute x in the second equation
5( ) 4 2 − − y y 8 2 =
Simplify
20 − − 10y y 8 2 =
Rearrange
18y = 188 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Divide both sides by 18 to get: y = 1
Substitute y = 1 in the first equation: 3 6 x y + = 12
3 6 x + = ( ) 1 12
Hence: x = 2
Example 1.5 System of Linear and Nonlinear Equation
Solve the system of equations by substitution
3 2 x y − = −
2 0 x y 2 − =
Solution
Rearrange y as a function of x
y x = + 3 2
Substitute y in the second equation
2 3 x x 2 − − 2 0 =
The value of x
− − b b ∓ 2 4ac 3 3 ∓ 2 − − ( ) 4 2( )( ) 2 3 2 ∓ 5 x = = = 2a ( ) 2 2( ) 4
 1   1  x = − , 2    , y =  , 8  2   2 
Example 1.6 Application of Nonlinear Algebraic equations
The hydrolysis of acetic anhydride forms acetic acid took place in a continuously 
stirred tank reactor (V= 1250 L). The species concentration of feed to the reactor is 
2.5 mol/L of acetic anhydride and 50 mol/L of water. The feed flow rate is 15 L/s 
(Figure 1.1). The reaction
(CH3CO)2 O + H O2 3 ↔ 2CH COOH
The reaction rate is first in acetic anhydride and first in the water. The reaction rate 
constant is 0.075 L/(mol s). Derive the nonlinear equations. Introduction 9
Solution
Putting the reaction in symbolic form
(CH3CO)2 O + H O2 3 ↔ 2CH COOH
A W+ = 2B
The rate of reaction is first order in A and W, hence
r k A A = − C CW
Component mole balance on A
F F Ao − +A A R V = 0
Substitute the rate of reaction
v Co Ao o − − v CA A kC C VW = 0
Component mole balance on W
F F Ao − +A A R V = 0
Substitute the rate of reaction
v Co Wo o − − v CW A kC C VW = 0
The given data are
L L mol mol v k 0 = = 15  ,  0.0025  , V C = = 1250  , L s ( ) mol s Ao 2.5  ,  C = 50 
L wo L
FIGURE 1.1 Schematic of the continuous stirred tank reactor (CSTR).10 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The following two nonlinear algebraic equations are to be solved simultaneously
v Co Ao o − − v CA A kC C VW = 0
v Co Wo o − − v CW A kC C VW = 0
After the substitution of the known data, there are two unknown variables ( , C CA W )
and two equations. The unknown can be found by the substitution method.
 L  mol  L  L  15   2.5  − 15  C C A A −  0.0075  C ( )        W 1250  0 L = s L  s mol s
 L  mol  L  L  15   50  − 15  C C W A −  0.0075  C ( )   0 =  s        W 1250 L
L s mol s
Divide both sides by 15
 mol  2.5  − − C C A A ( ) 29.6875 CW = 0  L 
 mol  50  − − C C W A ( ) 29.6875   0 C   W = L
Subtract the first equation from the second one
C C A W − + 47.5 = 0
C C W A = + 47.5
Substitute Cw in the first equation
 mol  2.5  − − C C A A ( ) 0.625 ( ) CA + = 47.5 0  L 
Simplify
2.5 − − C C 0.625 2 A A − = 29.6875CA 0
Simplify further
2.5 − − 0.625C C 2
A A 30.6875 = 0
Solving the quadratic equation, the concentration of A and W are:
mol CA = 0.081 
L
mol Cw = 47.6 
LIntroduction 11
Example 1.7 Using Numerical Integration
The elementary gas phase reaction occurs in a plug flow reactor (PFR) at constant 
temperature and pressure.
A B + → 2C
The total inlet concentration is 0.5 mol/L. The feed is equal molar in A and B. The 
inlet molar rate of A is 5.0 mol/s. The reaction rate constant is k= 0.1 L/mol/s. Find 
the volume of the PFR to achieve 90% conversion of A.
Solution
This is a reactor design example where the design equation of the PFR for the gas 
phase is to be used.
0.9
dx V = FAo ∫ −rA 0
The rate law is elementary, and hence
−r k A A = C CB
Putting CA and CB as a function of x using the stoichiometric table
F C A
A = v
where FA is the molar flow rate of A, v is the volumetric flow rate. For gas phase,
 = + ( ) P v v 0   T  0 1 ε x    P     To 
where ε = yA0δ , δ = −2 1− =1 0, under isothermal and isobaric reaction conditions,
0
FA = − F x 0 1 v A ( )
CA = = − C x 1 v 1 0 Ao ( ) ( ) +
The rate law is as follows,
−r kC x 2
0 1 2
A A = − ( )
Combining the rate law with the design equation,
0.9
F V A0 dx = 2 kC 0 1   x 2
A ∫
0 ( ) −12 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Analytical integration,
∫
x1
dx x1
1   x 2 = 1 x1 0 ( ) − −
Substitution of known values.
0.
F 1 5 0.9 V = A0
∫
9
dx FA0 x
kC2 ( ) 1   − x 2 = 8780.45
kC2 = 0 0 1 x1 0.082 * 2 = L A A −   0.5 1 0.9 0 ( ) 0.5 −
The integral can also be found using numerical integration techniques in later 
chapters.
Example 1. 8 Liquid Reaction in Continuous Stirred Tank Reactor
The liquid phase reaction
A B + → C
Occurs in 1m3
 continuous stirred tank reactor (CSTR) reactor. The rate law of this 
reaction is r k A A = − C , if k s = −1
, CAo = 0.02 mol/L in an inert. The inlet volumetric 
flow rate is 10.0 L/s.
What is the conversion of A under steady-state conditions at 350°K and 5 atm? 
The ideal gas law R= 0.0821 L·atm/mol/K.
Solution
The question is a reactor design problem, where the single pass conversion of a 
liquid phase reaction in a CSTR reactor is required (required knowledge in reactor 
design).
F X VCSTR = Ao
−rA
The rate of reaction is first order, the liquid concentration of A in terms of x
C C A A = − o ( ) 1 X
Combining
( ) F X V = Ao
CSTR kCAo ( ) 1− X
Rearranging to solve for X
( ) V k CSTR × CA0 0 V k × CA V k × X = CSTR = CSTR = FAo v Co Ao o v 1− XIntroduction 13
Substitution of known values
 1 3 1 liter m 1000  × 0.005 s
−
 m3  X = liter 1− X 10 s
Simplifying
 1 3 1 liter m 1000  × 0.005 s
−
 m3  X = = 0.5 liter 1− X 10 s
Solving for X
0.5 1 X = = 1.5 3
1.4 ORDINARY DIFFERENTIAL EQUATIONS
The ordinary differential equation (ODE) is helpful for students in engineering and 
physics because they will need the concepts to follow derivations and homework 
problems in their major courses in mass transfer, heat transfer, and many more. The 
ODE is an equation that involves some ordinary derivatives of a function. Differential 
equations require a solid understanding of previous calculus and algebraic manipu￾lation concepts. Differential equations are not easy, and they acquire knowledge in 
familiar and unfamiliar contexts. ODE equations are used in many models to deter￾mine how the state of that model changes (concerning time or another variable). 
Thus, explanatory equations are essential for many scientific fields because they arise 
whenever a relationship is given to changing a model/system. Differential equations 
involve derivatives of one or more functions.
dy = + 6 1 x (1.4) dx
dy 3
+ =y x 2
 (1.5) dx x
d y3
3 = 64 x (1.6) dx
d y2 dy 2 − − 2 3y = 0 (1.7) dx dx14 Numerical Methods in Chemical Engineering Using Python® and Simulink®
1.4.1 order of dIffereNtIal equatIoN
The order of a differential equation is the highest order of derivatives present in the 
equation.
First order:
dy + = 2 s y x in (1.8) dx
 dy 
2
  = 4x (1.9)  dx 
Second order:
d y2
2 + = 4xy ex
 (1.10) dx
Third order:
d y3 d y2 dy 3 − + 6 9 2 = 0 (1.11) dx dx dx
Example 1.9 Generation of First ODE
Consider the following simple series of reactions taking place in a batch reactor
→
k1
A B
k2
B C →
Assuming that the reaction rate is first order concerning A and B, derive the con￾centration change of components A, B, and C with time.
r k 1 1 = CA
r k 2 2 = CB
Solution
The complete set of differential equations for a well-mixed batch reactor are as 
follows:
dCA = −r k
dt 1 1 = − CA
dCB = − r r dt 1 2 = − k C1 2 A B k C
dCc = = r k 3 2CB dtIntroduction 15
1.4.2 aNalytIcal solutIoN of fIrst-order dIffereNtIal equatIoN
Often the goal is to solve the ODE equation, that is, to determine a function or many 
functions that fulfill the equation. Consider the following first-order ODE:
dy = 5  y (1.12) dx
The exact solution can be found as follows:
Rearrange the equation as follows
dy = 5dx (1.13)
y
Integrating
ln( ) y x = 5 (1.14)
The general solution is
y e = 5x
 (1.15)
The general solution of
dy = 2x (1.16) dx
is
y x = +2 c (1.17)
The particular solution of
dy = = 2x y ,   ( ) 1 4 (1.18) dx
is
y x = +2 c (1.19)
Using the initial conditions to find c, when x = 1, y = 4 (initial conditions)
4 = + ( ) 1 2 c (1.20)16 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solving for c, c = 3. Accordingly, the general solution
y x = +2 3 (1.21)
Example 1.10 Derive the Differential Equations for a Mixing Tank
A liquid level system where liquid enters a cylindrical tank at the rate of Ff and 
leaves at a rate Fo. The mathematical model for the system is a differential equa￾tion that shows the relationship between the height (h) of the liquid and the input 
flow rate. The surface area of the bottom of the cylindrical tank is A (Figure 1.2). 
Develop the differential equation.
Solution
Applying the unsteady state material balance around the tank,
dm = − m m . . f o dt
In terms of flow rate, assuming constant density,
d V ( ) ρ = − ρ ρ F F f o dt
Simplify and replace V with Ah. The following ODE is generated:
dh A = − F F f o dt
FIGURE 1.2 Schematic diagram of stirred tank.Introduction 17
Example 1.11 The Concentration of Salt in a Tank
Purified water flows into a tank at a rate of 10 L/min. The contents of the tank are 
well mixed; they flow out at a rate of 10 L/min. Add salt to the tank at the rate of 
0.1 kg/min. Initially, the tank contains 10 kg of salt in 100 L of water. The volume of 
the tank is 100 L. How much salt is in the tank after 30 minutes?
Solution
Here, the setup is very similar to the previous example. The only difference from 
the previous one is adding 0.1 kg/min salt to the tank. As a result, we can modify 
the differential equation to consider this. Let the concentration of salt in the tank, Cs
Total material balance,
d V( ) Cs = +0 0.1−C Fs f dt
Simplify
(100 liter)
dCs kg kg liter = − 0.1 Cs × 10
dt min liter min
Rearrange
dCs s 0.1 C   1( ) 0 = − dt 100 100
The generated ODE is
dCs = − 0.001 0.1Cs dt
The initial condition is at time = 0, and the concentration of salt is
( ) 10 kg salt kg Cs 0 = = 0.1
100 liter water liter
Integrating the generated to ODE
C t 0.01 0.09e 0.1t s ( ) = + −
The concentration of salt in the tank after 30 min
C t 0.01 0.09e 0.1 30 s ( ) = + − ( )
kg C t s ( ) = 0.01448
liter
The amount of salt
kg ms s = × 100    liter   3 C ( ) 0 = × 0.01448  100 liter k = 1.448  g liter18 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Example 1.12 Mixing Tank with Variable Volume
Pure water flows into a tank at 12 L/min. The tank’s contents are thoroughly mixed 
and flow out at 10.0 L/min. Initially, the tank contains 10 kg of salt in 100 L of water. 
Develop the model ODE equation and then calculate the amount of salt in the 
tank after 30 min.
Solution
The inlet flow rate is greater than the outflow rate. As a result, size is not constant. 
Using the initial conditions and flow rates, we can say that the volume V of liquid 
in the tank is
V = + V v 0 o t t = + 100 ( ) 12 − = 10 100 + 2t
Total component balance (salt)
d C( ) sV = − F F f o ( ) 0 Cs dt
Since the volume varied with time
dC dV V s + = Cs o −F Cs dt dt
Overall mass balance at constant density
dV = − F F f o dt
Replace dV d/ t with F F f o −
dC V s + − C F s f F F o oCs dt ( ) = −
Rearrange
( dC V v o o + = t) s − − F Co s C Fs f + F Co s dt
Simplify further
( dC V v o o + = t) s −C Fs f dt
Rearrange
dCs  dt  = −F
C f  s  ( ) V v o o + t 

Using separable integration
( )  F V ln l C f   s = −  n o  + t C  +  v v 1
o   o Introduction 19
Substitute known values to find C1
C1 = 21.169
( )  12  100  ln 0.1 = −  ln + 0 +C  2   2  1
The concentration of salt at any time
( )  F V ln l C f   s = −  n o  + t + 21.169  vo   vo 
After 30 min, the salt concentration
( )  12  100  ln Cs = −  ln + 30 + 21.169  2   2 
The concentration after 30 min
kg Cs = 0.00596
liter
The amount of salt in 30 min
kg Cs = × 0.00596 100 liter k = 0.596  g liter
1.5 BOUNDARY VALUE PROBLEMS
A boundary value problem (BVP) is a system of ODEs with solutions and derivative 
values defined at more than one point. The solution and derivatives are defined at 
only two points (the boundaries), a two-point BVP. A differential equation with given 
conditions allows us to find the specific function that satisfies a given differential 
equation, rather than a family of functions. These types of problems are called initial 
value problems (IVP). If the provided conditions are at more than one point and the 
differential equation is of order two or higher, it is called a BVP. This section aims 
to give a brief look at the idea of BVPs and to give enough information to allow us 
to do some basic partial differential equations in the next chapter. With BVPs, we 
will have a differential equation and define the function and derivatives at different 
points, which we will call boundary values. The following systems represent BVPs 
frequently found in chemical engineering (Figure 1.3).
An essential problem in chemical engineering is the prediction of diffusion and 
reaction in a porous catalyst pellet. The goal is to predict the overall reaction rate of 
the catalyst pellet. The conservation of mass in a spherical coordinate provides
 1 d  D 2 dc  r 2 r  = R  dr  dr (1.22) 
with the following boundary condition20 Numerical Methods in Chemical Engineering Using Python® and Simulink®
dc
at  0 r = = ,  0 (Axial symmetry about the origin) dr
at r r = = p A ,   c c s (Concentration at the catalyst surface)
where D is the diffusivity, r is the radial coordinate, c is the concentration of a given 
chemical species, and R is the reaction rate function. Consider a cylindrical porous 
solid catalyst particle of radius R and length L, as shown in Figure 1.4.
Assuming the catalyst has a sizeable length-to-diameter ratio ( 2 L R >> ), the dif￾fusion of substance A is mainly in the r-direction. Substance A undergoes a first￾order decomposition reaction
A B → = , r k A A − C
CA is the local molar concentration of A in the catalyst, and k is the first-order rate 
constant. Considering molecular diffusion and neglecting bulk diffusion. Assuming 
isothermal operation, the A concentration at the catalyst’s surface is constant and 
equal to CAS. The following differential equation governs the steady-state equation 
mass balance on cylindrical coordinates considering the given assumptions
1 d  dC rD A 
 − = kC 0
r dr  dr  A (1.23)
FIGURE 1.3 Reaction in spherical porous catalyst.Introduction 21
The relevant boundary conditions are
dC
at  0 r = = ,   A 0 (1.24) dr
Heat transfer is an essential subject in engineering. Fins are frequently used in heat￾ing houses, cars, and industry.
Figure 1.5 shows a fin used in heat transfer to increase the surface area available 
for heat transfer between metal walls and poorly conductive fluids such as gases. 
A simple and practical application of thermal conductivity is a calculation-efficient 
cooling fin. Assuming L B >> , the fin will not lose heat from the end of the edges; 
the heat flows to the surface by the temperature profile in the fin. In which h is the 
constant convective heat transfer coefficient as is the surrounding fluid temperature 
Ta, then the governing differential equation is
d T2 hA h W   2( ) L h k 2 = − ( ) T Ta a = − ( ) T T = − ( ) T T (1.25) dz V 2BWL B a
where k is the thermal conductivity of the fin, and the boundary conditions are
at  0 z T = = ,      ( ) 0 Tw
 (1.26)
Example 1.13 Boundary Value Problems
Find a solution to the BVP
d y2
2 − =y y 0;      ( ) 0 0 = = ,  y( ) 1 1
dx
Consider a general solution to the differential equation
y x( ) = + c ex x 1 2 c e−
FIGURE 1.4 Porous cylindrical porous solid catalyst.22 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solution
The characteristic equation is
m2 − =1 0,   m∓ = ∓1
The general solution is
y x( ) = + c ex x 1 2 c e
Using the boundary condition 1,
y c ( ) 0 0 = = 0 0 1e c + = 2e c − 1 2 + c
Simplifying,
0 = + c c 1 2
Using boundary condition,
y c ( ) 1 1 = = 1 1 1e c + 2e−
Simplify
c 1 = + c e 2
1 e
Substitute c1 2 = −c
c 1 = −c e 2
2 + e
Rearrange
FIGURE 1.5 Schematic of a heating fin [1].Introduction 23
 1 1   − e2  1 = − c2 2  e c  =  e  
 e 

 e  c2 = 
 1− e2 

Then
 −e  c1 2 = −c = 
 1− e2 

The final solution
( )  −e  e y x = 
1 1 e2 2  ex x   +   e−
 −   − e 
Example 1.14 Boundary Value Problem
Consider the following second-order BVP
d y2 dy π 2 + = 4 0 y y ,   ( )   0 1 = ,   = 2
dx dx  2 
If the general solution of the differential equation is
y x( ) = + c x 1 2 cos 2( ) c x sin 2( )
Using the boundary conditions, find the expression for c1 and c2
Solution
The characteristic polynomial
p m( ) = + m m 2 4 0 = →  2 ∓ = ∓ i
The general solution
y x( ) = + c x 1 2 cos 2( ) c x sin 2( )
Substitution of boundary condition 1
y c ( ) 0 1 = = 1 2 cos 0( )+ c sin 0( )
Hence,
1 0 = + c c 1 1 => = 124 Numerical Methods in Chemical Engineering Using Python® and Simulink®
To substitute boundary condition 2, first, differentiate the proposed solution 
equation
y c ′
( ) x = −2 s1 2 in( ) 2 2 x c + cos 2( ) x
Substitution of boundary condition 2
 π   π   π  y c ′  = = 2 2− × sin 2   2  + × c cos 2   2  1 2  2   2 
Simplify
 π  y c ′  = = 2 2− π sin 2 cos 0 2
2 1 2 ( )+ π c c ( ) = −   2
Accordingly,
c2 = −1
Substitution of c1 and c2
y x( ) = + ( ) 1 cos( ) 2 1 x x ( ) − = sin 2( ) cos 2( ) x x − sin 2( )
Example 1.15 Unsteady State Mass Transfer in a Tubular Liquid Flow
Develop the unsteady state BVP model equation for the diffusion of a laminar flow 
liquid solute A into water. Starting with the following equation of change,
∂CA + ∇ v C . D C2 z A = ∇ A + r ∂t
Solution
The schematic diagram is shown in Figure 1.6
Consider the following assumptions:
FIGURE 1.6 Schematic of the unsteady state mass transfer in a tubular liquid flow.Introduction 25
1. Steady-state operation.
2. No reaction ( 0 r = ). 
3. Neglect the diffusion in the radial direction.
4. Neglect velocity in the r-direction.
5. Laminar flow ( 2100) NRe < , the parabolic velocity profile.
  r 
2  v v z o = − 2 1     R 

Starting with the equation change
∂CA + ∇ v C . D C2 z A = ∇ A A + r ∂t
Expand the equation
∂C   r 2  ∂C 2 A  A ∂CA A  ∂ C 1 ∂  ∂C  + − 2 1 vo    +  vr = D 2 +  r A
 + r ∂t   R  ∂z ∂r  ∂z r ∂z  ∂r 
 A
Initial conditions
t = = 0,  CA 0
Boundary conditions
z = = 0    C C A Ao
Assuming a very long tube,
∂C
z = L,      A = 0 ∂z
Symmetric condition at the center
∂C r = 0,   A = 0    ∂r
Non-reactive wall
∂C r R = − ,   A = 0      ∂r
The equation can be simplified based on the given assumption
  r 
2  ∂C  ∂2
C  0 2 + − v 1 0   A A
o + = D 2 + 0   R 
 ∂z 
 ∂z 
26 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The equation is simplified to
 r 2  ∂C 2
C 2 1 v A A ∂ o −  2 − D 2 = 0  R 
 ∂z ∂z
Example 1.16 Flow Through the Circular Tube 
Using the Navier-Stokes Equation
The Navier-Stokes equation can be used in problems where the pseudo-momen￾tum equilibrium method was initially used. For this problem, assume the pressure 
decreases linearly with length. Also, suppose that density and viscosity are con￾stant. The Navier-Stokes equation can be written in the z-direction as
 ∂vz ∂vz z vθ ∂v ∂vz z  ∂P  1 ∂  ∂v  1 ∂2
v v ∂2  ρ  + v + + v      = − + µ r  + z z + + ρg  ∂t r ∂r r ∂θ z ∂z  ∂z r 
 ∂r  ∂r r  2 θ2 ∂z2  ∂  z
It is better to use cylindrical coordinates here and velocity in the z-direction only. 
The continuity equation is equivalent to the following, assuming constant ρ and 
µ. The ρg is not necessary because gravity does not play a role. The schematic 
diagram is shown in Figure 1.7.
Solution
Based on the steady-state assumptions, the Navier-Stokes equation in the z-direc￾tion is simplified to the following:
∂P 1 ∂  ∂v = µ r z    ∂z r ∂r  ∂r 
Since the pressure gradient is linear
P P L o − d  dv r = r z 
 µL dr  dr 
Perform the first integration
dv P P r 2 z L  − o    c = − + 1
dr 
 2µL     r 
 r
FIGURE 1.7 Schematic diagram of water flow in a pipe.Introduction 27
Integrating the above equation,
 P P v L o − 
r c 2 z = − − +  4 L  1 2 lnr c  µ 
Boundary conditions 1
dv
at r = = 0, z 0
dr
Applying boundary condition 1 in the following equation,
dv P P r 2 z L  − o    c = − + 1
dr 
 2µL     r 
 r
Substitute the boundary condition
 P P 0 c 0 = − L o −    1

 2µL r    +    r
Accordingly,
c1 = 0
at r R = = 1, 0 vz since it is at a solid–liquid boundary
P P L o − R c 2 = 4µL 2
Substitution of c1 and c2
 P P v L o − 
r 2 2 P P L o − z = − +  R  4 4 µ µ L 
 L
Rearrange
 P P v L o −  R r 2 2 z = 
 4µL 

( ) −
Reposition again
( ) P P R2 r 2
v o L −     z = 1−    4µL   R 

 P P 2
v L o −  2  r   z =   R     1−     4µL   R 
or28 Numerical Methods in Chemical Engineering Using Python® and Simulink®
1.6 SUMMARY
Numerical methods is a discipline in mathematics concerned with the development 
of effective methods for obtaining numerical solutions to mathematical problems that 
are difficult to solve by analytical methods. This chapter deals with possible equa￾tions that may appear in many topics of chemistry or other engineering subjects that 
need to be solved by numerical methods. Linear and nonlinear algebraic equations 
may appear in material and energy balances, mass transfer, heat transfer, and ordi￾nary and partial differential equality in modeling and simulation.
1.7 PROBLEMS
1. Solve the following LAE
x + = 7 12
Find the value of x
Answer: x = 5
2. Solve the following system of LAEs
2 6
4
x y
x y
+ =
+ =
Find the value of x, y
Answer: (x = 2, y = 2)
3. A system of nonlinear equations consists of two or more equations with at 
least one equation that is not linear
25
3 4 0
2 2 x y
x y
+ =
+ =
Find the value of x, y
Answer: (x = 4, y = –3)
4. Solve the system of two nonlinear equations
45
27
2 2
2 2
x y
x y
+ =
− = −
Find the value of x, y
Answer: ( 3 x y = = ,  6)
5. Pure water flows into a tank at a rate of 10 L/min. The contents of the tank 
are preserved and mixed well. The contents flow out at a rate of 10 L/min. 
Initially, the tank contained 10kg of salt in 100L of water. How much salt 
will there be in the tank after 30 minutes?
Answer: 0.5Introduction 29
 6. Pure water flows into a tank at a rate of 8 L/min. The contents of the tank are 
Answer: 0.0248
7. Water with salt dissolved at a specified concentration of 0.1 kg/L, flowing 
into a tank at a rate of 10 L/min. The contents of the tank are well mixed, 
and the contents flow out at a rate of 10 L/min. Initially, the tank contained 
10 kg of salt in 100 L of water. How much salt will there be in the tank after 
30 minutes?
Answer: 0.0248
8. Water with salt dissolved at a specified concentration of 0.1 kg/L, flowing 
into a tank at a rate of 10 L/min. The contents of the tank are well mixed, 
and the contents flow out at 12 L/min. Initially, the tank contained 10 kg 
of salt in 100 L of water. How much salt will there be in the tank after 30 
minutes?
Answer: 0.099
9. Write the ODE of the following two simple series reactions taking place in 
a batch reactor
k k 1 2
A B → → C
Write the complete set of the differential equation for a well-mixed batch 
reactor.
 10. Solve the following BVP
d y2
2 + = 2 0 y y ,   ( ) 0 1 = = ,   y( ) π 1
dx
Answer:
= − ( ) cos 2t
y t cos 2 ( ) sin 2t
sin 2 ( )t ( )
REFERENCE
1. Ghasem, N., 2019. Modeling and Simulation of Chemical Process Systems, New York: 
CRC Press.31
2 Numerical Solutions 
of Linear Systems
Numerical methods can solve systems of linear equations. Generally, they are divided 
into two categories: direct methods, which lead to the exact solution within a limited 
number of steps, such as the Gaussian elimination method, and indirect methods. 
Indirect methods (iterative methods) are valuable for problems involving massive 
private arrays, such as Jacobi and Gauss-Seidel. This chapter focuses on linear alge￾braic equations and how to solve them using different methods such as Cramer’s rule, 
Gauss elimination method, and Gauss-Jordan, Jacobi, and Gauss-Seidel elimination 
methods.
LEARNING OBJECTIVES
 1. Identify the linear algebraic equation.
2. Find the determinant of 2 × 2 and 3 × 3 matrices.
 3. Use Cramer’s rule to solve systems of two and three equations.
 4. Use Gauss and Gauss-Jordan elimination methods.
 5. Apply Jacobi and Gauss-Seidel iterative methods.
6. Make use of Simulink and Python to solve linear algebraic equations.
2.1 INTRODUCTION
A system of linear equations is a collection of linear equations that are independent 
of one another, and we cannot derive one equation from another. An equation is lin￾ear if each term is simply a constant or a constant multiplied by a variable. If we ever 
have a variable multiplied by another variable or a variable to the power of anything, 
then the equation is not linear. Solving a system of linear equations means finding a 
value for each unknown variable. There is sometimes more than one solution to a set 
of linear equations; the complete set of solutions is called the solution set.
The linear system of equations ax b = can be solved using various numerical 
methods. A numerical method is a mathematical tool designed to solve numerical 
problems in natural and social sciences, engineering, medicine, and business. The 
following sections explain the system of linear algebraic equations and the appropri￾ate methods for numerical solutions [1].
2.1.1 defINItIoN of a lINear system of algebraIc equatIoNs
A linear equation is an equation that is linear about its variables, such as 3 7 x = . We 
can also have a linear equation with more than one variable, such as 2 3 x y + = 9.
DOI: 10.1201/9781003360544-232 Numerical Methods in Chemical Engineering Using Python® and Simulink®
A linear algebraic equation is one in which the highest power of the variables is 
always 1. The standard form of a linear algebraic equation is one variable of the form
ax b + = 0
where a and b are constants, x is a variable, a is a coefficient of the variable x, and b
is a constant. A system of linear equations is a collection of more than one equation. 
The system of n linear algebraic equation is as follows:
a11X a 1 1 + + 2 2 X a … +       1 1 n n X b =
a21X a 1 2 + + 2 2 X a … +       2 2 n n X b =
am n 1 1 X a + + 2 2 X a … +       mn X b n m =
where m is the number of rows and n is the number of columns. Here m is the number 
of independent equations to solve n number of variables. In a matrix structure,
AX = b
where A is the coefficient matrix:
 a a 11 12…… a  1n 
  a a 21 22…… a2n   a a mn m m 2…… a  n 

 X  1 
 The X matrix is  X2   X  n 

 b  1 
 The b matrix is  b2   b  m 

In general, a matrix has 𝑛×𝑚 elements. If n = m, there may be a unique solution, 
and the rank of the matrix is m. Consider the following matrix, A
The determinant, A
A a = − d bc
The following are two linear algebraic equations:
2 3 x y + = 5
x − =y 4Numerical Solutions of Linear Systems 33
A 2 × 2 matrix represents the equations as follows:
 2 3   x   5  A X =  , , =   b = 1 1 y    −     4 
The following three algebraic equations represent an example of a 3 3 × matrix:
2 3 x y + + 2 7 z =
3 3 x y + − 2 4 z =
x + −y z = 5
The coefficients exist in the following matrix:
 2 3 2    A = − 1 1 1  
3 3 −2 
 

The X and b matrices are as follows:
 x   7      X =  y , b = 5    z  4   
 

2.1.2 ProPertIes of a matrIx aNd oPeratIoN
The matrix properties can exist as
• Symmetric matrix, 𝑎𝑖𝑗 = 𝑎𝑗 𝑖
• A square matrix, n m     =
• Diagonal matrix, 0
0








...
... (only diagonal elements)
The possible operations:
Summation:
[ ] A B m n× = + [ ]m n× [ ] C m n×
Multiplication (rules):
[ ] A B m n× × = [ ]n l × [ ] C m l ×
Therefore, multiplication is not permissible for
[ ] B A nl × ≠ [ ]mn       for l     m34 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The following multiplications are permissible:
 5 1     −3 0  3 2 ×     1 0  0 3      2 2×
3 2×
 5 1     1 2 3  3 2 ×     4 5 6  0 3      2 3×
3 2×
 0     1 2 3  × 5  1 3×  
4 
 

3 1×
The following multiplications are not permissible:
5 1 0 1 3     3 2 × 4 5 6      0 3   7 8 9   3 2× ×  3 3
 5 1   1 2      3 2 × 4 5      0 3  8 7  3 2 
 
 × 3 2×
   
  1  1 2 3  ×  1 3×    2 2 1×
= × ∑
k
Rule C a ij ik bkj
1
For example, the permissible multiplications of the following two matrices:
  5 3 5 1  ( ) × +1 1 × × ( ) 5 0 + ×1 5 
   3 0   
3 2 ×       =  ( ) 3 3 × + 2 1 × ×   ( ) 3 0 + ×2 5  1 5 0 3   ×      2 2  3 2× ( ) 0 0 × + 3 1 0 0 + ×3 5 
 × × ( ) 

3 2×
2.1.3 INverse of matrIx [a]–1
The I is the identity matrix
I = × [ ] A A 1
m n× × [ ]−
n mNumerical Solutions of Linear Systems 35
The I is the identity matrix
 100    I ≡ 010  
001 
 

Consider the following matrix A:
 a a
A =  11 12 

a a  21 22 
The inverse of A matrix, [ ] A −1
−  − [ ] a a
A 1 1 =  22 12 
 A −a a  21 11 
where the determinant, A
A a = − ( 11×a a 22 12 × a21 )
where the value of A should not be equal to zero; otherwise, the matrix A is con￾sidered singular.
2.1.4 traNsPose a matrIx
Matrix transposition is obtained by interchanging its rows into columns or columns 
into rows. The transpose of a matrix is denoted by using the letter ‘T’ in the super￾script of the given matrix. For example, if A is the given matrix, then the transposi￾tion of the matrix A is represented by AT
. Consider the following matrix, A:
 a a
A 11 12......a =  1n 

a a 21 22 a  ...... mn 
The transpose matrix [ ] A T
 is the interchange of rows with columns, as shown below:
 [ ]T a a
A 11 21......a =  m1 

a a 1n m      ......... n n m×
For example,
 a  1 

[ ] a A =  2   ...    a  n n×136 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The transpose matrix is
[ ] A a T = …  1 2 a a  n 
1×n
2.2 CRAMER’S RULE
Cramer’s rule is a method that uses determinants to solve linear algebraic equations 
systems with the same number of equations as variables. Cramer’s rule generally 
works well for a small matrix, and Cramer’s rule replaces a variable column with a 
regular column.
A
X j
j = A
[ ] A X[ ] = [ ] b
where Aj is determined by replacing the jth column of A by b in a case of an algebraic 
equation in the form of the following sections.
2.2.1 solvINg tWo lINear equatIoNs usINg cramer’s rule
An example of two linear equations of two variables as follows:
ax b + =y e
cx d + =y f
If we solve for x, the x column is replaced with the column of constants (e, f) on the 
right-hand side of the equations. Using Cramer’s rule, the solution for x is given as 
follows in which D ≠ 0:
 e b   
D f d ed fb x = = x   − = D  a b  ad − cb
   c d 
If we are solving for y, replace the y column with the constant,
 a e   
D c f af ce
y = = y   − = D  a b  ad − cb
   c d Numerical Solutions of Linear Systems 37
2.2.2 solvINg three lINear equatIoNs usINg cramer’s rule
Consider a system of three linear equations to be solved using Cramer’s rule.
a1 1 x b + +y c1 1 z d =
a2 2 x b + +y c2 2 z d =
a3 3 x b + +y c3 3 z d =
The solution is
= = D D D
x x , , y y z = ≠ z , 0 where D
D D D
Putting the equations in a matrix format,
 a b 1 1 c  1 
 D =  a b 2 2 c2 , D ≠ 0
 a b 3 3 c  3 

Then,
d b 1 1 c1 a d 1 1 c1 a b 1 1 d1
Dx y = = d b 2 2 c2 , , D a d 2 2 c2 Dz = a b 2 2 d2
d b 3 3 c3 a d 3 3 c3 a b 3 3 d3
The equations should be independent, and the determinant should not equal zero. For 
example, the following two equations are not independent.
2 3 x x 1 2 + = 11
4x x 1 2 + = 6 22
We know that by checking if the matrix is independent ( 0 A ≠ ) or not independent 
( 0 A = ).
 2 3  A =   = ×263 − × 4 0 =
 4 6 2 2×
Accordingly, the two equations are not independent. There is no unique solution, and 
the matrix coefficient is singular; a zero determinant means that either the system has 
no solution or an infinite number of solutions.38 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Example 2.1 I mplication of Cramer’s Rule for 
Linear Algebraic Equations
Solve the following two linear algebraic equations manually using Cramer’s rule.
2 3 x x 1 2 + = 11
x1 2 + = x 4
Verify the manual calculation with Simulink and Python programming of Cramer’s 
rule.
Solution
First, we must check the singularity of the equation by finding the determinant.
Put the equations into matrix format.
 2 3   11  A b =  , =    1 1   4 
The determinant of A,
A = × ( ) 2 1 − × ( ) 3 1 = −1
The two algebraic equations are independent, and there is a unique solution. To 
find the unknown values, use Cramer’s rule:
 11 3  Ax =   = − 11 12 = −1
 4 1 
 2 11  Ay =   = −8 11 3 = −
 1 4 
Accordingly,
A 1 x x
1 = = − = 1
A −1
A 3 x y − 2 = = = 3
A −1
Solution Using the Simulink Algebraic Constraint Block
Two ways can solve the two independent equations using Simulink’s ‘Algebraic 
Constraint’ block (Figure 2.1a). Figure 2.1a is to write each equation using the avail￾able blocks in Simulink (Gain, Constant, and Sum). By contrast, in Figure 2.1b, the 
matrix coefficients entered the Gain in a vector structure ‘[2 3;1 1]’ and selected Numerical Solutions of Linear Systems 39
from the ‘Multiplication’ pulldown menu ‘Matrix(K*u) (u vector)’. Then double 
click on the Constant block and enter the matrix constants such as ‘[11 4]’.
Solution Using the Simulink MATLAB® Function
Figure 2.2 shows the Simulink solution using Cramer’s rule in the form of a 
MATLAB function embedded in the Simulink MATLAB function block available in 
the Simulink library under user-defined functions.
FIGURE 2.1 Simulink solution uses the Simulink algebraic constraint function block to 
solve the equation defined in Example 2.1.
FIGURE 2.2 Simulink solution using Cramer’s rule embedded in the MATLAB function to 
solve the equations stated in Example 2.1.40 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The following program is the MATLAB code describing Cramer’s rule embed￾ded into the MATLAB function.
function Res = Cramer(A, B)
x = ones(2,1);
a_det = det(A);
for i = 1:2
C = A;
C(:, i) = B;
x(i, 1) = det(C)/a_det;
end
Res = x’;
Python Solution
The following program is the Python code that employs Cramer’s rule to solve the 
two algebraic equations presented in Example 2.1.
# Example 2.1
# Calculating the determinant
from sympy import *
x1,x2 = symbols([‘x1’,‘x2’])
system = [Eq(2*x1 + 3*x2,11),
Eq(x1 + x2,4)]
soln = solve(system,[x1,x2])
print(‘\n the solution:’,soln)
The following are the Python program executed results of Example 2.1.
The solution: {x1: 1, x2: 3}
Example 2.2 Determinant Calculation (3 × 3 Matrix)
Find the determinant of the following matrix manually.
 0 2 1    A = − 3 1 1  
4 0 1 
 

Confirm the manual solution using Simulink and Python programming.
Solution
To find the determinant of the 3 × 3 matrix, first, take the first element of the first 
row and multiply it by a secondary 2 × 2 matrix, which becomes from the elements 
remaining in the 3 × 3 matrix that do not belong to the row or column to which 
your first selected elements belong. Arrange the matrix with the first two columns 
and then follow the formula.
 0 2 1    A = − 3 1 1  
4 0 1 
 

Accordingly,Numerical Solutions of Linear Systems 41
− = ( ) 1 1 3 1 3 1 A 0 − + ( ) 2 ( ) − 1
0 1 4 1 4 0
Simplify
A = +( ) 0 1 
( ) − − ( ) 1 0( )( ) 1 2  − − ( )[(3)( ) 1 4( )( ) 1 1 +( )( ) 3 0( )− − ( ) 4 1 ( )
A = +0 2 + = 4 6
Simulink Solution
The Simulink solution of Example 2.2 is shown in Figure 2.3, followed by the 
embedded MATLAB code implanted in the MATLAB function.
The following program is the MATLAB code embedded in the MATLAB 
function.
function Res = Determinant(A)
x = ones(3);
a_det = det(A);
Res = a_det;
Python Solution
The following Python code is programmed to calculate the determinant of the 
3 × 3 matrix of the three equations presented in Example 2.2.
#Example 2.2
#Calculating the determinant
#importing Numpy package
import numpy as np
FIGURE 2.3 Simulink’s solution using a MATLAB function implanted with MATLAB 
code to find the determinant of the matrix given in Example 2.2. 42 Numerical Methods in Chemical Engineering Using Python® and Simulink®
# creating a 3X3 Numpy matrix
n_array = np.array([[0,2,1],
[3,-1,1],
[4,0,1]])
# calculating the determinant of matrix
det = np.linalg.det(n_array)
print(“\n Determinant of given 3X3 square matrix:”,int(det))
Execution
Determinant of given 3 × 3 square matrix: 6
Example 2.3 Finding the Determinant of the 3 × 3 Matrix
Find the determinant of the following 3 3 × matrix manually and using Simulink and 
Python programming.
 1 3− 7    A = 1 1 1  
1 2− 3 
 

Solution
The determinant is a scalar value equal to the product of the main diagonal ele￾ments minus the product of its counter diagonal elements. The determinant of A
1 3− 7
A = 1 1 1
1 2− 3
Split the matrix as follows:
1 1 1 1 1 1 A = +1 − −( ) 3 1 + + 7 −2 3 1 3 1 2−
A = − 1 1  3 2 1 3 1 3 ( ) ( )( ) ( ) − ( ) 
 − −( )( )( )−( ) 1 1( ) + − 7 1 ( )( ) 2 1 −( )( ) 1  
Simplify
A = + 1 3( ) 2 3 + − ( ) 3 1 + − 7 2 ( ) − = 1 5 + −6 21 1 = − 0
Simulink Solution
Figure 2.4 displays the value of the matrix determinant listed in Example 2.3, solved 
by Simulink, shown in the embedded MATLAB function.
The embedded MATLAB code is implanted into the MATLAB function to find 
the determinant of the matrix defined in Example 2.3.
function Res = Determinant(A)
x = ones(3);
a_det = det(A);
Res = a_det;Numerical Solutions of Linear Systems 43
Python Solution
The Python code for the determinant of the 3 × 3 matrix is programmed below. It 
can solve any 3 × 3 matrix by modifying the array coefficients.
# Example 2.3
#importing Numpy package
import numpy as np
# creating a 3X3 Numpy matrix
n_array = np.array([[1,-3,7],
[1,1,1],
[1,-2,3]])
# calculating the determinant of matrix
det = np.linalg.det(n_array)
print(“\n Determinant of given 3X3 square matrix:”,int(det))
Execution 
Determinant of given 3 X 3 square matrix: -10
Example 2.4 Cramer’s Rule Implementation
Use Cramer’s rule to solve the set of the following linear equation manually.
x + −y z = 6
3 2 x y − + z = −5
x + − 3 2 y z = 14
Confirm the manual calculation with Simulink and Python programming of 
Cramer’s rule.
FIGURE 2.4 Simulink’s solution using the MATLAB function implanted with MATLAB 
code to find the determinant of the matrix given in Example 2.3.44 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solution
Cramer’s rule is a method that uses determinants to solve systems of equations that 
have the same number of equations as variables. First, put the equation in matrix 
format.
 1 1 −1   6      D d = 3 2− 1 , = −5      1 3 −2 
 14  
 

Then, to solve for x, replace the first column with the d column (the constants at 
the right-hand side of the three equations).
 6 1 −1    Dx = − − 5 2 1  
 14 3 2−   
Replace the second column with the d column.
 1 6 −1    Dy = 3 5− 1  
1 14 2− 
 

Replace the third column with the d column.
 1 1 6    Dz = − 3 2 −5  
1 3 14 
 

Find the determinant of the matrix D.
1 1 −1
D = 3 2−   1
1 3 −2
Split the matrix.
− = +( ) 2 1 3 1 3 2 D 1 −( ) 1 + −( ) − 1
3 2− 1 2− 1 3
D = +1 7 − = 11 −3
Augment the matrix with the first two columns and then follow the formula.
6 1 −1
Dx = − − 5 2 1    
14 3 2−Numerical Solutions of Linear Systems 45
Solving for Dx
Dx = − 6 2 ( )( ) − − 2 3( )( ) 1 1  − − ( ) 5 2 ( ) − −( ) 14 ( ) 1 1  − − ( ) 5 3( )− − ( ) 14 ( ) 2 
Dx = +6 4 − = 13   3−
Augment the matrix with the first two columns and then follow the formula.
   1 6 −1
Dy =    3 5− 1   
   1 14 2−
Solving for Dy
Dy = − 1 5 
( )( ) − − 2 1( ) 4 1( )
 − − 6 3 ( )( ) 2 1 −( )( ) 1 1  − − 
( ) 3 1( ) 4 1( )( ) −5 
= −4 4 + −2 47 9 = −
Solving for Dz
1 1 6
Dz = − 3 2 −5
1 3 14
Augment the matrix with the first two columns and then follow the formula.
1 1 6
Dz = − 3 2 −5  
1 3 14
Using Cramer’s Rule, similarly
Dz = 6
Solve for x.
D 3 x = = x − = 1
D −3
Solve for y.
D 9
y = = y − = 3
D −3
Solve for z.
D 6
z = = z = −2
D −346 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Simulink Solution
We are solving the set of linear equations using Simulink and the Algebraic con￾straint’s function built in the Simulink library. The problem can be solved in two 
ways: The first method is constructing each algebraic equation using the basic 
Simulink block diagram using the primary Algebraic constraint function (Figure 2.5a). 
The second method puts the matrix coefficients in the Gain and the constants of the 
algebraic equation in the Simulink Constant block, as shown in Figure 2.5b.
Simulink Using Cramer’s Rule
In linear algebra, Cramer’s Rule is an explicit formula for solving a system of lin￾ear equations with as many equations as unknowns. The rule is valid whenever 
the system has a unique solution. It expresses the solution in terms of the coef￾ficient matrix’s determinants and matrices obtained from it by replacing one col￾umn with the vector of the right-hand sides of the equations. Figure 2.6 shows the 
Simulink solution of Example 2.4 using Cramer’s Rule. The figure is followed by the 
MATLAB code that embeds the Simulink function.
function Res = Cramer(A,B)
x = ones(3,1);
a_det = det(A);
for i = 1:3
C = A;
C(:,i) = B;
x(i,1) = det(C)/a_det;
end
Res = x’;
FIGURE 2.5 Simulink block diagram (a) detailed solution (b) using the gain and constants 
in matrix format to solve the set of equations presented in Example 2.4.Numerical Solutions of Linear Systems 47
Python Solution
The following Python code determines the solution of the three linear algebraic 
equations presented in Example 2.4, followed by the execution results. The pro￾gram can be used to solve any valid system of three algebraic equations by replac￾ing the matric coefficients (a).
# Example 2.4
import numpy as np
a = np.array([[1,1,-1],
[3,-2,1],
[1,3,-2]])
b = np.array([6,-5,14])
def cramer(mat,constant):
D = np.linalg.det(mat)
mat1 = np.array([constant,mat[:,1],mat[:,2]])
mat2 = np.array([mat[:,0],constant,mat[:,2]])
mat3 = np.array([mat[:,0],mat[:,1],constant])
Dx = np.linalg.det([mat1,mat2,mat3])
X = Dx/D
print(‘\n The result,x,y,z’)
print(X)
cramer(a,b)
Execution result
The result,x,y,z
[ 1.3.-2.]
FIGURE 2.6 Simulink block diagram using Cramer’s rule encoded in MATLAB and 
implanted in a MATLAB function indicating the solution to the set of equations defined in 
Example 2.4.48 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Example 2.5 Implementation of Cramer’s Rule (2 x 2 Matrix)
Solve the following 2 2 × system using Cramer’s rule manually.
12x y + = 3 15
2 3 x y − = 13
Confirm the manual calculation with Simulink and Python programming of 
Cramer’s rule.
Solution
 1. Write the system in matrix form 
 12 3   x   15 
A X =  , , =   B = 2 3 y    −  13    
2. Find D, which is the determinant of A. Also, find the determinants Dx and 
Dy were:
Dx = det (A), where the first column is replaced with B
Dy = det (A),where the second column is replaced with B
 3. Find the values of the variables 
15 3
D 13 3 x = = x −
D 12 3
2 3−
D 45 39 x = = x − − = 2
D − − 36 6
 4. To solve for 
12 15
D 2 13
y = = x
D 12 3
2 3−
D 156 30
y = = x − = −3
D − − 36 6
Simulink Solution
Figure 2.7 describes the Simulink solution of the two linear algebraic equations 
defined in Example 2.5. The MATLAB embedded code follows the figure.
function Res = Cramer(A,B)
x = ones(2,1);
a_det = det(A);
for i = 1:2Numerical Solutions of Linear Systems 49
C = A;
C(:,i) = B;
x(i,1) = det(C)/a_det;
end
Res = x’;
Python Solution
The following programming is the Python code, followed by the execution result that 
determines the solution of the two linear algebraic equations defined in Example 2.5.
# Example 2.5
# Implementation f Cramer’s rule (2x2)
a = 12
b = 3
c = 2
d = -3
# Right-hand side
e = 15
f = 13
#12x+3y=15
#2x-3y=13
if (a*d - b*c == 0):
print(“The equation has no solution”)
else:
x = (e*d-b*f)/(a*d-b*c)
y = (a*f-e*c)/(a*d-b*c)
print(‘\n The result’)
print (“\n x=%s” % x, “y=%s” % y)
The result
x=2.0 y=-3.0
FIGURE 2.7 Simulink block diagram using Cramer’s rule encoded in MATLAB and 
implanted in a MATLAB function representing the solution to the equations defined in 
Example 2.5.50 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Example 2.6 Cramer’s Rule of Inconsistent Equations
Using Cramer’s rule, solve the following set of equations manually.
3 2 x y − = 4
6x y − = 4 0
Confirm the manual calculations with Simulink and Python programming of 
Cramer’s rule.
Solution
Write the system in matrix form AX = B.
 3 2−   x   4  A X =  ,  =  , B = 6 4− y   0      
The determinant D
3 2− D = = −12 + = 12 0
6 4−
A determinant of zero means the system has no solution.
Simulink Solution
The Simulink reveals that there is no available solution for the matrix defined in 
Example 2.6 because the determinant is zero (Figure 2.8).
The following program is the MATLAB code implanted in the Simulink MATLAB 
function.
function Res = fcn(A,B)
x = ones(2,1);
a_det = det(A);
for i = 1:2
C = A;
C(:,i) = B;
x(i,1) = det(C)/a_det;
end
Res = x’;
Python Solution
The following program is the Python code to find the determinant required in 
Example 2.6.
# Example 2.6
#importing Numpy package
import numpy as np
# creating a 3X3 Numpy matrixNumerical Solutions of Linear Systems 51
n_array = np.array([[3,-2],
[6,-4]])
# calculating the determinant of matrix
det = np.linalg.det(n_array)
print(“\n Determinant of given 3X3 square matrix:”,int(det))
The Python program executed the result. 
Determinant of given 3 × 3 square matrix: 0
2.3 GAUSS ELIMINATION METHOD
Gauss elimination transforms a system of linear equations into a matrix in the form 
of an upper triangular matrix, making solving for all variables easy. The steps to 
performing at Gauss elimination are the following:
 1. Create the augmented matrix.
 2. Turn every element in the first column to zero except the top one in row 1.
 3. Repeat the second step until only one nonzero variable is left in each row.
 4. Use backward substitution to solve for all the unknowns.
Gauss elimination is essentially a way to reduce an augmented matrix into an upper 
triangular matrix to make solving systems of linear equations much more accessible.
The Gauss elimination method has been widely used to solve linear algebraic 
equations. This method is known as the row reduction algorithm for solving linear 
equations systems, and it consists of a sequence of operations performed on the cor￾responding matrix coefficients.
Ax = b
FIGURE 2.8 Simulink solution using Cramer’s rule encoded in MATLAB and implanted 
in a Simulink MATLAB function representing the solution to the linear equations defined in 
Example 2.6.52 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The following system is a set of three linear algebraic equations:
a11x a 1 1 + + 2 2 x a    13 x b 3 1 = (2.1)
a21x a 1 2 + + 2 2 x a    23 x b 3 2 = (2.2)
a31x a 1 3 + + 2 2 x a    33 x b 3 3 = (2.3)
In matrix form,
 a a 11 12 a13   x1   b      1 
  a a 21 22 a23   x2  =  b2 
 a a 31 32 a33   x b   3      3 

Equation (2.1) is named pivot row, and the first nonzero element (a11 ) is called a piv￾otal element. Subsequent operations are performed around the pivot row and pivotal 
element as the following steps:
Set the equation in matrix form, AX = B.
 a a 11 12 a13   x1   b1         0 a a 22′ ′23   x2  =  b2′     0 a a 32′ ′ x3   33 b   3′      
The first equation is divided by a11( 0 a11 ≠ ), multiplied by a21, and subtracted from 
the second equation to yield the modified equation (2.2).
 a
a a 21  22′ = − 22   × a  a 12
11 
 a21  a a 23′ = − 23   × a  a 13
11 
 a b b 21  2 2 ′ = −   × b  a 1
11 
Similarly, the first equation is divided by a11, multiplied by a31, and subtracted from 
the third equation to yield the modified equation (2.3).
 a
a a 31  32′ = − 32   × a  a 12
11 
 a31  a a 33′ = − 33   × a  a 13
11 
 a b b 31  3 3 ′ = −   × b  a 1
11 Numerical Solutions of Linear Systems 53
The new row 2 equals row 2 – row 1 multiplied by ( / a a 21 11), and the new row 3 equals 
row 3 – row 1 ( / a a 31 11).
Finally, an upper triangular matrix is obtained. The three modified algebraic 
equations are as follows:
a11x a 1 1 + + 2 2 x a13x b 3 1 =
a22′ x a 2 2 + ′3 3 x b = 2′
a33′′ x b 3 3 = ′′3
This is a new set of three linearly independent algebraic equations to solve. Reverse 
substitution to determine x,
b′′ x = 3
3 a33′′
b a ′ x 2 2 − ′3 3 x 2 = a22′
b a
x 1 1 − − 2 2 x a13x3
1 = a11
In general, for the i variable of n equations
− −
= ∑n
b a i 1 i−1 i ij x j
x j i = +1
i ai−1
ii
Many equations of more than three require a program, such as Simulink or MATLAB 
programming, to solve.
Example 2.7 Implementation of Gauss Elimination Method
Calculate the determinant of the following matrix:
 a a 
A =  11 12 
 a a 21 22 
Solution
The determinant of A is calculated as follows:
det A a = × ( ) 11 a a 22 − × ( ) 12 a2154 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Apply the Gauss elimination method.
 a a  ′ =  11 12 A  ′ 
 a a 21 22 

  a   a22′ = −  21  ×  a   22 a  a11  12 
The determinant of the modified matrix A′ =
det A a ′ = × ( ) 11 a a 22′ − × ( ) 12 a21
The value of the determinant is not changed by the forward elimination step of the 
Gauss elimination, and this must be true because the forward step only modifies 
the equations.
det d [ ] A A = et[ }′ = a a11 22′ ′ a33′
 a a  12 a a  11 a13  a  11 12 13   
 a a 21 22 a23  → → Gauss elimination   0 a a 22′ ′23 
 a a a  31 32 33     0 0 a33′  
Example 2.8 Implementation of Gauss elimination Method
Solve the following set of linear algebraic equations utilizing the Gauss elimination 
method manually.
2 2 x y + + z =
2 2 x y + + 3 5 z =
2 3 x y + + 4 1 z = 1
Validate the manual calculations using Simulink and Python programming of the 
Gauss elimination method.
Solution
First, write these equations in matrix form AX = B.
 a a12   2 1 1 2  11 a13  x  b     x        1         a a 21 22 a23   y  =  b2 → 2 2 3 5    y  =  
 a a a   z   b   234   z   11   31 32 33     3       Numerical Solutions of Linear Systems 55
Solving for the new matrix,
 a a 11 12 a13   x1   b1         0 a a 22′ ′23   x2  =  b2′     0 a a 32′ ′ x3   33 b   3′      
Solving for a22′ ′ , a a 23, , 32′ ′   , a a 33   , 2 3 ′ ′ b ,
 a   2 a22′ = − a22  21   × = a 2 − 1 1  a11  12   × =  2
 a   2  a23′ = − a 21
23   × = a 3 −   × =1 2  a11  13  2
 a b b ′ = −  21   2  2 2  × = b1 5 −   × = 2 3  a11   2 
 a   2  a32′ = − a32  31  × = a −  12 3   × =1 2  a11  2 
 a a 31   2  33′ = − a33   × = a − a  13 4   × =1 3  11  2 
 a  b b 31  2  3 3 ′ = −   × = b a 1 11−   × = 2 9  11   2 
 a a  11 12 a13   x   1   b  211   x 2   1  1            0 a a 22′ ′23   x2  =  b2′ → 012  x 3   2  =         0 2 3    9   0 a a  3 3 32′ ′33 x b     3′     x      
The second step is to follow a similar procedure. In this case, the second row 
becomes the pivotal equation and a'
22 abecomes pivotal elements.
 a a 11 12 a13   x1   b      1 
  0 a a 22′ ′23   x2  =  b2′     a33 x3   0 0 ′′ b   3′′      
where
 a′ − 32   2  a33′′ = a33′ ' × 23′ = −   a 3   × = 2 1−  a22   1 
 a b b 32′   2 3 3 ′′= ′ − ×   b′ = −9   × = 3 3  a22′  22  1 
The new matrix56 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Substituting calculated value,
 2 1 1   x 2   1        0 1 2  x   2  =  3 
 0 0 −1     x  3   3    
Reverse substitution to determine x:
From the last row,
b x 3′′ 3 3 = = = −3 a33′′ −1
From the second last row,
b a x 2 3 ′ − ′3 3 x 3 3 − − ( )( ) 3 2 = = = 9 a22′ 1
From the first row,
b a x 1 1 − − 2 2 x a13x3 ( ) 2191 −× −×( ) −3 1 = = = −2 a11 2
Figure 2.9 shows the solution of the set of linear algebraic equations using the 
‘Algebraic constraints’ block available in the Simulink Math functions library. 
Note that when using the Gain to enter the matrix coefficient [2 1 1;2 2 3;2 3 4], 
do not forget to select the ‘Matrix (K*u) (u vector)’ from the pulldown menu near 
FIGURE 2.9 Simulation calculation using the Simulink algebraic constraint block for the 
matrix given in Example 2.8.Numerical Solutions of Linear Systems 57
multiplication. An alternative way is to use the MATLAB function, where the Gauss 
elimination method is programmed in the MATLAB file implanted in the MATLAB 
function, followed by Figure 2.10. The Simulink results are the same as those 
obtained using the Gauss elimination method.
The following program is the embedded MATLAB code utilizing the Gauss 
elimination methods of the equations defined in Example 2.8.
function y = fcn(a)
% Code from “Gauss elimination and Gauss Jordan methods using 
MATLAB.”
%Gauss elimination method [m,n)=size(a);[m,n]=size(a);
for j=1:m-1
for z=2:m
if a(j,j)==0
t=a(j,:);a(j,:)=a(z,:);a(z,:)=t;
end
end
for i=j+1:m
a(i,:)=a(i,:)-a(j,:)*(a(i,j)/a(j,j));
end
end
x=zeros(1,m);
for s=m:-1:1
c=0;
for k=2:m
c=c+a(s,k)*x(k);
end
x(s)=(a(s,n)-c)/a(s,s);
end
%display the results of the gauss elimination method;
y = x’;
FIGURE 2.10 Simulink solution using the Gauss elimination method coded in MATLAB 
and implanted in the Simulink MATLAB function of equations specified in Example 2.8.58 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Python Solution
The following Python program solves systems of linear equations with n unknowns 
using the Gauss elimination method. Given that a system is first transformed to 
upper triangular matrix row operations, then the solution is obtained by a back￾ward substitution. The Python results are the same as those obtained manually 
using the Gauss elimination method to solve the equation defined in Example 2.8.
#Example 2.8,Gauss elimination method
import numpy as np
# #initial coefficients
a=np.array([[2.0,1.0,1.0],[2.0,2.0,3.0],[2.0,3.0,4.0]])
b=np.array([2.0,5.0,11.0])
def gaussElim(a,b):
n = len(b)
# Elimination phase
for k in range(0,n-1):
for i in range(k+1,n):
if a[i,k]!= 0.0:
#if not null, define λ
lam = a [i,k]/a[k,k]
#we calculate the new row of the matrix
a[i,k+1:n] = a[i,k+1:n]-lam*a[k,k+1:n]
#we update vector b
b[i] = b[i]-lam*b[k]
# backward substitution
for k in range(n-1,-1,-1):
b[k] = (b[k]-np.dot(a[k,k+1:n],b[k+1:n]))/a[k,k]
return b
x = gaussElim(a,b)
#print the result
print(‘\n Result’)
print(“x =\n”,x)
The Python program execution result:
Result
x = [-2.9.-3.]
2.4 GAUSS-JORDAN ELIMINATION
The Gauss-Jordan elimination method is an algorithm used to solve linear equations 
systems and find the inverse of any inverted matrix. It is based on three basic class 
operations that can be used in an array:
• Switch the positions of two rows.
• Multiply a row by a nonzero number.
• Adding or subtracting the standard multiple of one line to another line.Numerical Solutions of Linear Systems 59
Example 2.9 Implementation of Gauss-Jordan Elimination
Solve the following set of linear algebraic equations manually using the Gauss￾Jordan elimination methods.
x + −y z = 7
x − +y z 2 3 =
2 9 x y + + z =
Verify the manual calculation using the Simulink and Python programming of the 
Gauss-Jordan elimination method.
Solution
Arrange the equations into matrix form
 1 1 −1 7    1 1− 2 | 3  
2 1 1 9 
 

Subtract row 2 from row 1 ( ) R R 1 2 −
R R 1 2 −
1 1 − = 0
1 1 − −( ) = 2
−1 2 − = ( ) −3
7 − = 3 4
Replace the second row with 0, 2, –3, and 4.
 1 1 −1 7    0 2 −3 | 4
2 1 1 9 
 

Multiply the row 1 by –2 and add to the third row ( 2− + R R 1 3)
 1 1 −1 7    0 2 −3 | 4
0 1− 3 −5 
 
60 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Add the second row to two times the third row ( 2 R R 2 3 + )
R R 2 3 + 2
0 2 + = ( ) 0 0
2 2 + −( ) 1 0 =
−3 2 + = ( ) 3 3
4 + − 2 5 ( ) = −6
The final matrix is
 1 1 −1 7    0 2 −3 | 4
0 0 3 −6 
 

Multiply row 1 by 3 minus row 2 (3R R 1 2 − )
 3 1 0 17    0 2 −3 | 4
0 0 3 −6 
 

Add row 2 and row 3 ( ) R R 2 3 +
 3 1 0 17    0 2 0 | −2  
0 0 3 −6 
 

Add two times row 1 minus row 2 (2R R 1 2 − )
 600 36    0 2 0 | −2  
0 0 3 −6 
 

Multiply the first row by 1 / 6, the second row by 1 / 2, and the third row by 1 / 3:
 100 6    010 | −1  
001 −2 
 

Accordingly,
x = = 6,  1 y z − = ,  −2Numerical Solutions of Linear Systems 61
Simulink Solution
The Simulink MATLAB function will return a column vector representing the solu￾tion to each variable in the order of appearance in the given matrix (Figure 2.11).
The following program is a MATLAB code associated with MATLAB function 
programs Gauss-Jordan method to solve the matrix indicated in Example 2.9.
function Ans = gauss_jordan (x)
for n = 1:(length(x)-1)
% Step 1: make the row N’s Nth term 1 by dividing
% the whole row by it
A = x(n,:);
A = A/A(n);
x(n,:) = A;
% Step 2: for every other row, add to it -1 * that rows Nth 
term *
% the Nth row
for k = 1:(length(x)-1)
if n~=k
x(k,:) = A*(-1*x(k,n))+x(k,:);
end
end
end
y = x(:,length(x))’;
Ans = y;
Python Solution
Gauss-Jordan elimination method is a structured method of solving a system of 
linear equations. Thus, it is an algorithm that can easily be programmed in Python 
to solve linear equations. This function will take a matrix designed to be used by 
the Gauss-Jordan algorithm and solve it, returning a transposed version of the last 
FIGURE 2.11 Simulink’s solution uses a Gauss-Jordan elimination method encoded in the 
MATLAB and implanted in the Simulink MATLAB function to solve the matrix indicated 
in Example 2.9.62 Numerical Methods in Chemical Engineering Using Python® and Simulink®
column in the ending matrix representing the solution to the unknown variables. 
Input: The function takes one matrix of n by n + 1, where n equals the number of 
unknown variables. Each row represents the coefficients of the variables in each 
equation. Furthermore, the last column contains the constants on the right-hand 
side of each equation.
#Example 2.9, Gauss Jordan elimination method
# Matrix 3 x 3
sd = [[1,1,-1,7],[1,-1,2,3],[2,1,1,9]]
print (“\n Augmented matrix of question”)
print(‘==================================\n’)
def Matrix():
for i in sd:
for j in i:
print(j,end=”\t\t”)
print(“\n”)
def getone(pp):
for i in range(len(sd[0])):
if sd[pp][pp]! = 1:
q00 = sd[pp][pp]
for j in range(len(sd[0])):
sd[pp][j] = sd[pp][j]/q00
def getzero(r,c):
for i in range(len(sd[0])):
if sd[r][c]! = 0:
q04 = sd[r][c]
for j in range(len(sd[0])):
sd[r][j] = sd[r][j] - ((q04) * sd[c][j])
Matrix()
print(‘=========== Result ===============\n’)
for i in range(len(sd)):
getone(i)
for j in range(len(sd)):
if i! = j:
getzero(j,i)
Matrix()
The result after the program execution is as follows:
Augmented matrix of question
=======================================
1 1 -1 7 
1 -1 2 3 
2 1 1 9 
=================Result===================
1.0 0.0 0.0 6.0 
0.0 1.0 0.0 -1.0 
0.0 0.0 1.0 -2.0
The above matrix is the augmented matrix of equations defined in Example 2.9, 
whereas the second matrix is the same in the reduced row-echelon form in which 
elements of the fourth column are the values of x, y, and z.
2.5 THE GAUSS-JACOBI AND GAUSS-SEIDEL ITERATIVE METHODS
The Gauss-Seidel method is an improved version of the Jacobi method, also known 
as the successive displacement method. The only difference between Jacobi and Numerical Solutions of Linear Systems 63
Gauss-Seidel methods is that in the Jacobi method, the value of the variables is not 
modified until the next iteration, while in the Gauss-Seidel method, the values of the 
variables are modified once a new value is evaluated.
2.5.1 the gauss-JacobI method
The Jacobi method is a method of solving a matrix equation on a matrix that has no 
zeros along its main diagonal. The Jacobi method is an iterative algorithm for rigor￾ously determining the solutions of a diagonally dominant system of linear equations.
Two assumptions were made on the Jacobi method.
 1. The system has a unique solution
a11x a 1 1 + + 2 2 x a … = 1 1 n n x b
a21x a 1 2 + + 2 2 x a … = 2 2 n n x b
an n 1 1 x a + + 2 2 x a … = nn x b n n
 2. The coefficient matrix 
1
x1 = − ( ) b a 1 12 2 x a − − 13x a 3 1 … a n n x 11
1
x2 = − ( ) b a 2 21 1 x a − − 23x a x
a 3 2 … n n
22
1
xn = − ( ) b a x a x a x
a n n1 1 − − n n 2 2 … , 1 n n − −1
nn
Make an initial guess of x o o
1 2 , x x ,  o
n . Substitute these values into the right-hand side 
of the rewritten equation to obtain the first approximation, x1
1 , x x 1 1
2 ,  n . Substitute the 
computed approximation, x value, into the right-hand side of the rewritten equations. 
This accomplished repeated iteration until forming a sequence of approximations.
Example 2.10 Application of the Jacobi Method
Solve the following set of linear algebraic equations using the Jacobi method.
5x y − + 2 3z = −1
−3 9 x y + + z = 2
2 7 x y − − z = 3
Validate the manual calculations with Simulink and Python programming.64 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solution
First, put the variables in the following form:
1 2 3 x = − + −y z 5 5 5
2 3 1
y x = + − z 9 9 9
3 2 1
z = − + −x y 7 7 7
Choose the initial guess, x = =y z = 0
The first approximation
x1
1 = −0.200
y
1 = 0.222
z
1 = −0.429 
Continue iterations until two successive approximations are identical when 
rounded to three significant digits (Table 2.1).
Simulink Solution
Jacobi’s iterative method is an algorithm for determining the solutions of a diago￾nally dominant system of linear equations. Each diagonal element is solved, and 
an approximate value is plugged in. The process is then iterated until it converges 
(Figure 2.12). The following MATLAB program employs the Gauss-Jacobi method 
to solve the equation presented in Example 2.10, and the program is embedded 
into the Simulink MATLAB function block diagram.
%Example 2.10
function Res = jacobi(A,b)
Eps=0.001;
%[5 -2 3 ;-3 9 1; 2 -1 -7] equation coefficients 
%[-1;2;3] equations right-hand side constants. 
TABLE 2.1
Approximate Solution Using the Jacobi Method of a Set of Equations Defined 
in Example 2.10
n 0 1 2 3 4 5 6 7
x 0.000 –0.200 0.146 0.192 0.181 0.185 0.186 0.186
y
z
0.000
0.000
 0.222
–0.429
 0.203
–0.517
 0.328
–0.416
 0.332
–0.421
 0.329
–0.424
 0.331
–0.423
 0.331
–0.423Numerical Solutions of Linear Systems 65
n = length(b) ;
x0 = zeros(3,1) ;
x = ones(size(x0)) ;
while norm(x-x0,inf) >= Eps
x0 = x;
for i = 1 : n
x(i) = b(i);
for j = 1 : n
if j ~= i
x(i) = x(i) - A(i, j)*x0(j);
end
end
x(i) = x(i) / A(i, i) ;
end
end
Res =x’;
Python Solution
The Jacobi method is an iterative matrix used to solve the equation A X    = b for 
a known square matrix of size n×n and known vector or length. The follow￾ing Python code utilizes the Jacobi method to solve the equations defined in 
Example 2.10.
# Example 2.10
# Jacobi method
f1 = lambda x, y, z : (-1 +2*y - 3*z)/5
f2 = lambda x, y, z : (2 + 3*x - z)/9
f3 = lambda x, y, z : (-3 + 2*x-y)/7
# Tolerance
e = 0.0001
iteration = 0
FIGURE 2.12 Simulink simulated block diagram using the Jacobi method coded in 
MATLAB and inserted in the Simulink MATLAB function to solve the set of algebraic 
equations given in Example 2.10.66 Numerical Methods in Chemical Engineering Using Python® and Simulink®
# initial values
x0 = y0 = z0 = 0
e1 = e2 = e3 = 1
print(“\n n x y z \n”)
while e1>e and e2>e and e3>e:
x1 = f1(x0,y0,z0)
y1 = f2(x0,y0,z0)
z1 = f3(x0,y0,z0)
e1 = abs (x0-x1)
e2 = abs (y0-y1)
e3 = abs (z0-z1)
iteration +=1
x0 = x1
y0 = y1
z0 = z1
print(f”{{y1:.3f} {z1:.3f}”)
print (f”\n The value of x = {x1:.3f},y= {y1:.3f},z= {z1:.3f}”)
print(f”\n number of iteratios = {iteration}”)
Execution result
n x y z
1.0 -0.200 0.222 -0.429
2.0 0.146 0.203 -0.517
3.0 0.192 0.328 -0.416
4.0 0.181 0.332 -0.421
5.0 0.185 0.329 -0.424
6.0 0.186 0.331 -0.423
7.0 0.186 0.331 -0.423
The value of x = 0.186, y= 0.331, z= -0.423
number of iterations 7 =
2.5.2 gauss-seIdel IteratIve methods
The Gauss-Seidel method is an iterative numerical method that can aid us in solving 
linear systems of equations. This method works for linear systems of equations and 
guarantees convergence if our matrix is diagonally dominant, just like the Jacobi 
iteration. The steps to solving a system of linear equations using the Gaussian method 
are as follows:
1. Guess every unknown value in the matrix. Assume a value for as many vari￾ables as x, y, and z. Set the initial iteration to 0, as many programming lan￾guages like Python have zero indexing, meaning we begin counting from 0. 
However, if using MATLAB, begin at 1, as it does not have zero indexing. A 
typical starting guess is just a zero matrix unless we have additional infor￾mation about the problem that could help our guesses. The benefit of having 
a better starting guess is that we achieve our final solution in fewer iterations 
and, therefore, less time.
2. Rewrite all of our independent equations and have them all solve for an 
individual variable.
3. Once we have rewritten all of our system of linear equations, it is often wise 
at this point to create a table to summarize all of the relevant information. Numerical Solutions of Linear Systems 67
Now we are ready to solve for iteration 1 user’s latest guesses of y and z year 
to help us solve for x at iteration 1. Then we must solve for y and use our 
latest guesses for x and z. Note that this is where the significant difference 
between the Jacobi iteration method and the Gauss-Seidel method is in the 
Jacobi method; we would not use the variable values in the same iteration 
on one another. However, in the Gauss-Seidel method, we do, which almost 
always leads to finding a solution quicker if there is one. Last, move on to 
solving z for iteration using x and y that we found in the first iteration.
4. After finding all the variable values for iteration 1, move forward to iteration 
2 and solve for x using the y and z values found in iteration 1.
5. Continue iterations until there is an acceptable amount of error. For coding 
purposes, verify that all equations’ right sides are within the error tolerance.
The Gauss-Seidel method is used to solve linear system equations. This method 
modifies the Gauss-iteration method and the Jacobi method. This modification 
reduces the number of iterations. The computed value replaces the previous value 
only at the end of the iteration. Because of this, Gauss-Seidel methods converge 
much faster than Gauss methods. The number of iteration methods required to get 
the solution is much less than the Gauss method in Gauss-Seidel methods. The 
Gauss-Seidel equation
= − ∑
n
1 xi ( ) b a x a i ij j
ii j j = ≠ 1, i
Example 2.11 Application of Gauss-Seidel Method
Use the approximate solution utilizing the Gauss-Seidel iteration method to solve 
the following set of three linear algebraic equations.
5x y − + 2 3z = −1
−3 9 x y + + z = 2
2 7 x y − − z = 3
Authenticate the manual calculations using Simulink and Python programming of 
the Gauss-Seidel iteration method.
Solution
Put the equations in the following form:
( ) − +1 2y z − 3 x = 5
( ) 2 3 + −x z
y = 9
( ) − +3 2x y − z = 768 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The first calculation is the same as the Jacobi iteration method, as a first initial 
guess.
x = =y z = 0
The value of x1 is based on the initial guess of y and z
1 2 3 x1 = − + − ( ) 0 ( ) 0 = −0.200
5 5 5
The value of y, is obtained by substituting the new value of x1 = −0.200, in the 
commutation of y
2 3 1
y = + ( ) − − 0.200 ( ) 0 = 0.156
9 9 9
In the computation of z, substitute the new values of x, y
3 3 1
z = − + −( ) 0.200 − = ( ) 0.156 −0.508
7 9 7
Continue the iterations until successive values are identical to the three decimal 
digits. The sequence of approximations is shown in Table 2.2. The solution con￾verges in less number of iterations.
Simulink Solution
The Simulink block diagram using the Simulink MATLAB function is presented in 
Figure 2.13, followed by the MATLAB code.
The following MATLAB program is the MATLAB code embedded in the 
Simulink MATLAB function utilizing the Gauss-Seidel iteration method of the set 
of equations presented in Figure 2.13.
% Example 2.11.
% Gauss-Seidel iteration method
function Res = gauss(A,b)
%This function solves the system of algebraic equations using the 
%Gaussian method
TABLE 2.2
Approximate Solution Using the Gauss-Seidel 
Method of the Set of Equations Defined in 
Example 2.11
n 0 1 2 3 4 5
𝑥 0.000 –0.200 0.167 0.191 0.186 0.186
𝑦 0.000 0.156 0.334 0.333 0.331 0.331
𝑧 0.000 –0.508 –0.429 –0.422 –0.423 –0.423Numerical Solutions of Linear Systems 69
%Ax=b
%Input: matrix A,column vector b
%Output vector x
n=size(A,1);
b=b(:);%make sure b is a column vector.
nb=n+1;
Ab=[A b];%extended matrix
%Forward process
for i=1:n-1
for j=i+1:n
Ab(j,i:nb)=Ab(j,i:nb)-Ab(j,i)*Ab(i,i:nb)/Ab(i,i);
end
end
%Inverse process
x=zeros(n,1);
x(n)=Ab(n,nb)/Ab(n,n);
for i=n-1:-1:1
x(i)=(Ab(i,nb)-Ab(i,i+1:n)*x(i+1:n))/Ab(i,i);
end
Res = x;
Python Solution
The following program is the Python code utilizing the Gauss-Seidel method to 
solve the equations defined in Example 2.11.
# Example 2.11
# Guass Seidel method
f1 = lambda x,y,z:(-1 + 2*y - 3*z)/5
f2 = lambda x,y,z:(2 + 3*x - z)/9
f3 = lambda x,y,z:(-3 + 2*x-y)/7
FIGURE 2.13 A simulated block diagram using the MATLAB-encoded Gauss-Seidel 
method and implanted in the Simulink MATLAB function to solve the set of linear algebraic 
equations defined in Example 2.11.70 Numerical Methods in Chemical Engineering Using Python® and Simulink®
# Tolerance
e = 0.0001
iteration = 0
# initial values
x0 = y0 = z0 = 0
e1 = e2 = e3 = 1
print(“\n n x y z \n”)
while e1>e and e2>e and e3>e:
x1 = f1(x0,y0,z0)
y1 = f2(x1,y0,z0)
z1 = f3(x1,y1,z0)
e1 = abs (x0-x1)
e2 = abs (y0-y1)
e3 = abs (z0-z1)
iteration +=1
x0 = x1
y0 = y1
z0 = z1
print(f”{iteration:.1f} {x1:.3f} {y1:.3f} {z1:.3f}”)
print (f”\n The value of x = {x1:.3f},y = {y1:.3f},z = {z1:.3f}”)
print(f”\n number of iteratios = {iteration}”)
Execution result
n x y z
1.0 -0.200 0.156 -0.508
2.0 0.167 0.334 -0.429
3.0 0.191 0.333 -0.422
4.0 0.186 0.331 -0.423
5.0 0.186 0.331 -0.423
The value of x = 0.186,y = 0.331,z= -0.423
number of iterations = 5
2.6 SUMMARY
Solving linear systems is fundamental to numerical computation. Binary and tertiary 
linear systems are easily solved by successive substitution, and the general linear 
system can be solved by triangulation and Gaussian elimination. Pivoting is essential 
for the stable implementation of Gaussian elimination. Algorithms and specialized 
software are available to solve specific types of linear systems using Simulink and 
Python.
2.7 PROBLEMS
1. Find the determinant of the following 2 × 2 matrix:
 −4 2     −8 7 
 Answer: (12)Numerical Solutions of Linear Systems 71
2. Find the determinant of the following 3 × 3 matrix:
 6 2 −4    5 6 −2  
5 2 −3 
 

 Answer: (6)
 3. Find the approximate solution of the system with two variables by Cramer’s 
5x y + = −13
3 2 x y − = 0
 Answer: (–2, –3)
 4. Solve the system with two variables by Cramer’s rule.
−2 3 x y + = −3
3 4 x y − = 5
 Answer: (3, 1)
 5. Solve the following two linear algebraic equations using the Gauss elimina
−8 6 x y − = −2
2 5 x y + = −1
 Answer: (4/7, –3/7)
 6. Solve the system shown below using the Gauss elimination method.
−2   x y + − z = 8
−3 2 x y − + z  1 = − 1
−2 2 x y + + z  3 = −
 Answer: (0.133, 4.067, –3.667)
7. Solve the system shown below using the Gauss elimination method.
x    + −y z   = 9
y z + = 3    372 Numerical Methods in Chemical Engineering Using Python® and Simulink®
−x z − = 2    2
 Answer: (2/3, 7, –4/3)
 8. Solve the system shown below using the Gauss-Jordan elimination method.
−x y + = 2 6−
3 4 x y − = 14
 Answer: (2, –2)
9. Solve the system of the following three linear algebraic equations using the 
Gauss-Jacobi elimination method.
2 2 x y + + z = 10
x + + 2 8 y z =
3 2 x y + − z =
 Answer: (1, 2, 3)
 10. Solve the system of the below three linear algebraic equations using the 
x + +y z = 4
2 3 x y − + z = 2
−x y + − 2 1 z = −
 Answer: (2, 1, 1)
REFERENCE
 1. Kong Q., Siauw T., Bayen A., 2020. 73
3 Bracketing Numerical 
Methods for Solving 
Systems of Nonlinear 
Equations
Root-finding methods of nonlinear algebraic equations are categorized into brack￾eted and open methods. This chapter covers the graphical and bracketing methods 
such as the bisection method, the false-position method, and the Ridders method. 
Programming these methods using Simulink and the open-source Python language 
is explained extensively.
LEARNING OBJECTIVES
 1. Determine the approximate roots of nonlinear equations using the graphical 
method.
2. Calculate the roots of nonlinear equations using the bisection method.
 3. Estimate the approximate roots of nonlinear equations using the false-posi￾tion method.
4. Find the roots of nonlinear equations using the Ridders method.
3.1 INTRODUCTION
Most numerical methods for finding roots of linear and nonlinear algebraic equations 
use repetition, resulting in a series of numbers that expectantly approach the root as 
a bound. It requires one or more initial guesses of the root as initial values, and then 
each iteration of the algorithm results in a more accurate approximation of the root 
successively.
Nonlinear equations involve multiple variables. To recognize a nonlinear equation 
is to observe that the x is not alone as in ax, but involves a product with itself, such as 
in x3+ 3x2 – 9 = 0. In this case, x3 and 2x2 are nonlinear terms. The differences between 
‘closed’ and ‘open’ methods are that the closed method uses a bounded interval. This 
method usually converges slowly and always finds a root if it exists. The open method 
usually converges quickly; many do not find a root if it exists. The available methods 
require a single or two starting values that do not necessarily bracket a root. Closed 
methods generate at least one root. Depending on the initial guess and type of function, 
the available methods sometimes result in divergence. By contrast, once converged, 
they are faster than closed methods and converged quickly. The bracketing methods 
DOI: 10.1201/9781003360544-374 Numerical Methods in Chemical Engineering Using Python and Simulink
include graphical, bisection, and false-position methods. The following equations are a 
set of the nonlinear algebraic equations:
f x 1 1 ( ) ………  0 xn = 

f x 2 1 ( )  ………xn = 0  = f x( ) (3.1)
 f x n n ( ) 1……...x = 0 
or
 f x( ) 
F X( )   =  ...  = 0 (3.2)
 f x n ( )   
where F X 1 ( ) takes the form such as ( X1 1 − = sin ) X 0, or
x − = sin 0 x x , and  2 1 = ex (3.3)
Solving a set of nonlinear algebraic equations usually is difficult. Solving one non￾linear equation f ( ) α = 0, finding the root ( ) α .
3.2 GRAPHICAL METHOD
The graphical method allows for solving simple problems intuitively and visually. 
This method is limited to two or three problem decision variables since it is impos￾sible to illustrate more than 3D graphically. For any cartesian equation in one vari￾able, the root of the given equation is where the graph intersects the x-axis. Now, if it 
is practically not easy to plot a graph of a given equation directly, for such an equa￾tion, we can split the given equation into two parts as follows. If the given equation is
f ( ) x = 0
We split the function f into f1 and f2 such that
f () () () x f = − 1 2 x f x
Now to find x such that f ( ) x = 0, we can find x such that f1 2 ( ) x f = ( ) x .
Steps for solving equations by graphical method:
 1. First, find the suitable range 
 2. For this selected range, plot the graph of 
 3. Find the approximate point on the Bracketing Numerical Methods 75
Example 3.1 Root Finding Using Graphical Method
Using the graphical method, find the roots of the following equation:
f ( ) x x = −3 2 3 3 x x − +1 0 =
Validate the manual calculations with Simulink and Python programming of the 
root finding using a graphical method.
Solution
Split the equation into two such as:
f 3 1 ( ) x x =
f2 ( ) x x = + 3 3 2 x −1
So that
f ( ) x f = − 3 2 1 2 ( ) x f ( ) x x = − ( ) 3 3( ) x x + − 3 1
Take appropriate values of x as shown in Table 3.1.
The root is at x = −1, because both functions give the same value at that inter￾section point.
Simulink Solution
Figure 3.1 symbolizes the Simulink block diagram utilizing the graphical method to 
solve the equation defined in Example 3.1.
To enter the X and Y label in the scope, select the X-Y graph generated by 
Simulink, and then run the below commands in the MATLAB command window: 
set(0,’ShowHiddenHandles’, ‘on’)
set(gcf, ‘menubar’, ‘figure’)
These commands will enable the toolbar in the X Y− graph figure window. Individuals 
can add axes names from Insert >> X Label and Insert >> Y Label (Figure 3.2).
TABLE 3.1
Values of f(x) at Various x Values
x –4 –3 –2 –1 0 1 2 3 4
f1(x) –64 –27 –8 –1 0 1 8 27 64
f2(x) 35 17 5 –1 –1 5 17 35 5976 Numerical Methods in Chemical Engineering Using Python and Simulink
FIGURE 3.2 Graphical representation using the graphical root finding of the equation 
defined in Example 3.1.
FIGURE 3.1 Simulink programming utilizes a graphical method to solve the equation 
defined in Example 3.1.Bracketing Numerical Methods 77
Python Solution
The following program is the Python code that generates the plot shown in 
Figure 3.3. The figure represents the graphical root-finding method of the equation 
defined in Example 3.1.
# Example 3.1
# Bisection method
import numpy as np
import matplotlib.pyplot as plt
def f(x):
 y= x**3 - 3*x**2 - 3*x + 1
 return y
def g(x):
 y1 = x**3
 return y1
def h(x):
 y2 = 3*x**2 + 3*x - 1
 return y2
a = -5
b = 5
def bisection(a, b):
 if f(a)*f(b)>0:
 print(“no root found”)
 return
 c = a
 while ((b-a)>=0.01):
 c = (a +b)/2
 if f(c)==0:
 exit()
 if f(c)*f(a)<0:
 b = c
 else:
 a = c
FIGURE 3.3 Find the root plot generated by Python programming for the graphical method 
of the given equation in Example 3.1.78 Numerical Methods in Chemical Engineering Using Python and Simulink
 print(“root of of i=”, c)
 plt.plot(c, f(c), ‘ro’)
bisection(a, b)
x=np.linspace(-3,3,20)
plt.plot (x, g(x), x, h(x), x, f(x))
plt.grid()
plt.xlabel(“x”, fontsize = 15)
plt.ylabel(“y”, fontsize = 15, rotation = 0)
plt.text(-2,20, ‘Roots are at the intersections of 
\n $y_1$ and $y_2$’)
plt.text(-2.5,-40, ‘$y=x^3 - 3x^2 - 3x + 1$’)
plt.text(2,30, ‘$y_1= x^3$’)
plt.text(1.2,-2, ‘$y_2= 3x^2 + 3x - 1$’)
Example 3.2 Root Finding of High-Order Equations
Find the root of the following equation using the graphical method.
f ( ) x x = −4 2 11x x + + 2 1
Validate the manual calculation of the root using Simulink and Python program￾ming of the graphical method.
Solution
The function can be arranged in the following form:
f ( ) 4 1 x x =
f2 ( ) x x = − 11 2 2 1 x −
f ( ) x f = − 1 2 ( ) x f ( ) x x = − ( ) 4 2 ( ) 11x x − − 2 1
The root is at x where
f1 2 ( ) x f = ( ) x
Taking an appropriate value of x to generate the data shown in Table 3.2. Two 
roots exist at x = −0.22437, and x = 0.40987. At these values, differences between 
f1 ( ) x and f2 ( ) x equal zero.
TABLE 3.2
Values of f(x) at Various Values of x
x –4 –3 –2 –1 –0.22437 0 0.40987 1 2 3 4
f1(x) 256 81 16 1 0.0025 0 0.0282 1 16 81 256
f2(x) 183 104 47 12 0.0025 –1 0.0282 8 39 92 167Bracketing Numerical Methods 79
Simulink Solution
The Simulink solution is described by the Simulink block diagram shown in 
Figure 3.4. By double-clicking the scope released in Figure 3.5.
FIGURE 3.4 The Simulink block diagram represents the method for finding the root by the 
graphical approach of the given equation in Example 3.2.
FIGURE 3.5 Simulink generated a plot of the graphical root-finding representation of the 
equation identified in Example 3.2.80 Numerical Methods in Chemical Engineering Using Python and Simulink
Python Solution
The following Python code uses the graphical root-finding method to solve the 
equation defined in Example 3.2. Figure 3.6 shows the plot with the intersections 
where the root lies. 
# Example 3.2
# Graphical and Bisection method
import numpy as np
import matplotlib.pyplot as plt
def f(x):
 y= x**4–11*x**2+2*x+1
 return y
def g(x):
 y1 = x**4
 return y1
def h(x):
 y2 = 11*x**2-2*x-1
 return y2
a 0
b = 2
def bisection(a, b):
 if f(a)*f(b)>0:
 print(“no root found”)
 return
c = a
while ((b-a)>=0.0001):
 c = (a +b)/2
 if f(c)==0:
 exit()
 if f(c)*f(a)<0:
 b = c
else:
 a c
=
=
FIGURE 3.6 Python-generated plot of the root finding using the graphical technique of the 
equation defined in Example 3.2.Bracketing Numerical Methods 81
 print(“root of of i=”, c)
 plt.plot(c, f(c), ‘ro’)
bisection(a, b)
x=np.linspace(-1,1,20)
plt.plot (x, g(x), ‘g’, x, h(x), ‘b’, x, f(x), ‘r’)
plt.grid()
plt.xlabel(“x”, fontsize = 12)
plt.ylabel(“y”, fontsize = 12, rotation=0)
plt.text(-0.5,7, ‘Roots are at the intersections of 
\n $y_1$ and $y_2$’)
plt.text(-0.75,-10, ‘$y=x^4–11x^2+2x+1$’)
plt.text(-1,5, ‘$y_1= x^4$’)
plt.text(-1,-2, ‘$y_2= 11x^2-2x-1$’)
Example 3.3 Graphical Methods for the Root of Quadratic Equations
Find the roots of the following quadratic equation using manual calculations, 
Python programming, and Simuling graphical programming.
y x = −2 4 3 x + = 0
Confirm the manual calculation using the graphical root-finding method utilizing 
Simulink and Python programming.
Manual Solution
The equation can be arranged in the following form.
x 2 − + 4 3 x = 0
This can be analyzed as follows:
(x x − − 3 1 )( ) = 0
Accordingly, the roots are 1 and 3.
Simulink Solution
Figure 3.7 shows the Simulink block diagram representing the graphical root￾finding method of the equation defined in Example 3.3. The intersection points 
represent the roots of the quadratic equations (Figure 3.8).
Python Solution
The following Python code describes the graphical root-finding method of the 
equation defined in Example 3.3. After execution, the results are plotted in 
Figure 3.9.
# Example 3.3
# Graphical & Bisection methods
import numpy as np
import matplotlib.pyplot as plt
def f(x):82 Numerical Methods in Chemical Engineering Using Python and Simulink
FIGURE 3.8 Simulink generated a plot of a graphical representation of the quadratic equa￾tion mentioned in Example 3.3.
FIGURE 3.7 Simulink block diagram utilizing the graphical method to solve the equation 
declared in Example 3.3.Bracketing Numerical Methods 83
 y = x**2 - 4*x + 3
 return y
def g(x):
 y1 = x**2
 return y1
def h(x):
 y2=4*x - 3
 return y2
a = 2
b = 5
def bisection(a, b):
 if f(a)*f(b)>0:
 print(“no root found”)
 return
c = a
while ((b-a)>=0.01):
 c = (a +b)/2
 if f(c)==0:
 exit()
 if f(c)*f(a)<0:
 b = c
 else:
 a = c
 print(“root of of i=”, c)
 plt.plot(c, f(c), ‘ro’)
bisection(a, b)
x=np.linspace(0,5,10)
plt.plot (x, g(x), x, h(x), x, f(x))
plt.grid()
plt.xlabel(“x”, fontsize = 12)
plt.ylabel(“y”, fontsize = 12, rotation=0)
plt.text(0.2,20, ‘Roots are at the intersections’)
plt.text(3.5,-0.5, ‘$y=x^2–4x+3$’)
plt.text(3.8,20, ‘$y= x^2$’)
plt.text(4,12, ‘$y=4x-3$’)
FIGURE 3.9 Root finding using the graphical method in Python of the equation described 
in Example 3.3.84 Numerical Methods in Chemical Engineering Using Python and Simulink
Example 3.4 Graphical Methods for Roots of Quadratic Equation
Find the roots of the following equation using the graphical method.
y e = +x x − 3
The equation can be written as follows:
ex = −3 x
There is one root which is around 0.8. Validate the root found manually with the 
graphical method using Simulink and Python programming.
Simulink Solution
Figure 3.10 is a Simulink block diagram describing a graphical method for find￾ing the root of the equation given in Example 3.4, and the output is displayed in 
Figure 3.11.
Python Solution
The following Python code uses the graphical root search method programmed to 
find one of the roots of the equation given in Example 3.4.
# Example 3.4
import numpy as np
import matplotlib.pyplot as plt
def f(x):
y = np.exp(x) + x - 3
FIGURE 3.10 Simulink graphical root-finding method of the equation defined in Example 
3.4.Bracketing Numerical Methods 85
 return y
def g(x):
 y1 = np.exp(x)
 return y1
def h(x):
 y2= 3-x
 return y2
# interval [a, b]
a = 0
b = 3
def bisection(a, b):
 if f(a)*f(b)>0:
 print(“no root found”)
 return
 c = a
 while ((b-a)>=0.01):
 c = (a + b)/2
 if f(c)==0:
 exit()
 if f(c)*f(a)<0:
 b = c
else:
 a = c
 print(“The root of the function :”, c)
FIGURE 3.11 Simulink generated a plot of the graphical root-finding method to solve the 
equation defined in Example 3.4.86 Numerical Methods in Chemical Engineering Using Python and Simulink
plt.plot(c, g(c), ‘ro’)
bisection(a, b)
x=np.linspace(0,2,10)
plt.plot (x, g(x), x, h(x), x, f(x))
plt.grid()
plt.xlabel(“x”, fontsize = 12)
plt.ylabel(“y”, fontsize = 12, rotation=0)
plt.text(0.25,4.5,’Roots are at the intersections of’
‘\n $y_1=3-x$ & $y_2=e^x$’, fontsize = 12)
plt.text(0.75,-1,’$y=e^x+x-3$’, fontsize = 12)
plt.text(0.25,0.5, ‘$y_2=e^x$’, fontsize = 10)
plt.text(0.25,3, ‘$y_1=3-x$’, fontsize = 10)
The program-executed plot is shown in Figure 3.12.
Example 3.5 G raphical Methods for Finding the 
Root of a Quadratic Equation
Find the roots of the following equation using the graphical root-finding method.
y x = + ln( ) x − 3
Using Simulink and Python programming to find the root of the defined equation.
Solution
The root is around 2.208.
FIGURE 3.12 Graphical method for finding the root of the equation defined in Example 3.4 
using Python.Bracketing Numerical Methods 87
Simulink Solution
The Simulink solution utilizing the graphical root-finding method of the equation 
present in Example 3.5 is shown in Figures 3.13 and 3.14.
FIGURE 3.13 Simulink graphical simulation method of finding the root with a cut-off time 
is five to solve the given equation in Example 3.5.
FIGURE 3.14 A graphically simulated root-finding method generated by Simulink to deter￾mine the root of the equation given in Example 3.5.88 Numerical Methods in Chemical Engineering Using Python and Simulink
Python solution
The following Python code programmed the graphical root-finding method to 
explore the root of the equation needed in Example 3.5.
# Example 3.5
import numpy as np
import matplotlib.pyplot as plt
def f(x):
y = np.log(x) + x - 3
return y
def g(x):
y1 = np.log(x)
return y1
def h(x):
y2= 3-x
return y2
# interval [a, b]
a = 0
b = 5
def bisection(a, b):
if f(a)*f(b)>0:
print(“no root found”)
return
c = a
while ((b-a)>=0.01):
c = (a +b)/2
if f(c)==0:
exit()
if f(c)*f(a)<0:
b = c
else:
a = c
print(“The root is:”, c)
plt.plot(c, g(c), ‘ro’)
bisection(a, b)
x=np.linspace(0,5,30)
plt.plot (x, g(x), x, h(x), x, f(x))
plt.grid()
plt.xlabel(“x”, fontsize = 13)
plt.ylabel(“y”, fontsize = 13, rotation=0)
plt.text(0.65,2.5,’Roots are at the intersections of’
‘\n $y_1=3-x$ & $y_2=ln(x)$’, fontsize = 12)
plt.text(1.3,-2, ‘$y=ln(x)+x-3$’, fontsize = 13)
plt.text(4,0.5, ‘$y_2=ln(x)$’, fontsize = 12)
plt.text(0.1,1.5, ‘$y_1=3-x$’, fontsize = 12)
The result is shown in Figure 3.15.
3.3 ROOTS SOLUTION WITH BRACKETING METHOD
The method is suitable for monotonically increasing or decreasing functions 
(Figure 3.16). The closed method is an interval where there is a root inside it. At each 
step, the method produces intervals that contain the root and steadily shrink. This 
method is guaranteed to find a root within the interval [a, b]. This technique is called 
the bracketing method. The following steps are taken to resolve the root.Bracketing Numerical Methods 89
 1. Find 
f ( ) x f l u × < ( ) x 0
This means that one root was trapped or enclosed in parentheses. Some 
functions may have multiple roots.
 2. Check, 
xU m = x (Replace xU with xm ), else x1 = xm and replace x1with xm
FIGURE 3.15 Python-generated plot represents the graphical root-finding method of the 
equation present in Example 3.5.
FIGURE 3.16 Graphical representation of the bracketing method of numerical analysis.90 Numerical Methods in Chemical Engineering Using Python and Simulink
3. The bracketing method is a simple technique for obtaining an estimate of 
the root for the equation f ( ) x = 0.
4. It gives a rough approximation of the root solution.
3.3.1 Bisection Method
The bisection method is a type of root-finding bracketing method in which the inter￾val is always divided in half. If the function changes signs over an interval, the value 
of the function will be evaluated at the midpoint. The root location is then identified 
as within the subinterval where the tag change occurs. The bisection method requires 
two initial guesses:
a    = x0 and b x     = 1, to satisfy the bracket condition
f ( ) x f 0 1 ·   ( ) x < 0
To check for a root of some function, f ( ) x , select an interval [ , x x o 1] in which the root 
lies in between xo and x1.
1. Calculate f ( ) x0 and f ( ) x1 .
2. Check to see if they have the same sign. If so, there may be no root between 
them, and then quit.
3. If they have opposite signs, then pick a point, f ( ) xi between the two ends.
4. Check the sign of the f ( ) xi , if it is signed the same as f ( ) x1 , the root lies 
between xi and x2, so set x1 = xi.
5. If it is signed the same as f ( ) x1 , then the root lies between xi and x1, so set 
xi as x1.
6. If f ( ) xi = 0, then xi is the root.
7. Otherwise, repeat with new xi.
Advantages of the bisection method:
1. The root needs to be inside the range.
2. It is always converging.
3. It only requires evaluation of function, not derivative.
Disadvantage of the bisection method:
1. It converges slowly compared to other methods
Example 3.6 Implementation of Bisection Technique
Use the bisectional method to find the root of the following equation on the inter￾val [1, 2].
3 2 f ( ) x x = −Bracketing Numerical Methods 91
Stop when the relative fraction change is 1 1 × 0−5
. The exact root is ∓ 3 . Verify the 
exact root with Simulink and Python programming of the bisection method.
Solution
Now, find the value of f ( ) x at a = 1.0 and b = 2.
f ( ) x0 = = 1    12 3 − = 1 – 3 = −  2    < 0
f ( ) x1 = = 2    22 3 − = 4 – 3 = >  1   0
The given function is continuous, and the root lies in the interval [1, 2]. The value 
of the lower limit is negative, and the upper interval is positive. Let ‘xi’ be the 
midpoint of the interval. We calculate the f ( 1 x1 = ) and f ( 2 x2 = ) the first guess is 
the midpoint of the interval, xi = 1.5, and then we evaluate the function f ( ) xi = 1.5 .
( ) 1 2 + xi   = = 1.5
2
Therefore, the value of the function at xi
 is
f ( ) x f i     = = ( ) 1.5    ( ) 1.5 2 3 − =   2.25 – 3 = −  0.75    < 0
If   0 f x( )i < , assume a    = xi, and if f ( ) xi > 0, assume b x     = i.
f ( ) xi is negative, so a is replaced with xi = 1.5 for successive iterations. The rest 
of the iterations for the given functions are tabulated in Table 3.3.
So, we get the final interval [1.7266, 1.7344]. Hence, 1.7344 is the approxi￾mated solution.
The Simulink solution is shown in Figure 3.17.
An alternative way to use Simulink is the MATLAB function from the Simulink 
user-defined functions library (Figure 3.18).
The following program is the MATLAB code that embeds the Simulink MATLAB 
function.
% Example 3.6
% Bisection Method in MATLAB
function y = fcn(a, b)
TABLE 3.3
Solution of Equation Present in Example 3.6 Using the Bisectional Method
Iterations a b xi f(a) f(b) f(xi
)
1 1 2 1.5 –2 1 -0.75
2 1.5 2 1.75 –0.75 1 0.062
3 1.5 1.75 1.625 –0.75 0.0625 –0.359
4 1.625 1.75 1.6875 –0.3594 0.0625 –0.1523
5 1.6875 1.75 1.7188 –1523 0.0625 –0.0457
6 1.7188 1.75 1.7344 –0.0457 0.0625 0.0081
7 1.7188 1.7344 1.7266 –0.0457 0.0081 –0.018992 Numerical Methods in Chemical Engineering Using Python and Simulink
f = @(x)(x^2–3);
%a = 1;
%b = 2;
eps = 0.001;
m = (a+b)/2;
fprintf(‘\n The value of, after bisection method, m 
is %f\n’, m);
while abs(b-a)>eps
 if (f(a)*f(m))<0
 b=m;
 else
 a=m;
 end
 m = (a+b)/2;
end
y = m;
FIGURE 3.18 Simulink solution using the MATLAB function and the associated 
MATLAB coding of the bisection method programmed in MATLAB of the equation 
defined in Example 3.6.
FIGURE 3.17 Simulink solution using the ‘algebraic constraint’ of the equation defined in 
Example 3.6.Bracketing Numerical Methods 93
Python solution
The following program is the Python code for finding one of the roots of the equa￾tion exhibited in Example 3.6.
#Example 3.6
# Our f(x) function
def f(x):
 y = x**2–3
 return y
# Function to update R
def UpdateBisec(L, U):
 R = (L + U)/2
 return R
# The Bisection method (BSM) function
def BSM(f, L, U):
 R = UpdateBisec(L, U)
 while abs(f(R)) > 1e-3:
 if f(L) * f(R) < 0:
 U = R
 elif f(U) * f(R) < 0:
 L = R
 elif f(R) == 0:
 return R
 R = UpdateBisec(L, U)
 return R
Root= BSM(f, 0, 5)
print (“The calculated root is =”, root)
The results:
The calculated root is = 1.732177734375
3.3.2 false-PosItIoN method
False-position methods or regula-falsi is a root-finding technique that can be con￾sidered an advanced version of the bisection method. The regula-falsi method is a 
numerical method for estimating the roots of a polynomial. The value x replaces 
the midpoint in the bisection method and serves as the new approximation of a root 
f ( ) x . (Figure 3.19).
x f x x
x i i ( ) 1 1 − i i f x( ) i+1 = − −
f x( ) i i −1 − f x( )
Example 3.7 Regula False Method
Solve the following equation using the regula-falsi method up to three decimal 
places within the interval [0,1].
f ( ) x x = −3 4 1 x +
Verify the manual calculations with Simulink and Python programming of the 
regula-falsi method.94 Numerical Methods in Chemical Engineering Using Python and Simulink
Solution
Start with finding the function at 0 and 1.
f ( ) 0 0 = −3 4 0( ) + =1 1
f ( ) 1 1 = − ( )3 4 1( ) + =1 2−
Because the value of f ( ) 0 is positive and the value of f ( ) 1 is negative, accordingly, 
the root lies between 0 and 1.
af ( ) b b − f a( ) 0 2 ( ) − −1 1( ) x1 = = = 0.333 
f b( ) − f a( ) − −2 1
f ( ) x 3
1 = − ( ) 0.333 4( ) 0.333 + =1 −0.2962
Since the value is negative, the root lies between a and x1, and it will replace b
af ( ) x x x 1 1 − f a( ) 2 = ( )     f x( ) 1 − f a( )
Substitute the values
0( ) − − 0.2962 0.333( ) 1 x2 = = 0.2571 − − 0.296 1
f ( ) x2 = − ( ) 0.2571 3 4( ) 0.2571 + =1 −0.0115
Since the value of f ( ) x2 is negative; the root lies between a and x2 , accordingly,
af ( ) x x x 2 2 − f a( ) 3 = ( ) f x( ) 2 − f a( )
FIGURE 3.19 Graphical representation of regula-falsi method.Bracketing Numerical Methods 95
Substitution
0( ) − − 0.0115 0.2571( ) 1 x3 = = 0.2541 ( ) − − 0.0115 1
Find f ( ) x3
f ( ) x 3
3 = − ( ) 0.2541 4( ) 0.2541 + =1 0.0001
Because the value is positive, the root lies between x2 and x3
x 3 2 2 3
4 = f x( ) 2 3 − f x( )
x f ( ) x x − f x( )
Substitute and find x4
0.2541( ) − − 0.0115 0.2571( ) 0.0001 x4 = = 0.2541 − − 0.0115 0.0001
Figure 3.20 represents the Simulink block diagram using the algebraic constraints 
for finding the root of the equation required in Example 3.7.
An alternative way is to program the regula-falsi method using the MATLAB 
function built in the Simulink library. The Simulink block diagram shown in 
Figure 3.21 describes the solution of Example 3.7.
The following program is the MATLAB code associated with the MATLAB func￾tion using the regula-falsi method to solve the equation described in Example 3.7.
FIGURE 3.20 Simulink block diagram using the ‘algebraic constraints’ represents the solu￾tion of the equation required to find its root in Example 3.7.96 Numerical Methods in Chemical Engineering Using Python and Simulink
%Example 3.7
%Using False Position Method
% Find out the root of a function
function y = fcn(a, b)
% within the interval [a, b]
x0=a;
x1=b;
tol=0.001;
n=100;
f=@(x)x^3–4*x + 1;
y0=f(x0);
y1=f(x1);
i=1;
while i<=n
 x=x1-y1*(x1-x0)/(y1-y0);
 if abs(x-x1)<tol
 disp(‘Root of function:’);
 disp(x);
 break
 end
 i=i+1;
 y=x^3–4*x + 1;
 if y0*y1<0
 x0=x;
 y0=y;
 else
 x1=x;
 y1=y;
 end
end
y = x1;
FIGURE 3.21 Regula-falsi method for solving the equation required in Example 3.7.Bracketing Numerical Methods 97
Python solution
The following program is the Python code that uses the false-position method, 
representing the equation’s solution defined in Example 3.5.
# Example 3.7
# False Position method (FPM)
# import numpy as np
# Our f(x) function
def f(x):
y = x**3 - 4*x +1
return y
# Function to update R
def UpdateFalseP(f, L, U):
R = U - (f(U) * (L - U))/(f(L) - f(U))
return R
# The False Position method function
def FPM(f, L, U):
R = UpdateFalseP(f, L, U)
while abs(f(R)) > 1e-3:
if f(L) * f(R) < 0:
U = R
elif f(U) * f(R) < 0:
L = R
elif f(R) == 0:
return R
R = UpdateFalseP(f, L, U)
return R
Root = FPM(f, 0, 1)
print (“\n The calculated root = “, Root)
Output
The calculated root = 0.2542021166217058
3.3.3 rIdders’ method
In numerical analysis, Ridders’ method is a root-finding algorithm proposed by 
Ridders in 1979. The Ridders method is a process for finding the root based on the 
regula-falsi method that uses an exponential function to fit a given function bracketed 
between x0 and x1. The Ridders algorithm for the determination of the root of the 
equation f ( ) x = 0 is as follows:
 1. Assume suitable guessed values for 
f ( ) x f o × < ( ) x1 0
2. Find the midpoint, u, such that
= x x
u 0 1 +
298 Numerical Methods in Chemical Engineering Using Python and Simulink
3. Find a new approximation for the root
x x
x 0 1 + x x 1 0 − sin f x( ) 2 . o − f x( )1 f u( ) = +
2 2 f u 2 ( ) − f x( ) o f x( )1
4. If x2 reached the convergence conditions, stop.
5. Otherwise, assign new xo and x1 using the old values, where the end of the 
bracket is x2.
6. Repeat the loop until it converges (Figure 3.22).
Example 3.8 Applying Ridders Numerical Method
Solve the following equation using the Ridders method within the interval [0.0,0.5].
f ( ) x x = −3 4 1 x +
Verify the manual calculations with Simulink and Python programming of the 
Ridders method.
Solution
1. Assume suitable guessed values for 
f ( ) x f o × < ( ) x1 0
f ( ) x f o = = ( ) 0 1
f ( ) x f 1 = = ( ) 0.5 −0.875
FIGURE 3.22 Graphical illustration of Ridders’ method.Bracketing Numerical Methods 99
 Accordingly,
f ( ) x f o × = ( ) x1 1 × −( ) 0.875 = −0.875 < 0
 2. Find the midpoint, 
x x u 0 1 + 0 + 0.5 1 = = = 0.25
2 2
 3. Find a new approximation for the root
x x x 0 1 + x x 1 0 − sin f x( ) o − f x( ) 1 1 f u( ) 2 = + . 2 2 f u 2 ( ) − f x( ) o f x( ) 1
Substitute the values,
0 + 0.5 0.5 − 0 sin 1+ 0.875 0.0156 x2 = + . = 0.254175
2 2 0.01562 − − 1( ) 0.875
The new interval should depend on f ( ) x f 1 2 ( ) x < 0 an x2 should be the end of the 
interval,
f ( ) x f 0 = = ( ) 0 1
f ( ) x f 1 = = ( ) 0.5 −0.875
f ( ) x f 2 = = ( ) 0.25417 −0.00028
Since the new value ( ) x2 is close to zero, it is considered one of the roots of the 
equation.
Simulink Solution
Figure 3.23 represents the Simulink graphical programming of the Ridders 
numerical method utilizing the Simulink MATLAB function for solving the equa￾tion defined in Example 3.8. The following MATLAB code programs the Ridders 
technique.
The following program describes the MATLAB code of the Ridders method 
associated with the MATLAB function to solve the equation specified in 
Example 3.6.
%Example 3.8
%Using Ridders Method
% Find out the root of a function
function root = riddler(a, b)
 xl=a;
 xh=b;
 func=@(x)x^3–4*x + 1;
 fl=func(a);100 Numerical Methods in Chemical Engineering Using Python and Simulink
 fh=func(b);
 tol=0.001;
 N=100;
 root = 0;
for i = 1:N
 xm = 0.5*(xl+xh);
 fm = func(xm);
 s = sqrt(fm*fm - fl*fh);
 if s == 0
 return;
 end
 xnew = xm + (xm - xl)*sign(fl - fh)*fm/s ;
 root =xnew;
 if (xnew-xm) <tol
 return
 end
 end % end for
 root = xnew;
Python Solution
The following program deals with the Ridders numerical method using Python 
language to solve the equation specified in Example 3.8.
# Example 3.8
‘‘‘ Finds a root of f(x) = 0 with Ridder’s method.
The root must be bracketed in (a, b).
‘‘‘
from numpy import sign
from numpy import sqrt
FIGURE 3.23 Simulink solution utilizing Ridder’s method to solve the equation defined in 
Example 3.8.Bracketing Numerical Methods 101
xl=0.0
xh=0.5
def func(x):
 return x**3–4*x + 1
fl=func(xl)
fh=func(xh)
tol=0.001
N=100
root = 0;
N=100
for i in range(0, N):
 xm = 0.5*(xl+xh)
 fm = func(xm)
 s = sqrt(fm*fm - fl*fh)
 if s == 0:
 exit()
 xnew = xm + (xm - xl)*sign(fl - fh)*fm/s
 if (xnew-xm) <tol:
 exit()
# print the root
print (‘The Root is‘, xnew)
The executed result
The Root is: 0.2541753744434931
3.4 SUMMARY
Graphical methods are a straightforward way to estimate the root of equation, 
f ( ) x = 0. We can approximate the root if we plot the function f ( ) x = 0 and note 
where it intersects the x-axis. The bracketing methods are based on the mean value 
theory, and the bisection method is a bracketing type of the root-finding method. The 
bisection method decreases the error by a constant factor by each iteration, referred 
to as linear convergence. The Ridders method is a root-finding algorithm based on 
the false-position method and uses an exponential function to approximate the root 
of a continuous function successively.
3.5 PROBLEMS
 1. Using the graphical method, find the roots of the following second-order 
y x = −2 4 3 x +
 Answer: (1, 3)
 2. Determine the root of the given equation using the bisectional method 
f ( ) x x = −2 3
 Answer: (1.7344)102 Numerical Methods in Chemical Engineering Using Python and Simulink
 3. Use the bisectional method to solve the following nonlinear equation within 
f ( ) x x = + 2
   2x – 8 
 Answer: (1.75)
 4. Using the false-position method, find the solution of the following nonlinear 
f ( ) x x = −3 x −1
 Answer: (1.325)
 5. Find the roots of the following nonlinear equation using the bisection 
f ( ) x x = −3 5
 Answer: (1.71)
 6. Consider finding the root of the following nonlinear equation using the 
f ( ) x e = − −x
( ) 3.2    sin c ( ) x x  0.5  os( )
 Answer: (3.2969)
 7. Use the false-position method to find the roots of the nonlinear equation. 
x3 2 − + 6 1 x x1 6 − = 0
 Answer: (3)
 8. Find the roots of the following equation using the graphical method.
f ( ) x e = −x sin 0 ( ) x =
 9. Find the roots of the following equation using the graphical method.
f ( ) x x = + ln( ) x = 0
10. Find the roots of the following equation using the graphical method within 
the interval [–1 1].
f ( ) x x = −2 tan 0 ( ) x =
REFERENCE
 1. William, H. Press, Saul A. Teukolsky, William T. Vetterling, and Brian P. Flannery, 103
4 Open Numerical 
Methods for Solving 
Systems of Nonlinear 
Equations
An equation is said to be nonlinear when it involves terms of a degree higher than 1 
in an unknown quantity. Several methods can be used to numerically solve a nonlin￾ear system of equations, and Newton’s method is the most feasible method to solve 
systems of nonlinear equations. This chapter studied open root-finding methods such 
as the method of substitution, fixed-point iteration method, Newton-Raphson (NR) 
method, secant method, and Muller’s method.
LEARNING OBJECTIVES
1. Use the method of substitution for solving simultaneous equations.
2. Utilize the fixed-point iteration method to solve equations of the form 
f x( ) = 0.
3. Employ the NR method for solving equations numerically.
4. Apply the secant method for root finding. 
5. Apply Muller’s method to solve equations of the form f x( ) = 0.
4.1 INTRODUCTION
Nonlinear algebraic equations are one of the subjects in mathematics. A system of 
nonlinear equations is a system of two or more equations in two or more variables 
containing at least one equation that is not linear. Any equation that cannot be writ￾ten in the following form is considered nonlinear [1].
Ax + + By C = 0 (4.1)
Numerical methods can solve root exploration in complicated nonlinear equations, 
and different methods are available to solve the nonlinear equations. This chapter 
presents the open numerical methods, including the method of substitution, the secant 
method, the fixed-point iteration method, the NR method, and Muller’s method.
DOI: 10.1201/9781003360544-4104 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Examples of nonlinear equations:
 1. One-dimensional equations
x 2 − + 6 9 x = 0 (4.2)
x − = sin 0 ( ) x (4.3)
 2. Two-dimensional equations
(1 0 − − x y) 2 3 x = (4.4)
y x 2 2 + − 1 0 = (4.5)
The open methods do not restrict the root from remaining trapped in a closed inter￾val. Accordingly, they are not as robust as bracketing methods and can divert, and 
they are more difficult to obtain compared to closed methods. The most popular are 
Newton’s method, the secant method, and Muller’s method.
4.2 METHOD OF SUBSTITUTION
The substitution method used previously for solving linear equations can still be used 
for nonlinear systems. We solve one equation for one variable and then substitute the 
result into the second equation to solve for another variable. The method of substitu￾tion involves three steps:
 1. Solve one equation for one of the variables.
2. Substitute this expression into the other equation and solve.
 3. Resubstitute the value into the original equation to find the corresponding 
Suppose we have the following algebraic equations and we want to use the substitu￾tion method to solve the two algebraic equations:
y x − = 2 8 (4.6)
y x = −5 (4.7)
1. Solve the first equation for y.
y x = + 8 2 (4.8)Open Numerical Methods 105
 2. Substitute this expression into the second equation.
(8 2 + = x x ) 5 − (4.9)
 3. Rearrange.
8 − = 5 2− − x x = −3x (4.10)
3 3 = − x
 (4.11)
x = −1
 4. Resubstitute the value of 
y x − = 2 8 (4.12)
y − − 2 1 ( ) = 8
 (4.13)
y = 6
Example 4.1 Applying Method of Substitution
Solve the following two equations using the method of substitution.
y x = +1
y x = +2 1
Support the manual calculation with Simulink and Python programming.
Solution
Solve for x
x = −y 1
Substitute in the second equation to solve for y
y y = − ( ) 1 1 2 +
Simplify
y y = −2 2 2 y +106 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Rearrange
0 3 = − y y 2 + 2
Factorize
( y y − − 2 1 )( ) = 0
Solving for y, gives y = 1 and y = 2.
Substitute each value of y in the first equation to find the value of x.
For y = 1,
x − =1 1−
x = 0
For y = 2,
x − = 2 1−
x = 1
Accordingly, the solutions are (0,1) and (1,2).
Simulink Solution
Figure 4.1 represents the Simulink block diagram using the MATLAB function 
dragged from the Simulink/User-Defined Functions library [2]. The MATLAB code 
is associated with the MATLAB function. The MATLAB function is attached to two 
FIGURE 4.1 Graphical demonstration of the solution of equation present in Example 4.1.Open Numerical Methods 107
ports representing the lower and upper root boundaries, a, and b, respectively. 
The exit port is attached to a Display block showing the value of the root within 
the selected interval. While Figure 4.2 illustrates the plot of the two equations in 
Example 4.1, the intersection of the two curves represents the root of equations 
( 1 x = ).
The MATLAB code embeds the Simulink function of Example 4.1 as follows:
% Example 4.1 Graphical method
function R = fcn(a, b)
R1=0;
for x = a:b
y1 = x+1;
y2 = x.^2+1;
if abs(y2-y1)<0.001
R1= x;
end
end
x= linspace(a, b);
y1 = x+1;
y2 = x.^2+1;
plot (x, y1,’b’, x, y2,’r’, ‘LineWidth’, 1.5)
txt1 = ‘\leftarrow y_1 = x+1’;
txt2 = ‘\leftarrow y_2 = x^2+1’;
text(-0.8,0,txt1,’FontSize’, 15);
text(-0.8,2.1,txt2,’FontSize’, 15);
ylabel(‘y_1, y_2’);
xlabel (‘x’);
grid on;
R=R1;
FIGURE 4.2 Plot of y x = + 1 and y x = +2 1 demonstrating the graphical root finding of 
the equation defined in Example 4.1.108 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Python Solution
The following program is the Python code used to solve the two nonlinear alge￾braic equations defined in Example 4.1. Running the program yields the following 
values of the two roots [3].
# Example 4.1
# importing library sympy
from sympy import symbols, Eq, solve
# defining symbols used in equations
# or unknown variables
x, y = symbols(‘x, y’)
# defining equations
eq1 = Eq((x-y), -1) # x-y =1
eq2 = Eq((y-x**2), 1) # y-x^2=1
# solving the equation
print(“Values of 2 unknown variables are as follows:”)
print(solve((eq1, eq2), (x, y)))
The results are as follows:
Values of 2 unknown variables are as follows:
[(0, 1), (1, 2)]
4.3 FIXED-POINT ITERATION METHOD
The fixed-point iteration method is a numerical analysis technique for finding roots 
with fixed-point iteration. This method frequently uses fixed-point concepts to cal￾culate the solution to a given equation. The fixed point is a point in the function f as 
f ( ) x x = . The given function is algebraically transformed into the form f ( ) x x = ; for 
example, assume a function f ( ) x = 0, rewrite x as of xn n +1 = x . Label the left side as 
xn+1 and right side with xn, choose x1, and plug it into the equation. Repeat the iteration 
until it converges, as shown in the graphical presentation of Figure 4.3.
The fixed-point iteration method employs the principle of a fixed point in a 
repeated approach to compute the solution of the desired equation. It is a point in the 
function g x( ) domain. The desired function in the fixed-point iteration technique is 
algebraically converted in the form of g x( ) = x.
Consider solving the equation: f ( ) x = 0. Set the equation as x = g x( ). Choose 
g x( ) such as:
` g x ′( ) < = 1  at x xo (4.14)
where xo is the initial guess called the fixed-point iteration approach. Then the itera￾tive method is applied by successive approximation given by
xn n = − g x( ) 1 (4.15)Open Numerical Methods 109
That is
x1 2 = = g x( ) o , x g( ) x1 (4.16)
Adhere to the following approach:
1. Choose the initial value 
( ) 0 o, is the average of 
2. Express the given equation in the form 
g x ′( ) < = 1 at x xo (4.17)
3. Apply the successive approximations
xn n = − g x( ) 1 (4.18)
For the continuous function, f ( ) x = 0, there will be a sequence of xn, that converges 
to the approximate solution.
Example 4.2 Application of the Fixed-Point Iteration Method
Using the fixed-point iteration method, find the first approximate root of the fol￾lowing equation up to four decimal places.
f ( ) x x = − 2 2 3 x − = 5 0
Support the manual calculation with Simulink/MATLAB and Python programming 
of the fixed-point iteration method.
FIGURE 4.3 Graphical representation of the fixed-point iteration method.110 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solution
 1. Follow the solution approach to finding the value of 
 2. Find 
g x ′( ) < = 1  at x xo
From the given function 2 2 x x 3 − − 5,
x 1/
3 2 5 +  2 5 x +  3
x = → =    x   = g x( ) 2  2 
To find xo ,
 + ′( ) 1 2 5 x 
−2/3
g x =   < 1 
3  2 
Solve
2
1 2 5 x + 3
g x ′( )   −
=   < 1
3  2 
x = 1.5 satisfies | | g x '
( ) < 1
Applying the iterative method (Table 4.1),
xn n = − g x( ) 1 , for n = 1 6 to 
Start with xo
The approximate root of f ( ) x by the fixed-point iteration method is 1.6006.
= 1.5
TABLE 4.1
The Fixed-Point Iteration Method to Solve the Equation in Example 4.2
n
1
2






g x( )
1/3
2 1.5 ( ) + 5 
 2 
1/3
2 1.5874 ( ) + 5 
 2 
x
1.5874
1.5989
3 


1/3
2 1.5989 ( ) + 5 
 2 
1.60037
4 


1/3
2 1.60037 ( ) + 5 
 2 
1.60057
5
6 





 (
1/3
2 1.60057 ( ) + 5 
 2 
1/3
2 1.60059) + 5
2
1.60059
1.600597
 Open Numerical Methods 111
Simulink Solution
The Simulink block diagram demonstrating the solution of Example 4.2 is shown in 
Figure 4.4. The MATLAB code associated with the MATLAB function (available in 
the Simulink/User-Defined Functions) relates to three ports, start point ( ) xo , num￾ber of iterations ( ) niter , and the allowable error (err). The output port of the function 
relates to the Display block showing the root of the desired equation.
The following program is MATLAB code that describes the solution of the non￾linear algebraic equation using the fixed-point iteration method. The following 
MATLAB code is implanted in the Simulink MATLAB function.
% Example 4.2
function Res = fcn(x0,n_iter, err)
g = @(x) ((2*x + 5)/2)^(1/3);
p0 = x0; %enter initial approximation
n = n_iter; % enter no. of ierations
tol = err; %tolerance
i = 1;
p=0;
while i <= n
p = g(p0);
if abs(p-p0) < tol
break;
else
i = i+1;
p0 = p;
end
end
Res = p;
FIGURE 4.4 Simulink program uses the fixed-point iteration numerical analysis method to 
solve the desired equation in Example 4.2.112 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Python Solution
The following Python code is programmed to utilize the fixed-point iteration 
method to solve the equation specified in Example 4.2.
# Example 4.2 Fixed Point Iteration Method
# input the following data
x0 = 1.5 #Enter Guess
e = 0.0001 #Tolerable Error
N = 6 #Maximum Number of Steps
# The required function
def f(x):
return 2*x**3-2*x -5
# Re-writing f(x)=0 to x = g(x)
def g(x):
return ((2*x + 5)/2)**(1/3)
# Implementing Fixed Point Iteration Method
print(‘\n\n=== Fixed Point Iteration Method ===\n’)
def fp(x0, e, N):
i = 1
flag = 1
condition = True
while condition:
x1 = g(x0)
print(‘%d x1 = %0.6f f(x1) = %0.6f’ % (i, x1, f(x1)))
x0 = x1
i = i + 1
if i > N:
flag=0
break
condition = abs(f(x1)) > e
if flag==1:
print(‘\nThe required root is: %0.8f’ % x1)
else:
print(‘\nNot Convergent.’)
# Starting Fixed point iteration method
res= fp(x0,e, N)
Execution
Running the Python program produces the results shown below, where the value 
of f ( ) x1 is close to zero and the discrepancy between two consecutive values is 
too low.
=== Fixed Point Iteration Method ===
1 x1 = 1.587401 f(x1) = -0.174802
2 x1 = 1.598880 f(x1) = -0.022957
3 x1 = 1.600375 f(x1) = -0.002991
4 x1 = 1.600569 f(x1) = -0.000389
5 x1 = 1.600595 f(x1) = -0.000051
The required root is: 1.60059476Open Numerical Methods 113
Example 4.3 Application of Fixed-Point Iteration
Find the root of the following nonlinear algebraic equation using the fixed-point 
iteration method.
x 2 − −x 1 0 =
Support the manual calculations with the Simulink and Python programming of 
the fixed-point iteration method.
Solution
Rearrange the equation such that x = …
1 x = +1 x
Label the left side as xn+1 and right side with xn
1 xn+1 = +1 xn
Choose 
x1 = 2
1 x1 = +1 = 1.5
2
1 1 x2 = +1 = +1 = 1.666 x1 1.5
Repeat
1 1 x3 = +1 = +1 = 1.666 x2 1.5
1 1 x4 = +1 = +1 = 1.6 x3 1.666
1 1 x5 = +1 = +1 = 1.625 x4 1.6
1 1 x6 = +1 = +1 = 1.6125 x5 1.625
Simulink Solution
The fixed-point iteration method is coded with MATLAB and linked to the Simulink 
MATLAB function available under the Simulink/User-Defined Functions library. 
Figure 4.5 demonstrates the Simulink graphical programming using the MATLAB 
function techniques. The inlet port of the MATLAB function is connected to a 114 Numerical Methods in Chemical Engineering Using Python® and Simulink®
constant block that shows the initial guess ( ) xo , and the exit port is connected to a 
Display block showing the numerical value of the calculated root.
The following program is the MATLAB code programmed for the fixed-point 
iteration method in MATLAB. The code is placed in the Simulink MATLAB function.
% Exmaple 4.3
% Fixed point iteration method
function y =fcn(x0)
x=x0;
TOL = 0.001;
N = 100;
% set the iteration index
i=1;
err = 1;
% Start the iteration
while (i<N && err>TOL)
i = i +1;
x = 1 + 1/x;
err = abs (x-1-1/x);
end
% display the results
y=x;
An alternative way of using Simulink is utilizing the Algebraic Constraint block 
from the Simulink/Math operation library and the other needed blocks, as demon￾strated in Figure 4.6. After connecting the blocks, the figure represents the solu￾tion of the equation specified in Example 4.3. The initial guess must be changed; 
accordingly, double-click on the “Algebraic Constraint” block, and set the initial 
guess to 2 to get the root value of 1.618.
FIGURE 4.5 Simulink block diagram utilizing the fixed-point iteration method to solve the 
equation specified in Example 4.3.Open Numerical Methods 115
Python Solution
The following Python program uses the fixed-point iteration method to solve 
Example 4.3. The executed results follow the program.
# Example 4.3 Fixed Point Iteration Method
import numpy as np
import matplotlib.pyplot as plt
def f(x):
return x*x - x -1
# Input Section
x0 =1.5 # Enter Guess
e = 0.0001 # Tolerable Error
N = 100 #Maximum Step
# Re-writing f(x)=0 to x = g(x)
def g(x):
return (x+1)/x
# Implementing Fixed Point Iteration(FIP) Method
def FIP(x0, e, N):
print(‘\n\n*** FIXED POINT ITERATION ***’)
step = 1
flag = 1
condition = True
while condition:
x1 = g(x0)
print(‘Iteration-%d, x1 = %0.6f and f(x1) = %0.6f’ % 
(step, x1, f(x1)))
x0 = x1
step = step + 1
if step > N:
flag=0
break
condition = abs(f(x1)) > e
if flag==1:
print(‘\nRequired root is: %0.8f’ % x1)
FIGURE 4.6 Simulink solution using the Algebraic constraint block to solve the equation 
specified in Example 4.3.116 Numerical Methods in Chemical Engineering Using Python® and Simulink®
plt.plot (x1,0, ‘ro’)
plt.text(x1,-0.5, ‘The root’)
else:
print(‘\nNot Convergent.’)
# Starting the Fixed Point Iteration mehtod
res=FIP(x0,e, N)
x=np.linspace(0,3,20)
plt.plot(x, f(x), x, x, ‘r’)
plt.xlabel(‘x’, fontsize = 15)
plt.ylabel (‘y’, fontsize = 15)
plt.grid(True)
After running the Python program, you should get the following results and the 
plot shown in Figure 4.7.
*** FIXED POINT ITERATION ***
Iteration-1, x1 = 1.666667 and f(x1) = 0.111111
Iteration-2, x1 = 1.600000 and f(x1) = -0.040000
Iteration-3, x1 = 1.625000 and f(x1) = 0.015625
Iteration-4, x1 = 1.615385 and f(x1) = -0.005917
Iteration-5, x1 = 1.619048 and f(x1) = 0.002268
Iteration-6, x1 = 1.617647 and f(x1) = -0.000865
Iteration-7, x1 = 1.618182 and f(x1) = 0.000331
Iteration-8, x1 = 1.617978 and f(x1) = -0.000126
Iteration-9, x1 = 1.618056 and f(x1) = 0.000048
Required root is: 1.61805556
4.4 NR METHOD
The NR method is utilized to find an approximate root of a real-valued function 
( 0 f x( ) = ). The method uses a continuous and differentiable function that can be 
approximated by a straight-line tangent, as graphically demonstrated in Figure 4.8. 
We make an initial guess for the desired root.
FIGURE 4.7 Python programming of the fixed-point iteration method to solve the equation 
present in Example 4.3.Open Numerical Methods 117
Find points a and b, such that a < b, and f ( ) a f ⋅ < ( ) b 0. The NR method finds the 
tangent to the function f ( ) x at x = xo and extrapolates it to intersect the x-axis to get x1. 
The intersection point represents the new approximation to the root, and the proce￾dure is repeated until convergence is obtained.
f x( ) xn 1 = − x n
+ n (4.19) f x ′( ) n
The procedure of finding the root using the NR method:
 1. Find points 
2. Select an interval [
3. Find 
 4. Find 
f x( ) x1 = − x o
o (4.20) f x ′( ) o
5. If 
 6. Repeat steps 3 and 4 until 
Example 4.4 NR Method for Single Polynomial Equation
Use the NR method to find the root of the following quadratic equation.
f ( ) x x = −3 x − =1 0
Validate the manual root finding with Simulink and Python programming of the 
NR method.
FIGURE 4.8 Graphical demonstration of NR method for root finding.118 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solution
The function f ( ) x ,
f ( ) x x = −3 x −1
The slope of f ( ) x is the f ′( ) x ,
f ′( ) x x = − 3 1 2
Find the interval where the root lies between the intervals. Try different values of x
until the function f ( ) x gets consecutive negative and positive signs.
The root lies within intervals 1 and 2. The first initial guess is
1 2 + xo = = 1.5
2
The first iteration
f x( ) 3 0 1.5 − − 1.5 1 0.87 x1 = − xo = − 1.5 1.5 1.35
f x ′( ) 3* 1.5 2 = − = o ( ) −1 5.7
Repeat the iterations until the value of xi is almost constant, as shown in Table 4.2.
The approximate root is 1.3247.
Simulink Solution
With Simulink, the root can be found in two ways: the first is by using the “Algebraic 
Constraint” block along with other required blocks such as Multiplication, 
Constant, Sum, and Display, as illustrated in Figure 4.9. The second method uses 
the Simulink “Matlab function” block available in the user-defined functions library 
(Figure 4.10). The MATLAB function requires writing a MATLAB code encrypting 
the NR method. The associated MATLAB program with the MATLAB function 
utilizes the NR method.
x 0 1 2
f (x) –1 –1 5
TABLE 4.2
NR Method for Finding the Root of the Equation Given in Example 4.4
S. No. xo f (x0) f’ (xo) xi
1 1.5 0.875 5.75 1.3478
2 1.3478 0.10068 4.44991 1.3252
3 1.3252 0.00206 4.26847 1.3247
4 1.3247 0 4.26463 1.3247Open Numerical Methods 119
FIGURE 4.10 Simulink block diagram utilizing the MATLAB function and NR method 
representing the solution of the equation defined in Example 4.4.
FIGURE 4.9 Root finding using the Simulink Algebraic constraint block to solve the qua￾dratics equations defined in Example 4.4.120 Numerical Methods in Chemical Engineering Using Python® and Simulink®
% Example 4.4
function y = fcn(x, x_old)
%x = initial guess;
%x_old = previous x;
iter = 0;
while abs(x_old-x) > 10^-3 && x ~= 0
x_old = x;
x = x - (x^3- x-1)/(3*x^2-1);
iter = iter + 1;
end
y=x;
Python Solution
The following program is the Python code that uses the NR method to solve 
the quadratic equation in Example 4.4. The program is followed by the results 
implemented.
# Example 4.4
# Newton Raphson
# The function is x^3- x -1
def func(x):
 return x**3- x -1
# Derivative of the above function
def derivFunc(x):
 return 3 * x**2-1
# Function to find the root
def newtonRaphson(x):
 h = func(x) / derivFunc(x)
 while abs(h) >= 0.0001:
 h = func(x)/derivFunc(x)
 
 # x(i+1) = x(i) - f(x) / f’(x)
 x = x - h
 print (“ “)
 print(“The value of the root is : “, “%.4f”% x)
# Driver program to test above
x0 = 5 # Initial values assumed
newtonRaphson(x0)
Execution result:
The value of the root is: 1.3247
Example 4.5 Application of NR Method
Find the root of the following quadratic nonlinear algebraic equation using the NR 
approach, and an initial guess value equals 4.
f ( ) x x = −2 7
Confirm the manual root finding with Simulink and Python programming of the 
NR method.Open Numerical Methods 121
Solution
Derivation of a nonlinear algebraic equation:
f ′( ) x x = 2
Using the NR method, the first iteration (starting with x= 4):
f x( ) 2 0 4 7 − 9 x1 = − xo = − 4 = − 4 = 2.875
f x ′( ) o 2 4( ) 8
The second iteration uses the new x1 = 2.875
f x( ) 2 1 2.875 − 7 1.266 x2 1 = − x = − 2.875 = − 2.875 = 2.655
f x ′( ) 1 2( ) 2.875 5.75
Repeat the iterations until the value of xi is almost constant, as shown in Table 4.3. 
The table shows that after four iterations, the value of 2.64575 is the approximate 
value of one of the roots.
Simulink Solution
Figure 4.11 is the Simulink block diagram utilizing NR’s method for solving the 
equation required in Example 4.5. The MATLAB code incorporated the MATLAB 
function block as follows.
The following MATLAB code built into the MATLAB function block is pro￾grammed in the NR method to solve the equation specified in Example 4.5.
%Example 4.5
function y = fcn(x, x_old)
%x = initial guess;
%x_old = previous x;
iter = 0;
while abs(x_old-x) > 10^-3 && x ~= 0
x_old = x;
x = x - (x^2–7)/(2*x);
iter = iter + 1;
end
y=x;
TABLE 4.3
Solution of Example 4.5 Using the NR Method 
S. No. xo f(x0) f’(xo) xi
1 4.00000 9.00000 8.00000 2.87500
2 2.87500 1.26560 5.75000 2.65489
3 2.65489 0.04844 5.30978 2.64577
4 2.64577 0.0000832 5.29153 2.64575122 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Python Solution
The below program is written in Python, employing the NR method to solve the 
nonlinear algebraic equation defined in Example 4.5. The implementation result 
follows the program.
# Example 4.5
# Newton Raphson
# The function is x^3- x -1
def func(x):
 return x**2–7
# Derivative of the above function
def derivFunc(x):
 return 2 * x
# Function to find the root
def newtonRaphson(x):
 h = func(x) / derivFunc(x)
 while abs(h) >= 0.0001:
 h = func(x)/derivFunc(x)
 
FIGURE 4.11 Simulink block diagram utilizing the NR method to solve of equation defined 
in Example 4.5.Open Numerical Methods 123
4.5 NR MULTIVARIABLE
The multivariate NR method directly extends the single variable method. While the 
single variable method solves a single equation of the form f ( ) x = 0, the multivariate 
version solves a system of more than one equation of the form
f1 1 ( ) x x ,  2 3 , ,, x x … =   , n n −1   0 x
f2 1 ( ) x x ,  2 3 , ,, x x … =   , n n −1   0 x
f3 1 ( ) x x ,  2 3 , ,, x x … =   , n n −1   0 x
fn n ( ) x x 1 2 ,  , ,, x x 3 1 … =   , −   0 xn
The multivariable method formula is as follows:
 −1
∂ f1 1 ∂ f  k k +1     x  k
   x   ∂ x ∂ y   f    =   −  1
 (4.21) y y      ∂  f2 2 ∂ f   f   2
 ∂ x ∂ y   
Example 4.6 Multivariate NR Method
Consider the system of two nonlinear algebraic equations. Find the values of the 
unknown variables using the multivariate NR method.
2 8 x x 3 + − 4 4 y =
4x y − − 3 1 y2 =
Validate the manual root finding with Simulink and Python programming of the 
multivariate NR method.
Solution
Rewrite the equations in the following form:
f 3 1 ( ) x y, 4 = − 8 2 x x − + 4 0 y =
f2 ( ) x y, 1 = − 4 3 x y + + y2 = 0
Take initial guess ( x y, ) = ( ) 0.5,0.5
 f 
−1
∂ 1 1 ∂ f k k +1      k
 x   x   ∂ x ∂ y    f    =   − 1
     y  y ∂ ∂  f   f  2 2f   2 
∂ x ∂ y 
 
124 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Take the derivatives of functions 1 and 2
 k+1  −1 k k
 x     0.5 8 6 4     − − x 2   f    =   −    1
  y    0.5  − + y f 
 4 3 2 
  2 0.5,0.5
Find the values of f1 and f2
 −1
 x   0.5   8 6x 2 4  − −  1.75    =   −      y    0.5  − + 0.75 
 4 3 2y 
  
Substitute values of x and y
 x   0.5   1
−9.5 4 
−
 1.75    =   − y     0.5 4 4 0.75      −   
Find the inverse of the matrix
1 x = + 0.5 ( ) 4 × − 1.75 4 × = 0.75 0.6818
22
1
y = + 0.5 ( ) 4 × − 1.75 9.5 × = 0.75 0.4943
22
 x   0.5  1  4 4−   1.75    =   −  y      −   0.5  22  4 9.5   0.75  
Continue the iteration as before till there is a convergence.
Simulink Solution
Figure 4.12 presents the Simulink block diagram for solving Example 4.6 using the 
Simulink Algebraic constraint block.
Python Solution
The following Python program shows how to use the NR algorithm to find the 
roots of a multivariate system of equations. The NR algorithm is relatively simple 
and very powerful for finding the roots of a real-valued function that has a continu￾ous derivative within a given range
# Example 4.6 Multivariant Newton-Raphson
import numpy as np
# differentiate (Jacobian)
def jacobian_Ex(xy):
x, y = xy
return [[6*x**2 + 8, -4],
[4, -3-2*y]]
# add your equations
def func_Ex(xy):
x, y = xy
return [2*x**3+8*x-4*y-4, 4*x-3*y-y**2-1]Open Numerical Methods 125
# From the exercise:
def iter_newton(fun, x_init, jacobian):
max_iter = 50
epsilon = 1e-8
x_last = x_init
for k in range(max_iter):
# Solve J(xn)*(xn+1- xn) = -F(xn):
J = np.array(jacobian(x_last))
F np.array(fun(x_last)) =
diff = np.linalg.solve(J, -F)
x_last x_last diff = +
# Stop condition:
if np.linalg.norm(diff) < epsilon:
print(‘\nNumber of iterations:’, k)
break
else: # only if the for loop end ‘naturally.’
print(‘not converged’)
return x_last
# Results:
xy_sol = iter_newton(func_Ex, [1.0,2.0], jacobian_Ex)
print(‘\nSolution (roots)\n [x, y]:\n’, xy_sol)
print(‘\nresubstitution of the roots\n [f(x), f(y)]:\n’, 
func_Ex(xy_sol))
Execution results:
Number of iterations: 5
Solution (roots)
FIGURE 4.12 Simulink solution equation defined in Example 4.6.126 Numerical Methods in Chemical Engineering Using Python® and Simulink®
[x, y]:
[0.66520106 0.47757534]
resubstitution of the roots
[f(x), f(y)]:
[-8.881784197001252e-16, -1.1102230246251565e-16]
4.6 SECANT METHOD
The secant method is a variation of Newton’s method when evaluating the derivatives 
is complex. Imitated locally by the linear function g x( ), which is the secant to f ( ) x , 
the root of g x( ) is taken as an improved approximation to the root of the nonlinear 
function f ( ) x . The secant method is numerical analysis, a root-finding technique 
that uses a succession of roots of secant lines to better approximate the root of a 
function f ( ) x . The method is a finite difference approximation of Newton’s method 
(Figure 4.13).
 x x
x 1  i i +1 = − x  i i − −
 f x( )i (4.22)
 f x( )i i − f x( ) −1    
As shown in Figure 4.2 ( 1 i = ),
 x x
x 1 0 −  2 1 = − x  f x( ) 1    1
 f x( ) − f x( )  (4.23) o 
In general, applying a backward approximation, the secant algorithm to find the root 
becomes
( ) x x
x x n n 1 2 − n n = − − −
−1 f x( ) 1 f x( ) n n 1 2 − f x( ) n− (4.24) − −
FIGURE 4.13 Graphical explanation of the numerical root finding using the secant method.Open Numerical Methods 127
for i = 2,
( ) x x
x 1 0 − 2 1 = − x f x( ) 1 (4.25) f x( ) 1 0 − f x( )
Figure 4.13 is a graphical demonstration of the secant method for root finding. The 
method is like the bisectional method, which divides each interval by choosing the 
midpoint; in contrast, the secant method divides each interval by the secant line con￾necting the endpoints. Providing that f ( ) x is continuous on [a, b] and f ( ) a f ( ) b < 0, 
the secant method always converges to a root for f ( ) x = 0. Considering the connec￾tion of the endpoint values (a f , ( ) a ) and (b f , ( ) b ). The line connecting these two 
points is called the secant line (Figure 4.14) and is given by the following formula:
f b( ) − f a( ) y = ( ) x a − + f a( ) (4.26) b a −
The point at which the secant line crosses the x-axis is
f b( ) − f a( ) 0   = ( ) x a − + f a( ) (4.27) b a −
Solving for x
− = − ( ) b a
x a f a (4.28) f b( ) − f a( )
FIGURE 4.14 Graphical description of the secant method.128 Numerical Methods in Chemical Engineering Using Python® and Simulink®
4.6.1 secaNt method advaNtages
1. It uses the recent approximation roots to find new approximations instead of 
being bounded by the interval to enclose the root.
2. The secant method converges faster than the bisection method.
4.6.2 secaNt method draWbacks
 1. The secant technique does not always guarantee convergence.
 2. Since convergence is not assured, a maximum number of iterations is imple
Example 4.7 Application of the Secant Method
Compute the following function in two iterations using the secant method, in 
which the real roots of the equation f ( ) x lie in the interval (0,1).
f ( ) x x = −3 5 1 x + = 0
Confirm the manual rooting find process using Simulink and Python programming 
of the secant method.
Solution
Using the given interval
xo = = 0,  0 f x( ) 0 f ( ) = 1
x1 1 = = 1,  1 f x( ) f ( ) = −3
Hence,
f ( ) a f ( ) b < 0
Using the secant method formula:
( ) x x − o 1 0 − 2 1 = − 1 ( ) x x f x( ) = −1 f ( ) 1 1 − 1 f x( ) f x( ) o f f ( ) 1 0 − ( )
( ) 1 0 − x2 1 f ( ) 1 = − 1 1 = − ( ) − = 3 0.25
f f ( ) 1 0 − ( ) − −3 1
The second approximation
( ) x x 2 1 − ( ) ( ) 0.25 −1 x3 2 = − x f x 0.25 0.25 ( ) 2 1 ( ) 2 = − f ( ) f x − f x f f ( ) 0.25 − ( ) 1
( ) 0.25 −1 x3 = − 0.25 ( ) –0.234 = 0.1866
–0.234 − −( ) 3
Since f ( ) x3 = 0.073, more trials are required until f ( ) xi is close to zero.Open Numerical Methods 129
Simulink Solution
Figure 4.15 is the Simulink block diagram representing the solution of the equation 
specified in Example 4.7. The MATLAB code follows the diagram representing the 
Secant method implants in the Simulink MATLAB function.
The embedded MATLAB code programmed the secant method to solve the 
equation defined in Example 4.7.
% Example 4.7
function y = fcn(a, b, n)
f=@(x)(x^3–5*x + 1);
xn1=a;
xn2=b;
xn = (xn2*f(xn1) - xn1*f(xn2))/(f(xn1) - f(xn2));
k = 0;
while (k < n)
k = k + 1;
xn2 = xn1;
xn1 = xn;
xn = (xn2*f(xn1) - xn1*f(xn2))/(f(xn1) - f(xn2));
end
y = xn;
Python Solution
The following is the Python code utilizing the secant method in solving the equa￾tion specified in Example 4.7.
# Example 4.7
# The Secant method function (SM)
FIGURE 4.15 Simulink block diagram using the secant method describing the solution of 
the equation defined in Example 4.7.130 Numerical Methods in Chemical Engineering Using Python® and Simulink®
import numpy as np
import matplotlib.pyplot as plt
# Our f(x) function
def f(x):
y = x**3–5*x + 1
return y
def SM(f, x1, x2):
while abs(f(x1)) > 1e-6:
fx1 = f(x1)
fx2 = f(x2)
xtemp = x1
x1 = x1- (x1- x2) * fx1/ (fx1- fx2)
x2 = xtemp
return x1
#call the SM function with inital guess, x1, x2
Root = SM(f, 2, 4)
print (Root)
x =np.linspace (0, 5)
plt.plot(x, f(x), Root, f(Root), ‘ro’, Root)
plt.xlabel (“x”)
plt.ylabel(“y”)
plt.grid()
The data generated from running the Python code is plotted in Figure 4.16.
Example 4.8 Secant Method to Solve a Cubic Equation
Using the secant method, compute the root of the equation in the interval [0, 1]. 
Make sure that the root should be correct to three decimal places.
f ( ) x x = −3 5 1 x + = 0
Validate the manual root finding with Simulink and Python programming of the 
secant method for a cubic equation.
FIGURE 4.16 Python solution using the secant method of the equation defined in 
Example 4.7.Open Numerical Methods 131
Solution
The equation is bounded by the interval [0,1].
xo o = = 0,  1 f x( ) , x f 1 1 = = 1,  3 ( ) x −
 x x x 0 1 −  2 1 = − x  f x( ) 1
 f x( ) o − f x( ) 1  Substitute
 0 1 −  x2 = −1  ( ) 3 0.25
1 3 − −( ) − =

f ( ) x2 = −0.234375
The second approximation is
 x x x = − 1 2 −  3 2 x  f x( ) − 2
 f x( )1 2 f x( )

 1− 0.25  x3 = −( ) 0.234375 −  ( ) − = 0.234375 0.186441 − −3 ( )  −0.234375 
The third approximation is
 x x x 2 3 −  4 3 = − x  f x( ) 3
 f x( ) 2 3 − f x( )

Substitute previous x3 and x2
 0.25 − 0.186441  x4 = − 0.186441  ( ) 0.234375 0.201736 
( ) − − 0.234375 ( ) − = 0.074276 
The fourth approximation is
 x x x 4 5 −  5 4 = − x  f x( ) 4
 f x( ) 4 5 − f x( )

Substitute the old x4
 0.186441− 0.201736  x5 = − 0.201736  ( ) 0.00470 0.201640
 0.074276 − −( ) − = −0.00470 
Simulink Solution
The Secant method followed by the implanted MATLAB coded in MATLAB func￾tion is presented in the Simulink graphical programming shown in Figure 4.17.132 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The following program is the MATLAB code encrypting the secant method and 
is associated with the Simulink MATLAB function block.
function y = fcn(x0,x1)
% Secant Method in MATLAB
f=@(x)x^3–5*x+1; % Roots of the function;xA3–5*x+l
tol = 0.001; % tolerance
itr=1000;%nurnber of iteration
for i=1:itr
x2=(x0*f(x1)-x1*f(x0))/(f(x1)-f(x0));
if abs(x2-x1)<tol
break;
else
x0=x1;
x1=x2;
end
end
y=x2;
The following root is obtained using the Math operation/Algebraic constraint func￾tion from the Simulink library with an initial guess of zero (Figure 4.18).
Python Solution
The following Python program utilizes the secant method coded to solve the equa￾tion defined in Example 4.8.
# Example 4.8
# Implementation of SECANT METHOD
# Defining Function
FIGURE 4.17 Secant method for the solution of the equation defined in Example 4.8.Open Numerical Methods 133
def f(x):
return x**3–5*x + 1
# Implementing Secant Method
def secant(x0,x1,e, N):
print(‘\n\n Secant Method ‘)
print(‘ =============================== ‘)
step = 1
condition = True
while condition:
if f(x0) == f(x1):
print(‘Divide by zero error!’)
break
x2 = x0- (x1-x0)*f(x0)/(f(x1) - f(x0))
x0 = x1
x1 = x2
step = step + 1
if step > N:
print(‘Not Convergent!’)
break
condition = abs(f(x2)) > e
print(‘\n Required root is: %0.8f’ % x2)
# Input Section
x0 = 0 # First Guess
x1 = 5 # Second Guess
ET = 0.0001 # Error Tolerable (ET)
N = 100 # Maximum Step
# Starting Secant Method
secant(x0,x1,ET, N)
Execution results:
Secant Method
===============================
The required root is: 0.20162848
FIGURE 4.18 Simulink solution using the Algebraic constraint block of the equation 
defined in Example 4.8.134 Numerical Methods in Chemical Engineering Using Python® and Simulink®
4.7 MULLER’S METHOD
Muller’s method is a root-finding algorithm, a numerical method for solving equa￾tions of the form f ( ) x = 0. David E. Muller first presented the method in 1956. The 
method is based on the secant method. Muller’s method is based on locally approxi￾mating the nonlinear function f ( ) x by a quadratic function g x( ), and the root of the 
quadratic function g x( ) is taken as an improved approximation to the root of the non￾linear function f ( ) x . Three initial approximations x0 1 , x , and x2, which are required 
to start the algorithm. The only difference between Muller’s method and the secant 
method is that g x( ) is a quadratic function in Muller’s method but a linear function 
in the secant method, as shown in Figure 4.19. The following steps can be taken to 
find the roots of an algebraic equation using Muller’s method:
1. Assume any three distinct initial roots of the function; let it be 
2. Draw a parabola through the values of the function 
 The equation of the second-degree polynomial through the three points is:
g x( ) = +c b( ) x x − + 2
2 2 a x( ) − x (4.29)
 where 
 3. After drawing the parabola, then find the intersection of this parabola with 
 Calculate 
FIGURE 4.19 Graphical presentation of Muller’s method.Open Numerical Methods 135
f x( ) 1 − f x( ) δ o
o = (4.30)
x x 1 − o
 Calculate 
f x( ) 2 1 − f x( ) δ 1 = (4.31)
x x 2 1 −
 Calculate 
h x o o = −2 x (4.32)
 Calculate 
h x 1 1 = − x2 (4.33)
 Calculate 
δ δ
a = 1 − o (4.34) h h 1 + o
b a = + h1 1 δ (4.35)
c = f x( ) 2 (4.36)
 Calculate 
−2c
x3 1 = + x (4.37)
b b ∓ 2 − 4ac
 The percent error
x x
ε = 3 2 − 100% (4.38)
x3136 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Example 4.9 Application of Muller’s Method
Use Muller’s method to find the roots of
x3 − − 13x 12 = 0
The three initial guesses are x0 = 4.5, x1 = 5.5, x2 = 5.0
Confirm the manual root findings with Simulink and Python programming of 
Muller’s method.
Solution
Following Muller’s method,
f x( ) 0 = = f ( ) 4.5 20.626
f x( ) 1 = = f ( ) 5.5 82.875
f x( ) 2 = = f ( ) 5 48.0
h x o = −1 0 x = − 5.5 4.5 = 1
h x 1 2 = − x1 = −5 5.5 = −0.5
f x( ) − = 1 f x( ) o 82.875 − 20.625 δ o = = 62.25 ( ) x x 1 − o 5.5 − 4.5
f x( ) − f x( ) 82.875 48 δ = 1 2 − 1 = = 69.75 ( ) x x 1 2 − 5.5 − 5.0
δ δ 1 − 69.75 a o − 62.25 = = = 15
h h 1 + o 1+ −( ) 0.5
b a = + h1 1 δ = − 15( ) 0.5 + = 69.75 62.25
c f = = ( ) x 3 2 5 1 − − 3 5( ) 12 = 48
−2c −2 4( ) 8 x x 3 1 = + = +5 = 3.976
b b ∓ 2 2 − 4ac 62.25 ∓ ( ) 62.25 − 4 1( ) 5 4( ) 8
The percentage error is:
3.976 − 5
ε = 100% = 25.79%
3.976
Simulink Solution
Using Muller’s method to build the Simulink block diagram representing the solu￾tion of the equation defined in Example 4.9 is shown in Figure 4.20. The MATLAB 
code follows the Simulink graphical solution implanted in the MATLAB function 
programs, the Muller method. The MATLAB function is connected to three input 
ports representing the three constants containing the three initial guesses.Open Numerical Methods 137
The following are the MATLAB codes implanted in the MATLAB function of 
Example 4.9.
% Example 4.9
function y = fcn (p0, p1, p2)
TOL = 10^-5;
NO = 100;
f =@ (x) x^3–13*x-12; % the required function
h1 = p1- p0; h2 = p2- p1;
DELTA1 = (f(p1) - f(p0))/h1;
DELTA2=(f(p2) - f(p1))/h2;
d = (DELTA2- DELTA1)/(h2 + h1);
i=3;
p=0;
while i <= NO
b = DELTA2 + h2*d;
D = (b^2–4*f(p2)*d)^(1/2);
if abs(b-D) < abs(b+D)
E = b + D;
else
E = b - D;
end
h = -2*f(p2)/E; p=p2+h;
if abs(h) < TOL
break
end
p0 = p1; p1= p2; p2 = p;
h1 = p1- p0; h2 = p2- p1;
DELTA1 = (f(p1) - f(p0))/h1;
DELTA2 = (f(p2) - f(p1))/h2;
d = (DELTA2- DELTA1)/(h2 + h1); i = i + 1;
end
y = p;
FIGURE 4.20 Simulink block diagram using the Muller method to solve the equation 
defined in Example 4.9.138 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Python Solution
The solution of Example 4.9 using Muller’s method programmed with Python is 
shown as follows:
# Example 4.9: Application of using Muller’s method
import math;
MAX_ITERATIONS = 100
# Function to calculate f(x)
def f(x):
 # Taking f(x) = x ^ 3–13x -12
 return (x**3–13 * x -12)
def Muller(a, b, c):
 res = 0
 i = 0
 while (True):
 # Calculating various constants
 f1 = f(a); f2 = f(b); f3 = f(c)
 d1 = f1- f3
 d2 = f2- f3
 h1 = a - c
 h2 = b - c
 a0 = f3
 a1 = (((d2 * pow(h1, 2)) -
 (d1 * pow(h2, 2))) /
 ((h1 * h2) * (h1- h2)))
 a2 = (((d1 * h2) - (d2 * h1)) /
 ((h1 * h2) * (h1- h2)))
 x = ((-2 * a0) / (a1 +
 abs(math.sqrt(a1 * a1–4 * a0 * a2))))
 y = ((-2 * a0) / (a1-
 abs(math.sqrt(a1 * a1–4 * a0 * a2))))
 # Taking the root, which is
 # closer to x2
 if (x >= y):
 res = x + c;
 else:
 res = y + c;
 # checking for the resemblance of x3
 m = res * 100;
 n = c * 100;
 m = math.floor(m)
 n = math.floor(n)
 if (m == n):
 break
 a = b
 b = c
 c = res
 if (i > MAX_ITERATIONS):
 print(“Root cannot be found “)
 break
 i =i+ 1
 if (i <= MAX_ITERATIONS):
 print(“\n using Muller’s method, the root is:”, 
round(res, 4))Open Numerical Methods 139
# Initial guesses
a = 4.5
b = 5.5
c = 5
Muller(a, b, c)
Execution result:
using Muller’s method, the root is: 4.0
4.8 SUMMARY
There are various methods available to find the roots of equations. The simplest 
method is the bisection method. The method is based on the changes in sign of a 
function in the vicinity of a root. NR is based on using an initial guess for the root 
and finding the intersection with the straight-line axis representing the slope at the 
initial guess. Based on a reasonable estimate of the initial guess, the method works 
and converges extremely fast.
4.9 PROBLEMS
1. Solving the following two equations using the substitution method.
x − = 2 8 y
x + = y 5
Answer: (x = 6, y = −1)
2. Solve the following two equations using the method of substitution.
2   x y + +  3    15    = 0
x    + + 4   y  2    = 0 
Answer: (x    = −54/5 and y = 11/5)
3. Solve the following two linear algebraic equations using the method of 
substitution.
y x = + 2 8
y x = − 5 1
Answer: (x = 3,y = 14)140 Numerical Methods in Chemical Engineering Using Python® and Simulink®
4. Solve the following two linear algebraic equations using the substitution 
method.
19 2
y x = − 5 5
y x = − 3 1 ( )
Answer: (x    = 2, y = 3)
5. Find the roots of the following nonlinear algebraic equation using the fixed￾point iteration method.
x 2 − − 2 3 x = 0
Answer: (x    = 3)
 6. Determine the root of the following equation using the fixed-point iteration 
2x x 3 2 − + 11.7 17.7x − = 5 0
Answer: (x = 0.365)
 7. Using NR method, find the root of the following equation:
x3 − − 3 5 x = 0
Answer: (x    = 2.279)
 8. Using NR method, find the roots of the following function:
x3 2 − + 2 3 x x − = 0
As an initial guess use, xo = 4
Answer: (x    = 2.174)
 9. Use the NR method to find the values of 
x 2 + − xy 10 = 0
y x + − 3 5 y2 7 0 =
Answer: x1 = 2.036, y1 = 2.843Open Numerical Methods 141
10. Find the roots of the following equation using Muller’s method, starting 
with the initial approximations as xo = = 2, x x 1 2 2.5,  3 =
x3 − − 3 5 x = 0
Answer: 2.279
 11. Find the roots of the following equation using Muller’s method, starting 
f ( ) x x = +3 2 2 1 x x + − 0 20 0 =
Answer: 1.368
 12. Find the roots of the following equation using Muller’s method, starting 
x5 − + 5 2 x = 0
Answer: 1.372
REFERENCES
 1. Hoffman, J.D. and Frankel, S., 2018. 
 2. Kiusalaas, J., 2005. 
 3. Kong, Q., Siauw, T. and Bayen, A., 2020. 143
5 Initial Value Problem 
Differential Equations
An initial value problem (IVP) is an ordinary differential equation (ODE) with an 
initial condition that specifies the value of the unknown function at a given point 
in the domain. Numerical methods are essential for solving system IVPs in ODEs, 
especially in complicated cases. This chapter introduces eigenvalue, eigenvector, and 
elimination techniques to solve systems of more than one initial value ODEs.
LEARNING OBJECTIVES
1. Solve IVP using eigenvalue and eigenvector technique.
2. Apply elimination techniques to solve initial value problems (IVPs).
3. Master the use of the Simulink Integrator block in designing and simulating 
dynamic systems.
4. Utilize Python programming language to address an IVP.
5.1 INTRODUCTION
In mathematics, an ODE is a differential equation that contains one or more functions 
of one independent variable and the derivatives of those functions. The term ordinary 
is used in contrast to the partial differential equation, which may concern more than 
one independent variable. ODEs may represent system dynamics in transferring heat 
and mass and related problems in chemical engineering and other engineering disci￾plines. The IVP describes the behavior of a system due to certain disturbances that 
cause the system to deviate from its steady-state value. Differential equations can 
arise naturally from physical modeling. The following IVP describes the concentra￾tion profile of three chemicals in a reactor as a function of time. The following set of 
ODEs represents certain dynamic equations [1].
dc1 = … f c 1 1 ( ) …c3 dt
dc2 = … f c 2 1 ( ) …c3 dt
dc3 = … f c n ( ) 1 3 …c
dt
DOI: 10.1201/9781003360544-5144 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The set of equations can be written in the following form:
dC = f c( ) dt
Under steady-state conditions, it can be written as
0 = … f c 1 1 ( ) …c3
0 = … f c 2 1 ( ) …c3
0 = … f c n ( ) 1 3 …c
The solution method is the same as the single first-order ODE solution method and 
can be extended to multiple ODEs system.
5.2 EIGENVALUE AND EIGENVECTOR
Eigenvalues and eigenvectors are used to solve linear systems of ODEs. Each eigen￾value is associated with a specific eigenvector. IVPs can be presented in terms of an 
eigenvalue technique as follows:
Ax = λx
where A is an n × n matrix (the coefficients of the ODEs), x is a nonzero n× 1 (vec￾tor), and λ is the eigenvalue (scaler) of matrix A. The eigenvalue problem is rewritten 
as follows:
Ax − = λx 0
Ax − = λIx 0
where ( )I is the identity matrix, rearranging
( A x − = λI) 0
Since x is nonzero, the characteristic equation would be
A − = λI 0
The roots ( ) λ are called the eigenvalues of A.Initial Value Problem Differential Equations 145
Example 5.1 Application of Eigenvalue and Eigenvector
Solve the following two ODEs simultaneously using the eigenvalue and eigenvec￾tor technique.
dy1 = −3 2 y y 1 2 + = ,    y1 ( ) 0 1
dt
dy2 = − y y 1 2 2 ,     y2 ( ) 0 0 = dt
Find the values of y1 and y2 when t = 2.
Manual Solution
First, convert the system into matrix form. The equations can be written as follows:
dY = AY
dt
where
 −3 2  A =    1 2− 
First determine eigenvalue λ
A− = λI 0
 −3 2   λ 0   − − λ 3 2 
  −   =   = 0
 1 2−   0 λ   1 2− − λ 
Find the determinant
 − − λ 3 2 
det  = −( ) λ λ − − 3 2 ( ) − − ( ) 1 2( ) = 0
 1 2− − λ 
Rearrange
λ2 2 + + 5 6 λ λ − = 2 5 + + λ 4 0 =
Factorize
(λ λ + + 4 1 )( ) = 0
The two eigenvalues: λ1 2 = −1,  4 λ = −146 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Determine corresponding eigenvectors
 −3 2   x 
 
 x 

λ1 = −1:    11  = −1 11   1 2−  x  12 x   12 
Solving the matrix,
−3 2 x x 11 + = 12 −x11
x x 11 − = 2 12 −x12
Rearranging and simplifying,
x11 = x12
Accordingly,
 1 
X1 =    1 
Finding the eigenvector of λ2,
 −3 2  
 x21 
  x  λ2 = −4 :     = −4  21 
  1 2−   x22   x    22 
Solving the matrix,
−3 2 x x 21 + = 22 −4x21
x x 21 − = 2 4 22 − x22
Rearranging and simplifying,
−2 4 x x 21 = − 21 − 4x22
Simplify
2 4 x x 21 = − 22
Hence,
x21 = −2x22
 −2 
X2 =    1 
The general solution is
Y = + c e( ) λ1t 2 1 1 X c2 2 e X λ tInitial Value Problem Differential Equations 147
In another format,
 y1   1  ( ) 2  1   = c e t  − 1   − + c e   −4t
y 2
 2   1   1   
The solution is
y c − − 1 1 = − e c t t 2 e 4 2
y c 2 1 = + e c − − t t 2e 4
c1 and c2 are determined from the initial conditions.
1 2 = − c c 1 2
0 = + c c 1 2
Solving for c1 and c2 , the values are as follows:
1 1 c1 2 = = , c − 3 3
When t = 2 min, the values of y1 and y2 are as follows:
1 2 8 1 y e− −  1 = − 2 −  e = 0.0453
3  3
1 1
y e 2 =−= − − 2 8 e 0.045
3 3
Simulink Solution
Figure 5.1 represents the Simulink block diagram using the Simulink Integrator 
block for solving the two ODEs defined in Example 5.1. The integrator’s default 
numerical integration method is the fourth-order Runge-Kutta method.
An alternative way is to use the MATLAB function block available in the User￾Defined Functions of the Simulink library. The MATLAB function is associated 
with a program written in MATLAB programming language. The solution using 
the eigenvalue and eigenvector approaches of the two ODEs specified in Example 
5.1 is presented by the Simulink block diagram shown in Figure 5.2. The Simulink 
block diagram is followed by the MATLAB code associated with the MATLAB 
function. The predicted approximate results are identical to the case using the 
Integrator block and the default RK4. The MATLAB function input port relates to a 
constant (n), representing the independent variable’s simulation stop time (t). The 
exit ports are connected with two Display blocks for the output of y1 and y2 at 
the simulation stop time. The change in the dependent variable ( , y y 1 2 ) versus the 
independent time variable ( )t is presented in Figure 5.3.
The following program represents the MATLAB code implanted in the MATLAB 
function shown in Figure 5.2. The results are plotted in Figure 5.3.148 Numerical Methods in Chemical Engineering Using Python® and Simulink®
FIGURE 5.2 Simulink solution using the eigenvalue and eigenvector approach of ODEs 
defined in Example 5.1.
FIGURE 5.1 Solution using the Simulink integrator block and the fourth-order Runge￾Kutta approach of equations defined in Example 5.1.Initial Value Problem Differential Equations 149
% Example 5.1
function [Res1,Res2] = fcn(n)
% The coefficients of the Matrix
A = [-3 2;
1 -2];
% Calculating the eigenvalue and eigenvectors
[V, D] = eig(A);
% initial conditions
Y0 = [1; 0];
% Calculating the constants C1 and C2
c = diag(V\Y0);
t = linspace(0,n);
T = [t;t];
y = V*c*exp(D*T);
plot(t, y, ‘LineWidth’, 1.5))
xlabel(“Time”)
ylabel(“y “, rotation=0)
grid on
str = ‘\leftarrow y_1’;
text(0.2,0.6,str)
str2 = ‘\leftarrow y_2’;
text(0.2,0.1,str2)
Res1 = y(1,end);
Res2 = y(2,end);
Python Solution
The following program is a Python code that uses the eigenvalue and eigenvector 
approaches to solve the two ODEs equations given in Example 5.1. The plot of y1
and y2 versus time (t) is presented in Figure 5.4.
FIGURE 5.3 Simulink generates a plot of the two ODEs defined in Example 5.1.150 Numerical Methods in Chemical Engineering Using Python® and Simulink®
# Example 5.1
import numpy as np
import matplotlib.pyplot as plt
A = np.array([[-3,2], [1,-2]])
# extract eigenvalues
[w, v]= np.linalg.eig(A)
y10 = 1
y20 = 0
Pinitial = np.array([y10, y20])
C1, C2 = np.linalg.solve(v, Pinitial)
# combine everything to get the solution to P1
#t = np.linspace(0,2)
fig = plt.figure()
t=np.linspace(0,2,100)
y1 = C1 * np.exp(w[0]*t)*v[0,0] + C2 * np.exp(w[1] * t) * v[0,1]
y2 = C1 * np.exp(w[0]*t)*v[1,0] + C2 * np.exp(w[1] * t) * v[1,1]
#plt.plot(t, y1, t, y2)
plt.plot(t, y1, ‘-r’, label=’y1’)
plt.plot(t, y2, ‘:b’, label=’y2’)
plt.grid(True)
plt.ylabel(“y”, rotation =0)
plt.xlabel(“Time”)
plt.legend()
Example 5.2 Determine the Eigenvalue and Eigenvector
Calculate the eigenvalue and eigenvector for the following two ODEs.
dy1 = = y y 2 1 ,   ( ) 0 1
dt
dy2 = −2 3 y y 1 2 − = ,     y2 ( ) 0 0
dt
FIGURE 5.4 Plot of y1 and y2 versus time (t) generated by the Python program using eigen￾value and eigenvector represents the solution of two ODEs defined in Example 5.1.Initial Value Problem Differential Equations 151
Solve the two ODEs manually and support the manual solution using the Simulink/
MATLAB programming and Python programming of the eigenvalue and eigenvec￾tor approaches.
Solution
Putting the two ODEs in terms of a 2 × 2 matrix
 0 1  A =   − −  2 3 
The characteristic equation is
A− = λI 0
Substitute the values matrices A and I
 0 1   1 0   0 1   λ 0   0 1 − λ 
  − λ   =   −   =    − − 2 3   0 1   − − 2 3   0 λ   − − 2 3 − λ 
The determinant of a matrix: A determinant is a particular number calculated from 
a matrix. The matrix must be square (the same number of rows and columns). This 
has two rows and two columns: The following matrix is a 2 2 × :
 a b      A =   = − ad bc
 c d 
Accordingly,
 0 1 − λ    = − 
( ) 0 3 λ λ ( ) − −  − −   ( ) 2 1( ) = 0
 − − 2 3 − λ 
Simplify
λ2 + + 3 2 λ λ = + ( ) 2 1 ( ) λ + = 0
And the two eigenvalues are
λ λ 1 2 = −1,  2 = −
Find the two eigenvectors as follows:
To find the eigenvector, X1, associated with the eigenvalue, λ1 = −1152 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The eigenvectors for λ1 = −1 are determined as follows:
A X. . 1 1 = λ X1
( A X − = λ1 1 ). 0
 0 1   λ 0   −λ 1    −  1 .X =  1
1 . 0
 1  1 =  − −  2 3   0 λ   − −  2 3 − λ   1 

X
Substitute the value of λ1 = −1
 1 1   1 1   x 
 .x =  . 0 11 = − − 2 2 1   − −    2 2   x  12 
So clearly, from the top row of the equation, we get
x11 + = x12 0
Accordingly,
x11 = −x12
If we use the second row, we will get the same
−2 2 x x 11 − = 12 0
Divide by 2 and rearrange, again
x11 = −x12
The eigenvector
 x   −1  X1 =  11  =    x12   1 
We find that the first eigenvector is any vector composed of two components 
where the two components have the same magnitude and opposite signs. Follow 
the same procedure to determine the eigenvector for the second eigenvalue 
( 2 λ2 = − ):
A X. . 2 2 = λ X2
Rearrange
( A X − = λ2 2 ). 0
 0 1    λ 0    −  2 . 0 X =  − − 2 3 0 λ 2
  
 2 
  Initial Value Problem Differential Equations 153
Subtract the two matrixes
 0 1 − − λ2 0   . 0 X − −2 0 − −3 λ 2 =

 2 

Substitute the value of λ2 = −2
 2 1   2 1   x  .X . 0  21 
2 1 1 =    = − −  − −   2 1  x    22 
Multiply the first row in the first matrix with the first column of the second matrix
2 0 x x 21 + = 22
Rearrange
2x x 21 = − 22
Accordingly,
 −1  X2 =    2 
Again, the eigenvector’s choice of –1 and 2 was arbitrary; Only their proportion is 
essential. The general solution is
Y = + c e( ) λ1t 2 1 1 X c λ t 2 2 e X
In another format,

 y1  ( ) 1  1 
c e t t  −1   = − −  − 1   + c e 2 2    y2 1 2      
The solution is
y c 2 1 1 = − e c − − t t − 2e
y c = + e c − − t t 2 2e 2 2 1
The values of c1 and c2 can be determined using the initial condition of y1 and y2
1 = − c e−0 2 0 1 c e− ( ) 2
0 2 = −c e− − ( ) 0 2 0 1 + ( ) c e2154 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Simplifying,
1 = −c c 1 2 −
0 2 = + c c 1 2
Hence solving for c1
c1 = −2
c2 = 1
Accordingly,
 −1   −1 
Y = −2  e e − − t t +1  2
 1   2 
The final solution is
y e 1 = −2 − − t t − e 2
y e 2 = + 2 2 − − t t e 2
When t = 2
y e2 1 2 −2 2 1 = − − e ( ) = 0.25235
y e = + 2 2 − − ( ) 2 2( ) e 2 2 = −0.23404
Simulink Solution
Figure 5.5 is the Simulink block diagram representing the solution of the two 
nonlinear ODEs equations defined in Example 5.2. The following program is the 
MATLAB code utilizing the eigenvalue and eigenvector approach associated with 
the Simulink MATLAB function block dragged from the User-Defined Functions 
Simulink library. The MATLAB function input port is connected with a constant 
(n), representing the simulation end time. The output port is connected with two 
Display blocks that yield the values of dependent variables at the simulation stop 
time.
The following program signifies the MATLAB code implanted in the MATLAB 
function present in Figure 5.5. The program uses eigenvalue and eigenvector 
methodology to solve the two ODEs defined in Example 5.2.
% Example 5.2
function [Res1,Res2] = fcn(n)
% The coefficients of the Matrix
A = [0 1;
-2 -3];
% Calculating the eigenvalue and eigenvectorsInitial Value Problem Differential Equations 155
[V, D] = eig(A);
% initial conditions
Y0 = [1; 0];
% Calculating the constants C1 and C2
c = diag(V\Y0);
t = linspace(0,n);
T = [t;t];
y = V*c*exp(D*T);
% Plot sextion
plot(t, y, ‘LineWidth’, 1.5)
xlabel(“Time”)
ylabel(“y “, rotation=0)
grid on
str1 =’\leftarrow y_1’;
str2 = ‘\leftarrow y_2’;
text (0.65,0.8,str1,’Color’, ‘b’, ‘FontSize’, 15);
text (0.4,-0.4,str2,’Color’, ‘r’, ‘FontSize’, 15);
ylim([-0.6 1]);
Res1 = y(1,end);
Res2 = y(2,end);
Executing the described Simulink block diagram generates the plot shown in 
Figure 5.6.
Python Simulation
The following program is a Python code that simultaneously uses the eigenvalue and 
eigenvector approaches to solve the two nonlinear equations given in Example 5.2. 
Running the Python program generates the data plotted in Figure 5.7.
FIGURE 5.5 The Simulink block diagram using the eigenvalue and eigenvector approach 
of two ODEs defined Example 5.2.156 Numerical Methods in Chemical Engineering Using Python® and Simulink®
# Example 5.2
import numpy as np
import matplotlib.pyplot as plt
A = np.array([[0,1], [-2,-3]])
# extract eigenvalues
[w, v]= np.linalg.eig(A)
y10 = 1
y20 = 0
Pinitial = np.array([y10, y20])
C1, C2 = np.linalg.solve(v, Pinitial)
FIGURE 5.6 Plot of y1 and y2 versus time (t) using eigenvalue and eigenvector in MATLAB 
of the two equations defined in Example 5.2.
FIGURE 5.7 Plot of y1 and y2 versus time (t) utilizing the eigenvalue and eigenvector 
approach programmed in Python of the two equations described in Example 5.2.Initial Value Problem Differential Equations 157
# combine everything to get the solution to P1
#t = np.linspace(0,2)
fig = plt.figure()
t=np.linspace(0,2,100)
y1 = C1 * np.exp(w[0]*t)*v[0,0] + C2 * np.exp(w[1] * t) * v[0,1]
y2 = C1 * np.exp(w[0]*t)*v[1,0] + C2 * np.exp(w[1] * t) * v[1,1]
#plt.plot(t, y1, t, y2)
plt.plot(t, y1, ‘-g’, label=’y1’)
plt.plot(t, y2, ‘:r’, label=’y2’)
plt.grid(True)
plt.ylabel(“y “, rotation=0)
plt.xlabel(“Time”)
plt.legend()
Example 5.3 Application of Eigenvalue and Eigenvector Technique
Solve the following two ODEs using the eigenvalue-eigenvector technique.
dy1 = + 2y y 1 2 ,    y1 ( ) 0 1 = dx
dy2 = = 3y y 1 2 ,   ( ) 0 0
dt
Solution
Arrange the equations in matrix form
dY  2 1   1  = = AY  Y Y ,     dt 3 0 o =      0 
Using the identity matrix (I) and the eigenvalue ( ) λ , first, we will determine the 
eigenvalues of matrix A
AX = λX
Rearrange
AX − = λ λ X A( ) − = I X 0
The ( A I − = λ ) X 0 in matrix format
 2 1   λ 0 
  −   X = 0
 3 0   0 λ 
The result of subtraction matrices
 2 1 − λ    = 0
 3 0 − λ 158 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The determinant equation
 2 1 − λ 
det  = 0
3 0 − λ  
The resultant quadratic equation
(2 3 − − λ λ )( ) − = ( )( ) 1 0
Simplify
λ2 − − 2 3 λ = 0
Factorize
(λ λ − + 3 1 )( ) = 0
The eigenvalues are
λ1 2 = = 3,  1 λ −
Each eigenvalue has an eigenvector.
Eigenvector X1 for λ1 = 3
 2 1 − λ 0  1  x11      =    3 −λ1  x  12 0    
Substitute λ1 = 3
 −1 1  x   0    11  =   −  3 3  x  12   0 
−x x 11 + = 12 0
If we assume that x11 = 1, then x12 = 1
 x   1  X1 =  11  =   x  12   1 
 1  The eigenvector of λ1 is    1 
Eigenvector X2 of λ2 = −1
 2 1 − λ2  x   21   0   =   3 
 −λ2 x 
 22 0    Initial Value Problem Differential Equations 159
Substitute λ2 = −1
 2 1 − −( ) 1  x      0  21  =    3 1 − −( )  x   0    22 
 3 1  x  0    21   =    3 1  x22 0    
3 1 x x 21 + = 22 0
If we assume x21 = 1, then x22 = −3
 1  According to the eigenvector for λ2 is   −  3 
The eigenvector matrix is
 1 1 
X =    1 3− 
The solution
Y = + c e( ) λ1t
1 1 X c2 2 e X λ2t
Substitute the eigenvalues and eigenvectors
 y  1 
 = ( ) c e λ1t  1  λ2   c e t  1  1 2  +   1 3  y2    −  
The solution of the two equations
y c 1 1 = + e c 3t t 2e
y c = − 3t t 2 1e c3 2e
Substitute the initial conditions
y y 1 2 ( ) 0 1 = = ,  ( ) 0 0
After substituting the initial conditions,
1   = + c c 1 2 (5.1)
0 3 = − c c 1 2 (5.2)
Subtract equation (5.2) from (5.1)
1 0 − = ccc 1 1 − + 2 2 − −( ) 3 4 c c = 2160 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Accordingly,
1 3 c2 1 = = , c 4 4
The final solution for the two ODEs:
3
y e = + 3t t 1 1 e 4 4
3 3 3
y e t t 2 = − e 4 4
Simulink Solution
Figure 5.8 shows the Simulink block diagram representing the solution of the two 
ODEs defined in Example 5.3 using the Integrator block dragged from the most 
Simulink commonly used library. Figure 5.9 is obtained by double-clicking the 
Scope. To change the color of the plot generated by the Scope, click on view/style 
and change the Figure color to white and the axis background color to white. The 
figure should be like that in Figure 5.9.
The Simulink block diagram describes the solution using the eigenvalue and 
eigenvector of the two ODEs defined in Example 5.3, shown in Figure 5.10. The 
input port of the MATLAB function (dragged from the User-Defined Functions in 
the Simulink library) is connected with a constant (n), representing the simulation 
end time. The two outlet ports are connected with two Display blocks to yield the 
dependent variable values ( , y y 1 2 ) at the end period of the independent variable ( )t .
FIGURE 5.8 Simulink solution using the Integrator block to solve simultaneously the two 
ODEs defined in Example 5.3.Initial Value Problem Differential Equations 161
% Example 5.3
function [Res1,Res2] = fcn(n)
% The coefficients of the Matrix
A = [2 1;
3 0];
% Calculating the eigenvalue and eigenvectors
[V, D] = eig(A);
FIGURE 5.9 Plot generated by double-clicking the scope in the Simulink block diagram 
represents the solution of the two ODEs defined in Example 5.3.
FIGURE 5.10 Simulink block diagram using eigenvalue and eigenvector of the two ODEs 
described in Example 5.3.162 Numerical Methods in Chemical Engineering Using Python® and Simulink®
% initial conditions
Y0 = [1; 0];
% Calculating the constants C1 and C2
c = diag(V\Y0);
t = linspace(0,n);
T = [t;t];
y = V*c*exp(D*T);
% plot section
plot(t, y, ‘LineWidth’, 1.2)
xlabel(“Time”, “FontSize”, 15)
ylabel(“y”, ‘rotation’, 0,’FontSize’, 15)
ylim([0 16]);
grid on;
str1 = ‘\leftarrow y_2’;
str2 = ‘y_1 \rightarrow’;
text (0.6,4,str1,’color’, ‘b’, ‘FontSize’, 15);
text (0.65,7.5,str2,’color’, ‘r’, ‘FontSize’, 15);
% displayed results
Res1 = y(1,end);
Res2 = y(2,end);
The result of Example 5.3 generated by Simulink using the eigenvalue and eigen￾vector approach is shown in Figure 5.11. 
Python Solution
The following is a Python program utilizing the eigenvalue and eigenvector to 
solve the binary equation described in Example 5.3. After the program’s execution, 
the generated plot is shown in Figure 5.12.
FIGURE 5.11 Simulink solution of the binary differential equations defined in Example 5.3 
using the eigenvalue and eigenvector approach.Initial Value Problem Differential Equations 163
# Example 5.3
import numpy as np
import matplotlib.pyplot as plt
A = np.array([[2,1], [3,0]])
# extract eigenvalues
[w, v]= np.linalg.eig(A)
y10 = 1
y20 = 0
Pinitial = np.array([y10, y20])
C1, C2 = np.linalg.solve(v, Pinitial)
# combine everything to get the solution to P1
#t = np.linspace(0,2)
fig = plt.figure()
t=np.linspace(0,1,100)
y1 = C1 * np.exp(w[0]*t)*v[0,0] + C2 * np.exp(w[1] * t) * v[0,1]
y2 = C1 * np.exp(w[0]*t)*v[1,0] + C2 * np.exp(w[1] * t) * v[1,1]
#plt.plot(t, y1, t, y2)
plt.plot(t, y1, ‘-b’, label=’y1’)
plt.plot(t, y2, ‘:r’, label=’y2’)
plt.grid(True)
plt.ylabel(“y “, rotation=0)
plt.xlabel(“Time”)
plt.legend()
5.3 ELIMINATION METHODS
Here, the procedure is the same as solving a system of linear equations, just using 
the operator “D.” Solving a system of linear differential equations by applying the 
following steps to reach the solution:
1. Replace indep
derivatives 
d
d ( )





 with D.
FIGURE 5.12 Python solution using eigenvalue and eigenvector technique of the two equa￾tions described in Example 5.3.164 Numerical Methods in Chemical Engineering Using Python® and Simulink®
2. Rearrange the equations such that they start with x and follows by y.
3. Solve by eliminating Dx or Dy.
4. Solve the differential equation.
5. Solve the other equation following the steps.
6. Eliminate constants using boundary conditions.
Example 5.4 Elimination Method
Solve the following two ODEs simultaneously using the elimination method.
dy = −9x dt
dx = −4y dt
Solution
Using the elimination method, follow the steps below:
 1. Replace the derivative with D.
Dy = −9x
Dx = −4y
 2. Organize the equation. Putting y first, as follows:
Dy + = 9 0 x
4y D+ = x 0
 3. Start the elimination process. Multiply the first equation by D and the 
second equation by 9.
D y2 + = 9 0 Dx
36y D + = 9 0 x
Subtract the second from the first
D y2 − = 36y 0
 4. Solve the differential equation. Let y a = eat and substitute the expression 
of y.
a2
e e at − = 36 at 0.Initial Value Problem Differential Equations 165
Divide both sides by eat
a2 − = 36 0
a = ∓6
Accordingly,
y c = + 6t t 6 1 c e− 2
Repeat the same for x by eliminating y
Dy + = 9 0 x
4y D+ = x 0
Multiply the first by 4
4 3 Dy + = 6 0 x
4Dy + = D x2 0
Subtract the first from the second
D x2 − = 36x 0
Let x = aeat
a2
e e at − = 36 at 0
Divide by eat
a2 − = 36 0
a = ∓6
x c = + 6t t −6 1e c2e
Example 5.5 Applying the Elimination Method
Solve the following set of ODEs using the elimination method
dx = − 4 3 x y dt
dy = − 6 7 x y dt166 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solution
 d Replace derivatives     ( ) , with D. In other words, write in differential nota-  d indep 
tion (D).

Dx = − 4 3 x y
Dy = − 6 7 x y
Move all terms with dependent variables to the left-hand side and arrange columns 
by variables.
( ) D x − + 4 3y = 0
−6 7 x D + + ( ) y = 0
Start the elimination process by eliminating x. Multiply the first equation by 6 and 
the second by (D − 4) as follows:
6 4 x D( ) − +18y = 0
−6 4 x D( ) − + ( ) D D − + 4 7 ( ) y = 0
Simplify and rearrange
18y D + + ( ) 2 3 2 D y − = 8 0
Divide both sides by y and rearrange
D D 2 + − 3 10 0 =
Find the roots
(D D − + 2 5 )( ) = 0
d D = = 2 5 or − dt
Accordingly,
y t( ) = + c e−5t t 1 c e2 2
Solve for x by substituting y in one of the following equations:
dy = − 6 7 x y dt
Hence,
−5 2 c e− − 5t t 2 1 + = c e2 6 7 x c − + ( ) 5 2 1e c t t 2eInitial Value Problem Differential Equations 167
Rearrange to obtain the solution of x
( ) 1 −5t t 3
x t c = + e c 2 1 2e
3 2
Example 5.6 Applying Eigenvalue and Eigenvector
Solve the following two IVPs by applying the eigenvalue and eigenvector method.
dy1 = + y y 1 2 2 ,    y1 ( ) 0 0 = dt
dy2 = + 3 2 y y 1 2 ,   y2 ( ) 0 4 = − dt
Solution
The first thing is to determine the eigenvalues for the matrix
 1 2 − 
det( ) λ A I − = λ    3 2 − λ  
= − λ λ 2 3 4 −
= + ( ) λ λ 1 4 ( ) − →  1 λ λ 1 2 = − ,  = 4
Now let us find the eigenvector for each of these
λ1 = −1
You need to solve
 1 2  x11   0     =    3 3  x 0  12   
2 2 x x 11 + = 12 0 → = x x 11 − 12
The eigenvector, in this case, is assumed, x11 = −1
 −1  X =    1 
λ2 = 4
We will need to solve
 −3 2  x  21   0    =   3 2−   x22 0    
 2 − + 3 2 x x 21 22 = →0  x x 21 =    3 22168 Numerical Methods in Chemical Engineering Using Python® and Simulink®
assuming, x22 = 1,   x21 = 2 / 3
 2/3 
The eigenvector in this case is x =  
 1 
The general solution is
1 2 X t c −t t  −  4   ( ) = 1 2 e c +  1  e      3 
Apply the initial conditions to find C1 and C2
 0   2  c c 1 2 ( ) −1    =  1 +  ( )  −4  1   1    3 

Multiply and solve for c1 and c2
0 2 = −c c 1 2 +
−4 3 = + c c 1 2
Rearranging,
8 4 c1 2 = − , c = − 5 5
The equations in vector form are
 − ( ) 8 1  4 2 X t e−t t − 4   = −  1  e   5   5  3 
The final solution of the individual equations is
8 − 8
y e = −t t e4 1 5 5
8 12
y e t t 4 2 = − − − e 5 5
Simulink Solution
The Simulink integrator, dragged from the Simulink/Commonly used Blocks library, 
can be used to solve the two ODEs simultaneously, as shown in Figure 5.13.
Figure 5.14 is the plot generated by double-clicking on the Scope block of 
Figure 5.13. The generated figure is the solution of the two equations ( ) y y 1 2 and 
versus time (t).
An alternative Simulink solution uses the MATLAB function associated with the 
MATLAB function.
Figure 5.15 is the Simulink block diagram using the eigenvalue and eigenvector 
to solve Example 5.6.Initial Value Problem Differential Equations 169
FIGURE 5.14 Plot generated by double-clicking the scope of Figure 5.13, generating the 
solution of y1 and y2 versus time.
FIGURE 5.13 Solution of the equations in Example 5.6 using the Simulink integrator.
FIGURE 5.15 Simulink MATLAB function and the eigenvalue and eigenvector technique 
to solve the two ODEs defined in Example 5.6.170 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The following is the MATLAB program implanted in the MATLAB function 
graphically programmed in Figure 5.15. The MATLAB code simultaneously pro￾grammed the eigenvalue and eigenvector for solving the two ODE equations 
described in Example 5.6. Figure 5.16 shows the plotted result of the solution of 
the two ODEs defined in Example 5.6.
% Example 5.6
function [Res1,Res2] = fcn(n)
% The coefficients of the Matrix
A = [1 2;
3 2];
% Calculating the eigenvalue and eigenvectors
[V, D] = eig(A);
% initial conditions
Y0 = [0; -4];
% Calculating the constants C1 and C2
c = diag(V\Y0);
t = linspace(0,n);
T = [t;t];
y = V*c*exp(D*T);
plot(t, y)
xlabel(“Time”)
ylabel(“y “, rotation =0 )
grid on;
str1 = ‘\leftarrow y_1’;
str2 = ‘y_2 \rightarrow’;
text (0.7,-20,str1,’FontSize’, 15);
text (0.55,-40,str2,’FontSize’, 15);
Res1 = y(1,end);
Res2 = y(2,end);
FIGURE 5.16 Simulink generated plot signifies the solution of the two ODEs in Example 
5.6 using eigenvalue and eigenvector.Initial Value Problem Differential Equations 171
Python Solution
The following Python code utilizes the eigenvalue and eigenvector approaches to 
solve the two equations described in Example 5.6. Running the Python program 
generates the plot shown in Figure 5.17.
# Example 5.6
import numpy as np
import matplotlib.pyplot as plt
A = np.array([[1,2], [3,2]])
# extract eigenvalues
[w, v]= np.linalg.eig(A)
y10 = 0
y20 = -4
Pinitial = np.array([y10, y20])
C1, C2 = np.linalg.solve(v, Pinitial)
# combine everything to get the solution to P1
#t = np.linspace(0,2)
fig = plt.figure()
t=np.linspace(0,1,100)
y1 = C1 * np.exp(w[0]*t)*v[0,0] + C2 * np.exp(w[1] * t) * v[0,1]
y2 = C1 * np.exp(w[0]*t)*v[1,0] + C2 * np.exp(w[1] * t) * v[1,1]
#plt.plot(t, y1, t, y2)
plt.plot(t, y1, ‘-b’, label=’y1’)
plt.plot(t, y2, ‘:r’, label=’y2’)
plt.grid(True)
plt.ylabel(“y “, rotation = 0)
plt.xlabel(“Time”)
plt.legend()
FIGURE 5.17 Plot of the y1 and y2 versus time (t) generated by the Python program uses the 
eigenvalue and eigenvector for solving the two equations defined in Example 5.6.172 Numerical Methods in Chemical Engineering Using Python® and Simulink®
5.4 SUMMARY
The aim of this chapter is to acquaint the reader with the numerical method required 
in solving initial value ODEs that arise in chemical engineering topics such as fluid 
flow, diffusion, reaction, mass, and heat transfer. IVP is an ODE with an initial con￾dition that determines the value of the unknown function at a given point in the 
domain. In this chapter, we solved systems of two linear differential equations in 
which the eigenvalues are real numbers. The eigenvalue is a number, and the eigen￾vector is a vector, both of which are hiding in the matrix.
5.5 PROBLEMS
1. Solve the following two ODE using eigenvalue and eigenvector techniques.
dy = + 3x y,   y( ) 0 1 = − dt
dx = − 5x y,  x( ) 0 2 = dt
Answer:
3
x( )t e = − 2 4 t t 7
+ e
2 2
9 7
y t( ) = − e e 2 4 t t +
2 2
 2. Solve the following IVPs using the elimination method.
dx = − y x5 ,  x 1 0
dt ( ) + = ( )
dy = − 4x y,   y( ) 1 1 = dt
Answer:
x( )t c = + e c − − 3t t 1 te 3 2
y t( ) = −( ) 2 2 c c − − 3 1 2 + − e c t t 2te 3Initial Value Problem Differential Equations 173
 3. Solve the following system of IVPs using the elimination method.
dx
Answer:
x
 4. Solve the following system of IVPs using the elimination method.
dx
Answer:
x
5. Solve the following ODEs using eigenvalue and eigenvector.
dx174 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Answer:
133
x( )t t = + 3cos( ) 8 e t 2 2 t t sin 8( )e
8
( ) ( ) 2 2 t t 25
y t = −10cos 8t e + sin 8( )t e
8
 6. Solve the following two ODEs using the eigenvalue and eigenvector 
technique.
dx
= + 2 3 x y dt
dy = + 4x y dt
Answer:
x( )t c = + 5 1e c t t 3 2 2e−
y t( ) = − c e5t t 1 4c e−2 1
7. Solve the following two ODEs using the elimination method.
dy = 3x
dt
dx = y dt
Answer:
x( )t c = + 3 3 1e c t t 2e−
x( )t c = − 3 3 3 3 1e c t t 2e−Initial Value Problem Differential Equations 175
 8. Solve the following two ODEs using the elimination method.
dy
Answer:
x
 9. Solve the following two ODEs using the elimination method.
dy
Answer:
x
 10. Solve the following two ODEs using eigenvalue and eigenvector techniques.
dx
Answer:
x
REFERENCE
1. Griffiths, D.F. and Higham, D.J., 2011. Numerical Methods for Ordinary Differential 
Equations. New York, NY: Springer.177
6 Numerical Integration 
of Definite Functions
Numerical integration estimates the values of definite integrals when a closed integral 
form is challenging to find. The integral is evaluated at a finite set of points called 
the points of integration, and a weighted sum of these values is used to approximate 
the integral. This chapter aims to calculate definite integrals using various numerical 
integration methods and validate the manual calculations with those programmed 
using Python and the Simulink graphical programming of MATLAB. The integra￾tion methods include Simpson, Trapezoidal, Midpoint, Boole, and Romberg rules.
LEARNING OBJECTIVES
1. Calculate a definite integral using Simpson’s rule.
2. Estimate a definite integral using Trapezoidal rule. 
3. Assess a definite integral using Midpoint rule.
4. Evaluate a definite integral using Boole’s rule.
5. Use Romberg’s rule to estimate the value of a definite integral.
6. Apply Simulink and Python to compute definite integrals.
6.1 INTRODUCTION
There are cases where it is difficult to find an analytical solution to a definite inte￾gral. However, it is possible to approximate the integral by dividing the function 
into small subintervals and approximating the area. Numerical integration includes 
a wide range of algorithms for calculating the numerical value of a definite integral. 
Integration is often used to find the area under the graph of a function, and the area 
can be found by adding small slices close to zero width. The definite integral is a for￾mal computation of the area under a function using tiny fragments or lines from the 
area. A definite integral has start and end values: in other words, there is an interval 
[a, b], where a and b are called limits, bounds, or boundaries.
Numerical integration methods combine evaluations of the integral to obtain an 
approximation of the definite integral. Integration is evaluated at a finite set of points 
called integration points, and a weighted sum of these values is used to approximate 
the integral. In numerical analysis, numerical integration constitutes a wide range 
of algorithms for calculating the numerical value of a definite integral, and thus, 
the term is sometimes also used to describe the numerical solution of differential 
equations. The fundamental problem that is considered by numerical integration is 
calculating an approximate solution to a definite integral. They differ from analytic 
integration in two ways: The first is approximate and will not yield an exact answer; 
error analysis is an essential aspect of numerical integration. Second, it does not 
DOI: 10.1201/9781003360544-6178 Numerical Methods in Chemical Engineering Using Python® and Simulink®
result in an initial function from which the area can be determined due to arbitrary 
bounds; it only produces an approximate numerical value for the area [1]. A definite 
integral is an area under a curve between two fixed limits. The following is a definite 
integral of f x( ) concerning dx from a to b:
∫
b
f x( )dx (6.1)
a
where a and b are lower and upper integral limits, f ( ) x is the integrand, and dx is the 
integrating agent. The definite integral of the real-valued function:
∫
b
f x( )dx = − F b( ) F a( ) (6.2)
a
When having a continuous function f ( ) x of the interval [a, b], the interval is divided 
into n subdivisions of equal width (h), and from each interval, choose a point, xi. 
Then the definite integral of the mentioned function is
b n
∫ f x( )dx = ∆ lim ∑f x( )i x (6.3) n→∞
a i=1
The number at the bottom of the integral sign (a) is the integral lower limit, and 
(b) at the top of the integral sign is the integral upper limit. Numerical integration 
estimates the values of definite integrals when an approximate value only of the defi￾nite integral is needed or when a closed-form integral is difficult to find. The most 
used numerical integration techniques are the Simpson, Trapezoidal, and Midpoint 
rules. Simpson’s rule approximates the definite integral using quadratic functions; 
the Trapezoidal rule approximates the definite integral using trapezoidal regions; the 
Midpoint rule approximates the definite integral using rectangular approximation; 
Boole’s rule represents the area under the curve y f = ( ) x and between the coordi￾nates x = a and x = b. Romberg’s method evaluates the integrand at equally spaced 
points, and the integrand must have continuous derivatives. The Romberg integration 
(I) is approximated using the composite Trapezoidal rule.
6.2 SIMPSON’S RULE
Simpson’s rule is a numerical technique approximating a definite integral’s value 
using a quadratic function. The method is named after the English mathematician 
Thomas Simpson (1710–1761). In Simpson’s rule, we estimate the areas of regions 
under curves by using rectangles. Simpson’s rule is a method for approximating a 
definite integral using a multidefined quadratic function; the method uses parabolas 
rather than a straight line. In numerical analysis, Simpson’s 1/3 rule is a method for 
the numerical approximation of definite integrals. Specifically, it is the following 
approximation:Numerical Integration of Definite Functions 179
∫
b
f x( ) h dx = + { f x( ) o 4 2 f x( ) 1 2 + + f x( ) 4 f x( ) 3 +…+ f x( ) (6.4) 3 a
n }
To obtain an approximate value of the definite integral, split the main interval into 
subintervals with an even number of n subintervals (Figure 6.1). Each step size 
(width), h, can be defined as follows:
b a − h = (6.5) n
Simpson’s rule works best when the function has a similar shape to the approxima￾tion device within a narrow interval. 
Example 6.1 Application of Simpson’s Rule
Use Simpson’s rule to integrate the following definite integral, dividing it into two 
subintervals.
1
∫x d3 x
0
Evaluate the definite integral manually and confirm the manual calculations with 
the following approaches:
a. Simulink/MATLAB programming of Simpson’s rule with n subinterval.
b. Write a Python program to evaluate a definite integral using Simpson’s rule 
with n subdivisions.
FIGURE 6.1 Graphical representation of Simpson’s rule.180 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solution
Divide the main interval [0,1] into two subintervals with a width, h,
1 0 − 1 h = = 2 2
Substitute in Simpson’s rule formula as follows:
h  1  Sn = +  ( )   f f 0 4   + f ( ) 1  3   2 
Substitute the values of the function at the subdivisions
 1     2   1  Sn =  0 4 + +1 3  8 
The approximate numerical value of the definite integral is
1 Sn = = 0.25
4
The exact value of the definite integral is
∫
1 4
3 x 1 1 x dx = = − = 0 = 0.25
4 4 4 0
The approximate numerical value agreed with the exact value of the definite 
integral.
Simulink Solution
Using the Simpson rule, the Simulink block diagram for solving Example 6.1 is 
described in Figure 6.2. The figure is followed by the MATLAB program associated 
with the Simulink MATLAB function. The MATLAB function is connected to three 
input ports: the lower integral limit (a), the upper integral limit (b), and the number 
of subintervals (n). There is one output port connected to the Display block to release 
the output value of the integral. The following program is the MATLAB code associ￾ated with the Simulink MATLAB function [2].
function res = simp(a, b, n)
f=@(x)x^3; %the desired function
h=(b-a)/n;
s0=f(a)+f(b);
s1=0;
s2=0;
for i=1:(n-1)
x=a+i*h;
if rem(i, 2)==0Numerical Integration of Definite Functions 181
s2=s2+f(x);
else
s1=s1+f(x);
end
end
res=(h/3)*(s0+2*s2+4*s1);
end
Python Solution
This Python program uses Simpson’s 1/3 rule to determine the approximate solu￾tion of the definite integral required in Example 6.1. In the implementation, the 
function input parameters a, b, and n return the approximation results into the 
Display block [3].
# Example 6.1
# Solution of a definite integral using Simpson’s rule with n 
# subdivisions
def f(x):
return x**3
# the lower limit, upper limit, subinterval number
a=0
b=1
n=2
h= (b-a)/n
sum = f(a)+f(b)
d=4
for k in range(1,n):
x= a+k*h
sum= sum+ d*f(x)
d= 6-d
sum= h/3*sum
print(“value of the integral= “, sum)
The executed result is
value of the integral= 0.25
FIGURE 6.2 A Simulink solution using the Simpson rule of the definite integral defined in 
Example 6.1. 182 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Example 6.2 Application of Simpson’s Rule
Estimate the following definite integral using Simpson’s rule, dividing it into six 
subdivisions.
∫
4
1 x d2 x 2 1
Evaluate the definite integral manually and confirm the manual calculations with 
the following approaches:
a. Simulink/MATLAB programming of Simpson’s rule with n subinterval.
Solution
The step size (h) for six subintervals
4 1 − 1 h = = 6 2
Starting with Simpson’s rule formula,
h Sn = + ( f x( ) 0 1 4 2 f x( ) + + f x( ) 2 3 4 2 f x( ) + + f x( ) 4 5 4 f x( ) + f x( ) 6 ) 3
As a function of x,
h  ( )  3  5  7  Sn = +  f f 1 4   + + 2 2 f f ( ) 4   + + 2 3 f f ( ) 4   + f ( ) 4
3   2  2    2  
Substitute the values obtained from function f ( ) x at each node
 1     2 Sn = (0.5 + + 4 ( ) 1.125 2( ) 2.0 + + 4( ) 3.125 2( ) 4.5 + + 4( ) 6.125 8 = 10.5
3 )
The correct solution is
∫
4
1 2 x3 3 4 1 − 3
x dx = = = 10.5
2 2 3 6 1 ( )( )
The approximate numerical value of the definite integral is identical to the exact 
value.
 b. Write a Python program to evaluate a definite integral using Simpson’s rule Numerical Integration of Definite Functions 183
Simulink Solution
Figure 6.3 is the Simulink graphical programming using Simpson’s rule, represent￾ing the solution of the definite integral defined in Example 6.2. The figure is fol￾lowed by the MATLAB code associated with the MATLAB function, where a and b 
are the lower and upper interval limits, respectively, and n is the number of subdi￾visions. The output port is connected to the Display block and outputs the integra￾tion value between the two limits (a and b).
The following program is the MATLAB code using Simpson’s rule and implanted 
in the Simulink MATLAB function.
function res = simp(a, b, n)
f=@(x)0.5*x^2; %the desired function
h=(b-a)/n;
s0=f(a)+f(b);
s1=0;
s2=0;
for i=1:(n-1)
x=a+i*h;
if rem(i, 2)==0
s2=s2+f(x);
else
s1=s1+f(x);
end
end
res=(h/3)*(s0+2*s2+4*s1);
end
Python Solution
The “SciPy. Integration” subpackage includes many functions for approximating 
integrals numerically and solving differential equations. Using Simpson’s rule avail￾able in Scipy, the following program is the Python code, which resulted in an 
integral execution value of 10.5.
FIGURE 6.3 A Simulink block diagram using the Simpson rule demonstrating the solution 
of the definite integral specified in Example 6.2.184 Numerical Methods in Chemical Engineering Using Python® and Simulink®
# Example 6.2
# Simpson’s rule is available in Scipy.
import numpy as np
import scipy.integrate as spi
a=1
b=4
N=6
x=np.linspace(a, b, N-1)
y=0.5*x*x
approx=spi.simps(y, x)
print(“value of the integral= “, approx)
The program execution result is
value of the integral= 10.5
Example 6.3 Application Simpson’s Rule
Use Simpson’s rule with four subdivisions ( 4 n = ) to approximate the following 
definite integral.
8
f ( ) x x = ∫ 0.5dx
0
Evaluate the definite integral manually and check the manual calculations with the 
following approaches:
 1. Simulink/MATLAB programming of Simpson’s rule with n subintervals.
 2. Write a Python program to evaluate a definite integral using Simpson’s rule 
with n subdivisions.
Solution
The step size of each interval is calculated as follows:
b a − 8 0 − h = = = 2 n 4
Calculate the function values at the points of xi : [0, 2, 4, 6, 8]
f ( ) x f 0 00.5 o = = ( ) = 0
f ( ) x f 1 = = ( ) 2 20.5 = 1.414
f ( ) x f 2 = = ( ) 4 40.5 = 2
f ( ) x f = = ( ) 6 60.5 3 = 2.449
f ( ) x f 0. 4 = = ( ) 8 8 5 = 2.828Numerical Integration of Definite Functions 185
Substitute these into Simpson’s rule formula as follows:
∫
8
x d 0.5 h x ≅ + 
 f x( ) 4 2 ( ) + + ( ) 4 ( ) 3 o f x1 2 f x f x3 4 + f x( )
0
Substitute the values of the function f ( ) x for each subinterval
2
∫
8
x d 0.5 x ≅ + 
0 4( ) 1.414 + + 2 2( ) 4( ) 2.449 + ( ) 2.828  ≈14.85
3 0
The correct (analytical) solution
∫
8
 8
x 0.5 1+
0.5  x dx =   = − (81.5 1 0 ) .5  /1.5 ≈15.09
1.5 0 0  
The percent error in approximating the integral compared with the exact analytical 
solution
15.09 −14.86 E = × = 100% 1.5%
15.09
Simulink Solution
Figure 6.4 represents Simpson’s rule programmed in MATLAB and linked to the 
Simulink MATLAB function. The Simulink block diagram can be used to solve 
other functions by changing the values of integral limits (a, b) and the number 
of subintervals (n). Other functions can replace the desired integral function in 
the MATLAB code to solve other definite integrals. The following program is the 
MATLAB code utilizing the Simpson rule and embedded in the Simulink MATLAB 
function located at the center of Figure 6.4.
function res = simp(a, b, n)
f=@(x)x^0.5; %the desired function
h=(b-a)/n;
s0=f(a)+f(b);
s1=0;
s2=0;
for i=1:(n-1)
x=a+i*h;
if rem(i, 2)==0
s2=s2+f(x);
else
s1=s1+f(x);
end
end
res=(h/3)*(s0+2*s2+4*s1);
end186 Numerical Methods in Chemical Engineering Using Python® and Simulink®
FIGURE 6.4 Simulink solution employing Simpson’s rule for solving the definite integral 
associated with Example 6.3.
Python Solution
In this example, the Simpson rule function is included, and there is no need to 
import the “SciPy. integrate” library. The Simpson function keeps track of the run￾ning sum and the multiplicands associated with each evaluation of the function, 
but the function to be evaluated is an actual Python program that takes in a single 
argument, x, and returns its value. The Trapezoidal rule yields comparable results, 
and the following is the Python program written to evaluate the desired definite 
integral using Simpson’s rule with n subdivisions.
# Example 6.3
# The program evaluates a definite integral using Simpson’s
# rule with n subdivisions
# Implementing Simpson’s 1/3 rule
def f(x):
return x**0.5 # The desired function
def simpson(x0,xn, n):
h= (xn-x0)/n # The step size
Sum=f(x0)+f(xn)
for i in range(1,n):
j = x0 + i*h
if i%2 == 0:
Sum = Sum + 2 * f(j)
else:
Sum= Sum + 4 * f(j)
#Finding value
Sum = Sum * h/3
return Sum
result = simpson(0,8, 4)
print(“The value is: %0.5f” % (result))
The execution result is
The value is: 14.85549Numerical Integration of Definite Functions 187
6.3 TRAPEZOIDAL RULE
The Trapezoidal rule is a rule that evaluates the area under the curve. The area under 
the curve is calculated by dividing the total area into small trapezoids instead of the 
rectangles that divide the interval [a, b] into n equal subintervals, each of width, h, 
as shown in Figure 6.5.
b a − h = n
Such that,
a = < x x o n 1 2 < …x x < = b
The Trapezoidal rule approximates the definite integrals and uses the linear approxi￾mation of the functions. When the underlying function is smooth, the Trapezoidal 
rule does not give values as accurate as Simpson’s rule because Simpson’s rule 
uses the quadratic approximation rather than the linear approximation used by the 
Trapezoidal rule. Both the Trapezoidal rule and Simpson’s rule give the approxima￾tion value. By contrast, Simpson’s rule gives more accurate values of the definite 
integral.
The function, f ( ) x , is a continuous function over the interval [a, b]. The approxi￾mate solution of such a function is given by
∫
b
f x( ) h dx = + ( f x( ) 012 2 2 f x( ) + + f x( ) …+ 2   f x( ) − + ( ) 2 n n 1 f x (6.5)
a
)
FIGURE 6.5 Graphical interpretation of Trapezoidal rule.188 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Example 6.4 Application of Trapezoidal Rule
Estimate the following definite integral using the Trapezoidal rule utilizing four 
subintervals, estimating the absolute and relative error.
1
∫x d2 x
0
Evaluate the definite integral manually and support the manual calculations with 
the following approaches:
 1. Simulink/MATLAB programming of the Trapezoidal rule.
 2. Write a Python program to evaluate a definite integral using the Trapezoidal 
rule with n subdivisions.
Solution
First, calculate the step size, h, using the integral upper limit (b) and lower limit (a) 
and the number of the subintervals (n):
b a − 1 0 − 1 h = = = n 4 4
The Trapezoidal rule
1
∫
1    
= = 2  4    1   1 3 T x n f f ( )     dx  0 2 +   + 2 f f   +…+ 2   + f ( ) 1          2  4 2 4  0
Find the functions at different intervals and substitute them into the Trapezoidal 
technique formula
1 1  
∫   2  4    1   1   9   11 T x n = = dx  0 2 +   + 2  +…+ 2  + ( ) 1 0.344
2  16     = =  4 16   32 0
The calculated value from the direct integration
1 1 3 1
∫ 2 x  x dx =  = 3 3 0 0 
The absolute error is calculated
1 11 1 − = 3 32 192
The percent relative error isNumerical Integration of Definite Functions 189
1 11 1 − 3 32 = × 192 100% = 3.1% 1 1
3 3
Simulink Solution
Using the MATLAB function that utilizes the Trapezoidal rule implanted in the 
Simulink MATLAB function (Figure 6.6), the embedded MATLAB code follows 
Figure 6.6. The Simulink block diagram can be used to solve other functions by 
changing the values of integral limits (a, b), the number of subintervals (n), and the 
desired function in MATLAB code.
The following program is the MATLAB code embedded in the Simulink 
MATLAB function and centered in Figure 6.6. The function can be used to solve 
other definite integrals by changing the desired function.
function result = Trapz(a, b, n)
f=@(x)x^2; %the desired function
h=(b-a)/n;
sum = 0;
for i=1:(n-1)
sum = sum +f(a+i*h);
end
result = (h/2)*(f(a)+f(b)+2*sum);
end
FIGURE 6.6 Trapezoidal rule programmed in Simulink/MATLAB function for solving the 
definite integral specified in Example 6.4.190 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Python Solution
The Trapezoidal algorithm is used without importing the function from the Python 
library in the solution of this example using Python programming. The function (f) 
can be changed to any other desired function. The Trapezoidal rule yields compa￾rable results to Simpson’s rule.
# Example 6.4
# Python program to evaluate a definite integral using 
Trapezoidal’s # rule with n subdivisions
# Implementing Trapezoidal’s rule
def trapezoid(a, b, n):
f= lambda x: x**2 # the desired function
sum = 0
h= (b - a ) / n
for k in range(n + 1):
x = a + (k * h)
summand = f(x)
if (k != 0) and (k != n):
summand *= 2
sum += summand
return sum * h / 2
# Example of use
result =trapezoid(0, 1, 4)
print(“The calculated value is: %0.5f” % (result))
The execution result is
The calculated value is: 0.34375
6.4 RECTANGLE RULE (MIDPOINT RULE)
The Midpoint rule approximates the area between the graph of f ( ) x and the x-axis 
by adding the rectangular area with midpoints that are points on the function f ( ) x . 
Assume f ( ) x is continuous on the interval [ ] a b,  . If divided into n subintervals, each 
of length h and mi is the midpoint of the ith subinterval, and the approximate area 
under the curve is estimated as
= ∑
n
M h n f m( )i (6.6)
i=1
The Midpoint rule is more accurate than the Trapezoidal rule. Figure 6.7 graphically 
demonstrates the Midpoint rule. 
Example 6.5 Applying the Midpoint Rule
Use the Midpoint rule with four subdivisions to evaluate the following definite 
integral.Numerical Integration of Definite Functions 191
∫
1
x d2 x
0
Compare the approximate numerical integration result using the Midpoint rule 
with actual analytical integration value and Python and Simulink/MATLAB pro￾gramming of the Midpoint rule.
Solution
The actual value of this integral is as follows:
∫
1
x 
1 3
2 1 0 1 x dx =  = − = 3  3 3 3 0 0
The interval length
b a − 1 0 − 1 h = = = n 4 4
There are four subintervals
 1 1 3  0   −− −−   − − − −1 
 4 2 4 

The middle point of these subintervals
 1 1 3 1 5 3 7  0 − − − −   − − − −1 
 8 4 8 2 8 4 8 

FIGURE 6.7 Graphical clarification of Midpoint rule.192 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The integral is calculated using the Midpoint rule as follows:
∫
1
x d2 1   1  3  5  7   x =  ffff   +   +   +    4  8  8      0  8 8 
Find the function and substitute
1
∫x d2 1 1 9 25 21 21 x = 4 64 64 64 64 64 0
{ } +++ = = 0.328
The absolute error
A B −
1 21 1 − = 3 64 192
The relative error is the error as a percentage of the actual value and is given by
A B − ×100%
A
where A is the actual value and B is our estimated value. Figure 6.8 shows the 
Simulink block diagram representing the Midpoint rule function. The Simulink 
block diagram can be utilized to solve other functions by changing the values of 
integral limits (a, b), the number of subintervals (n), and the desired function in 
MATLAB code.
The following MATLAB program of the Midpoint method is rooted in the 
MATLAB function (Figure 6.8).
function Result = Midp(a, b, n)
f=@(x)x^2; %the desired function
h=(b-a)/n;
sum = 0;
FIGURE 6.8 Simulink midpoint block diagram represents the solution of the definite inte￾gral required in Example 6.5.Numerical Integration of Definite Functions 193
for i=1:n
sum = sum +h*(f((a+(a+h))/2));
a=a+h;
end
Result = sum;
End
Python Solution
The Midpoint rule evaluates the desired function between each point in the 
required interval. Using the functions from the Python library is certainly much 
faster to implement. By contrast, the following Midpoint method in Python was 
interesting to learn how the function works.
# Example 6.5
# Python program to evaluate a definite integral using Midpoint’s 
# rule with n subdivisions
# implementing Midpoint’s Rule
def midpoint(a, b, n):
f=lambda x:x**2 # The desired function
sum = 0
x_in=((2*n+1)*a-b)/(2*n)
h=(b-a)/n
for k in range (1,n+1):
x=x_in+(k*h)
sum= sum + f(x)
return sum*h
# Example to use
Res = midpoint (0,1,4)
print(“The calculated value is: %0.5f” % (Res))
The result after the program execution is
The calculated value is: 0.32812
6.5 BOOLE’S RULE
The method is named after a famous English mathematician George Boole (1815–
1864). Boole’s rule is derived by putting n = 4 in the general quadrature formula, 
which means f ( ) x can be approximated by a polynomial of the fourth degree. It is 
used to evaluate the definite integral, and it can only be used for problems with sub￾interval, i.e., n = 4 (Figure 6.9).
∫
b
2h f x( )dx = +   7( y y o 32 1 2 + + 12y y 32
45 3 4 + + 14y y 32 5 6 + + 12y y 32 7 8 + + 14y ..
a
)
Example 6.6 Applying Boole’s Rule to Estimate a Definite Integral
Estimate for following definite integral using Boole’s rule, assuming the number of 
intervals equals 4.
∫
1
dx
1+ x 2
0194 Numerical Methods in Chemical Engineering Using Python® and Simulink®
FIGURE 6.9 Graphical representation of Boole’s rule.
Compare the result of the approximate numerical integration using Boole’s rule 
with actual analytical integration value and employ Python and Simulink/MATLAB 
programming of Boole’s rule.
Solution
From the given data, assuming n = 4, then
b a − 1 0 − 1 h = = = 4 4 4
Applying Boole’s formula,
∫
1
dx 2h
= + y y y y x [ ] + + + y 1+ 2   7 0 1 32 12 2 3 32 7
45 4
0
Then substitute the obtained values at each subinterval
∫
1
dx 2h  ( )  1   1   3  = + f f 0 32   + f f 32   + 7 1 f ( )   7 12   +
1+ x 2 45 
  4   2   4  
0 
Substitute
1
2
∫ dx h 2 = +   7
 ( ) 1 32( ) 0.9412 + + 12( ) 0.8 32( ) 0.64 + 7( ) 0.5  = 0.7855
1+ x 45 0
Accordingly, the obtained approximate solution of the defined integral is 0.7855.
Simulink Solution
The Simulink block diagram represents the solution of the definite function speci￾fied in Example 6.6, shown in Figure 6.10. Boole’s method programmed in the 
MATLAB code is associated with the Simulink MATLAB function. The Simulink 
block diagram can be utilized to solve other integrals by changing the values of Numerical Integration of Definite Functions 195
FIGURE 6.10 Simulink block diagram utilizing Boole method to estimate the definite inte￾gral needed in Example 6.6.
integral limits (a, b), the number of subintervals (n), and the desired function in 
MATLAB code.
The following is the MATLAB code implanted in the Simulink MATLAB func￾tion to solve the equation required in Example 6.6.
function Result = Bool(a, b, n)
f=@(x)1/(1+x^2); %the desired function
h=(b-a)/n;
sum = 7*(f(a)+f(b));
sum = sum +32*(f(a+h)+f(b-h));
sum = sum +12*(f(a+2*h));
Result = 2*sum*h/45;
Python Solution
Here, Example 6.6 is solved by programming Boole’s rule in Python. The program 
evaluates the required integral within the interval [0, 1] and with n subdivisions.
# Example 6.6
# Python program to evaluate a definite integral using Boole 
method
# implementing the Boole method
def Boole(a, b, n):
f=lambda x:1/(1+x**2 )# The desired function
h = (b-a)/n
sum = 7*(f(a)+f(b))
sum = sum +32*(f(a+h)+f(b-h))
sum = sum+ 12*(f(a+2*h))
res = 2*sum*h/45
return res
# Example to use
res = Boole (0,1,4)
print(“The calculated value is: %0.5f” % (res))
The result after running the program is
The calculated value is: 0.78553196 Numerical Methods in Chemical Engineering Using Python® and Simulink®
6.6 R OMBERG INTEGRATION AND 
RICHARDSON EXTRAPOLATION
Romberg integration is an approximate computation of integrals using numerical 
techniques. This method improves the approximate result obtained by the finite dif￾ference method. Romberg’s method is used to estimate a definite integral
∫
b
f x( )dx
a
Romberg integration combines the composite Trapezoidal rule with Richardson 
extrapolation (Table 6.1). The composite Trapezoidal rule
b
I ∫ h  n−1  = = f x( )dx   2  f a( ) + + ∑f x( ) 2 i f b( )
a 
 i=1 

where
b a − h = n
xi i = + x h −1
This procedure ends when two successive values are remarkably close (Figure 6.11). 
TABLE 6.1
The Romberg Integration Table
hi Ii
′ Ii
′ Ii
′′ Ii
′′′
h I1 I1′ = I2 + 1
3
(I2 − I1 )
I1′′= 1 I1′ + (I2′ − 3
I1 )
h
2
I2 I2′ = I3 + 1
3
(I3 − I2 ) I1′′′= 1 I2′′+ ( 3
I2′′− I1′′)
I2′′ = 1 I3′ + (I3′ − 3
I2 )
h
4
I3 I3′ = I4 + 1
3
(I4 − I3 )
h
8
I4Numerical Integration of Definite Functions 197
Example 6.7 Applying Romberg’s Rule
Evaluate for following definite integral by Boole’s rule in four subintervals.
∫
8
x d2 x
0
Compare the approximate numerical integration result of manual calculation 
with actual analytical integration value and the result from utilizing Python and 
Simulink/MATLAB programming of Romberg’s rule.
Solution
Find the step size
b a − 8 0 − h = = = 2 n 4
f ( ) x x = 2
The interval will be
h    = 4
∫
8
x d2 h x = +   2
2 { } f x( ) o f x( )1 4 + f x( )
0
∫
8
I = = x d2 4 1 x f   0( ) + + 2  f f ( ) 4 ( ) x 2 { } ( ) 4
0
8
2 2 4 I 2 2 1 = = ∫x dx   0 + + 2  4 8
2 { } () () ( ) = 192
0
FIGURE 6.11 Graphical representation of the (a) Romberg integration and (b) Richardson 
extrapolation.198 Numerical Methods in Chemical Engineering Using Python® and Simulink®
h = 2
∫
8
2 h x dx = +   2 { f x( ) o + + +
2 ( f x( )1 2 f x( ) f x( ) 3 4 f x( )
0
∫
8
2 h I2 = = x dx   0( ) + + 2  ( ) 246 ( ) + + ( ) ( ) 8
2 { f f ( f f f
0
8
2 I = = x d2 2 2 ∫ x   0 2  246 2 2 + + 8 ) = 176
2 { + + ( ) 2 2
0
h    = 1
1 I { 2 2 3 = +   0 2 (1 + + 234 2 2 + +2 2 5 6 + +2 2 7 8 + = 2 172
2
h    = 0.5
0.5 I 2 2 2 2 2 2 3 = +   0{ 2 (0.5 + + 1 1.5 + +.. 7.5 + = 8 171
2
) }
) }
}
) }
) }
The rest of the calculation is listed in Table 6.2.
Finally,
1
( )  1 I1 2 ′′′= + I I 170.66 170.66 170.66 170.66
3 2 1 ′′− I′′ = +  ( ) − =  3
∫
8
x d2 x = 170.66
0
Simulink Solution
The Romberg method programmed in the MATLAB code is associated with the 
Simulink MATLAB function. The Simulink block diagram can be utilized to solve other 
integrals by changing the values of integral limits (a,b), the number of subintervals 
TABLE 6.2
This Arithmetic Procedure Ends When Two Consecutive Values Are 
Very Close (170.66)
hi Ii Ii
′ Ii
′′
h 192 176 + 1/3 (176 – 192) = 170.66 170.66 + 1/3 (170.66 – 170.66) = 170.66
h 176 172 + 1/3 (172 – 176) = 170.66 170.66 + 1/3 (170.66 – 170.66) = 170.66
2
h 172 171 + 1/3 (171 – 172) = 170.66
4
h 171
8Numerical Integration of Definite Functions 199
(n), and the desired function in MATLAB code. The Simulink block diagram for solv￾ing the definite integral required in Example 6.7 is shown in Figure 6.12. To reach 
h= 0.5, the program’s n value equals 16.
The following is the MATLAB program refers to the Romberg integration 
method associated with the Simulink MATLAB function.
function Result = Romberg(a, b, n)
f=@(x)x) x^2; %the desired function
h=(b-a);
r=zeros(2,n+1);
r(1,1)=(f(a)+f(b))/(2*h);
for i = 2:n
rv=0;
for k = 1:2^(i-2)
rv=rv+f(a+(k-0.5)*h);
end
r(2,1)=(r(1,1) + h*rv)/2;
for j=2:i
l=2^(2*(j-1));
r(2,j)=r(2,j-1)+(r(2,j-1)-r(1,j-1))/(l-1);
end
for k=1:i
fprintf(‘%7.5f’, r(2,k));
end
fprintf(‘\n\n’);
h=h/2;
for j=1:i
r(1,j)=r(2,j);
end
end
Result=r(1,n);
End
FIGURE 6.12 Simulink solution applying Romberg’s rule programmed to solve the definite 
integral identified in Example 6.7.200 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Python Solution
Romberg integration method of a definite integral returns the integral of a function 
of one variable over the interval [a, b]. The printed solution represents the triangu￾lar array of the intermediate results. The following Python program uses Romberg’s 
rule available in Scipy to evaluate the definite integral specified in Example 6.7.
# Example 6.7
# The program evaluates a definite integral using Romberg’s rule
# Implementing the Romberg method
import numpy as np
from scipy import integrate
f = lambda x: x**2 # The desired function
# using scipy.integrate.romberg()
res = integrate.romberg(f, 0, 8, show = True)
print(“The calculated value is: %0.5f” % (res))
The result of the definite integral of the function defined in Example 6.7 is as 
follows:
Steps StepSize Results
1 8.000000 256.000000
2 4.000000 192.000000 170.666667
4 2.000000 176.000000 170.666667 170.666667
The final result is 170.66666666666666 after 5 function 
evaluations.
The calculated value is: 170.66667
Example 6.8 Applying the Romberg Integration Technique
Solve the following integral utilizing the Romberg integration method
∫
1
1 dx x +1 0
Compare the approximate numerical integration result of manual calculation with 
actual analytical integration value and utilize Python and Simulink/MATLAB pro￾gramming of Romberg’s rule.
Solution
First, start with the Trapezoidal rule
h = 0.5
0.5 I1 = = f x( )dx f f ( ) 0 2 + ( ) 0.5 f ( ) 1
2 {
( ) 0.5 I1 = = f x dx { f f ( ) 0 2 + ( ) 0.5 f ( ) 1
2
+ }
+ }Numerical Integration of Definite Functions 201
0.5 h = = 0.25
2
( ) 0.25 I2 = = f x dx { f f ( ) 0 2 + + ( ( ) 0.25 f f ( ) 0.5 + + ( ) 0.75 f ( ) 1
2
( ) 0.25 I2 = = f x dx {1 2 + + ( ) 0.8 0.667 + + 0.5714 0.5 = 0.697
) }
} 2
0.25 h = = 0.125
2
  0.125 + + ( ) 0.25 f f ( ) 0.375 + +  f f ( ) ( ) 0.5 f f (0.625 0.75  0.125 + ( )  I3 = +  f ( ) 0 2  + f ( ) 1  2 
 + 0.875   f (    
0.125 I3 = + ( ) 1 2(0.89 + 0.8 +++ 0.727 0.667 0.615 0.57 + =
2 { + + 53 0.5 0.694 ) }
Table 6.3 lists the rest of the calculation.
The Simulink graphical programming utilizing the Romberg rule is demon￾strated in Figure 6.13, followed by the MATLAB code associated with the MATLAB 
function.
By double-clicking the Simulink MATLAB function block, the following code 
will appear.
function Result = Romberg(a, b, n)
f=@(x)1/(1+x); %the desired function
h=(b-a);
r=zeros(2,n+1);
r(1,1)=(f(a)+f(b))/(2*h);
for i = 2:n
rv=0;
for k = 1:2^(i-2)
rv=rv+f(a+(k-0.5)*h);
end
TABLE 6.3
Romberg Integration Method of the Definite Integral Specified in Example 
6.8
hi Ii Ii
′ Ii
′′
h 0.708 0.697 + 1/3 (0.697 – 0.708) = 0.6933 0.6931 + 1/3 (0.693 – 0.6933) =0.6929
h
2
0.697 0.694 + 1/3 (0.694 – 0.697) = 0.693
h
4
0.694202 Numerical Methods in Chemical Engineering Using Python® and Simulink®
r(2,1)=(r(1,1) + h*rv)/2;
for j=2:i
l=2^(2*(j-1));
r(2,j)=r(2,j-1)+(r(2,j-1)-r(1,j-1))/(l-1);
end
for k=1:i
fprintf(‘%7.5f’, r(2,k));
end
fprintf(‘\n\n’);
h=h/2;
for j=1:i
r(1,j)=r(2,j);
end
end
Result=r(1,n);
end
Python Solution
In this example, the Romberg function is imported from the built-in Python library 
“SciPy. integrate”. We used Romberg integration of a callable function from limit (a
to b) by using “SciPy. integrate”. Romberg’s rule is available in SciPy.
# Example 6.8
# The program evaluates the definite integral using Romberg’s 
rule
# import scipy.integrate
from scipy import integrate
f = lambda x: 1/(1+x) # desired function
# using scipy.integrate.romberg()
res = integrate.romberg(f, 0, 1, show = True)
print(res)
FIGURE 6.13 Simulink program utilizing Romberg integration method for solving the defi￾nite integral identified in Example 6.8.Numerical Integration of Definite Functions 203
The results of the program execution are
Steps StepSize Results
1 1.000000 0.750000
2 0.500000 0.708333 0.694444
4 0.250000 0.697024 0.693254 0.693175
8 0.125000 0.694122 0.693155 0.693148 0.693147
16 0.062500 0.693391 0.693148 0.693147 0.693147 0.693147
32 0.031250 0.693208 0.693147 0.693147 0.693147 0.693147 0.693147
The final result is 0.6931471805622968 after 33 function 
evaluations.
0.6931471805622968
6.7 SUMMARY
Numerical integration evaluates a definite integral from a set of integrand f ( ) x
numerical values. The most widely used methods of numerical integration are the 
Midpoint rule, Trapezoidal rule, and Simpson’s rule. The Midpoint rule approximates 
the definite integral using rectangular areas, while the Trapezoidal rule approximates 
the definite integral using a trapezoidal approximation. We can use numerical inte￾gration to estimate the values of definite integrals when it is difficult to find a closed 
form or when only an approximate value of the definite integral is needed. The most 
widely used methods of numerical integration are the Midpoint rule, Trapezoidal 
rule, and Simpson’s rule.
6.8 PROBLEM
1. Solve the integral by the Trapezoidal rule with h = 0.5, 25, and 0.125. Then 
obtain a better estimate using the Romberg integration method. Compared 
with Simulink and the analytical solution.
1
1 0
1
∫ ( ) = +
f x
x
dx
2. Using Simpson’s rule, estimate the approximate value with n = 4 (n = Even). 
Compared with the Simulink and the analytical solution.
2
10
3
∫x dx
Answer: 2496204 Numerical Methods in Chemical Engineering Using Python® and Simulink®
 3. Calculate the approximate value of the following definite integral using the 
f ( ) ∫
2
1
x = dx
x 1
Answer: 0.694
4. Calculate the approximate value of the following definite integral using 
Simpson’s rule with n = 6 (note that n should be an even number). Compared 
with the Simulink and the analytical solution.
∫ ∫
2 2
( ) 1 f x dx = 1 0.5 dx
0 0 ( ) x +
Answer: 1.4642
 5. Use the Midpoint rule to get the approximate value (
3.
∫ ∫
5 3.5
f x( )dx = 0.25 x d3 x
−0.5 −0.5
Answer: 9
 6. Use the Midpoint rule to get the approximate value ( =
∫
5
x x ( ) 2 − dx
1
Answer: −16.7407
 7. Use Boole’s rule to get the approximate value (
0.6
1 2 1
0.
∫( ) + −
x dx
2
Answer: 0.343Numerical Integration of Definite Functions 205
 8. Use Boole’s rule to get the approximate value (
∫
4
( ) 1 2 + −
x d 1 x
0
Answer: 1.3624
 9. Use the Romberg integration method and Trapezoidal rule to get the approx
∫
1
( ) x d +1 −1 x
0
Answer: 0.6931
 10. Use the Romberg integration method and the Trapezoidal rule to get the 
∫
1
( ) 1 2 + −
x d 1 x
0
Answer: 0.7853
REFERENCES
1. Davis, P.J. and Rabinowitz, P., 2014, Methods of Numerical Integration. Orlando, FL: 
Academic Press Inc.
2. Woodford, C. and Phillips, C., 2012, Numerical Methods with Worked Examples. 
Cham: Springer International Publishing,.
3. Kong, Q., Siauw, T. and Bayen, A., 2020, Python Programming and Numerical 
Methods: A Guide for Engineers and Scientists. Amsterdam: Elsevier Science.207
7 Numerical Solution of 
Ordinary Differential 
Equations
An ordinary differential equation (ODE) is a mathematical equation relating one 
or more functions of the independent variable with their derivatives. Differential 
equations are important to chemical engineers as they are essential tools for the 
mathematical modeling of any problem involving rate changes. The chapter presents 
Euler, Midpoint, Heun, Runge-Kutta, and Picard’s iteration methods to solve differ￾ent ODEs. The methods produce the integral value of the desired ODE in different 
approaches and numerical precision.
LEARNING OBJECTIVES
1. Solve ODEs using the Euler method.
2. Utilize the Midpoint method to solve ODE. 
3. Use Heun’s method to solve ODE.
4. ApplyRunge-Kutta fourth-order (RK4) method. 
5. Apply Picard’s iterative method.
6. Employ Python and Simulink to solve ODE. 
7.1 INTRODUCTION
Solving differential equations is an essential skill for mathematicians and engineers. 
However, many differential equations cannot be solved using traditional symbolic calcu￾lations (analysis). Therefore, a more advanced solution method is required to solve more 
complex or lengthy differential equations. Accordingly, a numerical approximation of 
the solution is used as a method of solution and is often sufficient for practical purposes.
A differential equation is an equation that contains one or more functions and 
their derivatives; it contains derivatives that are either ordinary derivatives or par￾tial derivatives. An ODE contains one or more functions of one independent vari￾able. Different numerical methods are used to solve the numerical approximation for 
ODEs; depending on the desired value, the methods are used to find the numerical 
approximations to the solution of ODEs. The integral solution for ODEs is desired 
in several cases, and this use is known as ‘numerical integration’. The reason behind 
numerical integration is that many differential equations cannot be solved using sym￾bolic computation as they require long computation and are complex equations. In 
engineering and for practical purposes, an ODE is extracted from a practical applica￾tion, and the integral is required, so the numerical approximation to the solution is 
DOI: 10.1201/9781003360544-7208 Numerical Methods in Chemical Engineering Using Python® and Simulink®
sufficient to provide accurate results. Various algorithms studied in this chapter can 
be used to compute the integral value for ODEs, each with a different approach and 
accuracy level. A manual numerical solution solves each example in this class, and 
the manual solution is confirmed using Simulink/MATLAB and Python. The objec￾tive of explaining different solution methods is to educate the reader on software 
usage, keep up with the advancement of technology, and utilize available resources. 
The Euler solution has two main methods, namely explicit and implicit, each pre￾sented in this chapter. Furthermore, other methods, such as Midpoint, Heun, Runge￾Kutta, and Picard’s iteration, are explained in the solution method.
7.2 EULER METHOD (EXPLICIT METHOD)
In finding the integral value for an ODE, a solution method called the Euler method 
is used. Two leading solutions depend on the case study, either explicit or implicit. 
The parameters are calculated based on previous levels in the definitive solution, so it 
uses forward or central difference methods. The Euler method is a numerical proce￾dure for solving ODEs with a given initial value. Although this method does not out￾put a highly accurate value, it is easily solvable and helps understand the numerical 
methods approach for ODEs. The Euler method can be used to solve ODEs as long 
as the initial value is stated. Although the method is neither accurate nor efficient as 
other numerical solution methods, it helps understand the general ODE numerical 
method solution. Figure 7.1 shows the Euler method solution approach, where the 
initial coordinate point is taken and the following coordinate is solved depending on 
the step size and the trend the values are showing. The Euler method is a first-order 
method that uses the following first-order ODE.
dy = = f x( ) , y y ,   ( ) x y o o dx
The Euler method solution is based on the following equation:
y y i i +1 = + hf ( ) x y i i ,
FIGURE 7.1 Euler’s interpretation numerical method.Numerical Solution of ODEs 209
where h is the step size. 
Example 7.1 Applying the Forward Euler Method
Solve the following initial value ODE using the explicit Euler method and step size, 
h = 0.1, calculate the value of y at x = 1.4.
dy = 3x y2
dx
Consider the following initial conditions
y x( ) o o = →y y  1( ) = 2
Compare the approximate results obtained from the Euler method, Simulink, and 
Python to the actual analytical solution values
y x( ) = 2* ex2 −1
Solution
( ) dy In the Euler equation, the f x y i i , is the derivative equation , and is substituted dx
as such. Knowing the initial condition, at xo = = 1,  1 y( ) 2, we start by adding the 
step size to the initial value of x, x = +x h. At each step, the values of x    and y are 
taken from the previous step solved, and this is why an initial value is required for 
this method to work.
x1 = 1.1
y y 1 = +o o hf ( ) x y, o
y f 1 = +2 0.1 ( ) 1,2
y1 = +2 0.13 1( )2
2 = 2.6  
x2 = 1.2
y y 2 1 = + hf ( ) x y 1 1 ,
y f 2 = + 2.6 0.1 ( ) 1.1,2.6
y 2
2 = + 2.6 0.13( ) 1.1 2.6 = 3.544  
x3 = 1.3
y y 3 2 = + hf ( ) x y 2 2 ,
y f 3 = + 3.544 0.1 ( ) 1.2,3.544
y = + 3.544 0.13( ) 1.2 2
3 3.544 = 5.075  210 Numerical Methods in Chemical Engineering Using Python® and Simulink®
x4 = 1.4
y y 4 3 = + hf ( ) x y 3 3 ,
y f 4 = + 5.0747 0.1 ( ) 1.3,5.0747
y4 = + 5.0747 0.13   ( ) 1.3 2
5.0747 = 7.648 
Simulink and MATLAB Solution
Solving ODEs in Simulink/MATLAB will help understand the diagram of opera￾tion used in the ODE solution and equip the reader with more solution options. 
Therefore, a detailed step-by-step solution is presented. First, start MATLAB, then 
Simulink, while in Simulink and from modeling/setting, on the solver page, specify 
the start time, stop time, the fixed-step size, and the solver (Figure 7.2).
Figures 7.3 and 7.4 show the Simulink block diagram that describes the solution 
of Example 7.1 without writing any MATLAB code. The first integrator generates the 
variable x, while the second integrator produces the value of y. The results shown 
are for the required value at x4 = 1.4, which is 7.648, a similar value as obtained in 
the Euler method solution by hand correct to three decimal points. An alternative 
method is using the ‘MATLAB function’ available in the Simulink library under the 
‘user-defined functions’, where a code is extracted from the Simulink-created dia￾gram. The MATLAB function required for solving the ODE integral and outputting 
the value at a specific point at the normal function is presented in Example 7.1. The 
presented MATLAB code can be used for solving similar ODEs by changing the 
equation at the right-hand side of the function ‘f’ (line 2). Furthermore, the integra￾tion interval between [a, b] needs to be specified along with step size, h, and the 
initial value yo. The code is written in the area displayed after double-clicking the 
‘MATLAB function’ (Figure 7.4).
FIGURE 7.2 Solver setup of a Simulink integral to use the forward Euler method in the 
solution case in Example 7.1.Numerical Solution of ODEs 211
The following MATLAB code represents forward Euler’s method that combines 
the Simulink MATLAB function to solve the following initial value problem (IVP) 
defined in Example 7.1.
function Res = euler(a, b, h, y0)
f = @(x, y)(3*x^2*y);% ODE
x = a:h:b;
n = (b-a)/h;
y=zeros(size(x));
y(1)=y0;
FIGURE 7.3 Simulink block diagram using the Euler method of the equation defined in 
Example 7.1.
FIGURE 7.4 Simulink block diagram using the Euler method of equation specified in 
Example 7.1, the stop time is four.212 Numerical Methods in Chemical Engineering Using Python® and Simulink®
for i=1:n+1
k1 = f(x(i), y(i));
y(i+1) =y(i) + h*(k1);
end
Res=y(i+1);
End
Python Solution
The Python program is utilized to solve the IVP stated in Example 7.1. The approxi￾mate numerical integration value and the exact analytical solution are illustrated 
in Figure 7.5. The figure shows the approximate solution using the forward Euler 
method and the exact analytical solution. Figure 7.5 shows an increasing gap as the 
x value is increased due to an accumulated error. The discrepancy gap between 
the approximated and the exact solution can be shrunk by decreasing the step size, 
as decreasing the step size will increase the accuracy of the solution. The Spyder 
editor version five is used to edit and run the following Python code.
# Euler method numerical approximation
import numpy as np
from matplotlib import pyplot as plt
x0 = 1
y0 = 2 # initial conditions
xf = 1.4 # the final interval of the independent variable
n = 5 # number of steps
h= 0.1
x = np.linspace(x0,xf, n)
# define the function dy/dx = x+2y
def f(x, y):
 return 3*(x**2)*y
# set the intial condtios
y = np.zeros([n])
y[0] = y0
FIGURE 7.5 Comparison of the Euler’s method programmed in Python and the accurate 
analytical solution of the ODE defined in Example 7.1.Numerical Solution of ODEs 213
for i in range(1,n):
 y[i] = y[i-1] + h*f(x[i-1], y[i-1])
print(“x_n\t y_n”)
for i in range(n):
 print(x[i], “\t”, format(y[i], ‘6f’))
# plot section
x_true = np.linspace(1,1.4,10)
y_true = 2*np.exp(x_true**2-1)
plt.plot(x, y, ‘o-’, x_true, y_true, ‘r’)
plt.axis([1,1.45,2,8])
plt.legend([‘Euler’, ‘True’])
plt.xlabel(“x”)
plt.ylabel(“y”)
plt.grid(True)
plt.title(“Euler Solution of $y’=3x^2y, y(1)=2$”)
plt.show() 
Example 7.2 Solving ODE with the Euler Explicit Method
The forward Euler (explicit) method is a first-order numerical procedure for solv￾ing ODEs with a given initial value. Consider the following first-order differential 
equation with an initial condition y( ) 0 1 = , and a step size, h = 0.025, find y(0.1).
dy = +x y + xy dx
Manual Solution
Specify the function as the right-hand side of the ODE.
f ( ) x y, = +x y + xy
With the initial conditions and the following step size,
xo o = = 0,   1 y h ,   = 0.025
Utilizing the Euler method formula,
y y i i = + − − 1 1 hf ( ) x y i i , −1
Substitute the initial value in the Euler format to calculate y1,
y y 1 = +o o hf ( ) x y, 1 o = + 0.025  0 f ( ) ,1
y1 = +1 0.025 × + ( ) 0101 + × = 1.025
Accordingly,
y( ) 0.025 = 1.025214 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Similarly, we can calculate, y(0.05) to y(0.1) as tabulated in Table 7.1.
The exact analytical solution at x=0.1 is 1.11589, so the value obtained has an 
error % of 0.38% when compared with the explicit Euler method.
Simulink/MATLAB Solution
Simulink is a graphical programming environment in MATLAB. The Euler method 
settings are shown in Figure 7.6, where the Euler method is selected by following, 
modeling/model settings. While on the configuration parameters page, change 
the default values to those shown in Figure 7.6 (start time, stop time, type, solve, 
and the fixed-step size). The entire Simulink program utilizing the Euler method 
is described in Figure 7.7. Executing the Simulink program outputs the value y at 
x=0.1 as 1.112. The value is identical to that found in manual calculations.
An alternative way is to program the Euler method in MATLAB and embed the 
MATLAB code into the MATLAB function (Figure 7.8). The MATLAB function got 
four inputs: the lower limit interval (a), higher limit interval (b), step size (h), and the 
initial condition of y( ) yo . Running the Simulink program leads to the same previous 
results of y (1.112).
The following program is the MATLAB codes implanted in the MATLAB func￾tion of Figure 7.8. The program represents Euler’s method combined with the 
Simulink MATLAB function for solving the ODE described in Example 7.2. The 
MATLAB code can be used to solve other ODEs by changing the equation after 
the function:
TABLE 7.1
Explicit Euler Method
i x y
0 0 1
1 0.025 1.025
2 0.05 1.051891
3 0.075 1.080753
4 0.1 1.111673
FIGURE 7.6 Setting the solver to the Euler forward method of Example 7.2.Numerical Solution of ODEs 215
f=@(x, y).
function Res = euler(a, b, h, y0)
f = @(x, y)(x+y+x*y);% ODE
x = a:h:b;
n = (b-a)/h; 
y=zeros(size(x));
y(1)=y0;
FIGURE 7.7 Simulink solution using fixed-point iteration Euler method of Example 7.2.
FIGURE 7.8 Simulink MATLAB function using the Euler method of the ODE defined in 
Example 7.2.216 Numerical Methods in Chemical Engineering Using Python® and Simulink®
for i=1:n
 y(i+1) =y(i) + h*f(x(i), y(i));
end
 Res=y(i+1);
end
Python Solution
The solution of Example 7.2 in Python programming is shown below to enhance 
the reader’s programming skills. In this solution, the function Euler is created and 
called at the code’s end. Figure 7.9 depicts the approximate numerical solution 
generated after running the Python program.
# Euler method numerical approximation 
import numpy as np
from matplotlib import pyplot as plt
x0 = 0
y0 = 1 # initial conditions
xf = 0.1 # the final interval of the independent variable
n = 5 # number of steps
h= 0.025
x = np.linspace(x0,xf, n)
def f(x, y):
 return x+y+x*y
# set the intial condtios 
y = np.zeros([n])
y[0] = y0
print(“x_n\t y_n”)
for i in range(1,n):
 y[i] = y[i-1] + h*f(x[i-1], y[i-1])
for i in range(n):
print(format(x[i], ‘4f’), “\t”, format(y[i], ‘4f’))
# plot section
plt.plot(x, y, ‘-o’)
FIGURE 7.9 Python numerical approximate solution of the ODE specified in Example 7.2.Numerical Solution of ODEs 217
plt.xlabel(“x”)
plt.ylabel(“y”)
plt.grid(True)
plt.axis([0,0.12,1,1.12])
plt.title(“Euler Approximation Solution”)
plt.grid(True)
plt.show()
The results
x_n y_n
0.000000 1.000000
0.025000 1.025000
0.050000 1.051891
0.075000 1.080753
0.100000 1.111673 
7.3 BACKWARD EULER METHOD (IMPLICIT METHOD)
In numerical analysis and scientific computing, the backward Euler method (or 
implicit Euler method) is one of the most basic numerical methods for solving ODEs. 
Implicit methods find a solution by solving an equation involving both the current 
state of the system and the latter one. In this method, we must solve an equation to 
find yi+1. Solving this method outcomes in an algebraic equation requires, in some 
cases, using fixed-point iteration. It requires more time to solve this equation than the 
Euler explicit methods but results in higher accuracy of the solution. Considering the 
following first-order initial value ODE,
dy = = f x( ) , y y ,      ( ) x y o o dx
The backward Euler (Implicit) method is
y y i i + + 1 1 = + hf ( ) x y i i , +1
The new approximation yi+1 appears on both sides of the equation, and thus the 
method needs to solve an algebraic equation for unknown yi+1. Figure 7.10 shows the 
presentation of the backward Euler method. 
Example 7.3 Solving ODE with the Backward 
Euler Method (Implicit Method)
The backward Euler method is a first-order numerical procedure for solving ODEs 
with a given initial value. Consider the following first-order differential equation 
with an initial condition y( ) 0 1 = , and a step size, h = 0.025, find y(0.1).
dy = +x y + xy dx
Confirm the manual solution with Python and Simulink/MATLAB programming.218 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Manual Solution
The formula of the backward Euler method
y y i i = + −1 hf ( ) x y i i ,
Place the function equal to the right-hand side of the equation
f ( ) x y, = +x y + xy
Substituting,
i x = = 1,  0.025   
y y 1 1 = +o o hf ( ) x y, 1 1 = + y h( ) x y + +1 1 x y1
i x = = 2,  0.05   
y y 2 1 = + hf ( ) x y 2 2 , = + y h 1 2 ( ) x y + +2 2 x y2
i x = = 3,  0.075   
y y 3 2 = + hf ( ) x y 3 3 , = + y h 2 3 ( ) x y + +3 3 x y3
i x = = 4,  0.1 
y y 4 3 = + hf ( ) x y 4 4 , = + y h 3 4 ( ) x y + +4 4 x y4
Rearranging,
  1 ( ) h x + − 1 1 h y   +++   0   0  0  = −hx1 − yo
y h 1 3   1 + + ( ) x h − + y h 2 2 0 0 + = − x
0 1 + + y h 2 3 ( ) + − x h y h 3 3 + = 0   − x
0 0 + + y h 3 4 + + ( ) x h − = 1 y h 4 4 − x
FIGURE 7.10 Graphical explanation of the backward Euler method.Numerical Solution of ODEs 219
The below Python program solves the above set of linear algebraic equations. The 
result for x1 to x4 are shown below the Python program.
# Solving a set of linear algebraic equations,
import numpy as np
x0=0
y0=1
h=0.025
a1=h+h*0.025-1
a2=h+h*0.05-1
a3=h+h*0.075-1
a4=h+h*0.1-1
A1=[a1, 0,0,0]
A2=[1, a2,0,0]
A3=[0, 1,a3,0]
A4=[0,0,1,a4]
A = np.array([A1,A2 , A3 , A4 ])
B = np.array([-h*0.025-y0, -h*0.05, -h*0.075, -h*0.1])
X = np.linalg.inv(A).dot(B)
print(“ “)
print(X)
The answer is shown in a 1 × 4 matrix, each column representing a step in the solu￾tion, and the last column is at x= 0.1.
[1.02694035 1.05590793 1.08699595 1.12030431]
Simulink and MATLAB Solution
Simulink is a graphical programming language of MATLAB that helps understand 
the solution’s connections and the bigger picture. While on the Simulink page, 
click on modeling in the toolbar, then ‘model setting’ to change the configuration 
parameters. Select the type of solver, and specify the start time, stop time, and step 
size (Figure 7.11).
Figure 7.12 demonstrates the Simulink block diagram. The displayed value of y
is 1.12 at the stop time of 0.1. An alternative way to solve Example 7.3 in Simulink is 
to use the MATLAB function (Figure 7.13). The Simulink MATLAB function requires 
writing a MATLAB code describing the backward Euler method. The MATLAB 
function contains four input ports: the lower limit interval (a), upper limit interval 
(b), step size (h), and the initial condition ( ) yo , and one output port connected to 
the Display. The Display outputs the value of y at the upper limit interval.
The MATLAB code shown below represents the implicit Euler method com￾bined with the Simulink MATLAB function for the solution of the following ODE 
defined in Example 7.3.
function Res = Im_euler(a, b, h, y0)
f = @(x, y)(x+y+x*y);% ODE
%f - this is your y prime
xinit = a;
yinit = y0;
xfinal = b;
%h - step size
n = (xfinal-xinit)/h; %Calculate steps220 Numerical Methods in Chemical Engineering Using Python® and Simulink®
% Initialize arrays...
% The first elements take xinit
% yinit correspondingly, the rest fill with 0s.
x = [xinit zeros(1,n)];
y = [yinit zeros(1,n)];
%Numeric routine
for i = 1:n
x(i+1) = x(i)+h;
ynew = y(i)+h*(f(x(i), y(i)));
y(i+1) = y(i)+h*f(x(i+1), ynew);
end
Res = y(i+1);
End
FIGURE 7.12 Backward Euler method solution of the equation specified in Example 7.3.
FIGURE 7.11 Simulink modeling configuration menu for setting the simulation time, solver 
selection, and solver details of the backward Euler method for solving the equation defined 
in Example 7.3.Numerical Solution of ODEs 221
Python Solution
The Python program below uses the backward Euler method to solve the equa￾tion given in Example 7.3. Running the Python program produces the following 
numerical approximation results containing the values of y at different values of x
with a step size of h (0.025).
#Backward Euler method (Implicit method)
from scipy.optimize import fsolve
import numpy as np
x0=0
tspan =[0,0.1]
y0= 1
n=5
x1=0
def f( x, y ):
return (x + y + x * y)
# Backward Euler method (Implicit)
def backward_euler ( f, tspan, y0, n ):
x = np.zeros ( n + 1 )
y = np.zeros ( n + 1 )
h = 0.025
x[0] = 0
y[0] = 1
print (“ “), print (“ Solution “)
print (“x y”), print (“--- -----”)
for i in range ( 0, n ):
to = x[i]
yo y[i] =
FIGURE 7.13 Simulink block diagram using the backward Euler (implicit) method for solv￾ing the equation required in Example 7.3.222 Numerical Methods in Chemical Engineering Using Python® and Simulink®
tp = x[i] + h
yp = yo + h * f ( to, yo )
yp = fsolve (backward_euler_residual, yp, args = (f, to, yo, 
tp))
x[i+1] = tp
y[i+1] = yp
print (“%.3f”%x[i], “%.3f”%y[i])
return x, y
def backward_euler_residual ( yp, f, to, yo, tp ):
value = yp - yo - ( tp - to ) * f ( tp, yp );
return value
backward_euler ( f, tspan, y0, n )
The results obtained from running the Python code are shown below:
Solution
x y
--- -----
0.000 1.000
0.025 1.027
0.050 1.056
0.075 1.087
0.100 1.120
7.4 MIDPOINT METHOD
The Midpoint method solves for the integral of the first-order ODEs and finds the 
function’s value at a specific point. The midpoint numerical method uses the deriva-
  tive at the midpoint  x y 1  ,  1  to compute y  i i + +
2 2  i+1 with an IVP. The Midpoint method 
is a point where the desired solution is solved by studying the trend of the values in 
the midpoint between the initial value and the desired point. Finding the slope and 
value of the midpoint increases the accuracy of the solution and outputs a lower error 
percentage. Figure 7.14 is a representation of the Midpoint numerical method. It first 
estimates y 1, then using the derivative at the midpoint to compute yi+1, for the fol- i+
2
lowing ODE
dy = = f x( ) , y y ,   ( ) 0 yo dx
Using the Midpoint numerical method,
y y i i +1 2 = + k h
here k1
k f 1 = ( ) x y i i ,Numerical Solution of ODEs 223
and k2
 h h  k f 2 1 = +  x ,  y + k   2 i 2 
Example 7.4 Applying Midpoint Numerical Method
Solve the initial value ODE using the Midpoint method and a step size of 1.5(h = 1.5)
to find y( ) 3 .
dy = − 3e y −x 0.4 ,   y( ) 0 5 = dx
Confirm the manual calculations with Python and Simulink/MATLAB programming.
Solution
The initial condition to start with is x0 = = 0,   yo 5, h = 1.5
Accordingly, at x1 =+=+ 0 0 h 1.5 = 1.5
Find
k f 1 = = ( ) x y i i , 0 f e ( ) , 5 3 = − * 0 0.4( ) 5 1 =
Calculate
 h h   1.5 1.5  k f 2 1 = +  x ,  y + k f  = + +   2 i   0 , 5 ( ) 1
2   2 2 
= f e ( ) 0.75, 5.75 = − 3* −0.75 0.4( ) 5.75 − 0.8829
FIGURE 7.14 Graphical representation of the Midpoint numerical method.224 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The value of y1 at x1 = 1.5
y y 1 0 = + k h2 = −5 0.8829( ) 1.5 = 3.676
At x2 = 3, the value of k1
k f = = ( ) x y, f e ( ) 1.5, 3.676 = − 3* −1.5 1 1 1 0.4( ) 3.676 = −0.8
The calculated value of k2
 h h   1.5 1.5 k f ( ) k f 2 1 = +  x ,  y +  = + 1.5 , 3.676 + −0.8    2 i 2   2 2
= f e ( ) 2.25, 3.075 = − 3* 2.25 0.4( ) 3.075 = −0.9138
The calculated value of y2 at x2 = 3
y y 2 1 = + k h2 = − 3.676 0.9138( ) 1.5 = 2.305
Simulink and MATLAB Solution
For this example, a Simulink diagram is created, and the MATLAB function is dragged 
from the Simulink library to the work environment to solve the IVP described 
in Example 7.4. Figure 7.15 shows the Simulink block diagram centered by the 
MATLAB function and connected between four input ports and one output Display. 
FIGURE 7.15 Simulink solution using MATLAB function and the Midpoint method of the 
ODE defined in Example 7.4.Numerical Solution of ODEs 225
The four input ports are the lower limit interval (a), the upper limit interval (b), the 
step size (h), and the initial value of y( ) y0 . The Display icon yields the value of the y
at the upper limit interval or the simulation stop time (i.e., 3). The figure is followed 
with embedded MATLAB functions. The following MATLAB codes programmed 
the Midpoint method combined with the Simulink MATLAB function for solving 
the ODE described in Example 7.4.
function Res = midpt(a, b, h, y0)
f = @(x, y)(3*exp(-x)-0.4*y);% ODE
x = a:h:b;
n = (b-a)/h;
y=zeros(n);
y(1)=y0;
for i=1:n
k1 = f(x(i), y(i));
k2 = f(x(i)+h/2, y(i)+k1*h/2);
y(i+1) =y(i) + h*(k2);
end
Res=y(i+1);
end
Python Solution
The following Python code solves the ODE specified in Example 7.4 using the 
midpoint method. Unless the right-hand side of the ODE is linear in the dependent 
variable, each of the midpoint steps requires solving an implicit nonlinear equa￾tion. Using the midpoint formula, the user can calculate the curve representing the 
solution to the normal differentiation of an equation with an initial value.
# Midpoint method python program
import numpy as np
# initial conditions
x0 = 0
y0 = 5
# The calculating point
xn = 3
n = 2
h = (xn-x0)/n
step= h
print(‘\n--------SOLUTION--------’)
# function to be solved
def f(x, y):
return 3*np.exp(-x)-0.4*y
# using the midpoint formula
for i in range(n):
k1 = h * (f(x0, y0))
k2 = h * (f((x0+h/2), (y0+k1/2)))
yn = y0 + k2
x0 = x0+h
print(“at x = “, x0,”, yn =”, yn)
y0 = yn
The results obtained from running Python code with midpoint in solving the given 
equation in Example 7.4 are shown as follows:226 Numerical Methods in Chemical Engineering Using Python® and Simulink®
--------SOLUTION--------
at x = 1.5 , yn = 3.6756494873345655
at x = 3.0 , yn = 2.304947496982057
7.5 HEUN’S METHOD
Heun’s method considers the tangent lines of the solution curve at both ends of the 
interval, one overestimates and the other underestimates the ideal vertical coordi￾nates (Figure 7.16). Heun’s method involves the determination of two derivatives at 
the interval at the initial and end points. This process relies on predicting the new 
value of 𝑦, then correcting it based on the slope calculated at that new value. The 
two derivatives are then averaged to obtain an improved slope estimate for the entire 
interval. The prediction line should be constructed based on the slope of the right 
endpoint tangent alone, approximated using the Euler method.
dy = = f x( ) , y y ,   ( ) 0 yo dx
Heun’s method involves the determination of two derivatives for the interval at the 
initial point and the endpoint.
k f 1 = ( ) x y i i ,
k f 2 1 = + ( ) x h,  y k i + h
The calculated yi+1
 k k +
= + 1 2  y y i i +1 h   2 
FIGURE 7.16 Graphical description of Heun’s numerical method.Numerical Solution of ODEs 227
Example 7.5 Applying the Heun Method
Solve the following initial value nonlinear ODE using Heun’s method to find y at 
x = 5 using a step size, h = 0.5
dy 100 + y = ,     y( ) 0.5 = 20
dx 5x
Confirm the manual answer with Python and Simulink/MATLAB programming of 
the Heun method.
Solution
The initial condition, at xo o = = 0.5,  y 20 , or y( ) 0.5 = 20
Set the function equal to the right-hand side of the equation.
100 y f ( ) +
x y, = 5x
At
x1 = + 0.5 h =+= 0.5 0.5 1.0
k f 2 1 = + ( ) 100 + x h o o ,  y k + = h f ( ) 0.5 + + 0.5, 20 48* 0.5 = = f ( ) 44 1, 44 = 28.8
0.5( ) 1
100 + k f = = ( ) x y, o f ( ) 20 1 0 0.5, 20 = = 48
5( ) 0.5
The calculated y1
 k k +   48 + 28.8 y y 1 0 = + h  1 2  = + 20 0.5  = 39.2  2   2 
The exact analytical solution of the ODE using separable integration
dy 100 + y = dx 5x
Rearrange to the separable integration format
y
y
∫ ∫x
dy 1 dx = 100 + y 5 x o ox
Integrate
 100 + y  1  x  ln =   ln    100 + yo o  5  x 228 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Simplify
1 1
= + ( ) x   1  1
y y   − = 5   1 5
100 o 100 120    x x 5
 − = 100 137.844 5 −100  xo   0.5  
Accordingly, the accurate analytical solution is
1
y x = − 137.844 5 100
Table 7.2 lists the approximate numerical solution using Heun’s method and the 
exact analytical solution of the ODE specified in Example 7.5.
Simulink and MATLAB Solution
The configuration parameters need to be changed to solve the ODE in Simulink 
using the Heun’s method, as shown in Figure 7.17. Click on modeling in the 
Simulink toolbar, then click on the gear shape model/setting. Fix the solver type, 
the start time, the stop time, and the fixed-step size. The entire Simulink block 
diagram is shown in Figure 7.18. The first integrator is to generate x with an initial 
value of 0.5 since the integration starts from 0.5 and ends at 5.
An alternative Simulink solution is to use the MATLAB function from the 
Simulink library (Figure 7.19). The MATLAB function requires writing a program 
describing the solution of the required ODE using the Heun method and implant￾ing it in the Simulink MATLAB function.
The following is a MATLAB code implanted in the MATLAB function pulled 
from the Simulink library corresponding to the Heun method used for the ODE 
solution presented in Example 7.5.
function Res = Heun(x0,xf, h, y0)
f= @(x, y)((100+y)/(5*x)); % ODE
n= (xf-x0)/h;
yi=y0;
TABLE 7.2
Heun’s Method of Numerical Approximation and the Exact Analytical 
Solution of the Equation Defined in Example 7.5
x k1 k2 yHeun yexact
0.5 20.000 20.000
1 48.000 28.800 39.200 37.844
1.5 27.840 20.416 51.264 49.488
2 20.169 16.135 60.340 58.341
2.5 16.034 13.469 67.715 65.568
3 13.417 11.628 73.977 71.717
3.5 11.598 10.273 79.445 77.093
4 10.254 9.229 84.315 81.886
4.5 9.216 8.397 88.718 86.222
5 8.387 7.716 92.744 90.187Numerical Solution of ODEs 229
xi=x0;
for i =1:n
k1= f(xi, yi);
k2= f(xi+h, yi+(h*k1));
yf =yi+(h/2)*(k1+k2);
yi=yf;
xi = xi +h;
end
Res=yi;
End
FIGURE 7.17 Simulink configuration parameters utilizing the Heun method to solve the 
ODE specified in Example 7.5.
FIGURE 7.18 Simulink block diagram using fixed-step size Heun’s method for the equa￾tion solution specified in Example 7.5, the stop time equals five.230 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Python Solution
The following is the Python code created to calculate the curve representing the 
Heun method of the first-order ODE defined in Example 7.5.
# Heun method python program
# initial conditions
x0 = 0.5
y0 = 20
# The calculating point
xn = 5
n = 9
h = (xn-x0)/n
print(‘\n--------SOLUTION--------’)
print(“at x= “, x0,” yn =”, y0)
# function to be solved
def f(x, y):
return (100+y)/(5*x)
# using Heun formula
for i in range(n):
k1 = (f(x0, y0))
k2 = (f((x0+h), (y0+k1*h)))
yn = y0 + h*(k1+k2)/2
x0 = x0+h
print(“at x= “, x0,” yn =”, yn)
y0 = yn
The results obtained after running the Python program that solves the ODE speci￾fied in Example 7.5 are as follows:
--------SOLUTION--------
at x= 0.5 yn = 20
at x= 1.0 yn = 39.2
at x= 1.5 yn = 51.264
at x= 2.0 yn = 60.33984
FIGURE 7.19 Simulink block diagram using the Heun method to solve the equation defined 
in Example 7.5, stop time equals five.Numerical Solution of ODEs 231
at x= 2.5 yn = 67.71547264
at x= 3.0 yn = 73.97685028522667
at x= 3.5 yn = 79.4446941513338
at x= 4.0 yn = 84.31533584972715
at x= 4.5 yn = 88.71842442835953
at x= 5.0 yn = 92.7444174828312
7.6 RUNGE-KUTTA METHOD
Various types of Runge-Kutta methods can be derived by employing different terms 
in the increment function specified by the order term. The fourth-order Runge-Kutta 
is a method of numerically integrating ODEs using a trial step at the midpoint of an 
interval. The method is an effective and widely used method for solving the IVPs of 
differential equations, and the method is graphically illustrated in Figure 7.20. The 
formulas of the RK4 method are as follows:
k f 1 = ( ) x y i i ,
 h h  k f 2 1 = +  xi i ,  y + k   2 2 
 h h  k f 3 2 = +  x ,  y + k   i i 2 2 
k f 4 3 = + ( ) x h i i ,  y h + k
The solution of the ODE, yi+1
h
y y i i +1 1 = + ( ) k k + + 2 2 2 3 k k + 4 6
FIGURE 7.20 Graphical explanation of the RK4 method.232 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Example 7.6 Applying RK4 Method
Solve the following initial value ODE using the RK4 method to find the value of y
at x= 1.5. Use a step size of 0.1(h = 0.1).
dy = = 3x y2 ,  x ( ) 1 2
dx
Confirm the manual calculations with Python and Simulink/MATLAB program￾ming of the RK4.
Solution
The initial value, x0 0 = = 1,  2 y h,  = 0.1
At x1 1 = = 1.1,  y ?
k f = = ( ) , 1( ) 3 1( )2
1 0 x y0 f ,2 = = 2 6
 h h   0.1 0.1  k f 2 0 = +  x ,  y0 1 + k f  = + 1 , 2 + 6 3  = = ( ) 1.05 2
( ) 2.3 7.607  2 2   2 2 
 h h   0.1 0.1  k f 3 0 = +  x ,  y0 2 + k f  = + 1 , 2 + 7.607 = 7.873  2 2   2 2 
k f 4 3 = + ( ) x h o o ,  y h + = k f ( ) 1+ + 0.1, 2 0.1( ) 7.873 = = f ( ) 1.1, 2.7873 2.785
The solution of the ODE, yi+1
h
y y i i +1 1 = + ( ) k k + + 2 2k k +
6 2 3 4
0.1
y y 1 0 = + ( ) 6 2 + + ( ) 7.607 2( ) 7.873 + = 10.118 2.785
6
At x = = 1.1,  y1 2.785
The analytical solution is defined as follows:
dy = 3x y2
dx
Using the separable integration,
∫ ∫
y x
dy = 3 x d2 x y 2 xo
The solution of the integral
 y  3(x x 3 3 − ln = o ) = −   x x 3 3
 yo  3 oNumerical Solution of ODEs 233
Rearrange
y y = = e e x x 3 3 − − o x o 2 3 1
Table 7.3 lists the solution of the ODE in Example 7.4 using RK4 (step size, h = 0.1) 
and the analytical solution. The RK4 calculations are in good agreement with the 
analytical solution.
Simulink and MATLAB Solution
Change the setting to the fixed-value RK4 method as follows: after launching 
Simulink, click on modeling in the toolbar, and then from the pulldown menu, 
select Model/Setting. While on the configuration parameters page, change the 
default values of the start time, stop time, type and solver, and fixed-step size to 
those shown in Figure 7.21. The Simulink block diagram that graphically describes 
the solution of the equation defined in Example 7.6 is shown in Figure 7.22. 
Running the model outputs the value of y (21.48) in the Display at x =1.5. 
The alternative way to use Simulink is embedding a MATLAB code into the 
Simulink function block (Figure 7.23). The MATLAB function is attached to four 
FIGURE 7.21 Model setting using fixed-step Runge-Kutta method, h = 0.1 (Example 7.6).
TABLE 7.3
Comparison of the Runge-Kutta Method and the Exact Solution of the ODE 
Defined in Example 7.6
x k1 k2 k3 k4 yRK4 yexact
1.000 2.000 2.000
1.100 6.000 7.607 7.873 10.118 2.785 2.785
1.200 10.108 13.053 13.638 17.921 4.141 4.142
1.300 17.891 23.606 24.946 33.645 6.619 6.620
1.400 33.558 45.362 48.589 67.489 11.435 11.440
1.500 67.236 93.329 101.558 145.736 21.480 21.502234 Numerical Methods in Chemical Engineering Using Python® and Simulink®
input ports, lower limit interval ( ) xo , upper limit interval ( ) x f , the step size (h), and 
the initial conditions ( ) y0 . The MATLAB function is connected to a display block 
that releases the value of y at the stop time x.
The following program represents the MATLAB code utilizing the RK4 method 
to solve the ODE required in Example 7.6. The MATLAB code is implanted in the 
Simulink MATLAB function. The resultant ODE solution found in the Simulink dis￾play block is 21.48 at the independent variable stop time (i.e., x = 0.2).
function Res = RK4(x0,xf, h, y0)
f= @(x, y)(3*x^2*y); % ODE
n= (xf-x0)/h;
yi=y0;
xi=x0;
for i =1:n
FIGURE 7.22 Simulink solution using fixed-step Runge-Kutta method of the ODE required 
in Example 7.6.
FIGURE 7.23 Simulink block diagram symbolizes the solution using the RK4 method with 
a stop time of five to the equation defined in Example 7.6.Numerical Solution of ODEs 235
k1 = f(xi, yi);
k2 = f(xi+h/2, yi+ h*k1/2);
k3 = f(xi+h/2, yi+k2*h/2);
k4 = f(xi+h, yi+k3*h);
k = k1+2*k2+2*k3+k4;
yf = yi + k*h/6;
yi=yf;
xi = xi +h;
end
Res=yi;
end
Python Solution
A Python code program that utilizes the RK4 method to solve an ODE in the 
Python programming language is presented. In this Python program, x0 and yo
represents the initial condition. xn is the calculation point on which the value of 
yn corresponding to xn is to be calculated using the RK4 method. The step size is 
h, which represents the number of finite steps before reaching to xn , desired value.
# RK4 method method python program
# initial conditions
x0 = 1
y0 = 2
# The calculating point
xn = 1.5
n = 5
#h = (xn-x0)/n
h =0.1
step= h
print(‘\n--------SOLUTION--------’)
print(“at x= “, x0,” yn =”, y0)
# function to be solved
def f(x, y):
return 3*(x**2)*y
# using midpint formula
for i in range(n):
k1 = (f(x0, y0))
k2 = (f((x0+h/2), (y0+k1*h/2)))
k3 = (f((x0+h/2), (y0+k2*h/2)))
k4 = (f((x0+h), (y0+k3*h)))
k = (k1+2*k2+2*k3+k4)
yn = y0 + k*h/6
x0 = x0+h
print(“at x= “, x0,” yn =”, yn)
y0 = yn
Running the Python code releases the following results:
 --------SOLUTION--------
at x= 1 yn = 2
at x= 1.1 yn = 2.7846419118859376
at x= 1.2000000000000002 yn = 4.141490537335979
at x= 1.3000000000000003 yn = 6.618844434974083
at x= 1.4000000000000004 yn = 11.434686303979241
at x= 1.5000000000000004 yn = 21.480436540827917236 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Example 7.7 Applying RK4 Method
Use the RK4 method to find the approximate value of y at x = 0.2
dy = +x y2
,   y( ) 0 1 = dx
Given that y = 1 when x = 0, in a step size, h = 0.1
Verify the manual calculations with Python and Simulink/MATLAB of the utili￾zation of RK4 method in solving the required ODE.
Solution
The following is an initial value nonlinear ODE
dy = +x y2
dx
The right-hand side of the ODE is
f ( ) x y, = +x y2
,    y( ) 0 1 =
At x1 0 = x h +=+ 0 0.1 = 0.1
k f 1 = = ( ) x y o o , 0 x y o o + =2 2 + = 1 1
k1 = 1
Calculate k2
 h h   0.1 0.1  k f 2 1 = +  xo o ,  y + k f  = +  0 , 1+ ( ) 1  = f ( ) 0.05, 1.1  2 2   2 2 
k2 = + 0.05 1.052 = 1.1525
k2 = 1.1525
Calculate k3
 h h   0.1 0.1  k f 3 2 = +  xo o ,  y + k f  = +  0 , 1+ ( ) 1.1525  = f ( ) 0.05, 1.0576  2 2   2 2 
k3 = + 0.05 1.05762 = 1.169
k3 = 1.169
Calculate k4
k f 4 2 = + ( ) x h o o ,  y h + = k f ( ) 0 + + 0.1, 1 0.1( ) 1.169 = f ( ) 0.1, 1.1169
k4 = + 0.1 1.11692 = 1.3474
k4 = 1.374Numerical Solution of ODEs 237
Calculate y1 at x1
h
y y 1 0 = + ( ) k k2 3
6 1 2 + + k k 3 4 +
0.1
y1 = +1 ( ) 1 2 + + ( ) 1.1525 2( ) 1.169 + = 1.374 1.1165
6
y1 ( ) 0.1 = 1.1165
Hence
x1 1 = = 0.1,  y 1.1165
Calculate y2 at x2 = 0.2
Calculate k1:
k f 1 1 = = ( ) x y ,  2 1 f ( ) 0.1,1.1165 = + 0.1 1.117 = 1.3466
Calculate k2:
 h k   0.1 0.1  k f 2 = +  xo o ,  y + 1
 = + f  0.1 , 1.1165 + 1.3466  2 2   2 2 
Simplify
k f 2 = = ( ) 0.15, 1.18383 0.15 + = 1.183832 1.5514
Calculate k3:
 h h   0.1 0.1  k f 3 2 = +  xo o ,  y + k f  = +  0.1 , 1.1165 + 1.5514  2 2   2 2 
Simplify
k f 3 = = ( ) 0.15, 1.1947 1.5758
Calculate k4
k4 3 = + f ( ) x h o o ,  y h + = k f (0.1+ + 0.1, 1.1165 0.1(1.5758))
Simplify
k f 4 = = ( ) 0.2, 1.274 0.2 + = 1.2742 1.8233238 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Calculate y2
h
y y 2 1 = + { } k k + + 2 2 ( ) ( ) k k +
6 1 2 3 4
h
y y 2 1 = + {1.3466 + + 2( ) 1.5514 2( ) 1.5758 + = 1.8233 1.2736 } 6
Hence, x2 2 = = 0.2, y 1.12736.
Simulink and MATLAB Solution
While on the Simulink page, click on modeling, then model setting, and fill in the 
following information, start time and stop time values of 0 and 0.2, respectively. 
The solver type is set as a fixed type with a fixed-step size value of 0.1, as shown 
in Figure 7.24.
The Simulink block diagram solution of Example 7.7 is shown in Figure 7.25, 
and the obtained results agree with the manual calculations.
A diagram is created using Simulink’s built-in function (Figure 7.26). Example 7.7 
can be solved in the following alternative method, which extracts the MATLAB code 
from the Simulink diagram.
The following MATLAB code corresponds to the RK4 method planted in the 
Simulink function for the solution of the following ODE solution (Example 7.7).
function Res = RK4(x0,xf, h, y0)
f= @(x, y)(x+y^2); % ODE
n= (xf-x0)/h;
yi=y0;
xi=x0;
for i =1:n
k1 = f(xi, yi);
k2 = f(xi+h/2, yi+ h*k1/2);
k3 = f(xi+h/2, yi+k2*h/2);
k4 = f(xi+h, yi+k3*h);
k = k1+2*k2+2*k3+k4;
yf = yi + k*h/6;
FIGURE 7.24 Model setting using the fixed step of 0.1 of the Runge-Kutta method for solv￾ing the ODE defined Example 7.7.Numerical Solution of ODEs 239
yi=yf;
xi = xi +h;
end
Res=yi;
end
Python Solution
The below Python program, followed by the execution results, corresponds to the 
approximate numerical solution of Example 7.7 using the RK4 method.
# RK4 method method python program
# initial conditions
x0 = 0
y0 = 1
# The calculating point
xn = 0.2
n = 2
#h = (xn-x0)/n
FIGURE 7.25 Simulink solution with a stop time of 0.2 of the equation defined in Example 7.7.
FIGURE 7.26 Simulink solution using the RK4 method, a stop time equal to 5, of the equa￾tion defined in Example 7.7.240 Numerical Methods in Chemical Engineering Using Python® and Simulink®
h =0.1
step= h
print(‘\n--------SOLUTION--------’)
print(“at x= “, x0,” yn =”, y0)
# function to be solved
def f(x, y):
return x+y**2
# using RK4 formula
for i in range(n):
k1 = (f(x0, y0))
k2 = (f((x0+h/2), (y0+k1*h/2)))
k3 = (f((x0+h/2), (y0+k2*h/2)))
k4 = (f((x0+h), (y0+k3*h)))
k = (k1+2*k2+2*k3+k4)
yn = y0 + k*h/6
x0 = x0+h
print(“at x= “, x0,” yn =”, yn)
y0 = yn
The results obtained from the Python code are as follows:
--------SOLUTION--------
at x= 0 yn = 1
at x= 0.1 yn = 1.1164918497132719
at x= 0.2 yn = 1.2735625426752228
7.7 PICARD’S ITERATIVE METHOD
Picard’s iterative method is relatively easy to implement, and the solutions obtained 
through this numerical analysis are generally power series. This method is used to 
solve differential equations with accurate solutions. It is a straight forward approach 
but requires lengthy calculations. If we consider the first-order differential equation 
with an initial condition, y y = 0 when x = xo.
dy = f x( ) , y dx
Integrate between limits, we get
∫ ∫
y x
dy = f x( ) , y dx
y0 xo
Integrating,
y y = +o ∫
x
f x( ) ,  y dx
x0
Now we replace y by yo as the first approximation
y y 1 = +o ∫
x
f x( ) ,  y d o x
x0Numerical Solution of ODEs 241
The second approximation
y y 2 1 = +o ∫
x
f x( ) ,  y dx
x0
For the nth approximation,
x
y y n o = + f x( ) ,  y d n−1 x
x
∫
0
The Picard’s method generates a sequence of approximations as y1, y2, and y3 that 
converges to the exact solution y x( ).
Example 7.8 Application of Picard’s Iterative Method
Determine the value of y at x = 0.3 of the following ODE using Picard’s iterative 
approximation method.
dy = +x y2
  ,  y( ) 0 0 = dx
Solve manually and with Python and Simulink/MATLAB programming.
Solution
Using Picard’s method,
1. First iteration when y = 0
∫ ∫
x x 2
y x( ) = + y f ( ) x y + = 2 o dx y f o + + ( ) x x d 0 x = 2 x0 0x
For x = 0.3, integration and substitute x = 0.3
x x
( ) x 2 2 0.3
y y 1 0.3 = +o f x 0 0 dx xdx
x
∫ ∫ ( ) + = + = = = 0.045
2 2 0 0x
2. Second iteration
2
dy  x 2 4
2  x = +x y = +x = +
dx 1   x  2 4 
Therefore,
0.3  x 4  y x 2 ( ) = + y x o ∫ +   dx  4  0
x x 2 5 0.32 5 0.3
y2 = + 0 + = 0 + + = 0.0451
2 20 2 20242 Numerical Methods in Chemical Engineering Using Python® and Simulink®
3. Third iteration
dy = +x y2
dx 2
dy  x x 2 5 
2
x x 4 7 2 x10
= +x + = + + +
dx   x  2 20 4  40 400
Therefore
0.3  = + ∫ x x 4 7 x10  y x 3 0 + + +   dx  4 20 400  0
x x 2 5 x x 8 11 2 0.3 0.30.5 8 0.3 0.311
y3 = + + + = + + + = 0.0451
2 20 160 4400 2 20 160 4400
Accordingly, at x = 0.3 ,  y = 0.0451, it is correct up to four decimal places.
Simulink and MATLAB Solution
The Simulink block diagram for Example 7.8 is shown in Figure 7.27. The default 
solver is used for RK4 as the Picard’s method is not built in MATLAB solver.
The alternative way to solve Example 7.8 is using the Simulink function, as 
shown in Figure 7.28, to output the MATLAB code.
The following MATLAB codes correspond to the Picard’s method planted in 
the Simulink function for the solution of the following ODE solution (Example 7.8).
function [y1,y2,y3] = Picard(a)
%Picard’s Method
%
f1 = @(x) x^2/2;
FIGURE 7.27 Simulink’s solution, with downtime equal to 0.3, of the equation given in 
Example 7.8.Numerical Solution of ODEs 243
f2 = @(x) x^2/2 + x^5/20;
f3 = @(x) x^2/2 + x^5/20+ x^8/160 + x^1/4400;
%
y1=f1(a);
y2=f2(a);
y3=f3(a);
end
Python Solution
The approximate numerical solution using Picard’s approximation method fol￾lowed by its solution is shown below in Python format.
#Picard’s Method
#
def y1(x):
Y1 = x**2/2
return Y1
def y2(x):
Y2 = x**2/2 + x**5/20
return Y2
def y3(x):
Y3 = x**2/2 + x**5/20+ x**8/160 + x**1/4400
return Y3
#
print (‘ ‘)
print (‘ === Solution ===’)
print (‘for dy(x) = x + y**2 the results are :’)
print (‘--------------------------------------’)
print (‘y1(0.3) = ‘, y1(0.3))
print (‘y2(0.3) = ‘, y2(0.3))
print (‘y3(0.3) = ‘, y3(0.3))
The results obtained from the Python code are as follows:
=== Solution ===
for dy(x) = x + y**2 the results are :
--------------------------------------
FIGURE 7.28 The block diagram of the simulation using the Picard method with a down￾time of 0.2 represents the solution of the equation given in Example 7.8.244 Numerical Methods in Chemical Engineering Using Python® and Simulink®
y1(0.3) = 0.045
y2(0.3) = 0.045121499999999995
y3(0.3) = 0.045190091880681814
7.8 SUMMARY
Numerical methods are used to find numerical approximations to the solutions of 
ODEs. Numerical integration includes a wide range of algorithms for calculating 
the numerical value of a definite integral (the area under a curve between two fixed 
terms). The numerical method with a minor error compared to the exact solution 
is the most accurate and easiest to solve. The problem lies in those cases where 
there is no exact solution. The approximate numerical solution of ODEs includes 
Euler’s explicit and implicit methods, the Midpoint method, the Heun method, and 
the Runge-Kutta method.
7.9 PROBLEMS
1. Using the Euler method, find an approximation for the solution of the dif￾ferential equation
dy = f x( ) , y dx
 With the initial condition
y x( ) o o = y
 2. The dilution of the concentrated orange in homemade orange juice is given 
dy = − 37.5 3.5y dt
Initially, the orange concentration in the tank was 50 g/L. Using explicit Euler’s 
method and a step size of h = 1.5 min, what is the orange concentration after 
3 minutes? Compare the predicted result with the analytical solution. Find the 
best step size that gives the closest result to the exact solution. The exact solu￾tion of the ODE is given by
y t( ) = + 10.714 39.286e−3.5t
 Answer: (10.7154 g/L, with h = 0.1)
 3. Using the RK4 method, find the approximate solution of the following ini
dy y = +1
dx xNumerical Solution of ODEs 245
With the initial condition, y( ) 1 1 = , the approximate numerical answer is (3.38).
4. Solve the following ODE using the Picard iterative method with an initial 
condition, y( ) 0 100 = , calculate y(50)
dy = − 50 0.01y dt
 Answer (1732)
 5. Using the Midpoint method, solve the following ODE with an initial condi
dy = − yx3 0.01y y ,   ( ) 0 = 1.0
dx
 The exact solution is 
 6. Using the Heun method, solve the following ODE with an initial condition, 
dy = − yx3 0.01y y ,   ( ) 0 = 1.0
dx
 The exact solution is 
7. Using the Euler’s method within the range t = 0 to 2, solve the following 
first-order initial value ODE, using a step size, h= 0.5
dy = − t y2 1.2y y ,   ( ) 0 1 = dt
 The exact solution is 
 8. Using the Midpoint’s method within the range 
dy = − t y2 1.2y y ,   ( ) 0 1 = dt
 The exact solution is 
 9. Using the RK4 method within the range 
dy = − t y2 1.2y y ,   ( ) 0 1 = dt
 The exact solution is = 1.30561, and the approximate answer is (1.29855).
 10. Using the RK4 method within the range 
dy = −x y 1.2 ,   y( ) 0 1 = dx246 Numerical Methods in Chemical Engineering Using Python® and Simulink®
 The exact solution is 
REFERENCES
 1. Gupta, S.K., 2014, 
2. Kharab, A. and Guenther, R., 2018, 
 3. Kong, Q., Siauw, T., and Bayen, A., 2020, 
 4. Hill, C., 2020, 247
8 Simultaneous Systems of 
Differential Equations
In this chapter, we will learn how to simultaneously solve a system of binary, linear, 
independent differential equations of the first order. Such systems arise when the 
model includes two or more variables. This chapter grants numerical methods pro￾gramming for generating simple and effective Python and MATLAB codes along 
with Simulink to output numerical solutions with the required accuracy. It uses the 
plotting functions of Matplotlib in Python and the Plot function in MATLAB to pres￾ent the required results graphically.
LEARNING OBJECTIVES
1. Solve binary ODEs simultaneously using the Euler method.
2. Employ the Midpoint method to solve a system of ODEs simultaneously.
3. Use the fourth-order Runge-Kutta (RK4) method to solve binary ODEs.
4. Solve ODEs simultaneously using the Picard method. 
8.1 INTRODUCTION
Numerical methods for solving ordinary differential equations (ODEs) are used to 
find approximate numerical solutions for ODE. Their use is also known as a numeri￾cal integral, although this term can also refer to the computation of integrals [1]. A 
first-order differential equation with only the first derivative of the dependent vari￾able (e.g., y) without higher derivatives is considered an initial value problem (IVP),
dy = y x ′( ) = = f x( , y x( ) ,  y x( ) o o y (8.1) dx
Several differential equations cannot be solved using symbolic computation. 
However, a numerical approximation of the solution is often sufficient in engineering 
and for practical purposes. The algorithms considered here can be used to calculate 
such an approximation. ODEs occur in various scientific disciplines, including phys￾ics, chemistry, biology, and economics. In addition, specific scalar partial differen￾tial equation methods convert the partial differential equation into an ordinary one, 
which must then be solved. The following sections use various methods to solve two 
ODEs simultaneously [2].
DOI: 10.1201/9781003360544-8248 Numerical Methods in Chemical Engineering Using Python® and Simulink®
8.2 SIMULTANEOUS NUMERICAL SOLUTION OF TWO ODEs
We will now consider systems of simultaneous linear differential equations that have 
one independent variable.
8.2.1 euler method
Considering that the following ODEs are to be solved simultaneously using the Euler 
method,
dy1 = = f t 1 1 ( ) , , y y2 1 ,   y y ( ) 0 1,0 (8.2) dt
dy2 = = f t 2 1 ( ) , , y y2 2 ,   y y ( ) 0 2, dt o (8.3)
The Euler algorithms for solving the stated two ODEs are as follows:
y y 1,i i +1 1 = + ,0 f t 1 , ( ) , , y y i i 1 ,2 (8.4)
y y 2,i o + + 1 2 = ,   f t 2 , ( ) i i , , y y 1 ,i 2 (8.5)
The following example illustrates the application of the explicit Euler method in solv￾ing two ODEs simultaneously.
Example 8.1 Application of Explicit Euler Method
Solve the following two ODEs simultaneously using the Euler method and a step 
size of 0.1.
dy1 = −y e1−t 1 + = 0.8y y 2 1 ,      ( ) 0 0
dt
dy2 = − y y3 1 2 ,    y2 ( ) 0 2 = dt
Manually calculate the values of the dependent variables ( , y y 1 2 ) within the inter￾val [0, 3]. Compare the manual calculations with the approximate solutions using 
Simulink (the graphical programming of MATLAB) and Python programming of the 
Euler method.Simultaneous Systems of Differential Equations 249
Solution
Apply the formulas of the explicit Euler method
dy1 = = f t 1 1 ( ) , , y y 1 2 1 − + y e −x 0.8y2 dx
dy2 = = f t 2 1 , , y y 3 2 1y y2 dx ( ) −
The explicit Euler algorithm
y y 1,i i +1 1 = +, 1 hf ( ) t y i i , , ,1 yi,2
y y 2,i i +1 2 = +, 2 hf ( ) t y i i , , ,1 yi,2
The initial conditions are at t = 0, where y1 ( ) 0 0 = , y2 ( ) 0 2 =
At t= 0.1,
y h = +0 0 f e ( ) , 0,2 0 = + 0.1( ) − + 0 1 0− 1,1 1 0.8( ) 2 = 0.16
y h 1 2 = +2 0 f ( ) ,0,2 = +2 0.1( ) 0 2 − = 3 2, 1.2
At t= 0.2,
y h ( ) 0.8
Simplify
y h 3
2,2 2 = + 1.2 f ( ) 0.1,0.16,1.2 = + 1.2 0.1( ) 0.16 − = ( ) 1.2 1.043
The rest of the calculations are listed in Table 8.1.
TABLE 8.1
Euler’s Method Solution of Example 8.1
Time (t) i y1 y2
0.000 0 0.000 2.000
0.100 1 0.160 1.200
0.200 2 0.217 1.043
2.800 28 1.067 0.953
2.900 29 1.126 0.973
3.000 30 1.187 0.994250 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Simulink Solution
To use the integrator block function from the Simulink library, the configuration 
parameters such as start time, stop time, type, and solver should be changed in the 
modeling set. Therefore, to do so, while on the Simulink simulation page, click on 
the modeling tab, and select the modeling setting. Change the start and stop times 
to 0.1 and 3, respectively. For the solver selection, indicate the type: fixed step and 
the solver: Euler, as shown in Figure 8.1. The entire Simulink graphical solution of 
the two ODEs defined in Example 8.1 using the explicit Euler method is presented 
in Figure 8.2. The values in the display blocks are the values of y1 and y2 with a 
stop time of three.
Individuals may want to change the background colors of the scope before 
copying the scale image. To do so, click on the ‘scope parameters’ icon (the 
FIGURE 8.2 Numerical solution of the two equations defined in Example 8.1 applying the 
explicit Euler method in Simulink.
FIGURE 8.1 Simulink solver configuration parameters for selecting the Euler method to 
solve the equations defined in Example 8.1.Simultaneous Systems of Differential Equations 251
second icon) and go to the ‘style’ tab. Change the shape color to black, the axes 
colors to white background and black writing, and the font color to black. After 
the modifications, the plot of the two ODEs generated by Simulink is shown in 
Figure 8.3. There is no option to automatically set the axis or name labels in the 
plot generated by the scope simulated graph. However, after the simulation, a per￾son can manually add axis names from the Graphical User Interface (GUI) shape 
or the command window. Select the scope graph from Simulink and run the fol￾lowing commands into the command window.
set(0,’ShowHiddenHandles’, ‘on’)
set(gcf, ‘menubar’, ‘figure’)
These commands will enable the toolbar in the scope graph shape window. One 
can add axis names from Insert>> X Label and Insert>> Y Label. To change the 
legend, while in the scope window, select the View > Legend option to display dif￾ferent variables to show the legend. If one double-clicks on a legend, a small text 
entry field will appear, allowing one to name it. After the scope amendment, the 
graph should look like that in Figure 8.3.
An alternative way to solve the equations defined in Example 8.1 is to use the 
Simulink MATLAB function (Figure 8.4). The MATLAB function requires writing a 
MATLAB code. Figure 8.4 shows the Simulink MATLAB function with five input 
ports: the lower limit interval (a), the upper limit interval (b), the step size (h), and 
the initial values of y y 1 ( ) o and y z 2 ( ) o . The two displays release the values of y1 and 
y2 at the simulation stop time [3].
FIGURE 8.3 Simulink plot of the numerical solution utilizing the explicit Euler method of 
the model equations defined in Example 8.1.252 Numerical Methods in Chemical Engineering Using Python® and Simulink®
The following program is the MATLAB code implanted in the Simulink MATLAB 
function shown in Figure 8.4. When running the Simulink graphical program, it 
generates the plot presented in Figure 8.5. The figure describes the change in the 
dependent variables ( , y y 1 2 ) with time within the desired interval [0, 3].
% Example 8.1 using the Euler method
function [y1f, y2f] = Euler(a, b, h, y0,z0)
%Euler integration method
FIGURE 8.5 Simulink generated a plot of numerical solution using the explicit Euler 
method of the equations described in Example 8.1.
FIGURE 8.4 Simulink numerical solution of the two equations described in Example 8.1 
using the Euler method. The stop time is three.Simultaneous Systems of Differential Equations 253
% Routine starts here
f1=@(x, y, z)(-y*exp(1-x)+ 0.8*z); % Enter RHS of the first ODE
f2=@(x, y, z) (y-z^3); % Enter RHS of the first ODE
x=a:h:b;
y=zeros(1,length(x));
z=zeros(1,length(x));
y(1)=y0;
z(1)=z0;
x(1)=a;
for i=1:(length(x)-1)
m1 = f2(x(i), y(i), z(i));
k1 = f1(x(i), y(i), z(i));
y(i+1) = y0 + h*k1;
y0=y(i+1);
z(i+1) = z0 + h*m1;
z0=z(i+1);
end
y1f=y0;
y2f=z0;
plot(x, y, x, z, ‘linewidth’, 1.5);
text(0.45,1, ‘\leftarrow z’, ‘Color’, ‘r’, FontSize=15)
text(0.45,0.2, ‘\leftarrow y’, ‘Color’, ‘b’, FontSize=15)
text(1.0,1.45, ‘Euler method’, FontSize=15)
xlabel(‘x’);
ylabel(‘y, z’);
grid on
Python Solution
The following is the Python code that utilizes the Euler method simultaneously for 
solving the two ODEs defined in Example 8.1. Numerical methods with Python 
programming allow the creation of simple and efficient Python code that produces 
numerical solutions with the required degree of accuracy. Use of matplotlib plot￾ting functions to present the results graphically [3]. The implementation of the 
program resulted in Figure 8.6.
# Euler method for solving 2 ODEs simultaneously
import matplotlib.pyplot as plt
import numpy as np
from numpy import arange
# y1’ = -y1*np.exp(1-x)+0.8*y2
# y2’ = y1-y2**3
def F1(y1, y2, x):
return -y1*np.exp(1-x)+0.8*y2
def F(y1, y2,x):
return y1-y2**3
a = 0
b = 3
N =30
h = (b-a)/N
xp = arange(a, b, h)
yp = []
up = []254 Numerical Methods in Chemical Engineering Using Python® and Simulink®
# initial conditons
y1 = 0.0
y2 = 2
for x in xp:
yp.append(y1)
up.append(y2)
m1 = h*F1(y1, y2, x)
k1 = h*F(y1, y2, x)
y1+= m1
y2+= k1
# plot section
plt.plot(xp, yp, ‘r-’, label=r’$y_{1}$’)
plt.plot(xp, up, ‘b--’, label=r’$y_{2}$’)
plt.xlabel(“Time”, fontsize=14)
plt.ylabel(‘y ‘, fontsize=14,rotation=0)
plt.legend()
plt.grid(True)
8.2.2 mIdPoINt method
The Midpoint method is a type of second-order Rung-Kutta method. It is used to 
solve ODEs with a given initial condition. This technique is called the Midpoint 
method because it uses the tangent at the midpoint and checks where the tangent cuts 
for the vertical lines. Considering h as the step size and the following two ODEs:
dy1 = f x 1 1 , , y y2 dx ( ) (8.6)
dy2 = f x 2 1 , , y y2 dx ( ) (8.7)
FIGURE 8.6 Python plot represents the numerical solution using the Euler method of the 
equations defined in Example 8.1.Simultaneous Systems of Differential Equations 255
The Midpoint algorithm for solving the two equations at once is as follows:
k f 1,1 1 = ( ) x y i i , , ,1 yi,2 (8.8)
k f 1,2 2 = ( ) x y i i , , ,1 yi,2 (8.9)
 h h h  k f 2,1 1 = +  xi i ,  y ,1 + + k y  2 2 1,1 , ,  i 2 2 k ,1  (8.10) 2 
 h h h  k f 2,2 2 = +  xi i ,  y ,1 + + k y  2 2 2,1 , ,  i 2 2 k ,2  (8.11) 2 
Finally,
y y i i ,1 = + −1,1 2 h k 1 (8.12)
y y i i ,2 = + −1,2 2 h k 2 (8.13)
Example 8.2 Applying the Midpoint Method 
to Solve Two Simultaneous Equations
Apply the Midpoint method to solve the following two ODEs using a step size of 0.1.
dy1 = −y e1−t 1 + = 0.8y y 2 1 ,      ( ) 0 0
dt
dy2 = − y y3 1 2 ,    y2 ( ) 0 2 = dt
Calculate y1 and y2 manually within the interval [0, 3] and confirm your manual 
calculations with Python and Simulink graphical programming.
Manual Solution
Following the Midpoint formulas (8–13),
k1,1
k f 1,1 1 = = ( ) t y, , 0,0,2 0e
1 0− i i,1 y f i,2 1 ( ) = − + = 0.8* 2 1.6256 Numerical Methods in Chemical Engineering Using Python® and Simulink®
k1,2
k f = = ( ) t y, , y f ( ) t y, , y f = = ( ) 0,0,2 0 − = 2 8 3 1,2 2 i i,1 i o ,2 2 0 ,1 o,2 2 −
k2,1
 h h h  k f 2,1 1 = + to o ,  y + + k y ,   2 o k  2 ,1 1,1 ,2 1 2 ,2 
 0.1 0.1 0.1  k f 2,1 1 = +  0 , 0 + + ( ) 1.6 , 2 ( ) −8   2 2 2 
k f 1 0 1 1 ( ) 0.05, 0.08,1.6 e .05 2, = = − + ( ) 0.08 − 0.8( ) 1.6 = 1.07314
k2,2
 h h h  k f 2,2 2 = + t ,  + + ,   o o y k y k
2 ,1 2 1,1 , o 2 1 2 ,2 
k f 3 3 2,2 2 = = ( ) 0.05, 0.08,1.6 y y 1 2 − = 0.08 − = 1.6 −4.016
Accordingly
y y 1 1 = + ,0 h k( ) 2,1
Substitute the values
y1 = + 0 0.1× = ( ) 1.07314 0.1107314
Following the same procedure to calculate, y2
y y 2 2 = + ,0 h k × 2,2
Substitute the known values
y2 = +2 0.1× −( ) 4.016 = 1.598
The remaining values are calculated using excel and tabulated in Table 8.2.
Figure 8.7 shows the excel plot of the numerical solution utilizing the Midpoint 
method. It shows the change in the dependent variables (y1 and y2) versus time (t).Simultaneous Systems of Differential Equations 257
Simulink Solution
The Simulink numerical solution of the two differential equations defined in 
Example 8.2 is shown in Figure 8.8. The Simulink graphical program uses the 
MATLAB function dragged from the Simulink library (under the user-defined func￾tions). The Simulink MATLAB function relates five input constants represent the 
lower limit interval (a), upper limit interval (b), step size (h), and the initial values 
of y1 (yo) and initial value of y2 (zo). The two output displays present the values of y1
and y2 at the simulation stop time [3].
The following is the MATLAB code of the Midpoint method implanted in the 
Simulink MATLAB function present in Figure 8.8. The generated plot of the depen￾dent variables versus time is revealed in Figure 8.9.
% Example 8.2 using Midpoint
function [y1f, y2f] = MidPoint(a, b, h, y0,z0)
% Midpoint integration method
% Enter RHS of the first ODE
f1=@(x, y, z)(-y*exp(1-x)+ 0.8*z);
TABLE 8.2
Solution of Binary Equation Defined in Example 8.2 Using the Midpoint 
Method
i x k1,1 k1,2 k2,1 k2,2 y1 y2
1 0.000 0.000 2.000
2 0.100 1.600 –8.000 1.073 –4.016 0.107 1.598
3 0.200 1.015 –3.976 0.750 –2.583 0.182 1.340
29 2.900 0.597 0.193 0.609 0.195 1.196 1.000
30 3.000 0.621 0.197 0.633 0.198 1.260 1.020
FIGURE 8.7 Excel plot of the manual calculations, utilizing the Midpoint method, of the 
equations defined in Example 8.2.258 Numerical Methods in Chemical Engineering Using Python® and Simulink®
% Enter RHS of the first ODE
f2=@(x, y, z) (y-z^3);
x=a:h:b;
y=zeros(1,length(x));
z=zeros(1,length(x));
FIGURE 8.8 Simulink solution utilizing MATLAB function and the Midpoint method of 
the two ODEs defined in Example 8.2, stop time equal three.
FIGURE 8.9 Simulink plot generated using the Midpoint method of the two equations 
defined in Example 8.2.Simultaneous Systems of Differential Equations 259
y(1)=y0;
z(1)=z0;
x(1)=a;
for i=1:(length(x)-1)
k1 = f1(x(i), y(i), z(i));
m1 = f2(x(i), y(i), z(i));
k2 = f1(x(i)+0.5*h, y(i)+0.5*h*k1,z(i)+0.5*h*m1 );
m2 = f2(x(i)+0.5*h, y(i)+0.5*h*k1,z(i)+0.5*h*m1 );
y(i+1) = y0 + h*k2;
y0=y(i+1);
z(i+1) = z0 + h*m2;
z0=z(i+1);
end
y1f=y0;
y2f=z0;
% Plot sections
plot(x, y, x, z, ‘linewidth’, 1.5);
text(0.5,1.05, ‘\leftarrow z’, ‘color’, ‘r’, FontSize=15)
text(0.45,0.25, ‘\leftarrow y’, ‘color’, ‘b’, FontSize=15)
text(1.0,1.45, ‘Midpoint method’, FontSize=15)
xlabel(‘Time’, FontSize=15);
ylabel(‘y_1, y_2’, FontSize=15);
grid on
The following is the Python program that employed the Midpoint method to solve 
two ODEs defined in Example 8.2. Running the program releases the plot of the 
dependent variables versus the independent variable, as shown in Figure 8.10.
# Example 8.2
# Midpoint method for solving two ODEs
import matplotlib.pyplot as plt
import numpy as np
from numpy import arange
# Enterthe two functions
FIGURE 8.10 Python-generated plot using the Midpoint method represents the solution of 
the equations defined in Example 8.2.260 Numerical Methods in Chemical Engineering Using Python® and Simulink®
def F1(y, u, x):
return -y*np.exp(1-x)+0.8*u
def F2(y, u, x):
return y-u**3
a = 0
b = 3
N =30
h = (b-a)/N
xp = arange(a, b, h)
yp = []
up = []
# initial conditions
y = 0.0
u = 2
for x in xp:
yp.append(y)
up.append(u)
m1 = h*F1(y, u, x)
k1 = h*F2(y, u, x)
m2 = h*F1(y+0.5*m1, u+0.5*k1, x+0.5*h)
k2 = h*F2(y+0.5*m1, u+0.5*k1, x+0.5*h)
y = y + m2
u = u + k2
# plot section
plt.plot(xp, yp, ‘r-’, label=”y”)
plt.plot(xp, up, ‘b-.’, label=”x”)
plt.xlabel(“Time”, fontsize=14)
plt.ylabel(“y, x”, fontsize=14)
plt.legend()
plt.grid(True)
The generated solution of the Python code after execution is represented in 
Figure 8.10.
8.2.3 fourth-order ruNge-kutta
The Runge-Kutta method is a mathematical algorithm used to solve systems of ODEs 
of the following forms:
dy1 = f t 1 1 , , y y2 dt ( ) (8.14)
dy2 = f t 2 1 , , y y2 dt ( ) (8.15)
The general form of these equations is as follows:
k f 1,1 1 = ( ) t y i i , , ,1 yi,2 (8.16)
k f 1,2 2 = ( ) t y i i , , ,1 yi,2 (8.17)Simultaneous Systems of Differential Equations 261
 h h h  k f 2,1 1 = + ti i ,  y ,1 + + k y 1,1 , , i 2 1 k ,2  (8.18)  2 2 2 
 h h h  k f 2,2 2 = + ti i ,  y ,1 + + k y 1,1 , , i 2 1 k ,2  (8.19)  2 2 2 
 h h h  k f 3,1 1 = + ti i ,  y ,1 + + k y 2,1 , , i 2 2 k ,2  (8.20)  2 2 2 
 h h h  k f 3,2 2 = + ti i ,  y ,1 + + k y 2,1 , , i 2 2 k ,2  (8.21)  2 2 2 
k f 4,1 1 = + ( ) t h i i ,  y h ,1 + + k y 3,1 3 ,  ,2 h k3,2 (8.22)
k f 4,2 2 = + ( ) t h i i ,  y h ,1 + + k y 3,1 3 ,  ,2 h k3,2 (8.23)
where h> 0 is a step size parameter, I= 1, 2, 3,…, the RK4 method is given by:
h
y y i i ,1 = + −1,1 1 k k ,1 2 2 2,1 3 k k ,1 4,1 6
{ } + + + (8.24)
h
y y i i ,2 = + −1,2 1 k k ,2 2 2 2,2 3 k k ,2 4,2 6
{ } + + + (8.25)
The Runge-Kutta method provides greater precision than multiplying each function 
in ODE by the step size factor and adding the results to the current values in y (such 
as the Euler method).
Example 8.3 Applying RK4 to Solve Two ODEs Simultaneously
Solve the following two ODEs simultaneously using RK4 and a step size of 0.1.
dy1 = −y e1−t 1 + = 0.8y y 2 1 ,      ( ) 0 0
dt
dy2 = − y y3 1 2 ,    y2 ( ) 0 2 = dt
Calculate the two dependent variables ( , y y 1 2 ) manually as a function of time (t) 
within the interval [0, 3]. Verify the manual calculations with Simulink (the graphi￾cal programming of MATLAB) and Python programming.262 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solution
Following the RK4 formulas (16–25),
Calculate k1,1 and k1,2
k f = = t y i i , , y f 0,0,2 0 = − e
1 0− 1,1 1 ( ) ,1 i,2 1 ( ) + = 0.8* 2 1.6
k f , , y f , , 0, 3 1,2 2 = = ( ) t y i i,1 i o ,2 2 0 ( ) t y ,1 y f o,2 = = 2 ( ) 0,2 0 − = 2 8−
Calculate k2,1 and k2,2
 h h h  k f 2,1 1 = + to o ,  y ,1 + + k y 1,1 , , o 2 1 k   2 2 2 ,2 
 0.1 0.1 0.1  k f 2,1 1 = +  0 , 0 + + ( ) 1.6 ,2 ( ) −8   2 2 2 
k f 2,1 1 = = ( ) 0.05, 0.08,1.6 − + ( ) 0.08e 1 0− .05 0.8( ) 1.6 = 1.07314
 h h h  k f 2,2 2 = + t y + + k y k  o o ,  ,  2 ,1 2 1,1 , o 2 1 2 ,2 
k f ( ) 0.08,1.6 y y3 3 2,2 2 = = 0.05,  1 2 − = 0.08 − = 1.6 −4.016
Calculate k3,1 and k3,2
 h h h  k f 3,1 1 = + t ,  y + + k y, k   o o 2 ,1 2 2,1 , o 2 2 2 ,2 
 0.1 0.1
3, + + ( ) 0.1  k f 1 1 = +  0 , 0 1.07314 , 2 ( ) −4.016   2 2 2 
k f 3, ( ) 1 1 1 = = 0.05, 0.053657, 1.799 − + y e −t 1 0.8y2
( ) k e = −0.0536576* 1 0− .05 3,1 + = 0.8( ) 1.799 1.3004
 h h h  k f 3,2 2 = + to o ,  y ,1 + + k y 2,1 , , k
2 2 o 2 2 2 ,2   
 0.1 0.1 0.1  k f 3,2 2 = +  0 , 0 + + ( ) 1.07314 , 2 ( ) −4.016   2 2 2 
k f 3 3,2 2 = = ( ) 0.05, 0.053657, 1.799 y y 1 2 −
k 3 3,2 = − 0.053657 1.799 = −5.77Simultaneous Systems of Differential Equations 263
Calculate k4,1 and k4,2
k f 4,1 1 = + ( ) t h i i ,  y h ,1 + + k y 3,1 3 ,  ,2 h k3,2
k f 4,1 1 = + ( ) 0 0.1, 0 + + 0.1( ) 1.3 , 2 0.1( ) −5.77
k f 4,1 1 = = ( ) 0.1, 0.13, 1.423 − + 0.13e
1 0− .1 0.8( ) 1.423 = 0.81865
k f 4,2 2 = + ( ) t h i i ,  y h ,1 + + k y 3,1 3 ,  ,2 h k3,2
k f 0.13, 1.423 0.13 1.4233 4,2 2 = = ( ) 0.1,  − = −2.751
calculate y1,1
h
y y 1,1 1 = + ,0 { } k k2 2
6 1,1 2 + + ,1 k k 3,1 4 + ,1
0.1
y1,1 = + 0 1.6 1.3 0.8186 0.1194 
6 { } + + 2( ) 1.073 2( ) + =
Calculate y1,2
h
y y 2,1 2 = + ,0 { } k k + + 2 2k k
6 1,2 2,2 3,2 4 + ,2
0.1
y2,1 = +2 { } − +8 2( ) − + 4.016 2( ) − − 5.77 2.751 = 1.4946
6
Table 8.3 summarizes the manual calculations of the first step (i.e., x1 = 0.1). The 
remaining values are calculated using Excel, listed in Table 8.4. Figure 8.11 is a plot 
of the data obtained from the excel calculations.
Simulink Solution
Before performing the Simulink block diagram solution of the equations described 
in Example 8.3, we must change the configuration parameters to RK4 (through the 
modeling/model setting). The changes include the start time, the stop time, the 
type, the solver selection, and the fixed step size (Figure 8.12). The Simulink graph￾ical programming (utilizing the RK4 method) of the equations defined in Example 
8.3 is illustrated in Figure 8.13. The figure shows the values of the dependent 
TABLE 8.3
Manual Calculation Using RK4 and Step Size, h = 0.1
i x
k1 k2 k3 k4
k1,1 k1,2 k2,1 k2,2 k3,1 k3,2 k4,1 k4,2 y1 y2
0 0 0 2
1 0.1 1.6 –8 1.073 –4.016 1.3 –5.77 0.81865 –2.751 0.119 1.4946264 Numerical Methods in Chemical Engineering Using Python® and Simulink®
TABLE 8.4
The Following Is the Excel Solution
i t k11 k1,1 k1,2 k2,2 k3,1 k3,2 k4,1 k4,2 y1 y2
0 0 0 2
1 0.1 1.600 –8.000 1.073 –4.016 1.301 –5.771 0.818 –2.751 0.119 1.495
2 0.2 0.902 –3.219 0.682 –2.207 0.748 –2.499 0.563 –1.734 0.192 1.255
3 0.3 0.578 –1.786 0.466 –1.364 0.495 –1.457 0.402 –1.125 0.240 1.113
4 0.4 0.407 –1.137 0.346 –0.916 0.361 –0.957 0.311 –0.776 0.275 1.018
5 0.5 0.313 –0.780 0.279 –0.648 0.287 –0.669 0.260 –0.557 0.304 0.952
29 2.9 0.595 0.195 0.607 0.196 0.607 0.197 0.619 0.198 1.186 0.996
30 3 0.619 0.198 0.632 0.199 0.632 0.200 0.644 0.201 1.249 1.016
FIGURE 8.11 Plot of the manual calculations utilizing the RK4 method for solving the two 
ODEs defined in Example 8.3.
FIGURE 8.12 Simulink solver setting to RK4 method for solving the equations defined in 
Example 8.3.Simultaneous Systems of Differential Equations 265
variables (y1, y2) at the simulation stop time (i.e., 3). Figure 8.14 shows the Simulink 
graphical programming solution utilizing the RK4 method of the twin ODEs speci￾fied in Example 8.3.
Figure 8.15 shows the graphical programming in Simulink using the MATLAB 
function from the Simulink library as an alternative way. Following the figure is the 
MATLAB code implanted in the MATLAB function. The following MATLAB pro￾gram is linked to the Simulink MATLAB function (Figure 8.15). Figure 8.16 shows 
the plot of the two ODEs described in Example 8.3. The Simulink MATLAB func￾tion is fed with five input constants representing the lower limit interval ( ) a , upper 
limit interval ( ) b , step size ( ) h , and the initial values of y1 ( ) yo and the initial value 
of y2 ( ) zo . The two output displays the values of the dependent variables (y1 and y2) 
at the simulation stop time (3).
% Example 8.3 using RK4
function [y1f, y2f] = Rk(a, b, h, y0,z0)
% Fourth-order Runge-Kutta integration routine
% Routine starts here
f1=@(x, y, z)(-y*exp(1-x)+ 0.8*z); % Enter RHS of the first ODE
f2=@(x, y, z) (y-z^3); % Enter RHS of the first ODE
x=a:h:b;
y=zeros(1,length(x));
z=zeros(1,length(x));
y(1)=y0;
z(1)=z0;
x(1)=a;
for i=1:(length(x)-1)
m1 = f2(x(i), y(i), z(i));
k1 = f1(x(i), y(i), z(i));
m2 = f2(x(i)+0.5*h, y(i)+0.5*h*k1,z(i)+0.5*h*m1 );
k2 = f1(x(i)+0.5*h, y(i)+0.5*h*k1,z(i)+0.5*h*m1 );
FIGURE 8.13 Simulink solution using the RK4 method of the two ODEs specified in 
Example 8.3.266 Numerical Methods in Chemical Engineering Using Python® and Simulink®
FIGURE 8.14 Simulink solution utilizing RK4 to solve the two ODEs defined in Example 
8.3.
FIGURE 8.15 Simulink simultaneous solution using RK4 of the two ODEs described in 
Example 8.3. Stop time is equal to three.Simultaneous Systems of Differential Equations 267
m3 = f2((x(i)+0.5*h), (y(i)+0.5*h*k2), z(i)+0.5*h*m2);
k3 = f1((x(i)+0.5*h), (y(i)+0.5*h*k2), z(i)+0.5*h*m2);
m4 = f2((x(i)+h), (y(i)+k3*h), z(i)+ h*m3);
k4 = f1((x(i)+h), (y(i)+k3*h), z(i)+ h*m3);
y(i+1) = y0 + (1/6)*(k1+2*k2+2*k3+k4)*h;
y0=y(i+1);
z(i+1) = z0 + (1/6)*(m1+2*m2+2*m3+m4)*h;
z0=z(i+1);
end
y1f=y0;
y2f=z0;
% Plot section
plot(x, y, x, z, ‘linewidth’, 1.3);
text(0.45,1.05, ‘\leftarrow y_1’, ‘color’, ‘r’, FontSize=15)
text(0.45,0.25, ‘\leftarrow y_2’, ‘color’, ‘b’, FontSize=15)
text(0.75,1.45, ‘Runge–Kutta method’, FontSize=15)
xlabel(‘x’, FontSize=15);
ylabel(‘y_1, y_2’, FontSize=15);
grid on 
Python Solution
The ‘SciPy’ method is used for solving the required set of equations defined in 
Example 8.3, and it now has ‘solve _ ivp ’. This solves the system on the interval 
(0,3) with an initial value (0,2). The result has an independent value (t in the nota￾tion) as ‘res.t’. These values were chosen automatically. One can provide ‘teval’ to 
have the solution evaluated at desired points: for example,
teval = np.linspace( ) 0,0.1
FIGURE 8.16 Simulink plot generated utilizing RK4 of the twin equations defined in 
Example 8.3.268 Numerical Methods in Chemical Engineering Using Python® and Simulink®
While the dependent variable, the function we are solving, is in res.y
Solve_ivp function built-in Python library (SciPy. Integrate) is employed to solve 
the two ODEs simultaneously. The Python code simultaneously solved the two 
ODEs described in Example 8.3, using the solve_ivp function. Running the Pyhone 
code generates Figure 8.17.
#Example 8.3
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
# enter the model equations
def rhs(t, y):
return [-y[0]*np.exp(1-t)+0.8*y[1], y[0]-y[1]**3]
# enter the initial conditions as shown below
res = solve_ivp(rhs, (0, 3), [0,2])
print (res.t)
t_eval=np.linspace(0, 3)
print (res.y)
plt.plot(res.t, res.y.T)
plt.ylabel(r’$y_{1}, y_{2}$’, fontsize=14)
plt.grid(True)
plt.xlabel(‘Time’, fontsize=14)
The following Python code is programmed using RK4 syntax to solve these two 
types of ODEs defined in Example 8.3. The results are in good agreement with 
those obtained from the solver of the IVP ( ) solveivp . Execution of the Python pro￾gram results in the plot disclosed in Figure 8.18. The Python code presented here 
is for the RK4 method in two dimensions.
# Example 8.3
# Runge Kutta method
import matplotlib.pyplot as plt
import numpy as np
from numpy import arange
FIGURE 8.17 Plot of dependent variables ( ) y y 1 2 and against the time generated by the 
Python program to solve Example 8.3.Simultaneous Systems of Differential Equations 269
# y’ = -y*np.exp(1-x)+0.8*u
# u’ = y-u**3
def F1(y, u, x):
return -y*np.exp(1-x)+0.8*u
def F(y, u, x):
return y-u**3
a = 0
b = 3
N =30
h = (b-a)/N
xp = arange(a, b, h)
yp = []
up = []
# initial conditons
y = 0.0
u = 2
for x in xp:
yp.append(y)
up.append(u)
m1 = h*F1(y, u, x)
k1 = h*F(y, u, x) #(x, v, t)
m2 = h*F1(y+0.5*m1, u+0.5*k1, x+0.5*h)
k2 = h*F(y+0.5*m1, u+0.5*k1, x+0.5*h)
m3 = h*F1(y+0.5*m2, u+0.5*k2, x+0.5*h)
k3 = h*F(y+0.5*m2, u+0.5*k2, x+0.5*h)
m4 = h*F1(y+m3, u+k3, x+h)
k4 = h*F(y+m3, u+k3, x+h)
y += (m1 + 2*m2 + 2*m3 + m4)/6
u += (k1 + 2*k2 + 2*k3 + k4)/6
# plot section
plt.plot(xp, yp, ‘r-’, label=’$y_{1}$’)
plt.plot(xp, up, ‘b-.’, label=’$y_{2}$’ )
plt.xlabel(‘Time’, fontsize=14)
plt.ylabel(r’$y_{1}, y_{2}$’, fontsize=14)
plt.legend()
plt.grid(True
FIGURE 8.18 Python solution using RK4 of the two ODEs given in Example 8.3.270 Numerical Methods in Chemical Engineering Using Python® and Simulink®
8.2.4 PIcard’s IteratIve method
Picard’s method is iteratively used for approximating the solution to differential 
equations. The method gives a sequence of approximations to the solution of dif￾ferential equations such that the nth approximation is obtained from one or more 
previous approximations ( , y x 1 2 ( ) y x( ), . … y x n ( )). The more iterations used, the more 
numerical results become more and more accurate. The following steps are used in 
solving simultaneous differential equations using Picard’s iterative method:
1. Substitute an approximate value of y into the right-hand side of the differen￾tial equation.
2. Integrate the equation concerning x, giving y in terms of x as a second 
approximation.
3. Iterate until two consecutive numerical solutions are the same.
Let
dy = = f x, , y z ,  with y xo o y dx ( ) ( ) (8.26)
and
dz = = g x( ) , , y z ,  with z x( ) o o z (8.27) dx
where z and y are dependent variables on x (independent). Using the Picard method, 
the value of yn and zn is given as
x
y y n o = + f x( ) , , y z n n − − 1 1 dx (8.28)
x
∫
o
and
x
zn o = + z g x y, , n n 1 1 z d
x
∫ ( ) − − x (8.29)
o
n = 1, The first approximation
x
y y 1 = +o f x, , y z o o dx
x
∫ ( ) (8.30)
oSimultaneous Systems of Differential Equations 271
and
x
z1 = + z g o ∫ ( ) x y, , o o z dx (8.31)
xo
n = 2, The second approximation
y y 2 1 o ∫
x
= + f x( ) , , y z1 dx (8.32)
xo
and
x
z2 1 = + z g o ∫ ( ) x y, ,z d 1 x (8.33)
xo
n = 3, The second approximation
x
y y 3 2 = +o f x, , y z2 dx
x
∫ ( ) (8.34)
o
and
x
z3 2 = + z g o ∫ ( ) x y, ,z d 2 x (8.35)
xo
Example 8.4 Application of Picard’s Method
Using the Picard method, find an approximate value of y and z at x = 0.1 for the 
following two ODEs
dy = +x z,    y( ) 0 2 = dx
dz = −x y2
,  z( ) 0 1 = dx
Solve manually and using Python and Simulink272 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solution
Applying Picard’s method for solving the following two ODEs together is as follows:
At x = 0
dy = +x z = f x( ) , , y z dx
dz = −x y2 = g x, , y z dx ( )
Employing the Picard method,
= + ∫
x
y y n o f x( ) , , y z n n − − 1 1 dx
xo
x
z z n o = + g x, , y z n n 1 1 dx
x
∫ ( ) − −
o
n = 1, the first approximation of y and z
= + ∫ ∫
x x
y y 1 o f x( ) , , x z o o dx = +2 f x( ) + z d o x
xo ox
y x 1 ( ) = +2 1
x
∫
x 2
( ) x x d + = x x 2 + +
2 o
Substitute x = 0.1
0.1
x 2 2 0.1
y x 1 ( ) 0.1 = +2 1 ∫( ) + = dx 2 + +x = +2 0.1+ = 2.105
2 2 0
Calculate z at x = 0.1
= + ∫ ∫
x x
z z 1 g x, , y z 1 2 o ( ) o o dx = + ( ) x y − o dx
xo ox
z1 ( ) x x = +1 2 ∫
x
( ) 2
2 x − = dx 1+ − 4x 2 0Simultaneous Systems of Differential Equations 273
Substitute x = 0.1
0.
( ) 0.1 1 2 ∫
1
( ) 2 2 0.1
z1 = + x d − = 2 x x 1+ − 4 1 x = + − = 4( ) 0.1 0.605
2 2 0
( 2 n = ) The second approximation of y and z
x
y y 2 = +o ∫ f x( ) , , y z dx
xo
x x
x 2  y x 2 2 2 ∫ ∫ = + ( ) + = z d 1 x x + +  1 4 − +x 2  dx   0 0
x x 2 3
y x 2 ( ) = +2 3 x − +
2 6
Substitute x = 0.1
0.12 3 0.1
y2 ( ) 0.1 = +2 0.1− + 3 = 2.085
2 6
Now we will calculate z2
x
x
∫
x
z2 1 = + z g o ( ) x y, ,z d 1
o
x
z2 1 = + z g o ∫ ( ) x y, ,z d 1 x
xo
x
= +1 ∫( ) x y − 2
1 dx
0
∫
x   x 2 
2 
= +1 2  x x − + +   2   dx   0 
x 1 4 ∫
x
 4  = + − − 2 − − 3 2 −  x x x x2 dx  4 
 0
x 2 3 x x5 4 x x2 3
= +1 − − 4x − − − 2 3 20 4 3274 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Substitute x = 0.1
( ) 0.12 3 0.1 0.15 4 0.1 2(0.1)3
z2 0.1 = +1 − 4( ) 0.1 −−− − = 0.603975
2 3 20 4 3
3rd approximation (n= 3)
∫
x
y y 3 2 = +o f x( ) , , y z2 dx
xo
x
y x 3 2 = +2 z dx
x
∫( ) +
o
∫
x
 3x 2 x x 4 5 
y x 3 = +2 1  + − 4x − − x3 − −  dx
 2 4 20 0 
Rearrange and integrate
3x x 234 x x5 6 x y x 3 = +2 − − − − − 2 2 4 20 120
Substitute x = 0.1
5 6
( ) 3( ) 0.1 234 ( ) 0.1 ( ) 0.1 ( ) 0.1 ( ) 0.1
y3 0.1 = +2 0.1− − − − − 2 2 4 20 120
y3 ( ) 0.1 = 2.085
For z
x
z3 2 = + z g o ∫ ( ) x y, ,z d 2 x
xo
1 ∫
x
z x y2 3 = + ( ) − 2 dx
0
∫
x   2
3x x 2 3  
z3 = +1 2 x x − + − +   dx  2 6    0  
Integrate
3x x5 7x x 31 x x z3 = −1 4x − + + − + −
2 2 12 60 12 252
2 3 4 5 6 7Simultaneous Systems of Differential Equations 275
Finally,
z3 ( ) 0.1 = 0.587
Simulink Solution
The Simulink solution of Example 8.4 is shown in Figure 8.19.
An alternative solution is the Simulink MATLAB function embedded with the 
MATLAB code. The MATLAB code describes the solution of the two ODEs defined 
in Example 8.4. The input port to the MATLAB function, the constant (a), repre￾sents the value at which the dependent variables are required to find (Figure 8.20).
% Example 8.4 using the Picards method
function [y, z]= fcn(a)
%x=a;res
y1=@(x) 2+x+x^2/2;
z1=@(x) (1 + x^2/2 - 4*x) ;
y2=@(x) 2 + x - 3*x^2/2 + x^3/6;
z2=@(x) 1+x^2/2 -4*x-x^3/3-x^5/20 - x^4/4 - 2*x^3/3;
y3=@(x) 2+x-3*x^2/2-x^3/2-x^4/4 -x^5/20-x^6/120;
z3=@(x) 1–4*x - 3*x^2/2 +5*x^3/2+7*x^4/12–31*x^5/60+x^6/12-x^7/252;
y =y3(a);
z =z3(a);
Python Solution
The following is the Python code utilized by the Picard method to solve the two 
ODEs defined in Example 8.3.
#Picard’s Method
#
FIGURE 8.19 Simulink solution using the Simulink integrator with default solver of the 
equation defined in Example 8.4, the stop time is 0.1.276 Numerical Methods in Chemical Engineering Using Python® and Simulink®
def y1(x):
Y1 = 2+x+x**2/2
return Y1
def z1(x):
z1 = 1 + x**2/2 - 4*x
return z1
def y2(x):
Y2 = 2 + x - 3*x**2/2 + x**3/6
return Y2
def z2(x):
z2 = 1+x**2/2 -4*x-x**3/3-x**5/20 - x**4/4 - 2*x**3/3
return z2
def y3(x):
Y3 = 2 + x - 3*x**2/2-x**3/2-x**4/4 -x**5/20-x**6/120
return Y3
def z3(x):
z3 = 1–4*x - 3*x**2/2 +5*x**3/2+7*x**4/12–31*x**5/60+x**6/12-x**7/252
return z3
#
print (‘ ‘)
print (‘ === Solution ===’)
print (‘for dy(x) = x + y^2 , dz(x)=x-y^2, the results are :’)
print (‘--------------------------------------’)
print (‘y1(0.1) = ‘, “%.3f”%y1(0.1))
print (‘y2(0.1) = ‘, “%.3f”%y2(0.1))
print (‘y3(0.1) = ‘, “%.3f”%y3(0.1))
print (‘z1(0.1) = ‘, “%.3f”%z1(0.1))
print (‘z2(0.1) = ‘, “%.3f”%z2(0.1))
print (‘z3(0.1) = ‘, “%.3f”%z3(0.1))
The Python execution results are displayed as follows:
=== Solution ===
for dy(x) = x + y^2 , dz(x)=x-y^2, the results are :
--------------------------------------
y1(0.1) = 2.105
y2(0.1) = 2.085
FIGURE 8.20 Simulink solution using Picard’s method of the equations defined in Example 
8.4 and a stop time of three.Simultaneous Systems of Differential Equations 277
y3(0.1) = 2.084
z1(0.1) = 0.605
z2(0.1) = 0.604
z3(0.1) = 0.588
8.3 SUMMARY
Numerical methods of ODEs are used to find a numerical approximation of solutions 
simultaneously to two ODEs. The chapter goes through the numerical integration 
methods, including Euler, Midpoint, the RK4, and the Picard as appropriate meth￾ods for solving two ODEs simultaneously. The numerical integration methods were 
graphically programmed using Simulink and coded using Python.
8.4 PROBLEMS
1. Solve the following two first-order initial value ODEs using the Euler 
method. Using a step size of 0.1, find the value of x and y at t= 0.3. verify 
the solution using Simulink and Python.
dx
= + 3 8 x y,   x( ) 0 6 = dt
dy = −x y − = 3 ,   y( ) 0 2− dt
Answer: 6.782, –2.060
 2. Applying the Midpoint method, solve the following two first-order initial 
dy1 = − 3 4 y y 1 2 ,     y1 ( ) 0 1 = dx
dy2 = − y y 1 2 ,   y2 ( ) 0 0 = dx
Answer: 2.155, 0.4029
 3. Utilizing the RK4 method, solve the following two first-order initial value 
dy = + 3 4 y x,   y( ) 0 0 = dt
dx = −4 3 y x + = ,    x( ) 0 1
dt
Answer: –1.87, 4.075278 Numerical Methods in Chemical Engineering Using Python® and Simulink®
4. Using the RK4 method, solve the following two first-order initial value 
ODEs using a step size of 0.1 to find the value of x and y at x= 0.3. Validate 
the manual results using Simulink and Python programming.
dy1 = = y y 2 1 ,  ( ) 0 0
dt
dy2 = − 10 1 , y y 2
1 2 1y y  0 2 1
dx ( ) − = ( )
Answer: 1.308, 6.518
5. Utilizing the RK4 method, solve the following two first-order initial value 
ODEs representing the concentration of components A and B in a batch 
reactor using a step size of 0.1 to find the value of CA and CB at t= 0.5. 
Confirm the manual solution using Simulink and Python programming. 
The values of the rate constants, k1 = 0.1, k2 = 0.2.
dCA = −k C1 ,  C 0 1
dt A A ( ) =
dCB = − k C1 2 A B k C ,    CB ( ) 0 0 = dt
Answer: 0.95, 0.046
 6. Solve the following two ODEs by Picard’s iteration method up to the second 
dy1 = = y y 2 1 ,      ( ) 0 1
dx
dy2 = + x y 3 1 2 y y ,      2 0 0.5
dx ( ) ( ) =
Answer: 1.4896, 0.8500
REFERENCES
1. Atkinson, K., Han, W., and Stewart, D., 2009, Numerical Solution of Ordinary 
Differential Equations. Newyork: John Wily.
3. Kong, Q., Siauw, T., and Bayen, A., 2021, Python Programming and Numerical 
Methods: A Guide for Engineers and Scientists. California, CA: Academic Press.
 2. Griffiths, D.F., and Higham, D., 2010, 279
9 Boundary Value 
Problems of Ordinary 
Differential Equations
A boundary value problem (BVP) is a system of ordinary differential equations 
(ODEs) with a solution and derivative values defined at more than one point. This 
chapter uses finite differences and shooting methods to convert BVPs into algebraic 
equations. Furthermore, the Thomas algorithm is presented and explained in this 
chapter. Manual calculations are compared to Python and Simulink programming 
predictions, where the code is given for each case.
LEARNING OBJECTIVES
1. Identify a BVP.
2. Implement the shooting method to solve a BVP.
3. Apply the finite difference method.
4. Use the Thomas algorithm to solve a BVP. 
5. Utilize Python and Simulink/MATLAB to tackle a BVP.
9.1 INTRODUCTION
A differential equation is defined as an equation that relates one or more unknown 
functions and their derivatives in mathematics. ODEs can only be solved given addi￾tional information, called boundary conditions (BCs). If the BCs are specified at the 
same independent variable value (e.g., x), the problem is an initial value problem 
(IVP). Some BCs are specified at different values for the independent variable, such 
as initial and final positions of x; these are called BVPs. The differential equation 
contains one or more terms and the derivatives of one dependent variable concerning 
another independent variable [1]. We often see them for problems where conditions 
are specified at various locations in space rather than time.
dy = f x( ) (9.1) dx
Here, ‘x’ is an independent variable and ‘y’ is a dependent variable, such as
dy = 5x (9.2) dx
DOI: 10.1201/9781003360544-9280 Numerical Methods in Chemical Engineering Using Python® and Simulink®
A differential equation contains derivatives that are either partial derivatives or ordi￾nary derivatives. BVPs commonly arise in many engineering subjects, such as heat 
transfer, mass transfer, and reactor design. An example of the BVP is the steady-state 
temperature distribution along a rod hung between two plates of different tempera￾tures (Figure 9.1). A BVP comprises a differential equation subject to a given set of 
BCs. BCs are prescribed for the unknown variable and its derivatives at more than 
one point [2].
An example of a second-order BVP is shown below:
d y2
dx 2 = y x( ) (9.3)
9.2 BOUNDARY CONDITIONS
BCs are constraints to solve a BVP. It is the conditions that are satisfied on the bound￾aries of the spatial domain of the problem. Considering the following BCs,
y y ( ) 0 0 = = ,  ( ) 1 1
Note that the number of BCs equals the order of the ODE. In this example, the given 
interval is [0, 1]. Then the number of subintervals, n,
b a − n = h
For h = 0.25
1 0 − n = = 4
0.25
The aim is to find y y ( ) 0.25 ,  ( ) 0.5 ,  y( ) 0.75 , if h = 0.25. From the BCs, y( ) 0 and y( ) 1
are known (Figure 9.2).
Every ordinary or partial derivative occurring in the equation and the BCs is 
replaced by finite difference approximation. Accordingly, the equation is reduced to 
FIGURE 9.1 Schematic of a rod fixed between two plats with different temperatures.Boundary Value Problems of ODEs 281
a set of linear systems of equations, which are then solved using standard methods. 
The following sections describe initial and BCs.
9.2.1 INItIal value Problems
In mathematics, an IVP is an ODE with an initial condition that defines the value of 
the unknown function at a given point in the domain. Modeling a system in physics 
or other sciences often amounts to solving an IVP. The auxiliary conditions are at 
one point of the independent variable
d y2 dy −2x
dx 2 + + 2 y e = (9.4) dx
The initial conditions are at one point of the independent variable ( 0 x = ),
dy y( ) 0 1 = = ,   ( ) 0 2.5
dx
9.2.2 bouNdary value Problem
The BVP is a differential equation with additional constraints called BCs. In the 
BVPs, the auxiliary conditions are not at one point of the independent variable. BVP 
is more difficult to solve compared to the IVPs. By contrast, the initial conditions in 
the IVP are at one point of the independent variable. A BVP is a system of ODEs 
with a solution and derivative values specified at more than one point. Usually, the 
solution and derivatives are specified at the boundaries (two points) that define the 
two-point BVP. Equation (9.5) is a second-order BVP with BCs at two different loca￾tions of the independent variable, x.
d y2 dy 2 + + 2 y e = −2x
 (9.5) dx dx
With the BCs: y y ( ) 0 1 = = , 2( ) 1.5
FIGURE 9.2 Schematic dividing the main interval [0, 1] into four subintervals.282 Numerical Methods in Chemical Engineering Using Python® and Simulink®
9.3 SOLUTION OF BVPs
The following sections present two methods of solving BVP: the finite difference 
method and shooing methods. These methods transform BVPs into algebraic equa￾tion problems. The generated set of equations is linear when the differential equation 
is linear for either method.
9.3.1 fINIte dIffereNce method
The finite difference method replaces derivatives in a differential equation with 
approximation, leading to an extensive linear equation system that must be solved 
using numerical techniques. The following formulas are used in solving BVPs:
The forward finite difference approximation formula for y x ′( )
dy y y = y′ = i i +1 − (9.6) dx h
Backward finite difference formula for y x ′( )
dy y y i i − −1 y x( ) − − y x( ) h Present P − revious = y′ = = = (9.7) dx h h h
Central finite difference, also called the central difference approximation for y x ′( )
dy y y i i + − 1 1 − y x( ) + − h y( ) x h − Next − Previous = y′ = = = (9.8) dx 2 2 h h h 2 ×
The formula for the second derivative, y x ′′( )
d y2 y y i i + − 1 1 − + 2 yi y x( ) + − h y 2 ( ) x y + − ( ) x h 2 = y′′ = 2 2 = (9.9) dx h h
d y2 Next − × 2 Present P + revious = (9.10) dx 2 2 h
Figure 9.3 describes the forward finite difference methods and central and backward 
formulas.
Follow the steps below to solve the BVP using the finite differences method:
1. Divide the interval between the initial and boundary value into n intervals.
 2. Use the finite difference approximation method to replace the derivatives.
 3. Solve the generated set of algebraic equations resulting from the finite dif￾ference approximation to obtain the solution to the BVP.Boundary Value Problems of ODEs 283
FIGURE 9.3 Representation of the finite difference method approximation.
The solution method can be summarized by substituting the finite difference 
approximation for the derivatives occurring in the equation and the BCs and then 
solving the algebraic equations by substitution or using any known solver.
9.3.2 thomas algorIthm
The Thomas algorithm can be used to obtain the solutions for the tridiagonal matrix 
system. The tridiagonal matrix has three non-zero elements in all its rows, except in 
the first and last rows. The first and last rows have one element on the right and left 
of the diagonal elements. The tridiagonal systems are standard when using the finite 
difference second-order method to solve BVPs. Having the algebraic equation,
ai i     y b − + 1 1 − + i i y ci i y r = i
where ai is the coefficient of yi−1, bi is the coefficient of yi, ci is the coefficient of yi+1, 
and ri is the right-hand side of the equation. The equations describing the Thomas 
algorithm are listed in Table 9.1.
Example 9.1 Application of Finite Difference Method
Solve the following BVP using the finite difference approximation approach apply￾ing four subintervals (n= 4).
d y2 dy 2 + + 2 y x = 2
dx dx
The BCs are as follows:
y y ( ) 0 = = 0.2,  ( ) 1 0.8
Solve the BVP manually, using Python and Simulink graphical programming 
language.284 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solution
Divide the interval [0, 1] into four subintervals ( 4 n = ), and hence h = 0.25.
Using finite central difference formulas,
d y2 y y = i i + − 1 1 − + 2 yi
dx 2 h2
Central method for the first derivatives
dy y y = i i + − 1 1 −
dx 2h
The second-order ODE becomes
y y i i + − 1 1 − + 2 yi i y y 2 + 2 + − 1 1 − i + = y x 2
h 2 i i h
Multiply both sides by h2
y y 1 1 − + 2 y h + − ( ) y y 2 2 2 i i + −i i+ − 1 1 i i + = h y h x
Rearrange
(1 2 − + h y) ( 2 2 2 i i − + 1 ( ) h y − + 1+ = h y) i 1 h x
TABLE 9.1
Thomas Algorithm for Solvent Tridiagonal Matrix
β1 = b1
γ 1 γ 1 = β1
For i = 2,...,n
βi
 ci − 1  = bi − ai

 β − 1
 i
γ i
 γ i − aiγ i−1  = 
 β 
 i
yn = γ n
End
For j = 1,...,n − 1
yn j −
yn j − +1 = γ n j − − cn j −
βn j −
EndBoundary Value Problems of ODEs 285
Divide by (1− h)
0.75  y y 1 1 1.9375 1.25  y x 0.0625 2 i i − + − + i i =
Solve for i = 1  to  3
  1 i y = −:  1.9375 + + 1.25  0 y x = − 0.0625 2 1 2 1 0.75yo
i y = − 2 :   0.75  1 2 1.9375y y + = 1.25  0.0625 2 3 2 x
i y = + 3 :   0  0.75  2 2 3 − = 1.9375y x 0.0625 3 −1.25  y4
Rearrange (previous y1, present y2, next y3) and consider the substitution of the 
known initial y0 and boundary value y4
–1.9375y y + + = −2 1 2 1.25   0   0.0625x y 1 0.75 0
0.75  y y 1 2 − + 1.9375 1.25    y x 2 3 2 =  0.0625
 0 + −  0.75  y y 2 3 1.9375 = −    0.0625x y 2
3 1.25  4
From BC 1, y y ( ) 0 = = 0 0.2 to BC 2, y y ( ) 3 = = 4 0.8
  −1.9375 1.25 0  y   0.146    1 −    0.75 −1.9375 1.25 = 0.0156   y2     0 0.75 −1.9375  y3   −0.9648      
In matrix form,
A Y. = B
The solution was obtained using the Python code shown below:
y y 1 2 = = 0.5166,  0.684,  y3 = 0.7627
Python provides a straightforward method to calculate the inverse of a matrix. 
The function linalg.inv(), available in the Python NumPy module, is used to com￾pute the inverse of a matrix. The inverse of a matrix (A) is multiplied by the con￾stants (B). The set of linear algebraic equations is solved as shown in the following 
Python codes.
# Solving a set of linear algebraic equations
import numpy as np
# Matrix coefficient
A1=[-1.9375, 1.25,0]
A2=[0.75, -1.9375,1.25]
A3=[0, 0.75,-1.9375]
A = np.array([A1,A2 , A3])
B = np.array([-0.146, 0.0156, -0.9648])286 Numerical Methods in Chemical Engineering Using Python® and Simulink®
X = np.linalg.inv(A).dot(B)
print(“”)
print(X)
The following calculated values of y1, y2, and y3 are generated from the Python 
program after execution.
[0.51668057 0.68405489 0.76275673]
Simulink Solution
Using Math Operations/Algebraic Constraints
First, the linear algebraic equations are arranged and solved by Simulink using the 
‘Math Operations/Algebraic Constraints’ function in the Simulink library.
− + 1.9375y y 1 2 1.25 + = 0.146 0
0.75y y 1 2 − + 1.9375 1.25y3 − = 0.0156 0
0.75y y 2 3 − + 1.9375 0.9648 = 0
The BCs
y y ( ) 0 = = 0.2,   ( ) 1 0.8
The Simulink predicted results (Figure 9.4) agree with the manual calculations used 
in solving the three linear algebraic equations.
Using the Simulink MATLAB function, an alternative Simulink solution uses the 
finite difference method by discretizing the ODE. The second-order BVP
d y2 dy 2 + + 2 y x = 2
dx dx
Discretizing the second-order ODE into a tridiagonal matrix by using the finite dif￾ference formula for the second derivative,
d y2  y i( ) + − 1 2y i( ) + − y i( ) 1 
dx 2 2 =    h 
Using the central method for the first derivative,
dy y i( ) + − 1 y( ) i 1 − =     dx 2h
The discretized ODE into a tridiagonal matrix
y i( ) + − 1 2y i( ) + + y i( ) 1 y i( ) + − 1 1 y i( ) +
   +2 + = y i( ) x( )i
h2 × 2
2hBoundary Value Problems of ODEs 287
Arranging,
( ) 1 1  ( ) 2  ( ) 1  y i + + 1 2 2  +y i − +1  + 1 y i + −1 = i 2
 x( )  h h 
  h 
 
 h 

The supper diagonal is the coefficient of y i( ) +1
1 1 supd = +
h h 2
The main diagonal is the coefficient of y i( )
2 maind = + 2 1
h
The sub diagonal is the coefficient of y i( ) −1
1 supd = −1
h
FIGURE 9.4 Simulink block diagram for the solution of the BVP defined in Example 9.1.288 Numerical Methods in Chemical Engineering Using Python® and Simulink®
FIGURE 9.5 Simulink block diagram using finite difference method for solving the BVP 
specified in Example 9.1.
Figure 9.5 is the Simulink block diagram followed by the MATLAB codes embed￾ded into the Simulink MATLAB function, illustrating the finite difference method 
solution of Example 9.1. The MATLAB function contains four input ports that rep￾resent the interval lower and upper limit (xlim), BC 1 ( ) y0 , BC 2 ( ) y1 , and the num￾ber of intervals (n). The exit port displays the results at each grid point.
The following MATLAB codes are associated with the Simulink MATLAB func￾tion and solve the ODE using an indicated discretization. Using MATLAB, the 
results are drawn in Figure 9.6.
function res = FDM(xlim, y0,y1,n)
% y”+2y’+y=x^2
% xlim: is the limit interval [a, b]
% y0, y1 are the boundary conditions at a, and b
% n is the number of elements in the final result
function [y, x] =ODEsolve(xlim, y0,y1,n)
 x = linspace(xlim(1), xlim(2), n)’;
 % stride
 h = x(2) - x(1);
 % The main diagonal has coefficients
 maind = [1;repmat(-2/h^2 + 1,n - 2,1);1];
 % The sub diagonals has coefficients
 subd = [repmat(1/h^2 - 1/h, n-2,1);0];
 % The super diagonals has coefficients
 supd = [0;repmat(1/h^2 + 1/h, n-2,1)];
 % The ODE matrix
 ODEmat = diag(maind) + diag(subd, -1) + diag(supd, 1);
 % create the right hand side for the solve:
 rhs = [y0;x(2:end-1).^2;y1];Boundary Value Problems of ODEs 289
FIGURE 9.6 Solution of the BVP defined in example 9.1 using finite difference method and 
the Simulink MATLAB function.
 % solve the matrixa a call to backslash
 y =ODEmat\rhs;
 end
[y, x] = ODEsolve(xlim, y0,y1,5);
res =y;
plot(x, y, ‘bo-’), xlabel(“x”), ylabel(“y”);
grid on
end
Python Solution
In the finite difference method, the derivatives of the differential equation are 
approximated using the finite difference equations. Python solution generates 
Figure 9.7 while using the finite difference method discretizing the BVP of Example 
9.1. The following Python program uses the finite difference method to solve the 
BVP equation using the finite difference approximation method. The values of y
are shown below, and the entire data are plotted in Figure 9.7.
import numpy as np
import matplotlib.pyplot as plt
# (1-h)y_(i-1)+(h^2-2)y_i+(1+h)y_(i+1)=h^2 x^2
a=0
b=1
n = 4
h = (b-a) / n
# Matrix coefficient
A = np.zeros((n+1, n+1))
A[0, 0] = 1
A[n, n] = 1290 Numerical Methods in Chemical Engineering Using Python® and Simulink®
FIGURE 9.7 Python solution using the BVP finite difference method described in 
Example 9.1.
# matrix coefficient
x = np.linspace(a, b, n+1)
for i in range(1, n):
 A[i, i-1] = 1-h
 A[i, i] = h*h-2
 A[i, i+1] = 1+h
#print(A)
x = np.linspace(a, b, n+1)
b = np.zeros(n+1)
b[0]=0.2 # boundary conditon 1
for i in range(1, n):
 b[i] = h**2*x[i]**2
b[n] = 0.8 # boundary condtion 2
#print(b)
# solve the linear equations
y = np.linalg.solve(A, b)
plt.figure(figsize=(8,5))
plt.plot(x, y, ‘ro-’)
plt.plot(a, b[0], ‘bo’), plt.plot(1, 0.8, ‘bo’)
plt.xlabel(‘x’), plt.ylabel(‘y’)
plt.grid(True)
print (y)
Execution
[0.2 0.51675525 0.68409563 0.76279508 0.8 ]
Example 9.2 Application of the Finite Difference Method
Solve the following second-order BVP using the finite difference approximation 
method with h= 0.5 within the interval [1, 3].
d y2  x    1 = − y x + = ; ( y y 1) 2, (3) 1 = − dx 2 
 5 

Solve manually using Python, Simulink, and MATLAB.Boundary Value Problems of ODEs 291
FIGURE 9.8 Describes the subintervals used to solve the BVP defined in Example 9.2.
Solution
Using a step size of 0.5, as stated in the problem statement (h= 0.5), resulting in 
four subintervals, as shown in Figure 9.8.
There are five nodes with h= 0.5: y0, y1, y2, y3, and y4. However, there are only 
three unknowns since y0, y4 are known:
  ( y y 0 4 = = 1) 2 ( and y = = y 3) −1
Discretizing the equation in the finite difference form, the ODE becomes
y y i i + − 1 1 − + 2 yi i  x  2 − −1 y x i i = =i 1, 2, 3, 4
h 
 5 

Multiply both sides by h2
 and rearranging,
2  x y y h i    2 2 i i + + 1 − − 1−   y y i i + =  5  1 h xi
Rearrange the equation (previous ( 1 i − ), present ( )i , next ( 1 i − )):
  x    2 y h2 + + 1  1 i 2 i − + − + =   y y h x   5  i i 1 i
Substitute, i= 1, 2, 3
i x = = 1, 1 1.5
 2  1.5  y y 0 − +  2 0.5 1− + = 0.5 ×1.5    y  5  1 2
i x = = 2, 2 2.0
 2  2  y y 1 − +  2 0.5 1−  2 3 + = y 0.52 × 2.0  
 5 

i x = = 3, 3 2.5
 y y − +  2 0.52  2.5  1−  + = 2 2  
 5 
 3 4 y 0.5 × 2.5292 Numerical Methods in Chemical Engineering Using Python® and Simulink®
FIGURE 9.9 Simulink block diagram for the solution of BVP stated in Example 9.2.
After simplifying and substituting the BC, y0 4 = = 2, y −1, the following three linear 
algebraic equations arise:
−2.175y y 1 2 + + 0 = −1.625
y y 1 2 − + 2.15 y3 = 0.5
0 + − y y 2 3 2.125 = 1.625
Solve the three unknowns in the linear algebraic equations by any means. The 
answer is as follows:
y y 1 2 = = 0.552, − = 0.424, y3 −0.9644
Simulink Solution
The linear algebraic equations are solved using Simulink and the Thomas algo￾rithm shown in Figure 9.9, followed by the MATLAB code embeds the Simulink 
function block. Figure 9.9 discloses the results plotted in Figure 9.10.
d y2  x  2 − − 1  y x = = ; ( y y 1) 2, (3) 1 = − dx  5 
After the substitution of the finite difference formulas, the discretized equation is
y y i i + − 1 1 − + 2 yi i  x  2 − − 1  y x 5 i i = h  Boundary Value Problems of ODEs 293
FIGURE 9.10 Simulink solution of the BVP defined in Example 9.2.
Rearranging,
  x   y i( 1 + + ){1} y i( ) − −  2 21− i
 h y 2 2 + − ( 1 i h ) ( = x i)   5  

The supper diagonal is the coefficient of y i( ) +1
supd = 1
The main diagonal is the coefficient of y i( )
 x maind = −2 2 − − 1 i 
 h2
 5 
The subdiagonal is the coefficient of y i( ) −1
subd = 1
On the right-hand side, RHS
rhs x = h2
Simulink Solution
Finite difference methods (FDMs) are numerical methods for solving Partial 
Differential Equations (PDE) by approximating them with difference equations, 
where finite differences approximate the derivatives. Thus, FDMs are discre￾tionary  methods. FDMs convert linear or nonlinear ODE/ Partial Differential 
Equation (PDE) into a system of linear (nonlinear) equations, which matrix algebra 294 Numerical Methods in Chemical Engineering Using Python® and Simulink®
techniques can solve. The reduction of the differential equation to a system of 
algebraic equations makes the problem of finding a solution to a particular ODE 
ideally suited to modern computers, hence the widespread use of FDM in mod￾ern numerical analysis. The Simulink block diagram (Figure 9.9) is a solution to 
Example 9.2. The MATLAB function is connected with four input ports, xlim, y0, 
y1, and n, represent the lower and upper limit intervals, the lower BC 1, the higher 
BC 2, and the number of intervals, respectively. The exit display port contains the 
values of the five nodes.
The following MATLAB code inserts the Simulink block MATLAB function, gen￾erates the result displayed in Figure 9.9, and the plotted the values of y at various 
values of x with step size, h= 0.2. The plotted results of y versus x are shown in 
Figure 9.10. The curve could be smoother if applying a smaller step size,
function res = FDM(xlim, y0,y1,n)
% y(i-1) - 2yi - h^2(1-xi/5)yi + y(i+1)=h^2 xi
% xlim: is the limit interval [a, b]
% y0, y1 are the boundary conditions at a, and b
% n is the number of elements in the final result
 function [y, x] =ODEsolve(xlim, y0,y1,n)
 x = linspace(xlim(1), xlim(2), n)’;
 % stride
 h = x(2) - x(1);
 % The main diagonal has coefficients
 maind = [1;-(2+h^2*(1-x(2:end-1)/5));1];
 % The sub diagonals has coefficients
 subd = [repmat(1,n-2,1);0];
 % The super diagonals has coefficients
 supd = [0;repmat(1,n-2,1)];
% The ODE matrix
ODEmat = diag(maind) + diag(subd, -1) + diag(supd, 1);
 % create the right hand side for the solve:
 rhs = [y0;x(2:end-1)*(h^2);y1];
% solve the matrixa a call to backslash
y =ODEmat\rhs;
end
[y, x] = ODEsolve(xlim, y0,y1,5);
res =y;
plot(x, y, ‘ro-’), xlabel(“X”), ylabel(“Y”);
grid on
end
The Thomas algorithm is utilized to obtain the solution for the tridiagonal matrix 
system.
The equations are solved using Simulink and the Thomas algorithm (Figure 9.11), 
followed by the MATLAB code describing the Thomas algorithm, followed by the 
executed results illustrated in Figure 9.12.
By double-clicking the MATLAB function block, the following MATLAB code is 
appended to the Simulink block:
% Thomas Algorithm, Example 9.2
function Res = Thomas(a0,b0,h, ya, yb)Boundary Value Problems of ODEs 295
FIGURE 9.12 Simulink plot for the solution of Example 9.2, red circle is the BCs; blue 
circles are calculated y values at the three nodes.
% yi-1+[2 + h^2(1-xi/5)yi + yi+1 = h^2xi
a1=a0+h;
b1=b0-h;
x=a1:h:b1;
n=length(x);
b=-(2+h*h*(1-x/5));
c=ones(1,n);a=c;
r=h*h*x;
FIGURE 9.11 Simulink block diagram using Thomas algorithm for the solution of the BVP 
presented in Example 9.2.296 Numerical Methods in Chemical Engineering Using Python® and Simulink®
r(1)=r(1)-ya;r(n)=r(n)-yb;
beta=c;gam=c;y=c;
beta(1)=b(1);gam(1)=r(1)/beta(1);
for i=2:n
 beta(i)=b(i)-a(i)*c(i-1)/beta(i-1);
 gam(i)=(r(i)-a(i)*gam(i-1))/beta(i);
end
y(n)=gam(n);
for j=1:n-1
 y(n-j)=gam(n-j)-c(n-j)*y(n-j+1)/beta(n-j);
end
plot (a0,ya, ‘ro’, b0,yb, ‘ro’, x, y, ‘bo’);
xlabel(‘x’);
ylabel (‘y’);
text(2,1.5,’o Calculated’, ‘Color’, ‘blue’, ‘FontSize’, 12)
text(2,1.7,’o Bounday conditions’, ‘Color’, ‘red’, ‘FontSize’, 12)
grid on
Res = [ya, y(1), y(2), y(3), yb];
Python Solution
Figure 9.13 presents the python solution of the set of equations generated using 
the finite difference method of Example 9.2. The four y values followed the python 
program are at the studied x values. The y values shown below the Python program 
results after executing the python program are the same as those obtained manu￾ally and by Simulink. Figure 9.13 displays the plotted data bounded by the BCs at 
x( ) 1 2 = and x( ) 2 1 = − . The curve could be smoother if decreasing the step size.
FIGURE 9.13 Python solution for the BVP defined in Example 9.2.Boundary Value Problems of ODEs 297
import numpy as np
import matplotlib.pyplot as plt
a=1
b=3
n = 4
h = (b-a) / n
# Matrix coefficient
A = np.zeros((n+1, n+1))
A[0, 0] = 1
A[n, n] = 1
# matrix coefficient
x = np.linspace(1, 3, n+1)
for i in range(1, n):
 A[i, i-1] = 1
 A[i, i] = -(2+h**2*(1-x[i]/5))
 A[i, i+1] = 1
print(A)
x = np.linspace(1, 3, n+1)
b = np.zeros(n+1)
b[0]=2 # boundary conditon 1
for i in range(1, n):
 b[i] = h**2*x[i]
b[n] = -1 # boundary condtion 2
print(b)
# solve the linear equations
y = np.linalg.solve(A, b)
plt.figure(figsize=(9,6))
plt.plot(x, y, ‘ro-’)
plt.plot(1,2,’bo’), plt.plot(3, -1, ‘bo’)
plt.xlabel(‘x’, fontsize=24)
plt.ylabel(‘y’, fontsize=24,rotation=0)
plt.yticks(fontsize=16)
plt.xticks(fontsize=16)
plt.savefig(‘image.jpg’)
plt.grid()
print (y)
Execution results
[ 2. 0.55201375 -0.4243701 -0.96440946 -1]
Example 9.3 Applying Finite Difference Method to Second-Order BVP
Solve the following second-order differential equation using the finite difference 
approximation method,
d y2
2 = −1 y,    dx
Boundary conditions
y y ( ) 0 0 = = ,  ( ) 1 0
Solve manually using Python, Simulink, and MATLAB.298 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solution
Using the finite difference approximation formulas, replace the derivatives with the 
finite difference as follows:
y y i i + − 1 1 − + 2 yi
2 + − yi 1 0 = h
Multiply by h2
y y i i + − 1 1 − + 2 0 y h2 2 i i + − y h =
Rearrange by collecting identical terms
y h 1 ( 2 2 ) 0 y y 2 i i + − + − + − i 1 h =
Substitute step size, h = 0.25
y y i i + − 1 1 − + 1.875 yi − = 0.0625 0
Substitute i = 0  (known BC 1)
yo = 0
Substitute i = 1 
y y 2 1 − + 1.938 y0 − = 0.0625 0
Substitute i = 2 
y y 3 2 − + 1.938 y1 − = 0.0625 0
Substitute i = 3 
y y 4 3 − + 1.938 y2 − = 0.0625 0
Substitute i = 4  known BC 2
y4 = 0
After substituting the BCs, solve the set of three linear algebraic equations to fined 
y y 1 2 , , y3
y y 2 1 − + 1.938 0 − = 0.0625 0
y y 3 2 − + 1.938 y1 − = 0.0625 0
0 − + 1.938y y 3 2 − = 0.0625 0Boundary Value Problems of ODEs 299
There are three equations and three unknowns (the degree of freedom is zero). 
Polymath and any other solver can quickly solve the equations:
y y 1 2 = −0.105,  = −0.140,  y3 = −0.105
Simulink Solution
The three linear algebraic equations can be solved using the algebraic constraint 
function in Simulink under Math Operations. The Simulink block diagram is shown 
in Figure 9.14.
An alternative Simulink solution uses the MATLAB function (Figure 9.15). Using 
finite difference approximation formulas, replace the derivatives with the finite 
difference.
y y i i + − 1 1 − + 2 yi
2 + − yi 1 0 = h
Multiply by h2
y y 1 1 2 0 y h2 2 i i + − − + i i + − y h =
FIGURE 9.14 Solution of three linear algebraic equations using the algebraic constraints 
function in Simulink (Example 9.3).300 Numerical Methods in Chemical Engineering Using Python® and Simulink®
FIGURE 9.15 Simulink block diagram represents the solution using the finite difference 
method of the equation defined in Example 9.3.
Rearrange by collecting the same terms
y i( ) + + 1 1{ } y i( ){ } − +2 1 h y 2 2 + − ( ) i h =
The supper diagonal is the coefficient of y i( ) +1 : supd = 1
The main diagonal is the coefficient of y i( ): maind = −2 + h2
The subdiagonal is the coefficient of y i( ) −1 : subd = 1
On the right-hand side, RHS
rhs h = 2
Figure 9.16 illustrates the values of y along with various values of x.
function res = FDM(xlim, y0,y1,n)
% y(i+1) - 2yi + y(i-1) + h^2 yi= h^2
% xlim: is the limit interval [a, b]
% y0, y1 are the boundary conditions at a, and b
% n is the number of elements in the final result
function [y, x] =ODEsolve(xlim, y0,y1,n)
 x = linspace(xlim(1), xlim(2), n)’;
 % stride
 h = x(2) - x(1);
 % The main diagonal has coefficients
 maind = [1;repmat(-2+h^2,n - 2,1);1];
 % The sub diagonals has coefficients
 subd = [repmat(1,n-2,1);0];
 % The super diagonals has coefficients
 supd = [0;repmat(1,n-2,1)];
 % The ODE matrix
 ODEmat = diag(maind) + diag(subd, -1) + diag(supd, 1);
 % create the right hand side for the solve:Boundary Value Problems of ODEs 301
FIGURE 9.16 Simulink-generated plot using the finite difference method represents the 
equation defined in Example 9.3.
 rhs = [y0;repmat(h^2, n-2,1);y1];
 % solve the matrixa a call to backslash
 y =ODEmat\rhs;
 end
[y, x] = ODEsolve(xlim, y0,y1,5);
res =y;
hold on;
plot(x, y, ‘-ro’)
plot(xlim(1), y0, ‘bo’)
plot(xlim(2), y1, ‘bo’)
grid on, xlabel(“x”), ylabel(“y”);
end
= [y0;repmat(h^2, n-2,1);y1];
Python Solution
The following results were generated by Python of the set of algebraic equations 
produced by the finite difference method:
[0.0 – 0.10467706 – 0.1403118 – 0.10467706 0.0]
The curve depicted in Figure 9.17 could be smoother if more grids were used 
(increase n). The python code is shown as follows:
import numpy as np
import matplotlib.pyplot as plt
plt.style.use(‘seaborn-poster’)
a=0
b=1
n = 4
h = (b-a) / n
# Matrix coefficient
A = np.zeros((n+1, n+1))302 Numerical Methods in Chemical Engineering Using Python® and Simulink®
FIGURE 9.17 Python solution using the finite difference method of the equation described 
in Example 9.3.
A[0, 0] = 1
A[n, n] = 1
# matrix coefficient
x = np.linspace(0, 1, n+1)
for i in range(1, n):
 A[i, i-1] = 1
 A[i, i] = h**2-2
 A[i, i+1] = 1
print(A)
x = np.linspace(0, 1, n+1)
b = np.zeros(n+1)
b[0]=0 # boundary conditon 1
for i in range(1, n):
 b[i] = h**2
b[n] = 0 # boundary condtion 2
print(b)
# solve the linear equations
y = np.linalg.solve(A, b)
plt.figure(figsize=(9,6))
plt.plot(x, y, ‘ro-’)
plt.plot(0,0,’bo’)
plt.plot(1, 0, ‘bo’)
plt.xlabel(‘x’)
plt.ylabel(‘y’, rotation=0)
plt.grid()
9.3.3 shootINg method for bvPs
In numerical analysis, the shooting method solves a BVP by reducing it to an IVP. 
Then we can solve it using the methods we learned in the previous chapters. The 
shooting method is iterative and can efficiently solve BVPs. The shooting method Boundary Value Problems of ODEs 303
FIGURE 9.18 Presentation of the shooting method principles.
converts a BVP into an equivalent IVP. Then, the IVP is solved via a trial-and-error 
approach. This technique is called a ‘shooting’ method, by analogy to the procedure 
of shooting an object at a stationary target (Figure 9.18). The following procedure is 
recommended to follow in solving a BVP using the shooting method:
 1. Start with a guess value for the auxiliary conditions at one point in time.
 2. Solve the IVP using the numerical integration methods, Euler, and Runge￾Kutta methods.
 3. Check if the BCs are satisfied, otherwise modify the guess, and resolve the 
problem.
 4. Use interpolation in updating the guess.
Example 9.4 Applying the Shooting Method for Heating Rod
Demonstrate the shooting method for the steady-state heat transfer in a rod fixed 
between two plates of differential temperatures. The rod is a length of 10 cm. The 
following second-order ODE describes the model equation.
d T2
= −0.05( ) 200 − T
dx 2
With the following BCs
T K ( ) 0 = = 200 , T K ( ) 10 400
Solve manually using Python and Simulink.304 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solution
 1. Apply the shooting method and divide second-order BVP into two IVPs. 
Let
dT
z = dx
It can be written as
dT = = z,  T ( ) 0 300
dx
 2. Take the first derivative of z; it will be dz d/ x
dz d T2
= = − − 0.05( ) 200 T z ,    ( ) 0 = guess dx dx 2
Applying the Euler method for solving the two initial value ODEs 
simultaneously.
T T i i +1 1 = + hf ( ) x Ti i , ,zi
z z i i +1 2 = + hf ( ) x Ti i , ,zi
The entire solution is described in Table 9.2.
Using excel and by utilizing the data/goal seek. The rest of the data can be 
found in Table 9.3.
Simulink Solution
The same data can be obtained using Simulink. Since we are using the Euler 
method, the solver in Simulink should be changed to a fixed value step size and 
the Euler method, as shown in Figure 9.19. Click on the modeling tab, then the set￾ting, then fill in the start, stop time, the type to fixed step, and for the solver, select 
Euler, and enter the step as stated in the problem statement.
Figure 9.20 shows the Simulink block diagram. The initial guess found by excel 
(−10.8232) is used for the same purpose as an initial guess for z integrator. The 
temperature profile is shown in Figure 9.21.
TABLE 9.2
Solution Using the Shooting Method of Equation Defined in Example 9.4
i x T z
0
1
2
3
0
1
2
3
300
300 + 1 * (–7) = 293
293 + 1 * (–2) = 291
–7 (Initial guess)
–7 + 1 * (–0.05 * (200–300) = –2
–2 + 1 * (–0.05 * (200–293) = 2.65
9 9
10 10 400 (Target)Boundary Value Problems of ODEs 305
TABLE 9.3
Solution of Two IVPs Simultaneously Using the Euler Method
i x T z
0 0 300.00 –10.82
1 1 289.18 –5.82
2 2 283.35 –1.36
3 3 281.99 2.80
4 4 284.79 6.90
5 5 291.70 11.14
6 6 302.84 15.73
7 7 318.56 20.87
8 8 339.43 26.80
9 9 366.23 33.77
10 10 400.00 42.08
FIGURE 9.19 Setting the Simulink solver to the Euler method and step size, h= 1.
Python Solution
The solution of Example 9.4 using Python is plotted as shown in Figure 9.22. A 
trial and error of the initial guess value of z are required. The shooting methods are 
developed to convert ODE BVPs into equivalent IVPs, and then we can solve them 
using the methods we learned from the previous chapter. In the IVPs, we can start 
from the initial value and move forward to get the solution.306 Numerical Methods in Chemical Engineering Using Python® and Simulink®
FIGURE 9.20 Represents the Simulink block diagram for solving the algebraic equations 
generated from the shooting method using the Euler method in Example 9.4.
FIGURE 9.21 Plot generated from the scope for the solution of the equation in Example 9.4.
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
x = np.linspace(0, 10, 100)
def equations(x, y):
 yprime = np.zeros(2)
 # Shooting method, desired equations
 yprime[0] = y[1]
 yprime[1] = -0.05*(200- y[0])
 return yprime
tol = 1e-6Boundary Value Problems of ODEs 307
FIGURE 9.22 Python solution of equation described in Example 9.4.
max_iters = 1000
low = -10
high = 10
count = 0
while count <= max_iters:
 count = count + 1
 xspan = (x[0], x[-1])
 # Set the initial condition
 y0 = [300, -13.24]
 # Solve the system using our guess
 sol = solve_ivp(equations, xspan, y0, t_eval = x)
 # Extract the function values from the solution object.
 y_num = sol.y[0, :]
 # Plot the solution
plt.plot(x, y_num, ‘b-’, label=‘Numeric’)
plt.plot([0, 10], [300,400], ‘ro’)
print(y_num[-1])
plt.grid(True)
plt.xlabel(‘x’, fontsize=24)
plt.ylabel(‘y’, fontsize=24,rotation=0)
plt.yticks(fontsize=16)
plt.xticks(fontsize=16)
plt.xlim((0,10))
plt.ylim((250,400))
Example 9.5 Applying the Shooting Method to Solve BVP
Use the shooting method and solve the following second-order BVP within the 
interval [1, 2].
d y2
2 = = 6x y ,   ( ) 1 2,   y( ) 2 9 = dx
Solve manually using Python, Simulink, and MATLAB308 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Solution
We will follow the following steps:
1. Convert the second-order ODE to a system of first-order ODEs.
2. Guess the initial conditions for the new ODE that are not available.
3. Solve the IVP.
4. Check if the known BCs are satisfied.
5. Modify the guess and resolve the problem again when needed.
First, we will convert the second-order ODE to two first-order ODEs IVPs, let
dy = = z y ,    ( ) 1 2
dx
dz = = 6x z ,    ( ) 1 2 ( ) Guess dx
Now we have two IVPs, and as a first approximation, we used the Euler method.
dy = = f x 1 ( ) , , y z z dx
dz = = f x 2 6
dx ( ) , , y z x
The initial conditions: x0 0 = = 1,  2 y z,  0 = 2(guess)
x1 0 = + x h = +1 0.5 = 1.5
We are implementing the Euler method for solving two ODEs simultaneously.
y y i i +1 1 = + hf ( ) x y i i , ,zi
z z i i +1 2 = + hf ( ) x y i i , ,zi
Substitute
xo o = = 1,  2 y z,  o = 2
y y 1 1 = +o hf ( ) 1,2,2 2 = + 0.5( ) 2 3 =
z z 1 2 = +o hf ( ) 1,2,2 2 = + 0.5( ) 6 1( ) = 5.
x y 1 1 = = 1.5,  3,  5 z1 =
y y 2 1 = + hf1 1 ( ) x y, , 1 1z y = +1 1f ( ) 1.5,3,5 = +3 0.5( ) 5 = 5.5
z z 2 1 = + hf2 1 ( ) x y, , 1 1z h = +5 f ( ) 1.5, 3, 6 = +5 0.5( ) 6( ) 1.5 = 9.5
It is better to be arranged in a table, as shown in Table 9.4.Boundary Value Problems of ODEs 309
TABLE 9.4
Assume z(0) = 0 as an Initial Guess
i xi yi zi
0 1 2 2
1 1.5 3 5
2 2.0 5.5 9.5
TABLE 9.5
Assume z0 = 5.5 as an Initial Guess
i xi yi zi
0 1.0 2.0 5.5
1 1.5 4.75 8.5
2 2.0 9.0 13.0
FIGURE 9.23 Solver setting of the configuration parameters page, for Example, 9.5 (Euler, 
fixed step size).
Since y( ) 2 = 5.5, the first trial initial guess ( 2 zo = ) is leading to not correct BC 
( 2 y( ) = 9). A second trial guess, zo = 5.5, based on this initial value guess for z, the 
results are listed in Table 9.5. The shooting method converged at y( ) 2 9 = .
Simulink Solution
First, from the modeling page in the toolbar, click on model/setting. Change the 
default setting of the configuration parameters. Set for the type: select fixed step; 
for the solver, select: mode1 (Euler) (Figure 9.23). The Simulink block diagram 
describing the solution of Example 9.5 is presented in Figure 9.24.310 Numerical Methods in Chemical Engineering Using Python® and Simulink®
FIGURE 9.24 Simulink block diagram using Euler and the desired fixed step size of the 
equations defined in Example 9.5.
Python Solution
A trial and error for the initial guess value of the hypothetical model equation in 
Example 9.5. The results are plotted in Figure 9.25. The shooting method reduces 
the BVP to the IVP. It is a common way to solve two-point BVPs.
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
x = np.linspace(1, 2, 100)
def equations(x, y):
 yprime = np.zeros(2)
 yprime[0] = y[1]
 yprime[1] = 6*x
return yprime
tol = 1e-6
max_iters = 100
low = -10
high = 10
count = 0
while count <= max_iters:
count = count + 1
xspan = (x[0], x[-1])
 # Set the initial condition vector to be passed into the solver
 y0 = [2, 2.9]
 # Solve the system using our guess
 sol = solve_ivp(equations, xspan, y0, t_eval = x)
 # For ease of use, extract the function values from the 
solution object.
 y_num = sol.y[0, :]Boundary Value Problems of ODEs 311
FIGURE 9.25 Python solution for equation defined in Example 9.5.
 # Plot the solution
plt.plot(x, y_num, ‘b-’)
plt.plot([1, 2], [2,9], ‘ro’)
print(y_num[-1])
plt.grid(True)
plt.xlabel(‘x’), plt.ylabel(‘y’)
plt.xlabel(‘x’, fontsize=24)
plt.ylabel(‘y’, fontsize=24,rotation=0)
plt.yticks(fontsize=20)
plt.xticks(fontsize=18)
plt.xlim((0.8,2.2))
plt.ylim((0,10))
Example 9.6 Applying the Shooting Method
Use the shooting method and the explicit Euler method to approximate the solu￾tion to the BVP:
d y2
2 = = 2y y ,   ( ) 0 1.2, y h ( ) 1 = = 0.9,    0.25 dx
Confirm the manual results with Python programming.
Solution
The basic idea of the shooting method is that we take the second-order ODE and 
write it as a system of the first-order ODE. Accordingly, split the second-order 
ODE BVP into two IVPs.
dy = =z f1 ( ) x y, ,z y ,   ( ) 0 = 1.2
dx
dz = = 2 , y f2 ( ) x y,z z ,   ( ) 0 = guess dx312 Numerical Methods in Chemical Engineering Using Python® and Simulink®
Using the Euler method and h = 0.25,
At x = 0.25
y y 1 0 = + 0.25 f1 ( ) 0,1.2,−1.0834
y1 = − 1.2 0.25 × −( ) 1.0834 = 0.929
z z 1 2 = +o 0.25 f ( ) 0,1.2,−1.0834
z1 = −1.0834 + × 0.25 ( ) 2 × = 1.2 −0.4834
The rest of the values are listed in Table 9.6.
Python Solution
Figure 9.26 displays the results of a trial and error for the hypothetical ODE.
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
x = np.linspace(0, 1, 4)
def equations(x, y):
 yprime = np.zeros(2)
 # the desired ODE(BVP) d2y/dx2=2y, dy/dx=z, dz/dx = 2y
 yprime[0] = y[1]
 yprime[1] = 2*y[0]
 return yprime
tol = 1e-6
max_iters = 100
low = -10
high = 10
count = 0
while count <= max_iters:
 count = count + 1
 xspan = (x[0], x[-1])
 # Set the initial condition vector to be passed into the solver
 y0 = [1.2,-1.25]
 # Solve the system using our guess
 sol = solve_ivp(equations, xspan, y0, t_eval = x)
TABLE 9.6
Solution Using Shooting and Euler’s Methods of the 
Equations Defined in Example 9.6
i xi y z
0 0 1.2 –1.0834
1 0.25 0.92915 –0.4834
2 0.5 0.8083 –0.01883
3 0.75 0.803594 0.385325
4 1 0.899925 0.787122Boundary Value Problems of ODEs 313
FIGURE 9.26 A trial-and-error solution of Example 9.6 using python.
# For ease of use, extract the function values from the solution 
object.
y_num = sol.y[0, :]
# Plot the solution
plt.plot(x, y_num, ‘ro-’, label=‘Numeric’)
plt.plot (0,1.2, ‘bo’), plt.plot(1,0.9, ‘bo’)
print(y_num[-1])
plt.grid(True)
plt.xlabel(‘x’), plt.ylabel(‘y’)
plt.xlabel(‘x’, fontsize=24)
plt.ylabel(‘y’, fontsize=24,rotation=0)
plt.yticks(fontsize=20)
plt.xticks(fontsize=18)
plt.xlim((0,1.2))
plt.ylim((0.7,1.3))
In the following solution, the initial guess of the z value is determined by Python 
without the initial guess trial-and-error solution (Figure 9.27).
from scipy.integrate import solve_bvp
import numpy as np
import matplotlib.pyplot as plt
# Solve the BVP of differential equations
# d2y/dx2 = 2y, y(0)=1.2 y(1)=0.9
def dydx(x, y):
 dy0 = y[1]
 dy1 = 2*y[0]
 return np.vstack((dy0, dy1))
# Calculation The boundary conditions
def boundCond(ya, yb):
 # The boundary conditions y(xa=0) = 1.2, y(xb=1) = 0.9
 fa = 1.2
 fb = 0.9
 return np.array([ya[0]-fa, yb[0]-fb])
# Indepedent variables, points (xa, xb)314 Numerical Methods in Chemical Engineering Using Python® and Simulink®
FIGURE 9.27 Python solution where the function found the initial guess.
xa, xb = 0, 1
xini = np.linspace(xa, xb, 11) # determine x Initial value of
yini = np.zeros((2, xini.size)) # determine y Initial value of
res = solve_bvp(dydx, boundCond, xini, yini) # solve BVP
xSol = np.linspace(xa, xb, 100) # Output mesh node
ySol = res.sol(xSol)[0] # At mesh nodes y value
# plot section
plt.plot(xSol, ySol, ‘r-’)
plt.plot(0,1.2, ‘bo’)
plt.plot(1, 0.9, ‘bo’)
plt.grid()
plt.xlabel(‘x’, fontsize=24)
plt.ylabel(‘y’, fontsize=24,rotation=0)
plt.yticks(fontsize=20)
plt.xticks(fontsize=18)
plt.xlim((-0.05,1.1))
plt.ylim((0.7,1.3))
9.4 SUMMARY
This chapter discusses the numerical solution of ODEs and BVPs. The BVPs specify 
the value of the dependent variable at the boundaries. Use strategies for IVPs to solve 
BVPs. The shooting method requires guessing an initial condition that substitutes for 
a BC and iterates to find the proper solution.
9.5 PROBLEMS
1. Solve the following BVP using the shooting method; after splitting the equa￾tion, use the explicit Euler method (step size, h= 1) to perform the numerical 
integration of the two IVPs simultaneously.
d y2
2 = − 2 8 y x + = 72,  y y ( ) 0 0,  ( ) 9 0 = dxBoundary Value Problems of ODEs 315
 2. Use the shooting method to solve the following BVP
d y
Use the step size 
3. Consider the following BVP 
d y
Solve it using the shooting method and perform the numerical integration 
4. Solve the following BVP using the finite difference method 
d y
Answer: 2 3 0.5701, 
d y
With the following BCs and step size, 
y y
Answer: 
6. Solve the following BVP using find difference approximation by dividing 
d y
Answer: 
7. Solve the following BVP using the shooting method; use any method to 
d y316 Numerical Methods in Chemical Engineering Using Python® and Simulink®
 8. Use the shooting method to solve
2
With the BCs, 
( ) 10
9. Use the shooting method to solve the following BVP with the Euler method, 
7 0
The BCs are
T
 10. Solve the following BVP using the shooting method. Split BVP into two 
2 0
The BCs are
y y
REFERENCES
 1. Ascher, U.M., Mattheij, R.M., and Russell, R.D., 1995, Classics in Applied Mathematics, 
Numerical Solution of Boundary Value Problems for Ordinary Differential Equations. 
Philadelphia: Society for Industrial and Applied Mathematics.
 2. Polyanin, A.D., and Zaitsev, V.F., 2003, Handbook of Exact Solutions for Ordinary 
Differential Equations. Boca Raton: Chapman & Hall/CRC Press.317
Appendix A
Python Programming Code
A.1 WHY IS PYTHON FAMOUS AND ESSENTIAL?
It is a universal programming language that is easy and simple to learn and use 
in multiple fields. For example, web development, data analytics, data engineering, 
data science, machine learning, and artificial intelligence. Therefore, the wide use 
of Python gained popularity in all fields, and users preferred it over other program￾ming languages. Unlike other programming languages, Python does not require a 
compiler (translator) that changes the program into a form the machine understands. 
Worldwide compatibility is essential, which makes integrating folders and utilizing a 
single language in different fields very beneficial.
A.2 INTRODUCTION
There are several rules that programmers follow in writing programming codes. The 
list of rules are as follows:
 1. Aim for a smaller number of code lines; if 10 lines can do the same task as 
20 lines, then why the extra complexity and lines of code to run?
 2. Aim for simpler code; program codes should be easily read and understood 
by different programmers since different programmers could work on the 
same code.
 3. Aim for explicit rather than implicit code; the code should be clearly and 
fully expressed, leaving nothing implied.
 4. Aim for flat code rather than nested code; for example, in the ‘if’ function, 
it is better to keep the code flat than nested, and the line’s starting point 
keeps getting further and further.
 5. Aim for sparse lines of code; having dense code is not favorable, and a 
straightforward sparse program is easier to work with.
 6. Aim for readability; take into consideration other programmers working 
on the same code.
Writing Python code with these guidelines in mind will help the programmer’s code 
to be more efficient, simpler, easier to understand, and require less computational 
time.318 Appendix A
A.3 SETTING UP
In this book, the program Spyder is used to write the code. Spyder is a free and open￾source tool that is written in Python to run Python codes. It features an interactive 
user interface and beautiful visualization capabilities. Spyder has several compo￾nents and can be updated with any plugin, thus increasing the possibility of adding 
more functions to the program. Spyder is available for Windows, MacOS, and Linux 
for free. The latest version of Python is 3.9.5, released on May 3, 2021.
In this book, Spyder is employed to write Python programs. Spyder is a powerful 
Interactive Development Environment (or IDE) for the Python programming lan￾guage. Figure A.1 shows the Spyder user interface.
To check for the current Python version on windows as an example, a simple code 
is used:
import sys
print(“User Current Version:-”, sys.version)
That results in the following as an example:
User Current Version:-3.7.13 (default, Apr 24 2022, 01:04:09)
[GCC 7.5.0]
After setting up the program and learning the rules of coding, the basics of Python 
can be introduced. In every programming language, the first function taught is 
responsible for displaying “Hello world!” on the screen. This can be easily done in 
Python with one line of code as follows:
print(“Hello world!”)
FIGURE A.1 Spyder interactive development environment for Python.Appendix A 319
When running the code, you should see the following output:
Hello world!
As can be seen from the results, the parentheses are not displayed but are required 
when writing the code to indicate what is the required text. When the editor reads the 
function print, it will display whatever is inside the parenthesis. Getting started with 
Python a basic function is taught at first, the ‘print’ function. The print function can 
be used in any place where a message is to be displaced.
In writing comments:
‘#’ hashtag is used to indicate the start of a comment.
If a comment stretches over many lines:’’ is written at the start, then ’’’ indicates 
the comment end, and those lines will not be executed when command is run.
A.4 PART 1: PYTHON BASICS
Several expressions in mathematics are used in Python as follows:
‘+ – * /’ represent addition, subtraction, multiplication, division, respectively.
Example:
#in writing multiple lines of math, print function is required
print(4+5) #Addition
print(4+4*2) #Python follows precedence order when execusion
print(36/4) #Example of division
print(36/4+9/3+2*2) #Example on precedence (solves left to right)
#Results:
9
12
9.0
16.0
‘%’ represents the remainder
Example:
101%10 #finding the remainder from 101 using 10
#Results:
1 #the solution is 1
Python deals with integers and real numbers.
Example:
print(1.123) #real number with multiple digits
print(3/2) #operator results a real number
print(-1.123) #positive and negative values are possible
#Results:
1.123
1.5
-1.123320 Appendix A
Other mathematical functions are also present in Python, but to activate them, the 
math class must be imported into the Python code. The functions can then be used 
as follows:
from math import * #to import class
print(cos(90)) #to solve cosine value in radians
print(pi) #pi represent pi value of a circle
print(e) #e represent euler’s number
#Results:
-0.4480736161291701
3.141592653589793
2.718281828459045
There are other mathematical functions in Python, as shown in the following table.
Command Name Description
Cos (value) cosine, angle unit in radians
Sin (value) sine, angle in radians
Log (value) Logarithm, with base value of e
log[] (value) Logarithm, with base value of []
Max (value1, value2) Finds maximum value
Min (value1, value2) Finds minimum value
Int (value) Converts value into an integer
Float (value) Converts value into a floating number
Abs (value) Outputs absolute value
Round (value) Outputs number to the nearest whole number
Sqrt (value) Square root
Python can store variables and assign a specific value to them as follows:
x = 2 #defining variable x
y = 2 #defining variable y
z = ‘hey’ #variable can be defined as string
#variables can be utilized in anyway possible
print(x+y)
print(x*y)
print(x/y)
print(z)
#Results:
4
4
1.0
Hey
An important function of coding is the ability to input information; this can be done 
with ‘input’ function. When ‘input’ function is used with text, the text is displayed, 
and the program waits for an input from the user to continue. An example utilizing 
‘input’ function is as follows:Appendix A 321
age = input(“How old are you:“) #input function to assign to 
varibale
print(‘Your age is ‘, age) #adding coma then variable displays it
print(‘You were born on ‘, 2022 - int(age)) #variable is defined 
as integer to allow for substraction
#Results:
How old are you: 24
Your age is 24
You were born on 1998
A.5 PART 2: IF FUNCTION
The ‘if’ function executes a group of functions only if the condition is true, as 
follows:
a = input(‘Input the GPA value: ‘) #Ask for input
if float(a) > 3.6: #input in Python is always regarded as string, 
thus must be identified as number
 print(“You have excellent academic standing”) #solution for if 
function
#Results
Input the GPA value: 3.67
You have excellent academic standing
The if function can be extended and other conditions can be added with ‘elif’ func￾tion, which stands for ‘else if’, and if the input doesn’t follow any condition, a ‘else’ 
function is added. The previous example can be extended as follows:
a = input(‘Input the GPA value: ‘) #Ask for input
if float(a) >= 3.6: #input in Python is always regarded as 
string, thus must be identified as number
 print(“You have excellent academic standing”) #solution for if 
function
elif float(a) >= 3.0:
 print(“You have good academic standing”) #pay attention to tabs
elif float(a) >= 2.5:
 print(“You have acceptable academic standing”)
else:
print(“You have bad academic standing”)
#Answer 1
Input the GPA value: 3.8
You have excellent academic standing
#Answer 2
Input the GPA value: 3.5
You have good academic standing
#Answer 3
Input the GPA value: 2.8
You have acceptable academic standing
#Answer 4
Input the GPA value: 2
You have bad academic standing322 Appendix A
Another example utilizing if, elif, and else functions is shown:
married = input(‘Are you married (Y/N):‘) #Question
if married == ‘Y’: #== indicate ‘is it equal’
 print(“Congratulations”) #shows results
elif married == ‘N’: #elif stands for else if
 print(“Good luck”) #shows results
else: print(“False input”) #ways to fail a program is always 
sought, thus must be considered
#Answering with ‘Y’
Are you married (Y/N): Y
Congratulations
#Answering with ‘N’
Are you married (Y/N): N
Good luck
#Answering with other
Are you married (Y/N): g
False input
a.5.1 for looP
In terms of loops, the ‘for’ repeats a set of statements over a group of values speci￾fied. A variable name gives a value to each repetition to keep track of progress. The 
group of values can be a range of integers using the ‘range’ function.
for x in range(6):
 print(x)
#Results:
0
1
2
3
4
5 #The values start from 0 and don’t end at 6 but at 5, but the 
total number of results are 6
The ‘for’ loop statements can be saved with every repetition, as follows:
a = 0
for x in range(6):
 a = a+x
 print(x)
print(a)
#Results:
0
1
2
3
4
5
15 #The sum of all x values
Another loop used in Python is the ‘while’ loop, which executes a group of state￾ments while the condition remains true and only stops when the condition is false. 
An example is as follows:Appendix A 323
x = 1
while x < 100: #condition
 x = x*2
 print(x)
#Results:
2
4
8
16
32
64
128 #statements are run until condition is false
There are several logical expressions to be used with ‘if’ statements and loops and 
are shown in the following table:
Logical Expression Meaning
== Is it equal
!= Is not equal
< Less than
<= Less than or equal
> More than
>= More than or equal
Combining the logical expressions with other operators can be very useful. 
Examples of operators are shown in the following table:
Operator Meaning
and Combines conditions and all have to be true
or Anyone of the conditions can be true
not Outputs ‘True’ if the expression is false
Loops can go forever, therefore loop controls are needed. Loop controls are shown 
in the following table:
Function Meaning
break Terminates the loop
continue Ends the current iteration and moves forward
pass Used as placeholder for future code324 Appendix A
A.6 PART 3: DATA TYPES
Data type is a property of the object, not the variable. When inputting a value into a 
variable, Python always treats it as a string (text). Therefore, clarification is required 
to identify each variable. To do this, there are several data types and functions that 
can be used. The following table shows several functions, operators, and symbols 
used in Python.
Operator Meaning
int(x) Converts x into an integer
float(x) Converts x into a floating number
xEy E is the mathematical × 10y
x ** y ** is the exponential
J Complex number
Complex number can be used in Python using ‘j’ to identify the complex number 
and value of −1. An example of complex number as follows:
x = 1+2j
z = 2j
sum = x + z
print(sum)
#Results
(1+4j) #complex numbers are added
a.6.1 strINgs
When defining a variable as a string, it can still use ‘+’ operator, as follows:
x = ‘Hello’ #defining as a string
y = ‘How are you’
z = x + ‘,‘ + y #adding variables
print(z) #print function
#Results:
Hello, How are you
A print function could be across several lines by using three quotes as follows:
print(“‘Hello
My name is Nayef
It is nice to meet you”‘)
#Results
Hello
My name is Nayef
It is nice to meet youAppendix A 325
In a string, each character is numbered starting from zero. This is shown in the 
following examples.
Example 1:
x = “Apple”
for y in range(7):
 print(x[y])
#Results
A
P
P
L
e
Example 2:
x = “0123456789”
print(x[0]) #starts from 0
print(x[1]) #1 is the second character in the string
print(x[1:4]) #1, 2, and 3 are included
print(x[6:10])
#Results
0
1
123
6789
There are function used with strings in Python as shown in the following table:
Operator Meaning
len(string) Shows the number of characters in a string
str(string) Identifies the variable as a string
The functions are shown in an example as follows:
x = “0123456789”
y = “CRC press”
z = 5
print(len(x)) #len shows number of characters
print(len(y))
c = z + 4
print(c) #to prove c is treated as a number
p = str(z) + ‘ ‘ + x #str treats a variable as a string
print(p)
#Results
10
9
9
5 0123456789326 Appendix A
When writing a print function, the ‘%’ operator can be used to include either a 
number or a specific string. The following example illustrates the point.
x = 1
y = ‘One’
print(“One is %d” %x)
print(“1 is %s” %y)
#However writing the code as follows is wrong
#print(“1 is %d” %y) #output an error
#Results
One is 1
1 is One
Types for data collection
There are three types of data collection.
First, a ‘list’ with an ordered set of data
list = [“Name1”, “Name2”, “Name3”] #[] brackets are used
print(list[0])
print(list[1])
print(list[2])
#Results
Name1
Name2
Name3
Second, a ‘set’ with unordered data
set = {“Name1”, “Name2”, “Name3”, “Name4”, “Name5”} #More names 
are added to show randomness
print(set)
#Results
{‘Name3’, ‘Name1’, ‘Name2’, ‘Name5’, ‘Name4’}
Third, a ‘dictionary’ with a pair of values stored
dictionary = {
 “Company”: “Toyota”,
 “Model”: “Camry”,
 “Year”: “2022”,
 “Color”: “Black”
}
print(dictionary)
print(dictionary[“Company”])
print(dictionary[“Model”])
print(dictionary[“Year”])
print(dictionary[“Color”])
#Results
{‘Company’: ‘Toyota’, ‘Model’: ‘Camry’, ‘Year’: ‘2022’
‘Color’: ‘Black’}
Toyota
Camry
2022
Black
, Appendix A 327
There are several functions in a list as shown in the following table:
In dictionaries, addition can be done in the code as shown in the following 
example.
dic = {
“One”: “1”,
“Two”: “2”,
“Three”: “3”,
“Four”: “90”, #written wrong intentially
“Five”: “5”,
“Six”: “6”,
“Seven”: “7”,
“Eight”: “8”,
“Nine”: “9”,
}
print(dic[“Four”])
dic[“Four”] = 4 #values can be set
print(dic[“Four”])
dic[“Ten”] = 10 #values can be added
print(dic)
del(dic[“One”]) #del deletes an element
print(dic)
#Results
90
4
{‘One’:‘1’, ‘Two’:‘2’, ‘Three’:‘3’, ‘Four’:4, ‘Five’:‘5’, 
‘Six’:‘6’, ‘Seven’:‘7’, ‘Eight’:‘8’, ‘Nine’:‘9’, ‘Ten’:10}
{‘Two’: ‘2’, ‘Three’: ‘3’, ‘Four’: 4,‘Five’: ‘5’,‘Six’: ‘6’, 
‘Seven’: ‘7’,‘Eight’: ‘8’, ‘Nine’: ‘9’, ‘Ten’: 10}
Loops can be used in dictionaries as follows:
CarColors = {
“Togg”: “Red”,
“Camry”: “Black”,
“Tesla”: “White”,
“Hyundai”: “Silver”,
“Mercedes”: “Gold”,
“BMW”: “Blue”,
}
List Function Meaning
list.append(x) Add x item at the end of the list
list.insert(i, x) Inserts an x item at the i position
list.remove(x) Removes x value item from the list
list.pop(i) Removes the item at position i and returns it
list.index(x) Shows the index in first item with value x
list.count(x) Shows the number of x appears in the list
list.sort() Sorts items in ascending order
list.reverse() Reverses items in the list328 Appendix A
for k in CarColors.keys():
 print(k, “: “, CarColors[k])
#Results
Togg: Red
Camry: Black
Tesla: White
Hyundai: Silver
Mercedes: Gold
BMW: Blue
Lists and dictionaries can be copied. For a list, the function ‘list’ is used to copy 
e.i. I2 = list(I1). For copying the dictionary, the function ‘list.copy()’ is used.
A.7 PART 4: FUNCTIONS
To create a function in Python, it is defined as ‘def’. First, the function is defined then 
can be called whenever, as follows:
def test(): #defining a function
 print(“This is a function test”) #part of the function
print(“To show space”)
test() #calling a function
#Results
To show space
This is a function test
Functions are objects that can be assigned to a variable, as a parameter, and returned 
from a function. Functions require the () after them, and this is what distinguishes 
them from variables.
def names(name):
 print(“Hello “ + name)
names(“Name1”)
names(“Name2”)
names(“Name3”)
#Results
Hello Name1
Hello Name2
Hello Name3
Difference between parameters and arguments. A parameter is a variable listed inside 
the parentheses in the function definition. While an argument is the value that is sent 
to the function when it is called. A function can have two arguments, as follows
def APA(author,year):
 print(“(“ + author + “,“ + year +“) ”)
APA(“Name1”, “2022”)
APA(“Name2”, “2020”)
#Results
(Name1, 2022)
(Name2, 2020)Appendix A 329
If the number of arguments is unknown, add ‘*’ before the parameter name. 
Example as follows:
def kids(*names):
 print(“The youngest child is “ + names[2])
kids(“OLd”, “Middle”, “Youngest”)
#Results
The youngest child is Youngest
Assigning values to the function is also possible as follows:
def kids(name1, name2, name3):
 print(“The youngest child is “ + name3)
kids(name1 = “Name1”, name2 = “Name2”, name3 = “Name3”)
#Results
The youngest child is Name3


 
 






330 Appendix A
#Results
 Hello\
 Hello Hey
 Hello
N
 Hello “
Characters in a string are numbered with indexes starting from 0, as follows:
Name = “Mohamed”
Index 0 1 2 3 4 5 6 7
Character M o h a m e d “Space”
As can be seen in the following example.
name = “Mohamed“
print(name[0])
print(name[1])
print(name[2])
print(name[3])
print(name[4])
print(name[5])
print(name[6])
print(name[7])
#Results
M
o
h
a
m
e
d
When outputting a string, it can be manipulated with different functions. Several 
functions are shown in the following table.
Function Meaning
capitalize Capitalizes the first word
center Centers a string
casefold Makes all lowercase
count(‘x’) Counts how many “x”
endswith(“x”) Checks if ends with x
find(“x”) True or false if string ends with x
upper Makes all characters upper case
lower Makes all characters lower case
The following uses each function in an example.
text = “python is a great language to learn” #all lowercase
name = “my name is Nayef ghasem” #all lowercaseAppendix A 331
mssg = “HOW ARE YOU” #all caps
print(text.capitalize()) #capitalizes the first word
print(mssg.center(36, ‘*’)) #centers a string
print(mssg.casefold()) #makes lowercase
print(mssg.count(“O”))
print(mssg.count(“o”)) #upper and lower case sensitive
print(mssg.endswith(“?”)) #checks if ends with specified string
print(name.find(“Nayef”)) #outputs first index value of the 
searched string
print(name.upper()) #all uppercase
print(name.lower()) #all lowercase
#Results
Python is a great language to learn
************HOW ARE YOU*************
how are you
2
0
False
11
MY NAME IS NAYEF GHASEM
my name is nayef ghasem
For loops can be used in strings as follows:
for x in “Tesla”:
 print(x)
#Results
T
e
s
l
a
In Python, characters map to numbers using standardized mappings such as ASCII 
and Unicode. Therefore, every string character has a number as in the following 
example:
alp = “abcdxyz”
for x in alp:
 print(x)
 print(ord(x))
#Results
a
97
b
98
c
99
d
100
x
120
y
121
z
122332 Appendix A
This method is reversable, as a number can be converted into a string, as follows:
a = 97
b = 98
c = 99
print(chr(a))
print(chr(b))
print(chr(c))
#Results
a
b
c
A.9 PART 6: OBJECTS AND CLASSES
Python is an object-oriented programming language, and almost everything in 
Python is an object, with its own properties and methods. A class in Python is like an 
object constructor, or a “blueprint” for creating objects.
To create a class the code is written as follows:
#class Name:
 #statements
class myclass:
 a = 1
 b = 2
 c = 3
T = myclass() #variable linked to class
print(T.a) #anything can be called from class
print(T.b)
print(T.c)
#Results
1
2
3
Using the link and call method, people can create classes and share them with differ￾ent people. A class might sound similar to a module, but the difference is that a class 
is used to define a blueprint for a given object, whereas a module is used to reuse a 
given piece of code inside another program.
The __init__() function:
All classes have a function called __init__(), which is always executed when the 
class is being initiated. An example of the init function is as follows: 
class information:
 def __init__(self, name, age): #the self reference is needed
 self.name = name
 self.age = age
T = information(“Name1”,24)
print(T.name)
print(T.age)
#Results
Name1
24Appendix A 333
A.10 OBJECT METHODS
Objects can also contain methods (functions that belong to the object), as shown in 
the following example:
class information:
 def __init__(self, name, age):
 self.name = name
 self.age = age
 def myfunc(self):
 print(“I am “+ self.name + “\n Nice to meet you.”) #works with 
strings
T = information(“Mohamed”, 24)
T.myfunc()
#Results
I am Mohamed
Nice to meet you.
The “self” is used in the examples, but it can be anything specified by the user. The 
objective of the first variable is to reference the current instance of the class. As can 
be seen in the following example:
class information:
 def __init__(anything, name, age):
 anything.name = name
 anything.age = age
 def myfunc(anything):
 print(“Hello “+ anything.name + “\n Nice to meet you.”) 
#works with strings
T = information(“John”,63)
T.myfunc()
#Results
Hello John
Nice to meet you.
Modifications can be done to the class, and there are three main operators as shown 
in the following example.
class information:
 def __init__(anything, name1, name2, name3):
 anything.name1 = name1
 anything.name2 = name2
 anything.name3 = name3
 def first(anything):
 print(“I am “+ anything.name1)
 def second(anything):
 print(“I am “+ anything.name2)
 def third(anything):
 print(“I am “+ anything.name3)
list = [“Name1”, “Name2”, “Name3”]
T = information(‘name1’, ‘name2’, ‘name3’)334 Appendix A
name1 = list[0]
name2 = list[1]
name3 = list[2]
T.first()
T.second()
T.third()
T.name2 = “NMG” #things can be assigned
T.second()
#del T.name1 can be used to delete
#Results
I am Name1
I am Name2
I am Name3
I am NMG
In classes, the user can define any function so that Python’s built-in operators can 
also be utilized.
Operator Class Method
– __neg__(self, cont), or __neg__(self)
+ __pos__(self, cont), or __pos__(self)
* __mul__(self, cont)
/ __truediv__(self, cont)
== __eq__(self, cont)
!= __ne__(self, cont)
< __lt__(self, cont)
> __gt__(self, cont)
<= __le__(self, cont)
>= __ge__(self, cont)
A.11 CONCLUSION
Appendix A introduced Python, starting from setting up the program to explaining 
all the functions used in Python. Each function method of working is explained, and 
examples are provided to show actual results. The objective is to explain the main 
functions possible, but this information can be used and extended to no boundaries. 
This provides foundations, but there is no limit set for the users and their creativity 
and applications.335
Appendix B
Introduction to Simulink
Simulink is a graphical extension to MATLAB for the modeling and simulation of 
systems. The system is drawn as a block diagram. Simulink is a software package that 
models and simulates a dynamic system whose output changes over time. Simulink 
is integrated with MATLAB, and the data can be easily transferred between the 
programs.
This appendix is written to introduce a tutorial for learners without prior experi￾ence with Simulink. In this appendix, we will apply Simulink to solve system model 
equations. Lines transmit signals in the direction indicated by the arrow, and lines 
must be combined using a block such as a summing junction.
There are several general classes of blocks:
 1. Sources, such as Ramp, Random Generator, Step
 2. Sink: Used to output or display signals
 3. Discrete: Transfer functions, state space
 4. Linear: summing, gains
 5. Nonlinear: arbitrary functions, delay
 6. Connections: Multiplexer, Mux.
 7. Continuous and discrete dynamics blocks include Integrator, Transfer, and 
Transport Delay functions.
 8. Math blocks: Sum and Product, and Add block.
First, start MATLAB (Figure B.1).
Individuals can start Simulink in two ways:
1. Click the Simulink icon on the MATLAB toolbar.
2. Enter the ‘>>Simulink’ Command at the MATLAB prompt. 
Starting Simulink displays the Simulink Library Browser (Figure B.2).
Click on the ‘Blank Model’ displays the Simulink Library Browser (Figure B.3).
Click on ‘Library Browser’ displays the Simulink Library Browser. The library 
Browser displays a tree-structured view of the Simulink block libraries installed on 
your system. One can build models by copying blocks from the library browser into 
a model window. The Simulink commonly used blocks (Figure B.3) contain the most 
frequently used Simulink block functions (Figure B.4).
The library lists the available ‘continuous’ function blocks (Figure B.5). The 
blocks are the most used in numerical methods and most often used are the transfer 
function (Transfer Fcn) and the ‘State-Space’.336 Appendix B
FIGURE B.3 Simulink untitled new file.
FIGURE B.2 Simulink start page.
FIGURE B.1 MATLAB start window.Appendix B 337
The Sources icon yields the library shown in Figure B.6. The most used source is 
‘Clock’, which is used to generate a time vector.
The ‘Sinks’ icons are shown in Figure B.7. The ‘Scope’ is the most common block 
used for plotting signals from a specific variable in the Simulink block diagram.
The Math library contains math functions block (Figure B.8).
FIGURE B.5 The available Simulink ‘continuous’ function blocks.
FIGURE B.4 Simulink commonly used blocks.338 Appendix B
FIGURE B.8 Math operations library.
FIGURE B.7 Simulink ‘sinks’ library.
FIGURE B.6 Simulink ‘sources’ library.Appendix B 339
Example B.1 Convert Celsius (oC) to Fahrenheit (oF)
Model the following algebraic equation using Simulink:
T T C F = − ( ) 32 / 1.8
Solution
 1. To create a new model, start MATLAB, click on Simulink, then Blank 
Model.
 2. Click the New button in the library browser toolbar. Simulink opens a 
new model window (Figures B.9 and B.10).
 3. Click on the Library Browser button.
To create this model, you need to drag and drop the blocks into the model from 
the following Simulink block libraries:
 1. Constant block to define a constant of thirty-two (32), copy from the 
Sources Library.
 2. Gain block to multiply the input spinal by 1.8 from the Math library.
 3. Sum block to add the two quantities, also from the Math library.
 4. Scope block to display the output from the Sinks library.
Next, gather the blocks into the model window (Figure B.11)
FIGURE B.9 New untitled blank page of Simulink file.340 Appendix B
FIGURE B.11 Simulink solution of Example B1.
FIGURE B.10 Commonly used blocks.Appendix B 341
FIGURE B.12 Simulink solution of linear order differential equation model.
Example B.2 Solving Single ODE
Solve the linear first-order differential equation:
dy 2
= +y t 2
,  y( ) 1 1 = dt t
Solution
The equation is solved using Simulink as follows:
Figure B.12 shows the model of this Example. By running the simulation, we 
obtained the numerical solution as well as the exact solution ( ) y t = 3 . The model 
time interval should start from 1, as the initial condition is y(1) = 1. To do that, while 
on the server, select the start time to 1, not zero. To perform better clipper.
Modeling/Model setting
Set the value of the Start Time: 1342 Appendix B
Example B.3 Solve the Linear Algebraic Equation
Solve the following algebraic equations using Simulink:
2 2 x y + − z = 3
x y − − z = 0
x y + + 3 1 z = 2
Solution
The problem can be arranged in matrix form as follows:
AX = B
 2 1 −2   x   3 
    1 1   − −1 y = 0        1 1 3  
 z     12 

Rearranging to prepare it for Simulink solution, such as AX − = B 0
 2 1 −2   x   3 
 1 1− −1    y  − 0  = 0       1 1 3  z         12 
Simulink Solution
Open the new Simulink page and select the blocks shown in Figure B.13.
Select the gain, double click, and input the matrix in the Gain windows 
(Figure B.14).
[2 1-2; 1-1-1; 1 1 3]
Multiplication: Matrix(K*u) (u vector)
Select constant, double click, and enter the constant as shown in Figure B.15.
Example B.4 Solving First-Order Differential Equation
Solve the first-order differential equation in MATLAB Simulink:
dy 1 3
= + 2 y ,  y( ) 1 2 = − dt t t
Build the Simulink block diagram and run it for the range of 1–4 seconds 
(Figure B.16).Appendix B 343
Solution
Set the modeling simulation period between 0 and 4. The setting of the configura￾tion parameters can be modified through MODELING/Model setting (Figures B.17 
and B.18).
FIGURE B.14 Matrix coefficient and multiplication (u vector).
FIGURE B.13 Solution of the matrix of Example B.3.344 Appendix B
FIGURE B.16 Simulink block diagram a solution to Example B.4.
FIGURE B.15 Matrix constant coefficient.Appendix B 345
FIGURE B.18 Plot of y versus time.
FIGURE B.17 Changing the start of the simulation time.346 Appendix B
Example B.5 Solving Second-Order Differential Equation
Solve the following second order differential equation using Simulink:
d y2 dy 2 + + 3 40 0 y = dt dt
Using the following initial conditions,
dy 1
y( ) 0 1 = = , 0( ) dt 3
Simulink Solution
Rearrange the second-order ODE such that the term with the highest order on the 
left side equals the rest of the terms.
d y2 dy 2 = −3 4 − 0y dt dt
The initial conditions are 1 and 1/3 (Figure B.19).
The plot is shown in Figure B.20.
The default scope background color is black, as shown in Figure B.21.
FIGURE B.19 Simulink solution of the second order ODE of Example B.4.Appendix B 347
FIGURE B.21 Changing of scope background and color using view/style.
FIGURE B.20 Plot of y versus time.348 Appendix B
Example B.6 Solving High-Order Polynomial Equation Using Simulink
Solve the following polynomial algebraic equation using Simulink:
5x x 6 4 + − 4 5x3 = 10
Solution
Rearrange the equation so that the right-hand side is zero.
5x x 6 4 + − 4 5x3 − = 10 0
Substituting the initial guess to 0.0 gives the root 0–0.96.
Setting the initial guess to 1.0 gives a root of 1.135 (Figure B.22).
Example B.7 Solving Simultaneous Equations Using Simulink
Solve the following algebraic equation simultaneously using Simulink:
5x y + − 4 5z = −  5
3 8 x y − + 2 1 z = 0
7 4 x y − − z = −14
FIGURE B.22 Simulink solution of the polynomial equation presented in Example B.6.Appendix B 349
Solution
Rearrange the equation so that the right-hand side is zero.
545 x y + − z + = 5  0
3 8 x y − + 2 1 z − = 0 0
7 4 x y − − z + = 14  0
The solution of the set of algabriac equations are solved in Figure B.23.
An alternative way is to put it in Matrix form is as follows:
AX − = B 0
545 x y + − z + = 5  0
3 8 x y − + 2 1 z − = 0 0
7 4 x y − − z + = 14  0
 5 4 −5   x   −5 
  3 8− 2   y  − 10  = 0        14      7 4− −1   z   −  
FIGURE B.23 Simulink solution of Example B.7.350 Appendix B
FIGURE B.24 Simulink alternative solution of the algebraic equations defined in Example 
B.7.
The more straightforward solution and using the matrix structure, the Simulink 
block diagram of Example B.7 is represented in Figure B.24.
Example B.8 Solving Simple Polynomial Using Simulink
Solve the single homogeneous polynomial equation using Simulink:
x 2 − −x 2 0 =
Solution
Using the Simulink Algebraic Constraint function, one of the roots is found (-1), as 
shown in Figure B.25.
Example B.9 S olving Simple Polynomial with Sin 
and Cos Using Simulink
Solve the single homogeneous polynomial equation using Simulink:
3 5 x x 3 + − sin 7 ( ) cos 2( ) x = 0Appendix B 351
Solution
Figure B.26 shows the Simulink Algebraic Constraint function for solving a polyno￾mial equation with trig functions (i.e., sin(x), cos(2x)).
FIGURE B.25 Simulink solution of the single homogeneous polynomial equation of 
Example B.8.
FIGURE B.26 Simulink solution of the cos and sin function of Example B.9.353
Index
Note: Bold page numbers refer to tables and italic page numbers refer to figures.
“Algebraic Constraint” block 92, 114
algebraic equations 283, 339, 342
linear equation 4–7
nonlinear equation 7–13
algebraic manipulation concepts 13
algorithm 1–2, 51, 58, 61, 64, 70, 247
Euler algorithms 248
Midpoint algorithm 255
NR algorithm 124
secant algorithm 126
Thomas algorithm 283
Trapezoidal algorithm 190
analytical method 1–3, 28
backward Euler method 217–222
graphical explanation 218
manual solution 218–219
Python solution 221–222
Simulink and MATLAB solution 219–221
bisection method 3, 127
advantages of 90
disadvantage of 90
false-position methods 93
implementation of 90–92
Python solution 91, 93
Boole’s rule
analytical integration value 194
definite integral 193–194
graphical representation 194
MATLAB code 195
Python solution 195
Simulink solution 194–195
boundary conditions (BCs) 279–281
boundary value problem 281
initial value problems 281
boundary value problem (BVP) 19–27, 279–280
boundary conditions 281
finite difference method 282–283, 290–302
initial value problems 281
shooting method 302–314
Thomas algorithm 283–290
bracketing method, roots solution with 88–90
bisection method 90–93
false-position methods 93–97
graphical representation of 89
Python-generated plot 89
Ridders’ method 97–101
cartesian equation 74
central finite difference 282
constant coefficient 344
continuous stirred tank reactor (CSTR) 9
liquid phase reaction 12–13
Cramer’s rule
implementation 43–48
implication of 38
inconsistent equations 50–51
2 × 2 matrix 48–49
Python solution 40, 47
Simulink algebraic constraint block 38–39
Simulink MATLAB function 39–40
Simulink solution 46–47
three linear equations 37
two linear equations 36
cubic equation 130–133
data type 324
definite integral 177, 178
approximate value 179, 180
Boole’s rule 193–194
mentioned function 178
real-valued function 178
rectangular approximation 178
Simpson’s rule 179, 182, 184
Trapezoidal rule 188
determinant calculation 40–41
Python solution 41–42
Simulink solution 41
differential equations
definition of 279
for mixing tank 16
digital computing process 2
direct integration 188
direct method 3
eigenvalue and eigenvector 144
application of 145, 157–163
ordinary differential equation 150–157
Python solution 149
Simulink solution 147
elimination methods 163–167
eigenvalue and eigenvector 167–168
Python solution 171
Simulink solution 168–171
Euler explicit method
Python solution 216–217
Simulink/MATLAB solution 214–216
Euler method 208
application of 248–250
interpretation numerical method 208354 Index
Euler method (cont.)
Python code 212–213, 253–254
Simulink and MATLAB solution 
210–212, 250–253
Euler solution 208
false-position methods
Python solution 97
regula false method 93–96
finite difference methods (FDMs) 282–283,
293–294
application of 283–286, 290
approximation 283
Python solution 289–290
to second-order BVP 297–302
second-order method 283
Simulink solution 286–289
first-order differential equation 
247, 342–343
fixed-point iteration method
application of 109–111, 113
Python solution 112, 115–116
Simulink solution 111, 113–115
for loop 322–323
fourth-order Runge-Kutta method 147, 148
gas phase reaction 11
Gauss elimination method 3
implementation of 53–57
Simulink MATLAB function 57
three linear algebraic equations 52
upper triangular matrix 53
Gauss-Jacobi method
application of 63–66
Python solution 65–66
Simulink solution 64–65
Gauss-Jordan elimination
implementation of 59–60
Python solution 61–62
Simulink MATLAB function 61
Gauss-Seidel method
application of 67–68
Python solution 69–70
Simulink solution 68–69
graphical method 74
graphical root-finding method 86–88
high-order equations 78–81
Python solution 77–78
roots of quadratic equations 81–83, 84–86
Simulink solution 75–76
Graphical User Interface (GUI) shape 251
Heun’s method
graphical description 226
initial value nonlinear ODE 227
Python solution 230–231
Simulink and MATLAB solution 228–230
high-order equations, root finding
Python solution 80–81
Simulink solution 79
high-order polynomial equation 348
‘if’ function 321–322
independent variable value 279
indirect numerical methods 4
initial error analysis 1
initial value problem (IVP) 19, 247, 279, 281
eigenvalues and eigenvectors 144–163
elimination methods 163–171
first-order ODE solution method 144
steady-state conditions 144
integration 177
Interactive Development Environment (IDE) 318
Iterative numerical methods 3–4
Jacobi method 3, 63, 68
linear algebraic equation (LAE) 
5, 292, 298
coefficient matrix 32
Cramer’s rule 36–51
definition of 31–33
Gauss elimination method 51–58
Gauss-Jacobi iterative method 62–66
Gauss-Jordan elimination method 58–62
Gauss-Seidel iterative method 66–70
matrix inverse 34–35
matrix properties 33–34
matrix transposition 35–36
vs. nonlinear equations 5
in one variable 5–6
operation properties 33–34
substitution method 4
sum of two numbers 6–7
linear equation system 5, 282
linear order differential equation model 
341, 341
liquid phase reaction 12–13
mass transfer, tubular liquid flow 24
mathematical functions 320
‘Math Operations/Algebraic Constraints’ 
function 286
math operations library 338
MATLAB code 107
finite difference approximation 299
programming language 147
secant method 129, 132
Simpson’s rule 183
Simulink MATLAB function 50
MATLAB program
rectangle rule (Midpoint rule) 192
MATLAB solution
Picard’s iterative method 
242–243
Runge-Kutta methods 233–235Index 355
matrix
coefficient 37
inverse of 34–35
properties of 33–34
transposition of 35–36
3 × 3 matrix
Python solution 43
Simulink solution 42–43
matrix coefficient and multiplication 343
Midpoint method
graphical representation 223
manual solution 255–257
Python program 259–260
Python solution 225–226
Simulink and MATLAB solution 224–22
Simulink solution 257–260
module, Python code 329
Muller’s method
application of 136
graphical presentation of 134
Python solution 138–139
Simulink solution 136–137
multivariate NR method
Python solution 124–126
Simulink solution 124
Navier-Stokes equation 26–27
Newton’s method 3, 126
nonlinear algebraic equations 113
application of 8–10
vs. linear equations 5
liquid phase reaction 12–13
numerical integration 11–12
system of 7–8
nonlinear equations
bracketing methods 73
one-dimensional equations 104
two-dimensional equations 104
NR method
application of 120–122
Python solution 120
root finding, procedure of 117
Simulink solution 118–120
single polynomial equation 117–118
numerical analysis 2
numerical integration 11–12, 177, 207
arbitrary bounds 178
definite integrals values 178
numerical method 31
advantage of 3
definition of 2
direct method 3
indirect numerical methods 3–4
initial error analysis 1
problem solving process 1
object methods 333–334
one variable, linear equations 5–6
5
ordinary differential equations (ODEs) 13, 15, 
143, 207, 247, 279
backward Euler method 217–222
eigenvalue and eigenvector technique 145
with Euler explicit method 213–217
Euler method 208
first-order differential equation 15–19
integral value for 208
order of differential equation 14
Partial Differential Equations (PDE) 293
PFR see plug flow reactor (PFR)
Picard’s iterative method
application of 241–242, 271–275
Python solution 243–244, 275–277
Simulink and MATLAB solution 
242–243, 275
pivotal element 52
plug flow reactor (PFR) 11
polynomial equation 348
porous cylindrical porous solid catalyst 21
pseudo-momentum equilibrium method 26
Python code
bisection method 93
Boole’s rule 195
Cramer’s rule 40, 47
data type 324
determinant calculation 41–42
eigenvalue and eigenvector 149–150
elimination methods 171
Euler method 253–254
false-position methods 97
fixed-point iteration method 112, 115–116
functions 328–329
Gauss elimination method 58
Gauss-Jacobi method 65–66
Gauss-Jordan elimination 61–62
Gauss-Seidel method 69–70
graphical method, root finding 77–78
Heun’s method 230–231
high-order equations, root finding 80–81
‘if’ function 321–322
inconsistent equations, Cramer’s rule 50–51
for loop 322–323
mathematical functions 320
2 × 2 matrix 48–49
3 × 3 matrix 43
Midpoint method 225–226, 259–260
module 329
Muller’s method 138–139
multivariate NR method 124–126
NR method 120
object methods 333–334
Picard’s iterative method 243–244, 275–277
programming codes writing rules 317
Python basics 319–321
Ridders’ method 100–101
Romberg integration 200356 Index
Python code (cont.)
Runge-Kutta methods 235–238, 267–269
Simpson’s rule 181–182
Spyder program 318
string 324–328
substitution method 108
texts and file processing 329–332
Trapezoidal rule 190
Python NumPy module 285
quadratic equations root 10
manual solution 81
Python solution 81–83, 84–86
Simulink solution 81, 84
‘range’ function 322
rectangle rule (Midpoint rule)
graphical clarification 191
MATLAB program 192
Python solution 193
Richardson extrapolation 196–202
graphical representation 197
Ridders’ method
graphical illustration of 98
MATLAB function 99
Python solution 100–101
Simulink solution 99–100
RK4 method 261–269
Romberg integration 196–202
definite integral 196
graphical representation 197
Python solution 200
Simulink solution 198–199
technique 200–203
Trapezoidal rule 196
Romberg’s method 178
Runge-Kutta method
Python solution 267–269
Simulink solution 263–267
Runge-Kutta methods
graphical explanation 231
initial value ODE 232
Python solution 235–238
Simulink and MATLAB solution 233–235
“SciPy. Integration” subpackage 183, 186
secant method
advantages 128
application of 128–130
cubic equation 130–133
drawbacks 128
graphical description 127
MATLAB code 129, 132
numerical root finding 126
second-order differential equation 
297–302, 346–348
shooting method
explicit Euler method 311–314
Python solution 305–307
second-order BVP 307–311
Simulink solution 304–305
for steady-state heat transfer 303–304
Simpson’s rule
application of 179, 182–186
definite integral 178
formula 180, 182
graphical representation 179
MATLAB code 183
Python program 181–182
quadratic function 178
Simulink solution 180–181
Simpson’s 1/3 rule 181
simulation time 345
Simulink
algebraic constraint block 56
algebraic equation 339, 342
blocks, classes of 335
commonly used blocks 337
constant coefficient 344
‘continuous’ function blocks 337
cos and sin function 351
first-order differential equation 342–343
high-order polynomial equation 348
linear order differential equation model 
341, 341
math operations library 338
MATLAB start window 336
matrix coefficient and multiplication 343
model window 339
polynomial equation 348
scope background and color 347
second order differential equation 346–348
simulation time 345
simultaneous equations 348–350
single homogeneous polynomial equation 
350–351
‘Sinks’ icons 337, 338
solution of 340, 344
‘sources’ library 338
start page 336
untitled new file 336
used blocks 340
Simulink algebraic constraint block 38–39
Simulink Library Browser 335
Simulink MATLAB function 
39–40, 180–181, 185
Simulink solution
Boole’s rule 194–195
Cramer’s rule 46–47
determinant calculation 41
eigenvalue and eigenvector 147
elimination methods 168–171
Euler method 250–253
fixed-point iteration method 111, 113–115Index 357
Gauss-Jordan elimination 61
Gauss-Seidel method 68–69
graphical method, root finding 75–76
high-order equations, root finding 79
inconsistent equations, Cramer’s rule 50
MATLAB code 41–43
3 × 3 matrix 42–43
Midpoint method 257–260
Muller’s method 136–137
multivariate NR method 124
NR method 118–120
Picard’s iterative method 242–243, 275
Ridders’ method 99–100
Romberg integration 198–199
Runge-Kutta methods 233–235, 263–267
Simpson’s rule 180–181
substitution method 106–107
Trapezoidal rule 189
simultaneous equations 348–350
simultaneous numerical solution
Euler method 248–254
Midpoint method 254–260
Picard’s iterative method 270–277
Runge-Kutta method 260–269
single homogeneous polynomial equation
117–118, 350
spherical porous catalyst 20
Spyder program 318
string, Python code 324–328
substitution method 4, 10
MATLAB code 107
Python solution 108
Simulink solution 106–107
texts and file processing 329–332
Thomas algorithm 283
transpose matrix 35–36
Trapezoidal rule 178, 186
graphical interpretation 187
Python solution 190
Simulink solution 189
trial-and-error approach 303
tridiagonal matrix system 283
tubular liquid flow 24
upper triangular matrix 53REQUEST A FREE TRIAL
support@taylorfrancis.com
Taylor & Francis eBooks
www.taylorfrancis.com
A single destination for eBooks from Taylor & Francis 
with increased functionality and an improved user 
experience to meet the needs of our customers.
90,000+ eBooks of award-winning academic content in 
Humanities, Social Science, Science, Technology, Engineering, 
and Medical written by a global network of editors and authors.
TAYLOR & FRANCIS EBOOKS OFFERS:
A streamlined 
experience for 
our library 
customers
A single point 
of discovery 
for all of our 
eBook content
Improved 
search and 
discovery of 
content at both 
book and 
chapter level

Probabilistic Machine LearningAdaptive Computation and Machine Learning
Thomas Dietterich, Editor
Christopher Bishop, David Heckerman, Michael Jordan, and Michael Kearns, Associate Editors
Bioinformatics: The Machine Learning Approach, Pierre Baldi and Søren Brunak
Reinforcement Learning: An Introduction, Richard S. Sutton and Andrew G. Barto
Graphical Models for Machine Learning and Digital Communication, Brendan J. Frey
Learning in Graphical Models, Michael I. Jordan
Causation, Prediction, and Search, second edition, Peter Spirtes, Clark Glymour, and Richard
Scheines
Principles of Data Mining, David Hand, Heikki Mannila, and Padhraic Smyth
Bioinformatics: The Machine Learning Approach, second edition, Pierre Baldi and Søren Brunak
Learning Kernel Classifiers: Theory and Algorithms, Ralf Herbrich
Learning with Kernels: Support Vector Machines, Regularization, Optimization, and Beyond,
Bernhard Schölkopf and Alexander J. Smola
Introduction to Machine Learning, Ethem Alpaydin
Gaussian Processes for Machine Learning, Carl Edward Rasmussen and Christopher K.I. Williams
Semi-Supervised Learning, Olivier Chapelle, Bernhard Schölkopf, and Alexander Zien, Eds.
The Minimum Description Length Principle, Peter D. Grünwald
Introduction to Statistical Relational Learning, Lise Getoor and Ben Taskar, Eds.
Probabilistic Graphical Models: Principles and Techniques, Daphne Koller and Nir Friedman
Introduction to Machine Learning, second edition, Ethem Alpaydin
Boosting: Foundations and Algorithms, Robert E. Schapire and Yoav Freund
Machine Learning: A Probabilistic Perspective, Kevin P. Murphy
Foundations of Machine Learning, Mehryar Mohri, Afshin Rostami, and Ameet Talwalker
Probabilistic Machine Learning: An Introduction, Kevin P. MurphyProbabilistic Machine Learning
An Introduction
Kevin P. Murphy
The MIT Press
Cambridge, Massachusetts
London, England© 2022 Massachusetts Institute of Technology
This work is subject to a Creative Commons CC-BY-NC-ND license.
Subject to such license, all rights are reserved.
The MIT Press would like to thank the anonymous peer reviewers who provided comments on drafts of this
book. The generous work of academic experts is essential for establishing the authority and quality of our
publications. We acknowledge with gratitude the contributions of these otherwise uncredited readers.
Printed and bound in the United States of America.
Library of Congress Cataloging-in-Publication Data
Names: Murphy, Kevin P., author.
Title: Probabilistic machine learning : an introduction / Kevin P. Murphy.
Description: Cambridge, Massachusetts : The MIT Press, [2022]
Series: Adaptive computation and machine learning series
Includes bibliographical references and index.
Identifiers: LCCN 2021027430 | ISBN 9780262046824 (hardcover)
Subjects: LCSH: Machine learning. | Probabilities.
Classification: LCC Q325.5 .M872 2022 | DDC 006.3/1–dc23
LC record available at https://lccn.loc.gov/2021027430
10 9 8 7 6 5 4 3 2 1This book is dedicated to my mother, Brigid Murphy,
who introduced me to the joy of learning and teaching.Brief Contents
1 Introduction 1
I Foundations 29
2 Probability: Univariate Models 31
3 Probability: Multivariate Models 75
4 Statistics 103
5 Decision Theory 163
6 Information Theory 201
7 Linear Algebra 223
8 Optimization 269
II Linear Models 315
9 Linear Discriminant Analysis 317
10 Logistic Regression 333
11 Linear Regression 363
12 Generalized Linear Models * 405
III Deep Neural Networks 413
13 Neural Networks for Structured Data 415
14 Neural Networks for Images 457
15 Neural Networks for Sequences 493
IV Nonparametric Models 535
16 Exemplar-based Methods 537
17 Kernel Methods * 557
18 Trees, Forests, Bagging, and Boosting 593viii BRIEF CONTENTS
V Beyond Supervised Learning 613
19 Learning with Fewer Labeled Examples 615
20 Dimensionality Reduction 645
21 Clustering 703
22 Recommender Systems 729
23 Graph Embeddings * 741
A Notation 761
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022Contents
Preface xi
1 Introduction 1
1.1 What is machine learning? 1
1.2 Supervised learning 1
1.2.1 Classification 2
1.2.2 Regression 8
1.2.3 Overfitting and generalization 12
1.2.4 No free lunch theorem 13
1.3 Unsupervised learning 14
1.3.1 Clustering 14
1.3.2 Discovering latent “factors of variation” 15
1.3.3 Self-supervised learning 16
1.3.4 Evaluating unsupervised learning 16
1.4 Reinforcement learning 17
1.5 Data 18
1.5.1 Some common image datasets 19
1.5.2 Some common text datasets 21
1.5.3 Preprocessing discrete input data 23
1.5.4 Preprocessing text data 24
1.5.5 Handling missing data 26
1.6 Discussion 27
1.6.1 The relationship between ML and other fields 27
1.6.2 Structure of the book 27
1.6.3 Caveats 28
I Foundations 29
2 Probability: Univariate Models 31
2.1 Introduction 31
2.1.1 What is probability? 31x CONTENTS
2.1.2 Types of uncertainty 31
2.1.3 Probability as an extension of logic 32
2.2 Random variables 33
2.2.1 Discrete random variables 33
2.2.2 Continuous random variables 34
2.2.3 Sets of related random variables 36
2.2.4 Independence and conditional independence 37
2.2.5 Moments of a distribution 38
2.2.6 Limitations of summary statistics * 41
2.3 Bayes’ rule 42
2.3.1 Example: Testing for COVID-19 44
2.3.2 Example: The Monty Hall problem 45
2.3.3 Inverse problems * 47
2.4 Bernoulli and binomial distributions 47
2.4.1 Definition 47
2.4.2 Sigmoid (logistic) function 48
2.4.3 Binary logistic regression 50
2.5 Categorical and multinomial distributions 51
2.5.1 Definition 51
2.5.2 Softmax function 52
2.5.3 Multiclass logistic regression 53
2.5.4 Log-sum-exp trick 54
2.6 Univariate Gaussian (normal) distribution 55
2.6.1 Cumulative distribution function 55
2.6.2 Probability density function 56
2.6.3 Regression 57
2.6.4 Why is the Gaussian distribution so widely used? 58
2.6.5 Dirac delta function as a limiting case 58
2.7 Some other common univariate distributions * 59
2.7.1 Student t distribution 59
2.7.2 Cauchy distribution 60
2.7.3 Laplace distribution 61
2.7.4 Beta distribution 61
2.7.5 Gamma distribution 62
2.7.6 Empirical distribution 63
2.8 Transformations of random variables * 64
2.8.1 Discrete case 64
2.8.2 Continuous case 64
2.8.3 Invertible transformations (bijections) 64
2.8.4 Moments of a linear transformation 67
2.8.5 The convolution theorem 68
2.8.6 Central limit theorem 69
2.8.7 Monte Carlo approximation 70
2.9 Exercises 71
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022CONTENTS xi
3 Probability: Multivariate Models 75
3.1 Joint distributions for multiple random variables 75
3.1.1 Covariance 75
3.1.2 Correlation 76
3.1.3 Uncorrelated does not imply independent 77
3.1.4 Correlation does not imply causation 77
3.1.5 Simpson’s paradox 78
3.2 The multivariate Gaussian (normal) distribution 78
3.2.1 Definition 79
3.2.2 Mahalanobis distance 81
3.2.3 Marginals and conditionals of an MVN * 82
3.2.4 Example: conditioning a 2d Gaussian 83
3.2.5 Example: Imputing missing values * 83
3.3 Linear Gaussian systems * 84
3.3.1 Bayes rule for Gaussians 85
3.3.2 Derivation * 85
3.3.3 Example: Inferring an unknown scalar 86
3.3.4 Example: inferring an unknown vector 88
3.3.5 Example: sensor fusion 88
3.4 The exponential family * 89
3.4.1 Definition 90
3.4.2 Example 91
3.4.3 Log partition function is cumulant generating function 91
3.4.4 Maximum entropy derivation of the exponential family 92
3.5 Mixture models 93
3.5.1 Gaussian mixture models 93
3.5.2 Bernoulli mixture models 95
3.6 Probabilistic graphical models * 96
3.6.1 Representation 96
3.6.2 Inference 99
3.6.3 Learning 99
3.7 Exercises 100
4 Statistics 103
4.1 Introduction 103
4.2 Maximum likelihood estimation (MLE) 103
4.2.1 Definition 103
4.2.2 Justification for MLE 104
4.2.3 Example: MLE for the Bernoulli distribution 106
4.2.4 Example: MLE for the categorical distribution 107
4.2.5 Example: MLE for the univariate Gaussian 107
4.2.6 Example: MLE for the multivariate Gaussian 108
4.2.7 Example: MLE for linear regression 110
4.3 Empirical risk minimization (ERM) 111
4.3.1 Example: minimizing the misclassification rate 111
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexii CONTENTS
4.3.2 Surrogate loss 112
4.4 Other estimation methods * 112
4.4.1 The method of moments 112
4.4.2 Online (recursive) estimation 114
4.5 Regularization 116
4.5.1 Example: MAP estimation for the Bernoulli distribution 117
4.5.2 Example: MAP estimation for the multivariate Gaussian * 118
4.5.3 Example: weight decay 119
4.5.4 Picking the regularizer using a validation set 120
4.5.5 Cross-validation 121
4.5.6 Early stopping 123
4.5.7 Using more data 123
4.6 Bayesian statistics * 124
4.6.1 Conjugate priors 125
4.6.2 The beta-binomial model 125
4.6.3 The Dirichlet-multinomial model 133
4.6.4 The Gaussian-Gaussian model 136
4.6.5 Beyond conjugate priors 139
4.6.6 Credible intervals 141
4.6.7 Bayesian machine learning 143
4.6.8 Computational issues 147
4.7 Frequentist statistics * 149
4.7.1 Sampling distributions 150
4.7.2 Gaussian approximation of the sampling distribution of the MLE 150
4.7.3 Bootstrap approximation of the sampling distribution of any estimator 151
4.7.4 Confidence intervals 152
4.7.5 Caution: Confidence intervals are not credible 153
4.7.6 The bias-variance tradeoff 154
4.8 Exercises 159
5 Decision Theory 163
5.1 Bayesian decision theory 163
5.1.1 Basics 163
5.1.2 Classification problems 165
5.1.3 ROC curves 167
5.1.4 Precision-recall curves 169
5.1.5 Regression problems 172
5.1.6 Probabilistic prediction problems 173
5.2 Choosing the “right” model 175
5.2.1 Bayesian hypothesis testing 175
5.2.2 Bayesian model selection 177
5.2.3 Occam’s razor 177
5.2.4 Connection between cross validation and marginal likelihood 179
5.2.5 Information criteria 180
5.2.6 Hypothesis testing without Bayes factors 182
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022CONTENTS xiii
5.3 Frequentist decision theory 184
5.3.1 Computing the risk of an estimator 184
5.3.2 Consistent estimators 187
5.3.3 Admissible estimators 187
5.4 Empirical risk minimization 188
5.4.1 Empirical risk 188
5.4.2 Structural risk 190
5.4.3 Cross-validation 190
5.4.4 Statistical learning theory * 191
5.5 Frequentist hypothesis testing * 193
5.5.1 Likelihood ratio test 193
5.5.2 Null hypothesis significance testing (NHST) 194
5.5.3 p-values 194
5.5.4 p-values considered harmful 195
5.5.5 Why isn’t everyone a Bayesian? 196
5.6 Exercises 198
6 Information Theory 201
6.1 Entropy 201
6.1.1 Entropy for discrete random variables 201
6.1.2 Cross entropy 203
6.1.3 Joint entropy 203
6.1.4 Conditional entropy 204
6.1.5 Perplexity 205
6.1.6 Differential entropy for continuous random variables * 206
6.2 Relative entropy (KL divergence) * 207
6.2.1 Definition 207
6.2.2 Interpretation 208
6.2.3 Example: KL divergence between two Gaussians 208
6.2.4 Non-negativity of KL 208
6.2.5 KL divergence and MLE 209
6.2.6 Forward vs reverse KL 210
6.3 Mutual information * 211
6.3.1 Definition 211
6.3.2 Interpretation 212
6.3.3 Example 212
6.3.4 Conditional mutual information 213
6.3.5 MI as a “generalized correlation coefficient” 214
6.3.6 Normalized mutual information 215
6.3.7 Maximal information coefficient 215
6.3.8 Data processing inequality 217
6.3.9 Sufficient Statistics 218
6.3.10 Fano’s inequality * 219
6.4 Exercises 220
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexiv CONTENTS
7 Linear Algebra 223
7.1 Introduction 223
7.1.1 Notation 223
7.1.2 Vector spaces 226
7.1.3 Norms of a vector and matrix 228
7.1.4 Properties of a matrix 230
7.1.5 Special types of matrices 233
7.2 Matrix multiplication 236
7.2.1 Vector–vector products 236
7.2.2 Matrix–vector products 237
7.2.3 Matrix–matrix products 237
7.2.4 Application: manipulating data matrices 239
7.2.5 Kronecker products * 241
7.2.6 Einstein summation * 242
7.3 Matrix inversion 243
7.3.1 The inverse of a square matrix 243
7.3.2 Schur complements * 243
7.3.3 The matrix inversion lemma * 245
7.3.4 Matrix determinant lemma * 245
7.3.5 Application: deriving the conditionals of an MVN * 246
7.4 Eigenvalue decomposition (EVD) 247
7.4.1 Basics 247
7.4.2 Diagonalization 248
7.4.3 Eigenvalues and eigenvectors of symmetric matrices 248
7.4.4 Geometry of quadratic forms 249
7.4.5 Standardizing and whitening data 250
7.4.6 Power method 251
7.4.7 Deflation 252
7.4.8 Eigenvectors optimize quadratic forms 253
7.5 Singular value decomposition (SVD) 253
7.5.1 Basics 253
7.5.2 Connection between SVD and EVD 254
7.5.3 Pseudo inverse 255
7.5.4 SVD and the range and null space of a matrix * 255
7.5.5 Truncated SVD 256
7.6 Other matrix decompositions * 258
7.6.1 LU factorization 258
7.6.2 QR decomposition 258
7.6.3 Cholesky decomposition 259
7.7 Solving systems of linear equations * 260
7.7.1 Solving square systems 261
7.7.2 Solving underconstrained systems (least norm estimation) 261
7.7.3 Solving overconstrained systems (least squares estimation) 262
7.8 Matrix calculus 263
7.8.1 Derivatives 263
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022CONTENTS xv
7.8.2 Gradients 264
7.8.3 Directional derivative 264
7.8.4 Total derivative * 265
7.8.5 Jacobian 265
7.8.6 Hessian 266
7.8.7 Gradients of commonly used functions 266
7.9 Exercises 268
8 Optimization 269
8.1 Introduction 269
8.1.1 Local vs global optimization 269
8.1.2 Constrained vs unconstrained optimization 271
8.1.3 Convex vs nonconvex optimization 271
8.1.4 Smooth vs nonsmooth optimization 275
8.2 First-order methods 276
8.2.1 Descent direction 278
8.2.2 Step size (learning rate) 278
8.2.3 Convergence rates 280
8.2.4 Momentum methods 281
8.3 Second-order methods 283
8.3.1 Newton’s method 283
8.3.2 BFGS and other quasi-Newton methods 284
8.3.3 Trust region methods 285
8.4 Stochastic gradient descent 286
8.4.1 Application to finite sum problems 287
8.4.2 Example: SGD for fitting linear regression 287
8.4.3 Choosing the step size (learning rate) 288
8.4.4 Iterate averaging 291
8.4.5 Variance reduction * 291
8.4.6 Preconditioned SGD 292
8.5 Constrained optimization 295
8.5.1 Lagrange multipliers 296
8.5.2 The KKT conditions 297
8.5.3 Linear programming 299
8.5.4 Quadratic programming 300
8.5.5 Mixed integer linear programming * 301
8.6 Proximal gradient method * 301
8.6.1 Projected gradient descent 302
8.6.2 Proximal operator for `1-norm regularizer 303
8.6.3 Proximal operator for quantization 304
8.6.4 Incremental (online) proximal methods 305
8.7 Bound optimization * 305
8.7.1 The general algorithm 305
8.7.2 The EM algorithm 306
8.7.3 Example: EM for a GMM 309
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexvi CONTENTS
8.8 Blackbox and derivative free optimization 313
8.9 Exercises 314
II Linear Models 315
9 Linear Discriminant Analysis 317
9.1 Introduction 317
9.2 Gaussian discriminant analysis 317
9.2.1 Quadratic decision boundaries 318
9.2.2 Linear decision boundaries 319
9.2.3 The connection between LDA and logistic regression 319
9.2.4 Model fitting 320
9.2.5 Nearest centroid classifier 322
9.2.6 Fisher’s linear discriminant analysis * 322
9.3 Naive Bayes classifiers 326
9.3.1 Example models 326
9.3.2 Model fitting 327
9.3.3 Bayesian naive Bayes 328
9.3.4 The connection between naive Bayes and logistic regression 329
9.4 Generative vs discriminative classifiers 330
9.4.1 Advantages of discriminative classifiers 330
9.4.2 Advantages of generative classifiers 331
9.4.3 Handling missing features 331
9.5 Exercises 332
10 Logistic Regression 333
10.1 Introduction 333
10.2 Binary logistic regression 333
10.2.1 Linear classifiers 333
10.2.2 Nonlinear classifiers 334
10.2.3 Maximum likelihood estimation 336
10.2.4 Stochastic gradient descent 339
10.2.5 Perceptron algorithm 339
10.2.6 Iteratively reweighted least squares 340
10.2.7 MAP estimation 341
10.2.8 Standardization 343
10.3 Multinomial logistic regression 344
10.3.1 Linear and nonlinear classifiers 344
10.3.2 Maximum likelihood estimation 344
10.3.3 Gradient-based optimization 347
10.3.4 Bound optimization 347
10.3.5 MAP estimation 349
10.3.6 Maximum entropy classifiers 349
10.3.7 Hierarchical classification 350
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022CONTENTS xvii
10.3.8 Handling large numbers of classes 351
10.4 Robust logistic regression * 353
10.4.1 Mixture model for the likelihood 353
10.4.2 Bi-tempered loss 354
10.5 Bayesian logistic regression * 356
10.5.1 Laplace approximation 356
10.5.2 Approximating the posterior predictive 359
10.6 Exercises 360
11 Linear Regression 363
11.1 Introduction 363
11.2 Least squares linear regression 363
11.2.1 Terminology 363
11.2.2 Least squares estimation 364
11.2.3 Other approaches to computing the MLE 368
11.2.4 Measuring goodness of fit 372
11.3 Ridge regression 373
11.3.1 Computing the MAP estimate 374
11.3.2 Connection between ridge regression and PCA 375
11.3.3 Choosing the strength of the regularizer 376
11.4 Lasso regression 377
11.4.1 MAP estimation with a Laplace prior (`1 regularization) 377
11.4.2 Why does `1 regularization yield sparse solutions? 378
11.4.3 Hard vs soft thresholding 379
11.4.4 Regularization path 381
11.4.5 Comparison of least squares, lasso, ridge and subset selection 382
11.4.6 Variable selection consistency 383
11.4.7 Group lasso 385
11.4.8 Elastic net (ridge and lasso combined) 387
11.4.9 Optimization algorithms 389
11.5 Regression splines * 391
11.5.1 B-spline basis functions 391
11.5.2 Fitting a linear model using a spline basis 392
11.5.3 Smoothing splines 393
11.5.4 Generalized additive models 393
11.6 Robust linear regression * 393
11.6.1 Laplace likelihood 395
11.6.2 Student-t likelihood 396
11.6.3 Huber loss 396
11.6.4 RANSAC 396
11.7 Bayesian linear regression * 396
11.7.1 Priors 397
11.7.2 Posteriors 397
11.7.3 Example 397
11.7.4 Computing the posterior predictive 398
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexviii CONTENTS
11.7.5 The advantage of centering 399
11.7.6 Dealing with multicollinearity 401
11.7.7 Automatic relevancy determination (ARD) * 402
11.8 Exercises 402
12 Generalized Linear Models * 405
12.1 Introduction 405
12.2 Examples 405
12.2.1 Linear regression 406
12.2.2 Binomial regression 406
12.2.3 Poisson regression 407
12.3 GLMs with non-canonical link functions 407
12.4 Maximum likelihood estimation 408
12.5 Worked example: predicting insurance claims 409
III Deep Neural Networks 413
13 Neural Networks for Structured Data 415
13.1 Introduction 415
13.2 Multilayer perceptrons (MLPs) 416
13.2.1 The XOR problem 417
13.2.2 Differentiable MLPs 418
13.2.3 Activation functions 418
13.2.4 Example models 419
13.2.5 The importance of depth 424
13.2.6 The “deep learning revolution” 425
13.2.7 Connections with biology 426
13.3 Backpropagation 428
13.3.1 Forward vs reverse mode differentiation 428
13.3.2 Reverse mode differentiation for multilayer perceptrons 430
13.3.3 Vector-Jacobian product for common layers 431
13.3.4 Computation graphs 434
13.4 Training neural networks 436
13.4.1 Tuning the learning rate 437
13.4.2 Vanishing and exploding gradients 437
13.4.3 Non-saturating activation functions 438
13.4.4 Residual connections 441
13.4.5 Parameter initialization 442
13.4.6 Parallel training 443
13.5 Regularization 444
13.5.1 Early stopping 444
13.5.2 Weight decay 445
13.5.3 Sparse DNNs 445
13.5.4 Dropout 445
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022CONTENTS xix
13.5.5 Bayesian neural networks 447
13.5.6 Regularization effects of (stochastic) gradient descent * 447
13.6 Other kinds of feedforward networks * 449
13.6.1 Radial basis function networks 449
13.6.2 Mixtures of experts 450
13.7 Exercises 453
14 Neural Networks for Images 457
14.1 Introduction 457
14.2 Common layers 458
14.2.1 Convolutional layers 458
14.2.2 Pooling layers 465
14.2.3 Putting it all together 466
14.2.4 Normalization layers 466
14.3 Common architectures for image classification 469
14.3.1 LeNet 469
14.3.2 AlexNet 471
14.3.3 GoogLeNet (Inception) 472
14.3.4 ResNet 473
14.3.5 DenseNet 474
14.3.6 Neural architecture search 475
14.4 Other forms of convolution * 475
14.4.1 Dilated convolution 476
14.4.2 Transposed convolution 476
14.4.3 Depthwise separable convolution 478
14.5 Solving other discriminative vision tasks with CNNs * 478
14.5.1 Image tagging 479
14.5.2 Object detection 479
14.5.3 Instance segmentation 480
14.5.4 Semantic segmentation 480
14.5.5 Human pose estimation 482
14.6 Generating images by inverting CNNs * 483
14.6.1 Converting a trained classifier into a generative model 483
14.6.2 Image priors 484
14.6.3 Visualizing the features learned by a CNN 486
14.6.4 Deep Dream 486
14.6.5 Neural style transfer 487
15 Neural Networks for Sequences 493
15.1 Introduction 493
15.2 Recurrent neural networks (RNNs) 493
15.2.1 Vec2Seq (sequence generation) 493
15.2.2 Seq2Vec (sequence classification) 496
15.2.3 Seq2Seq (sequence translation) 497
15.2.4 Teacher forcing 499
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexx CONTENTS
15.2.5 Backpropagation through time 500
15.2.6 Vanishing and exploding gradients 501
15.2.7 Gating and long term memory 502
15.2.8 Beam search 505
15.3 1d CNNs 506
15.3.1 1d CNNs for sequence classification 506
15.3.2 Causal 1d CNNs for sequence generation 507
15.4 Attention 508
15.4.1 Attention as soft dictionary lookup 509
15.4.2 Kernel regression as non-parametric attention 510
15.4.3 Parametric attention 510
15.4.4 Seq2Seq with attention 511
15.4.5 Seq2vec with attention (text classification) 514
15.4.6 Seq+Seq2Vec with attention (text pair classification) 514
15.4.7 Soft vs hard attention 515
15.5 Transformers 516
15.5.1 Self-attention 516
15.5.2 Multi-headed attention 517
15.5.3 Positional encoding 518
15.5.4 Putting it all together 519
15.5.5 Comparing transformers, CNNs and RNNs 521
15.5.6 Transformers for images * 522
15.5.7 Other transformer variants * 523
15.6 Efficient transformers * 523
15.6.1 Fixed non-learnable localized attention patterns 523
15.6.2 Learnable sparse attention patterns 523
15.6.3 Memory and recurrence methods 524
15.6.4 Low-rank and kernel methods 525
15.7 Language models and unsupervised representation learning 527
15.7.1 ELMo 527
15.7.2 BERT 528
15.7.3 GPT 531
15.7.4 T5 532
15.7.5 Discussion 533
IV Nonparametric Models 535
16 Exemplar-based Methods 537
16.1 K nearest neighbor (KNN) classification 537
16.1.1 Example 538
16.1.2 The curse of dimensionality 538
16.1.3 Reducing the speed and memory requirements 540
16.1.4 Open set recognition 540
16.2 Learning distance metrics 541
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022CONTENTS xxi
16.2.1 Linear and convex methods 542
16.2.2 Deep metric learning 543
16.2.3 Classification losses 544
16.2.4 Ranking losses 544
16.2.5 Speeding up ranking loss optimization 546
16.2.6 Other training tricks for DML 549
16.3 Kernel density estimation (KDE) 550
16.3.1 Density kernels 550
16.3.2 Parzen window density estimator 551
16.3.3 How to choose the bandwidth parameter 552
16.3.4 From KDE to KNN classification 553
16.3.5 Kernel regression 553
17 Kernel Methods * 557
17.1 Mercer kernels 557
17.1.1 Mercer’s theorem 558
17.1.2 Some popular Mercer kernels 559
17.2 Gaussian processes 564
17.2.1 Noise-free observations 564
17.2.2 Noisy observations 565
17.2.3 Comparison to kernel regression 566
17.2.4 Weight space vs function space 567
17.2.5 Numerical issues 567
17.2.6 Estimating the kernel 568
17.2.7 GPs for classification 571
17.2.8 Connections with deep learning 572
17.2.9 Scaling GPs to large datasets 573
17.3 Support vector machines (SVMs) 575
17.3.1 Large margin classifiers 575
17.3.2 The dual problem 577
17.3.3 Soft margin classifiers 579
17.3.4 The kernel trick 580
17.3.5 Converting SVM outputs into probabilities 581
17.3.6 Connection with logistic regression 581
17.3.7 Multi-class classification with SVMs 582
17.3.8 How to choose the regularizer C 583
17.3.9 Kernel ridge regression 584
17.3.10 SVMs for regression 585
17.4 Sparse vector machines 587
17.4.1 Relevance vector machines (RVMs) 587
17.4.2 Comparison of sparse and dense kernel methods 588
17.5 Exercises 591
18 Trees, Forests, Bagging, and Boosting 593
18.1 Classification and regression trees (CART) 593
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexxii CONTENTS
18.1.1 Model definition 593
18.1.2 Model fitting 595
18.1.3 Regularization 596
18.1.4 Handling missing input features 596
18.1.5 Pros and cons 596
18.2 Ensemble learning 598
18.2.1 Stacking 598
18.2.2 Ensembling is not Bayes model averaging 599
18.3 Bagging 599
18.4 Random forests 600
18.5 Boosting 601
18.5.1 Forward stagewise additive modeling 602
18.5.2 Quadratic loss and least squares boosting 602
18.5.3 Exponential loss and AdaBoost 603
18.5.4 LogitBoost 606
18.5.5 Gradient boosting 606
18.6 Interpreting tree ensembles 610
18.6.1 Feature importance 610
18.6.2 Partial dependency plots 611
V Beyond Supervised Learning 613
19 Learning with Fewer Labeled Examples 615
19.1 Data augmentation 615
19.1.1 Examples 615
19.1.2 Theoretical justification 616
19.2 Transfer learning 616
19.2.1 Fine-tuning 617
19.2.2 Adapters 618
19.2.3 Supervised pre-training 619
19.2.4 Unsupervised pre-training (self-supervised learning) 620
19.2.5 Domain adaptation 625
19.3 Semi-supervised learning 625
19.3.1 Self-training and pseudo-labeling 626
19.3.2 Entropy minimization 627
19.3.3 Co-training 630
19.3.4 Label propagation on graphs 630
19.3.5 Consistency regularization 631
19.3.6 Deep generative models * 633
19.3.7 Combining self-supervised and semi-supervised learning 637
19.4 Active learning 638
19.4.1 Decision-theoretic approach 638
19.4.2 Information-theoretic approach 638
19.4.3 Batch active learning 639
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022CONTENTS xxiii
19.5 Meta-learning 639
19.5.1 Model-agnostic meta-learning (MAML) 640
19.6 Few-shot learning 640
19.6.1 Matching networks 641
19.7 Weakly supervised learning 642
19.8 Exercises 643
20 Dimensionality Reduction 645
20.1 Principal components analysis (PCA) 645
20.1.1 Examples 645
20.1.2 Derivation of the algorithm 647
20.1.3 Computational issues 650
20.1.4 Choosing the number of latent dimensions 652
20.2 Factor analysis * 654
20.2.1 Generative model 655
20.2.2 Probabilistic PCA 656
20.2.3 EM algorithm for FA/PPCA 657
20.2.4 Unidentifiability of the parameters 659
20.2.5 Nonlinear factor analysis 661
20.2.6 Mixtures of factor analysers 662
20.2.7 Exponential family factor analysis 663
20.2.8 Factor analysis models for paired data 664
20.3 Autoencoders 667
20.3.1 Bottleneck autoencoders 668
20.3.2 Denoising autoencoders 670
20.3.3 Contractive autoencoders 670
20.3.4 Sparse autoencoders 671
20.3.5 Variational autoencoders 671
20.4 Manifold learning * 676
20.4.1 What are manifolds? 677
20.4.2 The manifold hypothesis 677
20.4.3 Approaches to manifold learning 678
20.4.4 Multi-dimensional scaling (MDS) 679
20.4.5 Isomap 682
20.4.6 Kernel PCA 683
20.4.7 Maximum variance unfolding (MVU) 685
20.4.8 Local linear embedding (LLE) 685
20.4.9 Laplacian eigenmaps 686
20.4.10 t-SNE 689
20.5 Word embeddings 693
20.5.1 Latent semantic analysis / indexing 693
20.5.2 Word2vec 695
20.5.3 GloVE 697
20.5.4 Word analogies 698
20.5.5 RAND-WALK model of word embeddings 699
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexxiv CONTENTS
20.5.6 Contextual word embeddings 699
20.6 Exercises 700
21 Clustering 703
21.1 Introduction 703
21.1.1 Evaluating the output of clustering methods 703
21.2 Hierarchical agglomerative clustering 705
21.2.1 The algorithm 706
21.2.2 Example 708
21.2.3 Extensions 709
21.3 K means clustering 710
21.3.1 The algorithm 710
21.3.2 Examples 710
21.3.3 Vector quantization 712
21.3.4 The K-means++ algorithm 713
21.3.5 The K-medoids algorithm 713
21.3.6 Speedup tricks 714
21.3.7 Choosing the number of clusters K 714
21.4 Clustering using mixture models 718
21.4.1 Mixtures of Gaussians 718
21.4.2 Mixtures of Bernoullis 722
21.5 Spectral clustering * 723
21.5.1 Normalized cuts 723
21.5.2 Eigenvectors of the graph Laplacian encode the clustering 723
21.5.3 Example 724
21.5.4 Connection with other methods 724
21.6 Biclustering * 725
21.6.1 Basic biclustering 726
21.6.2 Nested partition models (Crosscat) 727
22 Recommender Systems 729
22.1 Explicit feedback 729
22.1.1 Datasets 729
22.1.2 Collaborative filtering 730
22.1.3 Matrix factorization 731
22.1.4 Autoencoders 733
22.2 Implicit feedback 735
22.2.1 Bayesian personalized ranking 735
22.2.2 Factorization machines 736
22.2.3 Neural matrix factorization 737
22.3 Leveraging side information 737
22.4 Exploration-exploitation tradeoff 738
23 Graph Embeddings * 741
23.1 Introduction 741
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022CONTENTS xxv
23.2 Graph Embedding as an Encoder/Decoder Problem 742
23.3 Shallow graph embeddings 744
23.3.1 Unsupervised embeddings 745
23.3.2 Distance-based: Euclidean methods 745
23.3.3 Distance-based: non-Euclidean methods 746
23.3.4 Outer product-based: Matrix factorization methods 746
23.3.5 Outer product-based: Skip-gram methods 747
23.3.6 Supervised embeddings 749
23.4 Graph Neural Networks 750
23.4.1 Message passing GNNs 750
23.4.2 Spectral Graph Convolutions 751
23.4.3 Spatial Graph Convolutions 751
23.4.4 Non-Euclidean Graph Convolutions 753
23.5 Deep graph embeddings 754
23.5.1 Unsupervised embeddings 754
23.5.2 Semi-supervised embeddings 756
23.6 Applications 757
23.6.1 Unsupervised applications 757
23.6.2 Supervised applications 759
A Notation 761
A.1 Introduction 761
A.2 Common mathematical symbols 761
A.3 Functions 762
A.3.1 Common functions of one argument 762
A.3.2 Common functions of two arguments 762
A.3.3 Common functions of > 2 arguments 762
A.4 Linear algebra 763
A.4.1 General notation 763
A.4.2 Vectors 763
A.4.3 Matrices 763
A.4.4 Matrix calculus 764
A.5 Optimization 764
A.6 Probability 765
A.7 Information theory 765
A.8 Statistics and machine learning 766
A.8.1 Supervised learning 766
A.8.2 Unsupervised learning and generative models 766
A.8.3 Bayesian inference 766
A.9 Abbreviations 767
Index 769
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensePreface
In 2012, I published a 1200-page book called Machine Learning: A Probabilistic Perspective, which
provided a fairly comprehensive coverage of the field of machine learning (ML) at that time, under
the unifying lens of probabilistic modeling. The book was well received, and won the De Groot prize
in 2013.
The year 2012 is also generally considered the start of the “deep learning revolution”. The term
“deep learning” refers to a branch of ML that is based on neural networks with many layers (hence
the term “deep”). Although this basic technology had been around for many years, it was in 2012
when [KSH12] used deep neural networks (DNNs) to win the ImageNet image classification challenge
by such a large margin that it caught the attention of the wider community. Related advances on
other hard problems, such as speech recognition, appeared around the same time (see e.g., [Cir+10;
Cir+11; Hin+12]). These breakthroughs were enabled by advances in hardware technology (in
particular, the repurposing of fast graphics processing units (GPUs) from video games to ML), data
collection technology (in particular, the use of crowd sourcing tools, such as Amazon’s Mechanical
Turk platform, to collect large labeled datasets, such as ImageNet), as well as various new algorithmic
ideas. some of which we cover in this book.
Since 2012, the field of deep learning has exploded, with new advances coming at an increasing
pace. Interest in the field has also exploded, fueled by the commercial success of the technology,
and the breadth of applications to which it can be applied. Therefore, in 2018, I decided to write a
second edition of my book, to attempt to summarize some of this progress.
By March 2020, my draft of the second edition had swollen to about 1600 pages, and I still had
many topics left to cover. As a result, MIT Press told me I would need to split the book into two
volumes. Then the COVID-19 pandemic struck. I decided to pivot away from book writing, and to
help develop the risk score algorithm for Google’s exposure notification app [MKS21] as well as to
assist with various forecasting projects [Wah+21]. However, by the Fall of 2020, I decided to return
to working on the book.
To make up for lost time, I asked several colleagues to help me finish by writing various sections (see
acknowledgements below). The result of all this is two new books, “Probabilistic Machine Learning:
An Introduction”, which you are currently reading, and “Probabilistic Machine Learning: Advanced
Topics”, which is the sequel to this book [Mur22]. Together these two books attempt to present a
fairly broad coverage of the field of ML c. 2021, using the same unifying lens of probabilistic modeling
and Bayesian decision theory that I used in the 2012 book.
Nearly all of the content from the 2012 book has been retained, but it is now split fairly evenlyxxviii Preface
between the two new books. In addition, each new book has lots of fresh material, covering topics from
deep learning, as well as advances in other parts of the field, such as generative models, variational
inference and reinforcement learning.
To make this introductory book more self-contained and useful for students, I have added some
background material, on topics such as optimization and linear algebra, that was omitted from the
2012 book due to lack of space. Advanced material, that can be skipped during an introductory
level course, is denoted by an asterisk * in the section or chapter title. Exercises can be found at
the end of some chapters. Solutions to exercises marked with an asterisk * are available to qualified
instructors by contacting MIT Press; solutions to all other exercises can be found online. See the
book web site at probml.ai for additional teaching material (e.g., figures and slides).
Another major change is that all of the software now uses Python instead of Matlab. (In the
future, we may create a Julia version of the code.) The new code leverages standard Python libraries,
such as NumPy, Scikit-learn, JAX, PyTorch, TensorFlow, PyMC3, etc. Details on how to use the
code can be found at probml.ai.
Acknowledgements
I would like to thank the following people for helping me with the book:
• Zico Kolter (CMU), who helped write parts of Chapter 7 (Linear Algebra).
• Frederik Kunstner, Si Yi Meng, Aaron Mishkin, Sharan Vaswani, and Mark Schmidt who helped
write parts of Chapter 8 (Optimization).
• Mathieu Blondel (Google), who helped write Section 13.3 (Backpropagation).
• Krzysztof Choromanski (Google), who wrote Section 15.6 (Efficient transformers *).
• Colin Raffel (UNC), who helped write Section 19.2 (Transfer learning) and Section 19.3 (Semi￾supervised learning).
• Bryan Perozzi (Google), Sami Abu-El-Haija (USC) and Ines Chami, who helped write Chapter 23
(Graph Embeddings *).
• John Fearns and Peter Cerno for carefully proofreading the book.
• Many members of the github community for finding typos, etc (see https://github.com/probml/
pml-book/issues?q=is:issue for a list of issues).
• The 4 anonymous reviewers solicited by MIT Press.
• Mahmoud Soliman for writing all the magic plumbing code that connects latex, colab, github, etc,
and for teaching me about GCP and TPUs.
• The 2021 cohort of Google Summer of Code students who worked on code for the book: Aleyna
Kara, Srikar Jilugu, Drishti Patel, Ming Liang Ang, Gerardo Durán-Martín. (See https://
probml.github.io/pml-book/gsoc2021.html for a summary of their contributions.)
• Many members of the github community for their code contributions (see https://github.com/
probml/pyprobml#acknowledgements).
• The authors of [Zha+20], [Gér17] and [Mar18] for letting me reuse or modify some of their open
source code from their own excellent books.
• My manager at Google, Doug Eck, for letting me spend company time on this book.
• My wife Margaret for letting me spend family time on this book.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022Preface xxix
About the cover
The cover illustrates a neural network (Chapter 13) being used to classify a hand-written digit x into
one of 10 class labels y ∈ {0, 1, . . . , 9}. The histogram on the right is the output of the model, and
corresponds to the conditional probability distribution p(y|x).
Kevin Patrick Murphy
Palo Alto, California
August 2021.
Changelog
• 2021-11-08. Details at https://github.com/probml/pml-book/issues/247.
• 2022-02-07. Details at https://github.com/probml/pml-book/issues/269.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1 Introduction
1.1 What is machine learning?
A popular definition of machine learning or ML, due to Tom Mitchell [Mit97], is as follows:
A computer program is said to learn from experience E with respect to some class of tasks T,
and performance measure P, if its performance at tasks in T, as measured by P, improves with
experience E.
Thus there are many different kinds of machine learning, depending on the nature of the task T we
wish the system to learn, the nature of the performance measure P we use to evaluate the system,
and the nature of the training signal or experience E we give it.
In this book, we will cover the most common types of ML, but from a probabilistic perspective.
Roughly speaking, this means that we treat all unknown quantities (e.g., predictions about the
future value of some quantity of interest, such as tomorrow’s temperature, or the parameters of some
model) as random variables, that are endowed with probability distributions which describe a
weighted set of possible values the variable may have. (See Chapter 2 for a quick refresher on the
basics of probability, if necessary.)
There are two main reasons we adopt a probabilistic approach. First, it is the optimal approach to
decision making under uncertainty, as we explain in Section 5.1. Second, probabilistic modeling
is the language used by most other areas of science and engineering, and thus provides a unifying
framework between these fields. As Shakir Mohamed, a researcher at DeepMind, put it:1
Almost all of machine learning can be viewed in probabilistic terms, making probabilistic
thinking fundamental. It is, of course, not the only view. But it is through this view that we
can connect what we do in machine learning to every other computational science, whether that
be in stochastic optimisation, control theory, operations research, econometrics, information
theory, statistical physics or bio-statistics. For this reason alone, mastery of probabilistic
thinking is essential.
1.2 Supervised learning
The most common form of ML is supervised learning. In this problem, the task T is to learn
a mapping f from inputs x ∈ X to outputs y ∈ Y. The inputs x are also called the features,
1. Source: Slide 2 of https://bit.ly/3pyHyPn2 Chapter 1. Introduction
(a) (b) (c)
Figure 1.1: Three types of Iris flowers: Setosa, Versicolor and Virginica. Used with kind permission of Dennis
Kramb and SIGNA.
index sl sw pl pw label
0 5.1 3.5 1.4 0.2 Setosa
1 4.9 3.0 1.4 0.2 Setosa
· · ·
50 7.0 3.2 4.7 1.4 Versicolor
· · ·
149 5.9 3.0 5.1 1.8 Virginica
Table 1.1: A subset of the Iris design matrix. The features are: sepal length, sepal width, petal length, petal
width. There are 50 examples of each class.
covariates, or predictors; this is often a fixed-dimensional vector of numbers, such as the height
and weight of a person, or the pixels in an image. In this case, X = R
D, where D is the dimensionality
of the vector (i.e., the number of input features). The output y is also known as the label, target, or
response.
2 The experience E is given in the form of a set of N input-output pairs D = {(xn, yn)}
N
n=1,
known as the training set. (N is called the sample size.) The performance measure P depends
on the type of output we are predicting, as we discuss below.
1.2.1 Classification
In classification problems, the output space is a set of C unordered and mutually exclusive labels
known as classes, Y = {1, 2, . . . , C}. The problem of predicting the class label given an input is
also called pattern recognition. (If there are just two classes, often denoted by y ∈ {0, 1} or
y ∈ {−1, +1}, it is called binary classification.)
1.2.1.1 Example: classifying Iris flowers
As an example, consider the problem of classifying Iris flowers into their 3 subspecies, Setosa,
Versicolor and Virginica. Figure 1.1 shows one example of each of these classes.
2. Sometimes (e.g., in the statsmodels Python package) x are called the exogenous variables and y are called the
endogenous variables.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20221.2. Supervised learning 3
Figure 1.2: Illustration of the image classification problem. From https: // cs231n. github. io/ . Used with
kind permission of Andrej Karpathy.
In image classification, the input space X is the set of images, which is a very high-dimensional
space: for a color image with C = 3 channels (e.g., RGB) and D1 × D2 pixels, we have X = R
D,
where D = C × D1 × D2. (In practice we represent each pixel intensity with an integer, typically from
the range {0, 1, . . . , 255}, but we assume real valued inputs for notational simplicity.) Learning a
mapping f : X → Y from images to labels is quite challenging, as illustrated in Figure 1.2. However,
it can be tackled using certain kinds of functions, such as a convolutional neural network or
CNN, which we discuss in Section 14.1.
Fortunately for us, some botanists have already identified 4 simple, but highly informative, numeric
features — sepal length, sepal width, petal length, petal width — which can be used to distinguish
the three kinds of Iris flowers. In this section, we will use this much lower-dimensional input space,
X = R
4
, for simplicity. The Iris dataset is a collection of 150 labeled examples of Iris flowers, 50 of
each type, described by these 4 features. It is widely used as an example, because it is small and
simple to understand. (We will discuss larger and more complex datasets later in the book.)
When we have small datasets of features, it is common to store them in an N × D matrix, in which
each row represents an example, and each column represents a feature. This is known as a design
matrix; see Table 1.1 for an example.3
The Iris dataset is an example of tabular data. When the inputs are of variable size (e.g.,
sequences of words, or social networks), rather than fixed-length vectors, the data is usually stored
3. This particular design matrix has N = 150 rows and D = 4 columns, and hence has a tall and skinny shape, since
N  D. By contrast, some datasets (e.g., genomics) have more features than examples, D  N; their design matrices
are short and fat. The term “big data” usually means that N is large, whereas the term “wide data” means that
D is large (relative to N).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license4 Chapter 1. Introduction 6
8
sepal length (cm)
2
3
4
sepal width (cm)
2.5
5.0
petal length (cm)
5.0 7.5
sepal length (cm)
0
1
2
petal width (cm)
2 4
sepal width (cm)
2.5 5.0 7.5
petal length (cm)
0 2
petal width (cm)
label
setosa
versicolor
virginica
Figure 1.3: Visualization of the Iris data as a pairwise scatter plot. On the diagonal we plot the marginal
distribution of each feature for each class. The off-diagonals contain scatterplots of all possible pairs of
features. Generated by code at figures.probml.ai/book1/1.3
in some other format rather than in a design matrix. However, such data is often converted to a
fixed-sized feature representation (a process known as featurization), thus implicitly creating a
design matrix for further processing. We give an example of this in Section 1.5.4.1, where we discuss
the “bag of words” representation for sequence data.
1.2.1.2 Exploratory data analysis
Before tackling a problem with ML, it is usually a good idea to perform exploratory data analysis,
to see if there are any obvious patterns (which might give hints on what method to choose), or any
obvious problems with the data (e.g., label noise or outliers).
For tabular data with a small number of features, it is common to make a pair plot, in which
panel (i, j) shows a scatter plot of variables i and j, and the diagonal entries (i, i) show the marginal
density of variable i; all plots are optionally color coded by class label — see Figure 1.3 for an
example.
For higher-dimensional data, it is common to first perform dimensionality reduction, and then
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20221.2. Supervised learning 5
(a)
0 1 2 3 4 5 6 7
petal length (cm)
0.5
0.0
0.5
1.0
1.5
2.0
2.5
3.0
petal width (cm)
setosa
versicolor
virginica
(b)
Figure 1.4: Example of a decision tree of depth 2 applied to the Iris data, using just the petal length and
petal width features. Leaf nodes are color coded according to the predicted class. The number of training
samples that pass from the root to a node is shown inside each box; we show how many values of each class
fall into this node. This vector of counts can be normalized to get a distribution over class labels for each
node. We can then pick the majority class. Adapted from Figures 6.1 and 6.2 of [Gér19]. Generated by code
at figures.probml.ai/book1/1.4.
to visualize the data in 2d or 3d. We discuss methods for dimensionality reduction in Chapter 20.
1.2.1.3 Learning a classifier
From Figure 1.3, we can see that the Setosa class is easy to distinguish from the other two classes.
For example, suppose we create the following decision rule:
f(x; θ) = (
Setosa if petal length < 2.45
Versicolor or Virginica otherwise
(1.1)
This is a very simple example of a classifier, in which we have partitioned the input space into two
regions, defined by the one-dimensional (1d) decision boundary at xpetal length = 2.45. Points
lying to the left of this boundary are classified as Setosa; points to the right are either Versicolor or
Virginica.
We see that this rule perfectly classifies the Setosa examples, but not the Virginica and Versicolor
ones. To improve performance, we can recursively partition the space, by splitting regions in which
the classifier makes errors. For example, we can add another decision rule, to be applied to inputs
that fail the first test, to check if the petal width is below 1.75cm (in which case we predict Versicolor)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license6 Chapter 1. Introduction
Estimate
Setosa Versicolor Virginica
Truth
Setosa 0 1 1
Versicolor 1 0 1
Virginica 10 10 0
Table 1.2: Hypothetical asymmetric loss matrix for Iris classification.
or above (in which case we predict Virginica). We can arrange these nested rules into a tree structure,
called a decision tree, as shown in Figure 1.4a This induces the 2d decision surface shown in
Figure 1.4b.
We can represent the tree by storing, for each internal node, the feature index that is used, as well
as the corresponding threshold value. We denote all these parameters by θ. We discuss how to
learn these parameters in Section 18.1.
1.2.1.4 Empirical risk minimization
The goal of supervised learning is to automatically come up with classification models such as the
one shown in Figure 1.4a, so as to reliably predict the labels for any given input. A common way to
measure performance on this task is in terms of the misclassification rate on the training set:
L(θ) ,
1
N
X
N
n=1
I(yn 6= f(xn; θ)) (1.2)
where I(e) is the binary indicator function, which returns 1 iff (if and only if) the condition e is
true, and returns 0 otherwise, i.e.,
I(e) = 
1 if e is true
0 if e is false (1.3)
This assumes all errors are equal. However it may be the case that some errors are more costly
than others. For example, suppose we are foraging in the wilderness and we find some Iris flowers.
Furthermore, suppose that Setosa and Versicolor are tasty, but Virginica is poisonous. In this case,
we might use the asymmetric loss function `(y, yˆ) shown in Table 1.2.
We can then define empirical risk to be the average loss of the predictor on the training set:
L(θ) ,
1
N
X
N
n=1
`(yn, f(xn; θ)) (1.4)
We see that the misclassification rate Equation (1.2) is equal to the empirical risk when we use
zero-one loss for comparing the true label with the prediction:
`01(y, yˆ) = I(y 6= ˆy) (1.5)
See Section 5.1 for more details.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20221.2. Supervised learning 7
One way to define the problem of model fitting or training is to find a setting of the parameters
that minimizes the empirical risk on the training set:
θˆ = argmin
θ
L(θ) = argmin
θ
1
N
X
N
n=1
`(yn, f(xn; θ)) (1.6)
This is called empirical risk minimization.
However, our true goal is to minimize the expected loss on future data that we have not yet
seen. That is, we want to generalize, rather than just do well on the training set. We discuss this
important point in Section 1.2.3.
1.2.1.5 Uncertainty
[We must avoid] false confidence bred from an ignorance of the probabilistic nature of the
world, from a desire to see black and white where we should rightly see gray. — Immanuel
Kant, as paraphrased by Maria Konnikova [Kon20].
In many cases, we will not be able to perfectly predict the exact output given the input, due to
lack of knowledge of the input-output mapping (this is called epistemic uncertainty or model
uncertainty), and/or due to intrinsic (irreducible) stochasticity in the mapping (this is called
aleatoric uncertainty or data uncertainty).
Representing uncertainty in our prediction can be important for various applications. For example,
let us return to our poisonous flower example, whose loss matrix is shown in Table 1.2. If we predict
the flower is Virginica with high probability, then we should not eat the flower. Alternatively, we
may be able to perform an information gathering action, such as performing a diagnostic test, to
reduce our uncertainty. For more information about how to make optimal decisions in the presence
of uncertainty, see Section 5.1.
We can capture our uncertainty using the following conditional probability distribution:
p(y = c|x; θ) = fc(x; θ) (1.7)
where f : X → [0, 1]C maps inputs to a probability distribution over the C possible output labels.
Since fc(x; θ) returns the probability of class label c, we require 0 ≤ fc ≤ 1 for each c, and PC
c=1 fc = 1.
To avoid this restriction, it is common to instead require the model to return unnormalized log￾probabilities. We can then convert these to probabilities using the softmax function, which is
defined as follows
S(a) ,
"
e
a1
PC
c
0=1 e
ac0
, . . . ,
e
aC
PC
c
0=1 e
ac0
#
(1.8)
This maps R
C to [0, 1]C , and satisfies the constraints that 0 ≤ S(a)c ≤ 1 and PC
c=1 S(a)c = 1. The
inputs to the softmax, a = f(x; θ), are called logits. See Section 2.5.2 for details. We thus define
the overall model as follows:
p(y = c|x; θ) = Sc(f(x; θ)) (1.9)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license8 Chapter 1. Introduction
A common special case of this arises when f is an affine function of the form
f(x; θ) = b + wTx = b + w1x1 + w2x2 + · · · + wDxD (1.10)
where θ = (b, w) are the parameters of the model. This model is called logistic regression, and
will be discussed in more detail in Chapter 10.
In statistics, the w parameters are usually called regression coefficients (and are typically
denoted by β) and b is called the intercept. In ML, the parameters w are called the weights and b
is called the bias. This terminology arises from electrical engineering, where we view the function f
as a circuit which takes in x and returns f(x). Each input is fed to the circuit on “wires”, which
have weights w. The circuit computes the weighted sum of its inputs, and adds a constant bias or
offset term b. (This use of the term “bias” should not be confused with the statistical concept of bias
discussed in Section 4.7.6.1.)
To reduce notational clutter, it is common to absorb the bias term b into the weights w by defining
w˜ = [b, w1, . . . , wD] and defining x˜ = [1, x1, . . . , xD], so that
w˜
Tx˜ = b + wTx (1.11)
This converts the affine function into a linear function. We will usually assume that this has been
done, so we can just write the prediction function as follows:
f(x; w) = wTx (1.12)
1.2.1.6 Maximum likelihood estimation
When fitting probabilistic models, it is common to use the negative log probability as our loss
function:
`(y, f(x; θ)) = − log p(y|f(x; θ)) (1.13)
The reasons for this are explained in Section 5.1.6.1, but the intuition is that a good model (with low
loss) is one that assigns a high probability to the true output y for each corresponding input x. The
average negative log probability of the training set is given by
NLL(θ) = −
1
N
X
N
n=1
log p(yn|f(xn; θ)) (1.14)
This is called the negative log likelihood. If we minimize this, we can compute the maximum
likelihood estimate or MLE:
θˆmle = argmin
θ
NLL(θ) (1.15)
This is a very common way to fit models to data, as we will see.
1.2.2 Regression
Now suppose that we want to predict a real-valued quantity y ∈ R instead of a class label y ∈
{1, . . . , C}; this is known as regression. For example, in the case of Iris flowers, y might be the
degree of toxicity if the flower is eaten, or the average height of the plant.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20221.2. Supervised learning 9
Regression is very similar to classification. However, since the output is real-valued, we need to
use a different loss function. For regression, the most common choice is to use quadratic loss, or `2
loss:
`2(y, yˆ) = (y − yˆ)
2
(1.16)
This penalizes large residuals y − yˆ more than small ones.4 The empirical risk when using quadratic
loss is equal to the mean squared error or MSE:
MSE(θ) = 1
N
X
N
n=1
(yn − f(xn; θ))2
(1.17)
Based on the discussion in Section 1.2.1.5, we should also model the uncertainty in our prediction.
In regression problems, it is common to assume the output distribution is a Gaussian or normal.
As we explain in Section 2.6, this distribution is defined by
N (y|µ, σ2
) ,
1
√
2πσ2
e
− 1
2σ2
(y−µ)
2
(1.18)
where µ is the mean, σ
2
is the variance, and √
2πσ2 is the normalization constant needed to ensure
the density integrates to 1. In the context of regression, we can make the mean depend on the inputs
by defining µ = f(xn; θ). We therefore get the following conditional probability distribution:
p(y|x; θ) = N (y|f(x; θ), σ2
) (1.19)
If we assume that the variance σ
2
is fixed (for simplicity), the corresponding negative log likelihood
becomes
NLL(θ) = −
1
N
X
N
n=1
log "
1
2πσ2
1
2
exp 
−
1
2σ
2
(yn − f(xn; θ))2
#
(1.20)
=
1
2σ
2 MSE(θ) + const (1.21)
We see that the NLL is proportional to the MSE. Hence computing the maximum likelihood estimate
of the parameters will result in minimizing the squared error, which seems like a sensible approach to
model fitting.
1.2.2.1 Linear regression
As an example of a regression model, consider the 1d data in Figure 1.5a. We can fit this data using
a simple linear regression model of the form
f(x; θ) = b + wx (1.22)
4. If the data has outliers, the quadratic penalty can be too severe. In such cases, it can be better to use `1 loss
instead, which is more robust. See Section 11.6 for details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license10 Chapter 1. Introduction
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
7.5
5.0
2.5
0.0
2.5
5.0
7.5
10.0
(a)
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
7.5
5.0
2.5
0.0
2.5
5.0
7.5
10.0
(b)
Figure 1.5: (a) Linear regression on some 1d data. (b) The vertical lines denote the residuals between
the observed output value for each input (blue circle) and its predicted value (red cross). The goal of least
squares regression is to pick a line that minimizes the sum of squared residuals. Generated by code at
figures.probml.ai/book1/1.5.
where w is the slope, b is the offset, and θ = (w, b) are all the parameters of the model. By adjusting
θ, we can minimize the sum of squared errors, shown by the vertical lines in Figure 1.5b. until we
find the least squares solution
θˆ = argmin
θ
MSE(θ) (1.23)
See Section 11.2.2.1 for details.
If we have multiple input features, we can write
f(x; θ) = b + w1x1 + · · · + wDxD = b + wTx (1.24)
where θ = (w, b). This is called multiple linear regression.
For example, consider the task of predicting temperature as a function of 2d location in a room.
Figure 1.6(a) plots the results of a linear model of the following form:
f(x; θ) = b + w1x1 + w2x2 (1.25)
We can extend this model to use D > 2 input features (such as time of day), but then it becomes
harder to visualize.
1.2.2.2 Polynomial regression
The linear model in Figure 1.5a is obviously not a very good fit to the data. We can improve the
fit by using a polynomial regression model of degree D. This has the form f(x; w) = wTφ(x),
where φ(x) is a feature vector derived from the input, which has the following form:
φ(x) = [1, x, x2
, . . . , xD] (1.26)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20221.2. Supervised learning 11
0
5
10 15 20 25 30 35 40 0
5
10
15
20
25
30
15.0
15.5
16.0
16.5
17.0
17.5
18.0
18.5
19.0
(a)
0
5
10 15 20 25 30 35 40 0
5
10
15
20
25
30
15.0
15.5
16.0
16.5
17.0
17.5
18.0
18.5
19.0
(b)
Figure 1.6: Linear and polynomial regression applied to 2d data. Vertical axis is temperature, horizontal
axes are location within a room. Data was collected by some remote sensing motes at Intel’s lab in Berkeley,
CA (data courtesy of Romain Thibaux). (a) The fitted plane has the form ˆf(x) = w0 + w1x1 + w2x2. (b)
Temperature data is fitted with a quadratic of the form ˆf(x) = w0 + w1x1 + w2x2 + w3x
2
1 + w4x
2
2. Generated
by code at figures.probml.ai/book1/1.6.
This is a simple example of feature preprocessing, also called feature engineering.
In Figure 1.7a, we see that using D = 2 results in a much better fit. We can keep increasing D, and
hence the number of parameters in the model, until D = N − 1; in this case, we have one parameter
per data point, so we can perfectly interpolate the data. The resulting model will have 0 MSE, as
shown in Figure 1.7c. However, intuitively the resulting function will not be a good predictor for
future inputs, since it is too “wiggly”. We discuss this in more detail in Section 1.2.3.
We can also apply polynomial regression to multi-dimensional inputs. For example, Figure 1.6(b)
plots the predictions for the temperature model after performing a quadratic expansion of the inputs
f(x; w) = w0 + w1x1 + w2x2 + w3x
2
1 + w4x
2
2
(1.27)
The quadratic shape is a better fit to the data than the linear model in Figure 1.6(a), since it captures
the fact that the middle of the room is hotter. We can also add cross terms, such as x1x2, to capture
interaction effects. See Section 1.5.3.2 for details.
Note that the above models still use a prediction function that is a linear function of the parameters
w, even though it is a nonlinear function of the original input x. The reason this is important is
that a linear model induces an MSE loss function MSE(θ) that has a unique global optimum, as we
explain in Section 11.2.2.1.
1.2.2.3 Deep neural networks
In Section 1.2.2.2, we manually specified the transformation of the input features, namely polynomial
expansion, φ(x) = [1, x1, x2, x2
1
, x2
2
, . . .]. We can create much more powerful models by learning to
do such nonlinear feature extraction automatically. If we let φ(x) have its own set of parameters,
say V, then the overall model has the form
f(x; w, V) = wTφ(x; V) (1.28)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license12 Chapter 1. Introduction
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
10
5
0
5
10
15
degree 2
(a)
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
10
5
0
5
10
15
degree 14
(b)
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
10
5
0
5
10
15
degree 20
(c)
2 4 6 8 10 12 14
degree
0
2
4
6
8
10
12
14
16
mse
test
train
(d)
Figure 1.7: (a-c) Polynomials of degrees 2, 14 and 20 fit to 21 datapoints (the same data as in Figure 1.5).
(d) MSE vs degree. Generated by code at figures.probml.ai/book1/1.7.
We can recursively decompose the feature extractor φ(x; V) into a composition of simpler functions.
The resulting model then becomes a stack of L nested functions:
f(x; θ) = fL(fL−1(· · ·(f1(x))· · ·)) (1.29)
where f`(x) = f(x; θ`) is the function at layer `. The final layer is linear and has the form
fL(x) = wTf1:L−1(x), where f1:L−1(x) is the learned feature extractor. This is the key idea behind
deep neural networks or DNNs, which includes common variants such as convolutional neural
networks (CNNs) for images, and recurrent neural networks (RNNs) for sequences. See Part III
for details.
1.2.3 Overfitting and generalization
We can rewrite the empirical risk in Equation (1.4) in the following equivalent way:
L(θ; Dtrain) = 1
|Dtrain|
X
(x,y)∈Dtrain
`(y, f(x; θ)) (1.30)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20221.2. Supervised learning 13
where |Dtrain| is the size of the training set Dtrain. This formulation is useful because it makes explicit
which dataset the loss is being evaluated on.
With a suitably flexible model, we can drive the training loss to zero (assuming no label noise), by
simply memorizing the correct output for each input. For example, Figure 1.7(c) perfectly interpolates
the training data (modulo the last point on the right). But what we care about is prediction accuracy
on new data, which may not be part of the training set. A model that perfectly fits the training
data, but which is too complex, is said to suffer from overfitting.
To detect if a model is overfitting, let us assume (for now) that we have access to the true (but
unknown) distribution p
∗
(x, y) used to generate the training set. Then, instead of computing the
empirical risk we compute the theoretical expected loss or population risk
L(θ; p
∗
) , Ep∗(x,y)
[`(y, f(x; θ))] (1.31)
The difference L(θ; p
∗
) − L(θ; Dtrain) is called the generalization gap. If a model has a large
generalization gap (i.e., low empirical risk but high population risk), it is a sign that it is overfitting.
In practice we don’t know p
∗
. However, we can partition the data we do have into two subsets,
known as the training set and the test set. Then we can approximate the population risk using the
test risk:
L(θ; Dtest) ,
1
|Dtest|
X
(x,y)∈Dtest
`(y, f(x; θ)) (1.32)
As an example, in Figure 1.7d, we plot the training error and test error for polynomial regression
as a function of degree D. We see that the training error goes to 0 as the model becomes more
complex. However, the test error has a characteristic U-shaped curve: on the left, where D = 1,
the model is underfitting; on the right, where D  1, the model is overfitting; and when D = 2,
the model complexity is “just right”.
How can we pick a model of the right complexity? If we use the training set to evaluate different
models, we will always pick the most complex model, since that will have the most degrees of
freedom, and hence will have minimum loss. So instead we should pick the model with minimum
test loss.
In practice, we need to partition the data into three sets, namely the training set, the test set and
a validation set; the latter is used for model selection, and we just use the test set to estimate
future performance (the population risk), i.e., the test set is not used for model fitting or model
selection. See Section 4.5.4 for further details.
1.2.4 No free lunch theorem
All models are wrong, but some models are useful. — George Box [BD87, p424].5
Given the large variety of models in the literature, it is natural to wonder which one is best.
Unfortunately, there is no single best model that works optimally for all kinds of problems — this
is sometimes called the no free lunch theorem [Wol96]. The reason is that a set of assumptions
(also called inductive bias) that works well in one domain may work poorly in another. The best
5. George Box is a retired statistics professor at the University of Wisconsin.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license14 Chapter 1. Introduction
way to pick a suitable model is based on domain knowledge, and/or trial and error (i.e., using model
selection techniques such as cross validation (Section 4.5.4) or Bayesian methods (Section 5.2.2)).
For this reason, it is important to have many models and algorithmic techniques in one’s toolbox to
choose from.
1.3 Unsupervised learning
In supervised learning, we assume that each input example x in the training set has an associated
set of output targets y, and our goal is to learn the input-output mapping. Although this is useful,
and can be difficult, supervised learning is essentially just “glorified curve fitting” [Pea18].
An arguably much more interesting task is to try to “make sense of” data, as opposed to just
learning a mapping. That is, we just get observed “inputs” D = {xn : n = 1 : N} without any
corresponding “outputs” yn. This is called unsupervised learning.
From a probabilistic perspective, we can view the task of unsupervised learning as fitting an
unconditional model of the form p(x), which can generate new data x, whereas supervised learning
involves fitting a conditional model, p(y|x), which specifies (a distribution over) outputs given
inputs.6
Unsupervised learning avoids the need to collect large labeled datasets for training, which can
often be time consuming and expensive (think of asking doctors to label medical images).
Unsupervised learning also avoids the need to learn how to partition the world into often arbitrary
categories. For example, consider the task of labeling when an action, such as “drinking” or “sipping”,
occurs in a video. Is it when the person picks up the glass, or when the glass first touches the mouth,
or when the liquid pours out? What if they pour out some liquid, then pause, then pour again — is
that two actions or one? Humans will often disagree on such issues [Idr+17], which means the task is
not well defined. It is therefore not reasonable to expect machines to learn such mappings.7
Finally, unsupervised learning forces the model to “explain” the high-dimensional inputs, rather
than just the low-dimensional outputs. This allows us to learn richer models of “how the world works”.
As Geoff Hinton, who is a famous professor of ML at the University of Toronto, has said:
When we’re learning to see, nobody’s telling us what the right answers are — we just look.
Every so often, your mother says “that’s a dog”, but that’s very little information. You’d be
lucky if you got a few bits of information — even one bit per second — that way. The brain’s
visual system has 1014 neural connections. And you only live for 109
seconds. So it’s no use
learning one bit per second. You need more like 105 bits per second. And there’s only one place
you can get that much information: from the input itself. — Geoffrey Hinton, 1996 (quoted in
[Gor06]).
1.3.1 Clustering
A simple example of unsupervised learning is the problem of finding clusters in data. The goal is to
partition the input into regions that contain “similar” points. As an example, consider a 2d version
6. In the statistics community, it is common to use x to denote exogenous variables that are not modeled, but are
simply given as inputs. Therefore an unconditional model would be denoted p(y) rather than p(x).
7. A more reasonable approach is to try to capture the probability distribution over labels produced by a “crowd” of
annotators (see e.g., [Dum+18; Aro+19]). This embraces the fact that there can be multiple “correct” labels for a
given input due to the ambiguity of the task itself.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20221.3. Unsupervised learning 15
1 2 3 4 5 6 7
petal length (cm)
0.0
0.5
1.0
1.5
2.0
2.5
petal width (cm)
(a)
1 2 3 4 5 6 7
petal length (cm)
0.0
0.5
1.0
1.5
2.0
2.5
petal width (cm)
Cluster 0
Cluster 1
Cluster 2
(b)
Figure 1.8: (a) A scatterplot of the petal features from the iris dataset. (b) The result of unsupervised
clustering using K = 3. Generated by code at figures.probml.ai/book1/1.8.
sepal length
4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0
sepal width
2.0
2.5
3.0
3.5
4.0
4.5
petal length
1
2
3
4
5
6
7
(a)
sepal length
4
5
6
7
8
2.0 sepal width
2.5
3.0
3.5
4.0
4.5
petal length
1
2
3
4
5
6
7
(b)
Figure 1.9: (a) Scatterplot of iris data (first 3 features). Points are color coded by class. (b) We fit a 2d
linear subspace to the 3d data using PCA. The class labels are ignored. Red dots are the original data, black
dots are points generated from the model using xˆ = Wz + µ, where z are latent points on the underlying
inferred 2d linear manifold. Generated by code at figures.probml.ai/book1/1.9.
of the Iris dataset. In Figure 1.8a, we show the points without any class labels. Intuitively there
are at least two clusters in the data, one in the bottom left and one in the top right. Furthermore,
if we assume that a “good” set of clusters should be fairly compact, then we might want to split
the top right into (at least) two subclusters. The resulting partition into three clusters is shown
in Figure 1.8b. (Note that there is no correct number of clusters; instead, we need to consider the
tradeoff between model complexity and fit to the data. We discuss ways to make this tradeoff in
Section 21.3.7.)
1.3.2 Discovering latent “factors of variation”
When dealing with high-dimensional data, it is often useful to reduce the dimensionality by projecting
it to a lower dimensional subspace which captures the “essence” of the data. One approach to this
problem is to assume that each observed high-dimensional output xn ∈ R
D was generated by a set
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license16 Chapter 1. Introduction
of hidden or unobserved low-dimensional latent factors zn ∈ R
K. We can represent the model
diagrammatically as follows: zn → xn, where the arrow represents causation. Since we don’t know
the latent factors zn, we often assume a simple prior probability model for p(zn) such as a Gaussian,
which says that each factor is a random K-dimensional vector. If the data is real-valued, we can use
a Gaussian likelihood as well.
The simplest example is when we use a linear model, p(xn|zn; θ) = N (xn|Wzn + µ, Σ). The
resulting model is called factor analysis (FA). It is similar to linear regression, except we only
observe the outputs xn, and not the inputs zn. In the special case that Σ = σ
2
I, this reduces to
a model called probabilistic principal components analysis (PCA), which we will explain in
Section 20.1. In Figure 1.9, we give an illustration of how this method can find a 2d linear subspace
when applied to some simple 3d data.
Of course, assuming a linear mapping from zn to xn is very restrictive. However, we can create
nonlinear extensions by defining p(xn|zn; θ) = N (xn|f(zn; θ), σ2
I), where f(z; θ) is a nonlinear
model, such as a deep neural network. It becomes much harder to fit such a model (i.e., to estimate the
parameters θ), because the inputs to the neural net have to be inferred, as well as the parameters of
the model. However, there are various approximate methods, such as the variational autoencoder
which can be applied (see Section 20.3.5).
1.3.3 Self-supervised learning
A recently popular approach to unsupervised learning is known as self-supervised learning. In this
approach, we create proxy supervised tasks from unlabeled data. For example, we might try to learn
to predict a color image from a grayscale image, or to mask out words in a sentence and then try to
predict them given the surrounding context. The hope is that the resulting predictor xˆ1 = f(x2; θ),
where x2 is the observed input and xˆ1 is the predicted output, will learn useful features from the
data, that can then be used in standard, downstream supervised tasks. This avoids the hard problem
of trying to infer the “true latent factors” z behind the observed data, and instead relies on standard
supervised learning methods. We discuss this approach in more detail in Section 19.2.
1.3.4 Evaluating unsupervised learning
Although unsupervised learning is appealing, it is very hard to evaluate the quality of the output of
an unsupervised learning method, because there is no ground truth to compare to [TOB16].
A common method for evaluating unsupervised models is to measure the probability assigned by
the model to unseen test examples. We can do this by computing the (unconditional) negative log
likelihood of the data:
L(θ; D) = −
1
|D|
X
x∈D
log p(x|θ) (1.33)
This treats the problem of unsupervised learning as one of density estimation. The idea is that a
good model will not be “surprised” by actual data samples (i.e., will assign them high probability).
Furthermore, since probabilities must sum to 1.0, if the model assigns high probability to regions of
data space where the data samples come from, it implicitly assigns low probability to the regions
where the data does not come from. Thus the model has learned to capture the typical patterns
in the data. This can be used inside of a data compression algorithm.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20221.4. Reinforcement learning 17
(a) (b)
Figure 1.10: Examples of some control problems. (a) Space Invaders Atari game. From https: // gym.
openai. com/ envs/ SpaceInvaders-v0/ . (b) Controlling a humanoid robot in the MuJuCo simulator so it
walks as fast as possible without falling over. From https: // gym. openai. com/ envs/ Humanoid-v2/ .
Unfortunately, density estimation is difficult, especially in high dimensions. Furthermore, a model
that assigns high probability to the data may not have learned useful high-level patterns (after all,
the model could just memorize all the training examples).
An alternative evaluation metric is to use the learned unsupervised representation as features or
input to a downstream supervised learning method. If the unsupervised method has discovered useful
patterns, then it should be possible to use these patterns to perform supervised learning using much
less labeled data than when working with the original features. For example, in Section 1.2.1.1, we
saw how the 4 manually defined features of iris flowers contained most of the information needed
to perform classification. We were thus able to train a classifier with nearly perfect performance
using just 150 examples. If the input was raw pixels, we would need many more examples to achieve
comparable performance (see Section 14.1). That is, we can increase the sample efficiency of
learning (i.e., reduce the number of labeled examples needed to get good performance) by first
learning a good representation.
Increased sample efficiency is a useful evaluation metric, but in many applications, especially in
science, the goal of unsupervised learning is to gain understanding, not to improve performance on
some prediction task. This requires the use of models that are interpretable, but which can also
generate or “explain” most of the observed patterns in the data. To paraphrase Plato, the goal is
to discover how to “carve nature at its joints”. Of course, evaluating whether we have successfully
discovered the true underlying structure behind some dataset often requires performing experiments
and thus interacting with the world. We discuss this topic further in Section 1.4.
1.4 Reinforcement learning
In addition to supervised and unsupervised learning, there is a third kind of ML known as reinforce￾ment learning (RL). In this class of problems, the system or agent has to learn how to interact
with its environment. This can be encoded by means of a policy a = π(x), which specifies which
action to take in response to each possible input x (derived from the environment state).
For example, consider an agent that learns to play a video game, such as Atari Space Invaders (see
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license18 Chapter 1. Introduction
Figure 1.11: The three types of machine learning visualized as layers of a chocolate cake. This figure (originally
from https: // bit. ly/ 2m65Vs1 ) was used in a talk by Yann LeCun at NIPS’16, and is used with his kind
permission.
Figure 1.10a). In this case, the input x is the image (or sequence of past images), and the output a
is the direction to move in (left or right) and whether to fire a missile or not. As a more complex
example, consider the problem of a robot learning to walk (see Figure 1.10b). In this case, the input
x is the set of joint positions and angles for all the limbs, and the output a is a set of actuation or
motor control signals.
The difference from supervised learning (SL) is that the system is not told which action is the
best one to take (i.e., which output to produce for a given input). Instead, the system just receives
an occasional reward (or punishment) signal in response to the actions that it takes. This is like
learning with a critic, who gives an occasional thumbs up or thumbs down, as opposed to learning
with a teacher, who tells you what to do at each step.
RL has grown in popularity recently, due to its broad applicability (since the reward signal that
the agent is trying to optimize can be any metric of interest). However, it can be harder to make RL
work than it is for supervised or unsupervised learning, for a variety of reasons. A key difficulty is
that the reward signal may only be given occasionally (e.g., if the agent eventually reaches a desired
state), and even then it may be unclear to the agent which of its many actions were responsible for
getting the reward. (Think of playing a game like chess, where there is a single win or lose signal at
the end of the game.)
To compensate for the minimal amount of information coming from the reward signal, it is common
to use other information sources, such as expert demonstrations, which can be used in a supervised
way, or unlabeled data, which can be used by an unsupervised learning system to discover the
underlying structure of the environment. This can make it feasible to learn from a limited number of
trials (interactions with the environment). As Yann LeCun put it, in an invited talk at the NIPS8
conference in 2016: “If intelligence was a cake, unsupervised learning would be the chocolate sponge,
supervised learning would be the icing, and reinforcement learning would be the cherry.” This is
illustrated in Figure 1.11.
8. NIPS stands for “Neural Information Processing Systems”. It is one of the premier ML conferences. It has recently
been renamed to NeurIPS.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20221.5. Data 19
(a)
a 6 3 M c
5 9 l 4 7
u T e t 6
t v h 6 3
7 W 3 e 9
(b)
Figure 1.12: (a) Visualization of the MNIST dataset. Each image is 28 × 28. There are 60k training
examples and 10k test examples. We show the first 25 images from the training set. Generated by code at
figures.probml.ai/book1/1.12. (b) Visualization of the EMNIST dataset. There are 697,932 training examples,
and 116,323 test examples, each of size 28 × 28. There are 62 classes (a-z, A-Z, 0-9). We show the first 25
images from the training set. Generated by code at figures.probml.ai/book1/1.12.
More information on RL can be found in the sequel to this book, [Mur22].
1.5 Data
Machine learning is concerned with fitting models to data using various algorithms. Although we
focus on the modeling and algorithm aspects, it is important to mention that the nature and quality
of the training data also plays a vital role in the success of any learned model.
In this section, we briefly describe some common image and text datasets that we will use in this
book. We also briefly discuss the topic of data preprocessing.
1.5.1 Some common image datasets
In this section, we briefly discuss some image datasets that we will use in this book.
1.5.1.1 Small image datasets
One of the simplest and most widely used is known as MNIST [LeC+98; YB19].9 This is a dataset
of 60k training images and 10k test images, each of size 28 × 28 (grayscale), illustrating handwritten
digits from 10 categories. Each pixel is an integer in the range {0, 1, . . . , 255}; these are usually
rescaled to [0, 1], to represent pixel intensity. We can optionally convert this to a binary image by
thresholding. See Figure 1.12a for an illustration.
9. The term “MNIST” stands for “Modified National Institute of Standards”; The term “modified” is used because the
images have been preprocessed to ensure the digits are mostly in the center of the image.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license20 Chapter 1. Introduction
(a) (b)
Figure 1.13: (a) Visualization of the Fashion-MNIST dataset [XRV17]. The dataset has the same size as
MNIST, but is harder to classify. There are 10 classes: T-shirt/top, Trouser, Pullover, Dress, Coat, Sandal,
Shirt, Sneaker, Bag, Ankle-boot. We show the first 25 images from the training set. Generated by code at
figures.probml.ai/book1/1.13. (b) Some images from the CIFAR-10 dataset [KH09]. Each image is 32×32×3,
where the final dimension of size 3 refers to RGB. There are 50k training examples and 10k test examples.
There are 10 classes: plane, car, bird, cat, deer, dog, frog, horse, ship, and truck. We show the first 25 images
from the training set. Generated by code at figures.probml.ai/book1/1.13.
MNIST is so widely used in the ML community that Geoff Hinton, a famous ML researcher, has
called it the “drosophila of machine learning”, since if we cannot make a method work well on MNIST,
it will likely not work well on harder datasets. However, nowadays MNIST classification is considered
“too easy”, since it is possible to distinguish most pairs of digits by looking at just a single pixel.
Various extensions have been proposed.
In [Coh+17], they proposed EMNIST (extended MNIST), that also includes lower and upper
case letters. See Figure 1.12b for a visualization. This dataset is much harder than MNIST, since
there are 62 classes, several of which are quite ambiguous (e.g., the digit 1 vs the lower case letter l).
In [XRV17], they proposed Fashion-MNIST, which has exactly the same size and shape as
MNIST, but where each image is the picture of a piece of clothing instead of a handwritten digit.
See Figure 1.13a for a visualization.
For small color images, the most common dataset is CIFAR [KH09].10 This is a dataset of 60k
images, each of size 32×32×3, representing everyday objects from 10 or 100 classes; see Figure 1.13b
for an illustration.
1.5.1.2 ImageNet
Small datasets are useful for prototyping ideas, but it is also important to test methods on larger
datasets, both in terms of image size and number of labeled examples. The most widely used dataset
10. CIFAR stands for “Canadian Institute For Advanced Research”. This is the agency that funded labeling of
the dataset, which was derived from the TinyImages dataset at http://groups.csail.mit.edu/vision/TinyImages/
created by Antonio Torralba. See [KH09] for details.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20221.5. Data 21
(a) (b)
Figure 1.14: (a) Sample images from the ImageNet dataset [Rus+15]. This subset consists of 1.3M color
training images, each of which is 256 × 256 pixels in size. There are 1000 possible labels, one per image, and
the task is to minimize the top-5 error rate, i.e., to ensure the correct label is within the 5 most probable
predictions. Below each image we show the true label, and a distribution over the top 5 predicted labels. If the
true label is in the top 5, its probability bar is colored red. Predictions are generated by a convolutional neural
network (CNN) called “AlexNet” (Section 14.3.2). From Figure 4 of [KSH12]. Used with kind permission of
Alex Krizhevsky. (b) Misclassification rate (top 5) on the ImageNet competition over time. Used with kind
permission of Andrej Karpathy.
of this type is called ImageNet [Rus+15]. This is a dataset of ∼ 14M images of size 256 × 256 × 3
illustrating various objects from 20,000 classes; see Figure 1.14a for some examples.
The ImageNet dataset was used as the basis of the ImageNet Large Scale Visual Recognition
Challenge (ILSVRC), which ran from 2010 to 2018. This used a subset of 1.3M images from 1000
classes. During the course of the competition, significant progress was made by the community, as
shown in Figure 1.14b. In particular, 2015 marked the first year in which CNNs could outperform
humans (or at least one human, namely Andrej Karpathy) at the task of classifying images from
ImageNet. Note that this does not mean that CNNs are better at vision than humans (see e.g.,
[YL21] for some common failure modes). Instead, it mostly likely reflects the fact that the dataset
makes many fine-grained classification distinctions — such as between a “tiger” and a “tiger cat”
— that humans find difficult to understand; by contrast, sufficiently flexible CNNs can learn arbitrary
patterns, including random labels [Zha+17a].
Although ImageNet is much harder than MNIST and CIFAR as a classification benchmark, it too
is almost “saturated” [Bey+20]. Nevertheless, relative performance of methods on ImageNet is often
a surprisingly good predictor of performance on other, unrelated image classification tasks (see e.g.,
[Rec+19]), so it remains very widely used.
1.5.2 Some common text datasets
Machine learning is often applied to text to solve a variety of tasks. This is known as natural
language processing or NLP (see e.g., [JM20] for details). Below we briefly mention a few text
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license22 Chapter 1. Introduction
1. this film was just brilliant casting location scenery story direction everyone’s really suited the part they played robert
<UNK> is an amazing actor ...
2. big hair big boobs bad music and a giant safety pin these are the words to best describe this terrible movie i love cheesy
horror movies and i’ve seen hundreds...
Table 1.3: We show snippets of the first two sentences from the IMDB movie review dataset. The first example
is labeled positive and the second negative. (<UNK> refers to an unknown token.)
datasets that we will use in this book.
1.5.2.1 Text classification
A simple NLP task is text classification, which can be used for email spam classification, senti￾ment analysis (e.g., is a movie or product review positive or negative), etc. A common dataset for
evaluating such methods is the IMDB movie review dataset from [Maa+11]. (IMDB stands for
“Internet Movie Database”.) This contains 25k labeled examples for training, and 25k for testing.
Each example has a binary label, representing a positive or negative rating. See Table 1.3 for some
example sentences.
1.5.2.2 Machine translation
A more difficult NLP task is to learn to map a sentence x in one language to a “semantically equivalent”
sentence y in another language; this is called machine translation. Training such models requires
aligned (x, y) pairs. Fortunately, several such datasets exist, e.g., from the Canadian parliament
(English-French pairs), and the European Union (Europarl). A subset of the latter, known as the
WMT dataset (Workshop on Machine Translation), consists of English-German pairs, and is widely
used as a benchmark dataset.
1.5.2.3 Other seq2seq tasks
A generalization of machine translation is to learn a mapping from one sequence x to any other
sequence y. This is called a seq2seq model, and can be viewed as a form of high-dimensional
classification (see Section 15.2.3 for details). This framing of the problem is very general, and
includes many tasks, such as document summarization, question answering, etc. For example,
Table 1.4 shows how to formulate question answering as a seq2seq problem: the input is the text T
and question Q, and the output is the answer A, which is a set of words, possibly extracted from the
input.
1.5.2.4 Language modeling
The rather grandiose term “language modeling” refers to the task of creating unconditional
generative models of text sequences, p(x1, . . . , xT ). This only requires input sentences x, without
any corresponding “labels” y. We can therefore think of this as a form of unsupervised learning,
which we discuss in Section 1.3. If the language model generates output in response to an input, as
in seq2seq, we can regard it as a conditional generative model.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20221.5. Data 23
T: In meteorology, precipitation is any product of the condensation of atmospheric water vapor that falls under gravity. The
main forms of precipitation include drizzle, rain, sleet, snow, graupel and hail... Precipitation forms as smaller droplets
coalesce via collision with other rain drops or ice crystals within a cloud. Short, intense periods of rain in scattered
locations are called “showers”.
Q1: What causes precipitation to fall? A1: gravity
Q2: What is another main form of precipitation besides drizzle, rain, snow, sleet and hail? A2: graupel
Q3: Where do water droplets collide with ice crystals to form precipitation? A3: within a cloud
Table 1.4: Question-answer pairs for a sample passage in the SQuAD dataset. Each of the answers is a
segment of text from the passage. This can be solved using sentence pair tagging. The input is the paragraph
text T and the question Q. The output is a tagging of the relevant words in T that answer the question in Q.
From Figure 1 of [Raj+16]. Used with kind permission of Percy Liang.
1.5.3 Preprocessing discrete input data
Many ML models assume that the data consists of real-valued feature vectors, x ∈ R
D. However,
sometimes the input may have discrete input features, such as categorical variables like race and
gender, or words from some vocabulary. In the sections below, we discuss some ways to preprocess
such data to convert it to vector form. This is a common operation that is used for many different
kinds of models.
1.5.3.1 One-hot encoding
When we have categorical features, we need to convert them to a numerical scale, so that computing
weighted combinations of the inputs makes sense. The standard way to preprocess such categorical
variables is to use a one-hot encoding, also called a dummy encoding. If a variable x has K
values, we will denote its dummy encoding as follows: one-hot(x) = [I(x = 1), . . . ,I(x = K)]. For
example, if there are 3 colors (say red, green and blue), the corresponding one-hot vectors will be
one-hot(red) = [1, 0, 0], one-hot(green) = [0, 1, 0], and one-hot(blue) = [0, 0, 1].
1.5.3.2 Feature crosses
A linear model using a dummy encoding for each categorical variable can capture the main effects
of each variable, but cannot capture interaction effects between them. For example, suppose we
want to predict the fuel efficiency of a vehicle given two categorical input variables: the type (say
SUV, Truck, or Family car), and the country of origin (say USA or Japan). If we concatenate the
one-hot encodings for the ternary and binary features, we get the following input encoding:
φ(x) = [1,I(x1 = S),I(x1 = T),I(x1 = F),I(x2 = U),I(x2 = J)] (1.34)
where x1 is the type and x2 is the country of origin.
This model cannot capture dependencies between the features. For example, we expect trucks to
be less fuel efficient, but perhaps trucks from the USA are even less efficient than trucks from Japan.
This cannot be captured using the linear model in Equation (1.34) since the contribution from the
country of origin is independent of the car type.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license24 Chapter 1. Introduction
We can fix this by computing explicit feature crosses. For example, we can define a new composite
feature with 3 × 2 possible values, to capture the interaction of type and country of origin. The new
model becomes
f(x; w) = wTφ(x) (1.35)
= w0 + w1I(x1 = S) + w2I(x1 = T) + w3I(x1 = F)
+ w4I(x2 = U) + w5I(x2 = J)
+ w6I(x1 = S, x2 = U) + w7I(x1 = T, x2 = U) + w8I(x1 = F, x2 = U)
+ w9I(x1 = S, x2 = J) + w10I(x1 = T, x2 = J) + w11I(x1 = F, x2 = J) (1.36)
We can see that the use of feature crosses converts the original dataset into a wide format, with
many more columns.
1.5.4 Preprocessing text data
In Section 1.5.2, we briefly discussed text classification and other NLP tasks. To feed text data into
a classifier, we need to tackle various issues. First, documents have a variable length, and are thus
not fixed-length feature vectors, as assumed by many kinds of models. Second, words are categorical
variables with many possible values (equal to the size of the vocabulary), so the corresponding
one-hot encodings will be very high-dimensional, with no natural notion of similarity. Third, we may
encounter words at test time that have not been seen during training (so-called out-of-vocabulary
or OOV words). We discuss some solutions to these problems below. More details can be found in
e.g., [BKL10; MRS08; JM20].
1.5.4.1 Bag of words model
A simple approach to dealing with variable-length text documents is to interpret them as a bag of
words, in which we ignore word order. To convert this to a vector from a fixed input space, we first
map each word to a token from some vocabulary.
To reduce the number of tokens, we often use various pre-processing techniques such as the following:
dropping punctuation, converting all words to lower case; dropping common but uninformative words,
such as “and” and “the” (this is called stop word removal); replacing words with their base form,
such as replacing “running” and “runs” with “run” (this is called word stemming); etc. For details,
see e.g., [BL12], and for some sample code, see code.probml.ai/book1/text_preproc_torch.
Let xnt be the token at location t in the n’th document. If there are D unique tokens in the
vocabulary, then we can represent the n’th document as a D-dimensional vector x˜n, where x˜nv is
the number of times that word v occurs in document n:
x˜nv =
X
T
t=1
I(xnt = v) (1.37)
where T is the length of document n. We can now interpret documents as vectors in R
D. This is
called the vector space model of text [SWY75; TP10].
We traditionally store input data in an N × D design matrix denoted by X, where D is the number
of features. In the context of vector space models, it is more common to represent the input data
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20221.5. Data 25
Figure 1.15: Example of a term-document matrix, where raw counts have been replaced by their TF-IDF
values (see Section 1.5.4.2). Darker cells are larger values. From https: // bit. ly/ 2kByLQI . Used with
kind permission of Christoph Carl Kling.
as a D × N term frequency matrix, where TFij is the frequency of term i in document j. See
Figure 1.15 for an illustration.
1.5.4.2 TF-IDF
One problem with representing documents as word count vectors is that frequent words may have
undue influence, just because the magnitude of their word count is higher, even if they do not carry
much semantic content. A common solution to this is to transform the counts by taking logs, which
reduces the impact of words that occur many times within a single document.
To reduce the impact of words that occur many times in general (across all documents), we compute
a quantity called the inverse document frequency, defined as follows: IDFi , log N
1+DFi
, where
DFi
is the number of documents with term i. We can combine these transformations to compute the
TF-IDF matrix as follows:
TFIDFij = log(TFij + 1) × IDFi (1.38)
(We often normalize each row as well.) This provides a more meaningful representation of documents,
and can be used as input to many ML algorithms. See code.probml.ai/book1/tfidf_demo for an
example.
1.5.4.3 Word embeddings
Although the TF-IDF transformation improves on raw count vectors by placing more weight on
“informative” words and less on “uninformative” words, it does not solve the fundamental problem with
the one-hot encoding (from which count vectors are derived), which is that that semantically similar
words, such as “man” and “woman”, may be not be any closer (in vector space) than semantically
dissimilar words, such as “man” and “banana”. Thus the assumption that points that are close in
input space should have similar outputs, which is implicitly made by most prediction models, is
invalid.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license26 Chapter 1. Introduction
The standard way to solve this problem is to use word embeddings, in which we map each sparse
one-hot vector, xnt ∈ {0, 1}
V
, to a lower-dimensional dense vector, ent ∈ R
K using ent = Exnt,
where E ∈ R
K×V
is learned such that semantically similar words are placed close by. There are many
ways to learn such embeddings, as we discuss in Section 20.5.
Once we have an embedding matrix, we can represent a variable-length text document as a bag of
word embeddings. We can then convert this to a fixed length vector by summing (or averaging)
the embeddings:
en =
X
T
t=1
ent = Ex˜n (1.39)
where x˜n is the bag of words representation from Equation (1.37). We can then use this inside of a
logistic regression classifier, which we briefly introduced in Section 1.2.1.5. The overall model has the
form
p(y = c|xn, θ) = Sc(WEx˜n) (1.40)
We often use a pre-trained word embedding matrix E, in which case the model is linear in W,
which simplifies parameter estimation (see Chapter 10). See also Section 15.7 for a discussion of
contextual word embeddings.
1.5.4.4 Dealing with novel words
At test time, the model may encounter a completely novel word that it has not seen before. This is
known as the out of vocabulary or OOV problem. Such novel words are bound to occur, because
the set of words is an open class. For example, the set of proper nouns (names of people and places)
is unbounded.
A standard heuristic to solve this problem is to replace all novel words with the special symbol
UNK, which stands for “unknown”. However, this loses information. For example, if we encounter
the word “athazagoraphobia”, we may guess it means “fear of something”, since phobia is a common
suffix in English (derived from Greek) to mean “fear of”. (It turns out that athazagoraphobia means
“fear of being forgotten about or ignored”.)
We could work at the character level, but this would require the model to learn how to group
common letter combinations together into words. It is better to leverage the fact that words have
substructure, and then to take as input subword units or wordpieces [SHB16; Wu+16]; these
are often created using a method called byte-pair encoding [Gag94], which is a form of data
compression that creates new symbols to represent common substrings.
1.5.5 Handling missing data
Sometimes we may have missing data, in which parts of the input x or output y may be unknown.
If the output is unknown during training, the example is unlabeled; we consider such semi-supervised
learning scenarios in Section 19.3. We therefore focus on the case where some of the input features
may be missing, either at training or testing time, or both.
To model this, let M be an N × D matrix of binary variables, where Mnd = 1 if feature d in
example n is missing, and Mnd = 0 otherwise. Let Xv be the visible parts of the input feature matrix,
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20221.6. Discussion 27
corresponding to Mnd = 0, and Xh be the missing parts, corresponding to Mnd = 1. Let Y be the
output label matrix, which we assume is fully observed. If we assume p(M|Xv, Xh, Y) = p(M), we
say the data is missing completely at random or MCAR, since the missingness does not depend
on the hidden or observed features. If we assume p(M|Xv, Xh, Y) = p(M|Xv, Y), we say the data is
missing at random or MAR, since the missingness does not depend on the hidden features, but
may depend on the visible features. If neither of these assumptions hold, we say the data is not
missing at random or NMAR.
In the MCAR and MAR cases, we can ignore the missingness mechanism, since it tells us nothing
about the hidden features. However, in the NMAR case, we need to model the missing data
mechanism, since the lack of information may be informative. For example, the fact that someone
did not fill out an answer to a sensitive question on a survey (e.g., “Do you have COVID?”) could be
informative about the underlying value. See e.g., [LR87; Mar08] for more information on missing
data models.
In this book, we will always make the MAR assumption. However, even with this assumption, we
cannot directly use a discriminative model, such as a DNN, when we have missing input features, since
the input x will have some unknown values. A common heuristic is called mean value imputation,
in which missing values are replaced by their empirical mean. More generally, we can fit a generative
model to the input, and use that to fill in the missing values. We briefly discuss some suitable
generative models for this task in Chapter 20, and in more detail in the sequel to this book, [Mur22].
1.6 Discussion
In this section, we situate ML and this book into a larger context.
1.6.1 The relationship between ML and other fields
There are several subcommunities that work on ML-related topics, each of which have different names.
The field of predictive analytics is similar to supervised learning (in particular, classification
and regression), but focuses more on business applications. Data mining covers both supervised
and unsupervised machine learning, but focuses more on structured data, usually stored in large
commercial databases. Data science uses techniques from machine learning and statistics, but
also emphasizes other topics, such as data integration, data visualization, and working with domain
experts, often in an iterative feedback loop (see e.g., [BS17]). The difference between these areas is
often just one of terminology.11
ML is also very closely related to the field of statistics. Indeed, Jerry Friedman, a famous statistics
professor at Stanford, said12
[If the statistics field had] incorporated computing methodology from its inception as a
fundamental tool, as opposed to simply a convenient way to apply our existing tools, many of
the other data related fields [such as ML] would not have needed to exist — they would have
been part of statistics. — Jerry Friedman [Fri97b]
Machine learning is also related to artificial intelligence (AI). Historically, the field of AI
assumed that we could program “intelligence” by hand (see e.g., [RN10; PM17]), but this approach
11. See https://developers.google.com/machine-learning/glossary/ for a useful “ML glossary”.
12. Quoted in https://brenocon.com/blog/2008/12/statistics-vs-machine-learning-fight/
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license28 Chapter 1. Introduction
has largely failed to live up to expectations, mostly because it proved to be too hard to explicitly
encode all the knowledge such systems need. Consequently, there is renewed interest in using ML to
help an AI system acquire its own knowledge. (Indeed the connections are so close that sometimes
the terms “ML” and “AI” are used interchangeably, although this is arguably misleading [Pre21].)
1.6.2 Structure of the book
We have seen that ML is closely related to many other subjects in mathematics, statistics, computer
science, etc. It can be hard to know where to start.
In this book, we take one particular path through this interconnected landscape, using probability
theory as our unifying lens. We cover statistical foundations in Part I, supervised learning in
Part II–Part IV, and unsupervised learning in Part V. For more information on these (and other)
topics, please see the sequel to this book, [Mur22],
In addition to the book, you may find the online Python notebooks that accompany this book
helpful. See http://probml.ai for details.
1.6.3 Caveats
In this book, we will see how machine learning can be used to create systems that can (attempt
to) predict outputs given inputs. These predictions can then be used to choose actions so as to
minimize expected loss. When designing such systems, it can be hard to design a loss function that
correctly specifies all of our preferences; this can result in “reward hacking” in which the machine
optimizes the reward function we give it, but then we realize that the function did not capture various
constraints or preferences that we forgot to specify [Wei76; Amo+16; D’A+20]. (This is particularly
important when tradeoffs need to be made between multiple objectives.)
Reward hacking is an example of a larger problem known as the “alignment problem” [Chr20],
which refers to the potential discrepancy between what we ask our algorithms to optimize and what
we actually want them to do for us; this has raised various concerns in the context of AI ethics and
AI safety (see e.g., [KR19; Lia20]). Russell [Rus19] proposes to solve this problem by not explicitly
specifying a reward function, but instead forcing the machine to infer the reward by observing human
behavior, an approach known as inverse reinforcement learning. However, emulating current or
past human behavior too closely may be undesirable, and can be biased by the data that is available
for training (see e.g., [Pau+20]).
The above view of AI, in which an “intelligent” system makes decisions on its own, without a
human in the loop, is believed by many to be the path towards “artificial general intelligence”.
An alternative approach is to view AI as “augmented intelligence” (sometimes called intelligence
augmentation or IA). In this paradigm, AI is a process for creating “smart tools”, like adaptive
cruise control or auto-complete in search engines; such tools maintain a human in the decision-making
loop. In this framing, systems which have AI/ML components in them are not that different from
other complex, semi-autonomous human artefacts, such as aeroplanes with autopilot, online trading
platforms or medical diagnostic systems (c.f. [Jor19; Ace]). Of course, as the AI tools becomes
more powerful, they can end up doing more and more on their own, making this approach similar to
AGI. However, in augmented intelligence, the goal is not to emulate or exceed human behavior at
certain tasks, but instead to help humans get stuff done more easily; this is how we treat most other
technologies [Kap16].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022Part I
Foundations2 Probability: Univariate Models
2.1 Introduction
In this chapter, we give a brief introduction to the basics of probability theory. There are many good
books that go into more detail, e.g., [GS97; BT08].
2.1.1 What is probability?
Probability theory is nothing but common sense reduced to calculation. — Pierre Laplace,
1812
We are all comfortable saying that the probability that a (fair) coin will land heads is 50%. But
what does this mean? There are actually two different interpretations of probability. One is called
the frequentist interpretation. In this view, probabilities represent long run frequencies of events
that can happen multiple times. For example, the above statement means that, if we flip the coin
many times, we expect it to land heads about half the time.1 The other interpretation is called the
Bayesian interpretation of probability. In this view, probability is used to quantify our uncertainty
or ignorance about something; hence it is fundamentally related to information rather than repeated
trials [Jay03; Lin06]. In the Bayesian view, the above statement means we believe the coin is equally
likely to land heads or tails on the next toss.
One big advantage of the Bayesian interpretation is that it can be used to model our uncertainty
about one-off events that do not have long term frequencies. For example, we might want to compute
the probability that the polar ice cap will melt by 2030 CE. This event will happen zero or one times,
but cannot happen repeatedly. Nevertheless, we ought to be able to quantify our uncertainty about
this event; based on how probable we think this event is, we can decide how to take the optimal
action, as discussed in Chapter 5. We shall therefore adopt the Bayesian interpretation in this book.
Fortunately, the basic rules of probability theory are the same, no matter which interpretation is
adopted.
2.1.2 Types of uncertainty
The uncertainty in our predictions can arise for two fundamentally different reasons. The first is
due to our ignorance of the underlying hidden causes or mechanism generating our data. This is
1. Actually, the Stanford statistician (and former professional magician) Persi Diaconis has shown that a coin is about
51% likely to land facing the same way up as it started, due to the physics of the problem [DHM07].32 Chapter 2. Probability: Univariate Models
called epistemic uncertainty, since epistemology is the philosophical term used to describe the
study of knowledge. However, a simpler term for this is model uncertainty. The second kind of
uncertainty arises from intrinsic variability, which cannot be reduced even if we collect more data.
This is sometimes called aleatoric uncertainty [Hac75; KD09], derived from the Latin word for
“dice”, although a simpler term would be data uncertainty. As a concrete example, consider tossing
a fair coin. We might know for sure that the probability of heads is p = 0.5, so there is no epistemic
uncertainty, but we still cannot perfectly predict the outcome.
This distinction can be important for applications such as active learning. A typical strategy is to
query examples for which H(p(y|x, D)) is large (where H(p) is the entropy, discussed in Section 6.1).
However, this could be due to uncertainty about the parameters, i.e., large H(p(θ|D)), or just due to
inherent label noise or variability, corresponding to large entropy of p(y|x, θ). See [Osb16] for further
discussion.
2.1.3 Probability as an extension of logic
In this section, we review the basic rules of probability, following the presentation of [Jay03], in which
we view probability as an extension of Boolean logic.
2.1.3.1 Probability of an event
We define an event, denoted by the binary variable A, as some state of the world that either holds
or does not hold. For example, A might be event “it will rain tomorrow”, or “it rained yesterday”, or
“the label is y = 1”, or “the parameter θ is between 1.5 and 2.0”, etc. The expression Pr(A) denotes
the probability with which you believe event A is true (or the long run fraction of times that A will
occur). We require that 0 ≤ Pr(A) ≤ 1, where Pr(A) = 0 means the event definitely will not happen,
and Pr(A) = 1 means the event definitely will happen. We write Pr(A) to denote the probability of
event A not happening; this is defined to be Pr(A) = 1 − Pr(A).
2.1.3.2 Probability of a conjunction of two events
We denote the joint probability of events A and B both happening as follows:
Pr(A ∧ B) = Pr(A, B) (2.1)
If A and B are independent events, we have
Pr(A, B) = Pr(A) Pr(B) (2.2)
For example, suppose X and Y are chosen uniformly at random from the set X = {1, 2, 3, 4}. Let
A be the event that X ∈ {1, 2}, and B be the event that Y ∈ {3}. Then we have Pr(A, B) =
Pr(A) Pr(B) = 1
2
·
1
4
.
2.1.3.3 Probability of a union of two events
The probability of event A or B happening is given by
Pr(A ∨ B) = Pr(A) + Pr(B) − Pr(A ∧ B) (2.3)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.2. Random variables 33
If the events are mutually exclusive (so they cannot happen at the same time), we get
Pr(A ∨ B) = Pr(A) + Pr(B) (2.4)
For example, suppose X is chosen uniformly at random from the set X = {1, 2, 3, 4}. Let A be the
event that X ∈ {1, 2} and B be the event that X ∈ {3}. Then we have Pr(A ∨ B) = 2
4 +
1
4
.
2.1.3.4 Conditional probability of one event given another
We define the conditional probability of event B happening given that A has occurred as follows:
Pr(B|A) ,
Pr(A, B)
Pr(A)
(2.5)
This is not defined if Pr(A) = 0, since we cannot condition on an impossible event.
2.1.3.5 Independence of events
We say that event A is conditionally independent of event B if
Pr(A, B) = Pr(A) Pr(B) (2.6)
2.1.3.6 Conditional independence of events
We say that events A and B are conditionally independent given event C if
Pr(A, B|C) = Pr(A|C) Pr(B|C) (2.7)
This is written as A ⊥ B|C. Events are often dependent on each other, but may be rendered
independent if we condition on the relevant intermediate variables, as we discuss in more detail later
in this chapter.
2.2 Random variables
Suppose X represents some unknown quantity of interest, such as which way a dice will land when
we roll it, or the temperature outside your house at the current time. If the value of X is unknown
and/or could change, we call it a random variable or rv. The set of possible values, denoted X , is
known as the sample space or state space. An event is a set of outcomes from a given sample
space. For example, if X represents the face of a dice that is rolled, so X = {1, 2, . . . , 6}, the event
of “seeing a 1” is denoted X = 1, the event of “seeing an odd number” is denoted X ∈ {1, 3, 5}, the
event of “seeing a number between 1 and 3” is denoted 1 ≤ X ≤ 3, etc.
2.2.1 Discrete random variables
If the sample space X is finite or countably infinite, then X is called a discrete random variable.
In this case, we denote the probability of the event that X has value x by Pr(X = x). We define the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license34 Chapter 2. Probability: Univariate Models
1 2 3 4
0.00
0.25
0.50
0.75
1.00
(a)
1 2 3 4
0.00
0.25
0.50
0.75
1.00
(b)
Figure 2.1: Some discrete distributions on the state space X = {1, 2, 3, 4}. (a) A uniform distribution with
p(x = k) = 1/4. (b) A degenerate distribution (delta function) that puts all its mass on x = 1. Generated by
code at figures.probml.ai/book1/2.1.
probability mass function or pmf as a function which computes the probability of events which
correspond to setting the rv to each possible value:
p(x) , Pr(X = x) (2.8)
The pmf satisfies the properties 0 ≤ p(x) ≤ 1 and P
x∈X p(x) = 1.
If X has a finite number of values, say K, the pmf can be represented as a list of K numbers, which
we can plot as a histogram. For example, Figure 2.1 shows two pmf’s defined on X = {1, 2, 3, 4}.
On the left we have a uniform distribution, p(x) = 1/4, and on the right, we have a degenerate
distribution, p(x) = I(x = 1), where I() is the binary indicator function. Thus the distribution in
Figure 2.1(b) represents the fact that X is always equal to the value 1. (Thus we see that random
variables can also be constant.)
2.2.2 Continuous random variables
If X ∈ R is a real-valued quantity, it is called a continuous random variable. In this case, we
can no longer create a finite (or countable) set of distinct possible values it can take on. However,
there are a countable number of intervals which we can partition the real line into. If we associate
events with X being in each one of these intervals, we can use the methods discussed above for
discrete random variables. By allowing the size of the intervals to shrink to zero, we can represent
the probability of X taking on a specific real value, as we show below.
2.2.2.1 Cumulative distribution function (cdf)
Define the events A = (X ≤ a), B = (X ≤ b) and C = (a < X ≤ b), where a < b. We have that
B = A ∨ C, and since A and C are mutually exclusive, the sum rules gives
Pr(B) = Pr(A) + Pr(C) (2.9)
and hence the probability of being in interval C is given by
Pr(C) = Pr(B) − Pr(A) (2.10)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.2. Random variables 35
3 2 1 0 1 2 3
0.0
0.2
0.4
0.6
0.8
1.0
Gaussian cdf
(a)
)
-1(,/2) 0 )
-1(1-,/2)
,/2 ,/2
(b)
Figure 2.2: (a) Plot of the cdf for the standard normal, N (0, 1). Generated by code at fig￾ures.probml.ai/book1/2.2. (b) Corresponding pdf. The shaded regions each contain α/2 of the probability mass.
Therefore the nonshaded region contains 1 − α of the probability mass. The leftmost cutoff point is Φ
−1
(α/2),
where Φ is the cdf of the Gaussian. By symmetry, the rightmost cutoff point is Φ
−1
(1 − α/2) = −Φ
−1
(α/2).
Generated by code at figures.probml.ai/book1/2.2.
In general, we define the cumulative distribution function or cdf of the rv X as follows:
P(x) , Pr(X ≤ x) (2.11)
(Note that we use a capital P to represent the cdf.) Using this, we can compute the probability of
being in any interval as follows:
Pr(a < X ≤ b) = P(b) − P(a) (2.12)
Cdf’s are monotonically non-decreasing functions. See Figure 2.2a for an example, where we
illustrate the cdf of a standard normal distribution, N (x|0, 1); see Section 2.6 for details.
2.2.2.2 Probability density function (pdf)
We define the probability density function or pdf as the derivative of the cdf:
p(x) ,
d
dxP(x) (2.13)
(Note that this derivative does not always exist, in which case the pdf is not defined.) See Figure 2.2b
for an example, where we illustrate the pdf of a univariate Gaussian (see Section 2.6 for details).
Given a pdf, we can compute the probability of a continuous variable being in a finite interval as
follows:
Pr(a < X ≤ b) = Z b
a
p(x)dx = P(b) − P(a) (2.14)
As the size of the interval gets smaller, we can write
Pr(x ≤ X ≤ x + dx) ≈ p(x)dx (2.15)
Intuitively, this says the probability of X being in a small interval around x is the density at x times
the width of the interval.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license36 Chapter 2. Probability: Univariate Models
2.2.2.3 Quantiles
If the cdf P is strictly monotonically increasing, it has an inverse, called the inverse cdf, or percent
point function (ppf), or quantile function.
If P is the cdf of X, then P
−1
(q) is the value xq such that Pr(X ≤ xq) = q; this is called the q’th
quantile of P. The value P
−1
(0.5) is the median of the distribution, with half of the probability
mass on the left, and half on the right. The values P
−1
(0.25) and P
−1
(0.75) are the lower and upper
quartiles.
For example, let Φ be the cdf of the Gaussian distribution N (0, 1), and Φ
−1 be the inverse cdf.
Then points to the left of Φ
−1
(α/2) contain α/2 of the probability mass, as illustrated in Figure 2.2b.
By symmetry, points to the right of Φ
−1
(1 − α/2) also contain α/2 of the mass. Hence the central
interval (Φ−1
(α/2), Φ
−1
(1 − α/2)) contains 1 − α of the mass. If we set α = 0.05, the central 95%
interval is covered by the range
(Φ−1
(0.025), Φ
−1
(0.975)) = (−1.96, 1.96) (2.16)
If the distribution is N (µ, σ2
), then the 95% interval becomes (µ − 1.96σ, µ + 1.96σ). This is often
approximated by writing µ ± 2σ.
2.2.3 Sets of related random variables
In this section, we discuss distributions over sets of related random variables.
Suppose, to start, that we have two random variables, X and Y . We can define the joint
distribution of two random variables using p(x, y) = p(X = x, Y = y) for all possible values of
X and Y . If both variables have finite cardinality, we can represent the joint distribution as a 2d
table, all of whose entries sum to one. For example, consider the following example with two binary
variables:
p(X, Y ) Y = 0 Y = 1
X = 0 0.2 0.3
X = 1 0.3 0.2
If two variables are independent, we can represent the joint as the product of the two marginals. If
both variables have finite cardinality, we can factorize the 2d joint table into a product of two 1d
vectors, as shown in Figure 2.3.
Given a joint distribution, we define the marginal distribution of an rv as follows:
p(X = x) = X
y
p(X = x, Y = y) (2.17)
where we are summing over all possible states of Y . This is sometimes called the sum rule or the
rule of total probability. We define p(Y = y) similarly. For example, from the above 2d table, we
see p(X = 0) = 0.2 + 0.3 = 0.5 and p(Y = 0) = 0.2 + 0.3 = 0.5. (The term “marginal” comes from
the accounting practice of writing the sums of rows and columns on the side, or margin, of a table.)
We define the conditional distribution of an rv using
p(Y = y|X = x) = p(X = x, Y = y)
p(X = x)
(2.18)
We can rearrange this equation to get
p(x, y) = p(x)p(y|x) (2.19)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.2. Random variables 37
P(X, Y) P(Y)
P(X)
=
Figure 2.3: Computing p(x, y) = p(x)p(y), where X ⊥ Y . Here X and Y are discrete random variables; X
has 6 possible states (values) and Y has 5 possible states. A general joint distribution on two such variables
would require (6 × 5) − 1 = 29 parameters to define it (we subtract 1 because of the sum-to-one constraint).
By assuming (unconditional) independence, we only need (6 − 1) + (5 − 1) = 9 parameters to define p(x, y).
This is called the product rule.
By extending the product rule to D variables, we get the chain rule of probability:
p(x1:D) = p(x1)p(x2|x1)p(x3|x1, x2)p(x4|x1, x2, x3). . . p(xD|x1:D−1) (2.20)
This provides a way to create a high dimensional joint distribution from a set of conditional
distributions. We discuss this in more detail in Section 3.6.
2.2.4 Independence and conditional independence
We say X and Y are unconditionally independent or marginally independent, denoted X ⊥ Y ,
if we can represent the joint as the product of the two marginals (see Figure 2.3), i.e.,
X ⊥ Y ⇐⇒ p(X, Y ) = p(X)p(Y ) (2.21)
In general, we say a set of variables X1, . . . , Xn is independent if the joint can be written as a
product of marginals, i.e.,
p(X1, . . . , Xn) = Yn
i=1
p(Xi) (2.22)
Unfortunately, unconditional independence is rare, because most variables can influence most other
variables. However, usually this influence is mediated via other variables rather than being direct.
We therefore say X and Y are conditionally independent (CI) given Z iff the conditional joint
can be written as a product of conditional marginals:
X ⊥ Y | Z ⇐⇒ p(X, Y |Z) = p(X|Z)p(Y |Z) (2.23)
We can write this assumption as a graph X − Z − Y , which captures the intuition that all the
dependencies between X and Y are mediated via Z. By using larger graphs, we can define complex
joint distributions; these are known as graphical models, and are discussed in Section 3.6.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license38 Chapter 2. Probability: Univariate Models
2.2.5 Moments of a distribution
In this section, we describe various summary statistics that can be derived from a probability
distribution (either a pdf or pmf).
2.2.5.1 Mean of a distribution
The most familiar property of a distribution is its mean, or expected value, often denoted by µ.
For continuous rv’s, the mean is defined as follows:
E [X] ,
Z
X
x p(x)dx (2.24)
If the integral is not finite, the mean is not defined; we will see some examples of this later.
For discrete rv’s, the mean is defined as follows:
E [X] ,
X
x∈X
x p(x) (2.25)
However, this is only meaningful if the values of x are ordered in some way (e.g., if they represent
integer counts).
Since the mean is a linear operator, we have
E [aX + b] = aE [X] + b (2.26)
This is called the linearity of expectation.
For a set of n random variables, one can show that the expectation of their sum is as follows:
E
"Xn
i=1
Xi
#
=
Xn
i=1
E [Xi
] (2.27)
If they are independent, the expectation of their product is given by
E
"Yn
i=1
Xi
#
=
Yn
i=1
E [Xi
] (2.28)
2.2.5.2 Variance of a distribution
The variance is a measure of the “spread” of a distribution, often denoted by σ
2
. This is defined as
follows:
V [X] , E

(X − µ)
2

=
Z
(x − µ)
2
p(x)dx (2.29)
=
Z
x
2
p(x)dx + µ
2
Z
p(x)dx − 2µ
Z
xp(x)dx = E

X2

− µ
2
(2.30)
from which we derive the useful result
E

X2

= σ
2 + µ
2
(2.31)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.2. Random variables 39
The standard deviation is defined as
std [X] ,
p
V [X] = σ (2.32)
This is useful since it has the same units as X itself.
The variance of a shifted and scaled version of a random variable is given by
V [aX + b] = a
2V [X] (2.33)
If we have a set of n independent random variables, the variance of their sum is given by the sum
of their variances:
V
"Xn
i=1
Xi
#
=
Xn
i=1
V [Xi
] (2.34)
The variance of their product can also be derived, as follows:
V
"Yn
i=1
Xi
#
= E
"
(
Y
i
Xi)
2
#
− (E
"Y
i
Xi
#
)
2
(2.35)
= E
"Y
i
X2
i
#
− (
Y
i
E [Xi
])2
(2.36)
=
Y
i
E

X2
i

−
Y
i
(E [Xi
])2
(2.37)
=
Y
i
(V [Xi
] + (E [Xi
])2
) −
Y
i
(E [Xi
])2
(2.38)
=
Y
i
(σ
2
i + µ
2
i
) −
Y
i
µ
2
i
(2.39)
2.2.5.3 Mode of a distribution
The mode of a distribution is the value with the highest probability mass or probability density:
x
∗ = argmax
x
p(x) (2.40)
If the distribution is multimodal, this may not be unique, as illustrated in Figure 2.4. Furthermore,
even if there is a unique mode, this point may not be a good summary of the distribution.
2.2.5.4 Conditional moments
When we have two or more dependent random variables, we can compute the moments of one given
knowledge of the other. For example, the law of iterated expectations, also called the law of
total expectation, tells us that
E [X] = EY [E [X|Y ]] (2.41)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license40 Chapter 2. Probability: Univariate Models
2 1 0 1 2 3 4
0.00
0.05
0.10
0.15
0.20
0.25
0.30
0.35
0.40
Figure 2.4: Illustration of a mixture of two 1d Gaussians, p(x) = 0.5N (x|0, 0.5) + 0.5N (x|2, 0.5). Generated
by code at figures.probml.ai/book1/2.4.
To prove this, let us suppose, for simplicity, that X and Y are both discrete rv’s. Then we have
EY [E [X|Y ]] = EY
"X
x
x p(X = x|Y )
#
(2.42)
=
X
y
"X
x
x p(X = x|Y )
#
p(Y = y) = X
x,y
xp(X = x, Y = y) = E [X] (2.43)
To give a more intuitive explanation, consider the following simple example.2 Let X be the
lifetime duration of a lightbulb, and let Y be the factory the lightbulb was produced in. Suppose
E [X|Y = 1] = 5000 and E [X|Y = 2] = 4000, indicating that factory 1 produces longer lasting bulbs.
Suppose factory 1 supplies 60% of the lightbulbs, so p(Y = 1) = 0.6 and p(Y = 2) = 0.4. Then the
expected duration of a random lightbulb is given by
E [X] = E [X|Y = 1] p(Y = 1) + E [X|Y = 2] p(Y = 2) = 5000 × 0.6 + 4000 × 0.4 = 4600 (2.44)
There is a similar formula for the variance. In particular, the law of total variance, also called
the conditional variance formula, tells us that
V [X] = EY [V [X|Y ]] + VY [E [X|Y ]] (2.45)
To see this, let us define the conditional moments, µX|Y = E [X|Y ], sX|Y = E

X2
|Y

, and
σ
2
X|Y = V [X|Y ] = sX|Y − µ
2
X|Y
, which are functions of Y (and therefore are random quantities).
Then we have
V [X] = E

X2

− (E [X])2 = EY

sX|Y

−
￾
EY

µX|Y
2
(2.46)
= EY
h
σ
2
X|Y
i
+ EY
h
µ
2
X|Y
i
−
￾
EY

µX|Y
2
(2.47)
= EY [V [X|Y ]] + VY [µX|Y ] (2.48)
To get some intuition for these formulas, consider a mixture of K univariate Gaussians. Let
Y be the hidden indicator variable that specifies which mixture component we are using, and let
2. This example is from https://en.wikipedia.org/wiki/Law_of_total_expectation, but with modified notation.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202.2. Random variables 41
5 10 15 20
x
4
6
8
10
12
y
dataset = I
5 10 15 20
x
dataset = II
5 10 15 20
x
dataset = III
5 10 15 20
x
dataset = IV
Figure 2.5: Illustration of Anscombe’s quartet. All of these datasets have the same low order summary
statistics. Generated by code at figures.probml.ai/book1/2.5.
X =
PK
y=1 πyN (X|µy, σy). In Figure 2.4, we have π1 = π2 = 0.5, µ1 = 0, µ2 = 2, σ1 = σ2 = 0.5.
Thus
E [V [X|Y ]] = π1σ
2
1 + π2σ
2
2 = 0.25 (2.49)
V [E [X|Y ]] = π1(µ1 − µ)
2 + π2(µ2 − µ)
2 = 0.5(0 − 1)2 + 0.5(2 − 1)2 = 0.5 + 0.5 = 1 (2.50)
So we get the intuitive result that the variance of X is dominated by which centroid it is drawn from
(i.e., difference in the means), rather than the local variance around each centroid.
2.2.6 Limitations of summary statistics *
Although it is common to summarize a probability distribution (or points sampled from a distribution)
using simple statistics such as the mean and variance, this can lose a lot of information. A striking
example of this is known as Anscombe’s quartet [Ans73], which is illustrated in Figure 2.5. This
shows 4 different datasets of (x, y) pairs, all of which have identical mean, variance and correlation
coefficient ρ (defined in Section 3.1.2): E [x] = 9, V [x] = 11, E [y] = 7.50, V [y] = 4.12, and ρ = 0.816.
3
However, the joint distributions p(x, y) from which these points were sampled are clearly very different.
Anscombe invented these datasets, each consisting of 10 data points, to counter the impression among
statisticians that numerical summaries are superior to data visualization [Ans73].
An even more striking example of this phenomenon is shown in Figure 2.6. This consists of a
dataset that looks like a dinosaur4
, plus 11 other datasets, all of which have identical low order
statistics. This collection of datasets is called the Datasaurus Dozen [MF17]. The exact values of
the (x, y) points are available online.5 They were computed using simulated annealing, a derivative
free optimization method which we discuss in the sequel to this book, [Mur22]. (The objective
function being optimized measures deviation from the target summary statistics of the original
dinosaur, plus distance from a particular target shape.)
3. The maximum likelihood estimate for the variance in Equation (4.51) differs from the unbiased estimate in
Equation (4.38). For the former, we have V [x] = 10.00, V [y] = 3.75, for the latter, we have V [x] = 11.00, V [y] = 4.12.
4. This dataset was created by Alberto Cairo, and is available at http://www.thefunctionalart.com/2016/08/
download-datasaurus-never-trust-summary.html
5. https://www.autodesk.com/research/publications/same-stats-different-graphs. There are actually 13
datasets in total, including the dinosaur. We omitted the “away” dataset for visual clarity.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license42 Chapter 2. Probability: Univariate Models
0
20
40
60
80
100
y
dataset = dino dataset = h_lines dataset = v_lines dataset = x_shape
0
20
40
60
80
100
y
dataset = star dataset = high_lines dataset = dots dataset = circle
20 40 60 80 100
x
0
20
40
60
80
100
y
dataset = bullseye
20 40 60 80 100
x
dataset = slant_up
20 40 60 80 100
x
dataset = slant_down
20 40 60 80 100
x
dataset = wide_lines
Figure 2.6: Illustration of the Datasaurus Dozen. All of these datasets have the same low order summary
statistics. Adapted from Figure 1 of [MF17]. Generated by code at figures.probml.ai/book1/2.6.
Figure 2.7: Illustration of 7 different datasets (left), the corresponding box plots (middle) and
violin box plots (right). From Figure 8 of https: // www. autodesk. com/ research/ publications/
same-stats-different-graphs . Used with kind permission of Justin Matejka.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.3. Bayes’ rule 43
The same simulated annealing approach can be applied to 1d datasets, as shown in Figure 2.7. We
see that all the datasets are quite different, but they all have the same median and inter-quartile
range as shown by the central shaded part of the box plots in the middle. A better visualization
is known as a violin plot, shown on the right. This shows (two copies of) the 1d kernel density
estimate (Section 16.3) of the distribution on the vertical axis, in addition to the median and IQR
markers. This visualization is better able to distinguish differences in the distributions. However, the
technique is limited to 1d data.
2.3 Bayes’ rule
Bayes’s theorem is to the theory of probability what Pythagoras’s theorem is to geometry.
— Sir Harold Jeffreys, 1973 [Jef73].
In this section, we discuss the basics of Bayesian inference. According to the Merriam-Webster
dictionary, the term “inference” means “the act of passing from sample data to generalizations, usually
with calculated degrees of certainty”. The term “Bayesian” is used to refer to inference methods
that represent “degrees of certainty” using probability theory, and which leverage Bayes’ rule6
, to
update the degree of certainty given data.
Bayes’ rule itself is very simple: it is just a formula for computing the probability distribution over
possible values of an unknown (or hidden) quantity H given some observed data Y = y:
p(H = h|Y = y) = p(H = h)p(Y = y|H = h)
p(Y = y)
(2.51)
This follows automatically from the identity
p(h|y)p(y) = p(h)p(y|h) = p(h, y) (2.52)
which itself follows from the product rule of probability.
In Equation (2.51), the term p(H) represents what we know about possible values of H before
we see any data; this is called the prior distribution. (If H has K possible values, then p(H) is
a vector of K probabilities, that sum to 1.) The term p(Y |H = h) represents the distribution over
the possible outcomes Y we expect to see if H = h; this is called the observation distribution.
When we evaluate this at a point corresponding to the actual observations, y, we get the function
p(Y = y|H = h), which is called the likelihood. (Note that this is a function of h, since y is
fixed, but it is not a probability distribution, since it does not sum to one.) Multiplying the prior
distribution p(H = h) by the likelihood function p(Y = y|H = h) for each h gives the unnormalized
joint distribution p(H = h, Y = y). We can convert this into a normalized distribution by dividing
by p(Y = y), which is known as the marginal likelihood, since it is computed by marginalizing
over the unknown H:
p(Y = y) = X
h0∈H
p(H = h
0
)p(Y = y|H = h
0
) = X
h0∈H
p(H = h
0
, Y = y) (2.53)
6. Thomas Bayes (1702–1761) was an English mathematician and Presbyterian minister. For a discussion of whether
to spell this as Bayes’ rule or Bayes’s rule, see https://bit.ly/2kDtLuK.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license44 Chapter 2. Probability: Univariate Models
Observation
0 1
Truth 0 TNR=Specificity=0.975 FPR=1-TNR=0.025
1 FNR=1-TPR=0.125 TPR=Sensitivity=0.875
Table 2.1: Likelihood function p(Y |H) for a binary observation Y given two possible hidden states H. Each
row sums to one. Abbreviations: TNR is true negative rate, TPR is true positive rate, FNR is false negative
rate, FPR is false positive rate.
Normalizing the joint distribution by computing p(H = h, Y = y)/p(Y = y) for each h gives the
posterior distribution p(H = h|Y = y); this represents our new belief state about the possible
values of H.
We can summarize Bayes rule in words as follows:
posterior ∝ prior × likelihood (2.54)
Here we use the symbol ∝ to denote “proportional to”, since we are ignoring the denominator, which is
just a constant, independent of H. Using Bayes rule to update a distribution over unknown values of
some quantity of interest, given relevant observed data, is called Bayesian inference, or posterior
inference. It can also just be called probabilistic inference.
Below we give some simple examples of Bayesian inference in action. We will see many more
interesting examples later in this book.
2.3.1 Example: Testing for COVID-19
Suppose you think you may have contracted COVID-19, which is an infectious disease caused by
the SARS-CoV-2 virus. You decide to take a diagnostic test, and you want to use its result to
determine if you are infected or not.
Let H = 1 be the event that you are infected, and H = 0 be the event you are not infected. Let
Y = 1 if the test is positive, and Y = 0 if the test is negative. We want to compute p(H = h|Y = y),
for h ∈ {0, 1}, where y is the observed test outcome. (We will write the distribution of values,
[p(H = 0|Y = y), p(H = 1|Y = y)] as p(H|y), for brevity.) We can think of this as a form of binary
classification, where H is the unknown class label, and y is the feature vector.
First we must specify the likelihood. This quantity obviously depends on how reliable the
test is. There are two key parameters. The sensitivity (aka true positive rate) is defined as
p(Y = 1|H = 1), i.e., the probability of a positive test given that the truth is positive. The false
negative rate is defined as one minus the sensitivity. The specificity (aka true negative rate)
is defined as p(Y = 0|H = 0), i.e., the probability of a negative test given that the truth is negative.
The false positive rate is defined as one minus the specificity. We summarize all these quantities
in Table 2.1. (See Section 5.1.3.1 for more details.) Following https://nyti.ms/31MTZgV, we set
the sensitivity to 87.5% and the specificity to 97.5%.
Next we must specify the prior. The quantity p(H = 1) represents the prevalence of the
disease in the area in which you live. We set this to p(H = 1) = 0.1 (i.e., 10%), which was the
prevalence in New York City in Spring 2020. (This example was chosen to match the numbers in
https://nyti.ms/31MTZgV.)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.3. Bayes’ rule 45
Now suppose you test positive. We have
p(H = 1|Y = 1) = p(Y = 1|H = 1)p(H = 1)
p(Y = 1|H = 1)p(H = 1) + p(Y = 1|H = 0)p(H = 0) (2.55)
=
TPR × prior
TPR × prior + FPR × (1 − prior)
(2.56)
=
0.875 × 0.1
0.875 × 0.1 + 0.025 × 0.9
= 0.795 (2.57)
So there is a 79.5% chance you are infected.
Now suppose you test negative. The probability you are infected is given by
p(H = 1|Y = 0) = p(Y = 0|H = 1)p(H = 1)
p(Y = 0|H = 1)p(H = 1) + p(Y = 0|H = 0)p(H = 0) (2.58)
=
FNR × prior
FNR × prior + TNR × (1 − prior)
(2.59)
=
0.125 × 0.1
0.125 × 0.1 + 0.975 × 0.9
= 0.014 (2.60)
So there is just a 1.4% chance you are infected.
Nowadays COVID-19 prevalence is much lower. Suppose we repeat these calculations using a base
rate of 1%; now the posteriors reduce to 26% and 0.13% respectively.
The fact that you only have a 26% chance of being infected with COVID-19, even after a positive
test, is very counter-intuitive. The reason is that a single positive test is more likely to be a false
positive than due to the disease, since the disease is rare. To see this, suppose we have a population
of 100,000 people, of whom 1000 are infected. Of those who are infected, 875 = 0.875 × 1000 test
positive, and of those who are uninfected, 2475 = 0.025×99, 000 test positive. Thus the total number
of positives is 3350 = 875 + 2475, so the posterior probability of being infected given a positive test
is 875/3350 = 0.26.
Of course, the above calculations assume we know the sensitivity and specificity of the test. See
[GC20] for how to apply Bayes rule for diagnostic testing when there is uncertainty about these
parameters.
2.3.2 Example: The Monty Hall problem
In this section, we consider a more “frivolous” application of Bayes rule. In particular, we apply it to
the famous Monty Hall problem.
Imagine a game show with the following rules: There are three doors, labeled 1, 2, 3. A single prize
(e.g., a car) has been hidden behind one of them. You get to select one door. Then the gameshow
host opens one of the other two doors (not the one you picked), in such a way as to not reveal the
prize location. At this point, you will be given a fresh choice of door: you can either stick with your
first choice, or you can switch to the other closed door. All the doors will then be opened and you
will receive whatever is behind your final choice of door.
For example, suppose you choose door 1, and the gameshow host opens door 3, revealing nothing
behind the door, as promised. Should you (a) stick with door 1, or (b) switch to door 2, or (c) does
it make no difference?
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license46 Chapter 2. Probability: Univariate Models
Door 1 Door 2 Door 3 Switch Stay
Car - - Lose Win
- Car - Win Lose
- - Car Win Lose
Table 2.2: 3 possible states for the Monty Hall game, showing that switching doors is two times better (on
average) than staying with your original choice. Adapted from Table 6.1 of [PM18].
Intuitively, it seems it should make no difference, since your initial choice of door cannot influence
the location of the prize. However, the fact that the host opened door 3 tells us something about the
location of the prize, since he made his choice conditioned on the knowledge of the true location and
on your choice. As we show below, you are in fact twice as likely to win the prize if you switch to
door 2.
To show this, we will use Bayes’ rule. Let Hi denote the hypothesis that the prize is behind door i.
We make the following assumptions: the three hypotheses H1, H2 and H3 are equiprobable a priori,
i.e.,
P(H1) = P(H2) = P(H3) = 1
3
. (2.61)
The datum we receive, after choosing door 1, is either Y = 3 and Y = 2 (meaning door 3 or 2 is
opened, respectively). We assume that these two possible outcomes have the following probabilities.
If the prize is behind door 1, then the host selects at random between Y = 2 and Y = 3. Otherwise
the choice of the host is forced and the probabilities are 0 and 1.
P(Y = 2|H1) = 1
2
P(Y = 2|H2) = 0 P(Y = 2|H3) = 1
P(Y = 3|H1) = 1
2
P(Y = 3|H2) = 1 P(Y = 3|H3) = 0 (2.62)
Now, using Bayes’ theorem, we evaluate the posterior probabilities of the hypotheses:
P(Hi
|Y = 3) = P(Y = 3|Hi)P(Hi)
P(Y = 3) (2.63)
P(H1|Y = 3) = (1/2)(1/3)
P (Y =3) P(H2|Y = 3) = (1)(1/3)
P (Y =3) P(H3|Y = 3) = (0)(1/3)
P (Y =3) (2.64)
The denominator P(Y = 3) is P(Y = 3) = 1
6 +
1
3 =
1
2
. So
P(H1|Y = 3) = 1
3
P(H2|Y = 3) = 2
3
P(H3|Y = 3) = 0. (2.65)
So the contestant should switch to door 2 in order to have the biggest chance of getting the prize.
See Table 2.2 for a worked example.
Many people find this outcome surprising. One way to make it more intuitive is to perform a
thought experiment in which the game is played with a million doors. The rules are now that the
contestant chooses one door, then the game show host opens 999,998 doors in such a way as not to
reveal the prize, leaving the contestant’s selected door and one other door closed. The contestant
may now stick or switch. Imagine the contestant confronted by a million doors, of which doors 1 and
234,598 have not been opened, door 1 having been the contestant’s initial guess. Where do you think
the prize is?
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.4. Bernoulli and binomial distributions 47
Figure 2.8: Any planar line-drawing is geometrically consistent with infinitely many 3-D structures. From
Figure 11 of [SA93]. Used with kind permission of Pawan Sinha.
2.3.3 Inverse problems *
Probability theory is concerned with predicting a distribution over outcomes y given knowledge (or
assumptions) about the state of the world, h. By contrast, inverse probability is concerned with
inferring the state of the world from observations of outcomes. We can think of this as inverting the
h → y mapping.
For example, consider trying to infer a 3d shape h from a 2d image y, which is a classic problem
in visual scene understanding. Unfortunately, this is a fundamentally ill-posed problem, as
illustrated in Figure 2.8, since there are multiple possible hidden h’s consistent with the same observed
y (see e.g., [Piz01]). Similarly, we can view natural language understanding as an ill-posed
problem, in which the listener must infer the intention h from the (often ambiguous) words spoken
by the speaker (see e.g., [Sab21]).
To tackle such inverse problems, we can use Bayes’ rule to compute the posterior, p(h|y), which
gives a distribution over possible states of the world. This requires specifying the forwards model,
p(y|h), as well as a prior p(h), which can be used to rule out (or downweight) implausible world
states. We discuss this topic in more detail in the sequel to this book, [Mur22].
2.4 Bernoulli and binomial distributions
Perhaps the simplest probability distribution is the Bernoulli distribution, which can be used to
model binary events, as we discuss below.
2.4.1 Definition
Consider tossing a coin, where the probability of event that it lands heads is given by 0 ≤ θ ≤ 1.
Let Y = 1 denote this event, and let Y = 0 denote the event that the coin lands tails. Thus we are
assuming that p(Y = 1) = θ and p(Y = 0) = 1 − θ. This is called the Bernoulli distribution, and
can be written as follows
Y ∼ Ber(θ) (2.66)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license48 Chapter 2. Probability: Univariate Models
0 1 2 3 4 5 6 7 8 9 10
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
θ=0.250
(a)
0 1 2 3 4 5 6 7 8 9 10
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
θ=0.900
(b)
Figure 2.9: Illustration of the binomial distribution with N = 10 and (a) θ = 0.25 and (b) θ = 0.9. Generated
by code at figures.probml.ai/book1/2.9.
where the symbol ∼ means “is sampled from” or “is distributed as”, and Ber refers to Bernoulli. The
probability mass function (pmf) of this distribution is defined as follows:
Ber(y|θ) = (
1 − θ if y = 0
θ if y = 1
(2.67)
(See Section 2.2.1 for details on pmf’s.) We can write this in a more concise manner as follows:
Ber(y|θ) , θ
y
(1 − θ)
1−y
(2.68)
The Bernoulli distribution is a special case of the binomial distribution. To explain this, suppose
we observe a set of N Bernoulli trials, denoted yn ∼ Ber(·|θ), for n = 1 : N. Concretely, think of
tossing a coin N times. Let us define s to be the total number of heads, s ,
PN
n=1 I(yn = 1). The
distribution of s is given by the binomial distribution:
Bin(s|N, θ) ,

N
s

θ
s
(1 − θ)
N−s
(2.69)
where

N
k

,
N!
(N − k)!k!
(2.70)
is the number of ways to choose k items from N (this is known as the binomial coefficient, and is
pronounced “N choose k”). See Figure 2.9 for some examples of the binomial distribution. If N = 1,
the binomial distribution reduces to the Bernoulli distribution.
2.4.2 Sigmoid (logistic) function
When we want to predict a binary variable y ∈ {0, 1} given some inputs x ∈ X , we need to use a
conditional probability distribution of the form
p(y|x, θ) = Ber(y|f(x; θ)) (2.71)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.4. Bernoulli and binomial distributions 49
4 3 2 1 0 1 2 3 4
0.0
0.2
0.4
0.6
0.8
1.0
sigmoid function
(a)
−4 −3 −2 −1 0 1 2 3 4
0.0
0.2
0.4
0.6
0.8
1.0
Heaviside function
(b)
Figure 2.10: (a) The sigmoid (logistic) function σ(a) = (1 + e
−a
)
−1
. (b) The Heaviside function I(a > 0).
Generated by code at figures.probml.ai/book1/2.10.
σ(x) ,
1
1 + e−x
=
e
x
1 + e
x
(2.72)
d
dxσ(x) = σ(x)(1 − σ(x)) (2.73)
1 − σ(x) = σ(−x) (2.74)
σ
−1
(p) = log 
p
1 − p

, logit(p) (2.75)
σ+(x) , log(1 + e
x
) , softplus(x) (2.76)
d
dxσ+(x) = σ(x) (2.77)
Table 2.3: Some useful properties of the sigmoid (logistic) and related functions. Note that the logit function
is the inverse of the sigmoid function, and has a domain of [0, 1].
where f(x; θ) is some function that predicts the mean parameter of the output distribution. We will
consider many different kinds of function f in Part II–Part IV.
To avoid the requirement that 0 ≤ f(x; θ) ≤ 1, we can let f be an unconstrained function, and
use the following model:
p(y|x, θ) = Ber(y|σ(f(x; θ))) (2.78)
Here σ() is the sigmoid or logistic function, defined as follows:
σ(a) ,
1
1 + e−a
(2.79)
where a = f(x; θ). The term “sigmoid” means S-shaped: see Figure 2.10a for a plot. We see that it
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license50 Chapter 2. Probability: Univariate Models
0.0 0.5 1.0 1.5 2.0 2.5 3.0
Petal width (cm)
0.0
0.2
0.4
0.6
0.8
1.0
Probability
Decision boundary
Iris-Virginica
Not Iris-Virginica
Figure 2.11: Logistic regression applied to a 1-dimensional, 2-class version of the Iris dataset. Generated by
code at figures.probml.ai/book1/2.11. Adapted from Figure 4.23 of [Gér19].
maps the whole real line to [0, 1], which is necessary for the output to be interpreted as a probability
(and hence a valid value for the Bernoulli parameter θ). The sigmoid function can be thought of as a
“soft” version of the heaviside step function, defined by
H(a) , I(a > 0) (2.80)
as shown in Figure 2.10b.
Plugging the definition of the sigmoid function into Equation (2.78) we get
p(y = 1|x, θ) = 1
1 + e−a
=
e
a
1 + e
a
= σ(a) (2.81)
p(y = 0|x, θ) = 1 −
1
1 + e−a
=
e
−a
1 + e−a
=
1
1 + e
a
= σ(−a) (2.82)
The quantity a is equal to the log odds, log(
p
1−p
), where p = p(y = 1|x; θ). To see this, note that
log 
p
1 − p

= log 
e
a
1 + e
a
1 + e
a
1

= log(e
a
) = a (2.83)
The logistic function or sigmoid function maps the log-odds a to p:
p = logistic(a) = σ(a) ,
1
1 + e−a
=
e
a
1 + e
a
(2.84)
The inverse of this is called the logit function, and maps p to the log-odds a:
a = logit(p) = σ
−1
(p) , log 
p
1 − p

(2.85)
See Table 2.3 for some useful properties of these functions.
2.4.3 Binary logistic regression
In this section, we use a conditional Bernoulli model, where we use a linear predictor of the form
f(x; θ) = wTx + b. Thus the model has the form
p(y|x; θ) = Ber(y|σ(wTx + b)) (2.86)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.5. Categorical and multinomial distributions 51
In other words,
p(y = 1|x; θ) = σ(wTx + b) = 1
1 + e−(wTx+b)
(2.87)
This is called logistic regression.
For example consider a 1-dimensional, 2-class version of the iris dataset, where the positive class is
“Virginica” and the negative class is “not Virginica”, and the feature x we use is the petal width. We
fit a logistic regression model to this and show the results in Figure 2.11. The decision boundary
corresponds to the value x
∗ where p(y = 1|x = x
∗
, θ) = 0.5. We see that, in this example, x
∗ ≈ 1.7.
As x moves away from this boundary, the classifier becomes more confident in its prediction about
the class label.
It should be clear from this example why it would be inappropriate to use linear regression for a
(binary) classification problem. In such a model, the probabilities would increase above 1 as we move
far enough to the right, and below 0 as we move far enough to the left.
For more detail on logistic regression, see Chapter 10.
2.5 Categorical and multinomial distributions
To represent a distribution over a finite set of labels, y ∈ {1, . . . , C}, we can use the categorical
distribution, which generalizes the Bernoulli to C > 2 values.
2.5.1 Definition
The categorical distribution is a discrete probability distribution with one parameter per class:
Cat(y|θ) ,
Y
C
c=1
θ
I(y=c)
c
(2.88)
In other words, p(y = c|θ) = θc. Note that the parameters are constrained so that 0 ≤ θc ≤ 1 and
PC
c=1 θc = 1; thus there are only C − 1 independent parameters.
We can write the categorical distribution in another way by converting the discrete variable y into
a one-hot vector with C elements, all of which are 0 except for the entry corresponding to the class
label. (The term “one-hot” arises from electrical engineering, where binary vectors are encoded as
electrical current on a set of wires, which can be active (“hot”) or not (“cold”).) For example, if C = 3,
we encode the classes 1, 2 and 3 as (1, 0, 0), (0, 1, 0), and (0, 0, 1). More generally, we can encode the
classes using unit vectors, where ec is all 0s except for dimension c. (This is also called a dummy
encoding.) Using one-hot encodings, we can write the categorical distribution as follows:
Cat(y|θ) ,
Y
C
c=1
θ
yc
c
(2.89)
The categorical distribution is a special case of the multinomial distribution. To explain this,
suppose we observe N categorical trials, yn ∼ Cat(·|θ), for n = 1 : N. Concretely, think of rolling a
C-sided dice N times. Let us define s to be a vector that counts the number of times each face shows
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license52 Chapter 2. Probability: Univariate Models
0.0
0.2
0.4
0.6
0.8
1.0 T = 100
0.0
0.2
0.4
0.6
0.8
1.0 T = 2
0.0
0.2
0.4
0.6
0.8
1.0 T = 1
Figure 2.12: Softmax distribution S(a/T), where a = (3, 0, 1), at temperatures of T = 100, T = 2 and
T = 1. When the temperature is high (left), the distribution is uniform, whereas when the temperature is
low (right), the distribution is “spiky”, with most of its mass on the largest element. Generated by code at
figures.probml.ai/book1/2.12.
up, i.e., sc ,
PN
n=1 I(yn = c). (Equivalently, if we use one-hot encodings, we have s =
P
n
yn.) The
distribution of s is given by the multinomial distribution:
M(s|N, θ) ,

N
s1 . . . sC
 Y
C
c=1
θ
sc
c
(2.90)
where θc is the probability that side c shows up, and

N
s1 . . . sC

,
N!
s1!s2! · · · sC !
(2.91)
is the multinomial coefficient, which is the number of ways to divide a set of size N =
PC
c=1 sc
into subsets with sizes s1 up to sC . If N = 1, the multinomial distribution becomes the categorical
distribution.
2.5.2 Softmax function
In the conditional case, we can define
p(y|x, θ) = Cat(y|f(x; θ)) (2.92)
which we can also write as
p(y|x, θ) = M(y|1, f(x; θ)) (2.93)
We require that 0 ≤ fc(x; θ) ≤ 1 and PC
c=1 fc(x; θ) = 1.
To avoid the requirement that f directly predict a probability vector, it is common to pass the
output from f into the softmax function [Bri90], also called the multinomial logit. This is defined
as follows:
S(a) ,
"
e
a1
PC
c
0=1 e
ac0
, . . . ,
e
aC
PC
c
0=1 e
ac0
#
(2.94)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.5. Categorical and multinomial distributions 53
1 2 3 4 5 6 7
Petal length
1
0
1
2
3
4
Petal width
0.150
0.300
0.450
0.600
0.750
0.900
Iris-Virginica
Iris-Versicolor
Iris-Setosa
Figure 2.13: Logistic regression on the 3-class, 2-feature version of the Iris dataset. Adapted from Figure of
4.25 [Gér19]. Generated by code at figures.probml.ai/book1/2.13.
This maps R
C to [0, 1]C , and satisfies the constraints that 0 ≤ S(a)c ≤ 1 and PC
c=1 S(a)c = 1. The
inputs to the softmax, a = f(x; θ), are called logits, and are a generalization of the log odds.
The softmax function is so-called since it acts a bit like the argmax function. To see this, let us
divide each ac by a constant T called the temperature.
7 Then as T → 0, we find
S(a/T)c =

1.0 if c = argmaxc
0 ac
0
0.0 otherwise (2.95)
In other words, at low temperatures, the distribution puts most of its probability mass in the most
probable state (this is called winner takes all), whereas at high temperatures, it spreads the mass
uniformly. See Figure 2.12 for an illustration.
2.5.3 Multiclass logistic regression
If we use a linear predictor of the form f(x; θ) = Wx + b, where W is a C × D matrix, and b is a
C-dimensional bias vector, the final model becomes
p(y|x; θ) = Cat(y|S(Wx + b)) (2.96)
Let a = Wx + b be the C-dimensional vector of logits. Then we can rewrite the above as follows:
p(y = c|x; θ) = e
ac
PC
c
0=1 e
ac0
(2.97)
This is known as multinomial logistic regression.
If we have just two classes, this reduces to binary logistic regression. To see this, note that
S(a)0 =
e
a0
e
a0 + e
a1
=
1
1 + e
a1−a0
= σ(a0 − a1) (2.98)
so we can just train the model to predict a = a1 − a0. This can be done with a single weight vector
w; if we use the multi-class formulation, we will have two weight vectors, w0 and w1. Such a model
is over-parameterized, which can hurt interpretability, but the predictions will be the same.
7. This terminology comes from the area of statistical physics. The Boltzmann distribution is a distribution over
states which has the same form as the softmax function.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license54 Chapter 2. Probability: Univariate Models
We discuss this in more detail in Section 10.3. For now, we just give an example. Figure 2.13
shows what happens when we fit this model to the 3-class iris dataset, using just 2 features. We see
that the decision boundaries between each class are linear. We can create nonlinear boundaries by
transforming the features (e.g., using polynomials), as we discuss in Section 10.3.1.
2.5.4 Log-sum-exp trick
In this section, we discuss one important practical detail to pay attention to when working with
the softmax distribution. Suppose we want to compute the normalized probability pc = p(y = c|x),
which is given by
pc =
e
ac
Z(a)
=
e
ac
PC
c
0=1 e
ac0
(2.99)
where a = f(x; θ) are the logits. We might encounter numerical problems when computing the
partition function Z. For example, suppose we have 3 classes, with logits a = (0, 1, 0). Then we find
Z = e
0+e
1+e
0 = 4.71. But now suppose a = (1000, 1001, 1000); we find Z = ∞, since on a computer,
even using 64 bit precision, np.exp(1000)=inf. Similarly, suppose a = (−1000, −999, −1000); now
we find Z = 0, since np.exp(-1000)=0. To avoid numerical problems, we can use the following
identity:
logX
C
c=1
exp(ac) = m + logX
C
c=1
exp(ac − m) (2.100)
This holds for any m. It is common to use m = maxc ac which ensures that the largest value you
exponentiate will be zero, so you will definitely not overflow, and even if you underflow, the answer
will be sensible. This is known as the log-sum-exp trick. We use this trick when implementing the
lse function:
lse(a) , logX
C
c=1
exp(ac) (2.101)
We can use this to compute the probabilities from the logits:
p(y = c|x) = exp(ac − lse(a)) (2.102)
We can then pass this to the cross-entropy loss, defined in Equation (5.41).
However, to save computational effort, and for numerical stability, it is quite common to modify
the cross-entropy loss so that it takes the logits a as inputs, instead of the probability vector p. For
example, consider the binary case. The CE loss for one example is
L = − [I(y = 0) log p0 + I(y = 1) log p1] (2.103)
where
log p1 = log 
1
1 + exp(−a)

= log(1) − log(1 + exp(−a)) = 0 − lse([0, −a]) (2.104)
log p0 = 0 − lse([0, +a]) (2.105)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.6. Univariate Gaussian (normal) distribution 55
2.6 Univariate Gaussian (normal) distribution
The most widely used distribution of real-valued random variables y ∈ R is the Gaussian distribu￾tion, also called the normal distribution (see Section 2.6.4 for a discussion of these names).
2.6.1 Cumulative distribution function
We define the cumulative distribution function or cdf of a continuous random variable Y as
follows:
P(y) , Pr(Y ≤ y) (2.106)
(Note that we use a capital P to represent the cdf.) Using this, we can compute the probability of
being in any interval as follows:
Pr(a < Y ≤ b) = P(b) − P(a) (2.107)
Cdf’s are monotonically non-decreasing functions.
The cdf of the Gaussian is defined by
Φ(y; µ, σ2
) ,
Z y
−∞
N (z|µ, σ2
)dz (2.108)
where z = (y − µ)/σ. See Figure 2.2a for a plot. Note that the cdf of the Gaussian is often
implemented using Φ(y; µ, σ2
) = 1
2
[1 + erf(z/√
2)], where erf(u) is the error function, defined as
erf(u) ,
2
√
π
Z u
0
e
−t
2
dt (2.109)
The parameter µ encodes the mean of the distribution, which is the same as the mode, since the
distribution is unimodal. The parameter σ
2
encodes the variance. (Sometimes we talk about the
precision of a Gaussian, which is the inverse variance, denoted λ = 1/σ2
.) When µ = 0 and σ = 1,
the Gaussian is called the standard normal distribution.
If P is the cdf of Y , then P
−1
(q) is the value yq such that p(Y ≤ yq) = q; this is called the q’th
quantile of P. The value P
−1
(0.5) is the median of the distribution, with half of the probability
mass on the left, and half on the right. The values P
−1
(0.25) and P
−1
(0.75) are the lower and upper
quartiles.
For example, let Φ be the cdf of the Gaussian distribution N (0, 1), and Φ
−1 be the inverse cdf (also
known as the probit function). Then points to the left of Φ
−1
(α/2) contain α/2 of the probability
mass, as illustrated in Figure 2.2b. By symmetry, points to the right of Φ
−1
(1 − α/2) also contain
α/2 of the mass. Hence the central interval (Φ−1
(α/2), Φ
−1
(1 − α/2)) contains 1 − α of the mass. If
we set α = 0.05, the central 95% interval is covered by the range
(Φ−1
(0.025), Φ
−1
(0.975)) = (−1.96, 1.96) (2.110)
If the distribution is N (µ, σ2
), then the 95% interval becomes (µ − 1.96σ, µ + 1.96σ). This is often
approximated by writing µ ± 2σ.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license56 Chapter 2. Probability: Univariate Models
2.6.2 Probability density function
We define the probability density function or pdf as the derivative of the cdf:
p(y) ,
d
dyP(y) (2.111)
The pdf of the Gaussian is given by
N (y|µ, σ2
) ,
1
√
2πσ2
e
− 1
2σ2
(y−µ)
2
(2.112)
where √
2πσ2 is the normalization constant needed to ensure the density integrates to 1 (see
Exercise 2.12). See Figure 2.2b for a plot.
Given a pdf, we can compute the probability of a continuous variable being in a finite interval as
follows:
Pr(a < Y ≤ b) = Z b
a
p(y)dy = P(b) − P(a) (2.113)
As the size of the interval gets smaller, we can write
Pr(y ≤ Y ≤ y + dy) ≈ p(y)dy (2.114)
Intuitively, this says the probability of Y being in a small interval around y is the density at y times
the width of the interval. One important consequence of the above result is that the pdf at a point
can be larger than 1. For example, N (0|0, 0.1) = 3.99.
We can use the pdf to compute the mean, or expected value, of the distribution:
E [Y ] ,
Z
Y
y p(y)dy (2.115)
For a Gaussian, we have the familiar result that E

N (·|µ, σ2
)

= µ. (Note, however, that for some
distributions, this integral is not finite, so the mean is not defined.)
We can also use the pdf to compute the variance of a distribution. This is a measure of the
“spread”, and is often denoted by σ
2
. The variance is defined as follows:
V [Y ] , E

(Y − µ)
2

=
Z
(y − µ)
2
p(y)dy (2.116)
=
Z
y
2
p(y)dy + µ
2
Z
p(y)dy − 2µ
Z
yp(y)dy = E

Y
2

− µ
2
(2.117)
from which we derive the useful result
E

Y
2

= σ
2 + µ
2
(2.118)
The standard deviation is defined as
std [Y ] ,
p
V [Y ] = σ (2.119)
(The standard deviation can be more intepretable than the variance since it has the same units as Y
itself.) For a Gaussian, we have the familiar result that std 
N (·|µ, σ2
)

= σ.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.6. Univariate Gaussian (normal) distribution 57
20 10 0 10 20 30 40 50 60
0
5
10
15
20
(a)
20 10 0 10 20 30 40 50 60
0
5
10
15
20
(b)
Figure 2.14: Linear regression using Gaussian output with mean µ(x) = b + wx and (a) fixed variance
σ
2
(homoskedastic) or (b) input-dependent variance σ(x)
2
(heteroscedastic). Generated by code at fig￾ures.probml.ai/book1/2.14.
2.6.3 Regression
So far we have been considering the unconditional Gaussian distribution. In some cases, it is helpful
to make the parameters of the Gaussian be functions of some input variables, i.e., we want to create
a conditional density model of the form
p(y|x; θ) = N (y|fµ(x; θ), fσ(x; θ)
2
) (2.120)
where fµ(x; θ) ∈ R predicts the mean, and fσ(x; θ)
2 ∈ R+ predicts the variance.
It is common to assume that the variance is fixed, and is independent of the input. This is called
homoscedastic regression. Furthermore it is common to assume the mean is a linear function of
the input. The resulting model is called linear regression:
p(y|x; θ) = N (y|wTx + b, σ2
) (2.121)
where θ = (w, b, σ2
). See Figure 2.14(a) for an illustration of this model in 1d. and Section 11.2 for
more details on this model.
However, we can also make the variance depend on the input; this is called heteroskedastic
regression. In the linear regression setting, we have
p(y|x; θ) = N (y|wT
µx + b, σ+(wT
σx)) (2.122)
where θ = (wµ, wσ) are the two forms of regression weights, and
σ+(a) = log(1 + e
a
) (2.123)
is the softplus function, that maps from R to R+, to ensure the predicted standard deviation is
non-negative. See Figure 2.14(b) for an illustration of this model in 1d.
Note that Figure 2.14 plots the 95% predictive interval, [µ(x) − 2σ(x), µ(x) + 2σ(x)]. This is the
uncertainty in the predicted observation y given x, and captures the variability in the blue dots.
By contrast, the uncertainty in the underlying (noise-free) function is represented by p
V [fµ(x; θ)],
which does not involve the σ term; now the uncertainty is over the parameters θ, rather than the
output y. See Section 11.7 for details on how to model parameter uncertainty.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license58 Chapter 2. Probability: Univariate Models
2.6.4 Why is the Gaussian distribution so widely used?
The Gaussian distribution is the most widely used distribution in statistics and machine learning.
There are several reasons for this. First, it has two parameters which are easy to interpret, and which
capture some of the most basic properties of a distribution, namely its mean and variance. Second,
the central limit theorem (Section 2.8.6) tells us that sums of independent random variables have an
approximately Gaussian distribution, making it a good choice for modeling residual errors or “noise”.
Third, the Gaussian distribution makes the least number of assumptions (has maximum entropy),
subject to the constraint of having a specified mean and variance, as we show in Section 3.4.4; this
makes it a good default choice in many cases. Finally, it has a simple mathematical form, which
results in easy to implement, but often highly effective, methods, as we will see in Section 3.2.
From a historical perspective, it’s worth remarking that the term “Gaussian distribution” is a bit
misleading, since, as Jaynes [Jay03, p241] notes: “The fundamental nature of this distribution and
its main properties were noted by Laplace when Gauss was six years old; and the distribution itself
had been found by de Moivre before Laplace was born”. However, Gauss popularized the use of the
distribution in the 1800s, and the term “Gaussian” is now widely used in science and engineering.
The name “normal distribution” seems to have arisen in connection with the normal equations
in linear regression (see Section 11.2.2.2). However, we prefer to avoid the term “normal”, since it
suggests other distributions are “abnormal”, whereas, as Jaynes [Jay03] points out, it is the Gaussian
that is abnormal in the sense that it has many special properties that are untypical of general
distributions.
2.6.5 Dirac delta function as a limiting case
As the variance of a Gaussian goes to 0, the distribution approaches an infinitely narrow, but infinitely
tall, “spike” at the mean. We can write this as follows:
limσ→0
N (y|µ, σ2
) → δ(y − µ) (2.124)
where δ is the Dirac delta function, defined by
δ(x) = (
+∞ if x = 0
0 if x 6= 0
(2.125)
where
Z ∞
−∞
δ(x)dx = 1 (2.126)
A slight variant of this is to define
δy(x) = (
+∞ if x = y
0 if x 6= y
(2.127)
Note that we have
δy(x) = δ(x − y) (2.128)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.7. Some other common univariate distributions * 59
4 3 2 1 0 1 2 3 4
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
pdf
Gauss
Student(dof 1)
Student (dof 2)
Laplace
(a)
4 3 2 1 0 1 2 3 4
8
6
4
2
0
log pdf
Gauss
Student(dof 1)
Student (dof 2)
Laplace
(b)
Figure 2.15: (a) The pdf ’s for a N (0, 1), T (µ = 0, σ = 1, ν = 1), T (µ = 0, σ = 1, ν = 2), and Lap(0, 1/
√
2).
The mean is 0 and the variance is 1 for both the Gaussian and Laplace. When ν = 1, the Student is the same
as the Cauchy, which does not have a well-defined mean and variance. (b) Log of these pdf ’s. Note that the
Student distribution is not log-concave for any parameter value, unlike the Laplace distribution. Nevertheless,
both are unimodal. Generated by code at figures.probml.ai/book1/2.15.
The delta function distribution satisfies the following sifting property, which we will use later on:
Z ∞
−∞
f(y)δ(x − y)dy = f(x) (2.129)
2.7 Some other common univariate distributions *
In this section, we briefly introduce some other univariate distributions that we will use in this book.
2.7.1 Student t distribution
The Gaussian distribution is quite sensitive to outliers. A robust alternative to the Gaussian is
the Student t-distribution, which we shall call the Student distribution for short.8
Its pdf is
as follows:
T (y|µ, σ2
, ν) ∝
"
1 +
1
ν

y − µ
σ
2
#−(
ν+1
2
)
(2.130)
where µ is the mean, σ > 0 is the scale parameter (not the standard deviation), and ν > 0 is called
the degrees of freedom (although a better term would be the degree of normality [Kru13], since
large values of ν make the distribution act like a Gaussian).
8. This distribution has a colorful etymology. It was first published in 1908 by William Sealy Gosset, who worked at
the Guinness brewery in Dublin, Ireland. Since his employer would not allow him to use his own name, he called it the
“Student” distribution. The origin of the term t seems to have arisen in the context of tables of the Student distribution,
used by Fisher when developing the basis of classical statistical inference. See http://jeff560.tripod.com/s.html for
more historical details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license60 Chapter 2. Probability: Univariate Models
-5 0 5 10
0
0.1
0.2
0.3
0.4
0.5
gaussian
student T
laplace
(a)
-5 0 5 10
0
0.1
0.2
0.3
0.4
0.5
gaussian
student T
laplace
(b)
Figure 2.16: Illustration of the effect of outliers on fitting Gaussian, Student and Laplace distributions. (a)
No outliers (the Gaussian and Student curves are on top of each other). (b) With outliers. We see that the
Gaussian is more affected by outliers than the Student and Laplace distributions. Adapted from Figure 2.16
of [Bis06]. Generated by code at figures.probml.ai/book1/2.16.
We see that the probability density decays as a polynomial function of the squared distance from
the center, as opposed to an exponential function, so there is more probability mass in the tail than
with a Gaussian distribution, as shown in Figure 2.15. We say that the Student distribution has
heavy tails, which makes it robust to outliers.
To illustrate the robustness of the Student distribution, consider Figure 2.16. On the left, we show
a Gaussian and a Student distribution fit to some data with no outliers. On the right, we add some
outliers. We see that the Gaussian is affected a lot, whereas the Student hardly changes. We discuss
how to use the Student distribution for robust linear regression in Section 11.6.2.
For later reference, we note that the Student distribution has the following properties:
mean = µ, mode = µ, var =
νσ2
(ν − 2) (2.131)
The mean is only defined if ν > 1. The variance is only defined if ν > 2. For ν  5, the Student
distribution rapidly approaches a Gaussian distribution and loses its robustness properties. It is
common to use ν = 4, which gives good performance in a range of problems [LLT89].
2.7.2 Cauchy distribution
If ν = 1, the Student distribution is known as the Cauchy or Lorentz distribution. Its pdf is defined
by
C(x|µ, γ) = 1
γπ "
1 + 
x − µ
γ
2
#−1
(2.132)
This distribution has very heavy tails compared to a Gaussian. For example, 95% of the values from
a standard normal are between -1.96 and 1.96, but for a standard Cauchy they are between -12.7
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.7. Some other common univariate distributions * 61
and 12.7. In fact the tails are so heavy that the integral that defines the mean does not converge.
The half Cauchy distribution is a version of the Cauchy (with µ = 0) that is “folded over” on itself,
so all its probability density is on the positive reals. Thus it has the form
C+(x|γ) ,
2
πγ "
1 + 
x
γ
2
#−1
(2.133)
This is useful in Bayesian modeling, where we want to use a distribution over positive reals with
heavy tails, but finite density at the origin.
2.7.3 Laplace distribution
Another distribution with heavy tails is the Laplace distribution9
, also known as the double
sided exponential distribution. This has the following pdf:
Lap(y|µ, b) ,
1
2b
exp 
−
|y − µ|
b

(2.134)
See Figure 2.15 for a plot. Here µ is a location parameter and b > 0 is a scale parameter. This
distribution has the following properties:
mean = µ, mode = µ, var = 2b
2
(2.135)
In Section 11.6.1, we discuss how to use the Laplace distribution for robust linear regression, and
in Section 11.4, we discuss how to use the Laplace distribution for sparse linear regression.
2.7.4 Beta distribution
The beta distribution has support over the interval [0, 1] and is defined as follows:
Beta(x|a, b) = 1
B(a, b)
x
a−1
(1 − x)
b−1
(2.136)
where B(a, b) is the beta function, defined by
B(a, b) ,
Γ(a)Γ(b)
Γ(a + b)
(2.137)
where Γ(a) is the Gamma function defined by
Γ(a) ,
Z ∞
0
x
a−1
e
−x
dx (2.138)
See Figure 2.17a for plots of some beta distributions.
9. Pierre-Simon Laplace (1749–1827) was a French mathematician, who played a key role in creating the field of
Bayesian statistics.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license62 Chapter 2. Probability: Univariate Models
0.0 0.2 0.4 0.6 0.8 1.0
0
1
2
3
4
5
6
Beta distributions
a=0.1,b=0.1
a=0.1,b=1.0
a=1.0,b=1.0
a=2.0,b=2.0
a=2.0,b=8.0
(a)
0 1 2 3 4 5 6 7
0.00
0.25
0.50
0.75
1.00
1.25
1.50
1.75
2.00
Gamma distributions
a=1.0,b=1.0
a=1.5,b=1.0
a=2.0,b=1.0
a=1.0,b=2.0
a=1.5,b=2.0
a=2.0,b=2.0
(b)
Figure 2.17: (a) Some beta distributions. If a < 1, we get a “spike” on the left, and if b < 1, we get a “spike”
on the right. if a = b = 1, the distribution is uniform. If a > 1 and b > 1, the distribution is unimodal.
Generated by code at figures.probml.ai/book1/2.17. (b) Some gamma distributions. If a ≤ 1, the mode is at 0,
otherwise the mode is away from 0. As we increase the rate b, we reduce the horizontal scale, thus squeezing
everything leftwards and upwards. Generated by code at figures.probml.ai/book1/2.17.
We require a, b > 0 to ensure the distribution is integrable (i.e., to ensure B(a, b) exists). If
a = b = 1, we get the uniform distribution. If a and b are both less than 1, we get a bimodal
distribution with “spikes” at 0 and 1; if a and b are both greater than 1, the distribution is unimodal.
For later reference, we note that the distribution has the following properties (Exercise 2.8):
mean =
a
a + b
, mode =
a − 1
a + b − 2
, var =
ab
(a + b)
2(a + b + 1) (2.139)
2.7.5 Gamma distribution
The gamma distribution is a flexible distribution for positive real valued rv’s, x > 0. It is defined
in terms of two parameters, called the shape a > 0 and the rate b > 0:
Ga(x|shape = a,rate = b) ,
b
a
Γ(a)
x
a−1
e
−xb (2.140)
Sometimes the distribution is parameterized in terms of the shape a and the scale s = 1/b:
Ga(x|shape = a,scale = s) ,
1
s
aΓ(a)
x
a−1
e
−x/s (2.141)
See Figure 2.17b for some plots of the gamma pdf.
For reference, we note that the distribution has the following properties:
mean =
a
b
, mode = a − 1
b
, var =
a
b
2
(2.142)
There are several distributions which are just special cases of the Gamma, which we discuss below.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.7. Some other common univariate distributions * 63
• Exponential distribution. This is defined by
Expon(x|λ) , Ga(x|shape = 1,rate = λ) (2.143)
This distribution describes the times between events in a Poisson process, i.e. a process in which
events occur continuously and independently at a constant average rate λ.
• Chi-squared distribution. This is defined by
χ
2
ν
(x) , Ga(x|shape =
ν
2
,rate =
1
2
) (2.144)
where ν is called the degrees of freedom. This is the distribution of the sum of squared Gaussian
random variables. More precisely, if Zi ∼ N (0, 1), and S =
Pν
i=1 Z
2
i
, then S ∼ χ
2
ν
.
• The inverse Gamma distribution is defined as follows:
IG(x|shape = a,scale = b) ,
b
a
Γ(a)
x
−(a+1)e
−b/x (2.145)
The distribution has these properties
mean =
b
a − 1
, mode =
b
a + 1
, var =
b
2
(a − 1)2(a − 2) (2.146)
The mean only exists if a > 1. The variance only exists if a > 2. Note: if X ∼ Ga(shape =
a,rate = b), then 1/X ∼ IG(shape = a,scale = b). (Note that b plays two different roles in this
case.)
2.7.6 Empirical distribution
Suppose we have a set of N samples D = {x
(1), . . . , x(N)}, derived from a distribution p(X), where
X ∈ R. We can approximate the pdf using a set of delta functions (Section 2.6.5) or “spikes”, centered
on these samples:
pˆN (x) = 1
N
X
N
n=1
δx(i) (x) (2.147)
This is called the empirical distribution of the dataset D. An example of this, with N = 5, is
shown in Figure 2.18(a).
The corresponding cdf is given by
PˆN (x) = 1
N
X
N
n=1
I

x
(i) ≤ x

=
1
N
X
N
n=1
ux(i) (x) (2.148)
where uy(x) is a step function at y defined by
uy(x) = (
1 if x ≥ y
0 if x < y
(2.149)
This can be visualized as a “stair case”, as in Figure 2.18(b), where the jumps of height 1/N occur at
every sample.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license64 Chapter 2. Probability: Univariate Models
(a) (b)
Figure 2.18: Illustration of the (a) empirical pdf and (b) empirical cdf derived from a set of N = 5 samples.
From https: // bit. ly/ 3hFgi0e . Used with kind permission of Mauro Escudero.
2.8 Transformations of random variables *
Suppose x ∼ p() is some random variable, and y = f(x) is some deterministic transformation of it.
In this section, we discuss how to compute p(y).
2.8.1 Discrete case
If X is a discrete rv, we can derive the pmf for Y by simply summing up the probability mass for all
the x’s such that f(x) = y:
py(y) = X
x:f(x)=y
px(x) (2.150)
For example, if f(X) = 1 if X is even and f(X) = 0 otherwise, and px(X) is uniform on the set
{1, . . . , 10}, then py(1) = P
x∈{2,4,6,8,10}
px(x) = 0.5, and hence py(0) = 0.5 also. Note that in this
example, f is a many-to-one function.
2.8.2 Continuous case
If X is continuous, we cannot use Equation (2.150) since px(x) is a density, not a pmf, and we cannot
sum up densities. Instead, we work with cdf’s, as follows:
Py(y) , Pr(Y ≤ y) = Pr(f(X) ≤ y) = Pr(X ∈ {x|f(x) ≤ y}) (2.151)
If f is invertible, we can derive the pdf of y by differentiating the cdf, as we show below. If f is not
invertible, we can use numerical integration, or a Monte Carlo approximation.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.8. Transformations of random variables * 65
2.8.3 Invertible transformations (bijections)
In this section, we consider the case of monotonic and hence invertible functions. (Note a function is
invertible iff it is a bijector). With this assumption, there is a simple formula for the pdf of y, as we
will see. (This can be generalized to invertible, but non-monotonic, functions, but we ignore this
case.)
2.8.3.1 Change of variables: scalar case
We start with an example. Suppose x ∼ Unif(0, 1), and y = f(x) = 2x + 1. This function stretches
and shifts the probability distribution, as shown in Figure 2.19(a). Now let us zoom in on a point x
and another point that is infinitesimally close, namely x + dx. We see this interval gets mapped to
(y, y + dy). The probability mass in these intervals must be the same, hence p(x)dx = p(y)dy, and so
p(y) = p(x)dx/dy. However, since it does not matter (in terms of probability preservation) whether
dx/dy > 0 or dx/dy < 0, we get
py(y) = px(x)|
dx
dy | (2.152)
Now consider the general case for any px(x) and any monotonic function f : R → R. Let g = f
−1
,
so y = f(x) and x = g(y). If we assume that f : R → R is monotonically increasing we get
Py(y) = Pr(f(X) ≤ y) = Pr(X ≤ f
−1
(y)) = Px(f
−1
(y)) = Px(g(y)) (2.153)
Taking derivatives we get
py(y) ,
d
dyPy(y) = d
dyPx(x) = dx
dy
d
dxPx(x) = dx
dy px(x) (2.154)
We can derive a similar expression (but with opposite signs) for the case where f is monotonically
decreasing. To handle the general case we take the absolute value to get
py(y) = px (g(y))


d
dy g(y)

 (2.155)
This is called change of variables formula.
2.8.3.2 Change of variables: multivariate case
We can extend the previous results to multivariate distributions as follows. Let f be an invertible
function that maps R
n to R
n, with inverse g. Suppose we want to compute the pdf of y = f(x). By
analogy with the scalar case, we have
py(y) = px (g(y))

 det [Jg(y)]

 (2.156)
where Jg =
dg(y)
dyT is the Jacobian of g, and | det J(y)| is the absolute value of the determinant of J
evaluated at y. (See Section 7.8.5 for a discussion of Jacobians.) In Exercise 3.6 you will use this
formula to derive the normalization constant for a multivariate Gaussian.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license66 Chapter 2. Probability: Univariate Models
(a) (b)
Figure 2.19: (a) Mapping a uniform pdf through the function f(x) = 2x + 1. (b) Illustration of how two
nearby points, x and x + dx, get mapped under f. If dy
dx > 0, the function is locally increasing, but if dy
dx < 0,
the function is locally decreasing. From [Jan18]. Used with kind permission of Eric Jang.
Figure 2.20: Illustration of an affine transformation applied to a unit square, f(x) = Ax + b. (a) Here
A = I. (b) Here b = 0. From [Jan18]. Used with kind permission of Eric Jang.
Figure 2.20 illustrates this result in 2d, for the case where f(x) = Ax + b, where A =

a c
b d
.
We see that the area of the unit square changes by a factor of det(A) = ad − bc, which is the area of
the parallelogram.
As another example, consider transforming a density from Cartesian coordinates x = (x1, x2) to
polar coordinates y = f(x1, x2), so g(r, θ) = (r cos θ, r sin θ). Then
Jg =
∂x1
∂r
∂x1
∂θ
∂x2
∂r
∂x2
∂θ

=

cos θ −r sin θ
sin θ r cos θ

(2.157)
| det(Jg)| = |r cos2
θ + r sin2
θ| = |r| (2.158)
Hence
pr,θ(r, θ) = px1,x2
(r cos θ, r sin θ) r (2.159)
To see this geometrically, notice that the area of the shaded patch in Figure 2.21 is given by
Pr(r ≤ R ≤ r + dr, θ ≤ Θ ≤ θ + dθ) = pr,θ(r, θ)drdθ (2.160)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.8. Transformations of random variables * 67
rd
+d
r r + dr
dr
Figure 2.21: Change of variables from polar to Cartesian. The area of the shaded patch is r dr dθ. Adapted
from Figure 3.16 of [Ric95].
In the limit, this is equal to the density at the center of the patch times the size of the patch, which
is given by r dr dθ. Hence
pr,θ(r, θ) dr dθ = px1,x2
(r cos θ, r sin θ) r dr dθ (2.161)
2.8.4 Moments of a linear transformation
Suppose f is an affine function, so y = Ax + b. In this case, we can easily derive the mean and
covariance of y as follows. First, for the mean, we have
E [y] = E [Ax + b] = Aµ + b (2.162)
where µ = E [x]. If f is a scalar-valued function, f(x) = a
Tx + b, the corresponding result is
E

a
Tx + b

= a
Tµ + b (2.163)
For the covariance, we have
Cov [y] = Cov [Ax + b] = AΣAT
(2.164)
where Σ = Cov [x]. We leave the proof of this as an exercise.
As a special case, if y = a
Tx + b, we get
V [y] = V

a
Tx + b

= a
TΣa (2.165)
For example, to compute the variance of the sum of two scalar random variables, we can set a = [1, 1]
to get
V [x1 + x2] = ￾
1 1

Σ11 Σ12
Σ21 Σ22 1
1

(2.166)
= Σ11 + Σ22 + 2Σ12 = V [x1] + V [x2] + 2Cov [x1, x2] (2.167)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens68 Chapter 2. Probability: Univariate Models
- - 1 2 3 4 - -
7 6 5 - - - - - z0 = x0y0 = 5
- 7 6 5 - - - - z1 = x0y1 + x1y0 = 16
- - 7 6 5 - - - z2 = x0y2 + x1y1 + x2y0 = 34
- - - 7 6 5 - - z3 = x1y2 + x2y1 + x3y0 = 52
- - - - 7 6 5 - z4 = x2y2 + x3y1 = 45
- - - - - 7 6 5 z5 = x3y2 = 28
Table 2.4: Discrete convolution of x = [1, 2, 3, 4] with y = [5, 6, 7] to yield z = [5, 16, 34, 52, 45, 28]. In general,
zn =
P∞
k=−∞ xkyn−k. We see that this operation consists of “flipping” y and then “dragging” it over x,
multiplying elementwise, and adding up the results.
Note, however, that although some distributions (such as the Gaussian) are completely characterized
by their mean and covariance, in general we must use the techniques described above to derive the
full distribution of y.
2.8.5 The convolution theorem
Let y = x1 + x2, where x1 and x2 are independent rv’s. If these are discrete random variables, we
can compute the pmf for the sum as follows:
p(y = j) = X
k
p(x1 = k)p(x2 = j − k) (2.168)
for j = . . . , −2, −1, 0, 1, 2, . . ..
If x1 and x2 have pdf’s p1(x1) and p2(x2), what is the distribution of y? The cdf for y is given by
Py(y
∗
) = Pr(y ≤ y
∗
) = Z ∞
−∞
p1(x1)dx1
Z y
∗−x1
−∞
p2(x2)dx2 (2.169)
where we integrate over the region R defined by x1 + x2 < y∗
. Thus the pdf for y is
p(y) = 
d
dy∗
Py(y
∗
)

y∗=y
=
Z
p1(x1)p2(y − x1)dx1 (2.170)
where we used the rule of differentiating under the integral sign:
d
dx Z b(x)
a(x)
f(t)dt = f(b(x))db(x)
dx − f(a(x))da(x)
dx (2.171)
We can write Equation (2.170) as follows:
p = p1 ~ p2 (2.172)
where ~ represents the convolution operator. For finite length vectors, the integrals become
sums, and convolution can be thought of as a “flip and drag” operation, as illustrated in Table 2.4.
Consequently, Equation (2.170) is called the convolution theorem.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.8. Transformations of random variables * 69
S
2 3 4 5 6 7 8 9 10 11 12
p(S)
0.16
0.14
0.12
0.10
0.08
0.06
0.04
0.02
6_
36
5__
36
4_
36
3__
36
2__
36
1__
36
Figure 2.22: Distribution of the sum of two dice rolls, i.e., p(y) where y = x1+x2 and xi ∼ Unif({1, 2, . . . , 6}).
From https: // en. wikipedia. org/ wiki/ Probability_ distribution . Used with kind permission of
Wikipedia author Tim Stellmach.
For example, suppose we roll two dice, so p1 and p2 are both the discrete uniform distributions
over {1, 2, . . . , 6}. Let y = x1 + x2 be the sum of the dice. We have
p(y = 2) = p(x1 = 1)p(x2 = 1) = 1
6
1
6
=
1
36
(2.173)
p(y = 3) = p(x1 = 1)p(x2 = 2) + p(x1 = 2)p(x2 = 1) = 1
6
1
6
+
1
6
1
6
=
2
36
(2.174)
· · · (2.175)
Continuing in this way, we find p(y = 4) = 3/36, p(y = 5) = 4/36, p(y = 6) = 5/36, p(y = 7) = 6/36,
p(y = 8) = 5/36, p(y = 9) = 4/36, p(y = 10) = 3/36, p(y = 11) = 2/36 and p(y = 12) = 1/36. See
Figure 2.22 for a plot. We see that the distribution looks like a Gaussian; we explain the reasons for
this in Section 2.8.6.
We can also compute the pdf of the sum of two continuous rv’s. For example, in the case of
Gaussians, where x1 ∼ N (µ1, σ2
1
) and x2 ∼ N (µ2, σ2
2
), one can show (Exercise 2.4) that if y = x1+x2
then
p(y) = N (x1|µ1, σ2
1
) ⊗ N (x2|µ2, σ2
2
) = N (y|µ1 + µ2, σ2
1 + σ
2
2
) (2.176)
Hence the convolution of two Gaussians is a Gaussian.
2.8.6 Central limit theorem
Now consider N random variables with pdf’s (not necessarily Gaussian) pn(x), each with mean
µ and variance σ
2
. We assume each variable is independent and identically distributed or
iid for short, which means Xn ∼ p(X) are independent samples from the same distribution. Let
SN =
PN
n=1 Xn be the sum of the rv’s. One can show that, as N increases, the distribution of this
sum approaches
p(SN = u) = 1
√
2πNσ2
exp 
−
(u − Nµ)
2
2Nσ2

(2.177)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license70 Chapter 2. Probability: Univariate Models
0 0.5 1
0
1
2
3 N = 1
(a)
0 0.5 1
0
1
2
3 N = 5
(b)
Figure 2.23: The central limit theorem in pictures. We plot a histogram of µˆ
s
N =
1
N
PN
n=1 xns, where
xns ∼ Beta(1, 5), for s = 1 : 10000. As N → ∞, the distribution tends towards a Gaussian. (a) N = 1. (b)
N = 5. Adapted from Figure 2.6 of [Bis06]. Generated by code at figures.probml.ai/book1/2.23.
Hence the distribution of the quantity
ZN ,
SN − Nµ
σ
√
N
=
X − µ
σ/√
N
(2.178)
converges to the standard normal, where X = SN /N is the sample mean. This is called the central
limit theorem. See e.g., [Jay03, p222] or [Ric95, p169] for a proof.
In Figure 2.23 we give an example in which we compute the sample mean of rv’s drawn from a
beta distribution. We see that the sampling distribution of this mean rapidly converges to a Gaussian
distribution.
2.8.7 Monte Carlo approximation
Suppose x is a random variable, and y = f(x) is some function of x. It is often difficult to compute the
induced distribution p(y) analytically. One simple but powerful alternative is to draw a large number
of samples from the x’s distribution, and then to use these samples (instead of the distribution) to
approximate p(y).
For example, suppose x ∼ Unif(−1, 1) and y = f(x) = x
2
. We can approximate p(y) by drawing
many samples from p(x) (using a uniform random number generator), squaring them, and
computing the resulting empirical distribution, which is given by
pS(y) ,
1
Ns
X
Ns
s=1
δ(y − ys) (2.179)
This is just an equally weighted “sum of spikes”, each centered on one of the samples (see Section 2.7.6).
By using enough samples, we can approximate p(y) rather well. See Figure 2.24 for an illustration.
This approach is called a Monte Carlo approximation to the distribution. (The term “Monte
Carlo” comes from the name of a famous gambling casino in Monaco.) Monte Carlo techniques were
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.9. Exercises 71
−1 0 1
−0.5
0
0.5
1
1.5
0 0.5 1
0
2
4
6
0 0.5 1
0
0.05
0.1
0.15
0.2
0.25
Figure 2.24: Computing the distribution of y = x
2
, where p(x) is uniform (left). The analytic result is
shown in the middle, and the Monte Carlo approximation is shown on the right. Generated by code at
figures.probml.ai/book1/2.24.
first developed in the area of statistical physics — in particular, during development of the atomic
bomb — but are now widely used in statistics and machine learning as well. More details can be
found in the sequel to this book, [Mur22], as well as specialized books on the topic, such as [Liu01;
RC04; KTB11; BZ20].
2.9 Exercises
Exercise 2.1 [Conditional independence *]
(Source: Koller.)
a. Let H ∈ {1, . . . , K} be a discrete random variable, and let e1 and e2 be the observed values of two other
random variables E1 and E2. Suppose we wish to calculate the vector
P~ (H|e1, e2) = (P(H = 1|e1, e2), . . . , P(H = K|e1, e2))
Which of the following sets of numbers are sufficient for the calculation?
i. P(e1, e2), P(H), P(e1|H), P(e2|H)
ii. P(e1, e2), P(H), P(e1, e2|H)
iii. P(e1|H), P(e2|H), P(H)
b. Now suppose we now assume E1 ⊥ E2|H (i.e., E1 and E2 are conditionally independent given H). Which
of the above 3 sets are sufficient now?
Show your calculations as well as giving the final result. Hint: use Bayes rule.
Exercise 2.2 [Pairwise independence does not imply mutual independence]
We say that two random variables are pairwise independent if
p(X2|X1) = p(X2) (2.180)
and hence
p(X2, X1) = p(X1)p(X2|X1) = p(X1)p(X2) (2.181)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license72 Chapter 2. Probability: Univariate Models
We say that n random variables are mutually independent if
p(Xi|XS) = p(Xi) ∀S ⊆ {1, . . . , n} \ {i} (2.182)
and hence
p(X1:n) = Yn
i=1
p(Xi) (2.183)
Show that pairwise independence between all pairs of variables does not necessarily imply mutual independence.
It suffices to give a counter example.
Exercise 2.3 [Conditional independence iff joint factorizes *]
In the text we said X ⊥ Y |Z iff
p(x, y|z) = p(x|z)p(y|z) (2.184)
for all x, y, z such that p(z) > 0. Now prove the following alternative definition: X ⊥ Y |Z iff there exist
functions g and h such that
p(x, y|z) = g(x, z)h(y, z) (2.185)
for all x, y, z such that p(z) > 0.
Exercise 2.4 [Convolution of two Gaussians is a Gaussian]
Show that the convolution of two Gaussians is a Gaussian, i.e.,
p(y) = N (x1|µ1, σ
2
1) ⊗ N (x2|µ2, σ
2
2) = N (y|µ1 + µ2, σ
2
1 + σ
2
2) (2.186)
where y = x1 + x2, x1 ∼ N (µ1, σ2
1) and x2 ∼ N (µ2, σ2
2).
Exercise 2.5 [Expected value of the minimum of two rv’s *]
Suppose X, Y are two points sampled independently and uniformly at random from the interval [0, 1]. What
is the expected location of the leftmost point?
Exercise 2.6 [Variance of a sum]
Show that the variance of a sum is
V [X + Y ] = V [X] + V [Y ] + 2Cov [X, Y ] , (2.187)
where Cov [X, Y ] is the covariance between X and Y .
Exercise 2.7 [Deriving the inverse gamma density *]
Let X ∼ Ga(a, b), and Y = 1/X. Derive the distribution of Y .
Exercise 2.8 [Mean, mode, variance for the beta distribution]
Suppose θ ∼ Beta(a, b). Show that the mean, mode and variance are given by
E [θ] = a
a + b
(2.188)
V [θ] = ab
(a + b)
2(a + b + 1) (2.189)
mode [θ] = a − 1
a + b − 2
(2.190)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20222.9. Exercises 73
Exercise 2.9 [Bayes rule for medical diagnosis *]
After your yearly checkup, the doctor has bad news and good news. The bad news is that you tested positive
for a serious disease, and that the test is 99% accurate (i.e., the probability of testing positive given that you
have the disease is 0.99, as is the probability of testing negative given that you don’t have the disease). The
good news is that this is a rare disease, striking only one in 10,000 people. What are the chances that you
actually have the disease? (Show your calculations as well as giving the final result.)
Exercise 2.10 [Legal reasoning]
(Source: Peter Lee.) Suppose a crime has been committed. Blood is found at the scene for which there is no
innocent explanation. It is of a type which is present in 1% of the population.
a. The prosecutor claims: “There is a 1% chance that the defendant would have the crime blood type if he
were innocent. Thus there is a 99% chance that he is guilty”. This is known as the prosecutor’s fallacy.
What is wrong with this argument?
b. The defender claims: “The crime occurred in a city of 800,000 people. The blood type would be found in
approximately 8000 people. The evidence has provided a probability of just 1 in 8000 that the defendant
is guilty, and thus has no relevance.” This is known as the defender’s fallacy. What is wrong with this
argument?
Exercise 2.11 [Probabilities are sensitive to the form of the question that was used to generate the answer *]
(Source: Minka.) My neighbor has two children. Assuming that the gender of a child is like a coin flip,
it is most likely, a priori, that my neighbor has one boy and one girl, with probability 1/2. The other
possibilities—two boys or two girls—have probabilities 1/4 and 1/4.
a. Suppose I ask him whether he has any boys, and he says yes. What is the probability that one child is a
girl?
b. Suppose instead that I happen to see one of his children run by, and it is a boy. What is the probability
that the other child is a girl?
Exercise 2.12 [Normalization constant for a 1D Gaussian]
The normalization constant for a zero-mean Gaussian is given by
Z =
Z b
a
exp 
−
x
2
2σ2

dx (2.191)
where a = −∞ and b = ∞. To compute this, consider its square
Z
2 =
Z b
a
Z b
a
exp 
−
x
2 + y
2
2σ2

dxdy (2.192)
Let us change variables from cartesian (x, y) to polar (r, θ) using x = r cos θ and y = r sin θ. Since
dxdy = rdrdθ, and cos2
θ + sin2
θ = 1, we have
Z
2 =
Z 2π
0
Z ∞
0
r exp 
−
r
2
2σ2

drdθ (2.193)
Evaluate this integral and hence show Z =
√
σ22π. Hint 1: separate the integral into a product of two terms,
the first of which (involving dθ) is constant, so is easy. Hint 2: if u = e
−r
2/2σ
2
then du/dr = −
1
σ2 re−r
2/2σ
2
,
so the second integral is also easy (since R
u
0
(r)dr = u(r)).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license3 Probability: Multivariate Models
3.1 Joint distributions for multiple random variables
In this section, we discuss various ways to measure the dependence of one or more variables on each
other.
3.1.1 Covariance
The covariance between two rv’s X and Y measures the degree to which X and Y are (linearly)
related. Covariance is defined as
Cov [X, Y ] , E [(X − E [X])(Y − E [Y ])] = E [XY ] − E [X] E [Y ] (3.1)
If x is a D-dimensional random vector, its covariance matrix is defined to be the following
symmetric, positive semi definite matrix:
Cov [x] , E
h
(x − E [x])(x − E [x])T
i
, Σ (3.2)
=


V [X1] Cov [X1, X2] · · · Cov [X1, XD]
Cov [X2, X1] V [X2] · · · Cov [X2, XD]
.
.
.
.
.
.
.
.
.
.
.
.
Cov [XD, X1] Cov [XD, X2] · · · V [XD]


(3.3)
from which we get the important result
E

xxT

= Σ + µµT
(3.4)
Another useful result is that the covariance of a linear transformation is given by
Cov [Ax + b] = ACov [x] AT
(3.5)
as shown in Exercise 3.4.
The cross-covariance between two random vectors is defined as
Cov [x, y] = E

(x − E [x])(y − E [y])T

(3.6)76 Chapter 3. Probability: Multivariate Models
Figure 3.1: Several sets of (x, y) points, with the correlation coefficient of x and y for each set. Note that
the correlation reflects the noisiness and direction of a linear relationship (top row), but not the slope of
that relationship (middle), nor many aspects of nonlinear relationships (bottom). (Note: the figure in the
center has a slope of 0 but in that case the correlation coefficient is undefined because the variance of Y
is zero.) From https: // en. wikipedia. org/ wiki/ Pearson_ correlation_ coefficient . Used with kind
permission of Wikipedia author Imagecreator.
3.1.2 Correlation
Covariances can be between negative and positive infinity. Sometimes it is more convenient to
work with a normalized measure, with a finite lower and upper bound. The (Pearson) correlation
coefficient between X and Y is defined as
ρ , corr [X, Y ] ,
Cov [X, Y ]
p
V [X] V [Y ]
(3.7)
One can show (Exercise 3.2) that −1 ≤ ρ ≤ 1.
One can also show that corr [X, Y ] = 1 if and only if Y = aX + b (and a > 0) for some parameters
a and b, i.e., if there is a linear relationship between X and Y (see Exercise 3.3). Intuitively one might
expect the correlation coefficient to be related to the slope of the regression line, i.e., the coefficient a
in the expression Y = aX + b. However, as we show in Equation (11.27), the regression coefficient is
in fact given by a = Cov [X, Y ] /V [X]. In Figure 3.1, we show that the correlation coefficient can be
0 for strong, but nonlinear, relationships. (Compare to Figure 6.6.) Thus a better way to think of
the correlation coefficient is as a degree of linearity. (See code.probml.ai/book1/correlation2d for a
demo to illustrate this idea.)
In the case of a vector x of related random variables, the correlation matrix is given by
corr(x) =


1
E[(X1−µ1)(X2−µ2)]
σ1σ2
· · ·
E[(X1−µ1)(XD−µD)]
σ1σD
E[(X2−µ2)(X1−µ1)]
σ2σ1
1 · · ·
E[(X2−µ2)(XD−µD)]
σ2σD
.
.
.
.
.
.
.
.
.
.
.
.
E[(XD−µD)(X1−µ1)]
σDσ1
E[(XD−µD)(X2−µ2)]
σDσ2
· · · 1


(3.8)
This can be written more compactly as
corr(x) = (diag(Kxx))− 1
2 Kxx(diag(Kxx))− 1
2 (3.9)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20223.1. Joint distributions for multiple random variables 77
Figure 3.2: Examples of spurious correlation between causally unrelated time series. Consumption of ice
cream (red) and violent crime rate (yellow). over time. From http: // icbseverywhere. com/ blog/ 2014/
10/ the-logic-of-causal-conclusions/ . Used with kind permission of Barbara Drescher.
where Kxx is the auto-covariance matrix
Kxx = Σ = E

(x − E [x])(x − E [x])T

= Rxx − µµT
(3.10)
and Rxx = E

xxT

is the autocorrelation matrix.
3.1.3 Uncorrelated does not imply independent
If X and Y are independent, meaning p(X, Y ) = p(X)p(Y ), then Cov [X, Y ] = 0, and hence
corr [X, Y ] = 0. So independent implies uncorrelated. However, the converse is not true: uncorrelated
does not imply independent. For example, let X ∼ U(−1, 1) and Y = X2
. Clearly Y is dependent on
X (in fact, Y is uniquely determined by X), yet one can show (Exercise 3.1) that corr [X, Y ] = 0.
Some striking examples of this fact are shown in Figure 3.1. This shows several data sets where
there is clear dependence between X and Y , and yet the correlation coefficient is 0. A more general
measure of dependence between random variables is mutual information, discussed in Section 6.3.
This is zero only if the variables truly are independent.
3.1.4 Correlation does not imply causation
It is well known that “correlation does not imply causation”. For example, consider Figure 3.2.
In red, we plot x1:T , where xt is the amount of ice cream sold in month t. In yellow, we plot y1:T ,
where yt is the violent crime rate in month t. (Quantities have been rescaled to make the plots
overlap.) We see a strong correlation between these signals. Indeed, it is sometimes claimed that
“eating ice cream causes murder” [Pet13]. Of course, this is just a spurious correlation, due to a
hidden common cause, namely the weather. Hot weather increases ice cream sales, for obvious
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license78 Chapter 3. Probability: Multivariate Models
(a) (b)
Figure 3.3: Illustration of Simpson’s paradox. (a) Overall, y decreases y with x. (b) Within each group, y
increases with x. From https: // en. wikipedia. org/ wiki/ Simpson’s_ paradox . Used with kind permission
of Wikipedia author Pace svwiki.
reasons. Hot weather also increases violent crime; the reason for this is hotly (ahem) debated; some
claim it is due to an increase in anger [And01], but other claim it is merely due to more people being
outside [Ash18], where most murders occur.
Another famous example concerns the positive correlation between birth rates and the presence of
storks (a kind of bird). This has given rise to the urban legend that storks deliver babies [Mat00].
Of course, the true reason for the correlation is more likely due to hidden factors, such as increased
living standards and hence more food. Many more amusing examples of such spurious correlations
can be found in [Vig15].
These examples serve as a “warning sign”, that we should not treat the ability for x to predict y as
an indicator that x causes y.
3.1.5 Simpson’s paradox
Simpson’s paradox says that a statistical trend or relationship that appears in several different
groups of data can disappear or reverse sign when these groups are combined. This results in
counterintuitive behavior if we misinterpret claims of statistical dependence in a causal way.
A visualization of the paradox is given in Figure 3.3. Overall, we see that y decreases with x, but
within each subpopulation, y increases with x.
For a recent real-world example of Simpson’s paradox in the context of COVID-19, consider
Figure 3.4(a). This shows that the case fatality rate (CFR) of COVID-19 in Italy is less than in
China in each age group, but is higher overall. The reason for this is that there are more older people
in Italy, as shown in Figure 3.4(b). In other words, Figure 3.4(a) shows p(F = 1|A, C), where A
is age, C is country, and F = 1 is the event that someone dies from COVID-19, and Figure 3.4(b)
shows p(A|C), which is the probability someone is in age bucket A for country C. Combining these,
we find p(F = 1|C = Italy) > p(F = 1|C = China). See [KGS20] for more details.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20223.2. The multivariate Gaussian (normal) distribution 79
0-9 10-19 20-29 30-39 40-49 50-59 60-69 70-79 80+ Total
Age
0
2
4
6
8
10
12
14
%
Case fatality rates (CFRs) by age group
China, 17 February
Italy, 9 March
(a)
0-9 10-19 20-29 30-39 40-49 50-59 60-69 70-79 80+
Age
0
5
10
15
20
%
Proportion of confirmed cases by age group
China, 17 February
Italy, 9 March
(b)
Figure 3.4: Illustration of Simpson’s paradox using COVID-19, (a) Case fatality rates (CFRs) in Italy and
China by age group, and in aggregated form (“Total”, last pair of bars), up to the time of reporting (see legend).
(b) Proportion of all confirmed cases included in (a) within each age group by country. From Figure 1 of
[KGS20]. Used with kind permission of Julius von Kügelgen.
3.2 The multivariate Gaussian (normal) distribution
The most widely used joint probability distribution for continuous random variables is the multi￾variate Gaussian or multivariate normal (MVN). This is mostly because it is mathematically
convenient, but also because the Gaussian assumption is fairly reasonable in many cases (see the
discussion in Section 2.6.4).
3.2.1 Definition
The MVN density is defined by the following:
N (y|µ, Σ) ,
1
(2π)D/2|Σ|
1/2
exp 
−
1
2
(y − µ)
TΣ
−1
(y − µ)

(3.11)
where µ = E [y] ∈ R
D is the mean vector, and Σ = Cov [y] is the D × D covariance matrix,
defined as follows:
Cov [y] , E
h
(y − E [y])(y − E [y])T
i
(3.12)
=


V [Y1] Cov [Y1, Y2] · · · Cov [Y1, YD]
Cov [Y2, Y1] V [Y2] · · · Cov [Y2, YD]
.
.
.
.
.
.
.
.
.
.
.
.
Cov [YD, Y1] Cov [YD, Y2] · · · V [YD]


(3.13)
where
Cov [Yi
, Yj ] , E [(Yi − E [Yi
])(Yj − E [Yj ])] = E [YiYj ] − E [Yi
] E [Yj ] (3.14)
and V [Yi
] = Cov [Yi
, Yi
]. From Equation (3.12), we get the important result
E

yyT

= Σ + µµT
(3.15)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license80 Chapter 3. Probability: Multivariate Models
(a) (b) (c)
Figure 3.5: Visualization of a 2d Gaussian density as a surface plot. (a) Distribution using a full covariance
matrix can be oriented at any angle. (b) Distribution using a diagonal covariance matrix must be parallel to
the axis. (c) Distribution using a spherical covariance matrix must have a symmetric shape. Generated by
code at figures.probml.ai/book1/3.5.
full
-5 0 5
-10
-8
-6
-4
-2
0
2
4
6
8
10
(a)
diagonal
-5 0 5
-10
-8
-6
-4
-2
0
2
4
6
8
10
(b)
spherical
-5 0 5
-5
-4
-3
-2
-1
0
1
2
3
4
5
(c)
Figure 3.6: Visualization of a 2d Gaussian density in terms of level sets of constant probability density. (a) A
full covariance matrix has elliptical contours. (b) A diagonal covariance matrix is an axis aligned ellipse.
(c) A spherical covariance matrix has a circular shape. Generated by code at figures.probml.ai/book1/3.6.
The normalization constant in Equation (3.11) Z = (2π)
D/2
|Σ|
1/2
just ensures that the pdf
integrates to 1 (see Exercise 3.6).
In 2d, the MVN is known as the bivariate Gaussian distribution. Its pdf can be represented as
y ∼ N (µ, Σ), where y ∈ R
2
, µ ∈ R
2 and
Σ =

σ
2
1 σ
2
12
σ
2
21 σ
2
2

=

σ
2
1 ρσ1σ2
ρσ1σ2 σ
2
2

(3.16)
where ρ is the correlation coefficient, defined by
corr [Y1, Y2] ,
Cov [Y1, Y2]
p
V [Y1] V [Y2]
=
σ
2
12
σ1σ2
(3.17)
One can show (Exercise 3.2) that −1 ≤ corr [Y1, Y2] ≤ 1. Expanding out the pdf in the 2d case gives
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20223.2. The multivariate Gaussian (normal) distribution 81
the following rather intimidating-looking result:
p(y1, y2) = 1
2πσ1σ2
p
1 − ρ
2
exp 
−
1
2(1 − ρ
2)
×

(y1 − µ1)
2
σ
2
1
+
(y2 − µ2)
2
σ
2
2
− 2ρ
(y1 − µ1)
σ1
(y2 − µ2)
σ2
 (3.18)
Figure 3.5 and Figure 3.6 plot some MVN densities in 2d for three different kinds of covariance
matrices. A full covariance matrix has D(D + 1)/2 parameters, where we divide by 2 since Σ is
symmetric. (The reason for the elliptical shape is explained in Section 7.4.4, where we discuss the
geometry of quadratic forms.) A diagonal covariance matrix has D parameters, and has 0s in the
off-diagonal terms. A spherical covariance matrix, also called isotropic covariance matrix,
has the form Σ = σ
2
ID, so it only has one free parameter, namely σ
2
.
3.2.2 Mahalanobis distance
In this section, we attempt to gain some insights into the geometric shape of the Gaussian pdf
in multiple dimensions. To do this, we will consider the shape of the level sets of constant (log)
probability.
The log probability at a specific point y is given by
log p(y|µ, Σ) = −
1
2
(y − µ)
TΣ
−1
(y − µ) + const (3.19)
The dependence on y can be expressed in terms of the Mahalanobis distance ∆ between y and µ,
whose square is defined as follows:
∆2 , (y − µ)
TΣ
−1
(y − µ) (3.20)
Thus contours of constant (log) probability are equivalent to contours of constant Mahalanobis
distance.
To gain insight into the contours of constant Mahalanobis distance, we exploit the fact that Σ,
and hence Λ = Σ
−1
, are both positive definite matrices (by assumption). Consider the following
eigendecomposition (Section 7.4) of Σ:
Σ =
X
D
d=1
λdudu
T
d
(3.21)
We can similarly write
Σ
−1 =
X
D
d=1
1
λd
udu
T
d
(3.22)
Let us define zd , u
T
d
(y − µ), so z = U(y − µ). Then we can rewrite the Mahalanobis distance as
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license82 Chapter 3. Probability: Multivariate Models
follows:
(y − µ)
TΣ
−1
(y − µ) = (y − µ)
T
 X
D
d=1
1
λd
udu
T
d
!
(y − µ) (3.23)
=
X
D
d=1
1
λd
(y − µ)
Tudu
T
d
(y − µ) = X
D
d=1
z
2
d
λd
(3.24)
As we discuss in Section 7.4.4, this means we can interpret the Mahalanobis distance as Euclidean
distance in a new coordinate frame z in which we rotate y by U and scale by Λ.
For example, in 2d, let us consider the set of points (z1, z2) that satisfy this equation:
z
2
1
λ1
+
z
2
2
λ2
= r (3.25)
Since these points have the same Mahalanobis distance, they correspond to points of equal probability.
Hence we see that the contours of equal probability density of a 2d Gaussian lie along ellipses. This is
illustrated in Figure 7.6. The eigenvectors determine the orientation of the ellipse, and the eigenvalues
determine how elongated it is.
3.2.3 Marginals and conditionals of an MVN *
Suppose y = (y1, y2) is jointly Gaussian with parameters
µ =

µ1
µ2

, Σ =

Σ11 Σ12
Σ21 Σ22
, Λ = Σ
−1 =

Λ11 Λ12
Λ21 Λ22
(3.26)
where Λ is the precision matrix. Then the marginals are given by
p(y1) = N (y1|µ1, Σ11)
p(y2) = N (y2|µ2, Σ22)
(3.27)
and the posterior conditional is given by
p(y1|y2) = N (y1|µ1|2, Σ1|2)
µ1|2 = µ1 + Σ12Σ
−1
22 (y2 − µ2)
= µ1 − Λ
−1
11 Λ12(y2 − µ2)
= Σ1|2 (Λ11µ1 − Λ12(y2 − µ2))
Σ1|2 = Σ11 − Σ12Σ
−1
22 Σ21 = Λ
−1
11
(3.28)
These equations are of such crucial importance in this book that we have put a box around them,
so you can easily find them later. For the derivation of these results (which relies on computing the
Schur complement Σ/Σ22 = Σ11 − Σ12Σ
−1
22 Σ21), see Section 7.3.5.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20223.2. The multivariate Gaussian (normal) distribution 83
We see that both the marginal and conditional distributions are themselves Gaussian. For the
marginals, we just extract the rows and columns corresponding to y1 or y2. For the conditional, we
have to do a bit more work. However, it is not that complicated: the conditional mean is just a
linear function of y2, and the conditional covariance is just a constant matrix that is independent of
y2. We give three different (but equivalent) expressions for the posterior mean, and two different
(but equivalent) expressions for the posterior covariance; each one is useful in different circumstances.
3.2.4 Example: conditioning a 2d Gaussian
Let us consider a 2d example. The covariance matrix is
Σ =

σ
2
1 ρσ1σ2
ρσ1σ2 σ
2
2

(3.29)
The marginal p(y1) is a 1D Gaussian, obtained by projecting the joint distribution onto the y1 line:
p(y1) = N (y1|µ1, σ2
1
) (3.30)
Suppose we observe Y2 = y2; the conditional p(y1|y2) is obtained by “slicing” the joint distribution
through the Y2 = y2 line:
p(y1|y2) = N

y1|µ1 +
ρσ1σ2
σ
2
2
(y2 − µ2), σ2
1 −
(ρσ1σ2)
2
σ
2
2

(3.31)
If σ1 = σ2 = σ, we get
p(y1|y2) = N
￾
y1|µ1 + ρ(y2 − µ2), σ2
(1 − ρ
2
)

(3.32)
For example, suppose ρ = 0.8, σ1 = σ2 = 1, µ1 = µ2 = 0, and y2 = 1. We see that E [y1|y2 = 1] =
0.8, which makes sense, since ρ = 0.8 means that we believe that if y2 increases by 1 (beyond its
mean), then y1 increases by 0.8. We also see V [y1|y2 = 1] = 1 − 0.8
2 = 0.36. This also makes sense:
our uncertainty about y1 has gone down, since we have learned something about y1 (indirectly) by
observing y2. If ρ = 0, we get p(y1|y2) = N
￾
y1|µ1, σ2
1

, since y2 conveys no information about y1 if
they are uncorrelated (and hence independent).
3.2.5 Example: Imputing missing values *
As an example application of the above results, suppose we observe some parts (dimensions) of y,
with the remaining parts being missing or unobserved. We can exploit the correlation amongst the
dimensions (encoded by the covariance matrix) to infer the missing entries; this is called missing
value imputation.
Figure 3.7 shows a simple example. We sampled N vectors from a D = 10-dimensional Gaussian,
and then deliberately “hid” 50% of the data in each sample (row). We then inferred the missing
entries given the observed entries and the true model parameters.1 More precisely, for each row n of
1. In practice, we would need to estimate the parameters from the partially observed data. Unfortunately the MLE
results in Section 4.2.6 no longer apply, but we can use the EM algorithm to derive an approximate MLE in the
presence of missing data. See the sequel to this book for details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licen84 Chapter 3. Probability: Multivariate Models
0 1 2 3 4 5 6 7 8 9
0
1
2
3
4
5
6
7
Observed
(a)
0 1 2 3 4 5 6 7 8 9
0
1
2
3
4
5
6
7
Hidden truth
(b)
0 1 2 3 4 5 6 7 8 9
0
1
2
3
4
5
6
7
Imputation with true params
(c)
Figure 3.7: Illustration of data imputation using an MVN. (a) Visualization of the data matrix. Blank entries
are missing (not observed). Blue are positive, green are negative. Area of the square is proportional to the
value. (This is known as a Hinton diagram, named after Geoff Hinton, a famous ML researcher.) (b) True
data matrix (hidden). (c) Mean of the posterior predictive distribution, based on partially observed data in
that row, using the true model parameters. Generated by code at figures.probml.ai/book1/3.7.
the data matrix, we compute p(yn,h|yn,v, θ), where v are the indices of the visible entries in that
row, h are the remaining indices of the hidden entries, and θ = (µ, Σ). From this, we compute the
marginal distribution of each missing variable i ∈ h, p(yn,i|yn,v, θ). From the marginal, we compute
the posterior mean, y¯n,i = E [yn,i|yn,v, θ].
The posterior mean represents our “best guess” about the true value of that entry, in the sense
that it minimizes our expected squared error, as explained in Chapter 5. We can use V [yn,i|yn,v, θ]
as a measure of confidence in this guess, although this is not shown. Alternatively, we could draw
multiple posterior samples from p(yn,h|yn,v, θ); this is called multiple imputation, and provides a
more robust estimate to downstream algorithms that consume the “filled in” data.
3.3 Linear Gaussian systems *
In Section 3.2.3, we conditioned on noise-free observations to infer the posterior over the hidden parts
of a Gaussian random vector. In this section, we extend this approach to handle noisy observations.
Let z ∈ R
L be an unknown vector of values, and y ∈ R
D be some noisy measurement of z. We
assume these variables are related by the following joint distribution:
p(z) = N (z|µz, Σz) (3.33)
p(y|z) = N (y|Wz + b, Σy) (3.34)
where W is a matrix of size D × L. This is an example of a linear Gaussian system.
The corresponding joint distribution, p(z, y) = p(z)p(y|z), is a L + D dimensional Gaussian, with
mean and covariance given by
µ =

µz
Wµz + b

(3.35)
Σ =

Σz ΣzWT
WΣz Σy + WΣzWT

(3.36)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20223.3. Linear Gaussian systems * 85
By applying the Gaussian conditioning formula in Equation (3.28) to the joint p(y, z) we can
compute the posterior p(z|y), as we explain below. This can be interpreted as inverting the z → y
arrow in the generative model from latents to observations.
3.3.1 Bayes rule for Gaussians
The posterior over the latent is given by
p(z|y) = N (z|µz|y, Σz|y)
Σ
−1
z|y = Σ
−1
z + WTΣ
−1
y W
µz|y = Σz|y[WTΣ
−1
y
(y − b) + Σ
−1
z µz]
(3.37)
This is known as Bayes’ rule for Gaussians. Furthermore, the normalization constant of the
posterior is given by
p(y) = Z
N (z|µz, Σz)N (y|Wz + b, Σy)dz = N (y|Wµz + b, Σy + WΣzWT
) (3.38)
We see that the Gaussian prior p(z), combined with the Gaussian likelihood p(y|z), results in a
Gaussian posterior p(z|y). Thus Gaussians are closed under Bayesian conditioning. To describe this
more generally, we say that the Gaussian prior is a conjugate prior for the Gaussian likelihood,
since the posterior distribution has the same type as the prior. We discuss the notion of conjugate
priors in more detail in Section 4.6.1.
In the sections below, we give various applications of this result. But first, we give the derivation.
3.3.2 Derivation *
We now derive Equation 3.37. The basic idea is to derive the joint distribution, p(z, y) = p(z)p(y|z),
and then to use the results from Section 3.2.3 for computing p(z|y).
In more detail, we proceed as follows. The log of the joint distribution is as follows (dropping
irrelevant constants):
log p(z, y) = −
1
2
(z − µz)
T Σ
−1
z
(z − µz) −
1
2
(y − Wz − b)
T Σ
−1
y
(y − Wz − b) (3.39)
This is clearly a joint Gaussian distribution, since it is the exponential of a quadratic form.
Expanding out the quadratic terms involving z and y, and ignoring linear and constant terms, we
have
Q = −
1
2
z
T Σ
−1
z z −
1
2
y
T Σ
−1
y y −
1
2
(Wz)
T Σ
−1
y
(Wz) + y
T Σ
−1
y Wz (3.40)
= −
1
2

z
y
T 
Σ
−1
z + WT Σ
−1
y W −WT Σ
−1
y
−Σ
−1
y W Σ−1
y
 z
y

(3.41)
= −
1
2

z
y
T
Σ
−1

z
y

(3.42)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license86 Chapter 3. Probability: Multivariate Models
where the precision matrix of the joint is defined as
Σ
−1 =

Σ
−1
z + WT Σ
−1
y W −WT Σ
−1
y
−Σ
−1
y W Σ−1
y

, Λ =

Λxx Λxy
Λyx Λyy
(3.43)
From Equation 3.28, and using the fact that µy = Wµz + b, we have
p(z|y) = N (µz|y, Σz|y) (3.44)
Σz|y = Λ
−1
xx = (Σ
−1
z + WT Σ
−1
y W)
−1
(3.45)
µz|y = Σz|y (Λxxµz − Λxy(y − µy)) (3.46)
= Σz|y
￾
Σ
−1
z µz + WTΣ
−1
y Wµz + WT Σ
−1
y
(y − µy)

(3.47)
= Σz|y
￾
Σ
−1
z µz + WTΣ
−1
y
(Wµz + y − µy)

(3.48)
= Σz|y
￾
Σ
−1
z µz + WT Σ
−1
y
(y − b)

(3.49)
3.3.3 Example: Inferring an unknown scalar
Suppose we make N noisy measurements yi of some underlying quantity z; let us assume the
measurement noise has fixed precision λy = 1/σ2
, so the likelihood is
p(yi
|z) = N (yi
|z, λ−1
y
) (3.50)
Now let us use a Gaussian prior for the value of the unknown source:
p(z) = N (z|µ0, λ−1
0
) (3.51)
We want to compute p(z|y1, . . . , yN , σ2
). We can convert this to a form that lets us apply Bayes
rule for Gaussians by defining y = (y1, . . . , yN ), W = 1N (an N × 1 column vector of 1’s), and
Σ
−1
y = diag(λyI). Then we get
p(z|y) = N (z|µN , λ−1
N ) (3.52)
λN = λ0 + Nλy (3.53)
µN =
Nλyy + λ0µ0
λN
=
Nλy
Nλy + λ0
y +
λ0
Nλy + λ0
µ0 (3.54)
These equations are quite intuitive: the posterior precision λN is the prior precision λ0 plus N units
of measurement precision λy. Also, the posterior mean µN is a convex combination of the MLE y
and the prior mean µ0. This makes it clear that the posterior mean is a compromise between the
MLE and the prior. If the prior is weak relative to the signal strength (λ0 is small relative to λy), we
put more weight on the MLE. If the prior is strong relative to the signal strength (λ0 is large relative
to λy), we put more weight on the prior. This is illustrated in Figure 3.8.
Note that the posterior mean is written in terms of Nλyy, so having N measurements each of
precision λy is like having one measurement with value y and precision Nλy.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 23.3. Linear Gaussian systems * 87
5 0 5
0.0
0.1
0.2
0.3
0.4
0.5
0.6
prior variance of 1
prior
lik
post
(a)
5 0 5
0.0
0.1
0.2
0.3
0.4
0.5
0.6
prior variance of 5
prior
lik
post
(b)
Figure 3.8: Inference about z given a noisy observation y = 3. (a) Strong prior N (0, 1). The posterior mean
is “shrunk” towards the prior mean, which is 0. (b) Weak prior N (0, 5). The posterior mean is similar to the
MLE. Generated by code at figures.probml.ai/book1/3.8.
We can rewrite the results in terms of the posterior variance, rather than posterior precision, as
follows:
p(z|D, σ2
) = N (z|µN , τ 2
N ) (3.55)
τ
2
N =
1
N
σ2 +
1
τ
2
0
=
σ
2
τ
2
0
Nτ 2
0 + σ
2
(3.56)
µN = τ
2
N

µ0
τ
2
0
+
Ny
σ
2

=
σ
2
Nτ 2
0 + σ
2
µ0 +
Nτ 2
0
Nτ 2
0 + σ
2
y (3.57)
where τ
2
0 = 1/λ0 is the prior variance and τ
2
N = 1/λN is the posterior variance.
We can also compute the posterior sequentially, by updating after each observation. If N = 1,
we can rewrite the posterior after seeing a single observation as follows (where we define Σy = σ
2
,
Σ0 = τ
2
0 and Σ1 = τ
2
1
to be the variances of the likelihood, prior and posterior):
p(z|y) = N (z|µ1, Σ1) (3.58)
Σ1 =

1
Σ0
+
1
Σy
−1
=
ΣyΣ0
Σ0 + Σy
(3.59)
µ1 = Σ1

µ0
Σ0
+
y
Σy

(3.60)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license88 Chapter 3. Probability: Multivariate Models
We can rewrite the posterior mean in 3 different ways:
µ1 =
Σy
Σy + Σ0
µ0 +
Σ0
Σy + Σ0
y (3.61)
= µ0 + (y − µ0)
Σ0
Σy + Σ0
(3.62)
= y − (y − µ0)
Σy
Σy + Σ0
(3.63)
The first equation is a convex combination of the prior and the data. The second equation is the
prior mean adjusted towards the data. The third equation is the data adjusted towards the prior
mean; this is called shrinkage. These are all equivalent ways of expressing the tradeoff between
likelihood and prior. If Σ0 is small relative to Σy, corresponding to a strong prior, the amount of
shrinkage is large (see Figure 3.8(a)), whereas if Σ0 is large relative to Σy, corresponding to a weak
prior, the amount of shrinkage is small (see Figure 3.8(b)).
Another way to quantify the amount of shrinkage is in terms of the signal-to-noise ratio, which
is defined as follows:
SNR ,
E

Z
2

E [
2]
=
Σ0 + µ
2
0
Σy
(3.64)
where z ∼ N (µ0, Σ0) is the true signal, y = z +  is the observed signal, and  ∼ N (0, Σy) is the
noise term.
3.3.4 Example: inferring an unknown vector
Suppose we have an unknown quantity of interest, z ∈ R
D, which we endow with a Gaussian prior,
p(z) = N (µz, Σz). If we “know nothing” about z a priori, we can set Σz = ∞I, which means we are
completely uncertain about what the value of z should be. (In practice, we can use a large but finite
value for the covariance.) By symmetry, it seems reasonable to set µz = 0.
Now suppose we make N noisy but independent measurements of z, yn ∼ N (z, Σy), each of size
D. We can represent the likelihood as follows:
p(D|z) = Y
N
n=1
N (yn|z, Σy) = N (y|z,
1
N
Σy) (3.65)
Note that we can replace the N observations with their average, y, provided we scale down the
covariance by 1/N to compensate. Setting W = I, b = 0, we can then use Bayes rule for Gaussian
to compute the posterior over z:
p(z|y1, . . . , yN ) = N (z|
aµ,
a
Σ) (3.66)
a
Σ
−1
= Σ
−1
z + NΣ
−1
y
(3.67)
aµ =
a
Σ (Σ
−1
y
(Ny) + Σ
−1
z µz) (3.68)
where aµ and a
Σ are the parameters of the posterior.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20223.3. Linear Gaussian systems * 89
1.00 0.75 0.50 0.25 0.00 0.25 0.50 0.75 1.00
1.00
0.75
0.50
0.25
0.00
0.25
0.50
0.75
1.00
data
(a)
1.00 0.75 0.50 0.25 0.00 0.25 0.50 0.75 1.00
1.00
0.75
0.50
0.25
0.00
0.25
0.50
0.75
1.00 prior
(b)
1.00 0.75 0.50 0.25 0.00 0.25 0.50 0.75 1.00
1.00
0.75
0.50
0.25
0.00
0.25
0.50
0.75
1.00 post after 10 observation
(c)
Figure 3.9: Illustration of Bayesian inference for a 2d Gaussian random vector z. (a) The data is generated
from yn ∼ N (z, Σy), where z = [0.5, 0.5]T
and Σy = 0.1[2, 1; 1, 1]). We assume the sensor noise covariance
Σy is known but z is unknown. The black cross represents z. (b) The prior is p(z) = N (z|0, 0.1I2). (c) We
show the posterior after 10 data points have been observed. Generated by code at figures.probml.ai/book1/3.9.
Figure 3.9 gives a 2d example. We can think of z as representing the true, but unknown, location
of an object in 2d space, such as a missile or airplane, and the yn as being noisy observations, such
as radar “blips”. As we receive more blips, we are better able to localize the source. (In the sequel to
this book, [Mur22], we discuss the Kalman filter algorithm, which extends this idea to a temporal
sequence of observations.)
The posterior uncertainty about each component of z location vector depends on how reliable the
sensor is in each of these dimensions. In the above example, the measurement noise in dimension 1 is
higher than in dimension 2, so we have more posterior uncertainty about z1 (horizontal axis) than
about z2 (vertical axis).
3.3.5 Example: sensor fusion
In this section, we extend Section 3.3.4, to the case where we have multiple measurements, coming
from different sensors, each with different reliabilities. That is, the model has the form
p(z, y) = p(z)
Y
M
m=1
N
Ym
n=1
N (yn,m|z, Σm) (3.69)
where M is the number of sensors (measurement devices), and Nm is the number of observations
from sensor m, and y = y1:N,1:M ∈ R
K. Our goal is to combine the evidence together, to compute
p(z|y). This is known as sensor fusion.
We now give a simple example, where there are just two sensors, so y1 ∼ N (z, Σ1) and y2 ∼
N (z, Σ2). Pictorially, we can represent this example as y1 ← z → y2. We can combine y1 and y2
into a single vector y, so the model can be represented as z → [y1, y2], where p(y|z) = N (y|Wz, Σy),
where W = [I; I] and Σy = [Σ1, 0; 0, Σ2] are block-structured matrices. We can then apply Bayes’
rule for Gaussians to compute p(z|y).
Figure 3.10(a) gives a 2d example, where we set Σ1 = Σ2 = 0.01I2, so both sensors are equally
reliable. In this case, the posterior mean is halfway between the two observations, y1 and y2. In
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license90 Chapter 3. Probability: Multivariate Models
0.2 0.0 0.2 0.4 0.6 0.8 1.0 1.2
1.2
1.0
0.8
0.6
0.4
0.2
0.0
0.2
(a)
0.50 0.25 0.00 0.25 0.50 0.75 1.00 1.25
1.50
1.25
1.00
0.75
0.50
0.25
0.00
0.25
(b)
0.75 0.50 0.25 0.00 0.25 0.50 0.75 1.00 1.25
1.25
1.00
0.75
0.50
0.25
0.00
0.25
0.50
0.75
(c)
Figure 3.10: We observe y1 = (0, −1) (red cross) and y2 = (1, 0) (green cross) and estimate E [z|y1, y2]
(black cross). (a) Equally reliable sensors, so the posterior mean estimate is in between the two circles. (b)
Sensor 2 is more reliable, so the estimate shifts more towards the green circle. (c) Sensor 1 is more reliable
in the vertical direction, Sensor 2 is more reliable in the horizontal direction. The estimate is an appropriate
combination of the two measurements. Generated by code at figures.probml.ai/book1/3.10.
Figure 3.10(b), we set Σ1 = 0.05I2 and Σ2 = 0.01I2, so sensor 2 is more reliable than sensor 1. In
this case, the posterior mean is closer to y2. In Figure 3.10(c), we set
Σ1 = 0.01 
10 1
1 1
, Σ2 = 0.01 
1 1
1 10
(3.70)
so sensor 1 is more reliable in the second component (vertical direction), and sensor 2 is more reliable
in the first component (horizontal direction). In this case, the posterior mean uses y1’s vertical
component and y2’s horizontal component.
3.4 The exponential family *
In this section, we define the exponential family, which includes many common probability
distributions. The exponential family plays a crucial role in statistics and machine learning. In this
book, we mainly use it in the context of generalized linear models, which we discuss in Chapter 12.
We will see more applications of the exponential family in the sequel to this book, [Mur22].
3.4.1 Definition
Consider a family of probability distributions parameterized by η ∈ R
K with fixed support over
Y
D ⊆ R
D. We say that the distribution p(y|η) is in the exponential family if its density can be
written in the following way:
p(y|η) ,
1
Z(η)
h(y) exp[η
T
T (y)] = h(y) exp[η
T
T (y) − A(η)] (3.71)
where h(y) is a scaling constant (also known as the base measure, often 1), T (y) ∈ R
K are
the sufficient statistics, η are the natural parameters or canonical parameters, Z(η) is a
normalization constant known as the partition function, and A(η) = log Z(η) is the log partition
function. One can show that A is a convex function over the concave set Ω , {η ∈ R
K : A(η) < ∞}.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20223.4. The exponential family * 91
It is convenient if the natural parameters are independent of each other. Formally, we say that an
exponential family is minimal if there is no η ∈ R
K \ {0} such that η
TT (y) = 0. This last condition
can be violated in the case of multinomial distributions, because of the sum to one constraint on
the parameters; however, it is easy to reparameterize the distribution using K − 1 independent
parameters, as we show below.
Equation (3.71) can be generalized by defining η = f(φ), where φ is some other, possibly smaller,
set of parameters. In this case, the distribution has the form
p(y|φ) = h(y) exp[f(φ)
T
T (y) − A(f(φ))] (3.72)
If the mapping from φ to η is nonlinear, we call this a curved exponential family. If η = f(φ) = φ,
the model is said to be in canonical form. If, in addition, T (y) = y, we say this is a natural
exponential family or NEF. In this case, it can be written as
p(y|η) = h(y) exp[η
Ty − A(η)] (3.73)
3.4.2 Example
As a simple example, let us consider the Bernoulli distribution. We can write this in exponential
family form as follows:
Ber(y|µ) = µ
y
(1 − µ)
1−y
(3.74)
= exp[y log(µ) + (1 − y) log(1 − µ)] (3.75)
= exp[T (y)
Tη] (3.76)
where T (y) = [I(y = 1),I(y = 0)], η = [log(µ), log(1 − µ)], and µ is the mean parameter. However,
this is an over-complete representation since there is a linear dependence between the features.
We can see this as follows:
1
T
T (y) = I(y = 0) + I(y = 1) = 1 (3.77)
If the representation is overcomplete, η is not uniquely identifiable. It is common to use a minimal
representation, which means there is a unique η associated with the distribution. In this case, we
can just define
Ber(y|µ) = exp 
y log 
µ
1 − µ

+ log(1 − µ)

(3.78)
We can put this into exponential family form by defining
η = log 
µ
1 − µ

(3.79)
T (y) = y (3.80)
A(η) = − log(1 − µ) = log(1 + e
η
) (3.81)
h(y) = 1 (3.82)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license92 Chapter 3. Probability: Multivariate Models
We can recover the mean parameter µ from the canonical parameter η using
µ = σ(η) = 1
1 + e−η
(3.83)
which we recognize as the logistic (sigmoid) function.
See the sequel to this book, [Mur22], for more examples.
3.4.3 Log partition function is cumulant generating function
The first and second cumulants of a distribution are its mean E [Y ] and variance V [Y ], whereas the
first and second moments are E [Y ] and E

Y
2

. We can also compute higher order cumulants (and
moments). An important property of the exponential family is that derivatives of the log partition
function can be used to generate all the cumulants of the sufficient statistics. In particular, the
first and second cumulants are given by
∇A(η) = E [T (y)] (3.84)
∇2A(η) = Cov [T (y)] (3.85)
From the above result, we see that the Hessian is positive definite, and hence A(η) is convex in η.
Since the log likelihood has the form log p(y|η) = η
TT (y) − A(η) + const, we see that this is concave,
and hence the MLE has a unique global maximum.
3.4.4 Maximum entropy derivation of the exponential family
Suppose we want to find a distribution p(x) to describe some data, where all we know are the
expected values (Fk) of certain features or functions fk(x):
Z
dx p(x)fk(x) = Fk (3.86)
For example, f1 might compute x, f2 might compute x
2
, making F1 the empirical mean and F2 the
empirical second moment. Our prior belief in the distribution is q(x).
To formalize what we mean by “least number of assumptions”, we will search for the distribution
that is as close as possible to our prior q(x), in the sense of KL divergence (Section 6.2), while
satisfying our constraints:
p = argmin
p
DKL (pkq) subject to constraints (3.87)
If we use a uniform prior, q(x) ∝ 1, minimizing the KL divergence is equivalent to maximizing the
entropy (Section 6.1):
p = argmax
p
H(p) subject to constraints (3.88)
The result is called a maximum entropy model.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20223.5. Mixture models 93
To minimize the KL subject to the constraints in Equation (3.86), and the constraint that p(x) ≥ 0
and P
x
p(x) = 1, we will use Lagrange multipliers (see Section 8.5.1). The Lagrangian is given by
J(p, λ) = −
X
x
p(x) log p(x)
q(x)
+ λ0
 
1 −
X
x
p(x)
!
+
X
k
λk
 
Fk −
X
x
p(x)fk(x)
!
(3.89)
We can use the calculus of variations to take derivatives wrt the function p, but we will adopt a
simpler approach and treat p as a fixed length vector (since we are assuming that x is discrete).
Then we have
∂J
∂pc
= −1 − log p(x = c)
q(x = c)
− λ0 −
X
k
λkfk(x = c) (3.90)
Setting ∂J
∂pc
= 0 for each c yields
p(x) = q(x)
Z
exp 
−
X
k
λkfk(x)
!
(3.91)
where we have defined Z , e
1+λ0
. Using the sum-to-one constraint, we have
1 = X
x
p(x) = 1
Z
X
x
q(x) exp 
−
X
k
λkfk(x)
!
(3.92)
Hence the normalization constant is given by
Z =
X
x
q(x) exp 
−
X
k
λkfk(x)
!
(3.93)
This has exactly the form of the exponential family, where f(x) is the vector of sufficient statistics,
−λ are the natural parameters, and q(x) is our base measure.
For example, if the features are f1(x) = x and f2(x) = x
2
, and we want to match the first and
second moments, we get the Gaussian disribution.
3.5 Mixture models
One way to create more complex probability models is to take a convex combination of simple
distributions. This is called a mixture model. This has the form
p(y|θ) = X
K
k=1
πkpk(y) (3.94)
where pk is the k’th mixture component, and πk are the mixture weights which satisfy 0 ≤ πk ≤ 1
and PK
k=1 πk = 1.
We can re-express this model as a hierarchical model, in which we introduce the discrete latent
variable z ∈ {1, . . . , K}, which specifies which distribution to use for generating the output y. The
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license94 Chapter 3. Probability: Multivariate Models
0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
0.2
0.3
0.4
0.5
0.6
0.7
0.8
(a) (b)
Figure 3.11: A mixture of 3 Gaussians in 2d. (a) We show the contours of constant probability for each
component in the mixture. (b) A surface plot of the overall density. Adapted from Figure 2.23 of [Bis06].
Generated by code at figures.probml.ai/book1/3.11
prior on this latent variable is p(z = k|θ) = πk, and the conditional is p(y|z = k, θ) = pk(y) = p(y|θk).
That is, we define the following joint model:
p(z|θ) = Cat(z|π) (3.95)
p(y|z = k, θ) = p(y|θk) (3.96)
where θ = (π1, . . . , πK, θ1, . . . , θK) are all the model parameters. The “generative story” for the data
is that we first sample a specific component z, and then we generate the observations y using the
parameters chosen according to the value of z. By marginalizing out z, we recover Equation (3.94):
p(y|θ) = X
K
k=1
p(z = k|θ)p(y|z = k, θ) = X
K
k=1
πkp(y|θk) (3.97)
We can create different kinds of mixture model by varying the base distribution pk, as we illustrate
below.
3.5.1 Gaussian mixture models
A Gaussian mixture model or GMM, also called a mixture of Gaussians (MoG), is defined
as follows:
p(y|θ) = X
K
k=1
πkN (y|µk, Σk) (3.98)
In Figure 3.11 we show the density defined by a mixture of 3 Gaussians in 2d. Each mixture
component is represented by a different set of elliptical contours. If we let the number of mixture
components grow sufficiently large, a GMM can approximate any smooth distribution over R
D.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20223.5. Mixture models 95
8 6 4 2 0 2 4
2
0
2
4
(a)
8 6 4 2 0 2 4
2
0
2
4
(b)
Figure 3.12: (a) Some data in 2d. (b) A possible clustering using K = 5 clusters computed using a GMM.
Generated by code at figures.probml.ai/book1/3.12.
GMMs are often used for unsupervised clustering of real-valued data samples yn ∈ R
D. This
works in two stages. First we fit the model e.g., by computing the MLE θˆ = argmax log p(D|θ), where
D = {yn : n = 1 : N}. (We discuss how to compute this MLE in Section 8.7.3.) Then we associate
each data point yn with a discrete latent or hidden variable zn ∈ {1, . . . , K} which specifies the
identity of the mixture component or cluster which was used to generate yn. These latent identities
are unknown, but we can compute a posterior over them using Bayes rule:
rnk , p(zn = k|xn, θ) = p(zn = k|θ)p(xn|zn = k, θ)
PK
k0=1 p(zn = k
0
|θ)p(xn|zn = k
0
, θ)
(3.99)
The quantity rnk is called the responsibility of cluster k for data point n. Given the responsibilities,
we can compute the most probable cluster assignment as follows:
zˆn = arg max
k
rnk = arg max
k
[log p(xn|zn = k, θ) + log p(zn = k|θ)] (3.100)
This is known as hard clustering. (If we use the responsibilities to fractionally assign each data
point to different clusters, it is called soft clustering.) See Figure 3.12 for an example.
If we have a uniform prior over zn, and we use spherical Gaussians with Σk = I, the hard clustering
problem reduces to
zn = argmin
k
||yn − µˆk||2
2
(3.101)
In other words, we assign each data point to its closest centroid, as measured by Euclidean distance.
This is the basis of the K-means clustering algorithm, which we discuss in Section 21.3.
3.5.2 Bernoulli mixture models
If the data is binary valued, we can use a Bernoulli mixture model or BMM (also called a
mixture of Bernoullis), where each mixture component has the following form:
p(y|z = k, θ) = Y
D
d=1
Ber(yd|µdk) = Y
D
d=1
µ
yd
dk(1 − µdk)
1−yd
(3.102)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license96 Chapter 3. Probability: Multivariate Models
0.05 0.04 0.06 0.06 0.02
0.03 0.06 0.01 0.04 0.08
0.07 0.06 0.08 0.06 0.07
0.04 0.02 0.03 0.06 0.03
Figure 3.13: We fit a mixture of 20 Bernoullis to the binarized MNIST digit data. We visualize the estimated
cluster means µˆk. The numbers on top of each image represent the estimated mixing weights πˆk. No labels
were used when training the model. Generated by code at figures.probml.ai/book1/3.13.
Here µdk is the probability that bit d turns on in cluster k.
As an example, we fit a BMM using K = 20 components to the MNIST dataset (Section 3.5.2). (We
use the EM algorithm to do this fitting, which is similar to EM for GMMs discussed in Section 8.7.3;
however we can also use SGD to fit the model, which is more efficient for large datasets.2
) The
resulting parameters for each mixture component (i.e., µk and πk) are shown in Figure 3.13. We see
that the model has “discovered” a representation of each type of digit. (Some digits are represented
multiple times, since the model does not know the “true” number of classes. See Section 21.3.7 for
more information on how to choose the number K of mixture components.)
3.6 Probabilistic graphical models *
I basically know of two principles for treating complicated systems in simple ways: the first is
the principle of modularity and the second is the principle of abstraction. I am an apologist
for computational probability in machine learning because I believe that probability theory
implements these two principles in deep and intriguing ways — namely through factorization
and through averaging. Exploiting these two mechanisms as fully as possible seems to me to
be the way forward in machine learning. — Michael Jordan, 1997 (quoted in [Fre98]).
We have now introduced a few simple probabilistic building blocks. In Section 3.3, we showed
one way to combine some Gaussian building blocks to build a high dimensional distribution p(y)
from simpler parts, namely the marginal p(y1) and the conditional p(y2|y1). This idea can be
extended to define joint distributions over sets of many random variables. The key assumption we
will make is that some variables are conditionally independent of others. We will represent our
CI assumptions using graphs, as we briefly explain below. (See the sequel to this book, [Mur22], for
more information.)
2. For the SGD code, see code.probml.ai/book1/mix_bernoulli_sgd_mnist.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20223.6. Probabilistic graphical models * 97
P (C=F) P(C=T)
0.5 0.5
C P(S=F) P(S=T)
F 0.5 0.5
T 0.9 0.1
C P(R=F) P(R=T)
F 0.8 0.2
T 0.2 0.8
S R P(W=F) P(W=T)
F F 1.0 0.0
T F 0.1 0.9
F T 0.1 0.9
T T 0.01 0.99
Cloudy
Sprinkler Rain
Wet 
Grass
Figure 3.14: Water sprinkler PGM with corresponding binary CPTs. T and F stand for true and false.
3.6.1 Representation
A probabilistic graphical model or PGM is a joint probability distribution that uses a graph
structure to encode conditional independence assumptions. When the graph is a directed acyclic
graph or DAG, the model is sometimes called a Bayesian network, although there is nothing
inherently Bayesian about such models.
The basic idea in PGMs is that each node in the graph represents a random variable, and each
edge represents a direct dependency. More precisely, each lack of edge represents a conditional
independency. In the DAG case, we can number the nodes in topological order (parents before
children), and then we connect them such that each node is conditionally independent of all its
predecessors given its parents:
Yi ⊥ Ypred(i)\pa(i)
|Ypa(i) (3.103)
where pa(i) are the parents of node i, and pred(i) are the predecessors of node i in the ordering. (This
is called the ordered Markov property.) Consequently, we can represent the joint distribution as
follows:
p(Y1:V ) = Y
V
i=1
p(Yi
|Ypa(i)) (3.104)
where V is the number of nodes in the graph.
3.6.1.1 Example: water sprinkler network
Suppose we want to model the dependencies between 4 random variables: C (whether it is cloudy
season or not), R (whether it is raining or not), S (whether the water sprinkler is on or not), and W
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license98 Chapter 3. Probability: Multivariate Models
y1 y2 y3
· · ·
(a)
y1 y2 y3
· · ·
(b)
Figure 3.15: Illustration of first and second order autoregressive (Markov) models.
(whether the grass is wet or not). We know that the cloudy season makes rain more likely, so we add
a C → R arc. We know that the cloudy season makes turning on a water sprinkler less likely, so we
add a C → S arc. Finally, we know that either rain or sprinklers can cause the grass to get wet, so
we add S → W and R → W edges.
Formally, this defines the following joint distribution:
p(C, S, R, W) = p(C)p(S|C)p(R|C,✓S)p(W|S, R,￾C) (3.105)
where we strike through terms that are not needed due to the conditional independence properties of
the model.
Each term p(Yi
|Ypa(i)) is a called the conditional probability distribution or CPD for node
i. This can be any kind of distribution we like. In Figure 3.14, we assume each CPD is a conditional
categorical distribution, which can be represented as a conditional probability table or CPT.
We can represent the i’th CPT as follows:
θijk , p(Yi = k|Ypa(i) = j) (3.106)
This satisfies the properties 0 ≤ θijk ≤ 1 and PKi
k=1 θijk = 1 for each row j. Here i indexes nodes,
i ∈ [V ]; k indexes node states, k ∈ [Ki
], where Ki
is the number of states for node i; and j indexes
joint parent states, j ∈ [Ji
], where Ji =
Q
p∈pa(i) Kp. For example, the wet grass node has 2 binary
parents, so there are 4 parent states.
3.6.1.2 Example: Markov chain
Suppose we want to create a joint probability distribution over variable-length sequences, p(y1:T ). If
each variable yt represents a word from a vocabulary with K possible values, so yt ∈ {1, . . . , K}, the
resulting model represents a distribution over possible sentences of length T; this is often called a
language model.
By the chain rule of probability, we can represent any joint distribution over T variables as follows:
p(y1:T ) = p(y1)p(y2|y1)p(y3|y2, y1)p(y4|y3, y2, y1). . . =
Y
T
t=1
p(yt|y1:t−1) (3.107)
Unfortunately, the number of parameters needed to represent each conditional distribution p(yt|y1:t−1)
grows exponentially with t. However, suppose we make the conditional independence assumption that
the future, yt+1:T , is independent of the past, y1:t−1, given the present, yt. This is called the first
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2023.6. Probabilistic graphical models * 99
order Markov condition, and is repesented by the PGM in Figure 3.15(a). With this assumption,
we can write the joint distribution as follows:
p(y1:T ) = p(y1)p(y2|y1)p(y3|y2)p(y4|y3). . . = p(y1)
Y
T
t=2
p(yt|yt−1) (3.108)
This is called a Markov chain, Markov model or autoregressive model of order 1.
The function p(yt|yt−1) is called the transition function, transition kernel or Markov kernel.
This is just a conditional distribution over the states at time t given the state at time t−1, and hence
it satisfies the conditions p(yt|yt−1) ≥ 0 and PK
k=1 p(yt = k|yt−1 = j) = 1. We can represent this
CPT as a stochastic matrix, Ajk = p(yt = k|yt−1 = j), where each row sums to 1. This is known
as the state transition matrix. We assume this matrix is the same for all time steps, so the model
is said to be homogeneous, stationary, or time-invariant. This is an example of parameter
tying, since the same parameter is shared by multiple variables. This assumption allows us to model
an arbitrary number of variables using a fixed number of parameters.
The first-order Markov assumption is rather strong. Fortunately, we can easily generalize first-order
models to depend on the last M observations, thus creating a model of order (memory length) M:
p(y1:T ) = p(y1:M)
Y
T
t=M+1
p(yt|yt−M:t−1) (3.109)
This is called an M’th order Markov model. For example, if M = 2, yt depends on yt−1 and
yt−2, as shown in Figure 3.15(b). This is called a trigram model, since it models the distribution
over word triples. If we use M = 1, we get a bigram model, which models the distribution over
word pairs.
For large vocabulary sizes, the number of parameters needed to estimate the conditional distributions
for M-gram models for large M can become prohibitive. In this case, we need to make additional
assumptions beyond conditional independence. For example, we can assume that p(yt|yt−M:t−1) can
be represented as a low-rank matrix, or in terms of some kind of neural network. This is called a
neural language model. See Chapter 15 for details.
3.6.2 Inference
A PGM defines a joint probability distribution. We can therefore use the rules of marginalization
and conditioning to compute p(Yi
|Yj = yj ) for any sets of variables i and j. Efficient algorithms to
perform this computation are discussed in the sequel to this book, [Mur22].
For example, consider the water sprinkler example in Figure 3.14. Our prior belief that it has
rained is given by p(R = 1) = 0.5. If we see that the grass is wet, then our posterior belief that it has
rained changes to p(R = 1|W = 1) = 0.7079. Now suppose we also notice the water sprinkler was
turned on: our belief that it rained goes down to p(R = 1|W = 1, S = 1) = 0.3204. This negative
mutual interaction between multiple causes of some observations is called the explaining away
effect, also known as Berkson’s paradox. (See code.probml.ai/book1/sprinkler_pgm for some code
that reproduces these calculations.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license100 Chapter 3. Probability: Multivariate Models
3.6.3 Learning
If the parameters of the CPDs are unknown, we can view them as additional random variables, add
them as nodes to the graph, and then treat them as hidden variables to be inferred. Figure 3.16(a)
shows a simple example, in which we have N iid random variables, yn, all drawn from the same
distribution with common parameter θ. (The shaded nodes represent observed values, whereas the
unshaded (hollow) nodes represent latent variables or parameters.)
More precisely, the model encodes the following “generative story” about the data:
θ ∼ p(θ) (3.110)
yn ∼ p(y|θ) (3.111)
where p(θ) is some (unspecified) prior over the parameters, and p(y|θ) is some specified likelihood
function. The corresponding joint distribution has the form
p(D, θ) = p(θ)p(D|θ) (3.112)
where D = (y1, . . . , yN ). By virtue of the iid assumption, the likelihood can be rewritten as follows:
p(D|θ) = Y
N
n=1
p(yn|θ) (3.113)
Notice that the order of the data vectors is not important for defining this model, i.e., we can permute
the numbering of the leaf nodes in the PGM. When this property holds, we say that the data is
exchangeable.
3.6.3.1 Plate notation
In Figure 3.16(a), we see that the y nodes are repeated N times. To avoid visual clutter, it is common
to use a form of syntactic sugar called plates. This is a notational convention in which we draw a
little box around the repeated variables, with the understanding that nodes within the box will get
repeated when the model is unrolled. We often write the number of copies or repetitions in the
bottom right corner of the box. This is illustrated in Figure 3.16(b). This notation is widely used to
represent certain kinds of Bayesian model.
Figure 3.17 shows a more interesting example, in which we represent a GMM (Section 3.5.1) as a
graphical model. We see that this encodes the joint distribution
p(y1:N , z1:N , θ) = p(π)
"Y
K
k=1
p(µk)p(Σk)
# "Y
N
n=1
p(zn|π)p(yn|zn, µ1:K, Σ1:K)
#
(3.114)
We see that the latent variables zn as well as the unknown paramters, θ = (π, µ1:K, Σ1:K), are all
shown as unshaded nodes.
3.7 Exercises
Exercise 3.1 [Uncorrelated does not imply independent *]
Let X ∼ U(−1, 1) and Y = X
2
. Clearly Y is dependent on X (in fact, Y is uniquely determined by X).
However, show that ρ(X, Y ) = 0. Hint: if X ∼ U(a, b) then E[X] = (a + b)/2 and V [X] = (b − a)
2
/12.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20223.7. Exercises 101
θ
y1 yN
N
θ
yn
Figure 3.16: Left: data points yn are conditionally independent given θ. Right: Same model, using plate
notation. This represents the same model as the one on the left, except the repeated yn nodes are inside a
box, known as a plate; the number in the lower right hand corner, N, specifies the number of repetitions of
the yn node.
K
N
µk Σk
yn
zn
π
Figure 3.17: A Gaussian mixture model represented as a graphical model.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license102 Chapter 3. Probability: Multivariate Models
Exercise 3.2 [Correlation coefficient is between -1 and +1]
Prove that −1 ≤ ρ(X, Y ) ≤ 1
Exercise 3.3 [Correlation coefficient for linearly related variables is ±1 *]
Show that, if Y = aX + b for some parameters a > 0 and b, then ρ(X, Y ) = 1. Similarly show that if a < 0,
then ρ(X, Y ) = −1.
Exercise 3.4 [Linear combinations of random variables]
Let x be a random vector with mean m and covariance matrix Σ. Let A and B be matrices.
a. Derive the covariance matrix of Ax.
b. Show that tr(AB) = tr(BA).
c. Derive an expression for E

x
T Ax

.
Exercise 3.5 [Gaussian vs jointly Gaussian ]
Let X ∼ N (0, 1) and Y = W X, where p(W = −1) = p(W = 1) = 0.5. It is clear that X and Y are not
independent, since Y is a function of X.
a. Show Y ∼ N (0, 1).
b. Show Cov [X, Y ] = 0. Thus X and Y are uncorrelated but dependent, even though they are Gaussian.
Hint: use the definition of covariance
Cov [X, Y ] = E [XY ] − E [X] E [Y ] (3.115)
and the rule of iterated expectation
E [XY ] = E [E [XY |W]] (3.116)
Exercise 3.6 [Normalization constant for a multidimensional Gaussian]
Prove that the normalization constant for a d-dimensional Gaussian is given by
(2π)
d/2
|Σ|
1
2 =
Z
exp(−
1
2
(x − µ)
T Σ
−1
(x − µ))dx (3.117)
Hint: diagonalize Σ and use the fact that |Σ| =
Q
i
λi to write the joint pdf as a product of d one-dimensional
Gaussians in a transformed coordinate system. (You will need the change of variables formula.) Finally, use
the normalization constant for univariate Gaussians.
Exercise 3.7 [Sensor fusion with known variances in 1d]
Suppose we have two sensors with known (and different) variances v1 and v2, but unknown (and the same)
mean µ. Suppose we observe n1 observations y
(1)
i ∼ N (µ, v1) from the first sensor and n2 observations
y
(2)
i ∼ N (µ, v2) from the second sensor. (For example, suppose µ is the true temperature outside, and sensor
1 is a precise (low variance) digital thermosensing device, and sensor 2 is an imprecise (high variance) mercury
thermometer.) Let D represent all the data from both sensors. What is the posterior p(µ|D), assuming a
non-informative prior for µ (which we can simulate using a Gaussian with a precision of 0)? Give an explicit
expression for the posterior mean and variance.
Exercise 3.8 [Show that the Student distribution can be written as a Gaussian scale mixture]
Show that a Student distribution can be written as a Gaussian scale mixture, where we use a Gamma
mixing distribution on the precision α, i.e.
p(x|µ, a, b) = Z ∞
0
N (x|µ, α
−1
)Ga(α|a, b)dα (3.118)
This can be viewed as an infinite mixture of Gaussians, with different precisions.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224 Statistics
4.1 Introduction
In Chapter 2–Chapter 3, we assumed all the parameters θ of our probability models were known. In
this chapter, we discuss how to learn these parameters from data.
The process of estimating θ from D is called model fitting, or training, and is at the heart of
machine learning. There are many methods for producing such estimates, but most boil down to an
optimization problem of the form
θˆ = argmin
θ
L(θ) (4.1)
where L(θ) is some kind of loss function or objective function. We discuss several different loss
functions in this chapter. In some cases, we also discuss how to solve the optimization problem in
closed form. In general, however, we will need to use some kind of generic optimization algorithm,
which we discuss in Chapter 8.
In addition to computing a point estimate, θˆ, we discuss how to model our uncertainty or
confidence in this estimate. In statistics, the process of quantifying uncertainty about an unknown
quantity estimated from a finite sample of data is called inference. We will discuss both Bayesian
and frequentist approaches to inference.1
4.2 Maximum likelihood estimation (MLE)
The most common approach to parameter estimation is to pick the parameters that assign the highest
probability to the training data; this is called maximum likelihood estimation or MLE. We give
more details below, and then give a series of worked examples.
4.2.1 Definition
We define the MLE as follows:
θˆmle , argmax
θ
p(D|θ) (4.2)
1. In the deep learning community, the term “inference” refers to what we will call “prediction”, namely computing
p(y|x, θˆ).104 Chapter 4. Statistics
We usually assume the training examples are independently sampled from the same distribution, so
the (conditional) likelihood becomes
p(D|θ) = Y
N
n=1
p(yn|xn, θ) (4.3)
This is known as the iid assumption, which stands for “independent and identically distributed”. We
usually work with the log likelihood, which is given by
LL(θ) , log p(D|θ) = X
N
n=1
log p(yn|xn, θ) (4.4)
This decomposes into a sum of terms, one per example. Thus the MLE is given by
θˆmle = argmax
θ
X
N
n=1
log p(yn|xn, θ) (4.5)
Since most optimization algorithms (such as those discussed in Chapter 8) are designed to minimize
cost functions, we can redefine the objective function to be the (conditional) negative log
likelihood or NLL:
NLL(θ) , − log p(D|θ) = −
X
N
n=1
log p(yn|xn, θ) (4.6)
Minimizing this will give the MLE. If the model is unconditional (unsupervised), the MLE becomes
θˆmle = argmin
θ
−
X
N
n=1
log p(yn|θ) (4.7)
since we have outputs yn but no inputs xn.
2
Alternatively we may want to maximize the joint likelihood of inputs and outputs. The MLE in
this case becomes
θˆmle = argmin
θ
−
X
N
n=1
log p(yn, xn|θ) (4.8)
4.2.2 Justification for MLE
There are several ways to justify the method of MLE. One way is to view it as simple point
approximation to the Bayesian posterior p(θ|D) using a uniform prior, as explained in Section 4.6.7.1.
2. In statistics, it is standard to use y to represent variables whose generative distribution we choose to model, and to
use x to represent exogoneous inputs which are given but not generated. Thus supervised learning concerns fitting
conditional models of the form p(y|x), and unsupervised learning is the special case where x = ∅, so we are just fitting
the unconditional distribution p(y). In the ML literature, supervised learning treats y as generated and x as given,
but in the unsupervised case, it often switches to using x to represent generated variables.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.2. Maximum likelihood estimation (MLE) 105
In particular, suppose we approximate the posterior by a delta function, p(θ|D) = δ(θ −θˆmap), where
θˆmap is the posterior mode, given by
θˆmap = argmax
θ
log p(θ|D) = argmax
θ
log p(D|θ) + log p(θ) (4.9)
If we use a uniform prior, p(θ) ∝ 1, the MAP estimate becomes equal to the MLE, θˆmap = θˆmle.
Another way to justify the use of the MLE is that the resulting predictive distribution p(y|θˆmle) is
as close as possible (in a sense to be defined below) to the empirical distribution of the data. In
the unconditional case, the empirical distribution is defined by
pD(y) ,
1
N
X
N
n=1
δ(y − yn) (4.10)
We see that the empirical distribution is a series of delta functions or “spikes” at the observed training
points. We want to create a model whose distribution q(y) = p(y|θ) is similar to pD(y).
A standard way to measure the (dis)similarity between probability distributions p and q is the
Kullback Leibler divergence, or KL divergence. We give the details in Section 6.2, but in brief
this is defined as
DKL (pkq) = X
y
p(y) log p(y)
q(y)
(4.11)
=
X
y
p(y) log p(y)
| {z }
− H(p)
−
X
y
p(y) log q(y)
| {z }
H(p,q)
(4.12)
where H (p) is the entropy of p (see Section 6.1), and H (p, q) is the cross-entropy of p and q (see
Section 6.1.2). One can show that DKL (pkq) ≥ 0, with equality iff p = q.
If we define q(y) = p(y|θ), and set p(y) = pD(y), then the KL divergence becomes
DKL (pkq) = X
y
pD(y) log pD(y) − pD(y) log q(y) (4.13)
= − H(pD) −
1
N
X
N
n=1
log p(yn|θ) (4.14)
= const + NLL(θ) (4.15)
The first term is a constant which we can ignore, leaving just the NLL. Thus minimizing the KL is
equivalent to minimizing the NLL which is equivalent to computing the MLE, as in Equation (4.7).
We can generalize the above results to the supervised (conditional) setting by using the following
empirical distribution:
pD(x, y) = pD(y|x)pD(x) = 1
N
X
N
n=1
δ(x − xn)δ(y − yn) (4.16)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license106 Chapter 4. Statistics
The expected KL then becomes
EpD(x)
[DKL (pD(Y |x)kq(Y |x))] = X
x
pD(x)
"X
y
pD(y|x) log pD(y|x)
q(y|x)
#
(4.17)
= const −
X
x,y
pD(x, y) log q(y|x) (4.18)
= const −
1
N
X
N
n=1
log p(yn|xn, θ) (4.19)
Minimizing this is equivalent to minimizing the conditional NLL in Equation (4.6).
4.2.3 Example: MLE for the Bernoulli distribution
Suppose Y is a random variable representing a coin toss, where the event Y = 1 corresponds to
heads and Y = 0 corresponds to tails. Let θ = p(Y = 1) be the probability of heads. The probability
distribution for this rv is the Bernoulli, which we introduced in Section 2.4.
The NLL for the Bernoulli distribution is given by
NLL(θ) = − log Y
N
n=1
p(yn|θ) (4.20)
= − log Y
N
n=1
θ
I(yn=1)(1 − θ)
I(yn=0) (4.21)
= −
X
N
n=1
I(yn = 1) log θ + I(yn = 0) log(1 − θ) (4.22)
= −[N1 log θ + N0 log(1 − θ)] (4.23)
where we have defined N1 =
PN
n=1 I(yn = 1) and N0 =
PN
n=1 I(yn = 0), representing the number of
heads and tails. (The NLL for the binomial is the same as for the Bernoulli, modulo an irrelevant
￾N
c

term, which is a constant independent of θ.) These two numbers are called the sufficient
statistics of the data, since they summarize everything we need to know about D. The total count,
N = N0 + N1, is called the sample size.
The MLE can be found by solving d
dθNLL(θ) = 0. The derivative of the NLL is
d
dθNLL(θ) = −N1
θ
+
N0
1 − θ
(4.24)
and hence the MLE is given by
ˆθmle =
N1
N0 + N1
(4.25)
We see that this is just the empirical fraction of heads, which is an intuitive result.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2024.2. Maximum likelihood estimation (MLE) 107
4.2.4 Example: MLE for the categorical distribution
Suppose we roll a K-sided dice N times. Let Yn ∈ {1, . . . , K} be the n’th outcome, where Yn ∼ Cat(θ).
We want to estimate the probabilities θ from the dataset D = {yn : n = 1 : N}. The NLL is given by
NLL(θ) = −
X
k
Nk log θk (4.26)
where Nk is the number of times the event Y = k is observed. (The NLL for the multinomial is the
same, up to irrelevant scale factors.)
To compute the MLE, we have to minimize the NLL subject to the constraint that PK
k=1 θk = 1.
To do this, we will use the method of Lagrange multipliers (see Section 8.5.1).3 The Lagrangian is as
follows:
L(θ, λ) , −
X
k
Nk log θk − λ
 
1 −
X
k
θk
!
(4.27)
Taking derivatives with respect to λ yields the original constraint:
∂L
∂λ = 1 −
X
k
θk = 0 (4.28)
Taking derivatives with respect to θk yields
∂L
∂θk
= −
Nk
θk
+ λ = 0 =⇒ Nk = λθk (4.29)
We can solve for λ using the sum-to-one constraint:
X
k
Nk = N = λ
X
k
θk = λ (4.30)
Thus the MLE is given by
ˆθk =
Nk
λ
=
Nk
N
(4.31)
which is just the empirical fraction of times event k occurs.
4.2.5 Example: MLE for the univariate Gaussian
Suppose Y ∼ N (µ, σ2
) and let D = {yn : n = 1 : N} be an iid sample of size N. We can estimate
the parameters θ = (µ, σ2
) using MLE as follows. First, we derive the NLL, which is given by
NLL(µ, σ2
) = −
X
N
n=1
log "
1
2πσ2
1
2
exp 
−
1
2σ
2
(yn − µ)
2
#
(4.32)
=
1
2σ
2
X
N
n=1
(yn − µ)
2 +
N
2
log(2πσ2
) (4.33)
3. We do not need to explicitly enforce the constraint that θk ≥ 0 since the gradient of the Lagrangian has the form
−Nk/θk − λ; so negative values of θk would increase the objective, rather than minimize it. (Of course, this does not
preclude setting θk = 0, and indeed this is the optimal solution if Nk = 0.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license108 Chapter 4. Statistics
The minimum of this function must satisfy the following conditions, which we explain in Section 8.1.1.1:
∂
∂µNLL(µ, σ2
) = 0,
∂
∂σ2
NLL(µ, σ2
) = 0 (4.34)
So all we have to do is to find this stationary point. Some simple calculus (Exercise 4.1) shows that
the solution is given by the following:
µˆmle =
1
N
X
N
n=1
yn = y (4.35)
σˆ
2
mle =
1
N
X
N
n=1
(yn − µˆmle)
2 =
1
N
"X
N
n=1
y
2
n + ˆµ
2
mle − 2ynµˆmle#
= s
2 − y
2
(4.36)
s
2 ,
1
N
X
N
n=1
y
2
n
(4.37)
The quantities y and s
2 are called the sufficient statistics of the data, since they are sufficient to
compute the MLE, without loss of information relative to using the raw data itself.
Note that you might be used to seeing the estimate for the variance written as
σˆ
2
unb =
1
N − 1
X
N
n=1
(yn − µˆmle)
2
(4.38)
where we divide by N − 1. This is not the MLE, but is a different kind of estimate, which happens
to be unbiased (unlike the MLE); see Section 4.7.6.1 for details.4
4.2.6 Example: MLE for the multivariate Gaussian
In this section, we derive the maximum likelihood estimate for the parameters of a multivariate
Gaussian.
First, let us write the log-likelihood, dropping irrelevant constants:
LL(µ, Σ) = log p(D|µ, Σ) = N
2
log |Λ| − 1
2
X
N
n=1
(yn − µ)
TΛ(yn − µ) (4.39)
where Λ = Σ
−1
is the precision matrix (inverse covariance matrix).
4. Note that, in Python, numpy defaults to the MLE, but Pandas defaults to the unbiased estimate, as explained in
https://stackoverflow.com/questions/24984178/different-std-in-pandas-vs-numpy/.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.2. Maximum likelihood estimation (MLE) 109
4.2.6.1 MLE for the mean
Using the substitution zn = yn − µ, the derivative of a quadratic form (Equation (7.264)) and the
chain rule of calculus, we have
∂
∂µ
(yn − µ)
TΣ
−1
(yn − µ) = ∂
∂zn
z
T
nΣ
−1
zn
∂zn
∂µT
(4.40)
= −1(Σ
−1 + Σ
−T
)zn (4.41)
since ∂zn
∂µT = −I. Hence
∂
∂µ
LL(µ, Σ) = −
1
2
X
N
n=1
−2Σ
−1
(yn − µ) = Σ
−1 X
N
n=1
(yn − µ) = 0 (4.42)
µˆ =
1
N
X
N
n=1
yn = y (4.43)
So the MLE of µ is just the empirical mean.
4.2.6.2 MLE for the covariance matrix
We can use the trace trick (Equation (7.36)) to rewrite the log-likelihood in terms of the precision
matrix Λ = Σ
−1
as follows:
LL(µˆ, Λ) = N
2
log |Λ| − 1
2
X
n
tr[(yn − µˆ)(yn − µˆ)
TΛ] (4.44)
=
N
2
log |Λ| − 1
2
tr [SyΛ] (4.45)
Sy ,
X
N
n=1
(yn − y)(yn − y)
T =
 X
n
yny
T
n
!
− Nyy
T
(4.46)
where Sy is the scatter matrix centered on y.
We can rewrite the scatter matrix in a more compact form as follows:
Sy = Y˜ TY˜ = YTCT
N CN Y = YTCN Y (4.47)
where
CN , IN −
1
N
1N 1
T
N (4.48)
is the centering matrix, which converts Y to Y˜ by subtracting the mean y =
1
N YT1N off every
row.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license110 Chapter 4. Statistics
sepal_length sepal_width petal_length petal_width
sepal_length
sepal_width
petal_length
petal_width
0.69 -0.042 1.3 0.52
-0.042 0.19 -0.33 -0.12
1.3 -0.33 3.1 1.3
0.52 -0.12 1.3 0.58 0.0
0.5
1.0
1.5
2.0
2.5
3.0
(a)
sepal_length sepal_width petal_length petal_width
sepal_length
sepal_width
petal_length
petal_width
-0.12
0.87 -0.43
0.82 -0.37 0.96
0.4
0.2
0.0
0.2
0.4
0.6
0.8
1.0
(b)
Figure 4.1: (a) Covariance matrix for the features in the iris dataset from Section 1.2.1.1. (b) Correlation
matrix. We only show the lower triangle, since the matrix is symmetric and has a unit diagonal. Compare
this to Figure 1.3. Generated by code at figures.probml.ai/book1/4.1.
Using results from Section 7.8, we can compute derivatives of the loss with respect to Λ to get
∂LL(µˆ, Λ)
∂Λ
=
N
2
Λ
−T −
1
2
S
T
y = 0 (4.49)
Λ
−T = Λ
−1 = Σ =
1
N
Sy (4.50)
Σˆ =
1
N
X
N
n=1
(yn − y)(yn − y)
T =
1
N
YTCN Y (4.51)
Thus the MLE for the covariance matrix is the empirical covariance matrix. See Figure 4.1a for an
example.
Sometimes it is more convenient to work with the correlation matrix defined in Equation (3.8).
This can be computed using
corr(Y) = (diag(Σ))− 1
2 Σ (diag(Σ))− 1
2 (4.52)
where diag(Σ)
− 1
2 is a diagonal matrix containing the entries 1/σi
. See Figure 4.1b for an example.
Note, however, that the MLE may overfit or be numerically unstable, especially when the number
of samples N is small compared to the number of dimensions D. The main problem is that Σ has
O(D2
) parameters, so we may need a lot of data to reliably estimate it. In particular, as we see from
Equation (4.51), the MLE for a full covariance matrix is singular if N < D. And even when N > D,
the MLE can be ill-conditioned, meaning it is close to singular. We discuss solutions to this problem
in Section 4.5.2.
4.2.7 Example: MLE for linear regression
We briefly mentioned linear regression in Section 2.6.3. Recall that it corresponds to the following
model:
p(y|x; θ) = N (y|wTx, σ2
) (4.53)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.3. Empirical risk minimization (ERM) 111
where θ = (w, σ2
). Let us assume for now that σ
2
is fixed, and focus on estimating the weights w.
The negative log likelihood or NLL is given by
NLL(w) = −
X
N
n=1
log "
1
2πσ2
1
2
exp 
−
1
2σ
2
(yn − wTxn)
2
#
(4.54)
Dropping the irrelevant additive constants gives the following simplified objective, known as the
residual sum of squares or RSS:
RSS(w) ,
X
N
n=1
(yn − wTxn)
2 =
X
N
n=1
r
2
n
(4.55)
where rn the n’th residual error. Scaling by the number of examples N gives the mean squared
error or MSE:
MSE(w) = 1
N
RSS(w) = 1
N
X
N
n=1
(yn − wTxn)
2
(4.56)
Finally, taking the square root gives the root mean squared error or RMSE:
RMSE(w) = p
MSE(w) =
vuut
1
N
X
N
n=1
(yn − wTxn)
2 (4.57)
We can compute the MLE by minimizing the NLL, RSS, MSE or RMSE. All will give the same
results, since these objective functions are all the same, up to irrelevant constants
Let us focus on the RSS objective. It can be written in matrix notation as follows:
RSS(w) = X
N
n=1
(yn − wTxn)
2 = ||Xw − y||2
2 = (Xw − y)
T
(Xw − y) (4.58)
In Section 11.2.2.1, we prove that the optimum, which occurs where ∇wRSS(w) = 0, satisfies the
following equation:
wˆ mle , argmin
w
RSS(w) = (XTX)
−1XTy (4.59)
This is called the ordinary least squares or OLS estimate, and is equivalent to the MLE.
4.3 Empirical risk minimization (ERM)
We can generalize MLE by replacing the (conditional) log loss term in Equation (4.6), `(yn, θ; xn) =
− log p(yn|xn, θ), with any other loss function, to get
L(θ) = 1
N
X
N
n=1
`(yn, θ; xn) (4.60)
This is known as empirical risk minimization or ERM, since it is the expected loss where the
expectation is taken wrt the empirical distribution. See Section 5.4 for more details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license112 Chapter 4. Statistics
4.3.1 Example: minimizing the misclassification rate
If we are solving a classification problem, we might want to use 0-1 loss:
`01(yn, θ; xn) = (
0 if yn = f(xn; θ)
1 if yn 6= f(xn; θ)
(4.61)
where f(x; θ) is some kind of predictor. The empirical risk becomes
L(θ) = 1
N
X
N
n=1
`01(yn, θ; xn) (4.62)
This is just the empirical misclassification rate on the training set.
Note that for binary problems, we can rewrite the misclassifcation rate in the following notation.
Let y˜ ∈ {−1, +1} be the true label, and yˆ ∈ {−1, +1} = f(x; θ) be our prediction. We define the 0-1
loss as follows:
`01(˜y, yˆ) = I(˜y 6= ˆy) = I(˜y y <ˆ 0) (4.63)
The corresponding empirical risk becomes
L(θ) = 1
N
X
N
n=1
`01(yn, yˆn) = 1
N
X
N
n=1
I(˜yn yˆn < 0) (4.64)
where the dependence on xn and θ is implicit.
4.3.2 Surrogate loss
Unfortunately, the 0-1 loss used in Section 4.3.1 is a non-smooth step function, as shown in Figure 4.2,
making it difficult to optimize. (In fact, it is NP-hard [BDEL03].) In this section we consider the use
of a surrogate loss function [BJM06]. The surrogate is usually chosen to be a maximally tight
convex upper bound, which is then easy to minimize.
For example, consider a probabilistic binary classifier, which produces the following distribution
over labels:
p(˜y|x, θ) = σ(˜yη) = 1
1 + e−yη˜
(4.65)
where η = f(x; θ) is the log odds. Hence the log loss is given by
`ll(˜y, η) = − log p(˜y|η) = log(1 + e
−yη˜
) (4.66)
Figure 4.2 shows that this is a smooth upper bound to the 0-1 loss, where we plot the loss vs the
quantity yη˜ , known as the margin, since it defines a “margin of safety” away from the threshold
value of 0. Thus we see that minimizing the negative log likelihood is equivalent to minimizing a
(fairly tight) upper bound on the empirical 0-1 loss.
Another convex upper bound to 0-1 loss is the hinge loss, which is defined as follows:
`hinge(˜y, η) = max(0, 1 − yη˜ ) , (1 − yη˜ )+ (4.67)
This is plotted in Figure 4.2; we see that it has the shape of a partially open door hinge. This is
convex upper bound to the 0-1 loss, although it is only piecewise differentiable, not everywhere
differentiable.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.4. Other estimation methods * 113
−2.0 −1.5 −1.0 −0.5 0.0 0.5 1.0 1.5 2.0
0.0
0.5
1.0
1.5
2.0
2.5
3.0 0-1 loss
hinge loss
log loss
exp loss
Figure 4.2: Illustration of various loss functions for binary classification. The horizontal axis is the margin
z = yη˜ , the vertical axis is the loss. 0-1 loss is I(z < 0). Hinge-loss is max(0, 1−z). Log-loss is log2
(1 +e
−z
).
Exp-loss is e
−z
. Generated by code at figures.probml.ai/book1/4.2.
4.4 Other estimation methods *
4.4.1 The method of moments
Computing the MLE requires solving the equation ∇θNLL(θ) = 0. Sometimes this is computationally
difficult. In such cases, we may be able to use a simpler approach known as the method of moments
(MOM). In this approach, we equate the theoretical moments of the distribution to the empirical
moments, and solve the resulting set of K simultaneous equations, where K is the number of
parameters. The theoretical moments are given by µk = E

Y
k

, for k = 1 : K, and the empirical
moments are given by
µˆk =
1
N
Xn
n=1
y
k
n
(4.68)
so we just need to solve µk = ˆµk for each k. We give some examples below.
The method of moments is simple, but it is theoretically inferior to the MLE approach, since it
may not use all the data as efficiently. (For details on these theoretical results, see e.g., [CB02].)
Furthermore, it can sometimes produce inconsistent results (see Section 4.4.1.2). However, when it
produces valid estimates, it can be used to initialize iterative algorithms that are used to optimize the
NLL (see e.g., [AHK12]), thus combining the computational efficiency of MOM with the statistical
accuracy of MLE.
4.4.1.1 Example: MOM for the univariate Gaussian
For example, consider the case of a univariate Gaussian distribution. From Section 4.2.5, we have
µ1 = µ = y (4.69)
µ2 = σ
2 + µ
2 = s
2
(4.70)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license114 Chapter 4. Statistics
where y is the empirical mean and s
2
is the empirical average sum of squares. so µˆ = y and
σˆ
2 = s
2 − y
2
. In this case, the MOM estimate is the same as the MLE, but this is not always the
case.
4.4.1.2 Example: MOM for the uniform distribution
In this section, we give an example of the MOM applied to the uniform distribution. Our presentation
follows the wikipedia page.5 Let Y ∼ Unif(θ1, θ2) be a uniform random variable, so
p(y|θ) = 1
θ2 − θ1
I(θ1 ≤ y ≤ θ2) (4.71)
The first two moments are
µ1 = E [Y ] = 1
2
(θ1 + θ2) (4.72)
µ2 = E

Y
2

=
1
3
(θ
2
1 + θ1θ2 + θ
2
2
) (4.73)
Inverting these equations gives
(θ1, θ2) = 
µ1 −
q
3(µ2 − µ
2
1
), 2µ1 − θ1

(4.74)
Unfortunately this estimator can sometimes give invalid results. For example, suppose D =
{0, 0, 0, 0, 1}. The empirical moments are µˆ1 =
1
5
and µˆ2 =
1
5
, so the estimated parameters are
ˆθ1 =
1
5 −
2
√
3
5 = −0.493 and ˆθ2 =
1
5 +
2
√
3
5 = 0.893. However, these cannot possibly be the correct
parameters, since if θ2 = 0.893, we cannot generate a sample as large as 1.
By contrast, consider the MLE. Let y(1) ≤ y(2) ≤ · · · ≤ y(N) be the order statistics of the data
(i.e., the values sorted in increasing order). Let θ = θ2 − θ1. Then the likelihood is given by
p(D|θ) = (θ)
−N I
￾
y(1) ≥ θ1

I
￾
y(N) ≤ θ2

(4.75)
Within the permitted bounds for θ, the derivative of the log likelihood is given by
d
dθ log p(D|θ) = −
N
θ
< 0 (4.76)
Hence the likelihood is a decreasing function of θ, so we should pick
ˆθ1 = y(1),
ˆθ2 = y(N) (4.77)
In the above example, we get ˆθ1 = 0 and ˆθ2 = 1, as one would expect.
5. https://en.wikipedia.org/wiki/Method_of_moments_(statistics).
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 204.4. Other estimation methods * 115
4.4.2 Online (recursive) estimation
If the entire dataset D is available before training starts, we say that we are doing batch learning.
However, in some cases, the data set arrives sequentially, so D = {y1, y2, . . .} in an unbounded
stream. In this case, we want to perform online learning.
Let θˆ
t−1 be our estimate (e.g., MLE) given D1:t−1. To ensure our learning algorithm takes constant
time per update, we need to find a learning rule of the form
θt = f(θˆ
t−1, yt) (4.78)
This is called a recursive update. Below we give some examples of such online learning methods.
4.4.2.1 Example: recursive MLE for the mean of a Gaussian
Let us reconsider the example from Section 4.2.5 where we computed the MLE for a univariate
Gaussian. We know that the batch estimate for the mean is given by
µˆt =
1
t
Xt
n=1
yn (4.79)
This is just a running sum of the data, so we can easily convert this into a recursive estimate as
follows:
µˆt =
1
t
Xt
n=1
yn =
1
t
((t − 1)µˆt−1 + yt) (4.80)
= µˆt−1 +
1
t
(yt − µˆt−1) (4.81)
This is known as a moving average.
We see from Equation (4.81) that the new estimate is the old estimate plus a correction term. The
size of the correction diminishes over time (i.e., as we get more samples). However, if the distribution
is changing, we want to give more weight to more recent data examples. We discuss how to do this
in Section 4.4.2.2.
4.4.2.2 Exponentially-weighted moving average
Equation (4.81) shows how to compute the moving average of a signal. In this section, we show
how to adjust this to give more weight to more recent examples. In particular, we will compute
the following exponentially weighted moving average or EWMA, also called an exponential
moving average or EMA:
µˆt = βµt−1 + (1 − β)yt (4.82)
where 0 < β < 1. The contribution of a data point k steps in the past is weighted by β
k
(1 − β).
Thus the contribution from old data is exponentially decreasing. In particular, we have
µˆt = βµt−1 + (1 − β)yt (4.83)
= β
2µt−2 + β(1 − β)yt−1 + (1 − β)yt
.
.
. (4.84)
= β
ty0 + (1 − β)β
t−1y1 + · · · + (1 − β)βyt−1 + (1 − β)yt (4.85)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license116 Chapter 4. Statistics
0 20 40 60 80 100 120 140 160
10
8
6
4
2
0
2
beta = 0.90
EMA
EMA with bias correction
(a)
0 20 40 60 80 100 120 140 160
10
8
6
4
2
0
2
beta = 0.99
EMA
EMA with bias correction
(b)
Figure 4.3: Illustration of exponentially-weighted moving average with and without bias correction. (a) Short
memory: β = 0.9. (a) Long memory: β = 0.99. Generated by code at figures.probml.ai/book1/4.3.
The sum of a geometric series is given by
β
t + β
t−1 + · · · + β
1 + β
0 =
1 − β
t+1
1 − β
(4.86)
Hence
(1 − β)
Xt
k=0
β
k = (1 − β)
1 − β
t+1
1 − β
= 1 − β
t+1 (4.87)
Since 0 < β < 1, we have β
t+1 → 0 as t → ∞, so smaller β forgets the past more quickly, and adapts
to the more recent data more rapidly. This is illustrated in Figure 4.3.
Since the initial estimate starts from µˆ 0 = 0, there is an initial bias. This can be corrected by
scaling as follows [KB15]:
µ˜t =
µˆt
1 − β
t
(4.88)
(Note that the update in Equation (4.82) is still applied to the uncorrected EMA, µˆt−1, before being
corrected for the current time step.) The benefit of this is illustrated in Figure 4.3.
4.5 Regularization
A fundamental problem with MLE, and ERM, is that it will try to pick parameters that minimize
loss on the training set, but this may not result in a model that has low loss on future data. This is
called overfitting.
As a simple example, suppose we want to predict the probability of heads when tossing a coin. We
toss it N = 3 times and observe 3 heads. The MLE is ˆθmle = N1/(N0 + N1) = 3/(3 + 0) = 1 (see
Section 4.2.3). However, if we use Ber(y|
ˆθmle) to make predictions, we will predict that all future
coin tosses will also be heads, which seems rather unlikely.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.5. Regularization 117
The core of the problem is that the model has enough parameters to perfectly fit the observed
training data, so it can perfectly match the empirical distribution. However, in most cases the
empirical distribution is not the same as the true distribution, so putting all the probability mass on
the observed set of N examples will not leave over any probability for novel data in the future. That
is, the model may not generalize.
The main solution to overfitting is to use regularization, which means to add a penalty term to
the NLL (or empirical risk). Thus we optimize an objective of the form
L(θ; λ) = "
1
N
X
N
n=1
`(yn, θ; xn)
#
+ λC(θ) (4.89)
where λ ≥ 0 is the regularization parameter, and C(θ) is some form of complexity penalty.
A common complexity penalty is to use C(θ) = − log p(θ), where p(θ) is the prior for θ. If ` is
the log loss, the regularized objective becomes
L(θ; λ) = −
1
N
X
N
n=1
log p(yn|xn, θ) − λ log p(θ) (4.90)
By setting λ = 1 and rescaling p(θ) appropriately, we can equivalently minimize the following:
L(θ; λ) = −
"X
N
n=1
log p(yn|xn, θ) + log p(θ)
#
= − [log p(D|θ) + log p(θ)] (4.91)
Minimizing this is equivalent to maximizing the log posterior:
θˆ = argmax
θ
log p(θ|D) = argmax
θ
[log p(D|θ) + log p(θ) − const] (4.92)
This is known as MAP estimation, which stands for maximum a posterior estimation.
4.5.1 Example: MAP estimation for the Bernoulli distribution
Consider again the coin tossing example. If we observe just one head, the MLE is θmle = 1. To avoid
this, we can add a penalty to θ to discourage “extreme” values, such as θ = 0 or θ = 1. We can do
this by using a beta distribution as our prior, p(θ) = Beta(θ|a, b), where a, b > 1 encourages values
of θ near to a/(a + b) (see Section 2.7.4 for details). The log likelihood plus log prior becomes
LL(θ) = log p(D|θ) + log p(θ) (4.93)
= [N1 log θ + N0 log(1 − θ)] + [(a − 1) log(θ) + (b − 1) log(1 − θ)] (4.94)
Using the method from Section 4.2.3 we find that the MAP estimate is
θmap =
N1 + a − 1
N1 + N0 + a + b − 2
(4.95)
If we set a = b = 2 (which weakly favors a value of θ near 0.5), the estimate becomes
θmap =
N1 + 1
N1 + N0 + 2
(4.96)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license118 Chapter 4. Statistics
This is called add-one smoothing, and is a simple but widely used technique to avoid the zero
count problem. (See also Section 4.6.2.9.)
The zero-count problem, and overfitting more generally, is analogous to a problem in philosophy
called the black swan paradox. This is based on the ancient Western conception that all swans
were white. In that context, a black swan was a metaphor for something that could not exist. (Black
swans were discovered in Australia by European explorers in the 17th Century.) The term “black
swan paradox” was first coined by the famous philosopher of science Karl Popper; the term has also
been used as the title of a recent popular book [Tal07]. This paradox was used to illustrate the
problem of induction, which is the problem of how to draw general conclusions about the future
from specific observations from the past. The solution to the paradox is to admit that induction is in
general impossible, and that the best we can do is to make plausible guesses about what the future
might hold, by combining the empirical data with prior knowledge.
4.5.2 Example: MAP estimation for the multivariate Gaussian *
In Section 4.2.6, we showed that the MLE for the mean of an MVN is the empirical mean, µˆmle = y.
We also showed that the MLE for the covariance is the empirical covariance, Σˆ =
1
N
Sy.
In high dimensions the estimate for Σ can easily become singular. One solution to this is to
perform MAP estimation, as we explain below.
4.5.2.1 Shrinkage estimate
A convenient prior to use for Σ is the inverse Wishart prior. This is a distribution over positive
definite matrices, where the parameters are defined in terms of a prior scatter matrix, `
S, and a prior
sample size or strength `
N. One can show that the resulting MAP estimate is given by
Σˆ map =
`
S +Sy
`
N +N
=
`
N
`
N +N
`
S
`
N
+
N
`
N +N
Sy
N
= λΣ0 + (1 − λ)Σˆ mle (4.97)
where λ =
`N`N+N
controls the amount of regularization.
A common choice (see e.g., [FR07, p6]) for the prior scatter matrix is to use `
S=
`
N diag(Σˆ mle).
With this choice, we find that the MAP estimate for Σ is given by
Σˆ map(i, j) = 
Σˆ mle(i, j) if i = j
(1 − λ)Σˆ mle(i, j) otherwise
(4.98)
Thus we see that the diagonal entries are equal to their ML estimates, and the off-diagonal elements
are “shrunk” somewhat towards 0. This technique is therefore called shrinkage estimation.
The other parameter we need to set is λ, which controls the amount of regularization (shrink￾age towards the MLE). It is common to set λ by cross validation (Section 4.5.5). Alternatively,
we can use the closed-form formula provided in [LW04a; LW04b; SS05], which is the optimal
frequentist estimate if we use squared loss. This is implemented in the sklearn function https://scikit￾learn.org/stable/modules/generated/sklearn.covariance.LedoitWolf.html.
The benefits of this approach are illustrated in Figure 4.4. We consider fitting a 50-dimensional
Gaussian to N = 100, N = 50 and N = 25 data points. We see that the MAP estimate is always
well-conditioned, unlike the MLE (see Section 7.1.4.4 for a discussion of condition numbers). In
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.5. Regularization 119
0 5 10 15 20 25
0
0.5
1
1.5
eigenvalue
N=100, D=50
true, k=10.00
MLE, k= 71
MAP, k=8.62
0 5 10 15 20 25
0
0.5
1
1.5
eigenvalue
N=50, D=50
true, k=10.00
MLE, k=1.7e+17
MAP, k=8.85
0 5 10 15 20 25
0
0.5
1
1.5
eigenvalue
N=25, D=50
true, k=10.00
MLE, k=2.2e+18
MAP, k=21.09
Figure 4.4: Estimating a covariance matrix in D = 50 dimensions using N ∈ {100, 50, 25} samples. We
plot the eigenvalues in descending order for the true covariance matrix (solid black), the MLE (dotted blue)
and the MAP estimate (dashed red), using Equation (4.98) with λ = 0.9. We also list the condition number
of each matrix in the legend. We see that the MLE is often poorly conditioned, but the MAP estimate is
numerically well behaved. Adapted from Figure 1 of [SS05]. Generated by code at figures.probml.ai/book1/4.4.
particular, we see that the eigenvalue spectrum of the MAP estimate is much closer to that of the
true matrix than the MLE’s spectrum. The eigenvectors, however, are unaffected.
4.5.3 Example: weight decay
In Figure 1.7, we saw how using polynomial regression with too high of a degree can result in
overfitting. One solution is to reduce the degree of the polynomial. However, a more general solution
is to penalize the magnitude of the weights (regression coefficients). We can do this by using a
zero-mean Gaussian prior, p(w). The resulting MAP estimate is given by
wˆ map = argmin
w
NLL(w) + λ||w||2
2
(4.99)
where ||w||2
2 =
PD
d=1 w
2
d
. (We write w rather than θ, since it only really make sense to penalize the
magnitude of weight vectors, rather than other parameters, such as bias terms or noise variances.)
Equation (4.99) is called `2 regularization or weight decay. The larger the value of λ, the more
the parameters are penalized for being “large” (deviating from the zero-mean prior), and thus the
less flexible the model.
In the case of linear regression, this kind of penalization scheme is called ridge regression. For
example, consider the polynomial regression example from Section 1.2.2.2, where the predictor has
the form
f(x; w) = X
D
d=0
wdx
d = wT
[1, x, x2
, . . . , xD] (4.100)
Suppose we use a high degree polynomial, say D = 14, even though we have a small dataset with
just N = 21 examples. MLE for the parameters will enable the model to fit the data very well, by
carefully adjusting the weights, but the resulting function is very “wiggly”, thus resulting in overfitting.
Figure 4.5 illustrates how increasing λ can reduce overfitting. For more details on ridge regression,
see Section 11.3.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license120 Chapter 4. Statistics
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
7.5
5.0
2.5
0.0
2.5
5.0
7.5
10.0
L2 regularizer 0.00000
(a)
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
7.5
5.0
2.5
0.0
2.5
5.0
7.5
10.0
L2 regularizer 0.00019
(b)
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
7.5
5.0
2.5
0.0
2.5
5.0
7.5
10.0
L2 regularizer 1.10776
(c)
10
9 10
7 10
5 10
3 10
1 10
1
L2 regularizer
2.5
5.0
7.5
10.0
12.5
15.0
17.5
20.0
mse
test
train
(d)
Figure 4.5: (a-c) Ridge regression applied to a degree 14 polynomial fit to 21 datapoints. (d) MSE vs strength
of regularizer. The degree of regularization increases from left to right, so model complexity decreases from
left to right. Generated by code at figures.probml.ai/book1/4.5.
4.5.4 Picking the regularizer using a validation set
A key question when using regularization is how to choose the strength of the regularizer λ: a small
value means we will focus on minimizing empirical risk, which may result in overfitting, whereas a
large value means we will focus on staying close to the prior, which may result in underfitting.
In this section, we describe a simple but very widely used method for choosing λ. The basic idea
is to partition the data into two disjoint sets, the training set Dtrain and a validation set Dvalid
(also called a development set). (Often we use about 80% of the data for the training set, and
20% for the validation set.) We fit the model on Dtrain (for each setting of λ) and then evaluate its
performance on Dvalid. We then pick the value of λ that results in the best validation performance.
(This optimization method is a 1d example of grid search, discussed in Section 8.8.)
To explain the method in more detail, we need some notation. Let us define the regularized
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.5. Regularization 121
Figure 4.6: Schematic of 5-fold cross validation.
empirical risk on a dataset as follows:
Rλ(θ, D) = 1
|D|
X
(x,y)∈D
`(y, f(x; θ)) + λC(θ) (4.101)
For each λ, we compute the parameter estimate
θˆ
λ(Dtrain) = argmin
θ
Rλ(θ, Dtrain) (4.102)
We then compute the validation risk:
R
val
λ , R0(θˆ
λ(Dtrain), Dvalid) (4.103)
This is an estimate of the population risk, which is the expected loss under the true distribution
p
∗
(x, y). Finally we pick
λ
∗ = argmin
λ∈S
R
val
λ
(4.104)
(This requires fitting the model once for each value of λ in S, although in some cases, this can be
done more efficiently.)
After picking λ
∗
, we can refit the model to the entire dataset, D = Dtrain ∪ Dvalid, to get
θˆ∗ = argmin
θ
Rλ∗ (θ, D) (4.105)
4.5.5 Cross-validation
The above technique in Section 4.5.4 can work very well. However, if the size of the training set
is small, leaving aside 20% for a validation set can result in an unreliable estimate of the model
parameters.
A simple but popular solution to this is to use cross validation (CV). The idea is as follows: we
split the training data into K folds; then, for each fold k ∈ {1, . . . , K}, we train on all the folds but
the k’th, and test on the k’th, in a round-robin fashion, as sketched in Figure 4.6. Formally, we have
R
cv
λ ,
1
K
X
K
k=1
R0(θˆ
λ(D−k), Dk) (4.106)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license122 Chapter 4. Statistics
where Dk is the data in the k’th fold, and D−k is all the other data. This is called the cross-validated
risk. Figure 4.6 illustrates this procedure for K = 5. If we set K = N, we get a method known as
leave-one-out cross-validation, since we always train on N − 1 items and test on the remaining
one.
We can use the CV estimate as an objective inside of an optimization routine to pick the optimal
hyperparameter, λˆ = argminλ Rcv
λ
. Finally we combine all the available data (training and validation),
and re-estimate the model parameters using θˆ = argminθ Rλˆ(θ, D). See Section 5.4.3 for more details.
4.5.5.1 The one standard error rule
CV gives an estimate of Rˆ
λ, but does not give any measure of uncertainty. A standard frequentist
measure of uncertainty of an estimate is the standard error of the mean, which is the mean of
the sampling distribution of the estimate (see Section 4.7.1). We can compute this as follows. First
let Ln = `(yn, f(xn; θˆ
λ(D−n)) be the loss on the n’th example, where we use the parameters that
were estimated using whichever training fold excludes n. (Note that Ln depends on λ, but we drop
this from the notation.) Next let µˆ =
1
N
PN
n=1 Ln be the empirical mean and σˆ
2 =
1
N
PN
n=1(Ln −µˆ)
2
be the empirical variance. Given this, we define our estimate to be µˆ, and the standard error of
this estimate to be se(µˆ) = √σˆ
N
. Note that σ measures the intrinsic variability of Ln across samples,
whereas se(ˆµ) measures our uncertainty about the mean µˆ.
Suppose we apply CV to a set of models and compute the mean and se of their estimated risks.
A common heuristic for picking a model from these noisy estimates is to pick the value which
corresponds to the simplest model whose risk is no more than one standard error above the risk of
the best model; this is called the one-standard error rule [HTF01, p216].
4.5.5.2 Example: ridge regression
As an example, consider picking the strength of the `2 regularizer for the ridge regression problem
in Section 4.5.3. In Figure 4.7a, we plot the error vs log(λ) on the train set (blue) and test set
(red curve). We see that the test error has a U-shaped curve, where it decreases as we increase the
regularizer, and then increases as we start to underfit. In Figure 4.7b, we plot the 5-fold CV estimate
of the test MSE vs log(λ). We see that the minimum CV error is close the optimal value for the test
set (although it does underestimate the spike in the test error for large lambda, due to the small
sample size.)
4.5.6 Early stopping
A very simple form of regularization, which is often very effective in practice (especially for complex
models), is known as early stopping. This leverages the fact that optimization algorithms are
iterative, and so they take many steps to move away from the initial parameter estimates. If we detect
signs of overfitting (by monitoring performance on the validation set), we can stop the optimization
process, to prevent the model memorizing too much information about the training set. See Figure 4.8
for an illustration.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.5. Regularization 123
10
−9 10
−7 10
−5 10
−3 10
−1 10
1
log lambda
2.5
5.0
7.5
10.0
12.5
15.0
17.5
20.0
mean squared error
train_mse
test_mse
(a)
10
−9 10
−7 10
−5 10
−3 10
−1 10
1
log lambda
5
10
15
20
25
30
mean squared error
5-fold cross validation, ntrain = 21
(b)
Figure 4.7: Ridge regression is applied to a degree 14 polynomial fit to 21 datapoints shown in Figure 4.5
for different values of the regularizer λ. The degree of regularization increases from left to right, so model
complexity decreases from left to right. (a) MSE on train (blue) and test (red) vs log(λ). (b) 5-fold cross￾validation estimate of test MSE; error bars are standard error of the mean. Vertical line is the point chosen
by the one standard error rule. Generated by code at figures.probml.ai/book1/4.7.
4.5.7 Using more data
As the amount of data increases, the chance of overfitting (for a model of fixed complexity) decreases
(assuming the data contains suitably informative examples, and is not too redundant). This is
illustrated in Figure 4.9. We show the MSE on the training and test sets for four different models
(polynomials of increasing degree) as a function of the training set size N. (A plot of error vs training
set size is known as a learning curve.) The horizontal black line represents the Bayes error, which
is the error of the optimal predictor (the true model) due to inherent noise. (In this example, the
true model is a degree 2 polynomial, and the noise has a variance of σ
2 = 4; this is called the noise
floor, since we cannot go below it.)
We notice several interesting things. First, the test error for degree 1 remains high, even as N
increases, since the model is too simple to capture the truth; this is called underfitting. The test
error for the other models decreases to the optimal level (the noise floor), but it decreases more
rapidly for the simpler models, since they have fewer parameters to estimate. The gap between the
test error and training error is larger for more complex models, but decreases as N grows.
Another interesting thing we can note is that the training error (blue line) initially increases with
N, at least for the models that are sufficiently flexible. The reason for this is as follows: as the data
set gets larger, we observe more distinct input-output pattern combinations, so the task of fitting the
data becomes harder. However, eventually the training set will come to resemble the test set, and
the error rates will converge, and will reflect the optimal performance of that model.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license124 Chapter 4. Statistics
0 10 20 30 40 50
Epochs
0.1
0.2
0.3
0.4
0.5
0.6
0.7
Loss
Training and validation loss
Training loss
Validation loss
0 10 20 30 40 50
Epochs
0.6
0.7
0.8
0.9
1.0
Accuracy
Training and validation accuracy
Training acc
Validation acc
Figure 4.8: Performance of a text classifier (a neural network applied to a bag of word embeddings using
average pooling) vs number of training epochs on the IMDB movie sentiment dataset. Blue = train, red =
validation. (a) Cross entropy loss. Early stopping is triggered at about epoch 25. (b) Classification accuracy.
Generated by code at figures.probml.ai/book1/4.8.
0 25 50 75 100 125 150 175 200
size of training set
0.0
2.5
5.0
7.5
10.0
12.5
15.0
17.5
20.0
mse
truth = degree 2, model = degree 1
test
train
(a)
0 25 50 75 100 125 150 175 200
size of training set
0.0
2.5
5.0
7.5
10.0
12.5
15.0
17.5
20.0
mse
truth = degree 2, model = degree 2
test
train
(b)
0 25 50 75 100 125 150 175 200
size of training set
0.0
2.5
5.0
7.5
10.0
12.5
15.0
17.5
20.0
mse
truth = degree 2, model = degree 10
test
train
(c)
0 25 50 75 100 125 150 175 200
size of training set
0.0
2.5
5.0
7.5
10.0
12.5
15.0
17.5
20.0
mse
truth = degree 2, model = degree 20
test
train
(d)
Figure 4.9: MSE on training and test sets vs size of training set, for data generated from a degree 2 polynomial
with Gaussian noise of variance σ
2 = 4. We fit polynomial models of varying degree to this data. Generated
by code at figures.probml.ai/book1/4.9.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.6. Bayesian statistics * 125
4.6 Bayesian statistics *
So far, we have discussed several ways to estimate parameters from data. However, these approaches
ignore any uncertainty in the estimates, which can be important for some applications, such as
active learning, or avoiding overfitting, or just knowing how much to trust the estimate of some
scientifically meaningful quantity. In statistics, modeling uncertainty about parameters using a
probability distribution (as opposed to just computing a point estimate) is known as inference.
In this section, we use the posterior distribution to represent out uncertainty. This is the
approach adopted in the field of Bayesian statistics. We give a brief introduction here, but more
details can be found in the sequel to this book, [Mur22], as well as other good books, such as [Kru15;
McE20; Gel+14].
To compute the posterior, we start with a prior distribution p(θ), which reflects what we know
before seeing the data. We then define a likelihood function p(D|θ), which reflects the data we
expect to see for each setting of the parameters. We then use Bayes rule to condition the prior on
the observed data to compute the posterior p(θ|D) as follows:
p(θ|D) = p(θ)p(D|θ)
p(D)
=
p(θ)p(D|θ)
R
p(θ
0)p(D|θ
0)dθ
0
(4.107)
The denominator p(D) is called the marginal likelihood, since it is computed by marginalizing
over (or integrating out) the unknown θ. This can be interpreted as the average probability of
the data, where the average is wrt the prior. Note, however, that p(D) is a constant, independent of
θ, so we will often ignore it when we just want to infer the relative probabilities of θ values.
Equation (4.107) is analogous to the use of Bayes rule for COVID-19 testing in Section 2.3.1. The
difference is that the unknowns correspond to parameters of a statistical model, rather than the
unknown disease state of a patient. In addition, we usually condition on a set of observations D, as
opposed to a single observation (such as a single test outcome). In particular, for a supervised or
conditional model, the observed data has the form D = {(xn, yn) : n = 1 : N}. For an unsupervised
or unconditional model, the observed data has the form D = {(yn) : n = 1 : N}.
Once we have computed the posterior over the parameters, we can compute the posterior
predictive distribution over outputs given inputs by marginalizing out the unknown parameters.
In the supervised/ conditional case, this becomes
p(y|x, D) = Z
p(y|x, θ)p(θ|D)dθ (4.108)
This can be viewed as a form of Bayes model averaging (BMA), since we are making predictions
using an infinite set of models (parameter values), each one weighted by how likely it is. The use of
BMA reduces the chance of overfitting (Section 1.2.3), since we are not just using the single best
model.
4.6.1 Conjugate priors
In this section, we consider a set of (prior, likelihood) pairs for which we can compute the posterior
in closed form. In particular, we will use priors that are “conjugate” to the likelihood. We say that
a prior p(θ) ∈ F is a conjugate prior for a likelihood function p(D|θ) if the posterior is in the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license126 Chapter 4. Statistics
same parameterized family as the prior, i.e., p(θ|D) ∈ F. In other words, F is closed under Bayesian
updating. If the family F corresponds to the exponential family (defined in Section 3.4), then the
computations can be performed in closed form.
In the sections below, we give some common examples of this framework, which we will use later in
the book. For simplicity, we focus on unconditional models (i.e., there are only outcomes or targets
y, and no inputs or features x); we relax this assumption in Section 4.6.7.
4.6.2 The beta-binomial model
Suppose we toss a coin N times, and want to infer the probability of heads. Let yn = 1 denote the
event that the n’th trial was heads, yn = 0 represent the event that the n’th trial was tails, and let
D = {yn : n = 1 : N} be all the data. We assume yn ∼ Ber(θ), where θ ∈ [0, 1] is the rate parameter
(probability of heads). In this section, we discuss how to compute p(θ|D).
4.6.2.1 Bernoulli likelihood
We assume the data are iid or independent and identically distributed. Thus the likelihood
has the form
p(D|θ) = Y
N
n=1
θ
yn (1 − θ)
1−yn = θ
N1
(1 − θ)
N0
(4.109)
where we have defined N1 =
PN
n=1 I(yn = 1) and N0 =
PN
n=1 I(yn = 0), representing the number of
heads and tails. These counts are called the sufficient statistics of the data, since this is all we
need to know about D to infer θ. The total count, N = N0 + N1, is called the sample size.
4.6.2.2 Binomial likelihood
Note that we can also consider a Binomial likelihood model, in which we perform N trials and observe
the number of heads, y, rather than observing a sequence of coin tosses. Now the likelihood has the
following form:
p(D|θ) = Bin(y|N, θ) = 
N
y

θ
y
(1 − θ)
N−y
(4.110)
The scaling factor ￾N
y

is independent of θ, so we can ignore it. Thus this likelihood is proportional
to the Bernoulli likelihood in Equation (4.109), so our inferences about θ will be the same for both
models.
4.6.2.3 Prior
To simplify the computations, we will assume that the prior p(θ) ∈ F is a conjugate prior for the
likelihood function p(y|θ). This means that the posterior is in the same parameterized family as the
prior, i.e., p(θ|D) ∈ F.
To ensure this property when using the Bernoulli (or Binomial) likelihood, we should use a prior
of the following form:
p(θ) ∝ θ
`α−1
(1 − θ)
`β −1 = Beta(θ|
`α,
`
β) (4.111)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2024.6. Bayesian statistics * 127
0 0.2 0.4 0.6 0.8 1
0
0.5
1
1.5
2
2.5
3
prior Be(2.0, 2.0)
lik Be(5.0, 2.0)
post Be(6.0, 3.0)
(a)
0 0.2 0.4 0.6 0.8 1
0
0.5
1
1.5
2
2.5
prior Be(1.0, 1.0)
lik Be(5.0, 2.0)
post Be(5.0, 2.0)
(b)
Figure 4.10: Updating a Beta prior with a Bernoulli likelihood with sufficient statistics N1 = 4, N0 = 1. (a)
Beta(2,2) prior. (b) Uniform Beta(1,1) prior. Generated by code at figures.probml.ai/book1/4.10.
We recognize this as the pdf of a beta distribution (see Section 2.7.4).
4.6.2.4 Posterior
If we multiply the Bernoulli likelihood in Equation (4.109) with the beta prior in Equation (2.136)
we get a beta posterior:
p(θ|D) ∝ θ
N1
(1 − θ)
N0 θ
`α−1
(1 − θ)
`β −1
(4.112)
∝ Beta(θ|
`α +N1,
`
β +N0) (4.113)
= Beta(θ|
aα,
a
β) (4.114)
where aα,
`α +N1 and a
β,
`
β +N0 are the parameters of the posterior. Since the posterior has the same
functional form as the prior, we say that the beta distribution is a conjugate prior for the Bernoulli
likelihood.
The parameters of the prior are called hyper-parameters. It is clear that (in this example) the
hyper-parameters play a role analogous to the sufficient statistics; they are therefore often called
pseudo counts. We see that we can compute the posterior by simply adding the observed counts
(from the likelihood) to the pseudo counts (from the prior).
The strength of the prior is controlled by `
N=
`α +
`
β; this is called the equivalent sample size,
since it plays a role analogous to the observed sample size, N = N0 + N1.
4.6.2.5 Example
For example, suppose we set `α=
`
β= 2. This is like saying we believe we have already seen two heads
and two tails before we see the actual data; this is a very weak preference for the value of θ = 0.5.
The effect of using this prior is illustrated in Figure 4.10a. We see the posterior (blue line) is a
“compromise” between the prior (red line) and the likelihood (black line).
If we set `α=
`
β= 1, the corresponding prior becomes the uniform distribution:
p(θ) = Beta(θ|1, 1) ∝ θ
0
(1 − θ)
0 = Unif(θ|0, 1) (4.115)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license128 Chapter 4. Statistics
The effect of using this prior is illustrated in Figure 4.10b. We see that the posterior has exactly the
same shape as the likelihood, since the prior was “uninformative”.
4.6.2.6 Posterior mode (MAP estimate)
The most probable value of the parameter is given by the MAP estimate
ˆθmap = arg max
θ
p(θ|D) (4.116)
= arg max
θ
log p(θ|D) (4.117)
= arg max
θ
log p(θ) + log p(D|θ) (4.118)
One can show that this is given by
ˆθmap =
`α +N1 − 1
`α +N1 − 1+
`
β +N0 − 1
(4.119)
If we use a Beta(θ|2, 2) prior, this amounts to add-one smoothing:
ˆθmap =
N1 + 1
N1 + 1 + N0 + 1
=
N1 + 1
N + 2
(4.120)
If we use a uniform prior, p(θ) ∝ 1, the MAP estimate becomes the MLE, since log p(θ) = 0:
ˆθmle = arg max
θ
log p(D|θ) (4.121)
When we use a Beta prior, the uniform distribution is `α=
`
β= 1. In this case, the MAP estimate
reduces to the MLE:
ˆθmle =
N1
N1 + N0
=
N1
N
(4.122)
If N1 = 0, we will estimate that p(Y = 1) = 0.0, which says that we do not predict any future
observations to be 1. This is a very extreme estimate, that is likely due to insufficient data. We can
solve this problem using a MAP estimate with a stronger prior, or using a fully Bayesian approach,
in which we marginalize out θ instead of estimating it, as explained in Section 4.6.2.9.
4.6.2.7 Posterior mean
The posterior mode can be a poor summary of the posterior, since it corresponds to a single point.
The posterior mean is a more robust estimate, since it integrates over the whole space.
If p(θ|D) = Beta(θ|
aα,
a
β), then the posterior mean is given by
θ , E [θ|D] =
aα
a
β +
aα
=
aα
a
N
(4.123)
where a
N=
a
β +
aα is the strength (equivalent sample size) of the posterior.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.6. Bayesian statistics * 129
We will now show that the posterior mean is a convex combination of the prior mean, m =
`α /
`
N
(where `
N,
`α +
`
β is the prior strength), and the MLE: ˆθmle =
N1
N
:
E [θ|D] =
`α +N1
`α +N1+
`
β +N0
=
`
N m + N1
N+
`
N
=
`
N
N+
`
N
m +
N
N+
`
N
N1
N
= λm + (1 − λ)
ˆθmle (4.124)
where λ =
`NaN
is the ratio of the prior to posterior equivalent sample size. So the weaker the prior,
the smaller is λ, and hence the closer the posterior mean is to the MLE.
4.6.2.8 Posterior variance
To capture some notion of uncertainty in our estimate, a common approach is to compute the
standard error of our estimate, which is just the posterior standard deviation:
se(θ) = p
V [θ|D] (4.125)
In the case of the Bernoulli model, we showed that the posterior is a beta distribution. The variance
of the beta posterior is given by
V [θ|D] =
aα
a
β
(
aα +
a
β)
2(
aα +
a
β +1)
= E [θ|D]
2
a
β
aα (1+ aα +
a
β)
(4.126)
where aα=
`α +N1 and a
β=
`
β +N0. If N `α +
`
β, this simplifies to
V [θ|D] ≈
N1N0
N3
=
ˆθ(1 − ˆθ)
N
(4.127)
where ˆθ is the MLE. Hence the standard error is given by
σ =
p
V [θ|D] ≈
s
ˆθ(1 − ˆθ)
N
(4.128)
We see that the uncertainty goes down at a rate of 1/
√
N. We also see that the uncertainty (variance)
is maximized when ˆθ = 0.5, and is minimized when ˆθ is close to 0 or 1. This makes sense, since it is
easier to be sure that a coin is biased than to be sure that it is fair.
4.6.2.9 Posterior predictive
Suppose we want to predict future observations. A very common approach is to first compute an
estimate of the parameters based on training data, θˆ(D), and then to plug that parameter back into
the model and use p(y|θˆ) to predict the future; this is called a plug-in approximation. However,
this can result in overfitting. As an extreme example, suppose we have seen N = 3 heads in a row.
The MLE is ˆθ = 3/3 = 1. However, if we use this estimate, we would predict that tails are impossible.
One solution to this is to compute a MAP estimate, and plug that in, as we discussed in Section 4.5.1.
Here we discuss a fully Bayesian solution, in which we marginalize out θ.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license130 Chapter 4. Statistics
(0,0)
(1,0) (0,1)
(2,0) (1,1) (0,2)
(2,1)(3,0) (0,3)(1,2)
(3,1) (2,2) (1,3)
Figure 4.11: Illustration of sequential Bayesian updating for the beta-Bernoulli model. Each colored box
represents the predicted distribution p(xt|ht), where ht = (N1,t, N0,t) is the sufficient statistic derived from
history of observations up until time t, namely the total number of heads and tails. The probability of heads
(blue bar) is given by p(xt = 1|ht) = (Nt,1 + 1)/(t + 2), assuming we start with a uniform Beta(θ|1, 1) prior.
From Figure 3 of [Ort+19]. Used with kind permission of Pedro Ortega.
Bernoulli model
For the Bernoulli model, the resulting posterior predictive distribution has the form
p(y = 1|D) = Z 1
0
p(y = 1|θ)p(θ|D)dθ (4.129)
=
Z 1
0
θ Beta(θ|
aα,
a
β)dθ = E [θ|D] =
aα
aα +
a
β
(4.130)
In Section 4.5.1, we had to use the Beta(2,2) prior to recover add-one smoothing, which is a
rather unnatural prior. In the Bayesian approach, we can get the same effect using a uniform prior,
p(θ) = Beta(θ|1, 1), since the predictive distribution becomes
p(y = 1|D) = N1 + 1
N1 + N0 + 2
(4.131)
This is known as Laplace’s rule of succession. See Figure 4.11 for an illustration of this in the
sequential setting.
Binomial model
Now suppose we were interested in predicting the number of heads in M > 1 future coin tossing
trials, i.e., we are using the binomial model instead of the Bernoulli model. The posterior over θ is
the same as before, but the posterior predictive distribution is different:
p(y|D, M) = Z 1
0
Bin(y|M, θ)Beta(θ|
aα,
a
β)dθ (4.132)
=

M
y

1
B(
aα,
a
β)
Z 1
0
θ
y
(1 − θ)
M−y
θ
aα−1
(1 − θ)
aβ −1
dθ (4.133)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.6. Bayesian statistics * 131
0 1 2 3 4 5 6 7 8 9 10
0
0.02
0.04
0.06
0.08
0.1
0.12
0.14
0.16
0.18
0.2 posterior predictive
(a)
0 1 2 3 4 5 6 7 8 9 10
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35 plugin predictive
(b)
Figure 4.12: (a) Posterior predictive distributions for 10 future trials after seeing N1 = 4 heads and N0 = 1
tails. (b) Plug-in approximation based on the same data. In both cases, we use a uniform prior. Generated by
code at figures.probml.ai/book1/4.12.
We recognize the integral as the normalization constant for a Beta(
aα +y, M − y+
a
β) distribution.
Hence
Z 1
0
θ
y+aα−1
(1 − θ)
M−y+
aβ −1
dθ = B(y+
aα, M − y+
a
β) (4.134)
Thus we find that the posterior predictive is given by the following, known as the (compound)
beta-binomial distribution:
Bb(x|M, aα,
a
β) ,

M
x

B(x+
aα, M − x+
a
β)
B(
aα,
a
β)
(4.135)
In Figure 4.12(a), we plot the posterior predictive density for M = 10 after seeing N1 = 4 heads
and N0 = 1 tails, when using a uniform Beta(1,1) prior. In Figure 4.12(b), we plot the plug-in
approximation, given by
p(θ|D) ≈ δ(θ − ˆθ) (4.136)
p(y|D, M) = Z 1
0
Bin(y|M, θ)p(θ|D)dθ = Bin(y|M, ˆθ) (4.137)
where ˆθ is the MAP estimate. Looking at Figure 4.12, we see that the Bayesian prediction has
longer tails, spreading its probablity mass more widely, and is therefore less prone to overfitting and
black-swan type paradoxes. (Note that we use a uniform prior in both cases, so the difference is not
arising due to the use of a prior; rather, it is due to the fact that the Bayesian approach integrates
out the unknown parameters when making its predictions.)
4.6.2.10 Marginal likelihood
The marginal likelihood or evidence for a model M is defined as
p(D|M) = Z
p(θ|M)p(D|θ,M)dθ (4.138)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license132 Chapter 4. Statistics
When performing inference for the parameters of a specific model, we can ignore this term, since it is
constant wrt θ. However, this quantity plays a vital role when choosing between different models,
as we discuss in Section 5.2.2. It is also useful for estimating the hyperparameters from data (an
approach known as empirical Bayes), as we discuss in Section 4.6.5.3.
In general, computing the marginal likelihood can be hard. However, in the case of the beta￾Bernoulli model, the marginal likelihood is proportional to the ratio of the posterior normalizer to
the prior normalizer. To see this, recall that the posterior for the beta-binomial models is given by
p(θ|D) = Beta(θ|a
0
, b0
), where a
0 = a + N1 and b
0 = b + N0. We know the normalization constant of
the posterior is B(a
0
, b0
). Hence
p(θ|D) = p(D|θ)p(θ)
p(D)
(4.139)
=
1
p(D)

1
B(a, b)
θ
a−1
(1 − θ)
b−1
  N
N1

θ
N1
(1 − θ)
N0

(4.140)
=

N
N1

1
p(D)
1
B(a, b)

θ
a+N1−1
(1 − θ)
b+N0−1

(4.141)
So
1
B(a + N1, b + N0)
=

N
N1

1
p(D)
1
B(a, b)
(4.142)
p(D) = 
N
N1

B(a + N1, b + N0)
B(a, b)
(4.143)
The marginal likelihood for the beta-Bernoulli model is the same as above, except it is missing the

N
N1

term.
4.6.2.11 Mixtures of conjugate priors
The beta distribution is a conjugate prior for the binomial likelihood, which enables us to easily
compute the posterior in closed form, as we have seen. However, this prior is rather restrictive. For
example, suppose we want to predict the outcome of a coin toss at a casino, and we believe that the
coin may be fair, but may equally likely be biased towards heads. This prior cannot be represented
by a beta distribution. Fortunately, it can be represented as a mixture of beta distributions.
For example, we might use
p(θ) = 0.5 Beta(θ|20, 20) + 0.5 Beta(θ|30, 10) (4.144)
If θ comes from the first distribution, the coin is fair, but if it comes from the second, it is biased
towards heads.
We can represent a mixture by introducing a latent indicator variable h, where h = k means that
θ comes from mixture component k. The prior has the form
p(θ) = X
k
p(h = k)p(θ|h = k) (4.145)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.6. Bayesian statistics * 133
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
mixture of Beta distributions
prior
posterior
Figure 4.13: A mixture of two Beta distributions. Generated by code at figures.probml.ai/book1/4.13.
where each p(θ|h = k) is conjugate, and p(h = k) are called the (prior) mixing weights. One can
show (Exercise 4.6) that the posterior can also be written as a mixture of conjugate distributions as
follows:
p(θ|D) = X
k
p(h = k|D)p(θ|D, h = k) (4.146)
where p(h = k|D) are the posterior mixing weights given by
p(h = k|D) = p(h = k)p(D|h = k)
P
k0 p(h = k
0)p(D|h = k
0)
(4.147)
Here the quantity p(D|h = k) is the marginal likelihood for mixture component k (see Section 4.6.2.10).
Returning to our example above, if we have the prior in Equation (4.144), and we observe N1 = 20
heads and N0 = 10 tails, then, using Equation (4.143), the posterior becomes
p(θ|D) = 0.346 Beta(θ|40, 30) + 0.654 Beta(θ|30, 20) (4.148)
See Figure 4.13 for an illustration.
We can compute the posterior probability that the coin is biased towards heads as follows:
Pr(θ > 0.5|D) = X
k
Pr(θ > 0.5|D, h = k)p(h = k|D) = 0.9604 (4.149)
If we just used a single Beta(20,20) prior, we would get a slightly smaller value of Pr(θ > 0.5|D) =
0.8858. So if we were “suspicious” initially that the casino might be using a biased coin, our fears
would be confirmed more quickly than if we had to be convinced starting with an open mind.
4.6.3 The Dirichlet-multinomial model
In this section, we generalize the results from Section 4.6.2 from binary variables (e.g., coins) to
K-ary variables (e.g., dice).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license134 Chapter 4. Statistics
4.6.3.1 Likelihood
Let Y ∼ Cat(θ) be a discrete random variable drawn from a categorical distribution. The likelihood
has the form
p(D|θ) = Y
N
n=1
Cat(yn|θ) = Y
N
n=1
Y
C
c=1
θ
I(yn=c)
c =
Y
C
c=1
θ
Nc
c
(4.150)
where Nc =
P
n
I(yn = c).
4.6.3.2 Prior
The conjugate prior for a categorical distribution is the Dirichlet distribution, which is a mul￾tivariate generalization of the beta distribution. This has support over the probability simplex,
defined by
SK = {θ : 0 ≤ θk ≤ 1,
X
K
k=1
θk = 1} (4.151)
The pdf of the Dirichlet is defined as follows:
Dir(θ|
`α) ,
1
B(
`α)
Y
K
k=1
θ
`αk−1
k
I(θ ∈ SK) (4.152)
where B(
`α) is the multivariate beta function,
B(
`α) ,
QK
k=1 Γ(`αk)
Γ(PK
k=1
`αk)
(4.153)
Figure 4.14 shows some plots of the Dirichlet when K = 3. We see that `α0=
P
k
`αk controls the
strength of the distribution (how peaked it is), and the `αk control where the peak occurs. For example,
Dir(1, 1, 1) is a uniform distribution, Dir(2, 2, 2) is a broad distribution centered at (1/3, 1/3, 1/3),
and Dir(20, 20, 20) is a narrow distribution centered at (1/3, 1/3, 1/3). Dir(3, 3, 20) is an asymmetric
distribution that puts more density in one of the corners. If `αk< 1 for all k, we get “spikes” at
the corners of the simplex. Samples from the distribution when `αk< 1 will be sparse, as shown in
Figure 4.15.
4.6.3.3 Posterior
We can combine the multinomial likelihood and Dirichlet prior to compute the posterior, as follows:
p(θ|D) ∝ p(D|θ)Dir(θ|
`α) (4.154)
=
"Y
k
θ
Nk
k
# "Y
k
θ
`αk−1
k
#
(4.155)
= Dir(θ|
`α1 +N1, . . . ,
`αK +NK) (4.156)
= Dir(θ|
aα) (4.157)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.6. Bayesian statistics * 135
1
2
3
(a) (b)
(c) (d)
Figure 4.14: (a) The Dirichlet distribution when K = 3 defines a distribution over the simplex, which can be
represented by the triangular surface. Points on this surface satisfy 0 ≤ θk ≤ 1 and P3
k=1 θk = 1. Generated
by code at figures.probml.ai/book1/4.14. (b) Plot of the Dirichlet density for `α= (20, 20, 20). (c) Plot of the
Dirichlet density for `α= (3, 3, 20). (d) Plot of the Dirichlet density for `α= (0.1, 0.1, 0.1). Generated by code
at figures.probml.ai/book1/4.14.
where aαk=
`αk +Nk are the parameters of the posterior. So we see that the posterior can be computed
by adding the empirical counts to the prior counts.
The posterior mean is given by
θk =
aαk
PK
k0=1
aαk0
(4.158)
The posterior mode, which corresponds to the MAP estimate, is given by
ˆθk =
aαk −1
PK
k0=1(
aαk0 −1)
(4.159)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license136 Chapter 4. Statistics
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
Samples from Dir (alpha=0.1)
(a)
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
Samples from Dir (alpha=1.0)
(b)
Figure 4.15: Samples from a 5-dimensional symmetric Dirichlet distribution for different parameter values.
(a) `α= (0.1, . . . , 0.1). This results in very sparse distributions, with many 0s. (b) `α= (1, . . . , 1). This results
in more uniform (and dense) distributions. Generated by code at figures.probml.ai/book1/4.15.
If we use `αk= 1, corresponding to a uniform prior, the MAP becomes the MLE:
ˆθk = Nk/N (4.160)
(See Section 4.2.4 for a more direct derivation of this result.)
4.6.3.4 Posterior predictive
The posterior predictive distribution is given by
p(y = k|D) = Z
p(y = k|θ)p(θ|D)dθ (4.161)
=
Z
θkp(θk|D)dθk = E [θk|D] =
a
P
αk
k0
aαk0
(4.162)
In other words, the posterior predictive distribution is given by
p(y|D) = Cat(y|θ) (4.163)
where θ , E [θ|D] are the posterior mean parameters. If instead we plug-in the MAP estimate, we
will suffer from the zero-count problem. The only way to get the same effect as add-one smoothing is
to use a MAP estimate with `αc= 2.
Equation (4.162) gives the probability of a single future event, conditioned on past observations
y = (y1, . . . , yN ). In some cases, we want to know the probability of observing a batch of future data,
say y˜ = (˜y1, . . . , y˜M). We can compute this as follows:
p(y˜|y) = p(y˜, y)
p(y)
(4.164)
The denominator is the marginal likelihood of the training data, and the numerator is the marginal
likelihood of the training and future test data. We discuss how to compute such marginal likelihoods
in Section 4.6.3.5.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.6. Bayesian statistics * 137
4.6.3.5 Marginal likelihood
By the same reasoning as in Section 4.6.2.10, one can show that the marginal likelihood for the
Dirichlet-categorical model is given by
p(D) = B(N + α)
B(α)
(4.165)
where
B(α) =
QK
k=1 Γ(αk)
Γ(P
k αk)
(4.166)
Hence we can rewrite the above result in the following form, which is what is usually presented in
the literature:
p(D) = Γ(P
k αk)
Γ(N +
P
k αk)
Y
k
Γ(Nk + αk)
Γ(αk)
(4.167)
4.6.4 The Gaussian-Gaussian model
In this section, we derive the posterior for the parameters of a Gaussian distribution. For simplicity,
we assume the variance is known. (The general case is discussed in the sequel to this book, [Mur22],
as well as other standard references on Bayesian statistics.)
4.6.4.1 Univariate case
If σ
2
is a known constant, the likelihood for µ has the form
p(D|µ) ∝ exp 
−
1
2σ
2
X
N
n=1
(yn − µ)
2
!
(4.168)
One can show that the conjugate prior is another Gaussian, N (µ| m` ,
`τ
2
). Applying Bayes’ rule for
Gaussians, as in Section 4.6.4.1, we find that the corresponding posterior is given by
p(µ|D, σ2
) = N (µ| ma ,
aτ
2
) (4.169)
aτ
2 =
1
N
σ2 +
1
`τ 2
=
σ
2 `τ
2
N
`τ
2 +σ
2
(4.170)
ma =
aτ
2

m`
`τ
2 +
Ny
σ
2

=
σ
2
N
`τ
2 +σ
2
m` +
N
`τ
2
N
`τ
2 +σ
2
y (4.171)
where y ,
1
N
PN
n=1 yn is the empirical mean.
This result is easier to understand if we work in terms of the precision parameters, which are
just inverse variances. Specifically, let κ = 1/σ2 be the observation precision, and `
λ= 1/
`τ
2 be the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license138 Chapter 4. Statistics
5 0 5
0.0
0.1
0.2
0.3
0.4
0.5
0.6
prior variance of 1
prior
lik
post
(a)
5 0 5
0.0
0.1
0.2
0.3
0.4
0.5
0.6
prior variance of 5
prior
lik
post
(b)
Figure 4.16: Inferring the mean of a univariate Gaussian with known σ
2
given observation y = 3. (a)
Using strong prior, p(µ) = N (µ|0, 1). (b) Using weak prior, p(µ) = N (µ|0, 5). Generated by code at
figures.probml.ai/book1/4.16.
precision of the prior. We can then rewrite the posterior as follows:
p(µ|D, κ) = N (µ| ma ,
a
λ
−1
) (4.172)
a
λ =
`
λ +Nκ (4.173)
ma =
Nκy+
`
λm`
a
λ
=
Nκ
Nκ+
`
λ
y +
`
λ
Nκ+
`
λ
m` (4.174)
These equations are quite intuitive: the posterior precision a
λ is the prior precision `
λ plus N units of
measurement precision κ. Also, the posterior mean ma is a convex combination of the empirical mean
y and the prior mean m` . This makes it clear that the posterior mean is a compromise between the
empirical mean and the prior. If the prior is weak relative to the signal strength (`
λ is small relative
to κ), we put more weight on the empirical mean. If the prior is strong relative to the signal strength
(
`
λ is large relative to κ), we put more weight on the prior. This is illustrated in Figure 4.16. Note
also that the posterior mean is written in terms of Nκy, so having N measurements each of precision
κ is like having one measurement with value y and precision Nκ.
Posterior after seeing N = 1 examples
To gain further insight into these equations, consider the posterior after seeing a single data point y
(so N = 1). Then the posterior mean can be written in the following equivalent ways:
ma =
`
λ
a
λ
m` +
κ
a
λ
y (4.175)
=m` +
κ
a
λ
(y− m` ) (4.176)
= y −
`
λ
a
λ
(y− m` ) (4.177)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.6. Bayesian statistics * 139
The first equation is a convex combination of the prior mean and the data. The second equation
is the prior mean adjusted towards the data y. The third equation is the data adjusted towards
the prior mean; this is called a shrinkage estimate. This is easier to see if we define the weight
w =
`
λ/
a
λ, which is the ratio of the prior to posterior precision. Then we have
ma = y − w(y− m` ) = (1 − w)y + w m` (4.178)
Note that, for a Gaussian, the posterior mean and posterior mode are the same. Thus we can use
the above equations to perform MAP estimation. See Exercise 4.2 for a simple example.
Posterior variance
In addition to the posterior mean or mode of µ, we might be interested in the posterior variance,
which gives us a measure of confidence in our estimate. The square root of this is called the standard
error of the mean:
se(µ) ,
p
V [µ|D] (4.179)
Suppose we use an uninformative prior for µ by setting `
λ= 0 (see Section 4.6.5.1). In this case, the
posterior mean is equal to the MLE, ma = y. Suppose, in addition, that we approximate σ
2 by the
sample variance
s
2 ,
1
N
X
N
n=1
(yn − y)
2
(4.180)
Hence a
λ= Nκˆ = N/s2
, so the SEM becomes
se(µ) = p
V [µ|D] = 1
√a
λ
=
s
√
N
(4.181)
Thus we see that the uncertainty in µ is reduced at a rate of 1/
√
N.
In addition, we can use the fact that 95% of a Gaussian distribution is contained within 2 standard
deviations of the mean to approximate the 95% credible interval for µ using
I.95(µ|D) = y ± 2
s
√
N
(4.182)
4.6.4.2 Multivariate case
For D-dimensional data, the likelihood has the form
p(D|µ) = Y
N
n=1
N (yn|µ, Σ) (4.183)
=
N
(2π)D/2|Σ|
1
2
exp "
−
1
2
X
N
n=1
(yn − µ)
TΣ
−1
(yn − µ)
#
(4.184)
= N (y|µ,
1
N
Σ) (4.185)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license140 Chapter 4. Statistics
−1 0 1
−1
−0.5
0
0.5
1
data prior
−1 0 1
−1
−0.5
0
0.5
1
post after 10 obs
−1 0 1
−1
−0.5
0
0.5
1
Figure 4.17: Illustration of Bayesian inference for the mean of a 2d Gaussian. (a) The data is generated from
yn ∼ N (µ, Σ), where µ = [0.5, 0.5]T
and Σ = 0.1[2, 1; 1, 1]). (b) The prior is p(µ) = N (µ|0, 0.1I2). (c) We
show the posterior after 10 data points have been observed. Generated by code at figures.probml.ai/book1/4.17.
where y =
1
N
PN
n=1 yn. Thus we replace the set of observations with their mean, and scale down the
covariance by a factor of N.
For simplicity, we will use a conjugate prior, which in this case is a Gaussian, namely
p(µ) = N (µ| m` ,
`
V) (4.186)
We can derive a Gaussian posterior for µ based on the results in Section 3.3.1 We get
p(µ|D, Σ) = N (µ| ma ,
a
V) (4.187)
a
V
−1
=
`
V
−1
+NΣ
−1
(4.188)
ma =
a
V (Σ
−1
(Ny)+ `
V
−1
m` ) (4.189)
Figure 4.17 gives a 2d example of these results.
4.6.5 Beyond conjugate priors
We have seen various examples of conjugate priors, all of which have come from the exponential
family (see Section 3.4). These priors have the advantage of being easy to interpret (in terms of
sufficient statistics from a virtual prior dataset), and easy to compute with. However, for most
models, there is no prior in the exponential family that is conjugate to the likelihood. Furthermore,
even where there is a conjugate prior, the assumption of conjugacy may be too limiting. Therefore in
the sections below, we briefly discuss various other kinds of priors.
4.6.5.1 Noninformative priors
When we have little or no domain specific knowledge, it is desirable to use an uninformative,
noninformative or objective priors, to “let the data speak for itself”. For example, if we want to
infer a real valued quantity, such as a location parameter µ ∈ R, we can use a flat prior p(µ) ∝ 1.
This can be viewed as an “infinitely wide” Gaussian.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.6. Bayesian statistics * 141
Unfortunately, there is no unique way to define uninformative priors, and they all encode some
kind of knowledge. It is therefore better to use the term diffuse prior, minimally informative
prior or default prior. See the sequel to this book, [Mur22], for more details.
4.6.5.2 Hierarchical priors
Bayesian models require specifying a prior p(θ) for the parameters. The parameters of the prior are
called hyperparameters, and will be denoted by φ. If these are unknown, we can put a prior on
them; this defines a hierarchical Bayesian model, or multi-level model, which can visualize
like this: φ → θ → D. We assume the prior on the hyper-parameters is fixed (e.g., we may use some
kind of minimally informative prior), so the joint distribution has the form
p(φ, θ, D) = p(φ)p(θ|φ)p(D|θ) (4.190)
The hope is that we can learn the hyperparameters by treating the parameters themselves as
datapoints. This is useful when we have multiple related parameters that need to be estimated (e.g.,
from different subpopulations, or muliple tasks); this provides a learning signal to the top level of the
model. See the sequel to this book, [Mur22], for details.
4.6.5.3 Empirical priors
In Section 4.6.5.2, we discussed hierarchical Bayes as a way to infer parameters from data. Unfortu￾nately, posterior inference in such models can be computationally challenging. In this section, we
discuss a computationally convenient approximation, in which we first compute a point estimate of
the hyperparameters, φˆ, and then compute the conditional posterior, p(θ|φˆ, D), rather than the joint
posterior, p(θ, φ|D).
To estimate the hyper-parameters, we can maximize the marginal likelihood:
φˆ
mml(D) = argmax
φ
p(D|φ) = argmax
φ
Z
p(D|θ)p(θ|φ)dθ (4.191)
This technique is known as type II maximum likelihood, since we are optimizing the hyperparam￾eters, rather than the parameters. Once we have estimated φˆ, we compute the posterior p(θ|φˆ, D) in
the usual way.
Since we are estimating the prior parameters from data, this approach is empirical Bayes (EB)
[CL96]. This violates the principle that the prior should be chosen independently of the data.
However, we can view it as a computationally cheap approximation to inference in the full hierarchical
Bayesian model, just as we viewed MAP estimation as an approximation to inference in the one level
model θ → D. In fact, we can construct a hierarchy in which the more integrals one performs, the
“more Bayesian” one becomes, as shown below.
Method Definition
Maximum likelihood θˆ = argmaxθ p(D|θ)
MAP estimation θˆ = argmaxθ p(D|θ)p(θ|φ)
ML-II (Empirical Bayes) φˆ = argmaxφ
R
p(D|θ)p(θ|φ)dθ
MAP-II φˆ = argmaxφ
R
p(D|θ)p(θ|φ)p(φ)dθ
Full Bayes p(θ, φ|D) ∝ p(D|θ)p(θ|φ)p(φ)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license142 Chapter 4. Statistics
0 0.2 0.4 0.6 0.8 1
0
0.5
1
1.5
2
2.5
3
3.5
(a)
0 0.2 0.4 0.6 0.8 1
0
0.5
1
1.5
2
2.5
3
3.5
(b)
Figure 4.18: (a) Central interval and (b) HPD region for a Beta(3,9) posterior. The CI is (0.06, 0.52) and the
HPD is (0.04, 0.48). Adapted from Figure 3.6 of [Hof09]. Generated by code at figures.probml.ai/book1/4.18.
Note that ML-II is less likely to overfit than “regular” maximum likelihood, because there are
typically fewer hyper-parameters φ than there are parameters θ. See the sequel to this book, [Mur22],
for details.
4.6.6 Credible intervals
A posterior distribution is (usually) a high dimensional object that is hard to visualize and work
with. A common way to summarize such a distribution is to compute a point estimate, such as the
posterior mean or mode, and then to compute a credible interval, which quantifies the uncertainty
associated with that estimate. (A credible interval is not the same as a confidence interval, which is
a concept from frequentist statistics which we discuss in Section 4.7.4.)
More precisely, we define a 100(1 − α)% credible interval to be a (contiguous) region C = (`, u)
(standing for lower and upper) which contains 1 − α of the posterior probability mass, i.e.,
Cα(D) = (`, u) : P(` ≤ θ ≤ u|D) = 1 − α (4.192)
There may be many intervals that satisfy Equation (4.192), so we usually choose one such that there
is (1−α)/2 mass in each tail; this is called a central interval. If the posterior has a known functional
form, we can compute the posterior central interval using ` = F
−1
(α/2) and u = F
−1
(1−α/2), where
F is the cdf of the posterior, and F
−1
is the inverse cdf. For example, if the posterior is Gaussian,
p(θ|D) = N (0, 1), and α = 0.05, then we have ` = Φ−1
(α/2) = −1.96, and u = Φ−1
(1 − α/2) = 1.96,
where Φ denotes the cdf of the Gaussian. This is illustrated in Figure 2.2b. This justifies the common
practice of quoting a credible interval in the form of µ ± 2σ, where µ represents the posterior mean,
σ represents the posterior standard deviation, and 2 is a good approximation to 1.96.
In general, it is often hard to compute the inverse cdf of the posterior. In this case, a sim￾ple alternative is to draw samples from the posterior, and then to use a Monte Carlo approxi￾mation to the posterior quantiles: we simply sort the S samples, and find the one that occurs
at location α/S along the sorted list. As S → ∞, this converges to the true quantile. See
code.probml.ai/book1/beta_credible_int_demo for a demo of this.
A problem with central intervals is that there might be points outside the central interval which
have higher probability than points that are inside, as illustrated in Figure 4.18(a). This motivates
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.6. Bayesian statistics * 143
−4 −2 0 2 4 6 8 10
0.0
0.1
0.2
0.3
0.4
0.5
α/2 α/2
(a)
−4 −2 0 2 4 6 8 10
pMIN
(b)
Figure 4.19: (a) Central interval and (b) HPD region for a hypothetical multimodal posterior. Adapted from
Figure 2.2 of [Gel+04]. Generated by code at figures.probml.ai/book1/4.19.
an alternative quantity known as the highest posterior density or HPD region, which is the set
of points which have a probability above some threshold. More precisely we find the threshold p
∗ on
the pdf such that
1 − α =
Z
θ:p(θ|D)>p∗
p(θ|D)dθ (4.193)
and then define the HPD as
Cα(D) = {θ : p(θ|D) ≥ p
∗
} (4.194)
In 1d, the HPD region is sometimes called a highest density interval or HDI. For example,
Figure 4.18(b) shows the 95% HDI of a Beta(3, 9) distribution, which is (0.04, 0.48). We see that
this is narrower than the central interval, even though it still contains 95% of the mass; furthermore,
every point inside of it has higher density than every point outside of it.
For a unimodal distribution, the HDI will be the narrowest interval around the mode containing
95% of the mass. To see this, imagine “water filling” in reverse, where we lower the level until 95%
of the mass is revealed, and only 5% is submerged. This gives a simple algorithm for computing
HDIs in the 1d case: simply search over points such that the interval contains 95% of the mass
and has minimal width. This can be done by 1d numerical optimization if we know the inverse
CDF of the distribution, or by search over the sorted data points if we have a bag of samples (see
code.probml.ai/book1/betaHPD for some code).
If the posterior is multimodal, the HDI may not even be a connected region: see Figure 4.19(b) for
an example. However, summarizing multimodal posteriors is always difficult.
4.6.7 Bayesian machine learning
So far, we have focused on unconditional models of the form p(y|θ). In supervised machine learning,
we use conditional models of the form p(y|x, θ). The posterior over the parameters is now p(θ|D),
where D = {(xn, yn) : n = 1 : N}. Computing this posterior can be done using the principles we
have already discussed. This approach is called Bayesian machine learning, since we are “being
Bayesian” about the model parameters.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license144 Chapter 4. Statistics
4.6.7.1 Plugin approximation
Once we have computed the posterior over the parameters, we can compute the posterior predictive
distribution over outputs given inputs by marginalizing out the unknown parameters:
p(y|x, D) = Z
p(y|x, θ)p(θ|D)dθ (4.195)
Of course, computing this integral is often intractable. A very simple approximation is to assume
there is just a single best model, θˆ, such as the MLE. This is equivalent to approximating the
posterior as an infinitely narrow, but infinitely tall, “spike” at the chosen value. We can write this as
follows:
p(θ|D) = δ(θ − θˆ) (4.196)
where δ is the Dirac delta function (see Section 2.6.5). If we use this approximation, then the
predictive distribution can be obtained by simply “plugging in” the point estimate into the likelihood:
p(y|x, D) = Z
p(y|x, θ)p(θ|D)dθ ≈
Z
p(y|x, θ)δ(θ − θˆ)dθ = p(y|x, θˆ) (4.197)
This follows from the sifting property of delta functions (Equation (2.129)).
The approach in Equation (4.197) is called a plug-in approximation. This approach is equivalent
to the standard approach used in most of machine learning, in which we first fit the model (i.e.
compute a point estimate θˆ) and then use it to make predicitons. However, the standard (plug-in)
approach can suffer from overfitting and overconfidence, as we discussed in Section 1.2.3. The
fully Bayesian approach avoids this by marginalizing out the parameters, but can be expensive.
Fortunately, even simple approximations, in which we average over a few plausible parameter values,
can improve performance. We give some examples of this below.
4.6.7.2 Example: scalar input, binary output
Suppose we want to perform binary classification, so y ∈ {0, 1}. We will use a model of the form
p(y|x; θ) = Ber(y|σ(wTx + b)) (4.198)
where
σ(a) ,
e
a
1 + e
a
(4.199)
is the sigmoid or logistic function which maps R → [0, 1], and Ber(y|µ) is the Bernoulli distribution
with mean µ (see Section 2.4 for details). In other words,
p(y = 1|x; θ) = σ(wTx + b) = 1
1 + e−(wTx+b)
(4.200)
This model is called logistic regression. (We discuss this in more detail in Chapter 10.)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.6. Bayesian statistics * 145
4.5 5.0 5.5 6.0 6.5 7.0
sepal_length
0.0
0.2
0.4
0.6
0.8
1.0
p(y=1)
(a)
4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5
sepal_length
0.0
0.2
0.4
0.6
0.8
1.0
p(y=1)
(b)
Figure 4.20: (a) Logistic regression for classifying if an Iris flower is Versicolor (y = 1) or setosa (y = 0) using
a single input feature x corresponding to sepal length. Labeled points have been (vertically) jittered to avoid
overlapping too much. Vertical line is the decision boundary. Generated by code at figures.probml.ai/book1/4.20.
(b) Same as (a) but showing posterior distribution. Adapted from Figure 4.4 of [Mar18]. Generated by code
at figures.probml.ai/book1/4.20.
Let us apply this model to the task of determining if an iris flower is of type Setosa or Versicolor,
yn ∈ {0, 1}, given information about the sepal length, xn. (See Section 1.2.1.1 for a description of
the iris dataset.)
We first fit a 1d logistic regression model of the following form
p(y = 1|x; θ) = σ(b + wx) (4.201)
to the dataset D = {(xn, yn)} using maximum likelihood estimation. (See Section 10.2.3 for details
on how to compute the MLE for this model.) Figure 4.20a shows the plugin approximation to the
posterior predictive, p(y = 1|x, θˆ), where θˆ is the MLE of the parameters. We see that we become
more confident that the flower is of type Versicolor as the sepal length gets larger, as represented by
the sigmoidal (S-shaped) logistic function.
The decision boundary is defined to be the input value x
∗ where p(y = 1|x
∗
; θˆ) = 0.5. We can
solve for this value as follows:
σ(b + wx∗
) = 1
1 + e−(b+wx∗)
=
1
2
(4.202)
b + wx∗ = 0 (4.203)
x
∗ = −
b
w
(4.204)
From Figure 4.20a, we see that x
∗ ≈ 5.5 cm.
However, the above approach does not model the uncertainty in our estimate of the parameters, and
therefore ignores the induced uncertainty in the output probabilities, and the location of the decision
boundary. To capture this additional uncertainty, we can use a Bayesian approach to approximate
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license146 Chapter 4. Statistics
ETA for Company A
ETA for Company B
DEADLINE
Time
Figure 4.21: Distribution of arrival times for two different shipping companies. ETA is the expected time of
arrival. A’s distribution has greater uncertainty, and may be too risky. From https: // bit. ly/ 39bc4XL .
Used with kind permission of Brendan Hasz.
the posterior p(θ|D). (See Section 10.5 for details.) Given this, we can approximate the posterior
predictive distribution using a Monte Carlo approximation:
p(y = 1|x, D) ≈
1
S
X
S
s=1
p(y = 1|x, θ
s
) (4.205)
where θ
s ∼ p(θ|D) is a posterior sample. Figure 4.20b plots the mean and 95% credible interval of
this function. We see that there is now a range of predicted probabilities for each input. We can
also compute a distribution over the location of the decision boundary by using the Monte Carlo
approximation
p(x
∗
|D) ≈
1
S
X
S
s=1
δ

x
∗ − (−
b
s
ws
)

(4.206)
where (b
s
, ws
) = θ
s
. The 95% credible interval for this distribution is shown by the “fat” vertical line
in Figure 4.20b.
Although carefully modeling our uncertainty may not matter for this application, it can be
important in risk-sensitive applications, such as health care and finance, as we discuss in Chapter 5.
4.6.7.3 Example: binary input, scalar output
Now suppose we want to predict the delivery time for a package, y ∈ R, if shipped by company A vs
B. We can encode the company id using a binary feature x ∈ {0, 1}, where x = 0 means company A
and x = 1 means company B. We will use the following discriminative model for this problem:
p(y|x, θ) = N (y|µx, σ2
x
) (4.207)
where N (y|µ, σ2
) is the Gaussian distribution
N (y|µ, σ2
) ,
1
√
2πσ2
e
− 1
2σ2
(y−µ)
2
(4.208)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.6. Bayesian statistics * 147
and θ = (µ0, µ1, σ0, σ1) are the parameters of the model. We can fit this model using maximum
likelihood estimation as we discuss in Section 4.2.5; alternatively, we can adopt a Bayesian approach,
as we discuss in Section 4.6.4.
The advantage of the Bayesian approach is that by capturing uncertainty in the parameters θ, we
also capture uncertainty in our forecasts p(y|x, D), whereas using a plug-in approximation p(y|x, θˆ)
would underestimate this uncertainty. For example, suppose we have only used each company once, so
our training set has the form D = {(x1 = 0, y1 = 15),(x2 = 1, y2 = 20)}. As we show in Section 4.2.5,
the MLE for the means will be the empirical means, µˆ0 = 15 and µˆ1 = 20, but the MLE for the
standard deviations will be zero, σˆ0 = σˆ1 = 0, since we only have a single sample from each “class”.
The resulting plug-in prediction will therefore not capture any uncertainty.
To see why modeling the uncertainty is important, consider Figure 4.21. We see that the expected
time of arrival (ETA) for company A is less than for company B; however, the variance of A’s
distribution is larger, which makes it a risky choice if you want to be confident the package will
arrive by the specified deadline. (For more details on how to choose optimal actions in the presence
of uncertainty, see Chapter 5.)
Of course, the above example is extreme, because we assumed we only had one example from each
delivery company. However, this kind of problem occurs whenever we have few examples of a given
kind of input, as can happen whenever the data has a long tail of novel patterns, such as a new
combination of words or categorical features.
4.6.7.4 Scaling up
The above examples were both extremely simple, involving 1d input and 1d output, and just 2–4
parameters. Most practical problems involve high dimensional inputs, and sometimes high dimensional
outputs, and therefore use models with lots of parameters. Unfortunately, computing the posterior,
p(θ|D), and the posterior predictive, p(y|x, D), can be computationally challenging for many models.
We discuss this issue in Section 4.6.8.
4.6.8 Computational issues
Given a likelihood p(D|θ) and a prior p(θ), we can compute the posterior p(θ|D) using Bayes’ rule.
However, actually performing this computation is usually intractable, except for simple special cases,
such as conjugate models (Section 4.6.1), or models where all the latent variables come from a small
finite set of possible values. We therefore need to approximate the posterior. There are a large variety
of methods for performing approximate posterior inference, which trade off accuracy, simplicity,
and speed. We briefly discuss some of these algorithms below, but go into more detail in the sequel
to this book, [Mur22]. (See also [MFR20] for a review of various approximate inference methods,
starting with Bayes’ original method in 1763.)
As a running example, we will use the problem of approximating the posterior of a beta-Bernoulli
model. Specifically, the goal is to approximate
p(θ|D) ∝
"Y
N
n=1
Bin(yn|θ)
#
Beta(θ|1, 1) (4.209)
where D consists of 10 heads and 1 tail (so the total number of observations is N = 11), and we
use a uniform prior. Although we can compute this posterior exactly (see Figure 4.22), using the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license148 Chapter 4. Statistics
0.0 0.2 0.4 0.6 0.8 1.0
grid approximation
(a)
0.0 0.2 0.4 0.6 0.8 1.0
Quadratic approximation
Laplace
exact
(b)
Figure 4.22: Approximating the posterior of a beta-Bernoulli model. (a) Grid approximation using 20 grid
points. (b) Laplace approximation. Generated by code at figures.probml.ai/book1/4.22.
method discussed in Section 4.6.2, this serves as a useful pedagogical example since we can compare
the approximation to the exact answer. Also, since the target distribution is just 1d, it is easy to
visualize the results. (Note, however, that the problem is not completely trivial, since the posterior is
highly skewed, due to the use of an imbalanced sample of 10 heads and 1 tail.)
4.6.8.1 Grid approximation
The simplest approach to approximate posterior inference is to partition the space of possible values
for the unknowns into a finite set of possibilities, call them θ1, . . . , θK, and then to approximate the
posterior by brute-force enumeration, as follows:
p(θ = θk|D) ≈
p(D|θk)p(θk)
p(D)
=
p(D|θk)p(θk)
PK
k0=1 p(D, θk0 )
(4.210)
This is called a grid approximation. In Figure 4.22a, we illustrate this method applied to our 1d
problem. We see that it is easily able to capture the skewed posterior. Unfortunately, this approach
does not scale to problems in more than 2 or 3 dimensions, because the number of grid points grows
exponentially with the number of dimensions.
4.6.8.2 Quadratic (Laplace) approximation
In this section, we discuss a simple way to approximate the posterior using a multivariate Gaussian;
this is known as a Laplace approximation or a quadratic approximation (see e.g., [TK86;
RMC09]).
To derive this, suppose we write the posterior as follows:
p(θ|D) = 1
Z
e
−E(θ)
(4.211)
where E(θ) = − log p(θ, D) is called an energy function, and Z = p(D) is the normalization constant.
Performing a Taylor series expansion around the mode θˆ (i.e., the lowest energy state) we get
E(θ) ≈ E(θˆ) + (θ − θˆ)
T
g +
1
2
(θ − θˆ)
TH(θ − θˆ) (4.212)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.6. Bayesian statistics * 149
where g is the gradient at the mode, and H is the Hessian. Since θˆ is the mode, the gradient term is
zero. Hence
pˆ(θ, D) = e
−E(θˆ)
exp 
−
1
2
(θ − θˆ)
TH(θ − θˆ)

(4.213)
pˆ(θ|D) = 1
Z
pˆ(θ, D) = N (θ|θˆ, H−1
) (4.214)
Z = e
−E(θˆ)
(2π)
D/2
|H|
− 1
2 (4.215)
The last line follows from normalization constant of the multivariate Gaussian.
The Laplace approximation is easy to apply, since we can leverage existing optimization algorithms
to compute the MAP estimate, and then we just have to compute the Hessian at the mode. (In high
dimensional spaces, we can use a diagonal approximation.)
In Figure 4.22b, we illustrate this method applied to our 1d problem. Unfortunately we see that it
is not a particularly good approximation. This is because the posterior is skewed, whereas a Gaussian
is symmetric. In addition, the parameter of interest lies in the constrained interval θ ∈ [0, 1], whereas
the Gaussian assumes an unconstrained space, θ ∈ R. Fortunately, we can solve this latter problem
by using a change of variable. For example, in this case we can apply the Laplace approximation to
α = logit(θ). This is a common trick to simplify the job of inference.
4.6.8.3 Variational approximation
In Section 4.6.8.2, we discussed the Laplace approximation, which uses an optimization procedure
to find the MAP estimate, and then approximates the curvature of the posterior at that point
based on the Hessian. In this section, we discuss variational inference (VI), which is another
optimization-based approach to posterior inference, but which has much more modeling flexibility
(and thus can give a much more accurate approximation).
VI attempts to approximate an intractable probability distribution, such as p(θ|D), with one that
is tractable, q(θ), so as to minimize some discrepancy D between the distributions:
q
∗ = argmin
q∈Q
D(q, p) (4.216)
where Q is some tractable family of distributions (e.g., multivariate Gaussian). If we define D to be
the KL divergence (see Section 6.2), then we can derive a lower bound to the log marginal likelihood;
this quantity is known as the evidence lower bound or ELBO. By maximizing the ELBO, we can
improve the quality of the posterior approximation. See the sequel to this book, [Mur22], for details.
4.6.8.4 Markov Chain Monte Carlo (MCMC) approximation
Although VI is a fast, optimization-based method, it can give a biased approximation to the posterior,
since it is restricted to a specific function form q ∈ Q. A more flexible approach is to use a non￾parametric approximation in terms of a set of samples, q(θ) ≈
1
S
PS
s=1 δ(θ − θ
s
). This is called a
Monte Carlo approximation to the posterior. The key issue is how to create the posterior samples
θ
s ∼ p(θ|D) efficiently, without having to evaluate the normalization constant p(D) = R
p(θ, D)dθ.
A common approach to this problem is known as Markov chain Monte Carlo or MCMC. If
we augment this algorithm with gradient-based information, derived from ∇ log p(θ, D), we can
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license150 Chapter 4. Statistics
significantly speed up the method; this is called Hamiltonian Monte Carlo or HMC. See the
sequel to this book, [Mur22], for details.
4.7 Frequentist statistics *
The approach to statistical inference that we described in Section 4.6 is called Bayesian statistics.
It treats parameters of models just like any other unknown random variable, and applies the rules
of probability theory to infer them from data. Attempts have been made to devise approaches to
statistical inference that avoid treating parameters like random variables, and which thus avoid
the use of priors and Bayes rule. This alternative approach is known as frequentist statistics,
classical statistics or orthodox statistics.
The basic idea (formalized in Section 4.7.1) is to to represent uncertainty by calculating how a
quantity estimated from data (such as a parameter or a predicted label) would change if the data
were changed. It is this notion of variation across repeated trials that forms the basis for modeling
uncertainty used by the frequentist approach. By contrast, the Bayesian approach views probability in
terms of information rather than repeated trials. This allows the Bayesian to compute the probability
of one-off events, as we discussed in Section 2.1.1. Perhaps more importantly, the Bayesian approach
avoids certain paradoxes that plague the frequentist approach (see Section 4.7.5 and Section 5.5.4).
These pathologies led the famous statistician George Box to say:
I believe that it would be very difficult to persuade an intelligent person that current [frequentist]
statistical practice was sensible, but that there would be much less difficulty with an approach
via likelihood and Bayes’ theorem. — George Box, 1962 (quoted in [Jay76]).
Nevertheless, it is useful to be familiar with frequentist statistics, since it is widely used, and has
some key concepts that are useful even for Bayesians [Rub84].
4.7.1 Sampling distributions
In frequentist statistics, uncertainty is not represented by the posterior distribution of a random
variable, but instead by the sampling distribution of an estimator. (We define these two terms
below.)
As explained in the section on decision theory in Section 5.1, an estimator is a decision procedure
that specifies what action to take given some observed data. In the context of parameter estimation,
where the action space is to return a parameter vector, we will denote this by θˆ = π(D). For example,
θˆ could be the maximum likelihood estimate, the MAP estimate, or the method of moments estimate.
The sampling distribution of an estimator is the distribution of results we would see if we applied
the estimator multiple times to different datasets sampled from some distribution; in the context of
parameter estimation, it is the distribution of θˆ, viewed as a random variable that depends on the
random sample D. In more detail, imagine sampling S different data sets, each of size N, from some
true model p(x|θ
∗
) to generate
D˜ (s) = {xn ∼ p(xn|θ
∗
) : n = 1 : N} (4.217)
We denote this by D(s) ∼ θ
∗
for brevity. Now apply the estimator to each D(s)
to get a set of estimates,
{θˆ(D(s)
)}. As we let S → ∞, the distribution induced by this set is the sampling distribution of the
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.7. Frequentist statistics * 151
estimator. More precisely, we have
p(π(D˜ ) = θ|D ∼˜ θ
∗
) ≈
1
S
X
S
s=1
δ(θ = π(D
(s)
)) (4.218)
In some cases, we can compute this analytically, as we discuss in Section 4.7.2, although typically we
need to approximate it by Monte Carlo, as we discuss in Section 4.7.3.
4.7.2 Gaussian approximation of the sampling distribution of the MLE
The most common estimator is the MLE. When the sample size becomes large, the sampling
distribution of the MLE for certain models becomes Gaussian. This is known as the asymptotic
normality of the sampling distribution. More formally, we have the following result:
Theorem 4.7.1. If the parameters are identifiable, then
p(π(D˜ ) = θˆ|D ∼˜ θ
∗
) → N (θˆ|θ
∗
,(NF(θ
∗
))−1
) (4.219)
where F(θ
∗
) is the Fisher information matrix, defined in Equation (4.220).
The Fisher information matrix measures the amount of curvature of the log-likelihood surface at
its peak, as we show below.
More formally, the Fisher information matrix (FIM) is defined to be the covariance of the
gradient of the log likelihood (also called the score function):
F , Ex∼p(x|θ)

∇ log p(x|θ)∇ log p(x|θ)
T

(4.220)
Hence the (i, j)’th entry has the form
Fij = Ex∼θ
 ∂
∂θi
log p(x|θ)
  ∂
∂θj
log p(x|θ)
 (4.221)
One can show the following result.
Theorem 4.7.2. If log p(x|θ) is twice differentiable, and under certain regularity conditions, the
FIM is equal to the expected Hessian of the NLL, i.e.,
Fij = −Ex∼θ

∂
2
∂θiθj
log p(x|θ)

(4.222)
Thus we can interpret the FIM as the Hessian of the NLL.
This helps us understand the result in Equation (4.219): a log-likelihood function with high
curvature (large Hessian) will result in a low variance estimate, since the parameters are “well
determined” by the data, and hence robust to repeated sampling.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license152 Chapter 4. Statistics
0 0.2 0.4 0.6 0.8 1
0
500
1000
1500
2000
2500
3000
3500
4000
Boot: true = 0.70, n=10, mle = 0.90, se = 0.001
(a)
0 0.2 0.4 0.6 0.8 1
0
500
1000
1500
2000
2500
3000
3500
Boot: true = 0.70, n=100, mle = 0.70, se = 0.000
(b)
0 0.2 0.4 0.6 0.8 1
0
500
1000
1500
2000
2500
3000
Bayes: true = 0.70, n=10, post mean = 0.83, se = 0.001
(c)
0 0.2 0.4 0.6 0.8 1
0
500
1000
1500
2000
2500
3000
Bayes: true = 0.70, n=100, post mean = 0.70, se = 0.000
(d)
Figure 4.23: Bootstrap (top row) vs Bayes (bottom row). The N data cases were generated from Ber(θ = 0.7).
Left column: N = 10. Right column: N = 100. (a-b) A bootstrap approximation to the sampling distribution
of the MLE for a Bernoulli distribution. We show the histogram derived from B = 10, 000 bootstrap samples.
(c-d) Histogram of 10,000 samples from the posterior distribution using a uniform prior. Generated by code
at figures.probml.ai/book1/4.23.
4.7.3 Bootstrap approximation of the sampling distribution of any estimator
In cases where the estimator is a complex function of the data (e.g., not just an MLE), or when the
sample size is small, we can approximate its sampling distribution using a Monte Carlo technique
known as the bootstrap.
The idea is simple. If we knew the true parameters θ
∗
, we could generate many (say S) fake
datasets, each of size N, from the true distribution, using D˜ (s) = {xn ∼ p(xn|θ
∗
) : n = 1 : N}. We
could then compute our estimator from each sample, θˆs = π(D˜ (s)
) and use the empirical distribution
of the resulting θˆs as our estimate of the sampling distribution, as in Equation (4.218). Since θ
∗
is
unknown, the idea of the parametric bootstrap is to generate each sampled dataset using θˆ = π(D)
instead of θ
∗
, i.e., we use D˜ (s) = {xn ∼ p(xn|θˆ) : n = 1 : N} in Equation (4.218). This is a plug-in
approximation to the sampling distribution.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.7. Frequentist statistics * 153
An alternative, called the non-parametric bootstrap, is to sample N data points from the
original data with replacement. This creates a new distribution D(s) which has the same size as the
original. However, the number of unique data points in a bootstrap sample is just 0.632 × N, on
average. (To see this, note that the probability an item is picked at least once is (1 − (1 − 1/N)
N ),
which approaches 1 − e
−1 ≈ 0.632 for large N.)
Figure 4.23(a-b) shows an example where we compute the sampling distribution of the MLE for a
Bernoulli using the parametric bootstrap. (Results using the non-parametric bootstrap are essentially
the same.) When N = 10, we see that the sampling distribution is asymmetric, and therefore quite
far from Gaussian, but when N = 100, the distribution looks more Gaussian, as theory suggests (see
Section 4.7.2).
4.7.3.1 Bootstrap is a “poor man’s” posterior
A natural question is: what is the connection between the parameter estimates θˆs = π(D(s)
) computed
by the bootstrap and parameter values sampled from the posterior, θ
s ∼ p(·|D)? Conceptually they
are quite different. But in the common case that the estimator is MLE and the prior is not very
strong, they can be quite similar. For example, Figure 4.23(c-d) shows an example where we compute
the posterior using a uniform Beta(1,1) prior, and then sample from it. We see that the posterior
and the sampling distribution are quite similar. So one can think of the bootstrap distribution as a
“poor man’s” posterior [HTF01, p235].
However, perhaps surprisingly, bootstrap can be slower than posterior sampling. The reason is that
the bootstrap has to generate S sampled datasets, and then fit a model to each one. By contrast, in
posterior sampling, we only have to “fit” a model once given a single dataset. (Some methods for
speeding up the bootstrap when applied to massive data sets are discussed in [Kle+11].)
4.7.4 Confidence intervals
In frequentist statistics, we use the variability induced by the sampling distribution as a way to
estimate uncertainty of a parameter estimate. More precisely, we define a 100(1 − α)% confidence
interval for a parameter estimate θ as any interval I(D˜ ) = (`(D˜ ), u(D˜ )) derived from a hypothetical
dataset D˜ such that
Pr(θ ∈ I(D˜ )|D ∼˜ θ) = 1 − α (4.223)
It is common to set α = 0.05, which yields a 95% CI. This means that, if we repeatedly sampled
data, and compute I(D˜ ) for each such dataset, then about 95% of such intervals will contain the true
parameter θ.
Note, however, that Equation (4.223) does not mean that for any particular dataset that θ ∈ I(D)
with 95% probability; this is what a Bayesian credible interval computes (Section 4.6.6), but is not
what a frequentist confidence interval computes. For more details on this important distinction, see
Section 4.7.5.
Let us put aside such “philosophical” concerns, and discuss how to compute a confidence interval.
Suppose that ˆθ is an estimate of the parameter θ. Let θ
∗ be its true but unknown value. Also,
suppose that the sampling distribution of ∆ = ˆθ − θ
∗
is known. Let δ and δ denote its α/2 and
1 − α/2 quantiles. Hence
Pr(δ ≤ ˆθ − θ
∗ ≤ δ) = 1 − α (4.224)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license154 Chapter 4. Statistics
Rearranging we get
Pr(ˆθ − δ ≤ θ
∗ ≤ ˆθ − δ) = 1 − α (4.225)
And hence
I(D˜ ) = (ˆθ(D˜ ) − δ(D˜ ),
ˆθ(D˜ ) + δ(D˜ )) (4.226)
is a 100(1 − α)% confidence interval.
In some cases, we can analytically compute the distribution of ∆ = ˆθ − θ
∗
. This can be used to
derive exact confidence intervals. However, it is more common to assume a Gaussian approximation
to the sampling distribution, as in Section 4.7.2. In this case, we have q
NF(
ˆθ)(
ˆθ − θ
∗
) ∼ N (0, 1).
Hence we can compute an approximate CI using
ˆθ ± zα/2 ˆse (4.227)
where zα/2 is the α/2 quantile of the Gaussian cdf, and ˆse = 1/
q
NF(
ˆθ) is the estimated standard
error. If we set α = 0.05, we have zα/2 = 1.96, which justifies the common approximation ˆθ ± 2 ˆse.
If the Gaussian approximation is not a good one, we can use a bootstrap approximation (see
Section 4.7.3). In particular, we sample S datasets from ˆθ(D), and apply the estimator to each one
to get ˆθ(D(s)
); we then use the empirical distribution of ˆθ(D) − ˆθ(D(s)
) as an approximation to the
sampling distribution of ∆.
4.7.5 Caution: Confidence intervals are not credible
A 95% frequentist confidence interval for a parameter θ is defined as any interval I(D˜ ) such that
Pr(θ ∈ I(D˜ )|D ∼˜ θ) = 0.95, as we explain in Section 4.7.4. This does not mean that the parameter is
95% likely to live inside this interval given the observed data. That quantity — which is usually
what we want to compute — is instead given by the Bayesian credible interval p(θ ∈ I|D), as we
explain in Section 4.6.6. These concepts are quite different: In the frequentist approach, θ is treated
as an unknown fixed constant, and the data is treated as random. In the Bayesian approach, we
treat the data as fixed (since it is known) and the parameter as random (since it is unknown).
This counter-intuitive definition of confidence intervals can lead to bizarre results. Consider the
following example from [Ber85, p11]. Suppose we draw two integers D = (y1, y2) from
p(y|θ) =



0.5 if y = θ
0.5 if y = θ + 1
0 otherwise
(4.228)
If θ = 39, we would expect the following outcomes each with probability 0.25:
(39, 39),(39, 40),(40, 39),(40, 40) (4.229)
Let m = min(y1, y2) and define the following interval:
[`(D), u(D)] = [m, m] (4.230)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.7. Frequentist statistics * 155
For the above samples this yields
[39, 39], [39, 39], [39, 39], [40, 40] (4.231)
Hence Equation (4.230) is clearly a 75% CI, since 39 is contained in 3/4 of these intervals. However,
if we observe D = (39, 40) then p(θ = 39|D) = 1.0, so we know that θ must be 39, yet we only have
75% “confidence” in this fact. We see that the CI will “cover” the true parameter 75% of the time,
if we compute multiple CIs from different randomly sampled datasets, but if we just have a single
observed dataset, and hence a single CI, then the frequentist “coverage” probability can be very
misleading.
Another, less contrived, example is as follows. Suppose we want to estimate the parameter θ
of a Bernoulli distribution. Let y =
1
N
PN
n=1 yn be the sample mean. The MLE is ˆθ = y. An
approximate 95% confidence interval for a Bernoulli parameter is y ± 1.96p
y(1 − y)/N (this is called
a Wald interval and is based on a Gaussian approximation to the Binomial distribution; compare
to Equation (4.128)). Now consider a single trial, where N = 1 and y1 = 0. The MLE is 0, which
overfits, as we saw in Section 4.5.1. But our 95% confidence interval is also (0, 0), which seems even
worse. It can be argued that the above flaw is because we approximated the true sampling distribution
with a Gaussian, or because the sample size was too small, or the parameter “too extreme”. However,
the Wald interval can behave badly even for large N, and non-extreme parameters [BCD01]. By
contrast, a Bayesian credible interval with a non-informative Jeffreys prior behaves in the way we
would expect.
Several more interesting examples, along with Python code, can be found at [Van14]. See
also [Hoe+14; Mor+16; Lyu+20; Cha+19b], who show that many people, including professional
statisticians, misunderstand and misuse frequentist confidence intervals in practice, whereas Bayesian
credible intervals do not suffer from these problems.
4.7.6 The bias-variance tradeoff
An estimator is a procedure applied to data which returns an estimand. Let θˆ() be the estimator, and
θˆ(D) be the estimand. In frequentist statistics, we treat the data as a random variable, drawn from
some true but unknown distribution, p
∗
(D); this induces a distribution over the estimand, p
∗
(θˆ(D)),
known as the sampling distribution (see Section 4.7.1). In this section, we discuss two key properties
of this distribution, its bias and its variance, which we define below.
4.7.6.1 Bias of an estimator
The bias of an estimator is defined as
bias(
ˆθ(·)) , E
h
ˆθ(D)
i
− θ
∗
(4.232)
where θ
∗
is the true parameter value, and the expectation is wrt “nature’s distribution” p(D|θ
∗
). If
the bias is zero, the estimator is called unbiased. For example, the MLE for a Gaussian mean is
unbiased:
bias(ˆµ) = E [x] − µ = E
"
1
N
X
N
n=1
xn
#
− µ =
Nµ
N
− µ = 0 (4.233)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license156 Chapter 4. Statistics
where x is the sample mean.
However, the MLE for a Gaussian variance, σ
2
mle =
1
N
PN
n=1(xn −x)
2
, is not an unbiased estimator
of σ
2
. In fact, one can show (Exercise 4.7) that
E

σ
2
mle
=
N − 1
N
σ
2
(4.234)
so the ML estimator slightly underestimates the variance. Intuitively, this is because we “use up”
one of the data points to estimate the mean, so if we have a sample size of 1, we will estimate the
variance to be 0. If, however, µ is known, the ML estimator is unbiased (see Exercise 4.8).
Now consider the following estimator
σ
2
unb ,
1
N − 1
X
N
n=1
(xn − x)
2 =
N
N − 1
σ
2
mle (4.235)
This is an unbiased estimator, which we can easily prove as follows:
E

σ
2
unb
=
N
N − 1
E

σ
2
mle
=
N
N − 1
N − 1
N
σ
2 = σ
2
(4.236)
4.7.6.2 Variance of an estimator
It seems intuitively reasonable that we want our estimator to be unbiased. However, being unbiased is
not enough. For example, suppose we want to estimate the mean of a Gaussian from D = {x1, . . . , xN }.
The estimator that just looks at the first data point, ˆθ(D) = x1, is an unbiased estimator, but will
generally be further from θ
∗
than the empirical mean x (which is also unbiased). So the variance of
an estimator is also important.
We define the variance of an estimator as follows:
V
h
ˆθ
i
, E
h
ˆθ
2
i
−

E
h
ˆθ
i2
(4.237)
where the expectation is taken wrt p(D|θ
∗
). This measures how much our estimate will change as
the data changes. We can extend this to a covariance matrix for vector valued estimators.
4.7.6.3 The bias-variance tradeoff
In this section, we discuss a fundamental tradeoff that needs to be made when picking a method
for parameter estimation, assuming our goal is to minimize the mean squared error (MSE) of our
estimate. Let ˆθ = ˆθ(D) denote the estimate, and θ = E
h
ˆθ
i
denote the expected value of the estimate
(as we vary D). (All expectations and variances are wrt p(D|θ
∗
), but we drop the explicit conditioning
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.7. Frequentist statistics * 157
-1 -0.5 0 0.5 1 1.5 2 2.5
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8 sampling distribution, truth = 1.0, prior = 0.0, n = 5
postMean0
postMean1
postMean2
postMean3
(a)
sample size
5 10 15 20 25 30 35 40 45
relative MSE
0.5
0.6
0.7
0.8
0.9
1
1.1
MSE of postmean / MSE of MLE
postMean0
postMean1
postMean2
postMean3
(b)
Figure 4.24: Left: Sampling distribution of the MAP estimate (equivalent to the posterior mean) under a
N (θ0 = 0, σ2
/κ0) prior with different prior strengths κ0. (If we set κ = 0, the MAP estimate reduces to the
MLE.) The data is n = 5 samples drawn from N (θ
∗ = 1, σ2 = 1). Right: MSE relative to that of the MLE
versus sample size. Adapted from Figure 5.6 of [Hof09]. Generated by code at figures.probml.ai/book1/4.24.
for notational brevity.) Then we have
E
h
(
ˆθ − θ
∗
)
2
i
= E
h
(
ˆθ − θ) + (θ − θ
∗
)
i2

(4.238)
= E

ˆθ − θ
2

+ 2(θ − θ
∗
)E
h
ˆθ − θ
i
+ (θ − θ
∗
)
2
(4.239)
= E

ˆθ − θ
2

+ (θ − θ
∗
)
2
(4.240)
= V
h
ˆθ
i
+ bias2
(
ˆθ) (4.241)
In words,
MSE = variance + bias2
(4.242)
This is called the bias-variance tradeoff (see e.g., [GBD92]). What it means is that it might be
wise to use a biased estimator, so long as it reduces our variance by more than the square of the bias,
assuming our goal is to minimize squared error.
4.7.6.4 Example: MAP estimator for a Gaussian mean
Let us give an example, based on [Hof09, p79]. Suppose we want to estimate the mean of a Gaussian
from x = (x1, . . . , xN ). We assume the data is sampled from xn ∼ N (θ
∗ = 1, σ2
). An obvious
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license158 Chapter 4. Statistics
estimate is the MLE. This has a bias of 0 and a variance of
V [x|θ
∗
] = σ
2
N
(4.243)
But we could also use a MAP estimate. In Section 4.6.4.2, we show that the MAP estimate under a
Gaussian prior of the form N (θ0, σ2/κ0) is given by
x˜ ,
N
N + κ0
x +
κ0
N + κ0
θ0 = wx + (1 − w)θ0 (4.244)
where 0 ≤ w ≤ 1 controls how much we trust the MLE compared to our prior. The bias and variance
are given by
E [˜x] − θ
∗ = wθ∗ + (1 − w)θ0 − θ
∗ = (1 − w)(θ0 − θ
∗
) (4.245)
V [˜x] = w
2 σ
2
N
(4.246)
So although the MAP estimate is biased (assuming w < 1), it has lower variance.
Let us assume that our prior is slightly misspecified, so we use θ0 = 0, whereas the truth is θ
∗ = 1.
In Figure 4.24(a), we see that the sampling distribution of the MAP estimate for κ0 > 0 is biased
away from the truth, but has lower variance (is narrower) than that of the MLE.
In Figure 4.24(b), we plot mse(x˜)/mse(x) vs N. We see that the MAP estimate has lower MSE
than the MLE for κ0 ∈ {1, 2}. The case κ0 = 0 corresponds to the MLE, and the case κ0 = 3
corresponds to a strong prior, which hurts performance because the prior mean is wrong. Thus we
see that, provided the prior strength is properly “tuned”, a MAP estimate can outperform an ML
estimate in terms of minimizing MSE.
4.7.6.5 Example: MAP estimator for linear regression
Another important example of the bias-variance tradeoff arises in ridge regression, which we discuss
in Section 11.3. In brief, this corresponds to MAP estimation for linear regression under a Gaussian
prior, p(w) = N (w|0, λ−1
I) The zero-mean prior encourages the weights to be small, which reduces
overfitting; the precision term, λ, controls the strength of this prior. Setting λ = 0 results in the
MLE; using λ > 0 results in a biased estimate. To illustrate the effect on the variance, consider a
simple example where we fit a 1d ridge regression model using 2 different values of λ. Figure 4.25 on
the left plots each individual fitted curve, and on the right plots the average fitted curve. We see
that as we increase the strength of the regularizer, the variance decreases, but the bias increases.
See also Figure 4.26 where we give a cartoon sketch of the bias variance tradeoff in terms of model
complexity.
4.7.6.6 Bias-variance tradeoff for classification
If we use 0-1 loss instead of squared error, the frequentist risk is no longer expressible as squared bias
plus variance. In fact, one can show (Exercise 7.2 of [HTF09]) that the bias and variance combine
multiplicatively. If the estimate is on the correct side of the decision boundary, then the bias is
negative, and decreasing the variance will decrease the misclassification rate. But if the estimate
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.7. Frequentist statistics * 159
0 0.2 0.4 0.6 0.8 1
−1.5
−1
−0.5
0
0.5
1
1.5
ln(λ) = 5
0 0.2 0.4 0.6 0.8 1
−1
−0.5
0
0.5
1
ln(λ) = 5
0 0.2 0.4 0.6 0.8 1
−1.5
−1
−0.5
0
0.5
1
1.5
ln(λ) = −5
0 0.2 0.4 0.6 0.8 1
−1
−0.5
0
0.5
1
ln(λ) = −5
Figure 4.25: Illustration of bias-variance tradeoff for ridge regression. We generate 100 data sets from the
true function, shown in solid green. Left: we plot the regularized fit for 20 different data sets. We use linear
regression with a Gaussian RBF expansion, with 25 centers evenly spread over the [0, 1] interval. Right: we
plot the average of the fits, averaged over all 100 datasets. Top row: strongly regularized: we see that the
individual fits are similar to each other (low variance), but the average is far from the truth (high bias).
Bottom row: lightly regularized: we see that the individual fits are quite different from each other (high
variance), but the average is close to the truth (low bias). Adapted from [Bis06] Figure 3.5. Generated by
code at figures.probml.ai/book1/4.25.
Figure 4.26: Cartoon illustration of the bias variance tradeoff. From http: // scott. fortmann-roe. com/
docs/ BiasVariance. html . Used with kind permission of Scott Fortmann-Roe.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license160 Chapter 4. Statistics
is on the wrong side of the decision boundary, then the bias is positive, so it pays to increase the
variance [Fri97a]. This little known fact illustrates that the bias-variance tradeoff is not very useful
for classification. It is better to focus on expected loss, not directly on bias and variance. We can
approximate the expected loss using cross validation, as we discuss in Section 4.5.5.
4.8 Exercises
Exercise 4.1 [MLE for the univariate Gaussian *]
Show that the MLE for a univariate Gaussian is given by
µˆ =
1
N
XN
n=1
yn (4.247)
σˆ
2 =
1
N
XN
n=1
(yn − µˆ)
2
(4.248)
Exercise 4.2 [MAP estimation for 1D Gaussians *]
(Source: Jaakkola.)
Consider samples x1, . . . , xn from a Gaussian random variable with known variance σ
2
and unknown mean µ.
We further assume a prior distribution (also Gaussian) over the mean, µ ∼ N (m, s2
), with fixed mean m and
fixed variance s
2
. Thus the only unknown is µ.
a. Calculate the MAP estimate µˆMAP . You can state the result without proof. Alternatively, with a lot
more work, you can compute derivatives of the log posterior, set to zero and solve.
b. Show that as the number of samples n increase, the MAP estimate converges to the maximum likelihood
estimate.
c. Suppose n is small and fixed. What does the MAP estimator converge to if we increase the prior variance
s
2
?
d. Suppose n is small and fixed. What does the MAP estimator converge to if we decrease the prior variance
s
2
?
Exercise 4.3 [Gaussian posterior credible interval]
(Source: DeGroot.) Let X ∼ N (µ, σ2 = 4) where µ is unknown but has prior µ ∼ N (µ0, σ2
0 = 9). The
posterior after seeing n samples is µ ∼ N (µn, σ2
n). (This is called a credible interval, and is the Bayesian
analog of a confidence interval.) How big does n have to be to ensure
p(` ≤ µn ≤ u|D) ≥ 0.95 (4.249)
where (`, u) is an interval (centered on µn) of width 1 and D is the data? Hint: recall that 95% of the
probability mass of a Gaussian is within ±1.96σ of the mean.
Exercise 4.4 [BIC for Gaussians *]
(Source: Jaakkola.)
The Bayesian information criterion (BIC) is a penalized log-likelihood function that can be used for model
selection. It is defined as
BIC = log p(D|θˆML) −
d
2
log(N) (4.250)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20224.8. Exercises 161
where d is the number of free parameters in the model and N is the number of samples. In this question,
we will see how to use this to choose between a full covariance Gaussian and a Gaussian with a diagonal
covariance. Obviously a full covariance Gaussian has higher likelihood, but it may not be “worth” the extra
parameters if the improvement over a diagonal covariance matrix is too small. So we use the BIC score to
choose the model.
We can write
log p(D|Σˆ , µˆ) = −
N
2
tr 
Σˆ −1Sˆ

−
N
2
log( ˆ|Σ|) (4.251)
Sˆ =
1
N
XN
i=1
(xi − x)(xi − x)
T
(4.252)
where Sˆ is the scatter matrix (empirical covariance), the trace of a matrix is the sum of its diagonals, and we
have used the trace trick.
a. Derive the BIC score for a Gaussian in D dimensions with full covariance matrix. Simplify your answer as
much as possible, exploiting the form of the MLE. Be sure to specify the number of free parameters d.
b. Derive the BIC score for a Gaussian in D dimensions with a diagonal covariance matrix. Be sure to specify
the number of free parameters d. Hint: for the digaonal case, the ML estimate of Σ is the same as Σˆ ML
except the off-diagonal terms are zero:
Σˆ diag = diag(Σˆ ML(1, 1), . . . , Σˆ ML(D, D)) (4.253)
Exercise 4.5 [BIC for a 2d discrete distribution]
(Source: Jaakkola.)
Let x ∈ {0, 1} denote the result of a coin toss (x = 0 for tails, x = 1 for heads). The coin is potentially biased,
so that heads occurs with probability θ1. Suppose that someone else observes the coin flip and reports to you
the outcome, y. But this person is unreliable and only reports the result correctly with probability θ2; i.e.,
p(y|x, θ2) is given by
y = 0 y = 1
x = 0 θ2 1 − θ2
x = 1 1 − θ2 θ2
Assume that θ2 is independent of x and θ1.
a. Write down the joint probability distribution p(x, y|θ) as a 2 × 2 table, in terms of θ = (θ1, θ2).
b. Suppose have the following dataset: x = (1, 1, 0, 1, 1, 0, 0), y = (1, 0, 0, 0, 1, 0, 1). What are the MLEs for
θ1 and θ2? Justify your answer. Hint: note that the likelihood function factorizes,
p(x, y|θ) = p(y|x, θ2)p(x|θ1) (4.254)
What is p(D|θˆ, M2) where M2 denotes this 2-parameter model? (You may leave your answer in fractional
form if you wish.)
c. Now consider a model with 4 parameters, θ = (θ0,0, θ0,1, θ1,0, θ1,1), representing p(x, y|θ) = θx,y. (Only
3 of these parameters are free to vary, since they must sum to one.) What is the MLE of θ? What is
p(D|θˆ, M4) where M4 denotes this 4-parameter model?
d. Suppose we are not sure which model is correct. We compute the leave-one-out cross validated log
likelihood of the 2-parameter model and the 4-parameter model as follows:
L(m) = Xn
i=1
log p(xi, yi|m, ˆθ(D−i)) (4.255)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license162 Chapter 4. Statistics
and ˆθ(D−i)) denotes the MLE computed on D excluding row i. Which model will CV pick and why?
Hint: notice how the table of counts changes when you omit each training case one at a time.
e. Recall that an alternative to CV is to use the BIC score, defined as
BIC(M, D) , log p(D|θˆMLE) −
dof(M)
2
log N (4.256)
where dof(M) is the number of free parameters in the model, Compute the BIC scores for both models
(use log base e). Which model does BIC prefer?
Exercise 4.6 [A mixture of conjugate priors is conjugate *]
Consider a mixture prior
p(θ) = X
k
p(h = k)p(θ|z = k) (4.257)
where each p(θ|z = k) is conjugate to the likelihood. Prove that this is a conjugate prior.
Exercise 4.7 [ML estimator σ
2
mle is biased]
Show that σˆ
2
MLE =
1
N
PN
n=1(xn − µˆ)
2
is a biased estimator of σ
2
, i.e., show
EX1,...,Xn∼N(µ,σ)[ˆσ
2
(X1, . . . , Xn)] 6= σ
2
Hint: note that X1, . . . , XN are independent, and use the fact that the expectation of a product of independent
random variables is the product of the expectations.
Exercise 4.8 [Estimation of σ
2 when µ is known *]
Suppose we sample x1, . . . , xN ∼ N (µ, σ2
) where µ is a known constant. Derive an expression for the MLE
for σ
2
in this case. Is it unbiased?
Exercise 4.9 [Variance and MSE of estimators for Gaussian variance *]
Prove that the standard error for the MLE for a Gaussian variance is
q
V [σ
2
mle] = r
2(N − 1)
N2
σ
2
(4.258)
Hint: use the fact that
N − 1
σ2
σ
2
unb ∼ χ
2
N−1, (4.259)
and that V

χ
2
N−1

= 2(N − 1). Finally, show that MSE(σ
2
unb) = 2N−1
N2 σ
4
and MSE(σ
2
mle) = 2
N−1
σ
4
.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225 Decision Theory
5.1 Bayesian decision theory
Bayesian inference provides the optimal way to update our beliefs about hidden quantities H given
observed data X = x by computing the posterior p(H|x). However, at the end of the day, we
need to turn our beliefs into actions that we can perform in the world. How can we decide which
action is best? This is where Bayesian decision theory comes in. In this chapter, we give a brief
introduction. For more details, see e.g., [DeG70; KWW22].
5.1.1 Basics
In decision theory, we assume the decision maker, or agent, has a set of possible actions, A, to
choose from. For example, consider the case of a hypothetical doctor treating someone who may
have COVID-19. Suppose the actions are to do nothing, or to give the patient an expensive drug
with bad side effects, but which can save their life.
Each of these actions has costs and benefits, which will depend on the underlying state of nature
H ∈ H. We can encode this information into a loss function `(h, a), that specifies the loss we incur
if we take action a ∈ A when the state of nature is h ∈ H.
For example, suppose the state is defined by the age of the patient (young vs old), and whether
they have COVID-19 or not. Note that the age can be observed directly, but the disease state must
be inferred from noisy observations, as we discussed in Section 2.3. Thus the state is partially
observed.
Let us assume that the cost of administering a drug is the same, no matter what the state of the
patient is. However, the benefits will differ. If the patient is young, we expect them to live a long
time, so the cost of not giving the drug if they have COVID-19 is high; but if the patient is old, they
have fewer years to live, so the cost of not giving the drug if they have COVID-19 is arguably less
(especially in view of the side effects). In medical circles, a common unit of cost is quality-adjusted
life years or QALY. Suppose that the expected QALY for a young person is 60, and for an old
person is 10. Let us assume the drug costs the equivalent of 8 QALY, due to induced pain and
suffering from side effects. Then we get the loss matrix shown in Table 5.1.
These numbers reflect relative costs and benefits, and will depend on many factors. The numbers
can be derived by asking the decision maker about their preferences about different possible
outcomes. It is a theorem of decision theory that any consistent set of preferences can be converted
into an ordinal cost scale (see e.g., https://en.wikipedia.org/wiki/Preference_(economics)).
Once we have specified the loss function, we can compute the posterior expected loss or risk164 Chapter 5. Decision Theory
State Nothing Drugs
No COVID-19, young 0 8
COVID-19, young 60 8
No COVID-19, old 0 8
COVID-19, old 10 8
Table 5.1: Hypothetical loss matrix for a decision maker, where there are 4 states of nature, and 2 possible
actions.
test age pr(covid) cost-noop cost-drugs action
0 0 0.01 0.84 8.00 0
0 1 0.01 0.14 8.00 0
1 0 0.80 47.73 8.00 1
1 1 0.80 7.95 8.00 0
Table 5.2: Optimal policy for treating COVID-19 patients for each possible observation.
for each possible action:
R(a|x) , Ep(h|x)
[`(h, a)] = X
h∈H
`(h, a)p(h|x) (5.1)
The optimal policy (also called the Bayes estimator) specifies what action to take for each
possible observation so as to minimize the risk:
π
∗
(x) = argmin
a∈A
Ep(h|x)
[`(h, a)] (5.2)
An alternative, but equivalent, way of stating this result is as follows. Let us define a utility
function U(h, a) to be the desirability of each possible action in each possible state. If we set
U(h, a) = −`(h, a), then the optimal policy is as follows:
π
∗
(x) = argmax
a∈A
Eh [U(h, a)] (5.3)
This is called the maximum expected utility principle.
Let us return to our COVID-19 example. The observation x consists of the age (young or old)
and the test result (positive or negative). Using the results from Section 2.3.1 on Bayes rule for
COVID-19 diagnosis, we can convert the test result into a distribution over disease states (i.e.,
compute the probability the patient has COVID-19 or not). Given this belief state, and the loss
matrix in Table 5.1, we can compute the optimal policy for each possible observation, as shown in
Table 5.2.
We see from Table 5.2 that the drug should only be given to young people who test positive. If,
however, we reduce the cost of the drug from 8 units to 5, then the optimal policy changes: in this
case, we should give the drug to everyone who tests positive. The policy can also change depending
on the reliability of the test. For example, if we increase the sensitivity from 0.875 to 0.975, then
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.1. Bayesian decision theory 165
the probability that someone has COVID-19 if they test positive increases from 0.80 to 0.81, which
changes the optimal policy to be one in which we should administer the drug to everyone who tests
positive, even if the drug costs 8 QALY. (See code.probml.ai/book1/dtheory for the code to reproduce
this example.)
So far, we have implicitly assumed that the agent is risk neutral. This means that their decision
is not affected by the degree of certainty in a set of outcomes. For example, such an agent would be
indifferent between getting $50 for sure, of a 50% chance of $100 or $0. By contrast, a risk averse
agent would choose the first. We can generalize the framework of Bayesian decision theory to risk
sensitive applications, but we do not pursue the matter here. (See e.g., [Cho+15] for details.)
5.1.2 Classification problems
In this section, we use Bayesian decision theory to decide the optimal class label to predict given an
observed input x ∈ X .
5.1.2.1 Zero-one loss
Suppose the states of nature correspond to class labels, so H = Y = {1, . . . , C}. Furthermore,
suppose the actions also correspond to class labels, so A = Y. In this setting, a very commonly used
loss function is the zero-one loss `01(y
∗
, yˆ), defined as follows:
yˆ = 0 ˆy = 1
y
∗ = 0 0 1
y
∗ = 1 1 0
(5.4)
We can write this more concisely as follows:
`01(y
∗
, yˆ) = I(y
∗
6= ˆy) (5.5)
In this case, the posterior expected loss is
R(ˆy|x) = p(ˆy 6= y
∗
|x) = 1 − p(y
∗ = ˆy|x) (5.6)
Hence the action that minimizes the expected loss is to choose the most probable label:
π(x) = argmax
y∈Y
p(y|x) (5.7)
This corresponds to the mode of the posterior distribution, also known as the maximum a
posteriori or MAP estimate
5.1.2.2 Cost-sensitive classification
Consider a binary classification problem where the loss function is `(y
∗
, yˆ) is as follows:

`00 `01
`10 `11 
(5.8)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license166 Chapter 5. Decision Theory
Let p0 = p(y
∗ = 0|x) and p1 = 1 − p0. Thus we should choose label yˆ = 0 iff
`00p0 + `10p1 < `01p0 + `11p1 (5.9)
If `00 = `11 = 0, this simplifies to
p1 <
`01
`01 + `10
(5.10)
Now suppose `10 = c`01, so a false negative costs c times more than a false positive. The decision rule
further simplifies to the following: pick a = 0 iff p1 < 1/(1 + c). For example, if a false negative costs
twice as much as false positive, so c = 2, then we use a decision threshold of 1/3 before declaring a
positive.
5.1.2.3 Classification with the “reject” option
In some cases, we may able to say “I don’t know” instead of returning an answer that we don’t really
trust; this is called picking the reject option (see e.g., [BW08]). This is particularly important in
domains such as medicine and finance where we may be risk averse.
We can formalize the reject option as follows. Suppose the states of nature are H = Y = {1, . . . , C},
and the actions are A = Y ∪ {0}, where action 0 represents the reject action. Now define the following
loss function:
`(y
∗
, a) =



0 if y
∗ = a and a ∈ {1, . . . , C}
λr if a = 0
λe otherwise
(5.11)
where λr is the cost of the reject action, and λe is the cost of a classification error. Exercise 5.1
asks you to show that the optimal action is to pick the reject action if the most probable class has
a probability below λ
∗ = 1 −
λr
λe
; otherwise you should just pick the most probable class. In other
words, the optimal policy is as follows:
a
∗ =
(
y
∗
if p
∗ > λ∗
reject otherwise
(5.12)
where
y
∗ = argmax
y∈{1,...,C}
p(y|x) (5.13)
p
∗ = p(y
∗
|x) = max
y∈{1,...,C}
p(y|x) (5.14)
λ
∗ = 1 −
λr
λe
(5.15)
See Figure 5.1 for an illustration.
One interesting application of the reject option arises when playing the TV game show Jeopardy. In
this game, contestants have to solve various word puzzles and answer a variety of trivia questions, but
if they answer incorrectly, they lose money. In 2011, IBM unveiled a computer system called Watson
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.1. Bayesian decision theory 167
1.0
threshold
Reject 
Region
P(y = 1 | X)
P(y = 2 | X)
0.0
X
Figure 5.1: For some regions of input space, where the class posteriors are uncertain, we may prefer not to
choose class 1 or 2; instead we may prefer the reject option. Adapted from Figure 1.26 of [Bis06].
Estimate Row sum
0 1
Truth 0 TN FP N
1 FN TP P
Col. sum Nˆ Pˆ
Table 5.3: Class confusion matrix for a binary classification problem. TP is the number of true positives, FP
is the number of false positives, TN is the number of true negatives, FN is the number of false negatives, P is
the true number of positives, Pˆ is the predicted number of positives, N is the true number of negatives, Nˆ is
the predicted number of negatives.
which beat the top human Jeopardy champion. Watson uses a variety of interesting techniques
[Fer+10], but the most pertinent one for our present discussion is that it contains a module that
estimates how confident it is of its answer. The system only chooses to “buzz in” its answer if
sufficiently confident it is correct.
For some other methods and applications, see e.g., [Cor+16; GEY19].
5.1.3 ROC curves
In Section 5.1.2.2, we showed that we can pick the optimal label in a binary classification problem
by thresholding the probability using a value τ , derived from the relative cost of a false positive
and false negative. Instead of picking a single threshold, we can consider using a set of different
thresholds, and comparing the resulting performance, as we discuss below.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license168 Chapter 5. Decision Theory
Estimate
0 1
Truth 0 TN/N=TNR=Spec FP/N =FPR=Type I = Fallout
1 FN/P=FNR=Miss=Type II TP/P=TPR=Sens=Recall
Table 5.4: Class confusion matrix for a binary classification problem normalized per row to get p(yˆ|y).
Abbreviations: TNR = true negative rate, Spec = specificity, FPR = false positive rate, FNR = false negative
rate, Miss = miss rate, TPR = true positive rate, Sens = sensitivity. Note FNR=1-TPR and FPR=1-TNR.
Estimate
0 1
Truth 0 TN/Nˆ=NPV FP/Pˆ=FDR
1 FN/Nˆ=FOR TP/Pˆ=Prec=PPV
Table 5.5: Class confusion matrix for a binary classification problem normalized per column to get p(y|yˆ).
Abbreviations: NPV = negative predictive value, FDR = false discovery rate, FOR = false omission rate,
PPV = positive predictive value, Prec = precision. Note that FOR=1-NPV and FDR=1-PPV.
5.1.3.1 Class confusion matrices
For any fixed threshold τ , we consider the following decision rule:
yˆτ (x) = I(p(y = 1|x) ≥ 1 − τ ) (5.16)
We can compute the empirical number of false positives (FP) that arise from using this policy on a
set of N labeled examples as follows:
F Pτ =
X
N
n=1
I(ˆyτ (xn) = 1, yn = 0) (5.17)
Similarly, we can compute the empirical number of false negatives (FN), true positives (TP), and
true negatives (TN). We can store these results in a 2 × 2 class confusion matrix C, where Cij is
the number of times an item with true class label i was (mis)classified as having label j. In the case
of binary classification problems, the resulting matrix will look like Table 5.3.
From this table, we can compute p(yˆ|y) or p(y|yˆ), depending on whether we normalize across the
rows or columns. We can derive various summary statistics from these distributions, as summarized in
Table 5.4 and Table 5.5. For example, the true positive rate (TPR), also known as the sensitivity,
recall or hit rate, is defined as
T P Rτ = p(ˆy = 1|y = 1, τ ) = T Pτ
T Pτ + F Nτ
(5.18)
and the false positive rate (FPR), also called the false alarm rate, or the type I error rate, is
defined as
F P Rτ = p(ˆy = 1|y = 0, τ ) = F Pτ
F Pτ + T Nτ
(5.19)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.1. Bayesian decision theory 169
0.0 0.2 0.4 0.6 0.8 1.0
FPR
0.0
0.2
0.4
0.6
0.8
1.0
TPR
A
B
(a)
0.0 0.2 0.4 0.6 0.8 1.0
recall
0.0
0.2
0.4
0.6
0.8
1.0
precision
B A
(b)
Figure 5.2: (a) ROC curves for two hypothetical classification systems. The red curve for system A is better
than the blue curve for system B. We plot the true positive rate (TPR) vs the false positive rate (FPR) as we
vary the threshold τ . We also indicate the equal error rate (EER) with the red and blue dots, and the area
under the curve (AUC) for classifier B by the shaded area. Generated by code at figures.probml.ai/book1/5.2.
(b) A precision-recall curve for two hypothetical classification systems. The red curve for system A is better
than the blue curve for system B. Generated by code at figures.probml.ai/book1/5.2.
We can now plot the TPR vs FPR as an implicit function of τ . This is called a receiver operating
characteristic or ROC curve. See Figure 5.2(a) for an example.
5.1.3.2 Summarizing ROC curves as a scalar
The quality of a ROC curve is often summarized as a single number using the area under the
curve or AUC. Higher AUC scores are better; the maximum is obviously 1. Another summary
statistic that is used is the equal error rate or EER, also called the cross-over rate, defined as
the value which satisfies FPR = FNR. Since FNR=1-TPR, we can compute the EER by drawing a
line from the top left to the bottom right and seeing where it intersects the ROC curve (see points A
and B in Figure 5.2(a)). Lower EER scores are better; the minimum is obviously 0 (corresponding to
the top left corner).
5.1.3.3 Class imbalance
In some problems, there is severe class imbalance. For example, in information retrieval, the set of
negatives (irrelevant items) is usually much larger than the set of positives (relevant items). The ROC
curve is unaffected by class imbalance, as the TPR and FPR are fractions within the positives and
negatives, respectively. However, the usefulness of an ROC curve may be reduced in such cases, since
a large change in the absolute number of false positives will not change the false positive rate very
much, since FPR is divided by FP+TN (see e.g., [SR15] for discussion). Thus all the “action” happens
in the extreme left part of the curve. In such cases, we may choose to use other ways of summarizing
the class confusion matrix, such as precision-recall curves, which we discuss in Section 5.1.4.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license170 Chapter 5. Decision Theory
5.1.4 Precision-recall curves
In some problems, the notion of a “negative” is not well-defined. For example, consider detecting
objects in images: if the detector works by classifying patches, then the number of patches examined
— and hence the number of true negatives — is a parameter of the algorithm, not part of the problem
definition. Similarly, information retrieval systems usually get to choose the initial set of candidate
items, which are then ranked for relevance; by specifying a cutoff, we can partition this into a positive
and negative set, but note that the size of the negative set depends on the total number of items
retrieved, which is an algorithm parameter, not part of the problem specification.
In these kinds of situations, we may choose to use a precision-recall curve to summarize the
performance of our system, as we explain below. (See [DG06] for a more detailed discussion of the
connection between ROC curves and PR curves.)
5.1.4.1 Computing precision and recall
The key idea is to replace the FPR with a quantity that is computed just from positives, namely the
precision:
P(τ ) , p(y = 1|yˆ = 1, τ ) = T Pτ
T Pτ + F Pτ
(5.20)
The precision measures what fraction of our detections are actually positive. We can compare this to
the recall (which is the same as the TPR), which measures what fraction of the positives we actually
detected:
R(τ ) , p(ˆy = 1|y = 1, τ ) = T Pτ
T Pτ + F Nτ
(5.21)
If yˆn ∈ {0, 1} is the predicted label, and yn ∈ {0, 1} is the true label, we can estimate precision
and recall using
P(τ ) =
P
nP
ynyˆn
n
yˆn
(5.22)
R(τ ) =
P
nP
ynyˆn
n
yn
(5.23)
We can now plot the precision vs recall as we vary the threshold τ . See Figure 5.2(b). Hugging
the top right is the best one can do.
5.1.4.2 Summarizing PR curves as a scalar
The PR curve can be summarized as a single number in several ways. First, we can quote the
precision for a fixed recall level, such as the precision of the first K = 10 entities recalled. This
is called the precision at K score. Alternatively, we can compute the area under the PR curve.
However, it is possible that the precision does not drop monotonically with recall. For example,
suppose a classifier has 90% precision at 10% recall, and 96% precision at 20% recall. In this case,
rather than measuring the precision at a recall of 10%, we should measure the maximum precision
we can achieve with at least a recall of 10% (which would be 96%). This is called the interpolated
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.1. Bayesian decision theory 171
precision. The average of the interpolated precisions is called the average precision; it is equal
to the area under the interpolated PR curve, but may not be equal to the area under the raw PR
curve.1 The mean average precision or mAP is the mean of the AP over a set of different PR
curves.
5.1.4.3 F-scores
For a fixed threshold, corresponding to a single point on the PR curve, we can compute a single
precision and recall value, which we will denote by P and R. These are often combined into a single
statistic called the Fβ, which weights recall as β > 0 more important than precision. This is defined
as follows:2
1
Fβ
=
1
1 + β
2
1
P
+
β
2
1 + β
2
1
R
(5.24)
or equivalently
Fβ , (1 + β
2
)
P · R
β
2P + R
=
(1 + β
2
)T P
(1 + β
2)T P + β
2F N + F P
(5.25)
If we set β = 1, we get the harmonic mean of precision and recall:
1
F1
=
1
2

1
P
+
1
R

(5.26)
F1 =
2
1/R + 1/P
= 2
P · R
P + R
=
T P
T P +
1
2
(F P + F N)
(5.27)
To understand why we use the harmonic mean instead of the arithmetic mean, (P + R)/2, consider
the following scenario. Suppose we recall all entries, so yˆn = 1 for all n, and R = 1. In this case, the
precision P will be given by the prevalence, p(y = 1) =
P
n
I(yn=1)
N
. Suppose the prevalence is low,
say p(y = 1) = 10−4
. The arithmetic mean of P and R is given by (P + R)/2 = (10−4 + 1)/2 ≈ 50%.
By contrast, the harmonic mean of this strategy is only 2×10−4×1
1+10−4 ≈ 0.02%. In general, the harmonic
mean is more conservative, and requires both precision and recall to be high.
Using F1 score weights precision and recall equally. However, if recall is more important, we may
use β = 2, and if precision is more important, we may use β = 0.5.
5.1.4.4 Class imbalance
ROC curves are insensitive to class imbalance, but PR curves are not, as noted in [Wil20]. To see this,
let the fraction of positives in the dataset be π = P/(P +N), and define the ratio r = P/N = π/(1−π).
Let n = P + N be the population size. ROC curves are not affected by changes in r, since the TPR
is defined as a ratio within the positive examples, and FPR is defined as a ratio within the negative
examples. This means it does not matter which class we define as positive, and which we define as
negative.
1. For details, see https://sanchom.wordpress.com/tag/average-precision/.
2. We follow the notation from https://en.wikipedia.org/wiki/F-score#F%CE%B2.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license172 Chapter 5. Decision Theory
Now consider PR curves. The precision can be written as
Prec =
T P
T P + F P
=
P · T P R
P · T P R + N · F P R
=
T P R
T P R +
1
r
F P R
(5.28)
Thus Prec → 1 as π → 1 and r → ∞, and Prec → 0 as π → 0 and r → 0. For example, if we
we change from a balanced problem where r = 0.5 to an imbalanced problem where r = 0.1 (so
positives are rarer), the precision at each threshold will drop, and the recall (aka TPR) will stay the
same, so the overall PR curve will be lower. Thus if we have multiple binary problems with different
prevalences (e.g., object detection of common or rare objects), we should be careful when averaging
their precisions [HCD12].
The F-score is also affected by class imbalance. To see this, note that we can rewrite the F-score
as follows:
1
Fβ
=
1
1 + β
2
1
P
+
β
2
1 + β
2
1
R
(5.29)
=
1
1 + β
2
T P R +
N
P
F P R
T P R
+
β
2
1 + β
2
1
T P R
(5.30)
Fβ =
(1 + β
2
)T P R
T P R +
1
r
F P R + β
2
(5.31)
5.1.5 Regression problems
So far, we have considered the case where there are a finite number of actions A and states of nature
H. In this section, we consider the case where the set of actions and states are both equal to the real
line, A = H = R. We will specify various commonly used loss functions for this case (which can be
extended to R
D by computing the loss elementwise.) The resulting decision rules can be used to
compute the optimal parameters for an estimator to return, or the optimal action for a robot to take,
etc.
5.1.5.1 L2 loss
The most common loss for continuous states and actions is the `2 loss, also called squared error
or quadratic loss, which is defined as follows:
`2(h, a) = (h − a)
2
(5.32)
In this case, the risk is given by
R(a|x) = E

(h − a)
2
|x

= E

h
2
|x

− 2aE [h|x] + a
2
(5.33)
The optimal action must satisfy the condition that the derivative of the risk (at that point) is zero
(as explained in Chapter 8). Hence the optimal action is to pick the posterior mean:
∂
∂aR(a|x) = −2E [h|x] + 2a = 0 ⇒ π(x) = E [h|x] = Z
h p(h|x)dh (5.34)
This is often called the minimum mean squared error estimate or MMSE estimate.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.1. Bayesian decision theory 173
−3 −2 −1 0 1 2 3
−0.5
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
L2
L1
huber
Figure 5.3: Illustration of `2, `1, and Huber loss functions with δ = 1.5. Generated by code at fig￾ures.probml.ai/book1/5.3.
5.1.5.2 L1 loss
The `2 loss penalizes deviations from the truth quadratically, and thus is sensitive to outliers. A
more robust alternative is the absolute or `1 loss
`1(h, a) = |h − a| (5.35)
This is sketched in Figure 5.3. Exercise 5.4 asks you to show that the optimal estimate is the
posterior median, i.e., a value a such that Pr(h < a|x) = Pr(h ≥ a|x) = 0.5. We can use this for
robust regression as discussed in Section 11.6.1.
5.1.5.3 Huber loss
Another robust loss function is the Huber loss [Hub64], defined as follows:
`δ(h, a) = 
r
2/2 if |r| ≤ δ
δ|r| − δ
2/2 if |r| > δ (5.36)
where r = h − a. This is equivalent to `2 for errors that are smaller than δ, and is equivalent to `1
for larger errors. See Figure 5.3 for a plot. We can use this for robust regression as discussed in
Section 11.6.3.
5.1.6 Probabilistic prediction problems
In Section 5.1.2, we assumed the set of possible actions was to pick a single class label (or possibly the
“reject” or “do not know” action). In Section 5.1.5, we assumed the set of possible actions was to pick
a real valued scalar. In this section, we assume the set of possible actions is to pick a probability
distribution over some value of interest. That is, we want to perform probabilistic prediction
or probabilistic forecasting, rather than predicting a specific value. More precisely, we assume
the true “state of nature” is a distribution, h = p(Y |x), the action is another distribution, a = q(Y |x),
and we want to pick q to minimize E [`(p, q)] for a given x. We discuss various possible loss functions
below.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license174 Chapter 5. Decision Theory
5.1.6.1 KL, cross-entropy and log-loss
A common form of loss functions for comparing two distributions is the Kullback Leibler diver￾gence, or KL divergence, which is defined as follows:
DKL (pkq) ,
X
y∈Y
p(y) log p(y)
q(y)
(5.37)
(We have assumed the variable y is discrete, for notational simplicity, but this can be generalized
to real-valued variables.) In Section 6.2, we show that the KL divergence satisfies the following
properties: DKL (pkq) ≥ 0 with equality iff p = q. Note that it is an asymmetric function of its
arguments.
We can expand the KL as follows:
DKL (pkq) = X
y∈Y
p(y) log p(y) −
X
y∈Y
p(y) log q(y) (5.38)
= − H(p) + H(p, q) (5.39)
H(p) , −
X
y
p(y) log p(y) (5.40)
H(p, q) , −
X
y
p(y) log q(y) (5.41)
The H(p) term is known as the entropy. This is a measure of uncertainty or variance of p; it is
maximal if p is uniform, and is 0 if p is a degenerate or deterministic delta function. Entropy is often
used in the field of information theory, which is concerned with optimal ways of compressing and
communicating data (see Chapter 6). The optimal coding scheme will allocate fewer bits to more
frequent symbols (i.e., values of Y for which p(y) is large), and more bits to less frequent symbols. A
key result states that the number of bits needed to compress a dataset generated by a distribution p
is at least H(p); the entropy therefore provides a lower bound on the degree to which we can compress
data without losing information. The H(p, q) term is known as the cross-entropy. This measures
the expected number of bits we need to use to compress a dataset coming from distribution p if we
design our code using distribution q. Thus the KL is the extra number of bits we need to use to
compress the data due to using the incorrect distribution q. If the KL is zero, it means that we can
correctly predict the probabilities of all possible future events, and thus we have learned to predict
the future as well as an “oracle” that has access to the true distribution p.
To find the optimal distribution to use when predicting future data, we can minimize DKL (pkq).
Since H(p) is a constant wrt q, it can be ignored, and thus we can equivalently minimize the
cross-entropy:
q
∗
(Y |x) = argmin
q
H(q(Y |x), p(Y |x)) (5.42)
Now consider the special case in which the true state of nature is a degenerate distribution, which
puts all its mass on a single outcome, say c, i.e., h = p(Y |x) = I(Y = c). This is often called
a “one-hot” distribution, since it turns “on” the c’th element of the vector, and leaves the other
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.2. Choosing the “right” model 175
elements “off”, as shown in Figure 2.1. In this case, the cross entropy becomes
H(δ(Y = c), q) = −
X
y∈Y
δ(y = c) log q(y) = − log q(c) (5.43)
This is known as the log loss of the predictive distribution q when given target label c.
5.1.6.2 Proper scoring rules
Cross-entropy loss is a very common choice for probabilistic forecasting, but is not the only possible
metric. The key property we desire is that the loss function is minimized iff the decision maker picks
the distribution q that matches the true distribution p, i.e., `(p, p) ≤ `(p, q), with equality iff p = q.
Such a loss function ` is called a proper scoring rule [GR07].
We can show that cross-entropy loss is a proper scoring rule by virtue of the fact that DKL (pkp) ≤
DKL (pkq). However, the log p(y)/q(y) term can be quite sensitive to errors for low probability events
[QC+06]. A common alternative is to use the Brier score [Bri50], which is defined as follows (for a
discrete distribution with C values):
`(p, q) ,
1
C
X
C
c=1
(q(y = c|x) − p(y = c|x))2
(5.44)
This is just the squared error of the predictive distribution compared to the true distribution, when
viewed as vectors. Since it is based on squared error, the Brier score is less sensitive to extremely
rare or extremely common classes. Fortunately, it is also a proper scoring rule.
5.2 Choosing the “right” model
In this section, we consider the setting in which we have several candidate (parametric) models (e.g.,
neural networks with different numbers of layers), and we want to choose the “right” one. This can
be tackled using tools from Bayesian decision theory.
5.2.1 Bayesian hypothesis testing
Suppose we have two hypotheses or models, commonly called the null hypothesis, M0, and the
alternative hypothesis, M1, and we want to know which one is more likely to be true. This is
called hypothesis testing.
If we use 0-1 loss, the optimal decision is to pick the alternative hypothesis iff p(M1|D) > p(M0|D),
or equivalently, if p(M1|D)/p(M0|D) > 1. If we use a uniform prior, p(M0) = p(M1) = 0.5, the
decision rule becomes: select M1 iff p(D|M1)/p(D|M0) > 1. This quantity, which is the ratio of
marginal likelihoods of the two models, is known as the Bayes factor:
B1,0 ,
p(D|M1)
p(D|M0)
(5.45)
This is like a likelihood ratio, except we integrate out the parameters, which allows us to compare
models of different complexity, due to the Bayesian Occam’s razor effect explained in Section 5.2.3.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license176 Chapter 5. Decision Theory
Bayes factor BF(1, 0) Interpretation
BF < 1
100 Decisive evidence for M0
BF < 1
10 Strong evidence for M0
1
10 < BF < 1
3 Moderate evidence for M0
1
3 < BF < 1 Weak evidence for M0
1 < BF < 3 Weak evidence for M1
3 < BF < 10 Moderate evidence for M1
BF > 10 Strong evidence for M1
BF > 100 Decisive evidence for M1
Table 5.6: Jeffreys scale of evidence for interpreting Bayes factors.
If B1,0 > 1 then we prefer model 1, otherwise we prefer model 0. Of course, it might be that B1,0
is only slightly greater than 1. In that case, we are not very confident that model 1 is better. Jeffreys
[Jef61] proposed a scale of evidence for interpreting the magnitude of a Bayes factor, which is shown
in Table 5.6. This is a Bayesian alternative to the frequentist concept of a p-value (see Section 5.5.3).
We give a worked example of how to compute Bayes factors in Section 5.2.1.1.
5.2.1.1 Example: Testing if a coin is fair
As an example, suppose we observe some coin tosses, and want to decide if the data was generated by
a fair coin, θ = 0.5, or a potentially biased coin, where θ could be any value in [0, 1]. Let us denote
the first model by M0 and the second model by M1. The marginal likelihood under M0 is simply
p(D|M0) = 
1
2
N
(5.46)
where N is the number of coin tosses. From Equation (4.143), the marginal likelihood under M1,
using a Beta prior, is
p(D|M1) = Z
p(D|θ)p(θ)dθ =
B(α1 + N1, α0 + N0)
B(α1, α0)
(5.47)
We plot log p(D|M1) vs the number of heads N1 in Figure 5.4(a), assuming N = 5 and a uniform
prior, α1 = α0 = 1. (The shape of the curve is not very sensitive to α1 and α0, as long as the
prior is symmetric, so α0 = α1.) If we observe 2 or 3 heads, the unbiased coin hypothesis M0
is more likely than M1, since M0 is a simpler model (it has no free parameters) — it would be
a suspicious coincidence if the coin were biased but happened to produce almost exactly 50/50
heads/tails. However, as the counts become more extreme, we favor the biased coin hypothesis. Note
that, if we plot the log Bayes factor, log B1,0, it will have exactly the same shape, since log p(D|M0)
is a constant.
5.2.2 Bayesian model selection
Now suppose we have a set M of more than 2 models, and we want to pick the most likely. This
is called model selection. We can view this as a decision theory problem, where the action space
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.2. Choosing the “right” model 177
0 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 5
−1.8
−1.6
−1.4
−1.2
−1
−0.8
−0.6
−0.4
log10 p(D|M1)
(a)
0 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 5
−2.5
−2.45
−2.4
−2.35
−2.3
−2.25
−2.2
−2.15
−2.1
−2.05
−2
BIC approximation to log10 p(D|M1)
(b)
Figure 5.4: (a) Log marginal likelihood vs number of heads for the coin tossing example. (b) BIC approximation.
(The vertical scale is arbitrary, since we are holding N fixed.) Generated by code at figures.probml.ai/book1/5.4.
requires choosing one model, m ∈ M. If we have a 0-1 loss, the optimal action is to pick the most
probable model:
mˆ = argmax
m∈M
p(m|D) (5.48)
where
p(m|D) = p(D|m)p(m)
P
m∈M p(D|m)p(m)
(5.49)
is the posterior over models. If the prior over models is uniform, p(m) = 1/|M|, then the MAP
model is given by
mˆ = argmax
m∈M
p(D|m) (5.50)
The quantity p(D|m) is given by
p(D|m) = Z
p(D|θ, m)p(θ|m)dθ (5.51)
This is known as the marginal likelihood, or the evidence for model m. Intuitively, it is the
likelihood of the data averaged over all possible parameter values, weighted by the prior p(θ|m). If
all settings of θ assign high probability to the data, then this is probably a good model.
5.2.2.1 Example: polynomial regression
As an example of Bayesian model selection, we will consider polynomial regression in 1d. Figure 5.5
shows the posterior over three different models, corresponding to polynomials of degrees 1, 2 and 3 fit
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license178 Chapter 5. Decision Theory
−2 0 2 4 6 8 10 12
−10
0
10
20
30
40
50
60
deg=1 | logev=-16.28
(a)
−2 0 2 4 6 8 10 12
−20
0
20
40
60
deg=2 | logev=-20.64
(b)
−2 0 2 4 6 8 10 12
−50
0
50
100
150
200
250
300
deg=3 | logev=-24.95
(c)
1 2 3
M
0.0
0.2
0.4
0.6
0.8
1.0
P(M|D)
(d)
Figure 5.5: Ilustration of Bayesian model selection for polynomial regression. (a-c) We fit polynomials of
degrees 1, 2 and 3 fit to N = 5 data points. The solid green curve is the true function, the dashed red curve
is the prediction (dotted blue lines represent ±σ around the mean). (d) We plot the posterior over models,
p(m|D), assuming a uniform prior p(m) ∝ 1. Generated by code at figures.probml.ai/book1/5.5.
to N = 5 data points. We use a uniform prior over models, and use empirical Bayes to estimate the
prior over the regression weights (see Section 11.7.7). We then compute the evidence for each model
(see Section 11.7 for details on how to do this). We see that there is not enough data to justify a
complex model, so the MAP model is m = 1. Figure 5.6 shows the analogous plot for N = 30 data
points. Now we see that the MAP model is m = 2; the larger sample size means we can safely pick a
more complex model.
5.2.3 Occam’s razor
Consider two models, a simple one, m1, and a more complex one, m2. Suppose that both can explain
the data by suitably optimizing their parameters, i.e., for which p(D|θˆ
1, m1) and p(D|θˆ
2, m2) are
both large. Intuitively we should prefer m1, since it is simpler and just as good as m2. This principle
is known as Occam’s razor.
Let us now see how ranking models based on their marginal likelihood, which involves averaging
the likelihood wrt the prior, will give rise to this behavior. The complex model will put less prior
probability on the “good” parameters that explain the data, θˆ
2, since the prior must integrate to
1.0 over the entire parameter space. Thus it will take averages in parts of parameter space with
low likelihood. By contrast, the simpler model has fewer parameters, so the prior is concentrated
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.2. Choosing the “right” model 179
−2 0 2 4 6 8 10 12
0
10
20
30
40
50
60
deg=1 | logev=-146.15
(a)
−2 0 2 4 6 8 10 12
−10
0
10
20
30
40
50
60
70
deg=2 | logev=-72.37
(b)
−2 0 2 4 6 8 10 12
0
20
40
60
80
100
deg=3 | logev=-77.22
(c)
1 2 3
M
0.0
0.2
0.4
0.6
0.8
1.0
P(M|D)
(d)
Figure 5.6: Same as Figure 5.5 except now N = 30. Generated by code at figures.probml.ai/book1/5.6.
over a smaller volume; thus its averages will mostly be in the good part of parameter space, near θˆ
1.
Hence we see that the marginal likelihood will prefer the simpler model. This is called the Bayesian
Occam’s razor effect [Mac95; MG05].
Another way to understand the Bayesian Occam’s razor effect is to compare the relative predictive
abilities of simple and complex models. Since probabilities must sum to one, we have P
D0 p(D0
|m) = 1,
where the sum is over all possible datasets. Complex models, which can predict many things, must
spread their predicted probability mass thinly, and hence will not obtain as large a probability for
any given data set as simpler models. This is sometimes called the conservation of probability
mass principle, and is illustrated in Figure 5.7. On the horizontal axis we plot all possible data sets
in order of increasing complexity (measured in some abstract sense). On the vertical axis we plot the
predictions of 3 possible models: a simple one, M1; a medium one, M2; and a complex one, M3. We
also indicate the actually observed data D0 by a vertical line. Model 1 is too simple and assigns low
probability to D0. Model 3 also assigns D0 relatively low probability, because it can predict many
data sets, and hence it spreads its probability quite widely and thinly. Model 2 is “just right”: it
predicts the observed data with a reasonable degree of confidence, but does not predict too many
other things. Hence model 2 is the most probable model.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license180 Chapter 5. Decision Theory
p(D)
M1
M2
M3
D0 D
Figure 5.7: A schematic illustration of the Bayesian Occam’s razor. The broad (green) curve corresponds to a
complex model, the narrow (blue) curve to a simple model, and the middle (red) curve is just right. Adapted
from Figure 3.13 of [Bis06]. See also [MG05, Figure 2] for a similar plot produced on real data.
5.2.4 Connection between cross validation and marginal likelihood
We have seen how the marginal likelihood helps us choose models of the “right” complexity. In
non-Bayesian approaches to model selection, it is standard to use cross validation (Section 4.5.5) for
this purpose.
It turns out that the marginal likelihood is closely related to the leave-one-out cross-validation
(LOO-CV) estimate, as we now show. We start with the marginal likelihood, which we write in
sequential form as follows:
p(D|m) = Y
N
n=1
p(yn|y1:n−1, x1:N , m) = Y
N
n=1
p(yn|xn, D1:n−1, m) (5.52)
where
p(y|x, D1:n−1, m) = Z
p(y|x, θ)p(θ|D1:n−1, m)dθ (5.53)
Suppose we use a plugin approximation to the above distribution to get
p(y|x, D1:n−1, m) ≈
Z
p(y|x, θ)δ(θ − θˆm(D1:n−1))dθ = p(y|x, θˆm(D1:n−1)) (5.54)
Then we get
log p(D|m) ≈
X
N
n=1
log p(yn|xn, θˆm(D1:n−1)) (5.55)
This is very similar to a leave-one-out cross-validation estimate of the likelihood, except it is evaluated
sequentially. A complex model will overfit the “early” examples and will then predict the remaining
ones poorly, and thus will get low marginal likelihood as well as low cross-validation score. See [FH20]
for further discussion.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.2. Choosing the “right” model 181
5.2.5 Information criteria
The marginal likelihood, p(D|m) = R
p(D|θ, m)p(θ)dθ, which is needed for Bayesian model selection
discussed in Section 5.2.2, can be difficult to compute, since it requires marginalizing over the entire
parameter space. Furthermore, the result can be quite sensitive to the choice of prior. In this section,
we discuss some other related metrics for model selection known as information criteria. We only
give a brief discussion; see e.g., [GHV14] for further details.
5.2.5.1 The Bayesian information criterion (BIC)
The Bayesian information criterion or BIC [Sch78] can be thought of as a simple approximation
to the log marginal likelihood. In particular, if we make a Gaussian approximation to the posterior,
as discussed in Section 4.6.8.2, we get (from Equation (4.215)) the following:
log p(D|m) ≈ log p(D|θˆmap) + log p(θˆmap) −
1
2
log |H| (5.56)
where H is the Hessian of the negative log joint log p(D, θ) evaluated at the MAP estimate θˆmap. We
see that Equation (5.56) is the log likelihood plus some penalty terms. If we have a uniform prior,
p(θ) ∝ 1, we can drop the prior term, and replace the MAP estimate with the MLE, θˆ, yielding
log p(D|m) ≈ log p(D|θˆ) −
1
2
log |H| (5.57)
We now focus on approximating the log |H| term, which is sometimes called the Occam factor,
since it is a measure of model complexity (volume of the posterior distribution). We have H = PN
i=1 Hi
, where Hi = ∇∇ log p(Di
|θ). Let us approximate each Hi by a fixed matrix Hˆ . Then we
have
log |H| = log |NHˆ | = log(N
D|Hˆ |) = D log N + log |Hˆ | (5.58)
where D = dim(θ) and we have assumed H is full rank. We can drop the log |Hˆ | term, since it is
independent of N, and thus will get overwhelmed by the likelihood. Putting all the pieces together,
we get the BIC score that we want to maximize:
JBIC(m) = log p(D|m) ≈ log p(D|θˆ, m) −
Dm
2
log N (5.59)
We can also define the BIC loss, that we want to minimize, by multiplying by -2:
LBIC(m) = −2 log p(D|θˆ, m) + Dm log N (5.60)
(The use of 2 as a scale factor is chosen to simplify the expression when using a model with a Gaussian
likelihood.)
5.2.5.2 Akaike information criterion
The Akaike information criterion [Aka74] is closely related to the BIC. It has the form
LAIC(m) = −2 log p(D|θˆ, m) + 2D (5.61)
This penalizes complex models less heavily than BIC, since the regularization term is independent of
N. This estimator can be derived from a frequentist perspective.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license182 Chapter 5. Decision Theory
5.2.5.3 Minimum description length (MDL)
We can think about the problem of scoring different models in terms of information theory (Chapter 6).
The goal is for the sender to communicate the data to the receiver. First the sender needs to specify
which model m to use; this takes C(m) = − log p(m) bits (see Section 6.1). Then the receiver can
fit the model, by computing θˆm, and can thus approximately reconstruct the data. To perfectly
reconstruct the data, the sender needs to send the residual errors that cannot be explained by the
model; this takes −L(m) = − log p(D|θˆ, m) = −
P
n
log p(yn|θˆ, m) bits. The total cost is
LMDL(m) = − log p(D|θˆ, m) + C(m) (5.62)
We see that has the same basic form as BIC/AIC. Choosing the model which minimizes J(m) is
known as the minimum description length or MDL principle. See e.g., [HY01] for details.
5.2.6 Hypothesis testing without Bayes factors
The approach to hypothesis testing discussed in Section 5.2.1 relies on computing the Bayes factors
for the null vs the alternative model, p(D|H0)/p(D|H1). Unfortunately, computing the necessary
marginal likelihoods can be computationally difficult, and the results can be sensitive to the choice of
prior. Furthermore, we are often more interested in estimating an effect size, which is the difference
in magnitude between two parameters, rather than in deciding if an effect size is 0 (null hypothesis)
or not (alternative hypothesis).
For example, suppose we have two classifiers, m1 and m2, and we want to know which one is
better. Let µ1 and µ2 be their average accuracies, and let δ = µ1 − µ2 be the difference in their
accuracies. The probability that model 1 is more accurate, on average, than model 2 is given by
p(δ > 0|D). However, even if this probability is large, the improvement may be not be practically
significant. So it is better to compute a probability such as p(δ > |D) or p(|δ| > |D), where 
represents the minimal magnitude of effect size that is meaningful for the problem at hand. This is
called a one-sided test or two-sided test.
More generally, let R = [−, ] represent a region of practical equivalence or ROPE [Kru15;
KL17]. We can define 3 events of interest: the null hypothesis H0 : δ ∈ R, which says both methods
are practically the same (this is a more realistic assumption than the point null hypothesis
H0 : δ = 0); HA : δ > , which says m1 is better than m2; and HB : δ < −, which says m2 is better
than m1. To choose amongst these 3 hypotheses, we just have to compute p(δ|D), which avoids the
need to compute Bayes factors. In the sections below, we discuss how to compute this quantity using
two different kinds of model.
5.2.6.1 Bayesian t-test for difference in means
Suppose we have two classifiers, m1 and m2, which are evaluated on the same set of N test examples.
Let e
m
i be the error of method m on test example i. Since the classifiers are applied to the same
data, we can use a paired test for comparing them, which is more sensitive than looking at average
performance, since the factors that make one example easy or hard to classify (e.g., due to label
noise) will be shared by both methods. Thus we will work with the differences, xi = e
1
i − e
2
i
. We
assume xi ∼ N (δ, σ2
). We are interested in p(δ|x), where x = (x1, . . . , xN ).
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.2. Choosing the “right” model 183
If we use an uninformative prior for the unknown parameters (δ, σ), one can show that the posterior
marginal for the mean is given by a Student distribution:
p(δ|x) = TN−1(δ|x, s2
/N)
where x =
1
N
PN
i=1 xi
is the sample mean, and s
2 =
1
N−1
PN
i=1(xi − x)
2
is an unbiased estimate of
the variance. Hence we can easily compute p(|δ| > |x), with a ROPE of  = 0.01 (say). This is
known as a Bayesian t-test. [Ben+17]. (See also [Rou+09] for Bayesian t-test based on Bayes
factors, and [Die98] for a non-Bayesian approach to comparing classifiers.)
An alternative to a formal test is to just plot the posterior p(δ|x). If this distribution is tightly
centered on 0, we can conclude that there is no significant difference between the methods. (In fact,
an even simpler approach is to just make a boxplot of the data, {xi}, which avoids the need for any
formal statistical analysis.)
Note that this kind of problem arises in many applications, not just evaluating classifiers. For
example, suppose we have a set of N people, each of whom is exposed two drugs; let e
m
i be the
outcome (e.g., sickness level) when person i is exposed to drug m, and let x
m
i = e
1
i − e
2
i be the
difference in response. We can then analyse the effect of the drug by computing p(δ|x) as we discussed
above.
5.2.6.2 Bayesian χ
2
-test for difference in rates
Now suppose we have two classifiers which are evaluated on different test sets. Let ym be the number
of correct examples from method m ∈ {1, 2} out of Nm trials, so the accuracy rate is ym/Nm. We
assume ym ∼ Bin(Nm, θm), so we are interested in p(δ|D), where δ = θ1 −θ2, and D = (y1, N1, y2, N2)
is all the data.
If we use a uniform prior for θ1 and θ2 (i.e., p(θj ) = Beta(θj |1, 1)), the posterior is given by
p(θ1, θ2|D) = Beta(θ1|y1 + 1, N1 − y1 + 1)Beta(θ2|y2 + 1, N2 − y2 + 1)
The posterior for δ is given by
p(δ|D) = Z 1
0
Z 1
0
I(δ = θ1 − θ2) p(θ1|D1)p(θ2|D2)
=
Z 1
0
Beta(θ1|y1 + 1, N1 − y1 + 1)Beta(θ1 − δ|y2 + 1, N2 − y2 + 1)dθ1
We can then evaluate this for any value of δ that we choose. For example, we can compute
p(δ > |D) = Z ∞

p(δ|D)dδ
(We can compute this using 1 dimensional numerical integration or analytically [Coo05].) This is
called a Bayesian χ
2
-test.
Note that this kind of problem arises in many applications, not just evaluating classifiers, For
example, suppose the two groups are different companies selling the same product on Amazon, and
ym is the number of positive reviews for merchant m. Or suppose the two groups correspond to men
and women, and ym is the number of people in group m who are left handed, and Nm − ym to be
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license184 Chapter 5. Decision Theory
LH RH
Male 9 43 N1 = 52
Female 4 44 N2 = 48
Totals 13 87 100
Table 5.7: A 2x2 contingency table from http: // en. wikipedia. org/ wiki/ Contingency_ table . The
MLEs for the left handedness rate in males and females are ˆθ1 = 9/52 = 0.1731 and ˆθ2 = 4/48 = 0.0417.
the number who are right handed.3 We can represent the data as a 2 × 2 contingency table of
counts, as shown in Table 5.7.
The MLEs for the left handedness rate in males and females are ˆθ1 = 9/52 = 0.1731 and
ˆθ2 = 4/48 = 0.0417. It seems that there is a difference, but the sample size is low, so we cannot be
sure. Hence we will represent our uncertainty by computing p(δ|D), where δ = θ1 − θ2 and D is the
table of counts.
We find p(θ1 > θ2|D) = R ∞
0
p(δ|D) = 0.901, which suggests that left handedness is more common
in males, consistent with other studies [PP+20].
5.3 Frequentist decision theory
In this section, we discuss frequentist decision theory. This is similar to Bayesian decision theory,
discussed in Section 5.1, but differs in that there is no prior, and hence no posterior, over the unknown
state of nature. Consequently we cannot define the risk as the posterior expected loss. We will
consider other definitions in Section 5.3.1.
5.3.1 Computing the risk of an estimator
We define the frequentist risk of an estimator π given an unknown state of nature θ to be the
expected loss when applying that estimator to data x sampled from the likelihood function p(x|θ):
R(θ, π) , Ep(x|θ)
[`(θ, π(x))] (5.63)
We give an example of this in Section 5.3.1.1.
5.3.1.1 Example
Let us give an example, based on [BS94]. Consider the problem of estimating the mean of a Gaussian.
We assume the data is sampled from xn ∼ N (θ
∗
, σ2 = 1). If we use quadratic loss, `2(θ, ˆθ) = (θ − ˆθ)
2
,
the corresponding risk function is the MSE.
We now consider 5 different estimators for computing θ:
• π1(D) = x, the sample mean
• π2(D) = median(D), the sample median
3. This example is based on the following blog post by Bob Carpenter: https://bit.ly/2FykD1C.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.3. Frequentist decision theory 185
3
*
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
R(
3
*
,/)
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
0.45
0.5
risk functions for n=5
mle
median
fixed
postmean1
postmean5
(a)
3
*
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
R(
3
*
,/)
0
0.02
0.04
0.06
0.08
0.1
0.12
0.14
0.16
0.18
risk functions for n=20
mle
median
fixed
postmean1
postmean5
(b)
Figure 5.8: Risk functions for estimating the mean of a Gaussian. Each curve represents R(
ˆθi(·), θ∗
) plotted
vs θ
∗
, where i indexes the estimator. Each estimator is applied to N samples from N (θ
∗
, σ2 = 1). The dark
blue horizontal line is the sample mean (MLE); the red line horizontal line is the sample median; the black
curved line is the estimator ˆθ = θ0 = 0; the green curved line is the posterior mean when κ = 1; the light blue
curved line is the posterior mean when κ = 5. (a) N = 5 samples. (b) N = 20 samples. Adapted from Figure
B.1 of [BS94]. Generated by code at figures.probml.ai/book1/5.8.
• π3(D) = θ0, a fixed value
• πκ(D), the posterior mean under a N (θ|θ0, σ2/κ) prior:
πκ(D) = N
N + κ
x +
κ
N + κ
θ0 = wx + (1 − w)θ0 (5.64)
For πκ, we use θ0 = 0, and consider a weak prior, κ = 1, and a stronger prior, κ = 5.
Let ˆθ = ˆθ(x) = π(x) be the estimated parameter. The risk of this estimator is given by the MSE.
In Section 4.7.6.3, we show that the MSE can be decomposed into squared bias plus variance:
MSE(ˆθ|θ
∗
) = V
h
ˆθ
i
+ bias2
(
ˆθ) (5.65)
where the bias is defined as bias(
ˆθ) = E
h
ˆθ − θ
∗
i
. We now use this expression to derive the risk for
each estimator.
π1 is the sample mean. This is unbiased, so its risk is
MSE(π1|θ
∗
) = V [x] = σ
2
N
(5.66)
π2 is the sample median. This is also unbiased. Furthermore, one can show that its variance is
approximately π/(2N), so the risk is
MSE(π2|θ
∗
) = π
2N
(5.67)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license186 Chapter 5. Decision Theory
π3 returns the constant θ0, so its bias is (θ
∗ − θ0) and its variance is zero. Hence the risk is
MSE(π3|θ
∗
) = (θ
∗ − θ0)
2
(5.68)
Finally, π4 is the posterior mean under a Gaussian prior. We can derive its MSE as follows:
MSE(πκ|θ
∗
) = E
h
(wx + (1 − w)θ0 − θ
∗
)
2
i
(5.69)
= E
h
(w(x − θ
∗
) + (1 − w)(θ0 − θ
∗
))2
i
(5.70)
= w
2 σ
2
N
+ (1 − w)
2
(θ0 − θ
∗
)
2
(5.71)
=
1
(N + κ)
2
￾
Nσ2 + κ
2
(θ0 − θ
∗
)
2

(5.72)
These functions are plotted in Figure 5.8 for N ∈ {5, 20}. We see that in general, the best estimator
depends on the value of θ
∗
, which is unknown. If θ
∗
is very close to θ0, then π3 (which just predicts
θ0) is best. If θ
∗
is within some reasonable range around θ0, then the posterior mean, which combines
the prior guess of θ0 with the actual data, is best. If θ
∗
is far from θ0, the MLE is best.
5.3.1.2 Bayes risk
In general, the true state of nature θ that generates the data x is unknown, so we cannot compute
the risk given in Equation (5.63). One solution to this is to assume a prior π0 for θ, and then average
it out. This gives us the Bayes risk, also called the integrated risk:
R(π0, π) , Eπ0(θ)
[R(θ, π)] = Z
dθ dx π0(θ)p(x|θ)`(θ, π(x)) (5.73)
A decision rule that minimizes the Bayes risk is known as a Bayes estimator. This is equivalent to
the optimal policy recommended by Bayesian decision theory in Equation (5.2) since
π(x) = argmin
a
Z
dθ π0(θ)p(x|θ)`(θ, a) = argmin
a
Z
dθ p(θ|x)`(θ, a) (5.74)
Hence we see that picking the optimal action on a case-by-case basis (as in the Bayesian approach) is
optimal on average (as in the frequentist approach). In other words, the Bayesian approach provides
a good way of achieving frequentist goals. See [BS94, p448] for further discussion of this point.
5.3.1.3 Maximum risk
Of course the use of a prior might seem undesirable in the context of frequentist statistics. We can
therefore define the maximum risk as follows:
Rmax(π) , sup
θ
R(θ, π) (5.75)
A decision rule that minimizes the maximum risk is called a minimax estimator, and is denoted
πMM. For example, in Figure 5.9, we see that π1 has lower worst-case risk than π2, ranging over all
possible values of θ, so it is the minimax estimator.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2025.3. Frequentist decision theory 187
Figure 5.9: Risk functions for two decision procedures, π1 and π2. Since π1 has lower worst case risk, it is
the minimax estimator, even though π2 has lower risk for most values of θ. Thus minimax estimators are
overly conservative.
Minimax estimators have a certain appeal. However, computing them can be hard. And furthermore,
they are very pessimistic. In fact, one can show that all minimax estimators are equivalent to Bayes
estimators under a least favorable prior. In most statistical situations (excluding game theoretic
ones), assuming nature is an adversary is not a reasonable assumption.
5.3.2 Consistent estimators
Suppose we have a dataset D = {xn : n = 1 : N} where the samples xn ∈ X are generated from a
distribution p(x|θ
∗
), where θ
∗ ∈ Θ is the true parameter. Furthermore, suppose the parameters are
identifiable, meaning that p(D|θ) = p(D|θ
0
) iff θ = θ
0
for any dataset D. Then we say that an
estimator π : X
N → Θ is a consistent estimator if θˆ(D) → θ
∗ as N → ∞ (where the arrow denotes
convergence in probability). In other words, the procedure π recovers the true parameter (or a subset
of it) in the limit of infinite data. This is equivalent to minimizing the 0-1 loss, L(θ
∗
, θˆ) = I

θ
∗ 6= θˆ

.
An example of a consistent estimator is the maximum likelihood estimator (MLE).
Note that an estimator can be unbiased but not consistent. For example, consider the estimator
π({x1, . . . , xN }) = xN . This is an unbiased estimator of the mean, since E [π(D)] = E [x]. But the
sampling distribution of π(D) does not converge to a fixed value, so it cannot converge to the point
θ
∗
.
Although consistency is a desirable property, it is of somewhat limited usefulness in practice since
most real datasets do not come from our chosen model family (i.e., there is no θ
∗
such that p(·|θ
∗
)
generates the observed data D). In practice, it is more useful to find estimators that minimize some
discrepancy measure between the empirical distribution pD(x|D) and the estimated distribution
p(x|θˆ). If we use KL divergence as our discrepancy measure, our estimate becomes the MLE.
5.3.3 Admissible estimators
We say that π1 dominates π2 if R(θ, π1) ≤ R(θ, π2) for all θ. The domination is said to be strict
if the inequality is strict for some θ
∗
. An estimator is said to be admissible if it is not strictly
dominated by any other estimator. Interestingly, [Wal47] proved that all admissible decision rules
are equivalent to some kind of Bayesian decision rule, under some technical conditions. (See [DR21]
for a more general version of this result.)
For example, in Figure 5.8, we see that the sample median (dotted red line) always has higher risk
than the sample mean (solid blue line). Therefore the sample median is not an admissible estimator
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license188 Chapter 5. Decision Theory
for the mean. More surprisingly, one can show that the sample mean is not always an admissible
estimator either, even under a Gaussian likelihood model with squared error loss (this is known as
Stein’s paradox [Ste56]).
However, the concept of admissibility is of somewhat limited value. For example, let X ∼ N (θ, 1),
and consider estimating θ under squared loss. Consider the estimator π1(x) = θ0, where θ0 is a
constant independent of the data. We now show that this is an admissible estimator.
To see this, suppose it were not true. Then there would be some other estimator π2 with smaller
risk, so R(θ
∗
, π2) ≤ R(θ
∗
, π1), where the inequality must be strict for some θ
∗
. Consider the risk at
θ
∗ = θ0. We have R(θ0, π1) = 0, and
R(θ0, π2) = Z
(π2(x) − θ0)
2
p(x|θ0)dx (5.76)
Since 0 ≤ R(θ
∗
, π2) ≤ R(θ
∗
, π1) for all θ
∗
, and R(θ0, π1) = 0, we have R(θ0, π2) = 0 and hence
π2(x) = θ0 = π1(x). Thus the only way π2 can avoid having higher risk than π1 at θ0 is by being
equal to π1. Hence there is no other estimator π2 with strictly lower risk, so π2 is admissible.
Thus we see that the estimator π1(x) = θ0 is admissible, even though it ignores the data, so
is useless as an estimator. Conversely, it is possible to construct useful estimators that are not
admissable (see e.g., [Jay03, Sec 13.7]).
5.4 Empirical risk minimization
In this section, we consider how to apply frequentist decision theory in the context of supervised
learning.
5.4.1 Empirical risk
In standard accounts of frequentist decision theory used in statistics textbooks, there is a single
unknown “state of nature”, corresponding to the unknown parameters θ
∗ of some model, and we
define the risk as in Equation (5.63), namely R(π, θ
∗
) = Ep(D|θ∗)
[`(θ
∗
, π(D))].
In supervised learning, we have a different unknown state of nature (namely the output y) for each
input x, and our estimator π is a prediction function yˆ = f(x), and the state of nature is the true
distribution p
∗
(x, y). Thus the risk of an estimator as follows:
R(f, p∗
) = R(f) , Ep∗(x)p∗(y|x)
[`(y, f(x)] (5.77)
This is called the population risk, since the expectations are taken wrt the true joint distribution
p
∗
(x, y). Of course, p
∗
is unknown, but we can approximate it using the empirical distribution with
N samples:
pD(x, y|D) ,
1
|D|
X
(xn,yn)∈D
δ(x − xn)δ(y − yn) (5.78)
where pD(x, y) = ptr(x, y). Plugging this in gives us the empirical risk:
R(f, D) , EpD(x,y)
[`(y, f(x)] = 1
N
X
N
n=1
`(yn, f(xn)) (5.79)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.4. Empirical risk minimization 189
Note that R(f, D) is a random variable, since it depends on the training set.
A natural way to choose the predictor is to use
ˆfERM = argmin
f∈H
R(f, D) = argmin
f∈H
1
N
X
N
n=1
`(yn, f(xn)) (5.80)
where we optimize over a specific hypothesis space H of functions. This is called empirical risk
minimization (ERM).
5.4.1.1 Approximation error vs estimation error
In this section, we analyze the theoretical performance of functions that are fit using the ERM
principle. Let f
∗∗ = argminf R(f) be the function that achieves the minimal possible population risk,
where we optimize over all possible functions. Of course, we cannot consider all possible functions,
so let us also define f
∗ = argminf∈H R(f) to be the best function in our hypothesis space, H.
Unfortunately we cannot compute f
∗
, since we cannot compute the population risk, so let us finally
define the prediction function that minimizes the empirical risk in our hypothesis space:
f
∗
N = argmin
f∈H
R(f, D) = argmin
f∈H
Eptr [`(y, f(x))] (5.81)
One can show [BB08] that the risk of our chosen predictor compared to the best possible predictor
can be decomposed into two terms, as follows:
Ep∗ [R(f
∗
N ) − R(f
∗∗)] = R(f
∗
) − R(f
∗∗)
| {z }
Eapp(H)
+ Ep∗ [R(f
∗
N ) − R(f
∗
)]
| {z }
Eest(H,N)
(5.82)
The first term, Eapp(H), is the approximation error, which measures how closely H can model the
true optimal function f
∗∗. The second term, Eest(H, N), is the estimation error or generalization
error, which measures the difference in estimated risks due to having a finite training set. We can
approximate this by the difference between the training set error and the test set error, using two
empirical distributions drawn from p
∗
:
Ep∗ [R(f
∗
N ) − R(f
∗
)] ≈ Eptr [`(y, f ∗
N (x))] − Epte [`(y, f ∗
N (x))] (5.83)
This difference is often called the generalization gap.
We can decrease the approximation error by using a more expressive family of functions H, but
this usually increases the generalization error, due to overfitting. We discuss solutions to this tradeoff
below.
5.4.1.2 Regularized risk
To avoid the chance of overfitting, it is common to add a complexity penalty to the objective function,
giving us the regularized empirical risk:
Rλ(f, D) = R(f, D) + λC(f) (5.84)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license190 Chapter 5. Decision Theory
where C(f) measures the complexity of the prediction function f(x; θ), and λ ≥ 0, which is known
as a hyperparameter, controls the strength of the complexity penalty. (We discuss how to pick λ
in Section 5.4.2.)
In practice, we usually work with parametric functions, and apply the regularizer to the parameters
themselves. This yields the following form of the objective:
Rλ(θ, D) = R(θ, D) + λC(θ) (5.85)
Note that, if the loss function is log loss, and the regularizer is a negative log prior, the regularized
risk is given by
Rλ(θ, D) = −
1
N
X
N
n=1
log p(yn|xn, θ) − λ log p(θ) (5.86)
Minimizing this is equivalent to MAP estimation.
5.4.2 Structural risk
A natural way to estimate the hyperparameters is to minimize for the lowest achievable empirical
risk:
λˆ = argmin
λ
min
θ
Rλ(θ, D) (5.87)
(This is an example of bilevel optimization, also called nested optimization.) Unfortunately,
this technique will not work, since it will always pick the least amount of regularization, i.e., λˆ = 0.
To see this, note that
argmin
λ
min
θ
Rλ(θ, D) = argmin
λ
min
θ
R(θ, D) + λC(θ) (5.88)
which is minimized by setting λ = 0 The problem is that the empirical risk underestimates the
population risk, resulting in overfitting when we choose λ. This is called optimism of the training
error.
If we knew the regularized population risk Rλ(θ), instead of the regularized empirical risk Rλ(θ, D),
we could use it to pick a model of the right complexity (e.g., value of λ). This is known as structural
risk minimization [Vap98]. There are two main ways to estimate the population risk for a
given model (value of λ), namely cross-validation (Section 5.4.3), and statistical learning theory
(Section 5.4.4), which we discuss below.
5.4.3 Cross-validation
In this section, we discuss a simple way to estimate the population risk for a supervised learning
setup. We simply partition the dataset into two, the part used for training the model, and a second
part, called the validation set or holdout set, used for assessing the risk. We can fit the model on
the training set, and use its performance on the validation set as an approximation to the population
risk.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.4. Empirical risk minimization 191
To explain the method in more detail, we need some notation. First we make the dependence of
the empirical risk on the dataset more explicit as follows:
Rλ(θ, D) = 1
|D|
X
(x,y)∈D
`(y, f(x; θ)) + λC(θ) (5.89)
Let us also define θˆ
λ(D) = argminθ Rλ(D, θ). Finally, let Dtrain and Dvalid be a partition of D.
(Often we use about 80% of the data for the training set, and 20% for the validation set.)
For each model λ, we fit it to the training set to get θˆ
λ(Dtrain). We then use the unregularized
empirical risk on the validation set as an estimate of the population risk. This is known as the
validation risk:
R
val
λ , R0(θˆ
λ(Dtrain), Dvalid) (5.90)
Note that we use different data to train and evaluate the model.
The above technique can work very well. However, if the number of training cases is small, this
technique runs into problems, because the model won’t have enough data to train on, and we won’t
have enough data to make a reliable estimate of the future performance.
A simple but popular solution to this is to use cross validation (CV). The idea is as follows: we
split the training data into K folds; then, for each fold k ∈ {1, . . . , K}, we train on all the folds but
the k’th, and test on the k’th, in a round-robin fashion, as sketched in Figure 4.6. Formally, we have
R
cv
λ ,
1
K
X
K
k=1
R0(θˆ
λ(D−k), Dk) (5.91)
where Dk is the data in the k’th fold, and D−k is all the other data. This is called the cross-validated
risk. Figure 4.6 illustrates this procedure for K = 5. If we set K = N, we get a method known as
leave-one-out cross-validation, since we always train on N − 1 items and test on the remaining
one.
We can use the CV estimate as an objective inside of an optimization routine to pick the optimal
hyperparameter, λˆ = argminλ Rcv
λ
. Finally we combine all the available data (training and validation),
and re-estimate the model parameters using θˆ = argminθ Rλˆ(θ, D).
5.4.4 Statistical learning theory *
The principal problem with cross validation is that it is slow, since we have to fit the model multiple
times. This motivates the desire to compute analytic approximations or bounds on the population
risk. This is studied in the field of statistical learning theory (SLT) (see e.g., [Vap98]).
More precisely, the goal of SLT is to upper bound the generalization error with a certain probability.
If the bound is satisfied, then we can be confident that a hypothesis that is chosen by minimizing
the empirical risk will have low population risk. In the case of binary classifiers, this means the
hypothesis will make the correct predictions; in this case we say it is probably approximately
correct, and that the hypothesis class is PAC learnable (see e.g., [KV94] for details).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license192 Chapter 5. Decision Theory
5.4.4.1 Bounding the generalization error
In this section, we establish conditions under which we can prove that a hypothesis class is PAC
learnable. Let us initially consider the case where the hypothesis space is finite, with size dim(H) = |H|.
In other words, we are selecting a hypothesis from a finite list, rather than optimizing real-valued
parameters. In this case, we can prove the following.
Theorem 5.4.1. For any data distribution p
∗
, and any dataset D of size N drawn from p
∗
, the
probability that the generalization error of a binary classifier will be more than , in the worst case,
is upper bounded as follows:
P

max
h∈H
|R(h) − R(h, D)| > 
≤ 2 dim(H)e
−2N2
(5.92)
where R(h, D) = 1
N
PN
i=1 I(f(xi) 6= y
∗
i
) is the empirical risk, and R(h) = E [I(f(x) 6= y
∗
)] is the
population risk.
Proof. Before we prove this, we introduce two useful results. First, Hoeffding’s inequality, which
states that if E1, . . . , EN ∼ Ber(θ), then, for any  > 0,
P(|E − θ| > ) ≤ 2e
−2N2
(5.93)
where E =
1
N
PN
i=1 Ei
is the empirical error rate, and θ is the true error rate. Second, the union
bound, which says that if A1, . . . , Ad are a set of events, then P(∪
d
i=1Ai) ≤
Pd
i=1 P(Ai). Using
these results, we have
P

max
h∈H
|R(h) − R(h, D)| > 
= P
 [
h∈H
|R(h) − R(h, D)| > !
(5.94)
≤
X
h∈H
P (|R(h) − R(h, D)| > ) (5.95)
≤
X
h∈H
2e
−2N2
= 2 dim(H)e
−2N2
(5.96)
This bound tells us that the optimism of the training error increases with dim(H) but decreases
with N = |D|, as is to be expected.
5.4.4.2 VC dimension
If the hypothesis space H is infinite (e.g., we have real-valued parameters), we cannot use dim(H) =
|H|. Instead, we can use a quantity called the VC dimension of the hypothesis class, named after
Vapnik and Chervonenkis; this measures the degrees of freedom (effective number of parameters) of
the hypothesis class. See e.g., [Vap98] for the details.
Unfortunately, it is hard to compute the VC dimension for many interesting models, and the upper
bounds are usually very loose, making this approach of limited practical value. However, various
other, more practical, estimates of generalization error have recently been devised, especially for
DNNs, such as [Jia+20].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.5. Frequentist hypothesis testing * 193
(a) (b)
Figure 5.10: (a) Illustration of the Neyman-Pearson hypothesis testing paradigm. Generated by code at
figures.probml.ai/book1/5.10. (b) Two hypothetical two-sided power curves. B dominates A. Adapted from
Figure 6.3.5 of [LM86]. Generated by code at figures.probml.ai/book1/5.10.
5.5 Frequentist hypothesis testing *
Suppose we have two hypotheses, known as the null hypothesis H0 and an alternative hypothesis
H1, and we want to choose the one we think is correct on the basis of a dataset D. We could use a
Bayesian approach and compute the Bayes factor p(H0|D)/p(H1|D), as we discussed in Section 5.2.1.
However, this requires integrating over all possible parameterizations of the models H0 and H1, which
can be computationally difficult, and which can be sensitive to the choice of prior. In this section, we
consider a frequentist approach to the problem.
5.5.1 Likelihood ratio test
If we use 0-1 loss, and assume p(H0) = p(H1), then the optimal decision rule is to accept H0 iff
p(D|H0)
p(D|H1) > 1. This is called the likelihood ratio test. We give some examples of this below.
5.5.1.1 Example: comparing Gaussian means
Suppose we are interested in testing whether some data comes from a Gaussian with mean µ0 or
from a Gaussian with mean µ1. (We assume a known shared variance σ
2
.) This is illustrated in
Figure 5.10a, where we plot p(x|H0) and p(x|H1). We can derive the likelihood ratio as follows:
p(D|H0)
p(D|H1)
=
exp 
−
1
2σ2
PN
n=1(xn − µ0)
2

exp 
−
1
2σ2
PN
n=1(xn − µ1)
2
 (5.97)
= exp 
1
2σ
2
(2Nx(µ0 − µ1) + Nµ2
1 − Nµ2
0
)

(5.98)
We see that this ratio only depends on the observed data via its mean, x. This is an example of a
test statistic test(D), which is a scalar sufficient statistic for hypothesis testing. From Figure 5.10a,
we can see that p(D|H0)
p(D|H1) > 1 iff x < x∗
, where x
∗
is the point where the two pdf’s intersect (we are
assuming this point is unique).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license194 Chapter 5. Decision Theory
5.5.1.2 Simple vs compound hypotheses
In Section 5.5.1.1, the parameters for the null and alternative hypotheses were either fully specified
(µ0 and µ1) or shared (σ
2
). This is called a simple hypothesis test. In general, a hypothesis might
not fully specify all the parameters; this is called a compound hypothesis. In this case, we should
integrate out these unknown parameters, as in the Bayesian approach, since a hypothesis with more
parameters will always have higher likelihood. As an approximation, we can “maximize them out”,
which gives us the maximum likelihood ratio test:
p(H0|D)
p(H1|D)
=
R
θ∈H0
p(θ)pθ(D)
R
θ∈H1
p(θ)pθ(D)
≈
maxθ∈H0 pθ(D)
maxθ∈H1 pθ(D)
(5.99)
5.5.2 Null hypothesis significance testing (NHST)
Rather than assuming 0-1 loss, it is conventional to design the decision rule so that it has a type I
error rate (the probability of accidentally rejecting the null hypothesis H0) of α. (See Section 5.1.3
for details on error rates of binary decision rules.) The error rate α is called the significance of the
test. Hence the overall approach is called null hypothesis significance testing or NHST.
In our Gaussian mean example, we see from Figure 5.10a that the type I error rate is the vertical
shaded blue area:
α(µ0) = p(reject H0|H0 is true) (5.100)
= p(X(D˜ ) > x∗
|D ∼˜ H0) (5.101)
= p

X − µ0
σ/√
N
>
x
∗ − µ0
σ/√
N

(5.102)
Hence x
∗ = zασ/√
N + µ0, where zα is the upper α quantile of the standard Normal.
The type II error rate is the probability we accidentally accept the null when the alternative is
true:
β(µ1) = p(type II error) = p(accept H0|H1 is true) = p(test(D˜ ) < test∗
|D ∼˜ H1) (5.103)
This is shown by the horizontal shaded red area in Figure 5.10a. We define the power of a test
as 1 − β(µ1); this is the probability that we reject H0 given that H1 is true. In other words, it is
the ability to correctly recognize that the null hypothesis is wrong. Clearly the least power occurs
if µ1 = µ0 (so the curves overlap); in this case, we have 1 − β(µ1) = α(µ0). As µ1 and µ0 become
further apart, the power approaches 1 (because the shaded red area gets smaller, β → 0). If we have
two tests, A and B, where power(B) ≥ power(A) for the same type I error rate, we say B dominates
A. See Figure 5.10b. A test with highest power under H1 amongst all tests with significance level α
is called a most powerful test. It turns out that the likelihood ratio test is a most powerful test, a
result known as the Neyman-Pearson lemma.
5.5.3 p-values
When we reject H0 we often say the result is statistically significant at level α. However, the
result may be statistically significant but not practically significant, depending on how far from the
decision boundary the test statistic is.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.5. Frequentist hypothesis testing * 195
Rather than arbitrarily declaring a result as significant or not, it is preferable to quote the p-value.
This is defined as the probability, under the null hypothesis, of observing a test statistic that is as
large or larger than that actually observed:
pval(test(D)) , Pr(test(D˜ ) ≥ test(D)|D ∼˜ H0) (5.104)
In other words, pval(testobs) , Pr(testnull ≥ testobs), where testobs = test(D) and testnull = test(D˜ ),
where D ∼˜ H0 is hypothetical future data. To see the connection with hypothesis testing, suppose
we pick a decision threshold t
∗
such that Pr(test(D˜ ) ≥ t
∗
|H0) = α. If we set t
∗ = test(D), then
α = pval(test(D)).
Thus if we only accept hypotheses where the p-value is less than α = 0.05, then 95% of the time we
will correctly reject the null hypothesis. However, this does not mean that the alternative hypothesis
H1 is true with probability 0.95. Indeed, even most scientists misinterpret p-values.4 The quantity
that most people want to compute is the Bayesian posterior p(H1|D) = 0.95. For more on this
important distinction, see Section 5.5.4.
5.5.4 p-values considered harmful
A p-value is often interpreted as the likelihood of the data under the null hypothesis, so small values
are interpreted to mean that H0 is unlikely, and therefore that H1 is likely. The reasoning is roughly
as follows:
If H0 is true, then this test statistic would probably not occur. This statistic did occur.
Therefore H0 is probably false.
However, this is invalid reasoning. To see why, consider the following example (from [Coh94]):
If a person is an American, then he is probably not a member of Congress. This person is a
member of Congress. Therefore he is probably not an American.
This is obviously fallacious reasoning. By contrast, the following logical argument is valid reasoning:
If a person is a Martian, then he is not a member of Congress. This person is a member of
Congress. Therefore he is not a Martian.
The difference between these two cases is that the Martian example is using deduction, that is,
reasoning forward from logical definitions to their consequences. More precisely, this example uses a
rule from logic called modus tollens, in which we start out with a definition of the form P ⇒ Q;
when we observe ¬Q, we can conclude ¬P. By contrast, the American example concerns induction,
that is, reasoning backwards from observed evidence to probable (but not necessarily true) causes
using statistical regularities, not logical definitions.
To perform induction, we need to use probabilistic inference (as explained in detail in [Jay03]). In
particular, to compute the probability of the null hypothesis, we should use Bayes rule, as follows:
p(H0|D) = p(D|H0)p(H0)
p(D|H0)p(H0) + p(D|H1)p(H1)
(5.105)
4. See e.g., https://fivethirtyeight.com/features/not-even-scientists-can-easily-explain-p-values/.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license196 Chapter 5. Decision Theory
Ineffective Effective
“Not significant” 171 4 175
“Significant” 9 16 25
180 20 200
Table 5.8: Some statistics of a hypothetical clinical trial. Source: [SAM04, p74].
If the prior is uniform, so p(H0) = p(H1) = 0.5, this can be rewritten in terms of the likelihood
ratio LR = p(D|H0)/p(D|H1) as follows:
p(H0|D) = LR
LR + 1
(5.106)
In the American Congress example, D is the observation that the person is a member of Congress.
The null hypothesis H0 is that the person is American, and the alternative hypothesis H1 is that the
person is not American. We assume that p(D|H0) is low, since most Americans are not members of
Congress. However, p(D|H1) is also low — in fact, in this example, it is 0, since only Americans can
be members of Congress. Hence LR = ∞, so p(H0|D) = 1.0, as intuition suggests. Note, however,
that NHST ignores p(D|H1) as well as the prior p(H0), so it gives the wrong results — not just in
this problem, but in many problems.
In general there can be huge differences between p-values and p(H0|D). In particular, [SBB01]
show that even if the p-value is as low as 0.05, the posterior probability of H0 can be as high as 30%
or more, even with a uniform prior.
Consider this concrete example from [SAM04, p74]. Suppose 200 clinical trials are carried out for
some drug. Suppose we perform a statistical test of whether the drug has a significant effect or not.
The test has a type I error rate of α = 0.05 and a type II error rate of β = 0.2. The resulting data is
shown in Table 5.8.
We can compute the probability that the drug is not effective, given that the result is supposedly
“significant”, as follows:
p(H0|’significant’) = p(’significant’|H0)p(H0)
p(’significant’|H0)p(H0) + p(’significant’|H1)p(H1)
(5.107)
=
p(type I error)p(H0)
p(type I error)p(H0) + (1 − p(type II error))p(H1)
(5.108)
=
αp(H0)
αp(H0) + (1 − β)p(H1)
(5.109)
If we have prior knowledge, based on past experience, that most (say 90%) drugs are ineffective,
then we find p(H0|’significant’) = 0.36, which is much more than the 5% probability people usually
associate with a p-value of α = 0.05.
Thus we should distrust claims of statistical significance if they violate our prior knowledge.
5.5.5 Why isn’t everyone a Bayesian?
In Section 4.7.5 and Section 5.5.4, we have seen that inference based on frequentist principles can
exhibit various forms of counter-intuitive behavior that can sometimes contradict common sense
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.5. Frequentist hypothesis testing * 197
Figure 5.11: Cartoon illustrating the difference between frequentists and Bayesians. (The p < 0.05 comment
is explained in Section 5.5.4. The betting comment is a reference to the Dutch book theorem, which essentially
proves that the Bayesian approach to gambling (and other decision theory problems) is optimal, as explained
in e.g., [Háj08].) From https: // xkcd. com/ 1132/ . Used with kind permission of Rundall Munroe (author
of xkcd).
reason, as has been pointed out in multiple articles (see e.g., [Mat98; MS11; Kru13; Gel16; Hoe+14;
Lyu+20; Cha+19b; Cla21]).
The fundamental reason is that frequentist inference violates the likelihood principle [BW88],
which says that inference should be based on the likelihood of the observed data, not on hypothetical
future data that you have not observed. Bayes obviously satisfies the likelihood principle, and
consequently does not suffer from these pathologies.
Given these fundamental flaws of frequentist statistics, and the fact that Bayesian methods do not
have such flaws, an obvious question to ask is: “Why isn’t everyone a Bayesian?” The (frequentist)
statistician Bradley Efron wrote a paper with exactly this title [Efr86]. His short paper is well worth
reading for anyone interested in this topic. Below we quote his opening section:
The title is a reasonable question to ask on at least two counts. First of all, everyone used to
be a Bayesian. Laplace wholeheartedly endorsed Bayes’s formulation of the inference problem,
and most 19th-century scientists followed suit. This included Gauss, whose statistical work is
usually presented in frequentist terms.
A second and more important point is the cogency of the Bayesian argument. Modern
statisticians, following the lead of Savage and de Finetti, have advanced powerful theoretical
arguments for preferring Bayesian inference. A byproduct of this work is a disturbing catalogue
of inconsistencies in the frequentist point of view.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license198 Chapter 5. Decision Theory
Nevertheless, everyone is not a Bayesian. The current era (1986) is the first century in which
statistics has been widely used for scientific reporting, and in fact, 20th-century statistics is
mainly non-Bayesian. However, Lindley (1975) predicts a change for the 21st century.
Time will tell whether Lindley was right. However, the trends seem to be going in this direction.
For example, some journals have banned p-values [TM15; AGM19], and the journal The American
Statistician (produced by the American Statistical Association) published a whole special issue
warning about the use of p-values and NHST [WSL19].
Traditionally, computation has been a barrier to using Bayesian methods, but this is less of an issue
these days, due to faster computers and better algorithms (which we will discuss in the sequel to this
book, [Mur22]). Another, more fundamental, concern is that the Bayesian approach is only as correct
as its modeling assumptions. However, this criticism also applies to frequentist methods, since the
sampling distribution of an estimator must be derived using assumptions about the data generating
mechanism. (In fact [BT73] show that the sampling distributions for the MLE for common models
are identical to the posterior distributions under a noninformative prior.) Fortunately, we can check
modeling assumptions empirically using cross validation (Section 4.5.5), calibration, and Bayesian
model checking. We discuss these topics in the sequel to this book, [Mur22].
To summarize, it is worth quoting Donald Rubin, who wrote a paper [Rub84] called “Bayesianly
Justifiable and Relevant Frequency Calculations for the Applied Statistician”. In it, he writes
The applied statistician should be Bayesian in principle and calibrated to the real world in
practice. [They] should attempt to use specifications that lead to approximately calibrated pro￾cedures under reasonable deviations from [their assumptions]. [They] should avoid models that
are contradicted by observed data in relevant ways — frequency calculations for hypothetical
replications can model a model’s adequacy and help to suggest more appropriate models.
5.6 Exercises
Exercise 5.1 [Reject option in classifiers]
(Source: [DHS01, Q2.13].) In many classification problems one has the option either of assigning x to class j
or, if you are too uncertain, of choosing the reject option. If the cost for rejects is less than the cost of
falsely classifying the object, it may be the optimal action. Let αi mean you choose action i, for i = 1 : C + 1,
where C is the number of classes and C + 1 is the reject action. Let Y = j be the true (but unknown) state
of nature. Define the loss function as follows
λ(αi|Y = j) =



0 if i = j and i, j ∈ {1, . . . , C}
λr if i = C + 1
λs otherwise
(5.110)
In other words, you incur 0 loss if you correctly classify, you incur λr loss (cost) if you choose the reject
option, and you incur λs loss (cost) if you make a substitution error (misclassification).
a. Show that the minimum risk is obtained if we decide Y = j if p(Y = j|x) ≥ p(Y = k|x) for all k (i.e., j is
the most probable class) and if p(Y = j|x) ≥ 1 −
λr
λs
; otherwise we decide to reject.
b. Describe qualitatively what happens as λr/λs is increased from 0 to 1 (i.e., the relative cost of rejection
increases).
Exercise 5.2 [Newsvendor problem *]
Consider the following classic problem in decision theory / economics. Suppose you are trying to decide how
much quantity Q of some product (e.g., newspapers) to buy to maximize your profits. The optimal amount
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20225.6. Exercises 199
will depend on how much demand D you think there is for your product, as well as its cost to you C and its
selling price P. Suppose D is unknown but has pdf f(D) and cdf F(D). We can evaluate the expected profit
by considering two cases: if D > Q, then we sell all Q items, and make profit π = (P − C)Q; but if D < Q,
we only sell D items, at profit (P − C)D, but have wasted C(Q − D) on the unsold items. So the expected
profit if we buy quantity Q is
Eπ(Q) = Z ∞
Q
(P − C)Qf(D)dD +
Z Q
0
(P − C)Df(D)dD −
Z Q
0
C(Q − D)f(D)dD (5.111)
Simplify this expression, and then take derivatives wrt Q to show that the optimal quantity Q
∗
(which
maximizes the expected profit) satisfies
F(Q
∗
) = P − C
P
(5.112)
Exercise 5.3 [Bayes factors and ROC curves *]
Let B = p(D|H1)/p(D|H0) be the Bayes factor in favor of model 1. Suppose we plot two ROC curves, one
computed by thresholding B, and the other computed by thresholding p(H1|D). Will they be the same or
different? Explain why.
Exercise 5.4 [Posterior median is optimal estimate under L1 loss]
Prove that the posterior median is the optimal estimate under L1 loss.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license6 Information Theory
In this chapter, we introduce a few basic concepts from the field of information theory. More
details can be found in other books such as [Mac03; CT06], as well as the sequel to this book, [Mur22].
6.1 Entropy
The entropy of a probability distribution can be interpreted as a measure of uncertainty, or lack
of predictability, associated with a random variable drawn from a given distribution, as we explain
below.
We can also use entropy to define the information content of a data source. For example,
suppose we observe a sequence of symbols Xn ∼ p generated from distribution p. If p has high
entropy, it will be hard to predict the value of each osbervation Xn. Hence we say that the dataset
D = (X1, . . . , Xn) has high information content. By contrast, if p is a degenerate distribution with 0
entropy (the minimal value), then every Xn will be the same, so D does not contain much information.
(All of this can be formalized in terms of data compression, as we discuss in the sequel to this book.)
6.1.1 Entropy for discrete random variables
The entropy of a discrete random variable X with distribution p over K states is defined by
H (X) , −
X
K
k=1
p(X = k) log2 p(X = k) = −EX [log p(X)] (6.1)
(Note that we use the notation H (X) to denote the entropy of the rv with distribution p, just as
people write V [X] to mean the variance of the distribution associated with X; we could alternatively
write H (p).) Usually we use log base 2, in which case the units are called bits (short for binary
digits). For example, if X ∈ {1, . . . , 5} with histogram distribution p = [0.25, 0.25, 0.2, 0.15, 0.15], we
find H = 2.29 bits. If we use log base e, the units are called nats.
The discrete distribution with maximum entropy is the uniform distribution. Hence for a K-ary
random variable, the entropy is maximized if p(x = k) = 1/K; in this case, H (X) = log2 K. To see
this, note that
H (X) = −
X
K
k=1
1
K
log(1/K) = − log(1/K) = log(K) (6.2)202 Chapter 6. Information Theory
0 0.5 1
0
0.5
1
p(X = 1)
H(X)
Figure 6.1: Entropy of a Bernoulli random variable as a function of θ. The maximum entropy is log2 2 = 1.
Generated by code at figures.probml.ai/book1/6.1.
(a)
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
Sequence Position
0
1
2
Bits
(b)
Figure 6.2: (a) Some aligned DNA sequences. Each row is a sequence, each column is a location within the
sequence. (b) The corresponding position weight matrix represented as a sequence logo. Each column
represents a probablity distribution over the alphabet {A, C, G, T} for the corresponding location in the sequence.
The size of the letter is proportional to the probability. The height of column t is given by 2 − Ht, where
0 ≤ Ht ≤ 2 is the entropy (in bits) of the distribution pt. Thus deterministic distributions (with an entropy
of 0, corresponding to highly conserved locations) have height 2, and uniform distributions (with an entropy
of 2) have height 0. Generated by code at figures.probml.ai/book1/6.2.
Conversely, the distribution with minimum entropy (which is zero) is any delta-function that puts all
its mass on one state. Such a distribution has no uncertainty.
For the special case of binary random variables, X ∈ {0, 1}, we can write p(X = 1) = θ and
p(X = 0) = 1 − θ. Hence the entropy becomes
H (X) = −[p(X = 1) log2 p(X = 1) + p(X = 0) log2 p(X = 0)] (6.3)
= −[θ log2
θ + (1 − θ) log2
(1 − θ)] (6.4)
This is called the binary entropy function, and is also written H (θ). We plot this in Figure 6.1.
We see that the maximum value of 1 bit occurs when the distribution is uniform, θ = 0.5. A fair coin
requires a single yes/no question to determine its state.
As an interesting application of entropy, consider the problem of representing DNA sequence
motifs, which is a distribution over short DNA strings. We can estimate this distribution by aligning
a set of DNA sequences (e.g., from different species), and then estimating the empirical distribution
of each possible nucleotide from the 4 letter alphabet X ∼ {A, C, G, T} at each location t in the ith
sequence as follows:
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20226.1. Entropy 203
Nt =
 X
N
i=1
I(Xit = A),
X
N
i=1
I(Xit = C),
X
N
i=1
I(Xit = G),
X
N
i=1
I(Xit = T)
!
(6.5)
θˆ
t = Nt/N, (6.6)
This Nt is a length four vector counting the number of times each letter appears at each location
amongst the set of sequences. This θˆ
t distribution is known as a motif. We can also compute the
most probable letter in each location; this is called the consensus sequence.
One way to visually summarize the data is by using a sequence logo, as shown in Figure 6.2(b).
We plot the letters A, C, G and T, with the most probable letter on the top; the height of the t’th
bar is defined to be 0 ≤ 2 − Ht ≤ 2, where Ht is the entropy of θˆ
t (note that 2 is the maximum
possible entropy for a distribution over 4 letters). Thus tall bars correspond to nearly deterministic
distributions, which are the locations that are conserved by evolution (e.g., because they are part of
a gene coding region). In this example, we see that column 13 is all G’s, and hence has height 2.
Estimating the entropy of a random variable with many possible states requires estimating its
distribution, which can require a lot of data. For example, imagine if X represents the identity of
a word in an English document. Since there is a long tail of rare words, and since new words are
invented all the time, it can be difficult to reliably estimate p(X) and hence H (X). For one possible
solution to this problem, see [VV13].
6.1.2 Cross entropy
The cross entropy between distribution p and q is defined by
H(p, q) , −
X
K
k=1
pk log qk (6.7)
One can show that the cross entropy is the expected number of bits needed to compress some data
samples drawn from distribution p using a code based on distribution q. This can be minimized by
setting q = p, in which case the expected number of bits of the optimal code is H(p, p) = H(p) — this
is known as Shannon’s source coding theorem (see e.g., [CT06]).
6.1.3 Joint entropy
The joint entropy of two random variables X and Y is defined as
H (X, Y ) = −
X
x,y
p(x, y) log2 p(x, y) (6.8)
For example, consider choosing an integer from 1 to 8, n ∈ {1, . . . , 8}. Let X(n) = 1 if n is even, and
Y (n) = 1 if n is prime:
n 1 2 3 4 5 6 7 8
X 0 1 0 1 0 1 0 1
Y 0 1 1 0 1 0 1 0
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license204 Chapter 6. Information Theory
The joint distribution is
p(X, Y ) Y = 0 Y = 1
X = 0 1
8
3
8
X = 1 3
8
1
8
so the joint entropy is given by
H (X, Y ) = −

1
8
log2
1
8
+
3
8
log2
3
8
+
3
8
log2
3
8
+
1
8
log2
1
8

= 1.81 bits (6.9)
Clearly the marginal probabilities are uniform: p(X = 1) = p(X = 0) = p(Y = 0) = p(Y =
1) = 0.5, so H (X) = H (Y ) = 1. Hence H (X, Y ) = 1.81 bits < H (X) + H (Y ) = 2 bits. In
fact, this upper bound on the joint entropy holds in general. If X and Y are independent, then
H (X, Y ) = H (X) + H (Y ), so the bound is tight. This makes intuitive sense: when the parts are
correlated in some way, it reduces the “degrees of freedom” of the system, and hence reduces the
overall entropy.
What is the lower bound on H (X, Y )? If Y is a deterministic function of X, then H (X, Y ) = H (X).
So
H (X, Y ) ≥ max{H (X), H (Y )} ≥ 0 (6.10)
Intuitively this says combining variables together does not make the entropy go down: you cannot
reduce uncertainty merely by adding more unknowns to the problem, you need to observe some data,
a topic we discuss in Section 6.1.4.
We can extend the definition of joint entropy from two variables to n in the obvious way.
6.1.4 Conditional entropy
The conditional entropy of Y given X is the uncertainty we have in Y after seeing X, averaged
over possible values for X:
H (Y |X) , Ep(X)
[H (p(Y |X))] (6.11)
=
X
x
p(x) H (p(Y |X = x)) = −
X
x
p(x)
X
y
p(y|x) log p(y|x) (6.12)
= −
X
x,y
p(x, y) log p(y|x) = −
X
x,y
p(x, y) log p(x, y)
p(x)
(6.13)
= −
X
x,y
p(x, y) log p(x, y) −
X
x
p(x) log 1
p(x)
(6.14)
= H (X, Y ) − H (X) (6.15)
If Y is a deterministic function of X, then knowing X completely determines Y , so H (Y |X) = 0.
If X and Y are independent, knowing X tells us nothing about Y and H (Y |X) = H (Y ). Since
H (X, Y ) ≤ H (Y ) + H (X), we have
H (Y |X) ≤ H (Y ) (6.16)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20226.1. Entropy 205
with equality iff X and Y are independent. This shows that, on average, conditioning on data never
increases one’s uncertainty. The caveat “on average” is necessary because for any particular observation
(value of X), one may get more “confused” (i.e., H (Y |x) > H (Y )). However, in expectation, looking
at the data is a good thing to do. (See also Section 6.3.8.)
We can rewrite Equation (6.15) as follows:
H (X1, X2) = H (X1) + H (X2|X1) (6.17)
This can be generalized to get the chain rule for entropy:
H (X1, X2, . . . , Xn) = Xn
i=1
H (Xi
|X1, . . . , Xi−1) (6.18)
6.1.5 Perplexity
The perplexity of a discrete probability distribution p is defined as
perplexity(p) , 2
H(p)
(6.19)
This is often interpreted as a measure of predictability. For example, suppose p is a uniform
distribution over K states. In this case, the perplexity is K. Obviously the lower bound on perplexity
is 2
0 = 1, which will be achieved if the distribution can perfectly predict outcomes.
Now suppose we have an empirical distribution based on data D:
pD(x|D) = 1
N
X
N
n=1
δxn
(x) (6.20)
We can measure how well p predicts D by computing
perplexity(pD, p) , 2
H(pD,p)
(6.21)
Perplexity is often used to evaluate the quality of statistical language models, which is a generative
model for sequences of tokens. Suppose the data is a single long document x of length N, and
suppose p is a simple unigram model. In this case, the cross entropy term is given by
H = −
1
N
X
N
n=1
log p(xn) (6.22)
and hence the perplexity is given by
perplexity(pD, p) = 2H = 2− 1
N log(QN
n=1 p(xn)) =
N
vuutY
N
n=1
1
p(xn)
(6.23)
This is sometimes called the exponentiated cross entropy. We see that this is the geometric
mean of the inverse predictive probabilities.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license206 Chapter 6. Information Theory
In the case of language models, we usually condition on previous words when predicting the next
word. For example, in a bigram model, we use a second order Markov model of the form p(xi
|xi−1).
We define the branching factor of a language model as the number of possible words that can
follow any given word. We can thus interpret the perplexity as the weighted average branching factor.
For example, suppose the model predicts that each word is equally likely, regardless of context, so
p(xi
|xi−1) = 1/K. Then the perplexity is ((1/K)
N )
−1/N = K. If some symbols are more likely than
others, and the model correctly reflects this, its perplexity will be lower than K. However, as we
show in Section 6.2, we have H (p
∗
) ≤ H (p
∗
, p), so we can never reduce the perplexity below the
entropy of the underlying stochastic process p
∗
.
See [JM08, p96] for further discussion of perplexity and its uses in language models.
6.1.6 Differential entropy for continuous random variables *
If X is a continuous random variable with pdf p(x), we define the differential entropy as
h(X) , −
Z
X
dx p(x) log p(x) (6.24)
assuming this integral exists. For example, suppose X ∼ U(0, a). Then
h(X) = −
Z a
0
dx 1
a
log 1
a
= log a (6.25)
Note that, unlike the discrete case, differential entropy can be negative. This is because pdf’s can be
bigger than 1. For example if X ∼ U(0, 1/8), we have h(X) = log2
(1/8) = −3.
One way to understand differential entropy is to realize that all real-valued quantities can only be
represented to finite precision. It can be shown [CT91, p228] that the entropy of an n-bit quantization
of a continuous random variable X is approximately h(X) + n. For example, suppose X ∼ U(0,
1
8
).
Then in a binary representation of X, the first 3 bits to the right of the binary point must be 0 (since
the number is ≤ 1/8). So to describe X to n bits of accuracy only requires n − 3 bits, which agrees
with h(X) = −3 calculated above.
6.1.6.1 Example: Entropy of a Gaussian
The entropy of a d-dimensional Gaussian is
h(N (µ, Σ)) = 1
2
ln |2πeΣ| =
1
2
ln[(2πe)
d
|Σ|] = d
2
+
d
2
ln(2π) + 1
2
ln |Σ| (6.26)
In the 1d case, this becomes
h(N (µ, σ2
)) = 1
2
ln 
2πeσ2

(6.27)
6.1.6.2 Connection with variance
The entropy of a Gaussian increases monotonically as the variance increases. However, this is not
always the case. For example, consider a mixture of two 1d Gaussians centered at -1 and +1. As we
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20226.2. Relative entropy (KL divergence) * 207
move the means further apart, say to -10 and +10, the variance increases (since the average distance
from the overall mean gets larger). However, the entropy remains more or less the same, since we are
still uncertain about where a sample might fall, even if we know that it will be near -10 or +10. (The
exact entropy of a GMM is hard to compute, but a method to compute upper and lower bounds is
presented in [Hub+08].)
6.1.6.3 Discretization
In general, computing the differential entropy for a continuous random variable can be difficult. A
simple approximation is to discretize or quantize the variables. There are various methods for this
(see e.g., [DKS95; KK06] for a summary), but a simple approach is to bin the distribution based on
its empirical quantiles. The critical question is how many bins to use [LM04]. Scott [Sco79] suggested
the following heuristic:
B = N
1/3 max(D) − min(D)
3.5σ(D)
(6.28)
where σ(D) is the empirical standard deviation of the data, and N = |D| is the number of datapoints
in the empirical distribution. However, the technique of discretization does not scale well if X is a
multi-dimensional random vector, due to the curse of dimensionality.
6.2 Relative entropy (KL divergence) *
Given two distributions p and q, it is often useful to define a distance metric to measure how “close”
or “similar” they are. In fact, we will be more general and consider a divergence measure D(p, q)
which quantifies how far q is from p, without requiring that D be a metric. More precisely, we say
that D is a divergence if D(p, q) ≥ 0 with equality iff p = q, whereas a metric also requires that D be
symmetric and satisfy the triangle inequality, D(p, r) ≤ D(p, q)+D(q, r). There are many possible
divergence measures we can use. In this section, we focus on the Kullback-Leibler divergence
or KL divergence, also known as the information gain or relative entropy, between two
distributions p and q.
6.2.1 Definition
For discrete distributions, the KL divergence is defined as follows:
DKL (pkq) ,
X
K
k=1
pk log pk
qk
(6.29)
This naturally extends to continuous distributions as well:
DKL (pkq) ,
Z
dx p(x) log p(x)
q(x)
(6.30)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license208 Chapter 6. Information Theory
6.2.2 Interpretation
We can rewrite the KL as follows:
DKL (pkq) = X
K
k=1
pk log pk
| {z }
− H(p)
−
X
K
k=1
pk log qk
| {z }
H(p,q)
(6.31)
We recognize the first term as the negative entropy, and the second term as the cross entropy. It can
be shown that the cross entropy H(p, q) is a lower bound on the number of bits needed to compress
data coming from distribution p if your code is designed based on distribution q; thus we can interpret
the KL divergence as the “extra number of bits” you need to pay when compressing data samples
if you use the incorrect distribution q as the basis of your coding scheme compared to the true
distribution p.
There are various other interpretations of KL divergence. See the sequel to this book, [Mur22], for
more information.
6.2.3 Example: KL divergence between two Gaussians
For example, one can show that the KL divergence between two multivariate Gaussian distributions
is given by
DKL (N (x|µ1, Σ1)kN (x|µ2, Σ2))
=
1
2

tr(Σ
−1
2 Σ1) + (µ2 − µ1)
TΣ
−1
2
(µ2 − µ1) − D + log 
det(Σ2)
det(Σ1)
 (6.32)
In the scalar case, this becomes
DKL (N (x|µ1, σ1)kN (x|µ2, σ2)) = log σ2
σ1
+
σ
2
1 + (µ1 − µ2)
2
2σ
2
2
−
1
2
(6.33)
6.2.4 Non-negativity of KL
In this section, we prove that the KL divergence is always non-negative.
To do this, we use Jensen’s inequality. This states that, for any convex function f, we have
that
f(
Xn
i=1
λixi) ≤
Xn
i=1
λif(xi) (6.34)
where λi ≥ 0 and Pn
i=1 λi = 1. In words, this result says that f of the average is less than the
average of the f’s. This is clearly true for n = 2, since a convex function curves up above a straight
line connecting the two end points (see Section 8.1.3). To prove for general n, we can use induction.
For example, if f(x) = log(x), which is a concave function, we have
log(Exg(x)) ≥ Ex log(g(x)) (6.35)
We use this result below.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20226.2. Relative entropy (KL divergence) * 209
Theorem 6.2.1. (Information inequality) DKL (pkq) ≥ 0 with equality iff p = q.
Proof. We now prove the theorem following [CT06, p28]. Let A = {x : p(x) > 0} be the support of
p(x). Using the concavity of the log function and Jensen’s inequality (Section 6.2.4), we have that
−DKL (pkq) = −
X
x∈A
p(x) log p(x)
q(x)
=
X
x∈A
p(x) log q(x)
p(x)
(6.36)
≤ log X
x∈A
p(x)
q(x)
p(x)
= log X
x∈A
q(x) (6.37)
≤ log X
x∈X
q(x) = log 1 = 0 (6.38)
Since log(x) is a strictly concave function (− log(x) is convex), we have equality in Equation (6.37) iff
p(x) = cq(x) for some c that tracks the fraction of the whole space X contained in A. We have equality
in Equation (6.38) iff P
x∈A q(x) = P
x∈X q(x) = 1, which implies c = 1. Hence DKL (pkq) = 0 iff
p(x) = q(x) for all x.
This theorem has many important implications, as we will see throughout the book. For example,
we can show that the uniform distribution is the one that maximizes the entropy:
Corollary 6.2.1. (Uniform distribution maximizes the entropy) H (X) ≤ log |X |, where |X | is the
number of states for X, with equality iff p(x) is uniform.
Proof. Let u(x) = 1/|X |. Then
0 ≤ DKL (pku) = X
x
p(x) log p(x)
u(x)
= log |X | − H (X) (6.39)
6.2.5 KL divergence and MLE
Suppose we want to find the distribution q that is as close as possible to p, as measured by KL
divergence:
q
∗ = arg min
q
DKL (pkq) = arg min
q
Z
p(x) log p(x)dx −
Z
p(x) log q(x)dx (6.40)
Now suppose p is the empirical distribution, which puts a probability atom on the observed training
data and zero mass everywhere else:
pD(x) = 1
N
X
N
n=1
δ(x − xn) (6.41)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license210 Chapter 6. Information Theory
Using the sifting property of delta functions we get
DKL (pDkq) = −
Z
pD(x) log q(x)dx + C (6.42)
= −
Z
"
1
N
X
n
δ(x − xn)
#
log q(x)dx + C (6.43)
= −
1
N
X
n
log q(xn) + C (6.44)
where C =
R
p(x)log p(x)dx is a constant independent of q. This is called the cross entropy
objective, and is equal to the average negative log likelihood of q on the training set. Thus we see
that minimizing KL divergence to the empirical distribution is equivalent to maximizing likelihood.
This perspective points out the flaw with likelihood-based training, namely that it puts too
much weight on the training set. In most applications, we do not really believe that the empirical
distribution is a good representation of the true distribution, since it just puts “spikes” on a finite
set of points, and zero density everywhere else. Even if the dataset is large (say 1M images), the
universe from which the data is sampled is usually even larger (e.g., the set of “all natural images” is
much larger than 1M). We could smooth the empirical distribution using kernel density estimation
(Section 16.3), but that would require a similar kernel on the space of images. An alternative,
algorithmic approach is to use data augmentation, which is a way of perturbing the observed
data samples in way that we believe reflects plausible “natural variation”. Applying MLE on this
augmented dataset often yields superior results, especially when fitting models with many parameters
(see Section 19.1).
6.2.6 Forward vs reverse KL
Suppose we want to approximate a distribution p using a simpler distribution q. We can do this by
minimizing DKL (qkp) or DKL (pkq). This gives rise to different behavior, as we discuss below.
First we consider the forwards KL, also called the inclusive KL, defined by
DKL (pkq) = Z
p(x) log p(x)
q(x)
dx (6.45)
Minimizing this wrt q is known as an M-projection or moment projection.
We can gain an understanding of the optimal q by considering inputs x for which p(x) > 0 but
q(x) = 0. In this case, the term log p(x)/q(x) will be infinite. Thus minimizing the KL will force q
to include all the areas of space for which p has non-zero probability. Put another way, q will be
zero-avoiding or mode-covering, and will typically over-estimate the support of p. Figure 6.3(a)
illustrates mode covering where p is a bimodal distribution but q is unimodal.
Now consider the reverse KL, also called the exclusive KL:
DKL (qkp) = Z
q(x) log q(x)
p(x)
dx (6.46)
Minimizing this wrt q is known as an I-projection or information projection.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20226.3. Mutual information * 211
(a) (b) (c)
Figure 6.3: Illustrating forwards vs reverse KL on a bimodal distribution. The blue curves are the contours of
the true distribution p. The red curves are the contours of the unimodal approximation q. (a) Minimizing
forwards KL, DKL (pkq), wrt q causes q to “cover” p. (b-c) Minimizing reverse KL, DKL (qkp) wrt q causes
q to “lock onto” one of the two modes of p. Adapted from Figure 10.3 of [Bis06]. Generated by code at
figures.probml.ai/book1/6.3.
We can gain an understanding of the optimal q by consider inputs x for which p(x) = 0 but
q(x) > 0. In this case, the term log q(x)/p(x) will be infinite. Thus minimizing the exclusive KL will
force q to exclude all the areas of space for which p has zero probability. One way to do this is for q
to put probability mass in very few parts of space; this is called zero-forcing or mode-seeking
behavior. In this case, q will typically under-estimate the support of p. We illustrate mode seeking
when p is bimodal but q is unimodal in Figure 6.3(b-c).
6.3 Mutual information *
The KL divergence gave us a way to measure how similar two distributions were. How should we
measure how dependant two random variables are? One thing we could do is turn the question
of measuring the dependence of two random variables into a question about the similarity of their
distributions. This gives rise to the notion of mutual information (MI) between two random
variables, which we define below.
6.3.1 Definition
The mutual information between rv’s X and Y is defined as follows:
I(X; Y ) , DKL (p(x, y)kp(x)p(y)) = X
y∈Y
X
x∈X
p(x, y) log p(x, y)
p(x) p(y)
(6.47)
(We write I(X; Y ) instead of I(X, Y ), in case X and/or Y represent sets of variables; for example, we
can write I(X; Y, Z) to represent the MI between X and (Y, Z).) For continuous random variables,
we just replace sums with integrals.
It is easy to see that MI is always non-negative, even for continuous random variables, since
I(X; Y ) = DKL (p(x, y)kp(x)p(y)) ≥ 0 (6.48)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license212 Chapter 6. Information Theory
We achieve the bound of 0 iff p(x, y) = p(x)p(y).
6.3.2 Interpretation
Knowing that the mutual information is a KL divergence between the joint and factored marginal
distributions tells us that the MI measures the information gain if we update from a model that
treats the two variables as independent p(x)p(y) to one that models their true joint density p(x, y).
To gain further insight into the meaning of MI, it helps to re-express it in terms of joint and
conditional entropies, as follows:
I(X; Y ) = H (X) − H (X|Y ) = H (Y ) − H (Y |X) (6.49)
Thus we can interpret the MI between X and Y as the reduction in uncertainty about X after
observing Y , or, by symmetry, the reduction in uncertainty about Y after observing X. Incidentally,
this result gives an alternative proof that conditioning, on average, reduces entropy. In particular, we
have 0 ≤ I(X; Y ) = H (X) − H (X|Y ), and hence H (X|Y ) ≤ H (X).
We can also obtain a different interpretation. One can show that
I(X; Y ) = H (X, Y ) − H (X|Y ) − H (Y |X) (6.50)
Finally, one can show that
I(X; Y ) = H (X) + H (Y ) − H (X, Y ) (6.51)
See Figure 6.4 for a summary of these equations in terms of an information diagram. (Formally,
this is a signed measure mapping set expressions to their information-theoretic counterparts [Yeu91].)
6.3.3 Example
As an example, let us reconsider the example concerning prime and even numbers from Section 6.1.3.
Recall that H (X) = H (Y ) = 1. The conditional distribution p(Y |X) is given by normalizing each
row:
Y=0 Y=1
X=0 1
4
3
4
X=1 3
4
1
4
Hence the conditional entropy is
H (Y |X) = −

1
8
log2
1
4
+
3
8
log2
3
4
+
3
8
log2
3
4
+
1
8
log2
1
4

= 0.81 bits (6.52)
and the mutual information is
I(X; Y ) = H (Y ) − H (Y |X) = (1 − 0.81) bits = 0.19 bits (6.53)
You can easily verify that
H (X, Y ) = H (X|Y ) + I(X; Y ) + H (Y |X) (6.54)
= (0.81 + 0.19 + 0.81) bits = 1.81 bits (6.55)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20226.3. Mutual information * 213
Figure 6.4: The marginal entropy, joint entropy, conditional entropy and mutual information represented as
information diagrams. Used with kind permission of Katie Everett.
6.3.4 Conditional mutual information
We can define the conditional mutual information in the obvious way
I(X; Y |Z) , Ep(Z)
[I(X; Y )|Z] (6.56)
= Ep(x,y,z)

log p(x, y|z)
p(x|z)p(y|z)

(6.57)
= H (X|Z) + H (Y |Z) − H (X, Y |Z) (6.58)
= H (X|Z) − H (X|Y, Z) = H (Y |Z) − H (Y |X, Z) (6.59)
= H (X, Z) + H (Y, Z) − H (Z) − H (X, Y, Z) (6.60)
= I(Y ; X, Z) − I(Y ;Z) (6.61)
The last equation tells us that the conditional MI is the extra (residual) information that X tells us
about Y , excluding what we already knew about Y given Z alone.
We can rewrite Equation (6.61) as follows:
I(Z, Y ; X) = I(Z; X) + I(Y ; X|Z) (6.62)
Generalizing to N variables, we get the chain rule for mutual information:
I(Z1, . . . , ZN ; X) = X
N
n=1
I(Zn; X|Z1, . . . , Zn−1) (6.63)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license214 Chapter 6. Information Theory
6.3.5 MI as a “generalized correlation coefficient”
Suppose that (x, y) are jointly Gaussian:

x
y

∼ N 
0,

σ
2 ρσ2
ρσ2 σ
2
 (6.64)
We now show how to compute the mutual information between X and Y .
Using Equation (6.26), we find that the entropy is
h(X, Y ) = 1
2
log 
(2πe)
2 det Σ
=
1
2
log 
(2πe)
2σ
4
(1 − ρ
2
)

(6.65)
Since X and Y are individually normal with variance σ
2
, we have
h(X) = h(Y ) = 1
2
log 
2πeσ2

(6.66)
Hence
I(X, Y ) = h(X) + h(Y ) − h(X, Y ) (6.67)
= log[2πeσ2
] −
1
2
log[(2πe)
2σ
4
(1 − ρ
2
)] (6.68)
=
1
2
log[(2πeσ2
)
2
] −
1
2
log[(2πeσ2
)
2
(1 − ρ
2
)] (6.69)
=
1
2
log 1
1 − ρ
2
= −
1
2
log[1 − ρ
2
] (6.70)
We now discuss some interesting special cases.
1. ρ = 1. In this case, X = Y , and I(X, Y ) = ∞, which makes sense. Observing Y tells us an infinite
amount of information about X (as we know its real value exactly).
2. ρ = 0. In this case, X and Y are independent, and I(X, Y ) = 0, which makes sense. Observing Y
tells us nothing about X.
3. ρ = −1. In this case, X = −Y , and I(X, Y ) = ∞, which again makes sense. Observing Y allows
us to predict X to infinite precision.
Now consider the case where X and Y are scalar, but not jointly Gaussian. In general it can be
difficult to compute the mutual information between continuous random variables, because we have
to estimate the joint density p(X, Y ). For scalar variables, a simple approximation is to discretize
or quantize them, by dividing the ranges of each variable into bins, and computing how many values
fall in each histogram bin [Sco79]. We can then easily compute the MI using the empirical pmf.
Unfortunately, the number of bins used, and the location of the bin boundaries, can have a
significant effect on the results. One way to avoid this is to use K-nearest neighbor distances to
estimate densities in a non-parametric, adaptive way. This is the basis of the KSG estimator for MI
proposed in [KSG04]. This is implemented in the sklearn.feature_selection.mutual_info_regression
function. For papers related to this estimator, see [GOV18; HN19].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20226.3. Mutual information * 215
6.3.6 Normalized mutual information
For some applications, it is useful to have a normalized measure of dependence, between 0 and 1. We
now discuss one way to construct such a measure.
First, note that
I(X; Y ) = H (X) − H (X|Y ) ≤ H (X) (6.71)
= H (Y ) − H (Y |X) ≤ H (Y ) (6.72)
so
0 ≤ I(X; Y ) ≤ min (H (X), H (Y )) (6.73)
Therefore we can define the normalized mutual information as follows:
NMI(X, Y ) = I(X; Y )
min (H (X), H (Y )) ≤ 1 (6.74)
This normalized mutual information ranges from 0 to 1. When NMI(X, Y ) = 0, we have
I(X; Y ) = 0, so X and Y are independent. When NMI(X, Y ) = 1, and H (X) < H (Y ), we have
I(X; Y ) = H (X) − H (X|Y ) = H (X) =⇒ H (X|Y ) = 0 (6.75)
and so X is a deterministic function of Y . For example, suppose X is a discrete random variable
with pmf [0.5, 0.25, 0.25]. We have MI(X, X) = 1.5 (using log base 2), and H(X) = 1.5, so the
normalized MI is 1, as is to be expected.
For continuous random variables, it is harder to normalize the mutual information, because of
the need to estimate the differential entropy, which is sensitive to the level of quantization. See
Section 6.3.7 for further discussion.
6.3.7 Maximal information coefficient
As we discussed in Section 6.3.6, it is useful to have a normalized estimate of the mutual information,
but this can be tricky to compute for real-valued data. One approach, known as the maximal
information coefficient (MIC) [Res+11], is to define the following quantity:
MIC(X, Y ) = max
G
I((X, Y )|G)
log ||G|| (6.76)
where G is the set of 2d grids, and (X, Y )|G represents a discretization of the variables onto this
grid, and ||G|| is min(Gx, Gy), where Gx is the number of grid cells in the x direction, and Gy is
the number of grid cells in the y direction. (The maximum grid resolution depends on the sample
size n; they suggest restricting grids so that GxGy ≤ B(n), where B(n) = n
α, where α = 0.6.) The
denominator is the entropy of a uniform joint distribution; dividing by this ensures 0 ≤ MIC ≤ 1.
The intuition behind this statistic is the following: if there is a relationship between X and Y ,
then there should be some discrete gridding of the 2d input space that captures this. Since we don’t
know the correct grid to use, MIC searches over different grid resolutions (e.g., 2x2, 2x3, etc), as well
as over locations of the grid boundaries. Given a grid, it is easy to quantize the data and compute
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license216 Chapter 6. Information Theory
Figure 6.5: Illustration of how the maximal information coefficient (MIC) is computed. (a) We search over
different grid resolutions, and grid cell locations, and compute the MI for each. (b) For each grid resolution
(k, l), we define set M(k, l) to be the maximum MI for any grid of that size, normalized by log(min(k, l)). (c)
We visualize the matrix M. The maximum entry (denoted by a star) is defined to be the MIC. From Figure 1
of [Res+11]. Used with kind permission of David Reshef.
MI. We define the characteristic matrix M(k, l) to be the maximum MI achievable by any grid
of size (k, l), normalized by log(min(k, l)). The MIC is then the maximum entry in this matrix,
maxkl≤B(n) M(k, l). See Figure 6.5 for a visualization of this process.
In [Res+11], they show that this quantity exhibits a property known as equitability, which means
that it gives similar scores to equally noisy relationships, regardless of the type of relationship (e.g.,
linear, non-linear, non-functional).
In [Res+16], they present an improved estimator, called MICe, which is more efficient to compute,
and only requires optimizing over 1d grids, which can be done in O(n) time using dynamic program￾ming. They also present another quantity, called TICe (total information content), that has higher
power to detect relationships from small sample sizes, but lower equitability. This is defined to be
P
kl≤B(n) M(k, l). They recommend using TICe to screen a large number of candidate relationships,
and then using MICe to quantify the strength of the relationship. For an efficient implementation of
both of these metrics, see [Alb+18].
We can interpret MIC of 0 to mean there is no relationship between the variables, and 1 to represent
a noise-free relationship of any form. This is illustrated in Figure 6.6. Unlike correlation coefficients,
MIC is not restricted to finding linear relationships. For this reason, the MIC has been called “a
correlation for the 21st century” [Spe11].
In Figure 6.7, we give a more interesting example, from [Res+11]. The data consists of 357 variables
measuring a variety of social, economic, health and political indicators, collected by the World Health
Organization (WHO). On the left of the figure, we see the correlation coefficient (CC) plotted against
the MIC for all 63,546 variable pairs. On the right of the figure, we see scatter plots for particular
pairs of variables, which we now discuss:
• The point marked C (near 0,0 on the plot) has a low CC and a low MIC. The corresponding
scatter plot makes it clear that there is no relationship between these two variables (percentage of
lives lost to injury and density of dentists in the population).
• The points marked D and H have high CC (in absolute value) and high MIC, because they
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20226.3. Mutual information * 217
Pearson r=1.0
MIC=1.0
Pearson r=0.8
MIC=0.5
Pearson r=0.4
MIC=0.2
Pearson r=0.0
MIC=0.1
Pearson r=-0.4
MIC=0.2
Pearson r=-0.8
MIC=0.5
Pearson r=-1.0
MIC=1.0
Pearson r=1.0
MIC=1.0
Pearson r=1.0
MIC=1.0
Pearson r=1.0
MIC=1.0
Pearson r=-0.1
MIC=0.2
Pearson r=-1.0
MIC=1.0
Pearson r=-1.0
MIC=1.0
Pearson r=-1.0
MIC=1.0
Pearson r=0.1
MIC=0.8
Pearson r=-0.0
MIC=0.2
Pearson r=-0.0
MIC=0.2
Pearson r=0.0
MIC=0.4
Pearson r=-0.1
MIC=0.4
Pearson r=0.0
MIC=0.5
Pearson r=-0.0
MIC=0.1
Figure 6.6: Plots of some 2d distributions and the corresponding estimate of correlation coefficient R
2
and the maximal information coefficient (MIC). Compare to Figure 3.1. Generated by code at fig￾ures.probml.ai/book1/6.6.
represent nearly linear relationships.
• The points marked E, F, and G have low CC but high MIC. This is because they correspond
to non-linear (and sometimes, as in the case of E and F, non-functional, i.e., one-to-many)
relationships between the variables.
6.3.8 Data processing inequality
Suppose we have an unknown variable X, and we observe a noisy function of it, call it Y . If we
process the noisy observations in some way to create a new variable Z, it should be intuitively obvious
that we cannot increase the amount of information we have about the unknown quantity, X. This is
known as the data processing inequality. We now state this more formally, and then prove it.
Theorem 6.3.1. Suppose X → Y → Z forms a Markov chain, so that X ⊥ Z|Y . Then I(X; Y ) ≥
I(X;Z).
Proof. By the chain rule for mutual information (Equation (6.62)), we can expand the mutual
information in two different ways:
I(X; Y, Z) = I(X;Z) + I(X; Y |Z) (6.77)
= I(X; Y ) + I(X;Z|Y ) (6.78)
Since X ⊥ Z|Y , we have I(X;Z|Y ) = 0, so
I(X;Z) + I(X; Y |Z) = I(X; Y ) (6.79)
Since I(X; Y |Z) ≥ 0, we have I(X; Y ) ≥ I(X;Z). Similarly one can prove that I(Y ;Z) ≥ I(X;Z).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license218 Chapter 6. Information Theory
Figure 6.7: Left: Correlation coefficient vs maximal information criterion (MIC) for all pairwise relationships
in the WHO data. Right: scatter plots of certain pairs of variables. The red lines are non-parametric
smoothing regressions fit separately to each trend. From Figure 4 of [Res+11]. Used with kind permission of
David Reshef.
6.3.9 Sufficient Statistics
An important consequence of the DPI is the following. Suppose we have the chain θ → D → s(D).
Then
I(θ; s(D)) ≤ I(θ; D) (6.80)
If this holds with equality, then we say that s(D) is a sufficient statistic of the data D for the
purposes of inferring θ. In this case, we can equivalently write θ → s(D) → D, since we can
reconstruct the data from knowing s(D) just as accurately as from knowing θ.
An example of a sufficient statistic is the data itself, s(D) = D, but this is not very useful, since
it doesn’t summarize the data at all. Hence we define a minimal sufficient statistic s(D) as one
which is sufficient, and which contains no extra information about θ; thus s(D) maximally compresses
the data D without losing information which is relevant to predicting θ. More formally, we say s is a
minimal sufficient statistic for D if for all sufficient statistics s
0
(D) there is some function f such that
s(D) = f(s
0
(D)). We can summarize the situation as follows:
θ → s(D) → s
0
(D) → D (6.81)
Here s
0
(D) takes s(D) and adds redundant information to it, thus creating a one-to-many mapping.
P
For example, a minimal sufficient statistic for a set of N Bernoulli trials is simply N and N1 =
n
I(Xn = 1), i.e., the number of successes. In other words, we don’t need to keep track of the
entire sequence of heads and tails and their ordering, we only need to keep track of the total number
of heads and tails. Similarly, for inferring the mean of a Gaussian distribution with known variance
we only need to know the empirical mean and number of samples.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20226.3. Mutual information * 219
6.3.10 Fano’s inequality *
A common method for feature selection is to pick input features Xd which have high mutual
information with the response variable Y . Below we justify why this is a reasonable thing to do.
In particular, we state a result, known as Fano’s inequality, which bounds the probability of
misclassification (for any method) in terms of the mutual information between the features X and
the class label Y .
Theorem 6.3.2. (Fano’s inequality) Consider an estimator Yˆ = f(X) such that Y → X → Yˆ forms
a Markov chain. Let E be the event Yˆ 6= Y , indicating that an error occured, and let Pe = P(Y =6 Yˆ )
be the probability of error. Then we have
H (Y |X) ≤ H

Y |Yˆ

≤ H (E) + Pe log |Y| (6.82)
Since H (E) ≤ 1, as we saw in Figure 6.1, we can weaken this result to get
1 + Pe log |Y| ≥ H (Y |X) (6.83)
and hence
Pe ≥
H (Y |X) − 1
log |Y| (6.84)
Thus minimizing H (Y |X) (which can be done by maximizing I(X; Y )) will also minimize the lower
bound on Pe.
Proof. (From [CT06, p38].) Using the chain rule for entropy, we have
H

E, Y |Yˆ

= H

Y |Yˆ

+ H

E|Y, Yˆ

| {z }
=0
(6.85)
= H

E|Yˆ

+ H

Y |E, Yˆ

(6.86)
Since conditioning reduces entropy (see Section 6.2.4), we have H

E|Yˆ

≤ H (E). The final term
can be bounded as follows:
H

Y |E, Yˆ

= P(E = 0) H

Y |Y, E ˆ = 0
+ P(E = 1) H

Y |Y, E ˆ = 1
(6.87)
≤ (1 − Pe)0 + Pe log |Y| (6.88)
Hence
H

Y |Yˆ

≤ H

E|Yˆ

| {z }
≤H(E)
+ H

Y |E, Yˆ

| {z }
Pe log |Y|
(6.89)
Finally, by the data processing inequality, we have I(Y ; Yˆ ) ≤ I(Y ; X), so H (Y |X) ≤ H

Y |Yˆ

, which
establishes Equation (6.82).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license220 Chapter 6. Information Theory
6.4 Exercises
Exercise 6.1 [Expressing mutual information in terms of entropies *]
Prove the following identities:
I(X; Y ) = H(X) − H(X|Y ) = H(Y ) − H(Y |X) (6.90)
and
H(X, Y ) = H(X|Y ) + H(Y |X) + I(X; Y ) (6.91)
Exercise 6.2 [Relationship between D(p||q) and χ
2
statistic]
(Source: [CT91, Q12.2].)
Show that, if p(x) ≈ q(x), then
DKL (pkq) ≈
1
2
χ
2
(6.92)
where
χ
2 =
X
x
(p(x) − q(x))2
q(x)
(6.93)
Hint: write
p(x) = ∆(x) + q(x) (6.94)
p(x)
q(x)
= 1 + ∆(x)
q(x)
(6.95)
and use the Taylor series expansion for log(1 + x).
log(1 + x) = x −
x
2
2
+
x
3
3
−
x
4
4
· · · (6.96)
for −1 < x ≤ 1.
Exercise 6.3 [Fun with entropies *]
(Source: Mackay.) Consider the joint distribution p(X, Y )
x
1 2 3 4
1 1/8 1/16 1/32 1/32
y 2 1/16 1/8 1/32 1/32
3 1/16 1/16 1/16 1/16
4 1/4 0 0 0
a. What is the joint entropy H(X, Y )?
b. What are the marginal entropies H(X) and H(Y )?
c. The entropy of X conditioned on a specific value of y is defined as
H(X|Y = y) = −
X
x
p(x|y) log p(x|y) (6.97)
Compute H(X|y) for each value of y. Does the posterior entropy on X ever increase given an observation
of Y ?
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20226.4. Exercises 221
d. The conditional entropy is defined as
H(X|Y ) = X
y
p(y)H(X|Y = y) (6.98)
Compute this. Does the posterior entropy on X increase or decrease when averaged over the possible
values of Y ?
e. What is the mutual information between X and Y ?
Exercise 6.4 [Forwards vs reverse KL divergence]
(Source: Exercise 33.7 of [Mac03].) Consider a factored approximation q(x, y) = q(x)q(y) to a joint distribution
p(x, y). Show that to minimize the forwards KL DKL (pkq) we should set q(x) = p(x) and q(y) = p(y), i.e.,
the optimal approximation is a product of marginals
Now consider the following joint distribution, where the rows represent y and the columns x.
1 2 3 4
1 1/8 1/8 0 0
2 1/8 1/8 0 0
3 0 0 1/4 0
4 0 0 0 1/4
Show that the reverse KL DKL (qkp) for this p has three distinct minima. Identify those minima and evaluate
DKL (qkp) at each of them. What is the value of DKL (qkp) if we set q(x, y) = p(x)p(y)?
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license7 Linear Algebra
This chapter is co-authored with Zico Kolter.
7.1 Introduction
Linear algebra is the study of matrices and vectors. In this chapter, we summarize the key material
that we will need throughout the book. Much more information can be found in other sources, such
as [Str09; Kle13; Mol04; TB97; Axl15; Tho17; Agg20].
7.1.1 Notation
In this section, we define some notation.
7.1.1.1 Vectors
A vector x ∈ R
n is a list of n numbers, usually written as a column vector
x =





x1
x2
.
.
.
xn





. (7.1)
The vector of all ones is denoted 1. The vector of all zeros is denoted 0.
The unit vector ei
is a vector of all 0’s, except entry i, which has value 1:
ei = (0, . . . , 0, 1, 0, . . . , 0) (7.2)
This is also called a one-hot vector.
7.1.1.2 Matrices
A matrix A ∈ R
m×n with m rows and n columns is a 2d array of numbers, arranged as follows:
A =





a11 a12 · · · a1n
a21 a22 · · · a2n
.
.
.
.
.
.
.
.
.
.
.
.
am1 am2 · · · amn





. (7.3)224 Chapter 7. Linear Algebra
If m = n, the matrix is said to be square.
We use the notation Aij or Ai,j to denote the entry of A in the ith row and jth column. We use
the notation Ai,: to denote the i’th row and A:,j to denote the j’th column. We treat all vectors as
column vectors by default (so Ai,:
is viewed as a column vector with n entries). We use bold upper
case letters to denote matrices, bold lower case letters to denote vectors, and non-bold letters to
denote scalars.
We can view a matrix as a set of columns stacked along the horizontal axis:
A =


| | |
A:,1 A:,2 · · · A:,n
| | |

 . (7.4)
For brevity, we will denote this by
A = [A:,1, A:,2, . . . , A:,n] (7.5)
We can also view a matrix as a set of rows stacked along the vertical axis:
A =





— AT
1,: —
— AT
2,: —
.
.
.
— AT
m,: —





. (7.6)
For brevity, we will denote this by
A = [A1,:
; A2,:
; . . . ; Am,:
] (7.7)
(Note the use of a semicolon.)
The transpose of a matrix results from “flipping” the rows and columns. Given a matrix A ∈ R
m×n,
its transpose, written AT ∈ R
n×m, is defined as
(AT
)ij = Aji (7.8)
The following properties of transposes are easily verified:
(AT
)
T = A (7.9)
(AB)
T = B
TAT
(7.10)
(A + B)
T = AT + B
T
(7.11)
If a square matrix satisfies A = AT, it is called symmetric. We denote the set of all symmetric
matrices of size n as S
n.
7.1.1.3 Tensors
A tensor (in machine learning terminology) is just a generalization of a 2d array to more than 2
dimensions, as illustrated in Figure 7.1. For example, the entries of a 3d tensor are denoted by Aijk.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.1. Introduction 225
Vector 
Matrix Tensor
64 8x8 4x4x4
Figure 7.1: Illustration of a 1d vector, 2d matrix, and 3d tensor. The colors are used to represent individual
entries of the vector; this list of numbers can also be stored in a 2d matrix, as shown. (In this example, the
matrix is layed out in column-major order, which is the opposite of that used by Python.) We can also reshape
the vector into a 3d tensor, as shown.
(a) (b)
Figure 7.2: Illustration of (a) row-major vs (b) column-major order. From https: // commons. wikimedia.
org/ wiki/ File: Row_ and_ column_ major_ order. svg . Used with kind permission of Wikipedia author
Cmglee.
The number of dimensions is known as the order or rank of the tensor.1
In mathematics, tensors
can be viewed as a way to define multilinear maps, just as matrices can be used to define linear
functions, although we will not need to use this interpretation.
We can reshape a matrix into a vector by stacking its columns on top of each other, as shown in
Figure 7.1. This is denoted by
vec(A) = [A:,1; · · · ; A:,n] ∈ R
mn×1
(7.12)
Conversely, we can reshape a vector into a matrix. There are two choices for how to do this, known
as row-major order (used by languages such as Python and C++) and column-major order
(used by languages such as Julia, Matlab, R and Fortran). See Figure 7.2 for an illustration of the
difference.
1. Note, however, that the rank of a 2d matrix is a different concept, as discussed in Section 7.1.4.3.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license226 Chapter 7. Linear Algebra
(a) (b)
Figure 7.3: (a) Top: A vector v (blue) is added to another vector w (red). Bottom: w is stretched by a factor
of 2, yielding the sum v + 2w. From https: // en. wikipedia. org/ wiki/ Vector_ space . Used with kind
permission of Wikipedia author IkamusumeFan (b) A vector v in R
2
(blue) expressed in terms of different
bases: using the standard basis of R
2
, v = xe1 + ye2 (black), and using a different, non-orthogonal basis:
v = f1 + f2 (red). From https: // en. wikipedia. org/ wiki/ Vector_ space . Used with kind permission of
Wikiepdia author Jakob.scholbach.
7.1.2 Vector spaces
In this section, we discuss some fundamental concepts in linear algebra.
7.1.2.1 Vector addition and scaling
We can view a vector x ∈ R
n as defining a point in n-dimensional Euclidean space. A vector space
is a collection of such vectors, which can be added together, and scaled by scalars (1-dimensional
numbers), in order to create new points. These operations are defined to operate elementwise, in
the obvious way, namely x + y = (x1 + y1, . . . , xn + yn) and cx = (cx1, . . . , cxn), where c ∈ R. See
Figure 7.3a for an illustration.
7.1.2.2 Linear independence, spans and basis sets
A set of vectors {x1, x2, . . . xn} is said to be (linearly) independent if no vector can be represented
as a linear combination of the remaining vectors. Conversely, a vector which can be represented as a
linear combination of the remaining vectors is said to be (linearly) dependent. For example, if
xn =
nX−1
i=1
αixi (7.13)
for some {α1, . . . , αn−1} then xn is dependent on {x1, . . . , xn−1}; otherwise, it is independent of
{x1, . . . , xn−1}.
The span of a set of vectors {x1, x2, . . . , xn} is the set of all vectors that can be expressed as a
linear combination of {x1, . . . , xn}. That is,
span({x1, . . . , xn}) ,
(
v : v =
Xn
i=1
αixi
, αi ∈ R
)
. (7.14)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.1. Introduction 227
It can be shown that if {x1, . . . , xn} is a set of n linearly independent vectors, where each xi ∈ R
n,
then span({x1, . . . , xn}) = R
n. In other words, any vector v ∈ R
n can be written as a linear
combination of x1 through xn.
A basis B is a set of linearly independent vectors that spans the whole space, meaning that
span(B) = R
n. There are often multiple bases to choose from, as illustrated in Figure 7.3b. The
standard basis uses the coordinate vectors e1 = (1, 0, . . . , 0), up to en = (0, 0, . . . , 0, 1). This
lets us translate back and forth between viewing a vector in R
2 as an either an “arrow in the plane”,
rooted at the origin, or as an ordered list of numbers (corresponding to the coefficients for each basis
vector).
7.1.2.3 Linear maps and matrices
A linear map or linear transformation is any function f : V → W such that f(v + w) =
f(v) + f(w) and f(a v) = a f(v) for all v, w ∈ V. Once the basis of V is chosen, a linear map
f : V → W is completely determined by specifying the images of the basis vectors, because any
element of V can be expressed uniquely as a linear combination of them.
Suppose V = R
n and W = R
m. We can compute f(vi) ∈ R
m for each basis vector in V, and
store these along the columns of an m × n matrix A. We can then compute y = f(x) ∈ R
m for any
x ∈ R
n as follows:
y =


Xn
j=1
a1jxj , . . . ,Xn
j=1
amjxj

 (7.15)
This corresponds to multiplying the vector x by the matrix A:
y = Ax (7.16)
See Section 7.2 for more details.
If the function is invertible, we can write
x = A−1y (7.17)
See Section 7.3 for details.
7.1.2.4 Range and nullspace of a matrix
Suppose we view a matrix A ∈ R
m×n as a set of m vectors in R
n. The range (sometimes also called
the column space) of this matrix is the span of the columns of A. In other words,
range(A) , {v ∈ R
m : v = Ax, x ∈ R
n
}. (7.18)
This can be thought of as the set of vectors that can be “reached” or “generated” by A; it is a
subspace of R
m whose dimensionality is given by the rank of A (see Section 7.1.4.3). The nullspace
of a matrix A ∈ R
m×n is the set of all vectors that get mapped to the null vector when multiplied
by A, i.e.,
nullspace(A) , {x ∈ R
n
: Ax = 0}. (7.19)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license228 Chapter 7. Linear Algebra
R R
A
A
A
A
Null space Range
yi = A xi
x1
x2
x3
x4
0
y1
y2
n m
Figure 7.4: Visualization of the nullspace and range of an m × n matrix A. Here y1 = Ax1 and y2 = Ax4,
so y1 and y2 are in the range of A (are reachable from some x). Also Ax2 = 0 and Ax3 = 0, so x2 and x3
are in the nullspace of A (get mapped to 0). We see that the range is often a subset of the input domain of
the mapping.
The span of the rows of A is the complement to the nullspace of A.
See Figure 7.4 for an illustration of the range and nullspace of a matrix. We shall discuss how to
compute the range and nullspace of a matrix numerically in Section 7.5.4 below.
7.1.2.5 Linear projection
The projection of a vector y ∈ R
m onto the span of {x1, . . . , xn} (here we assume xi ∈ R
m) is the
vector v ∈ span({x1, . . . , xn}) , such that v is as close as possible to y, as measured by the Euclidean
norm kv − yk2. We denote the projection as Proj(y; {x1, . . . , xn}) and can define it formally as
Proj(y; {x1, . . . , xn}) = argminv∈span({x1,...,xn})ky − vk2. (7.20)
Given a (full rank) matrix A ∈ R
m×n with m ≥ n, we can define the projection of a vector y ∈ R
m
onto the range of A as follows:
Proj(y; A) = argminv∈R(A)kv − yk2 = A(ATA)
−1ATy . (7.21)
These are the same as the normal equations from Section 11.2.2.2.
7.1.3 Norms of a vector and matrix
In this section, we discuss ways of measuring the “size” of a vector and matrix.
7.1.3.1 Vector norms
A norm of a vector kxk is, informally, a measure of the “length” of the vector. More formally, a
norm is any function f : R
n → R that satisfies 4 properties:
• For all x ∈ R
n, f(x) ≥ 0 (non-negativity).
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.1. Introduction 229
• f(x) = 0 if and only if x = 0 (definiteness).
• For all x ∈ R
n, t ∈ R, f(tx) = |t|f(x) (absolute value homogeneity).
• For all x, y ∈ R
n, f(x + y) ≤ f(x) + f(y) (triangle inequality).
Consider the following common examples:
p-norm kxkp = (Pn
i=1 |xi
|
p
)
1/p, for p ≥ 1.
2-norm kxk2 =
pPn
i=1 x
2
i
, also called Euclidean norm. Note that kxk
2
2 = x
Tx.
1-norm kxk1 =
Pn
i=1 |xi
|.
Max-norm kxk∞ = maxi
|xi
|.
0-norm kxk0 =
Pn
i=1 I(|xi
| > 0). This is a pseudo norm, since it does not satisfy homogeneity.
It counts the number of non-zero elements in x. If we define 0
0 = 0, we can write this as
kxk0 =
Pn
i=1 x
0
i
.
7.1.3.2 Matrix norms
Suppose we think of a matrix A ∈ R
m×n as defining a linear function f(x) = Ax. We define the
induced norm of A as the maximum amount by which f can lengthen any unit-norm input:
||A||p = max
x6=0
||Ax||p
||x||p
= max
||x||=1
||Ax||p (7.22)
Typically p = 2, in which case
||A||2 =
q
λmax(ATA) = max
i
σi (7.23)
where σi
is the i’th singular value.
The nuclear norm, also called the trace norm, is defined as
||A||∗ = tr(√
ATA) = X
i
σi (7.24)
where √
ATA is the matrix square root. Since the singular values are always non-negative, we have
||A||∗ =
X
i
|σi
| = ||σ||1 (7.25)
Using this as a regularizer encourages many singular values to become zero, resulting in a low rank
matrix. More generally, we can define the Schatten p-norm as
||A||p =
 X
i
σ
p
i
(A)
!1/p
(7.26)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license230 Chapter 7. Linear Algebra
If we think of a matrix as a vector, we can define the matrix norm in terms of a vector norm,
||A|| = ||vec(A)||. If the vector norm is the 2-norm, the corresponding matrix norm is the Frobenius
norm:
||A||F =
vuut
Xm
i=1
Xn
j=1
a
2
ij =
q
tr(ATA) = ||vec(A)||2 (7.27)
If A is expensive to evaluate, but Av is cheap (for a random vector v), we can create a stochastic
approximation to the Frobenius norm by using the Hutchinson trace estimator from Equation (7.37)
as follows:
||A||2
F = tr(ATA) = E

v
TATAv

= E

||Av||2
2

(7.28)
where v ∼ N (0, I).
7.1.4 Properties of a matrix
In this section, we discuss various scalar properties of matrices.
7.1.4.1 Trace of a square matrix
The trace of a square matrix A ∈ R
n×n, denoted tr(A), is the sum of diagonal elements in the
matrix:
tr(A) ,
Xn
i=1
Aii. (7.29)
The trace has the following properties, where c ∈ R is a scalar, and A, B ∈ R
n×n are square
matrices:
tr(A) = tr(AT
) (7.30)
tr(A + B) = tr(A) + tr(B) (7.31)
tr(cA) = c tr(A) (7.32)
tr(AB) = tr(BA) (7.33)
tr(A) = Xn
i=1
λi where λi are the eigenvalues of A (7.34)
We also have the following important cyclic permutation property: For A, B, C such that ABC
is square,
tr(ABC) = tr(BCA) = tr(CAB) (7.35)
From this, we can derive the trace trick, which rewrites the scalar inner product x
TAx as follows
x
TAx = tr(x
TAx) = tr(xxTA) (7.36)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.1. Introduction 231
In some cases, it may be expensive to evaluate the matrix A, but we may be able to cheaply
evaluate matrix-vector products Av. Suppose v is a random vector such that E

vvT

= I. In this
case, we can create a Monte Carlo approximation to tr(A) using the following identity:
tr(A) = tr(AE

vvT

) = E

tr(AvvT
)

= E

tr(v
TAv)

(7.37)
This is called the Hutchinson trace estimator [Hut90].
7.1.4.2 Determinant of a square matrix
The determinant of a square matrix, denoted det(A) or |A|, is a measure of how much it changes
a unit volume when viewed as a linear transformation. (The formal definition is rather complex and
is not needed here.)
The determinant operator satisfies these properties, where A, B ∈ R
n×n
|A| = |AT
| (7.38)
|cA| = c
n
|A| (7.39)
|AB| = |A||B| (7.40)
|A| = 0 iff A is singular (7.41)
|A−1
| = 1/|A| if A is not singular (7.42)
|A| =
Yn
i=1
λi where λi are the eigenvalues of A (7.43)
For a positive definite matrix A, we can write A = LLT, where L is the lower triangular Cholesky
decomposition. In this case, we have
det(A) = det(L) det(L
T
) = det(L)
2
(7.44)
so
log det(A) = 2 log det(L) = 2 logY
i
Lii = 2trace(log(diag(L))) (7.45)
7.1.4.3 Rank of a matrix
The column rank of a matrix A is the dimension of the space spanned by its columns, and the row
rank is the dimension of the space spanned by its rows. It is a basic fact of linear algebra (that can be
shown using the SVD, discussed in Section 7.5) that for any matrix A, columnrank(A) = rowrank(A),
and so this quantity is simply referred to as the rank of A, denoted as rank(A). The following are
some basic properties of the rank:
• For A ∈ R
m×n, rank(A) ≤ min(m, n). If rank(A) = min(m, n), then A is said to be full rank,
otherwise it is called rank deficient.
• For A ∈ R
m×n, rank(A) = rank(AT) = rank(ATA) = rank(AAT).
• For A ∈ R
m×n, B ∈ R
n×p
, rank(AB) ≤ min(rank(A),rank(B)).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license232 Chapter 7. Linear Algebra
• For A, B ∈ R
m×n, rank(A + B) ≤ rank(A) + rank(B).
One can show that a square matrix is invertible iff it is full rank.
7.1.4.4 Condition numbers
The condition number of a matrix A is a measure of how numerically stable any computations
involving A will be. It is defined as follows:
κ(A) , ||A|| · ||A−1
|| (7.46)
where ||A|| is the norm of the matrix. We can show that κ(A) ≥ 1. (The condition number depends
on which norm we use; we will assume the `2-norm unless stated otherwise.)
We say A is well-conditioned if κ(A) is small (close to 1), and ill-conditioned if κ(A) is large. A
large condition number means A is nearly singular. This is a better measure of nearness to singularity
than the size of the determinant. For example, suppose A = 0.1I100×100. Then det(A) = 10−100
,
which suggests A is nearly singular, but κ(A) = 1, which means A is well-conditioned, reflecting the
fact that Ax simply scales the entries of x by 0.1.
To get a better understanding of condition numbers, consider the linear system of equations
Ax = b. If A is non-singular, the unique solution is x = A−1b. Suppose we change b to b + ∆b;
what effect will that have on x? The new solution must satisify
A(x + ∆x) = b + ∆b (7.47)
where
∆x = A−1∆b (7.48)
We say that A is well-conditioned if a small ∆b results in a small ∆x; otherwise we say that A is
ill-conditioned.
For example, suppose
A =
1
2

1 1
1 + 10−10 1 − 10−10
, A−1 =

1 − 1010 1010
1 + 1010 −1010
(7.49)
The solution for b = (1, 1) is x = (1, 1). If we change b by ∆b, the solution changes to
∆x = A−1∆b =

∆b1 − 1010(∆b1 − ∆b2)
∆b1 + 1010(∆b1 − ∆b2)

(7.50)
So a small change in b can lead to an extremely large change in x, because A is ill-conditioned
(κ(A) = 2 × 1010).
In the case of the `2-norm, the condition number is equal to the ratio of the largest to smallest
singular values (defined in Section 7.5); furthermore, the singular values are the square roots of the
eigenvalues:
κ(A) = σmax/σmin =
r
λmax
λmin
(7.51)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.1. Introduction 233
We can gain further insight into condition numbers by considering a quadratic objective function
f(x) = x
TAx. If we plot the level set of this function, it will be elliptical, as shown in Section 7.4.4.
As we increase the condition number of A, the ellipses become more and more elongated along certain
directions, corresponding to a very narrow valley in function space. If κ = 1 (the minimum possible
value), the level set will be circular.
7.1.5 Special types of matrices
In this section, we will list some common kinds of matrices with various forms of structure.
7.1.5.1 Diagonal matrix
A diagonal matrix is a matrix where all non-diagonal elements are 0. This is typically denoted
D = diag(d1, d2, . . . , dn), with
D =


d1
d2
.
.
.
dn


(7.52)
The identity matrix, denoted I ∈ R
n×n, is a square matrix with ones on the diagonal and zeros
everywhere else, I = diag(1, 1, . . . , 1). It has the property that for all A ∈ R
n×n,
AI = A = IA (7.53)
where the size of I is determined by the dimensions of A so that matrix multiplication is possible.
We can extract the diagonal vector from a matrix using d = diag(D). We can convert a vector
into a diagonal matrix by writing D = diag(d).
A block diagonal matrix is one which contains matrices on its main diagonal, and is 0 everywhere
else, e.g.,

A 0
0 B
(7.54)
A band-diagonal matrix only has non-zero entries along the diagonal, and on k sides of the
diagonal, where k is the bandwidth. For example, a tridiagonal 6 × 6 matrix looks like this:












A11 A12 0 · · · · · · 0
A21 A22 A23
.
.
.
.
.
.
.
.
.
0 A32 A33 A34
.
.
.
.
.
.
.
.
.
.
.
. A43 A44 A45 0
.
.
.
.
.
.
.
.
. A54 A55 A56
0 · · · · · · 0 A65 A66












(7.55)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license234 Chapter 7. Linear Algebra
7.1.5.2 Triangular matrices
An upper triangular matrix only has non-zero entries on and above the diagonal. A lower
triangular matrix only has non-zero entries on and below the diagonal.
Triangular matrices have the useful property that the diagonal entries of A are the eigenvalues of
A, and hence the determinant is the product of diagonal entries: det(A) = Q
i Aii.
7.1.5.3 Positive definite matrices
Given a square matrix A ∈ R
n×n and a vector x ∈ R
n, the scalar value x
TAx is called a quadratic
form. Written explicitly, we see that
x
TAx =
Xn
i=1
Xn
j=1
Aijxixj . (7.56)
Note that,
x
TAx = (x
TAx)
T = x
TATx = x
T
(
1
2
A +
1
2
AT
)x (7.57)
For this reason, we often implicitly assume that the matrices appearing in a quadratic form are
symmetric.
We give the following definitions:
• A symmetric matrix A ∈ S
n is positive definite iff for all non-zero vectors x ∈ R
n, x
TAx > 0.
This is usually denoted A  0 (or just A > 0). If it is possible that x
TAx = 0, we say the matrix
is positive semidefinite or psd. We denote the set of all positive definite matrices by S
n
++.
• A symmetric matrix A ∈ S
n is negative definite, denoted A ≺ 0 (or just A < 0) iff for all
non-zero x ∈ R
n, x
TAx < 0. If it is possible that x
TAx = 0, we say the matrix is negative
semidefinite.
• A symmetric matrix A ∈ S
n is indefinite, if it is neither positive semidefinite nor negative
semidefinite — i.e., if there exists x1, x2 ∈ R
n such that x
T
1Ax1 > 0 and x
T
2Ax2 < 0.
It should be obvious that if A is positive definite, then −A is negative definite and vice versa.
Likewise, if A is positive semidefinite then −A is negative semidefinite and vice versa. If A is
indefinite, then so is −A. It can also be shown that positive definite and negative definite matrices
are always invertible.
In Section 7.4.3.1, we show that a symmmetric matrix is positive definite iff its eigenvalues are
positive. Note that if all elements of A are positive, it does not mean A is necessarily positive definite.
For example, A =

4 3
3 2
is not positive definite. Conversely, a positive definite matrix can have
negative entries e.g., A =

2 −1
−1 2 
A sufficient condition for a (real, symmetric) matrix to be positive definite is that it is diagonally
dominant, i.e., if in every row of the matrix, the magnitude of the diagonal entry in that row is
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.1. Introduction 235
larger than the sum of the magnitudes of all the other (non-diagonal) entries in that row. More
precisely,
|aii| >
X
j6=i
|aij | for all i (7.58)
In 2d, any real, symmmetric 2 × 2 matrix 
a b
b d
is positive definite iff a > 0, d > 0 and ad > b2
.
Finally, there is one type of positive definite matrix that comes up frequently, and so deserves
some special mention. Given any matrix A ∈ R
m×n (not necessarily symmetric or even square), the
Gram matrix G = ATA is always positive semidefinite. Further, if m ≥ n (and we assume for
convenience that A is full rank), then G = ATA is positive definite.
7.1.5.4 Orthogonal matrices
Two vectors x, y ∈ R
n are orthogonal if x
Ty = 0. A vector x ∈ R
n is normalized if kxk2 = 1. A
set of vectors that is pairwise orthogonal and normalized is called orthonormal. A square matrix
U ∈ R
n×n is orthogonal if all its columns are orthonormal. (Note the different meaning of the term
orthogonal when talking about vectors versus matrices.) If the entries of U are complex valued, we
use the term unitary instead of orthogonal.
It follows immediately from the definition of orthogonality and normality that U is orthogonal iff
UTU = I = UUT
. (7.59)
In other words, the inverse of an orthogonal matrix is its transpose. Note that if U is not square —
i.e., U ∈ R
m×n, n < m — but its columns are still orthonormal, then UTU = I, but UUT 6= I. We
generally only use the term orthogonal to describe the previous case, where U is square.
An example of an orthogonal matrix is a rotation matrix (see Exercise 7.1). For example, a
rotation in 3d by angle α about the z axis is given by
R(α) =


cos(α) − sin(α) 0
sin(α) cos(α) 0
0 0 1

 (7.60)
If α = 45◦
, this becomes
R(45) =


√
1
2
− √
1
2
0
√
1
2
√
1
2
0
0 0 1

 (7.61)
where √
1
2
= 0.7071. We see that R(−α) = R(α)
−1 = R(α)
T, so this is an orthogonal matrix.
One nice property of orthogonal matrices is that operating on a vector with an orthogonal matrix
will not change its Euclidean norm, i.e.,
kUxk2 = kxk2 (7.62)
for any nonzero x ∈ R
n, and orthogonal U ∈ R
n×n.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license236 Chapter 7. Linear Algebra
Similarly, one can show that the angle between two vectors is preserved after they are transformed
by an orthogonal matrix. The cosine of the angle between x and y is given by
cos(α(x, y)) = x
Ty
||x||||y|| (7.63)
so
cos(α(Ux, Uy)) = (Ux)
T(Uy)
||Ux||||Uy|| =
x
Ty
||x||||y|| = cos(α(x, y)) (7.64)
In summary, transformations by orthogonal matrices are generalizations of rotations (if det(U) = 1)
and reflections (if det(U) = −1), since they preserve lengths and angles.
Note that there is technique called Gram Schmidt orthogonalization which is a way to make any
square matrix orthogonal, but we will not cover it here.
7.2 Matrix multiplication
The product of two matrices A ∈ R
m×n and B ∈ R
n×p
is the matrix
C = AB ∈ R
m×p
, (7.65)
where
Cij =
Xn
k=1
AikBkj . (7.66)
Note that in order for the matrix product to exist, the number of columns in A must equal the
number of rows in B.
Matrix multiplication generally takes O(mnp) time, although faster methods exist. In addition,
specialized hardware, such as GPUs and TPUs, can be leveraged to speed up matrix multiplication
significantly, by performing operations across the rows (or columns) in parallel.
It is useful to know a few basic properties of matrix multiplication:
• Matrix multiplication is associative: (AB)C = A(BC).
• Matrix multiplication is distributive: A(B + C) = AB + AC.
• Matrix multiplication is, in general, not commutative; that is, it can be the case that AB 6= BA.
(In each of the above cases, we are assuming that the dimensions match.)
There are many important special cases of matrix multiplication, as we discuss below.
7.2.1 Vector–vector products
Given two vectors x, y ∈ R
n, the quantity x
Ty, called the inner product, dot product or scalar
product of the vectors, is a real number given by
hx, yi , x
Ty =
Xn
i=1
xiyi
. (7.67)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.2. Matrix multiplication 237
Note that it is always the case that x
Ty = y
Tx.
Given vectors x ∈ R
m, y ∈ R
n (they no longer have to be the same size), xyT is called the outer
product of the vectors. It is a matrix whose entries are given by (xyT)ij = xiyj , i.e.,
xyT ∈ R
m×n =





x1y1 x1y2 · · · x1yn
x2y1 x2y2 · · · x2yn
.
.
.
.
.
.
.
.
.
.
.
.
xmy1 xmy2 · · · xmyn





. (7.68)
7.2.2 Matrix–vector products
Given a matrix A ∈ R
m×n and a vector x ∈ R
n, their product is a vector y = Ax ∈ R
m. There are
a couple ways of looking at matrix-vector multiplication, and we will look at them both.
If we write A by rows, then we can express y = Ax as follows:
y = Ax =





— a
T
1 —
— a
T
2 —
.
.
.
— a
T
m —





x =





a
T
1x
a
T
2x
.
.
.
a
T
mx





. (7.69)
In other words, the ith entry of y is equal to the inner product of the ith row of A and x, yi = a
T
i x.
Alternatively, let’s write A in column form. In this case we see that
y = Ax =


| | |
a1 a2 · · · an
| | |







x1
x2
.
.
.
xn





=


|
a1
|

 x1 +


|
a2
|

 x2 + . . . +


|
an
|

 xn. (7.70)
In other words, y is a linear combination of the columns of A, where the coefficients of the
linear combination are given by the entries of x. We can view the columns of A as a set of basis
vectors defining a linear subspace. We can contstruct vectors in this subspace by taking linear
combinations of the basis vectors. See Section 7.1.2 for details.
7.2.3 Matrix–matrix products
Below we look at four different (but, of course, equivalent) ways of viewing the matrix-matrix
multiplication C = AB.
First we can view matrix-matrix multiplication as a set of vector-vector products. The most
obvious viewpoint, which follows immediately from the definition, is that the i, j entry of C is equal
to the inner product of the ith row of A and the jth column of B. Symbolically, this looks like the
following,
C = AB =





— a
T
1 —
— a
T
2 —
.
.
.
— a
T
m —







| | |
b1 b2 · · · bp
| | |

 =





a
T
1b1 a
T
1b2 · · · a
T
1bp
a
T
2b1 a
T
2b2 · · · a
T
2bp
.
.
.
.
.
.
.
.
.
.
.
.
a
T
mb1 a
T
mb2 · · · a
T
mbp





. (7.71)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license238 Chapter 7. Linear Algebra
A
B
a1,1
a3,1 a3,2
a2,1 a2,2
a4,1 a4,2
a1,2
b1,2
b2,2
b1,3
b2,3
b1,1
b2,1
Figure 7.5: Illustration of matrix multiplication. From https: // en. wikipedia. org/ wiki/ Matrix_
multiplication . Used with kind permission of Wikipedia author Bilou.
Remember that since A ∈ R
m×n and B ∈ R
n×p
, ai ∈ R
n and bj ∈ R
n, so these inner products
all make sense. This is the most “natural” representation when we represent A by rows and B by
columns. See Figure 7.5 for an illustration.
Alternatively, we can represent A by columns, and B by rows, which leads to the interpretation of
AB as a sum of outer products. Symbolically,
C = AB =


| | |
a1 a2 · · · an
| | |







— b
T
1 —
— b
T
2 —
.
.
.
— b
T
n —





=
Xn
i=1
aib
T
i
. (7.72)
Put another way, AB is equal to the sum, over all i, of the outer product of the ith column of A
and the ith row of B. Since, in this case, ai ∈ R
m and bi ∈ R
p
, the dimension of the outer product
aib
T
i
is m × p, which coincides with the dimension of C.
We can also view matrix-matrix multiplication as a set of matrix-vector products. Specifically, if
we represent B by columns, we can view the columns of C as matrix-vector products between A and
the columns of B. Symbolically,
C = AB = A


| | |
b1 b2 · · · bp
| | |

 =


| | |
Ab1 Ab2 · · · Abp
| | |

 . (7.73)
Here the ith column of C is given by the matrix-vector product with the vector on the right, ci = Abi
.
These matrix-vector products can in turn be interpreted using both viewpoints given in the previous
subsection.
Finally, we have the analogous viewpoint, where we represent A by rows, and view the rows of C
as the matrix-vector product between the rows of A and the matrix B. Symbolically,
C = AB =





— a
T
1 —
— a
T
2 —
.
.
.
— a
T
m —





B =





— a
T
1B —
— a
T
2B —
.
.
.
— a
T
mB —





. (7.74)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.2. Matrix multiplication 239
Here the ith row of C is given by the matrix-vector product with the vector on the left, c
T
i = a
T
i B.
It may seem like overkill to dissect matrix multiplication to such a large degree, especially when all
these viewpoints follow immediately from the initial definition we gave (in about a line of math) at
the beginning of this section. However, virtually all of linear algebra deals with matrix multiplications
of some kind, and it is worthwhile to spend some time trying to develop an intuitive understanding
of the viewpoints presented here.
Finally, a word on notation. We write A2 as shorthand for AA, which is the matrix product. To
denote elementwise squaring of the elements of a matrix, we write A 2 = [A2
ij ]. (If A is diagonal,
then A2 = A 2
.)
We can also define the inverse of A2 using the matrix square root: we say A =
√
M if A2 = M.
To denote elementwise square root of the elements of a matrix, we write [
p
Mij ].
7.2.4 Application: manipulating data matrices
As an application of the above results, consider the case where X is the N × D design matrix, whose
rows are the data cases. There are various common preprocessing operations that we apply to this
matrix, which we summarize below. (Writing these operations in matrix form is useful because it is
notationally compact, and it allows us to implement the methods quickly using fast matrix code.)
7.2.4.1 Summing slices of the matrix
Suppose X is an N × D matrix. We can sum across the rows by premultiplying by a 1 × N matrix
of ones to create a 1 × D matrix:
1
T
N X =
￾P
n
xn1 · · · P
n
xnD
(7.75)
Hence the mean of the data vectors is given by
x
T =
1
N
1
T
N X (7.76)
We can sum across the columns by postmultiplying by a D × 1 matrix of ones to create a N × 1
matrix:
X1D =


P
d
x1d
.
.
P .
d
xNd

 (7.77)
We can sum all entries in a matrix by pre and post multiplying by a vector of 1s:
1
T
N X1D =
X
ij
Xij (7.78)
Hence the overall mean is given by
x =
1
ND
1
T
N X1D (7.79)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens240 Chapter 7. Linear Algebra
7.2.4.2 Scaling rows and columns of a matrix
We often want to scale rows or columns of a data matrix (e.g., to standardize them). We now show
how to write this in matrix notation.
If we pre-multiply X by a diagonal matrix S = diag(s), where s is an N-vector, then we just scale
each row of X by the corresponding scale factor in s:
diag(s)X =


s1 · · · 0
.
.
.
0 · · · sN




x1,1 · · · x1,D
.
.
.
xN,1 · · · xN,D

 =


s1x1,1 · · · s1x1,D
.
.
.
sN xN.1 · · · sN xN,D

 (7.80)
If we post-multiply X by a diagonal matrix S = diag(s), where s is a D-vector, then we just scale
each column of X by the corresponding element in s.
Xdiag(s) =


x1,1 · · · x1,D
.
.
.
xN,1 · · · xN,D




s1 · · · 0
.
.
.
0 · · · sD

 =


s1x1,1 · · · sDx1,D
.
.
.
s1xN,1 · · · sDxN,D

 (7.81)
Thus we can rewrite the standardization operation from Section 10.2.8 in matrix form as follows:
standardize(X) = (X − 1N µ
T
)diag(σ)
−1
(7.82)
where µ = x is the empirical mean, and σ is a vector of the empirical standard deviations.
7.2.4.3 Sum of squares and scatter matrix
The sum of squares matrix is D × D matrix defined by
S0 , XTX =
X
N
n=1
xnx
T
n =
X
N
n=1


x
2
n,1
· · · xn,1xn,D
.
.
.
xn,Dxn,1 · · · x
2
n,D

 (7.83)
The scatter matrix is a D × D matrix defined by
Sx ,
X
N
n=1
(xn − x)(xn − x)
T =
 X
n
xnx
T
n
!
− Nxx
T
(7.84)
We see that this is the sum of squares matrix applied to the mean-centered data. More precisely,
define X˜ to be a version of X where we subtract the mean x =
1
N XT1N off every row. Hence we can
compute the centered data matrix using
X˜ = X − 1N x
T = X −
1
N
1N 1
T
N X = CN X (7.85)
where
CN , IN −
1
N
1N 1
T
N (7.86)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.2. Matrix multiplication 241
is the centering matrix. The scatter matrix can now be computed as follows:
Sx = X˜ TX˜ = XTCT
N CN X = XTCN X (7.87)
where we exploited the fact that CN is symmetric and idempotent, i.e., Ck
N = CN for k = 1, 2, . . .
(since once we subtract the mean, subtracting it again has no effect).
7.2.4.4 Gram matrix
The N × N matrix XXT is a matrix of inner products called the Gram matrix:
K , XXT =


x
T
1x1 · · · x
T
1xN
.
.
.
x
T
nx1 · · · x
T
N xN

 (7.88)
Sometimes we want to compute the inner products of the mean-centered data vectors, K˜ = X˜ X˜ T.
However, if we are working with a feature similarity matrix instead of raw features, we will only have
access to K, not X. (We will see examples of this in Section 20.4.4 and Section 20.4.6.) Fortunately,
we can compute K˜ from K using the double centering trick:
K˜ = X˜ X˜ T = CN KCN = K −
1N
N
K − K
1N
N
+
1N
N
K
1N
N
(7.89)
This subtracts the row means and column means from K, and adds back the global mean that gets
subtracted twice, so that both row means and column means of K˜ are equal to zero.
To see why Equation (7.89) is true, consider the scalar form:
K˜
ij = x˜
T
i x˜j = (xi −
1
N
X
N
k=1
xk)(xj −
1
N
X
N
l=1
xl) (7.90)
= x
T
i xj −
1
N
X
N
k=1
x
T
i xk −
1
N
X
N
k=1
x
T
jxk +
1
N2
X
N
k=1
X
N
l=1
x
T
kxl (7.91)
7.2.4.5 Distance matrix
Let X be Nx × D datamatrix, and Y be another Ny × D datamatrix. We can compute the squared
pairwise distances between these using
Dij = (xi − yj )
T
(xi − yj ) = ||xi
||2 − 2x
T
i yj + ||yj ||2
(7.92)
Let us now write this in matrix form. Let xˆ = [||x1||2
; · · · ; ||xNx
||2
] = diag(XXT) be a vector where
each element is the squared norm of the examples in X, and define yˆ similarly. Then we have
D = xˆ1
T
Ny − 2XYT + 1Nx yˆ
T
(7.93)
In the case that X = Y, we have
D = xˆ1
T
N − 2XXT + 1N xˆ
T
(7.94)
This vectorized computation is often much faster than using for loops.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license242 Chapter 7. Linear Algebra
7.2.5 Kronecker products *
If A is an m×n matrix and B is a p×q matrix, then the Kronecker product A⊗B is the mp×nq
block matrix
A ⊗ B =



a11B · · · a1nB
.
.
.
.
.
.
.
.
.
am1B · · · amnB


 (7.95)
For example,


a11 a12
a21 a22
a31 a32

 ⊗

b11 b12 b13
b21 b22 b23
=








a11b11 a11b12 a11b13 a12b11 a12b12 a12b13
a11b21 a11b22 a11b23 a12b21 a12b22 a12b23
a21b11 a21b12 a21b13 a22b11 a22b12 a22b13
a21b21 a21b22 a21b23 a22b21 a22b22 a22b23
a31b11 a31b12 a31b13 a32b11 a32b12 a32b13
a31b21 a31b22 a31b23 a32b21 a32b22 a32b23








(7.96)
Here are some useful identities:
(A ⊗ B)
−1 = A−1 ⊗ B
−1
(7.97)
(A ⊗ B)vec(C) = vec(BCAT
) (7.98)
See [Loa00] for a list of other useful properties.
7.2.6 Einstein summation *
Einstein summation, or einsum for short, is a notational shortcut for working with tensors. The
convention was introduced by Einstein [Ein16, sec 5], who later joked to a friend, “I have made a great
discovery in mathematics; I have suppressed the summation sign every time that the summation
must be made over an index which occurs twice...” [Pai05, p.216]. For example, instead of writing
matrix multiplication as Cij =
P
P
k AikBkj , we can just write it as Cij = AikBkj , where we drop the
k
.
As a more complex example, suppose we have a 3d tensor Sntk where n indexes examples in the
batch, t indexes locations in the sequence, and k indexes words in a one-hot representation. Let
Wkd be an embedding matrix that maps sparse one-hot vectors R
k
to dense vectors in R
d
. We can
convert the batch of sequences of one-hots to a batch of sequences of embeddings as follows:
Entd =
X
k
SntkWkd (7.99)
We can compute the sum of the embedding vectors for each sequence (to get a global representation
of each bag of words) as follows:
End =
X
k
X
t
SntkWkd (7.100)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.3. Matrix inversion 243
Finally we can pass each sequence’s vector representation through another linear transform Vdc to
map to the logits over a classifier with c labels:
Lnc =
X
d
EndVdc =
X
d
X
k
X
t
SntkWkdVdc (7.101)
In einsum notation, we write Lnc = SntkWkdVdc. We sum over k and d because those indices occur
twice on the RHS. We sum over t because that index does not occur on the LHS.
Einsum is implemented in NumPy, Tensorflow, PyTorch, etc. What makes it particularly useful is
that it can perform the relevant tensor multiplications in complex expressions in an optimal order,
so as to minimize time and intermediate memory allocation.2 The library is best illustrated by the
examples in code.probml.ai/book1/einsum_demo.
Note that the speed of einsum depends on the order in which the operations are performed, which
depends on the shapes of the relevant arguments. The optimal ordering minimizes the treewidth
of the resulting computation graph, as explained in [GASG18]. In general, the time to compute
the optimal ordering is exponential in the number of arguments, so it is common to use a greedy
approximation. However, if we expect to repeat the same calculation many times, using tensors of
the same shape but potentially different content, we can compute the optimal ordering once and
reuse it multiple times.
7.3 Matrix inversion
In this section, we discuss how to invert different kinds of matrices.
7.3.1 The inverse of a square matrix
The inverse of a square matrix A ∈ R
n×n is denoted A−1
, and is the unique matrix such that
A−1A = I = AA−1
. (7.102)
Note that A−1
exists if and only if det(A) 6= 0. If det(A) = 0, it is called a singular matrix.
The following are properties of the inverse; all assume that A, B ∈ R
n×n are non-singular:
(A−1
)
−1 = A (7.103)
(AB)
−1 = B
−1A−1
(7.104)
(A−1
)
T = (AT
)
−1 , A−T
(7.105)
For the case of a 2 × 2 matrix, the expression for A−1
is simple enough to give explicitly. We have
A =

a b
c d
, A−1 =
1
|A|

d −b
−c a 
(7.106)
For a block diagonal matrix, the inverse is obtained by simply inverting each block separately, e.g.,

A 0
0 B−1
=

A−1 0
0 B−1

(7.107)
2. These optimizations are implemented in the opt-einsum library [GASG18]. Its core functionality is included in
NumPy and JAX einsum functions, provided you set optimize=True parameter.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license244 Chapter 7. Linear Algebra
7.3.2 Schur complements *
In this section, we review some useful results concerning block structured matrices.
Theorem 7.3.1 (Inverse of a partitioned matrix). Consider a general partitioned matrix
M =

E F
G H
(7.108)
where we assume E and H are invertible. We have
M−1 =

(M/H)
−1 −(M/H)
−1FH−1
−H−1G(M/H)
−1 H−1 + H−1G(M/H)
−1FH−1

(7.109)
=

E−1 + E−1F(M/E)
−1GE−1 −E−1F(M/E)
−1
−(M/E)
−1GE−1
(M/E)
−1

(7.110)
where
M/H , E − FH−1G (7.111)
M/E , H − GE−1F (7.112)
We say that M/H is the Schur complement of M wrt H, and M/E is the Schur complement of
M wrt E. (The reason for this notation will be explained in Equation (7.133).)
Equation (7.109) and Equation (7.110) are called the partitioned inverse formulae.
Proof. If we could block diagonalize M, it would be easier to invert. To zero out the top right block
of M we can pre-multiply as follows

I −FH−1
0 I  E F
G H
=

E − FH−1G 0
G H
(7.113)
Similarly, to zero out the bottom left we can post-multiply as follows

E − FH−1G 0
G H  I 0
−H−1G I
=

E − FH−1G 0
0 H
(7.114)
Putting it all together we get

I −FH−1
0 I 
| {z }
X

E F
G H
| {z }
M

I 0
−H−1G I
| {z }
Z
=

E − FH−1G 0
0 H
| {z }
W
(7.115)
Taking the inverse of both sides yields
Z
−1M−1X−1 = W−1
(7.116)
M−1 = ZW−1X (7.117)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.3. Matrix inversion 245
Substituting in the definitions we get

E F
G H−1
=

I 0
−H−1G I (M/H)
−1 0
0 H−1
 I −FH−1
0 I 
(7.118)
=

(M/H)
−1 0
−H−1G(M/H)
−1 H−1
 I −FH−1
0 I 
(7.119)
=

(M/H)
−1 −(M/H)
−1FH−1
−H−1G(M/H)
−1 H−1 + H−1G(M/H)
−1FH−1

(7.120)
Alternatively, we could have decomposed the matrix M in terms of E and M/E = (H − GE−1F),
yielding

E F
G H−1
=

E−1 + E−1F(M/E)
−1GE−1 −E−1F(M/E)
−1
−(M/E)
−1GE−1
(M/E)
−1

(7.121)
7.3.3 The matrix inversion lemma *
Equating the top left block of the first matrix in Equation (7.119) with the top left block of the
matrix in Equation (7.121)
(M/H)
−1 = (E − FH−1G)
−1 = E
−1 + E
−1F(H − GE−1F)
−1GE−1
(7.122)
This is known as the matrix inversion lemma or the Sherman-Morrison-Woodbury formula.
A typical application in machine learning is the following. Let X be an N × D data matrix, and
Σ be N × N diagonal matrix. Then we have (using the substitutions E = Σ, F = GT = X, and
H−1 = −I) the following result:
(Σ + XXT
)
−1 = Σ
−1 − Σ
−1X(I + XTΣ
−1X)
−1XTΣ
−1
(7.123)
The LHS takes O(N3
) time to compute, the RHS takes time O(D3
) to compute.
Another application concerns computing a rank one update of an inverse matrix. Let E = A,
F = u, G = v
T, and H = −1. Then we have
(A + uvT
)
−1 = A−1 + A−1u(−1 − v
TA−1u)
−1v
TA−1
(7.124)
= A−1 −
A−1uvTA−1
1 + v
TA−1u
(7.125)
This is known as the Sherman-Morrison formula.
7.3.4 Matrix determinant lemma *
We now use the above results to derive an efficient way to compute the determinant of a block￾structured matrix.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license246 Chapter 7. Linear Algebra
From Equation (7.115), we have
|X||M||Z| = |W| = |E − FH−1G||H| (7.126)
|

E F
G H
| = |E − FH−1G||H| (7.127)
|M| = |M/H||H| (7.128)
|M/H| =
|M|
|H|
(7.129)
So we can see that M/H acts somewhat like a division operator.
Furthermore, we have
|M| = |M/H||H| = |M/E||E| (7.130)
|M/H| =
|M/E||E|
|H|
(7.131)
|E − FH−1G| = |H − GE−1F||H−1
||E| (7.132)
Hence (setting E = A, F = −u, G = v
T, H = 1) we have
|A + uvT
| = (1 + v
TA−1u)|A| (7.133)
This is known as the matrix determinant lemma.
7.3.5 Application: deriving the conditionals of an MVN *
Consider a joint Gaussian of the form p(x1, x2) = N (x|µ, Σ), where
µ =

µ1
µ2

, Σ =

Σ11 Σ12
Σ21 Σ22
(7.134)
In Section 3.2.3, we claimed that
p(x1|x2) = N (x1|µ1 + Σ12Σ
−1
22 (x2 − µ2), Σ11 − Σ12Σ
−1
22 Σ21) (7.135)
In this section, we derive this result using Schur complenents.
Let us factor the joint p(x1, x2) as p(x2)p(x1|x2) as follows:
p(x1, x2) ∝ exp (
−
1
2

x1 − µ1
x2 − µ2
T 
Σ11 Σ12
Σ21 Σ22−1 
x1 − µ1
x2 − µ2
)
(7.136)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.4. Eigenvalue decomposition (EVD) 247
Using Equation (7.118) the above exponent becomes
p(x1, x2) ∝ exp (
−
1
2

x1 − µ1
x2 − µ2
T 
I 0
−Σ
−1
22 Σ21 I
 (Σ/Σ22)
−1 0
0 Σ−1
22 
(7.137)
×

I −Σ12Σ
−1
22
0 I  x1 − µ1
x2 − µ2
 (7.138)
= exp 
−
1
2
(x1 − µ1 − Σ12Σ
−1
22 (x2 − µ2))T
(Σ/Σ22)
−1
(7.139)
(x1 − µ1 − Σ12Σ
−1
22 (x2 − µ2))	
× exp 
−
1
2
(x2 − µ2)
TΣ
−1
22 (x2 − µ2)

(7.140)
This is of the form
exp(quadratic form in x1, x2) × exp(quadratic form in x2) (7.141)
Hence we have successfully factorized the joint as
p(x1, x2) = p(x1|x2)p(x2) (7.142)
= N (x1|µ1|2, Σ1|2)N (x2|µ2, Σ22) (7.143)
where the parameters of the conditional distribution can be read off from the above equations using
µ1|2 = µ1 + Σ12Σ
−1
22 (x2 − µ2) (7.144)
Σ1|2 = Σ/Σ22 = Σ11 − Σ12Σ
−1
22 Σ21 (7.145)
We can also use the fact that |M| = |M/H||H| to check the normalization constants are correct:
(2π)
(d1+d2)/2
|Σ|
1
2 = (2π)
(d1+d2)/2
(|Σ/Σ22| |Σ22|)
1
2 (7.146)
= (2π)
d1/2
|Σ/Σ22|
1
2 (2π)
d2/2
|Σ22|
1
2 (7.147)
where d1 = dim(x1) and d2 = dim(x2).
7.4 Eigenvalue decomposition (EVD)
In this section, we review some standard material on the eigenvalue decomposition or EVD of
square (real-valued) matrices.
7.4.1 Basics
Given a square matrix A ∈ R
n×n, we say that λ ∈ R is an eigenvalue of A and u ∈ R
n is the
corresponding eigenvector if
Au = λu, u 6= 0 . (7.148)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license248 Chapter 7. Linear Algebra
Intuitively, this definition means that multiplying A by the vector u results in a new vector that
points in the same direction as u, but is scaled by a factor λ. For example, if A is a rotation matrix,
then u is the axis of rotation and λ = 1.
Note that for any eigenvector u ∈ R
n, and scalar c ∈ R,
A(cu) = cAu = cλu = λ(cu) (7.149)
Hence cu is also an eigenvector. For this reason when we talk about “the” eigenvector associated
with λ, we usually assume that the eigenvector is normalized to have length 1 (this still creates some
ambiguity, since u and −u will both be eigenvectors, but we will have to live with this).
We can rewrite the equation above to state that (λ, x) is an eigenvalue-eigenvector pair of A if
(λI − A)u = 0, u 6= 0 . (7.150)
Now (λI − A)u = 0 has a non-zero solution to u if and only if (λI − A) has a non-empty nullspace,
which is only the case if (λI − A) is singular, i.e.,
det(λI − A) = 0 . (7.151)
This is called the characteristic equation of A. (See Exercise 7.2.) The n solutions of this equation
are the n (possibly complex-valued) eigenvalues λi
, and ui are the corresponding eigenvectors. It is
standard to sort the eigenvectors in order of their eigenvalues, with the largest magnitude ones first.
The following are properties of eigenvalues and eigenvectors.
• The trace of a matrix is equal to the sum of its eigenvalues,
tr(A) = Xn
i=1
λi
. (7.152)
• The determinant of A is equal to the product of its eigenvalues,
det(A) = Yn
i=1
λi
. (7.153)
• The rank of A is equal to the number of non-zero eigenvalues of A.
• If A is non-singular then 1/λi
is an eigenvalue of A−1 with associated eigenvector ui
, i.e.,
A−1ui = (1/λi)ui
.
• The eigenvalues of a diagonal or triangular matrix are just the diagonal entries.
7.4.2 Diagonalization
We can write all the eigenvector equations simultaneously as
AU = UΛ (7.154)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.4. Eigenvalue decomposition (EVD) 249
where the columns of U ∈ R
n×n are the eigenvectors of A and Λ is a diagonal matrix whose entries
are the eigenvalues of A, i.e.,
U ∈ R
n×n =


| | |
u1 u2 · · · un
| | |

 , Λ = diag(λ1, . . . , λn) . (7.155)
If the eigenvectors of A are linearly independent, then the matrix U will be invertible, so
A = UΛU−1
. (7.156)
A matrix that can be written in this form is called diagonalizable.
7.4.3 Eigenvalues and eigenvectors of symmetric matrices
When A is real and symmetric, it can be shown that all the eigenvalues are real, and the eigenvectors
are orthonormal, i.e., u
T
i uj = 0 if i 6= j, and u
T
i ui = 1, where ui are the eigenvectors. In matrix
form, this becomes UTU = UUT = I; hence we see that U is an orthogonal matrix.
We can therefore represent A as
A = UΛUT =


| | |
u1 u2 · · · un
| | |




λ1
λ2
.
.
.
λn




− u
T
1 −
− u
T
2 −
.
.
.
− u
T
n −


(7.157)
= λ1


|
u1
|


￾
− u
T
1 −

+ · · · + λn


|
un
|


￾
− u
T
n −

=
Xn
i=1
λiuiu
T
i
(7.158)
Thus multiplying by any symmetric matrix A can be interpreted as multiplying by a rotation matrix
UT, a scaling matrix Λ, followed by an inverse rotation U.
Once we have diagonalized a matrix, it is easy to invert. Since A = UΛUT, where UT = U−1
, we
have
A−1 = UΛ−1UT =
X
d
i=1
1
λi
uiu
T
i
(7.159)
This corresponds to rotating, unscaling, and then rotating back.
7.4.3.1 Checking for positive definiteness
We can also use the diagonalization property to show that a symmetric matrix is positive definite iff
all its eigenvalues are positive. To see this, note that
x
TAx = x
TUΛUTx = y
TΛy =
Xn
i=1
λiy
2
i
(7.160)
where y = UTx. Because y
2
i
is always nonnegative, the sign of this expression depends entirely on
the λi
’s. If all λi > 0, then the matrix is positive definite; if all λi ≥ 0, it is positive semidefinite.
Likewise, if all λi < 0 or λi ≤ 0, then A is negative definite or negative semidefinite respectively.
Finally, if A has both positive and negative eigenvalues, it is indefinite.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licen250 Chapter 7. Linear Algebra
µ
u1
u2
λ1
1/2
λ2
1/2
x1
x
2
Figure 7.6: Visualization of a level set of the quadratic form (x − µ)
TA(x − µ) in 2d. The major and minor
axes of the ellipse are defined by the first two eigenvectors of A, namely u1 and u2. Adapted from Figure 2.7
of [Bis06]. Generated by code at figures.probml.ai/book1/7.6.
7.4.4 Geometry of quadratic forms
A quadratic form is a function that can be written as
f(x) = x
TAx (7.161)
where x ∈ R
n and A is a positive definite, symmetric n-by-n matrix. Let A = UΛUT be a
diagonalization of A (see Section 7.4.3). Hence we can write
f(x) = x
TAx = x
TUΛUTx = y
TΛy =
Xn
i=1
λiy
2
i
(7.162)
where yi = x
Tui and λi > 0 (since A is positive definite). The level sets of f(x) define hyper-ellipsoids.
For example, in 2d, we have
λ1y
2
1 + λ2y
2
2 = r (7.163)
which is the equation of a 2d ellipse. This is illustrated in Figure 7.6. The eigenvectors determine
the orientation of the ellipse, and the eigenvalues determine how elongated it is.
7.4.5 Standardizing and whitening data
Suppose we have a dataset X ∈ R
N×D. It is common to preprocess the data so that each column has
zero mean and unit variance. This is called standardizing the data, as we discussed in Section 10.2.8.
Although standardizing forces the variance to be 1, it does not remove correlation between the
columns. To do that, we must whiten the data. To define this, let the empirical covariance matrix
be Σ =
1
N XTX, and let Σ = EDET be its diagonalization. Equivalently, let [U, S, V] be the SVD of
X (so E = V and D = S
2
, as we discuss in Section 20.1.3.3.) Now define
Wpca = D− 1
2 E
T
(7.164)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.4. Eigenvalue decomposition (EVD) 251
66 68 70 72 74 76 78
120
140
160
180
200
220
240
260
280
1
2
3
4
Raw
(a)
−0.10 −0.05 0.00 0.05 0.10
−1.0
−0.5
0.0
0.5
1.0
1.5
1
2
3
4
Standardized
(b)
−3 −2 −1 0 1 2 3
−1
0
1
2
3
1
2
3
4
PCA-whitened
(c)
−3 −2 −1 0 1 2 3 4
−1
0
1
2
3
1
2
3
4
ZCA-whitened
(d)
Figure 7.7: (a) Height/weight data. (b) Standardized. (c) PCA Whitening. (d) ZCA whitening. Numbers refer
to the first 4 datapoints, but there are 73 datapoints in total. Generated by code at figures.probml.ai/book1/7.7.
This is called the PCA whitening matrix. (We discuss PCA in Section 20.1.) Let y = Wpcax be a
transformed vector. We can check that its covariance is white as follows:
Cov [y] = WE

xxT
WT = WΣWT = (D− 1
2 E
T
)(EDET
)(ED− 1
2 ) = I (7.165)
The whitening matrix is not unique, since any rotation of it, W = RWpca, will still maintain the
whitening property, i.e., WTW = Σ
−1
. For example, if we take R = E, we get
Wzca = ED− 1
2 E
T = Σ
− 1
2 = VS−1VT
(7.166)
This is called Mahalanobis whitening or ZCA. (ZCA stands for “zero-phase component analysis”,
and was introduced in [BS97].) The advantage of ZCA whitening over PCA whitening is that the
resulting transformed data is as close as possible to the original data (in the least squares sense)
[Amo17]. This is illustrated in Figure 7.7. When applied to images, the ZCA transformed data
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license252 Chapter 7. Linear Algebra
vectors still look like images. This is useful when the method is used inside a deep learning system
[KH09].
7.4.6 Power method
We now describe a simple iterative method for computing the eigenvector corresponding to the largest
eigenvalue of a real, symmetric matrix; this is called the power method. This can be useful when
the matrix is very large but sparse. For example, it is used by Google’s PageRank to compute
the stationary distribution of the transition matrix of the world wide web (a matrix of size about 3
billion by 3 billion!). In Section 7.4.7, we will see how to use this method to compute subsequent
eigenvectors and values.
Let A be a matrix with orthonormal eigenvectors ui and eigenvalues |λ1| > |λ2| ≥ · · · ≥ |λm| ≥ 0,
so A = UΛUT. Let v(0) be an arbitrary vector in the range of A, so Ax = v(0) for some x. Hence
we can write v(0) as
v0 = U(ΛUTx) = a1u1 + · · · + amum (7.167)
for some constants ai
. We can now repeatedly multiply v by A and renormalize:
vt ∝ Avt−1 (7.168)
(We normalize at each iteration for numerical stability.)
Since vt is a multiple of Atv0, we have
vt ∝ a1λ
t
1u1 + a2λ
t
2u2 + · · · + amλ
t
mum (7.169)
= λ
t
1
￾
a1u1 + a1(λ2/λ1)
tu2 + · · · + am(λm/λ1)
tum

(7.170)
→ λ
t
1a1u1 (7.171)
since |λk|
|λ1| < 1 for k > 1 (assuming the eigenvalues are sorted in descending order). So we see that
this converges to u1, although not very quickly (the error is reduced by approximately |λ2/λ1| at
each iteration). The only requirement is that the initial guess satisfy v
T
0u1 = 0 6 , which will be true
for a random v0 with high probability.
We now discuss how to compute the corresponding eigenvalue, λ1. Define the Rayleigh quotient
to be
R(A, x) ,
x
TAx
xTx
(7.172)
Hence
R(A,ui) = u
T
i Aui
u
T
i ui
=
λiu
T
i ui
u
T
i ui
= λi (7.173)
Thus we can easily compute λ1 from u1 and A. See code.probml.ai/book1/power_method_demo
for a demo.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2027.5. Singular value decomposition (SVD) 253
7.4.7 Deflation
Suppose we have computed the first eigenvector and value u1, λ1 by the power method. We now
describe how to compute subsequent eigenvectors and values. Since the eigenvectors are orthonormal,
and the eigenvalues are real, we can project out the u1 component from the matrix as follows:
A(2) = (I − u1u
T
1
)A(1) = A(1) − u1u
T
1A(1) = A(1) − λ1u1u
T
1
(7.174)
This is called matrix deflation. We can then apply the power method to A(2), which will find the
largest eigenvector/value in the subspace orthogonal to u1.
In Section 20.1.2, we show that the optimal estimate Wˆ for the PCA model (described in
Section 20.1) is given by the first K eigenvectors of the empirical covariance matrix. Hence deflation
can be used to implement PCA. It can also be modified to implement sparse PCA [Mac09].
7.4.8 Eigenvectors optimize quadratic forms
We can use matrix calculus to solve an optimization problem in a way that leads directly to
eigenvalue/eigenvector analysis. Consider the following, equality constrained optimization problem:
maxx∈Rn x
TAx subject to kxk
2
2 = 1 (7.175)
for a symmetric matrix A ∈ S
n. A standard way of solving optimization problems with equality
constraints is by forming the Lagrangian, an objective function that includes the equality constraints
(see Section 8.5.1). The Lagrangian in this case can be given by
L(x, λ) = x
TAx + λ(1 − x
Tx) (7.176)
where λ is called the Lagrange multiplier associated with the equality constraint. It can be established
that for x
∗
to be a optimal point to the problem, the gradient of the Lagrangian has to be zero at x
∗
(this is not the only condition, but it is required). That is,
∇xL(x, λ) = 2ATx − 2λx = 0. (7.177)
Notice that this is just the linear equation Ax = λx. This shows that the only points which can
possibly maximize (or minimize) x
TAx assuming x
Tx = 1 are the eigenvectors of A.
7.5 Singular value decomposition (SVD)
We now discuss the SVD, which generalizes EVD to rectangular matrices.
7.5.1 Basics
Any (real) m × n matrix A can be decomposed as
A = USVT = σ1


|
u1
|


￾
− v
T
1 −

+ · · · + σr


|
ur
|


￾
− v
T
r −

(7.178)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licen254 Chapter 7. Linear Algebra
(a) (b)
Figure 7.8: SVD decomposition of a matrix, A = USVT
. The shaded parts of each matrix are not computed
in the economy-sized version. (a) Tall skinny matrix. (b) Short wide matrix.
where U is an m × m whose columns are orthornormal (so UTU = Im), V is n × n matrix whose
rows and columns are orthonormal (so VTV = VVT = In), and S is a m × n matrix containing the
r = min(m, n) singular values σi ≥ 0 on the main diagonal, with 0s filling the rest of the matrix.
The columns of U are the left singular vectors, and the columns of V are the right singular vectors.
This is called the singular value decomposition or SVD of the matrix. See Figure 7.8 for an
example.
As is apparent from Figure 7.8a, if m > n, there are at most n singular values, so the last m − n
columns of U are irrelevant (since they will be multiplied by 0). The economy sized SVD, also
called a thin SVD, avoids computing these unnecessary elements. In other words, if we write the U
matrix as U = [U1, U2], we only compute U1. Figure 7.8b shows the opposite case, where m < n,
where we represent V = [V1; V2], and only compute V1.
The cost of computing the SVD is O(min(mn2
, m2n)). Details on how it works can be found in
standard linear algebra textbooks.
7.5.2 Connection between SVD and EVD
If A is real, symmetric and positive definite, then the singular values are equal to the eigenvalues,
and the left and right singular vectors are equal to the eigenvectors (up to a sign change):
A = USVT = USUT = USU−1
(7.179)
Note, however, that NumPy always returns the singular values in decreasing order, whereas the
eigenvalues need not necessarily be sorted.
In general, for an arbitrary real matrix A, if A = USVT, we have
ATA = VSTUT USVT = V(S
TS)VT
(7.180)
Hence
(ATA)V = VDn (7.181)
so the eigenvectors of ATA are equal to V, the right singular vectors of A, and the eigenvalues of
ATA are equal to Dn = S
TS, which is an n × n diagonal matrix containing the squared singular
values. Similarly
AAT = USVT VSTUT = U(SST
)UT
(7.182)
(AAT
)U = UDm (7.183)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.5. Singular value decomposition (SVD) 255
so the eigenvectors of AAT are equal to U, the left singular vectors of A, and the eigenvalues of
AAT are equal to Dm = SST, which is an m × m diagonal matrix containing the squared singular
values. In summary,
U = evec(AAT
), V = evec(ATA), Dm = eval(AAT
), Dn = eval(ATA) (7.184)
If we just use the computed (non-zero) parts in the economy-sized SVD, then we can define
D = S
2 = S
TS = SST
(7.185)
Note also that an EVD does not always exist, even for square A, whereas an SVD always exists.
7.5.3 Pseudo inverse
The Moore-Penrose pseudo-inverse of A, pseudo inverse denoted A†
, is defined as the unique
matrix that satisfies the following 4 properties:
AA†A = A, A†AA† = A†
, (AA†
)
T = AA†
, (A†A)
T = A†A (7.186)
If A is square and non-singular, then A† = A−1
.
If m > n (tall, skinny) and the columns of A are linearly independent (so A is full rank), then
A† = (ATA)
−1AT
(7.187)
which is the same expression as arises in the normal equations (see Section 11.2.2.1). In this case,
A†
is a left inverse of A because
A†A = (ATA)
−1ATA = I (7.188)
but is not a right inverse because
AA† = A(ATA)
−1AT
(7.189)
only has rank n, and so cannot be the m × m identity matrix.
If m < n (short, fat) and the rows of A are linearly independent (so A is full rank), then the
pseudo inverse is
A† = AT
(AAT
)
−1
(7.190)
In this case, A†
is a right inverse of A.
We can compute the pseudo inverse using the SVD decomposition A = USVT. In particular, one
can show that
A† = V[diag(1/σ1, · · · , 1/σr, 0, · · · , 0)]UT
(7.191)
where r is the rank of the matrix. Thus A† acts just like a matrix inverse for non-square matrices:
A† = A−1 = (USVT
)
−1 = VS−1UT
(7.192)
where we define S
−1 = diag(σ
−1
1
, . . . , σ−1
r
, 0, . . . , 0).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license256 Chapter 7. Linear Algebra
7.5.4 SVD and the range and null space of a matrix *
In this section, we show that the left and right singular vectors form an orthonormal basis for the
range and null space.
From Equation (7.178) we have
Ax =
X
j:σj>0
σj (v
T
j x)uj =
Xr
j=1
σj (v
T
j x)uj (7.193)
where r is the rank of A. Thus any Ax can be written as a linear combination of the left singular
vectors u1, . . . ,ur, so the range of A is given by
range(A) = span ({uj : σj > 0}) (7.194)
with dimension r.
To find a basis for the null space, let us now define a second vector y ∈ R
n that is a linear
combination solely of the right singular vectors for the zero singular values,
y =
X
j:σj=0
cjvj =
Xn
j=r+1
cjvj (7.195)
Since the vj ’s are orthonormal, we have
Ay = U


σ1v
T
1y
.
.
.
σrv
T
r y
σr+1v
T
r+1y
.
.
.
σnv
T
ny


= U


σ10
.
.
.
σr0
0v
T
r+1y
.
.
.
0v
T
ny


= U0 = 0 (7.196)
Hence the right singular vectors form an orthonormal basis for the null space:
nullspace(A) = span ({vj : σj = 0}) (7.197)
with dimension n − r. We see that
dim(range(A)) + dim(nullspace(A)) = r + (n − r) = n (7.198)
In words, this is often written as
rank + nullity = n (7.199)
This is called the rank-nullity theorem. It follows from this that the rank of a matrix is the
number of nonzero singular values.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.5. Singular value decomposition (SVD) 257
rank 200
(a)
rank 2
(b)
rank 5
(c)
rank 20
(d)
Figure 7.9: Low rank approximations to an image. Top left: The original image is of size 200 × 320, so has
rank 200. Subsequent images have ranks 2, 5, and 20. Generated by code at figures.probml.ai/book1/7.9.
0 20 40 60 80 100
i
0
1
2
3
4
lo
g(σi)
Original
Randomized
Figure 7.10: First 100 log singular values for the clown image (solid red line), and for a data matrix obtained
by randomly shuffling the pixels (dotted green line). Generated by code at figures.probml.ai/book1/7.10.
Adapted from Figure 14.24 of [HTF09].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license258 Chapter 7. Linear Algebra
7.5.5 Truncated SVD
Let A = USVT be the SVD of A, and let Aˆ K = UKSKVT
K, where we use the first K columns of U
and V. This can be shown to be the optimal rank K approximation, in the sense that it minimizes
||A − AˆK||2
F
.
If K = r = rank(A), there is no error introduced by this decomposition. But if K < r, we incur
some error. This is called a truncated SVD. If the singular values die off quickly, as is typical in
natural data (see e.g., Figure 7.10), the error will be small. The total number of parameters needed
to represent an N × D matrix using a rank K approximation is
NK + KD + K = K(N + D + 1) (7.200)
As an example, consider the 200 × 320 pixel image in Figure 7.9(top left). This has 64,000 numbers
in it. We see that a rank 20 approximation, with only (200 + 320 + 1) × 20 = 10, 420 numbers is a
very good approximation.
One can show that the error in this approximation is given by
||A − Aˆ ||F =
Xr
k=K+1
σk (7.201)
where σk is the k’th singular value of A. Furthermore, one can show that the SVD offers the best
rank K approximation to a matrix (best in the sense of minimizing the above Frobenius norm).
7.6 Other matrix decompositions *
In this section, we briefly review some other useful matrix decompositions.
7.6.1 LU factorization
We can factorize any square matrix A into a product of a lower triangular matrix L and an upper
triangular matrix U. For example,


a11 a12 a13
a21 a22 a23
a31 a32 a33

 =


l11 0 0
l21 l22 0
l31 l32 l33




u11 u12 u13
0 u22 u23
0 0 u33

 . (7.202)
In general we may need to permute the entries in the matrix before creating this decomposition.
To see this, suppose a11 = 0. Since a11 = l11u11, this means either l11 or u11 or both must be zero,
but that would imply L or U are singular. To avoid this, the first step of the algorithm can simply
reorder the rows so that the first element is nonzero. This is repeated for subsequent steps. We can
denote this process by
PA = LU (7.203)
where P is a permutation matrix, i.e., a square binary matrix where Pij = 1 if row j gets permuted
to row i. This is called partial pivoting.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.6. Other matrix decompositions * 259
(a)
(b)
Figure 7.11: Illustration of QR decomposition, A = QR, where QTQ = I and R is upper triangular. (a)
Tall, skinny matrix. The shaded parts are not computed in the economy-sized version, since they are not
needed. (b) Short, wide matrix.
7.6.2 QR decomposition
Suppose we have A ∈ R
m×n representing a set of linearly independent basis vectors (so m ≥ n),
and we want to find a series of orthonormal vectors q1, q2, . . . that span the successive subspaces of
span(a1), span(a1, a2), etc. In other words, we want to find vectors qj and coefficients rij such that


| | |
a1 a2 · · · an
| | |

 =


| | |
q1 q2 · · · qn
| | |




r11 r12 · · · r1n
r22 · · · r2n
.
.
.
rnn


(7.204)
We can write this
a1 = r11q1 (7.205)
a2 = r12q1 + r22q2 (7.206)
.
.
.
an = r1nq1 + · · · + rnnqn (7.207)
so we see q1 spans the space of a1, and q1 and q2 span the space of {a1, a2}, etc.
In matrix notation, we have
A = Qˆ Rˆ (7.208)
where Qˆ is m × n with orthonormal columns and Rˆ is n × n and upper triangular. This is called a
reduced QR or economy sized QR factorization of A; see Figure 7.11.
A full QR factorization appends an additional m − n orthonormal columns to Qˆ so it becomes a
square, orthogonal matrix Q, which satisfies QQT = QTQ = I. Also, we append rows made of zero
to Rˆ so it becomes an m × n matrix that is still upper triangular, called R: see Figure 7.11. The
zero entries in R “kill off” the new columns in Q, so the result is the same as Qˆ Rˆ .
QR decomposition is commonly used to solve systems of linear equations, as we discuss in
Section 11.2.2.3.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license260 Chapter 7. Linear Algebra
7.6.3 Cholesky decomposition
Any symmetric positive definite matrix can be factorized as A = RTR, where R is upper triangular
with real, positive diagonal elements. (This can also be written as A = LLT, where L = RT is
lower triangular.) This is called a Cholesky factorization or matrix square root. In NumPy,
this is implemented by np.linalg.cholesky. The computational complexity of this operation is
O(V
3
), where V is the number of variables, but can be less for sparse matrices. Below we give some
applications of this factorization.
7.6.3.1 Application: Sampling from an MVN
The Cholesky decomposition of a covariance matrix can be used to sample from a multivariate
Gaussian. Let y ∼ N (µ, Σ) and Σ = LLT. We first sample x ∼ N (0, I), which is easy because it
just requires sampling from d separate 1d Gaussians. We then set y = Lx + µ. This is valid since
Cov [y] = LCov [x]L
T = L I LT = Σ (7.209)
See code.probml.ai/book1/cholesky_demo for some code.
7.7 Solving systems of linear equations *
An important application of linear algebra is the study of systems of linear equations. For example,
consider the following set of 3 equations:
3x1 + 2x2 − x3 = 1 (7.210)
2x1 − 2x2 + 4x3 = −2 (7.211)
−x1 +
1
2
x2 − x3 = 0 (7.212)
We can represent this in matrix-vector form as follows:
Ax = b (7.213)
where
A =


3 2 −1
2 −2 4
−1
1
2 −1

 , b =


1
−2
0

 (7.214)
The solution is x = [1, −2, −2].
In general, if we have m equations and n unknowns, then A will be a m × n matrix, and b will be
a m × 1 vector. If m = n (and A is full rank), there is a single unique solution. If m < n, the system
is underdetermined, so there is not a unique solution. If m > n, the system is overdetermined,
since there are more constraints than unknowns, and not all the lines intersect at the same point.
See Figure 7.12 for an illustration. We discuss how to compute solutions in each of these cases below.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.7. Solving systems of linear equations * 261
Figure 7.12: Solution of a set of m linear equations in n = 2 variables. (a) m = 1 < n so the system is
underdetermined. We show the minimal norm solution as a blue circle. (The dotted red line is orthogonal
to the line, and its length is the distance to the origin.) (b) m = n = 2, so there is a unique solution. (c)
m = 3 > n, so there is no unique solution. We show the least squares solution.
7.7.1 Solving square systems
In the case where m = n, we can solve for x by computing an LU decomposition, A = LU, and then
proceeding as follows:
Ax = b (7.215)
LUx = b (7.216)
Ux = L
−1
b , y (7.217)
x = U−1y (7.218)
The crucial point is that L and U are both triangular matrices, so we can avoid taking matrix
inverses, and use a method known as backsubstitution instead.
In particular, we can solve y = L
−1b without taking inverses as follows. First we write


L11
L21 L22
.
.
.
Ln1 Ln2 · · · Lnn




y1
.
.
.
yn

 =


b1
.
.
.
bn

 (7.219)
We start by solving L11y1 = b1 to find y1 and then substitute this in to solve
L21y1 + L22y2 = b2 (7.220)
for y2. We repeat this recursively. This process is often denoted by the backslash operator,
y = L \ b. Once we have y, we can solve x = U−1y using backsubstitution in a similar manner.
7.7.2 Solving underconstrained systems (least norm estimation)
In this section, we consider the underconstrained setting, where m < n.
3 We assume the rows are
linearly independent, so A is full rank.
3. Our presentation is based in part on lecture notes by Stephen Boyd at http://ee263.stanford.edu/lectures/
min-norm.pdf.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license262 Chapter 7. Linear Algebra
When m < n, there are multiple possible solutions, which have the form
{x : Ax = b} = {xp + z : z ∈ nullspace(A)} (7.221)
where xp is any particular solution. It is standard to pick the particular solution with minimal `2
norm, i.e.,
xˆ = argmin
x
||x||2
2
s.t. Ax = b (7.222)
We can compute the minimal norm solution using the right pseudo inverse:
xpinv = AT
(AAT
)
−1
b (7.223)
(See Section 7.5.3 for more details.)
To see this, suppose x is some other solution, so Ax = b, and A(x − xpinv) = 0. Thus
(x − xpinv)
Txpinv = (x − xpinv)
TAT
(AAT
)
−1
b = (A(x − xpinv))T
(AAT
)
−1
b = 0 (7.224)
and hence (x − xpinv) ⊥ xpinv. By Pythagoras’s theorem, the norm of x is
||x||2 = ||xpinv + x − xpinv||2 = ||xpinv||2 + ||x − xpinv||2 ≥ ||xpinv||2
(7.225)
Thus any solution apart from xpinv has larger norm.
We can also solve the constrained optimization problem in Equation (7.222) by minimizing the
following unconstrained objective
L(x,λ) = x
Tx + λ
T
(Ax − b) (7.226)
From Section 8.5.1, the optimality conditions are
∇xL = 2x + ATλ = 0, ∇λL = Ax − b = 0 (7.227)
From the first condition we have x = −ATλ/2. Subsituting into the second we get
Ax = −
1
2
AATλ = b (7.228)
which implies λ = −2(AAT)
−1b. Hence x = AT(AAT)
−1b, which is the right pseudo inverse
solution.
7.7.3 Solving overconstrained systems (least squares estimation)
If m > n, we have an overdetermined solution, which typically does not have an exact solution,
but we will try to find the solution that gets as close as possible to satisfying all of the constraints
specified by Ax = b. We can do this by minimizing the following cost function, known as the least
squares objective:
4
f(x) = 1
2
||Ax − b||2
2
(7.233)
4. Note that some equation numbers have been skipped. This is intentional. The reason is that I have omitted
some erroneous material from an earlier version (described in https://github.com/probml/pml-book/issues/266),
but want to make sure the equation numbering is consistent across different versions of the book.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.8. Matrix calculus 263
Using matrix calculus results from Section 7.8 we have that the gradient is given by
g(x) = ∂
∂x
f(x) = ATAx − AT
b (7.234)
The optimum can be found by solving g(x) = 0. This gives
ATAx = AT
b (7.235)
These are known as the normal equations, since, at the optimal solution, b − Ax is normal
(orthogonal) to the range of A, as we explain in Section 11.2.2.2. The corresponding solution xˆ is
the ordinary least squares (OLS) solution, which is given by
xˆ = (ATA)
−1AT
b (7.236)
The quantity A† = (ATA)
−1AT is the left pseudo inverse of the (non-square) matrix A (see
Section 7.5.3 for more details).
We can check that the solution is unique by showing that the Hessian is positive definite. In this
case, the Hessian is given by
H(x) = ∂
2
∂x2
f(x) = ATA (7.237)
If A is full rank (so the columns of A are linearly independent), then H is positive definite, since for
any v > 0, we have
v
T
(ATA)v = (Av)
T
(Av) = ||Av||2 > 0 (7.238)
Hence in the full rank case, the least squares objective has a unique global minimum.
7.8 Matrix calculus
The topic of calculus concerns computing “rates of change” of functions as we vary their inputs. It
is of vital importance to machine learning, as well as almost every other numerical discipline. In this
section, we review some standard results. In some cases, we use some concepts and notation from
matrix algebra, which we cover in Chapter 7. For more details on these results from a deep learning
perspective, see [PH18].
7.8.1 Derivatives
Consider a scalar-argument function f : R → R. We define its derivative at a point a to be the
quantity
f
0
(x) , lim
h→0
f(x + h) − f(x)
h
(7.239)
assuming the limit exists. This measures how quickly the output changes when we move a small
distance in input space away from x (i.e., the “rate of change” of the function). We can interpret
f
0
(x) as the slope of the tangent line at f(x), and hence
f(x + h) ≈ f(x) + f
0
(x)h (7.240)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license264 Chapter 7. Linear Algebra
for small h.
We can compute a finite difference approximation to the derivative by using a finite step size h,
as follows:
f
0
(x) ≡ lim
h→0
f(x + h) − f(x)
h
| {z }
forward difference
= lim
h→0
f(x + h/2) − f(x − h/2)
h
| {z }
central difference
= lim
h→0
f(x) − f(x − h)
h
| {z }
backward difference
(7.241)
The smaller the step size h, the better the estimate, although if h is too small, there can be errors
due to numerical cancellation.
We can think of differentiation as an operator that maps functions to functions, D(f) = f
0
, where
f
0
(x) computes the derivative at x (assuming the derivative exists at that point). The use of the
prime symbol f
0
to denote the derivative is called Lagrange notation. The second derivative
function, which measures how quickly the gradient is changing, is denoted by f
00. The n’th derivative
function is denoted f
(n)
.
Alternatively, we can use Leibniz notation, in which we denote the function by y = f(x), and its
derivative by dy
dx or d
dx f(x). To denote the evaluation of the derivative at a point a, we write df
dx




x=a
.
7.8.2 Gradients
We can extend the notion of derivatives to handle vector-argument functions, f : R
n → R, by defining
the partial derivative of f with respect to xi to be
∂f
∂xi
= lim
h→0
f(x + hei) − f(x)
h
(7.242)
where ei
is the i’th unit vector.
The gradient of a function at a point x is the vector of its partial derivatives:
g =
∂f
∂x
= ∇f =


∂f
∂x1
.
.
.
∂f
∂xn

 (7.243)
To emphasize the point at which the gradient is evaluated, we can write
g(x
∗
) ,
∂f
∂x




x∗
(7.244)
We see that the operator ∇ (pronounced “nabla”) maps a function f : R
n → R to another function
g : R
n → R
n. Since g() is a vector-valued function, it is known as a vector field. By contrast, the
derivative function f
0
is a scalar field.
7.8.3 Directional derivative
The directional derivative measures how much the function f : R
n → R changes along a direction
v in space. It is defined as follows
Dvf(x) = lim
h→0
f(x + hv) − f(x)
h
(7.245)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.8. Matrix calculus 265
We can approximate this numerically using 2 function calls to f, regardless of n. By contrast, a
numerical approximation to the standard gradient vector takes n + 1 calls (or 2n if using central
differences).
Note that the directional derivative along v is the scalar product of the gradient g and the vector
v:
Dvf(x) = ∇f(x) · v (7.246)
7.8.4 Total derivative *
Suppose that some of the arguments to the function depend on each other. Concretely, suppose the
function has the form f(t, x(t), y(t)). We define the total derivative of f wrt t as follows:
df
dt =
∂f
∂t +
∂f
∂x
dx
dt +
∂f
∂y
dy
dt (7.247)
If we multiply both sides by the differential dt, we get the total differential
df =
∂f
∂t dt +
∂f
∂xdx +
∂f
∂y dy (7.248)
This measures how much f changes when we change t, both via the direct effect of t on f, but also
indirectly, via the effects of t on x and y.
7.8.5 Jacobian
Consider a function that maps a vector to another vector, f : R
n → R
m. The Jacobian matrix of
this function is an m × n matrix of partial derivatives:
Jf (x) = ∂f
∂xT
,


∂f1
∂x1
· · ·
∂f1
∂xn
.
.
.
.
.
.
.
.
.
∂fm
∂x1
· · ·
∂fm
∂xn

 =


∇f1(x)
T
.
.
.
∇fm(x)
T

 (7.249)
Note that we lay out the results in the same orientation as the output f; this is sometimes called
numerator layout or the Jacobian formulation.5
7.8.5.1 Multiplying Jacobians and vectors
The Jacobian vector product or JVP is defined to be the operation that corresponds to right￾multiplying the Jacobian matrix J ∈ R
m×n by a vector v ∈ R
n:
Jf (x)v =


∇f1(x)
T
.
.
.
∇fm(x)
T


v =


∇f1(x)
Tv
.
.
.
∇fm(x)
Tv

 (7.250)
5. For a much more detailed discussion of notation, see https://en.wikipedia.org/wiki/Matrix_calculus.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license266 Chapter 7. Linear Algebra
So we can see that we can approximate this numerically using just 2 calls to f.
The vector Jacobian product or VJP is defined to be the operation that corresponds to
left-multiplying the Jacobian matrix J ∈ R
m×n by a vector u ∈ R
m:
u
TJf (x) = u
T

∂f
∂x1
, · · · ,
∂f
∂xn

=

u ·
∂f
∂x1
, · · · ,u ·
∂f
∂xn

(7.251)
The JVP is more efficient if m ≥ n, and the VJP is more efficient if m ≤ n. See Section 13.3 for
details on how this can be used to perform automatic differentiation in a computation graph such as
a DNN.
7.8.5.2 Jacobian of a composition
Sometimes it is useful to take the Jacobian of the composition of two functions. Let h(x) = g(f(x)).
By the chain rule of calculus, we have
Jh(x) = Jg(f(x))Jf (x) (7.252)
For example, suppose f : R → R
2 and g : R
2 → R
2
. We have
∂g
∂x =
 ∂
∂x g1(f1(x), f2(x))
∂
∂x g2(f1(x), f2(x))
=
 ∂g1
∂f1
∂f1
∂x +
∂g1
∂f2
∂f2
∂x
∂g2
∂f1
∂f1
∂x +
∂g2
∂f2
∂f2
∂x !
(7.253)
=
∂g
∂f
T
∂f
∂x =
 ∂g1
∂f1
∂g1
∂f2
∂g2
∂f1
∂g2
∂f2
! ∂f1
∂x
∂f2
∂x

(7.254)
7.8.6 Hessian
For a function f : R
n → R that is twice differentiable, we define the Hessian matrix as the
(symmetric) n × n matrix of second partial derivatives:
Hf =
∂
2f
∂x2
= ∇2
f =


∂
2
f
∂x2
1
· · ·
∂
2
f
∂x1∂xn
.
.
.
∂
2
f
∂xn∂x1
· · ·
∂
2
f
∂x2
n


(7.255)
We see that the Hessian is the Jacobian of the gradient.
7.8.7 Gradients of commonly used functions
In this section, we list without proof the gradients of certain widely used functions.
7.8.7.1 Functions that map scalars to scalars
Consider a differentiable function f : R → R. Here are some useful identities from scalar calculus,
which you should already be familiar with.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20227.8. Matrix calculus 267
d
dxcxn = cnxn−1
(7.256)
d
dx log(x) = 1/x (7.257)
d
dx exp(x) = exp(x) (7.258)
d
dx [f(x) + g(x)] = df(x)
dx +
dg(x)
dx (7.259)
d
dx [f(x)g(x)] = f(x)
dg(x)
dx + g(x)
df(x)
dx (7.260)
d
dxf(u(x)) = du
dx
df(u)
du (7.261)
Equation (7.261) is known as the chain rule of calculus.
7.8.7.2 Functions that map vectors to scalars
Consider a differentiable function f : R
n → R. Here are some useful identities:6
∂(a
Tx)
∂x
= a (7.262)
∂(b
TAx)
∂x
= AT
b (7.263)
∂(x
TAx)
∂x
= (A + AT
)x (7.264)
It is fairly easy to prove these identities by expanding out the quadratic form, and applying scalar
calculus.
7.8.7.3 Functions that map matrices to scalars
Consider a function f : R
m×n → R which maps a matrix to a scalar. We are using the following
natural layout for the derivative matrix:
∂f
∂X
=


∂f
∂x11
· · ·
∂f
∂x1n
.
.
.
∂f
∂xm1
· · ·
∂f
∂xmn

 (7.265)
Below are some useful identities.
6. Some of the identities are taken from the list at http://www.cs.nyu.edu/~roweis/notes/matrixid.pdf.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license268 Chapter 7. Linear Algebra
Identities involving quadratic forms
One can show the following results.
∂
∂X
(a
TXb) = abT
(7.266)
∂
∂X
(a
TXT
b) = baT
(7.267)
Identities involving matrix trace
One can show the following results.
∂
∂X
tr(AXB) = ATB
T
(7.268)
∂
∂X
tr(XTA) = A (7.269)
∂
∂X
tr(X−1A) = −X−TATX−T
(7.270)
∂
∂X
tr(XTAX) = (A + AT
)X (7.271)
Identities involving matrix determinant
One can show the following results.
∂
∂X
det(AXB) = det(AXB)X−T
(7.272)
∂
∂X
ln(det(X)) = X−T
(7.273)
7.9 Exercises
Exercise 7.1 [Orthogonal matrices]
a. A rotation in 3d by angle α about the z axis is given by the following matrix:
R(α) =


cos(α) − sin(α) 0
sin(α) cos(α) 0
0 0 1

 (7.274)
Prove that R is an orthogonal matrix, i.e., RT R = I, for any α.
b. What is the only eigenvector v of R with an eigenvalue of 1.0 and of unit norm (i.e., ||v||2 = 1)? (Your
answer should be the same for any α.) Hint: think about the geometrical interpretation of eigenvectors.
Exercise 7.2 [Eigenvectors by hand *]
Find the eigenvalues and eigenvectors of the following matrix
A =

2 0
0 3
(7.275)
Compute your result by hand and check it with Python.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228 Optimization
Parts of this chapter were written by Frederik Kunstner, Si Yi Meng, Aaron Mishkin, Sharan Vaswani,
and Mark Schmidt.
8.1 Introduction
We saw in Chapter 4 that the core problem in machine learning is parameter estimation (aka model
fitting). This requires solving an optimization problem, where we try to find the values for a set
of variables θ ∈ Θ, that minimize a scalar-valued loss function or cost function L : Θ → R:
θ
∗ ∈ argmin
θ∈Θ
L(θ) (8.1)
We will assume that the parameter space is given by Θ ⊆ R
D, where D is the number of variables
being optimized over. Thus we are focusing on continuous optimization, rather than discrete
optimization.
If we want to maximize a score function or reward function R(θ), we can equivalently minimize
L(θ) = −R(θ). We will use the term objective function to refer generically to a function we want
to maximize or minimize. An algorithm that can find an optimum of an objective function is often
called a solver.
In the rest of this chapter, we discuss different kinds of solvers for different kinds of objective
functions, with a focus on methods used in the machine learning community. For more details on
optimization, please consult some of the many excellent textbooks, such as [KW19b; BV04; NW06;
Ber15; Ber16] as well as various review articles, such as [BCN18; Sun+19b; PPS18; Pey20].
8.1.1 Local vs global optimization
A point that satisfies Equation (8.1) is called a global optimum. Finding such a point is called
global optimization.
In general, finding global optima is computationally intractable [Neu04]. In such cases, we will
just try to find a local optimum. For continuous problems, this is defined to be a point θ
∗ which
has lower (or equal) cost than “nearby” points. Formally, we say θ
∗
is a local minimum if
∃δ > 0, ∀θ ∈ Θ s.t. ||θ − θ
∗
|| < δ, L(θ
∗
) ≤ L(θ) (8.2)270 Chapter 8. Optimization
1.0 0.5 0.0 0.5 1.0 1.5 2.0 2.5 3.0
2.5
2.0
1.5
1.0
0.5
0.0
0.5
1.0
1.5
local minimum
Global minimum
(a)
X
4
2
0
2
4
Y
4
2
0
2
4
Z
20
10
0
10
20
*
Saddle Point
(b)
Figure 8.1: (a) Illustration of local and global minimum in 1d. Generated by code at figures.probml.ai/book1/8.1.
(b) Illustration of a saddle point in 2d. Generated by code at figures.probml.ai/book1/8.1.
A local minimum could be surrounded by other local minima with the same objective value; this
is known as a flat local minimum. A point is said to be a strict local minimum if its cost is
strictly lower than those of neighboring points:
∃δ > 0, ∀θ ∈ Θ, θ 6= θ
∗
: ||θ − θ
∗
|| < δ, L(θ
∗
) < L(θ) (8.3)
We can define a (strict) local maximum analogously. See Figure 8.1a for an illustration.
A final note on terminology; if an algorithm is guaranteed to converge to a stationary point
from any starting point, it is called globally convergent. However, this does not mean (rather
confusingly) that it will converge to a global optimum; instead, it just means it will converge to some
stationary point.
8.1.1.1 Optimality conditions for local vs global optima
For continuous, twice differentiable functions, we can precisely characterize the points which cor￾respond to local minima. Let g(θ) = ∇L(θ) be the gradient vector, and H(θ) = ∇2L(θ) be the
Hessian matrix. (See Section 7.8 for a refresher on these concepts, if necessary.) Consider a point
θ
∗ ∈ R
D, and let g
∗ = g(θ)|θ∗ be the gradient at that point, and H∗ = H(θ)|θ∗ be the corresponding
Hessian. One can show that the following conditions characterize every local minimum:
• Necessary condition: If θ
∗
is a local minimum, then we must have g
∗ = 0 (i.e., θ
∗ must be a
stationary point), and H∗ must be positive semi-definite.
• Sufficient condition: If g
∗ = 0 and H∗
is positive definite, then θ
∗
is a local optimum.
To see why the first condition is necessary, suppose we were at a point θ
∗ at which the gradient is
non-zero: at such a point, we could decrease the function by following the negative gradient a small
distance, so this would not be optimal. So the gradient must be zero. (In the case of nonsmooth
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.1. Introduction 271
functions, the necessary condition is that the zero is a local subgradient at the minimum.) To see why
a zero gradient is not sufficient, note that the stationary point could be a local minimum, maximum
or saddle point, which is a point where some directions point downhill, and some uphill (see
Figure 8.1b). More precisely, at a saddle point, the eigenvalues of the Hessian will be both positive
and negative. However, if the Hessian at a point is positive semi-definite, then some directions may
point uphill, while others are flat. This means that the objective function can not be decreased in
the neighbourhood of this point, implying that it is necessarily a local minimum. Moreover, if the
Hessian is strictly positive definite, then we are at the bottom of a “bowl”, and all directions point
uphill, which is sufficient for this to be a minimum.
8.1.2 Constrained vs unconstrained optimization
In unconstrained optimization, we define the optimization task as finding any value in the
parameter space Θ that minimizes the loss. However, we often have a set of constraints on the
allowable values. It is standard to partition the set of constraints C into inequality constraints,
gj (θ) ≤ 0 for j ∈ I and equality constraints, hk(θ) = 0 for k ∈ E. For example, we can represent a
sum-to-one constraint as an equality constraint h(θ) = (1−
PD
i=1 θi) = 0, and we can represent a non￾negativity constraint on the parameters by using D inequality constraints of the form gi(θ) = −θi ≤ 0
.
We define the feasible set as the subset of the parameter space that satisfies the constraints:
C = {θ : gj (θ) ≤ 0 : j ∈ I, hk(θ) = 0 : k ∈ E} ⊆ R
D (8.4)
Our constrained optimization problem now becomes
θ
∗ ∈ argmin
θ∈C
L(θ) (8.5)
If C = R
D, it is called unconstrained optimization.
The addition of constraints can change the number of optima of a function. For example, a function
that was previously unbounded (and hence had no well-defined global maximum or minimum) can
“acquire” multiple maxima or minima when we add constraints, as illustrated in Figure 8.2. However,
if we add too many constraints, we may find that the feasible set becomes empty. The task of finding
any point (regardless of its cost) in the feasible set is called a feasibility problem; this can be a
hard subproblem in itself.
A common strategy for solving constrained problems is to create penalty terms that measure
how much we violate each constraint. We then add these terms to the objective and solve an
unconstrained optimization problem. The Lagrangian is a special case of such a combined objective
(see Section 8.5 for details).
8.1.3 Convex vs nonconvex optimization
In convex optimization, we require the objective to be a convex function defined over a convex
set (we define these terms below). In such problems, every local minimum is also a global minimum.
Thus many models are designed so that their training objectives are convex.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license272 Chapter 8. Optimization
Figure 8.2: Illustration of constrained maximization of a nonconvex 1d function. The area between the dotted
vertical lines represents the feasible set. (a) There is a unique global maximum since the function is concave
within the support of the feasible set. (b) There are two global maxima, both occuring at the boundary of the
feasible set. (c) In the unconstrained case, this function has no global maximum, since it is unbounded.
Figure 8.3: Illustration of some convex and non-convex sets.
8.1.3.1 Convex sets
We say S is a convex set if, for any x, x
0 ∈ S, we have
λx + (1 − λ)x
0 ∈ S, ∀ λ ∈ [0, 1] (8.6)
That is, if we draw a line from x to x
0
, all points on the line lie inside the set. See Figure 8.3 for
some illustrations of convex and non-convex sets.
8.1.3.2 Convex functions
We say f is a convex function if its epigraph (the set of points above the function, illustrated in
Figure 8.4a) defines a convex set. Equivalently, a function f(x) is called convex if it is defined on a
convex set and if, for any x, y ∈ S, and for any 0 ≤ λ ≤ 1, we have
f(λx + (1 − λ)y) ≤ λf(x) + (1 − λ)f(y) (8.7)
See Figure 8.5(a) for a 1d example of a convex function. A function is called strictly convex if the
inequality is strict. A function f(x) is concave if −f(x) is convex, and strictly concave if −f(x)
is strictly convex. See Figure 8.5(b) for a 1d example of a function that is neither convex nor concave.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.1. Introduction 273
epi f (x)
f (x)
x1 x2
(a) (b)
Figure 8.4: (a) Illustration of the epigraph of a function. (b) For a convex function f(x), its epipgraph can
be represented as the intersection of half-spaces defined by linear lower bounds derived from the conjugate
function f
∗
(λ) = maxx λx − f(x).
X y
1- l
l
(a)
A B
(b)
Figure 8.5: (a) Illustration of a convex function. We see that the chord joining (x, f(x)) to (y, f(y)) lies
above the function. (b) A function that is neither convex nor concave. A is a local minimum, B is a global
minimum.
Here are some examples of 1d convex functions:
x
2
e
ax
− log x
x
a
, a > 1, x > 0
|x|
a
, a ≥ 1
x log x, x > 0
8.1.3.3 Characterization of convex functions
Intuitively, a convex function is shaped like a bowl. Formally, one can prove the following important
result:
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license274 Chapter 8. Optimization
Figure 8.6: The quadratic form f(x) = x
TAx in 2d. (a) A is positive definite, so f is convex. (b) A is
negative definite, so f is concave. (c) A is positive semidefinite but singular, so f is convex, but not strictly.
Notice the valley of constant height in the middle. (d) A is indefinite, so f is neither convex nor concave.
The stationary point in the middle of the surface is a saddle point. From Figure 5 of [She94].
Theorem 8.1.1. Suppose f : R
n → R is twice differentiable over its domain. Then f is convex iff
H = ∇2f(x) is positive semi definite (Section 7.1.5.3) for all x ∈ dom(f). Furthermore, f is strictly
convex if H is positive definite.
For example, consider the quadratic form
f(x) = x
TAx (8.8)
This is convex if A is positive semi definite, and is strictly convex if A is positive definite. It is
neither convex nor concave if A has eigenvalues of mixed sign. See Figure 8.6.
8.1.3.4 Strongly convex functions
We say a function f is strongly convex with parameter m > 0 if the following holds for all x, y in
f’s domain:
(∇f(x) − ∇f(y))T
(x − y) ≥ m||x − y||2
2
(8.9)
A strongly convex function is also strictly convex, but not vice versa.
If the function f is twice continuously differentiable, then it is strongly convex with parameter m
if and only if ∇2f(x)  mI for all x in the domain, where I is the identity and ∇2f is the Hessian
matrix, and the inequality  means that ∇2f(x) − mI is positive semi-definite. This is equivalent
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.1. Introduction 275
−1.00 −0.75 −0.50 −0.25 0.00 0.25 0.50 0.75 1.00
0.0
0.2
0.4
0.6
0.8
1.0
Smooth function
(a)
−1.00 −0.75 −0.50 −0.25 0.00 0.25 0.50 0.75 1.00
0.0
0.2
0.4
0.6
0.8
1.0
Non-smooth function
(b)
Figure 8.7: (a) Smooth 1d function. (b) Non-smooth 1d function. (There is a discontinuity at the origin.)
Generated by code at figures.probml.ai/book1/8.7.
to requiring that the minimum eigenvalue of ∇2f(x) be at least m for all x. If the domain is just
the real line, then ∇2f(x) is just the second derivative f
00(x), so the condition becomes f
00(x) ≥ m.
If m = 0, then this means the Hessian is positive semidefinite (or if the domain is the real line, it
means that f
00(x) ≥ 0), which implies the function is convex, and perhaps strictly convex, but not
strongly convex.
The distinction between convex, strictly convex, and strongly convex is rather subtle. To better
understand this, consider the case where f is twice continuously differentiable and the domain is the
real line. Then we can characterize the differences as follows:
• f is convex if and only if f
00(x) ≥ 0 for all x.
• f is strictly convex if f
00(x) > 0 for all x (note: this is sufficient, but not necessary).
• f is strongly convex if and only if f
00(x) ≥ m > 0 for all x.
Note that it can be shown that a function f is strongly convex with parameter m iff the function
J(x) = f(x) −
m
2
||x||2
(8.10)
is convex.
8.1.4 Smooth vs nonsmooth optimization
In smooth optimization, the objective and constraints are continuously differentiable functions.
For smooth functions, we can quantify the degree of smoothness using the Lipschitz constant. In
the 1d case, this is defined as any constant L ≥ 0 such that, for all real x1 and x2, we have
|f(x1) − f(x2)| ≤ L|x1 − x2| (8.11)
This is illustrated in Figure 8.8: for a given constant L, the function output cannot change by more
than L if we change the function input by 1 unit. This can be generalized to vector inputs using a
suitable norm.
In nonsmooth optimization, there are at least some points where the gradient of the objective
function or the constraints is not well-defined. See Figure 8.7 for an example. In some optimization
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license276 Chapter 8. Optimization
Figure 8.8: For a Lipschitz continuous function f, there exists a double cone (white) whose origin can be
moved along the graph of f so that the whole graph always stays outside the double cone. From https: // en.
wikipedia. org/ wiki/ Lipschitz_ continuity . Used with kind permission of Wikipedia author Taschee.
problems, we can partition the objective into a part that only contains smooth terms, and a part
that contains the nonsmooth terms:
L(θ) = Ls(θ) + Lr(θ) (8.12)
where Ls is smooth (differentiable), and Lr is nonsmooth (“rough”). This is often referred to as a
composite objective. In machine learning applications, Ls is usually the training set loss, and
Lr is a regularizer, such as the `1 norm of θ. This composite structure can be exploited by various
algorithms.
8.1.4.1 Subgradients
In this section, we generalize the notion of a derivative to work with functions which have local
discontinuities. In particular, for a convex function of several variables, f : R
n → R, we say that
g ∈ R
n is a subgradient of f at x ∈ dom(f) if for all vectors z ∈ dom(f),
f(z) ≥ f(x) + g
T
(z − x) (8.13)
Note that a subgradient can exist even when f is not differentiable at a point, as shown in Figure 8.9.
A function f is called subdifferentiable at x if there is at least one subgradient at x. The set of
such subgradients is called the subdifferential of f at x, and is denoted ∂f(x).
For example, consider the absolute value function f(x) = |x|. Its subdifferential is given by
∂f(x) =



{−1} if x < 0
[−1, 1] if x = 0
{+1} if x > 0
(8.14)
where the notation [−1, 1] means any value between -1 and 1 inclusive. See Figure 8.10 for an
illustration.
8.2 First-order methods
In this section, we consider iterative optimization methods that leverage first order derivatives of
the objective function, i.e., they compute which directions point “downhill”, but they ignore curvature
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.2. First-order methods 277
Subgradient of a function
g is a subgradient of f (not necessarily convex) at x if
f(y) ≥ f(x) + gT (y − x) for all y
x1 x2
f(x1) + gT
1 (x − x1)
f(x2) + gT
2 (x − x2)
f(x2) + gT
3 (x − x2)
f(x)
g2, g3 are subgradients at x2; g1 is a subgradient at x1
EE364b, Stanford University 2
Figure 8.9: Illustration of subgradients. At x1, the convex function f is differentiable, and g1 (which is
the derivative of f at x1) is the unique subgradient at x1. At the point x2, f is not differentiable, because
of the “kink”. However, there are many subgradients at this point, of which two are shown. From https:
// web. stanford. edu/ class/ ee364b/ lectures/ subgradients_ slides. pdf . Used with kind permission
of Stephen Boyd. Example
f(x) = |x|
f(x) = |x| ∂f(x)
x
x
1
−1
righthand plot shows ! {(x, g) | x ∈ R, g ∈ ∂f(x)}
EE364b, Stanford University 6
Figure 8.10: The absolute value function (left) and its subdifferential (right). From https: // web. stanford.
edu/ class/ ee364b/ lectures/ subgradients_ slides. pdf . Used with kind permission of Stephen Boyd.
information. All of these algorithms require that the user specify a starting point θ0. Then at each
iteration t, they perform an update of the following form:
θt+1 = θt + ηtdt (8.15)
where ηt is known as the step size or learning rate, and dt is a descent direction, such as the
negative of the gradient, given by gt = ∇θL(θ)|θt
. These update steps are continued until the
method reaches a stationary point, where the gradient is zero.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license278 Chapter 8. Optimization
8.2.1 Descent direction
We say that a direction d is a descent direction if there is a small enough (but nonzero) amount η
we can move in direction d and be guaranteed to decrease the function value. Formally, we require
that there exists an ηmax > 0 such that
L(θ + ηd) < L(θ) (8.16)
for all 0 < η < ηmax. The gradient at the current iterate,
gt , ∇L(θ)|θt = ∇L(θt) = g(θt) (8.17)
points in the direction of maximal increase in f, so the negative gradient is a descent direction. It
can be shown that any direction d is also a descent direction if the angle θ between d and −gt is less
than 90 degrees and satisfies
d
T
gt = ||d|| ||gt|| cos(θ) < 0 (8.18)
It seems that the best choice would be to pick dt = −gt. This is known as the direction of steepest
descent. However, this can be quite slow. We consider faster versions later.
8.2.2 Step size (learning rate)
In machine learning, the sequence of step sizes {ηt} is called the learning rate schedule. There are
several widely used methods for picking this, some of which we discuss below. (See also Section 8.4.3,
where we discuss schedules for stochastic optimization.)
8.2.2.1 Constant step size
The simplest method is to use a constant step size, ηt = η. However, if it is too large, the method
may fail to converge, and if it is too small, the method will converge but very slowly.
For example, consider the convex function
L(θ) = 0.5(θ
2
1 − θ2)
2 + 0.5(θ1 − 1)2
(8.19)
Let us pick as our descent direction dt = −gt. Figure 8.11 shows what happens if we use this descent
direction with a fixed step size, starting from (0, 0). In Figure 8.11(a), we use a small step size of
η = 0.1; we see that the iterates move slowly along the valley. In Figure 8.11(b), we use a larger step
size η = 0.6; we see that the iterates start oscillating up and down the sides of the valley and never
converge to the optimum, even though this is a convex problem.
In some cases, we can derive a theoretical upper bound on the maximum step size we can use. For
example, consider a quadratic objective, L(θ) = 1
2
θ
TAθ + b
Tθ + c with A  0. One can show that
steepest descent will have global convergence iff the step size satisfies
η <
2
λmax(A)
(8.20)
where λmax(A) is the largest eigenvalue of A. The intuitive reason for this can be understood by
thinking of a ball rolling down a valley. We want to make sure it doesn’t take a step that is larger than
the slope of the steepest direction, which is what the largest eigenvalue measures (see Section 3.2.2).
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.2. First-order methods 279
0.00 0.25 0.50 0.75 1.00 1.25 1.50 1.75
0.5
0.0
0.5
1.0
1.5
2.0
2.5
step size 0.100
(a)
0.00 0.25 0.50 0.75 1.00 1.25 1.50 1.75
0.5
0.0
0.5
1.0
1.5
2.0
2.5
step size 0.600
(b)
Figure 8.11: Steepest descent on a simple convex function, starting from (0, 0), for 20 steps, using a
fixed step size. The global minimum is at (1, 1). (a) η = 0.1. (b) η = 0.6. Generated by code at
figures.probml.ai/book1/8.11.
More generally, setting η < 2/L, where L is the Lipschitz constant of the gradient (Section 8.1.4),
ensures convergence. Since this constant is generally unknown, we usually need to adapt the step
size, as we discuss below.
8.2.2.2 Line search
The optimal step size can be found by finding the value that maximally decreases the objective along
the chosen direction by solving the 1d minimization problem
ηt = argmin
η>0
φt(η) = argmin
η>0
L(θt + ηdt) (8.21)
This is known as line search, since we are searching along the line defined by dt.
If the loss is convex, this subproblem is also convex, because φt(η) = L(θt + ηdt) is a convex
function of an affine function of η, for fixed θt and dt. For example, consider the quadratic loss
L(θ) = 1
2
θ
TAθ + b
Tθ + c (8.22)
Computing the derivative of φ gives
dφ(η)
dη =
d
dη 
1
2
(θ + ηd)
TA(θ + ηd) + b
T
(θ + ηd) + c

(8.23)
= d
TA(θ + ηd) + d
T
b (8.24)
= d
T
(Aθ + b) + ηd
TAd (8.25)
Solving for dφ(η)
dη = 0 gives
η = −
d
T(Aθ + b)
dTAd
(8.26)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license280 Chapter 8. Optimization
Using the optimal step size is known as exact line search. However, it is not usually necessary
to be so precise. There are several methods, such as the Armijo backtracking method, that try
to ensure sufficient reduction in the objective function without spending too much time trying to
solve Equation (8.21). In particular, we can start with the current stepsize (or some maximum value),
and then reduce it by a factor 0 < β < 1 at each step until we satisfy the following condition, known
as the Armijo-Goldstein test:
L(θt + ηdt) ≤ L(θt) + cηd
T
t ∇L(θt) (8.27)
where c ∈ [0, 1] is a constant, typically c = 10−4
. In practice, the initialization of the line-search and
how to backtrack can significantly affect performance. See [NW06, Sec 3.1] for details.
8.2.3 Convergence rates
We want to find optimization algorithms that converge quickly to a (local) optimum. For certain
convex problems, with a gradient with bounded Lipschitz constant, one can show that gradient
descent converges at a linear rate. This means that there exists a number 0 < µ < 1 such that
|L(θt+1) − L(θ∗)| ≤ µ|L(θt) − L(θ∗)| (8.28)
Here µ is called the rate of convergence.
For some simple problems, we can derive the convergence rate explicitly, For example, consider a
quadratic objective L(θ) = 1
2
θ
TAθ + b
Tθ + c with A  0. Suppose we use steepest descent with
exact line search. One can show (see e.g., [Ber15]) that the convergence rate is given by
µ =

λmax − λmin
λmax + λmin 2
(8.29)
where λmax is the largest eigenvalue of A and λmin is the smallest eigenvalue. We can rewrite this
as µ =
￾
κ−1
κ+1 
2
, where κ =
λmax
λmin
is the condition number of A. Intuitively, the condition number
measures how “skewed” the space is, in the sense of being far from a symmetrical “bowl”. (See
Section 7.1.4.4 for more information on condition numbers.)
Figure 8.12 illustrates the effect of the condition number on the convergence rate. On the left
we show an example where A = [20, 5; 5, 2], b = [−14; −6] and c = 10, so κ(A) = 30.234. On the
right we show an example where A = [20, 5; 5, 16], b = [−14; −6] and c = 10, so κ(A) = 1.8541. We
see that steepest descent converges much more quickly for the problem with the smaller condition
number.
In the more general case of non-quadratic functions, the objective will often be locally quadratic
around a local optimum. Hence the convergence rate depends on the condition number of the Hessian,
κ(H), at that point. We can often improve the convergence speed by optimizing a surrogate objective
(or model) at each step which has a Hessian that is close to the Hessian of the objective function as
we discuss in Section 8.3.
Although line search works well, we see from Figure 8.12 that the path of steepest descent with an
exact line-search exhibits a characteristic zig-zag behavior, which is inefficient. This problem can be
overcome using a method called conjugate gradient descent (see e.g., [She94]).
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2028.2. First-order methods 281
2.0 1.5 1.0 0.5 0.0 0.5 1.0 1.5
2.0
1.5
1.0
0.5
0.0
0.5
1.0
1.5
condition number of A=30.234
(a)
2.0 1.5 1.0 0.5 0.0 0.5 1.0 1.5
2.0
1.5
1.0
0.5
0.0
0.5
1.0
1.5
condition number of A=1.854
(b)
Figure 8.12: Illustration of the effect of condition number κ on the convergence speed of steepest descent with
exact line searches. (a) Large κ. (b) Small κ. Generated by code at figures.probml.ai/book1/8.12.
8.2.4 Momentum methods
Gradient descent can move very slowly along flat regions of the loss landscape, as we illustrated in
Figure 8.11. We discuss some solutions to this below.
8.2.4.1 Momentum
One simple heuristic, known as the heavy ball or momentum method [Ber99], is to move faster
along directions that were previously good, and to slow down along directions where the gradient has
suddenly changed, just like a ball rolling downhill. This can be implemented as follows:
mt = βmt−1 + gt−1 (8.30)
θt = θt−1 − ηtmt (8.31)
where mt is the momentum (mass times velocity) and 0 < β < 1. A typical value of β is 0.9. For
β = 0, the method reduces to gradient descent.
We see that mt is like an exponentially weighted moving average of the past gradients (see
Section 4.4.2.2):
mt = βmt−1 + gt−1 = β
2mt−2 + βgt−2 + gt−1 = · · · =
Xt−1
τ=0
β
τ
gt−τ−1 (8.32)
If all the past gradients are a constant, say g, this simplifies to
mt = g
Xt−1
τ=0
β
τ
(8.33)
The scaling factor is a geometric series, whose infinite sum is given by
1 + β + β
2 + · · · =
X∞
i=0
β
i =
1
1 − β
(8.34)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license282 Chapter 8. Optimization
Cost 
Regular 
momentum 
Update
Nesterov 
Update
Starting 
Point
bm
h
q1
q2
h
1
2
h 1
Figure 8.13: Illustration of the Nesterov update. Adapted from Figure 11.6 of [Gér19].
Thus in the limit, we multiply the gradient by 1/(1 − β). For example, if β = 0.9, we scale the
gradient up by 10.
Since we update the parameters using the gradient average mt−1, rather than just the most recent
gradient, gt−1, we see that past gradients can exhibit some influence on the present. Furthermore,
when momentum is combined with SGD, discussed in Section 8.4, we will see that it can simulate
the effects of a larger minibatch, without the computational cost.
8.2.4.2 Nesterov momentum
One problem with the standard momentum method is that it may not slow down enough at the
bottom of a valley, causing oscillation. The Nesterov accelerated gradient method of [Nes04]
instead modifies the gradient descent to include an extrapolation step, as follows:
θ˜
t+1 = θt + βt(θt − θt−1) (8.35)
θt+1 = θ˜
t+1 − ηt∇L(θ˜
t+1) (8.36)
This is essentially a form of one-step “look ahead”, that can reduce the amount of oscillation, as
illustrated in Figure 8.13.
Nesterov accelerated gradient can also be rewritten in the same format as standard momentum. In
this case, the momentum term is updated using the gradient at the predicted new location,
mt+1 = βmt − ηt∇L(θt + βmt) (8.37)
θt+1 = θt + mt+1 (8.38)
This explains why the Nesterov accelerated gradient method is sometimes called Nesterov momentum.
It also shows how this method can be faster than standard momentum: the momentum vector
is already roughly pointing in the right direction, so measuring the gradient at the new location,
θt + βmt, rather than the current location, θt, can be more accurate.
The Nesterov accelerated gradient method is provably faster than steepest descent for convex
functions when β and ηt are chosen appropriately. It is called “accelerated” because of this improved
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.3. Second-order methods 283
convergence rate, which is optimal for gradient-based methods using only first-order information
when the objective function is convex and has Lipschitz-continuous gradients. In practice, however,
using Nesterov momentum can be slower than steepest descent, and can even unstable if β or ηt are
misspecified.
8.3 Second-order methods
Optimization algorithms that only use the gradient are called first-order methods. They have the
advantage that the gradient is cheap to compute and to store, but they do not model the curvature
of the space, and hence they can be slow to converge, as we have seen in Figure 8.12. Second-order
optimization methods incorporate curvature in various ways (e.g., via the Hessian), which may yield
faster convergence. We discuss some of these methods below.
8.3.1 Newton’s method
The classic second-order method is Newton’s method. This consists of updates of the form
θt+1 = θt − ηtH−1
t gt (8.39)
where
Ht , ∇2L(θ)|θt = ∇2L(θt) = H(θt) (8.40)
is assumed to be positive-definite to ensure the update is well-defined. The pseudo-code for Newton’s
method is given in Algorithm 1. The intuition for why this is faster than gradient descent is that the
matrix inverse H−1
“undoes” any skew in the local curvature, converting a topology like Figure 8.12a
to one like Figure 8.12b.
Algorithm 1: Newton’s method for minimizing a function
1 Initialize θ0;
2 for t = 1, 2, . . . until convergence do
3 Evaluate gt = ∇L(θt);
4 Evaluate Ht = ∇2L(θt);
5 Solve Htdt = −gt for dt;
6 Use line search to find stepsize ηt along dt;
7 θt+1 = θt + ηtdt;
This algorithm can be derived as follows. Consider making a second-order Taylor series approxi￾mation of L(θ) around θt:
Lquad(θ) = L(θt) + g
T
t
(θ − θt) + 1
2
(θ − θt)
THt(θ − θt) (8.41)
The minimum of Lquad is at
θ = θt − H−1
t gt (8.42)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license284 Chapter 8. Optimization
(a) (b)
Figure 8.14: Illustration of Newton’s method for minimizing a 1d function. (a) The solid curve is the function
L(x). The dotted line Lquad(θ) is its second order approximation at θt. The Newton step dt is what must
be added to θt to get to the minimum of Lquad(θ). Adapted from Figure 13.4 of [Van06]. Generated by
code at figures.probml.ai/book1/8.14. (b) Illustration of Newton’s method applied to a nonconvex function.
We fit a quadratic function around the current point θt and move to its stationary point, θt+1 = θt + dt.
Unfortunately, this takes us near a local maximum of f, not minimum. This means we need to be careful
about the extent of our quadratic approximation. Adapted from Figure 13.11 of [Van06]. Generated by code at
figures.probml.ai/book1/8.14.
So if the quadratic approximation is a good one, we should pick dt = −H−1
t gt as our descent direction.
See Figure 8.14(a) for an illustration. Note that, in a “pure” Newton method, we use ηt = 1 as our
stepsize. However, we can also use linesearch to find the best stepsize; this tends to be more robust
as using ηt = 1 may not always converge globally.
If we apply this method to linear regression, we get to the optimum in one step, since (as we shown
in Section 11.2.2.1) we have H = XTX and g = XTXw − XTy, so the Newton update becomes
w1 = w0 − H−1
g = w0 − (XTX)
−1
(XTXw0 − XTy) = w0 − w0 + (XTX)
−1XTy (8.43)
which is the OLS estimate. However, when we apply this method to logistic regression, it may take
multiple iterations to converge to the global optimum, as we discuss in Section 10.2.6.
8.3.2 BFGS and other quasi-Newton methods
Quasi-Newton methods, sometimes called variable metric methods, iteratively build up an
approximation to the Hessian using information gleaned from the gradient vector at each step. The
most common method is called BFGS (named after its simultaneous inventors, Broyden, Fletcher,
Goldfarb and Shanno), which updates the approximation to the Hessian Bt ≈ Ht as follows:
Bt+1 = Bt +
yty
T
t
y
T
t st
−
(Btst)(Btst)
T
s
T
t Btst
(8.44)
st = θt − θt−1 (8.45)
yt = gt − gt−1 (8.46)
This is a rank-two update to the matrix. If B0 is positive-definite, and the step size η is chosen
via line search satisfying both the Armijo condition in Equation (8.27) and the following curvature
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.3. Second-order methods 285
Figure 8.15: Illustration of the trust region approach. The dashed lines represents contours of the original
nonconvex objective. The circles represent successive quadratic approximations. From Figure 4.2 of [Pas14].
Used with kind permission of Razvan Pascanu.
condition
∇L(θt + ηdt) ≥ c2ηd
T
t ∇L(θt) (8.47)
then Bt+1 will remain positive definite. The constant c2 is chosen within (c, 1) where c is the
tunable parameter in Equation (8.27). The two step size conditions are together known as the Wolfe
conditions. We typically start with a diagonal approximation, B0 = I. Thus BFGS can be thought
of as a “diagonal plus low-rank” approximation to the Hessian.
Alternatively, BFGS can iteratively update an approximation to the inverse Hessian, Ct ≈ H−1
t
,
as follows:
Ct+1 =

I −
sty
T
t
y
T
t st

Ct

I −
yts
T
t
y
T
t st

+
sts
T
t
y
T
t st
(8.48)
Since storing the Hessian approximation still takes O(D2
) space, for very large problems, one
can use limited memory BFGS, or L-BFGS, where we control the rank of the approximation by
only using the M most recent (st, yt) pairs while ignoring older information. Rather than storing
Bt explicitly, we just store these vectors in memory, and then approximate H−1
t gt by performing a
sequence of inner products with the stored st and yt vectors. The storage requirements are therefore
O(MD). Typically choosing M to be between 5–20 suffices for good performance [NW06, p177].
Note that sklearn uses LBFGS as its default solver for logistic regression.1
8.3.3 Trust region methods
If the objective function is nonconvex, then the Hessian Ht may not be positive definite, so dt =
−H−1
t gt may not be a descent direction. This is illustrated in 1d in Figure 8.14(b), which shows
that Newton’s method can end up in a local maximum rather than a local minimum.
In general, any time the quadratic approximation made by Newton’s method becomes invalid, we
are in trouble. However, there is usually a local region around the current iterate where we can safely
1. See https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license286 Chapter 8. Optimization
approximate the objective by a quadratic. Let us call this region Rt, and let us call M(δ) the model
(or approximation) to the objective, where δ = θ − θt. Then at each step we can solve
δ
∗ = argmin
δ∈Rt
Mt(δ) (8.49)
This is called trust-region optimization. (This can be seen as the “opposite” of line search, in the
sense that we pick a distance we want to travel, determined by Rt, and then solve for the optimal
direction, rather than picking the direction and then solving for the optimal distance.)
We usually assume that Mt(δ) is a quadratic approximation:
Mt(δ) = L(θt) + g
T
t δ +
1
2
δ
THtδ (8.50)
where gt = ∇θL(θ)|θt
is the gradient, and Ht = ∇2
θL(θ)|θt
is the Hessian. Furthermore, it is common
to assume that Rt is a ball of radius r, i.e., Rt = {δ : ||δ||2 ≤ r}. Using this, we can convert the
constrained problem into an unconstrained one as follows:
δ
∗ = argmin
δ
M(δ) + λ||δ||2
2 = argmin
δ
g
T
δ +
1
2
δ
T
(H + λI)δ (8.51)
for some Lagrange multiplier λ > 0 which depends on the radius r (see Section 8.5.1 for a discussion
of Lagrange multipliers). We can solve this using
δ = −(H + λI)
−1
g (8.52)
This is called Tikhonov damping or Tikhonov regularization. See Figure 8.15 for an illustration.
Note that adding a sufficiently large λI to H ensures the resulting matrix is always positive definite.
As λ → 0, this trust method reduces to Newton’s method, but for λ large enough, it will make all
the negative eigenvalues positive (and all the 0 eigenvalues become equal to λ).
8.4 Stochastic gradient descent
In this section, we consider stochastic optimization, where the goal is to minimize the average
value of a function:
L(θ) = Eq(z)
[L(θ, z)] (8.53)
where z is a random input to the objective. This could be a “noise” term, coming from the environment,
or it could be a training example drawn randomly from the training set, as we explain below.
At each iteration, we assume we observe Lt(θ) = L(θ, zt), where zt ∼ q. We also assume a way to
compute an unbiased estimate of the gradient of L. If the distribution q(z) is independent of the
parameters we are optimizing, we can use gt = ∇θLt(θt). In this case, The resulting algorithm can
be written as follows:
θt+1 = θt − ηt∇L(θt, zt) = θt − ηtgt (8.54)
This method is known as stochastic gradient descent or SGD. As long as the gradient estimate
is unbiased, then this method will converge to a stationary point, providing we decay the step size ηt
at a certain rate, as we discuss in Section 8.4.3.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.4. Stochastic gradient descent 287
8.4.1 Application to finite sum problems
SGD is very widely used in machine learning. To see why, recall from Section 4.3 that many model
fitting procedures are based on empirical risk minimization, which involve minimizing the following
loss:
L(θt) = 1
N
X
N
n=1
`(yn, f(xn; θt)) = 1
N
X
N
n=1
Ln(θt) (8.55)
This is called a finite sum problem. The gradient of this objective has the form
gt =
1
N
X
N
n=1
∇θLn(θt) = 1
N
X
N
n=1
∇θ`(yn, f(xn; θt)) (8.56)
This requires summing over all N training examples, and thus can be slow if N is large. Fortunately
we can approximate this by sampling a minibatch of B  N samples to get
gt ≈
1
|Bt|
X
n∈Bt
∇θLn(θt) = 1
|Bt|
X
n∈Bt
∇θ`(yn, f(xn; θt)) (8.57)
where Bt is a set of randomly chosen examples to use at iteration t.
2 This is an unbiased approximation
to the empirical average in Equation (8.56). Hence we can safely use this with SGD.
Although the theoretical rate of convergence of SGD is slower than batch GD (in particular, SGD
has a sublinear convergence rate), in practice SGD is often faster, since the per-step time is much
lower [BB08; BB11]. To see why SGD can make faster progress than full batch GD, suppose we have
a dataset consisting of a single example duplicated K times. Batch training will be (at least) K times
slower than SGD, since it will waste time computing the gradient for the repeated examples. Even if
there are no duplicates, batch training can be wasteful, since early on in training the parameters are
not well estimated, so it is not worth carefully evaluating the gradient.
8.4.2 Example: SGD for fitting linear regression
In this section, we show how to use SGD to fit a linear regression model. Recall from Section 4.2.7
that the objective has the form
L(θ) = 1
2N
X
N
n=1
(x
T
nθ − yn)
2 =
1
2N
||Xθ − y||2
2
(8.58)
The gradient is
gt =
1
N
X
N
n=1
(θ
T
t xn − yn)xn (8.59)
2. In practice we usually sample Bt without replacement. However, once we reach the end of the dataset (i.e., after a
single training epoch), we can perform a random shuffling of the examples, to ensure that each minibatch on the next
epoch is different from the last. This version of SGD is analyzed in [HS19].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license288 Chapter 8. Optimization
−1 0 1 2
−1.0
−0.5
0.0
0.5
1.0
1.5
2.0
2.5
LMS trajectory
(a)
0 5 10 15 20 25 30
0.0
0.5
1.0
1.5
2.0
2.5
RSS vs iteration
(b)
Figure 8.16: Illustration of the LMS algorithm. Left: we start from θ = (−0.5, 2) and slowly converging to
the least squares solution of θˆ = (1.45, 0.93) (red cross). Right: plot of objective function over time. Note
that it does not decrease monotonically. Generated by code at figures.probml.ai/book1/8.16.
Now consider using SGD with a minibatch size of B = 1. The update becomes
θt+1 = θt − ηt(θ
T
t xn − yn)xn (8.60)
where n = n(t) is the index of the example chosen at iteration t. The overall algorithm is called the
least mean squares (LMS) algorithm, and is also known as the delta rule, or the Widrow-Hoff
rule.
Figure 8.16 shows the results of applying this algorithm to the data shown in Figure 11.2. We
start at θ = (−0.5, 2) and converge (in the sense that ||θt − θt−1||2
2 drops below a threshold of 10−2
)
in about 26 iterations. Note that SGD (and hence LMS) may require multiple passes through the
data to find the optimum.
8.4.3 Choosing the step size (learning rate)
When using SGD, we need to be careful in how we choose the learning rate in order to achieve
convergence. For example, in Figure 8.17 we plot the loss vs the learning rate when we apply SGD
to a deep neural network classifier (see Chapter 13 for details). We see a U-shaped curve, where an
overly small learning rate results in underfitting, and overly large learning rate results in instability
of the model (c.f., Figure 8.11(b)); in both cases, we fail to converge to a local optimum.
One heuristic for choosing a good learning rate, proposed in [Smi18], is to start with a small
learning rate and gradually increase it, evaluating performance using a small number of minibatches.
We then make a plot like the one in Figure 8.17, and pick the learning rate with the lowest loss. (In
practice, it is better to pick a rate that is slightly smaller than (i.e., to the left of) the one with the
lowest loss, to ensure stability.)
Rather than choosing a single constant learning rate, we can use a learning rate schedule, in
which we adjust the step size over time. Theoretically, a sufficient condition for SGD to achieve
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.4. Stochastic gradient descent 289
10
5 10
4 10
3 10
2 10
1 10
0 10
1
Learning rate
0
2
4
6
8
10
12
14
Loss
Figure 8.17: Loss vs learning rate (horizontal axis). Training loss vs learning rate for a small MLP fit to
FashionMNIST using vanilla SGD. (Raw loss in blue, EWMA smoothed version in orange). Generated by
code at figures.probml.ai/book1/8.17.
0 20 40 60 80 100
0.75
0.80
0.85
0.90
0.95
1.00
piecewise constant
(a)
0 20 40 60 80 100
0.0
0.2
0.4
0.6
0.8
1.0
exponential decay
(b)
0 20 40 60 80 100
0.2
0.4
0.6
0.8
1.0
polynomial decay
(c)
Figure 8.18: Illustration of some common learning rate schedules. (a) Piecewise constant. (b) Exponential
decay. (c) Polynomial decay. Generated by code at figures.probml.ai/book1/8.18.
convergence is if the learning rate schedule satisfies the Robbins-Monro conditions:
ηt → 0,
P∞
t=1 η
2
P t
∞
t=1 ηt
→ 0 (8.61)
Some common examples of learning rate schedules are listed below:
ηt = ηi
if ti ≤ t ≤ ti+1 piecewise constant (8.62)
ηt = η0e
−λt exponential decay (8.63)
ηt = η0(βt + 1)−α polynomial decay (8.64)
In the piecewise constant schedule, ti are a set of time points at which we adjust the learning rate
to a specified value. For example, we may set ηi = η0γ
i
, which reduces the initial learning rate by a
factor of γ for each threshold (or milestone) that we pass. Figure 8.18a illustrates this for η0 = 1
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license290 Chapter 8. Optimization
(a) (b)
Figure 8.19: (a) Linear warm-up followed by cosine cool-down. (b) Cyclical learning rate schedule.
and γ = 0.9. This is called step decay. Sometimes the thresholds times are computed adaptively,
by estimating when the train or validation loss has plateaued; this is called reduce-on-plateau.
Exponential decay is typically too fast, as illustrated in Figure 8.18b. A common choice is polynomial
decay, with α = 0.5 and β = 1, as illustrated in Figure 8.18c; this corresponds to a square-root
schedule, ηt = η0 √
1
t+1 .
In the deep learning community, another common schedule is to quickly increase the learning rate
and then gradually decrease it again, as shown in Figure 8.19a. This is called learning rate warmup,
or the one-cycle learning rate schedule [Smi18]. The motivation for this is the following: initially
the parameters may be in a part of the loss landscape that is poorly conditioned, so a large step size
will “bounce around” too much (c.f., Figure 8.11(b)) and fail to make progress downhill. However,
with a slow learning rate, the algorithm can discover flatter regions of space, where a larger step size
can be used. Once there, fast progress can be made. However, to ensure convergence to a point, we
must reduce the learning rate to 0. See [Got+19] for more details.
It is also possible to increase and decrease the learning rate multiple times, in a cyclical fashion.
This is called a cyclical learning rate [Smi18], and was popularized by the fast.ai course. See
Figure 8.19b for an illustration using triangular shapes. The motivation behind this approach is to
escape local minima. The minimum and maximum learning rates can be found based on the initial
“dry run” described above, and the half-cycle can be chosen based on how many restarts you want to
do with your training budget. A related approach, known as stochastic gradient descent with
warm restarts, was proposed in [LH17]; they proposed storing all the checkpoints visited after each
cool down, and using all of them as members of a model ensemble. (See Section 18.2 for a discussion
of ensemble learning.)
An alternative to using heuristics for estimating the learning rate is to use line search (Sec￾tion 8.2.2.2). This is tricky when using SGD, because the noisy gradients make the computation of
the Armijo condition difficult [CS20]. However, [Vas+19] show that it can be made to work if the
variance of the gradient noise goes to zero over time. This can happen if the model is sufficiently
flexible that it can perfectly interpolate the training set.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.4. Stochastic gradient descent 291
8.4.4 Iterate averaging
The parameter estimates produced by SGD can be very unstable over time. To reduce the variance
of the estimate, we can compute the average using
θt =
1
t
Xt
i=1
θi =
1
t
θt +
t − 1
t
θt−1 (8.65)
where θt are the usual SGD iterates. This is called iterate averaging or Polyak-Ruppert
averaging [Rup88].
In [PJ92], they prove that the estimate θt achieves the best possible asymptotic convergence rate
among SGD algorithms, matching that of variants using second-order information, such as Hessians.
This averaging can also have statistical benefits. For example, in [NR18], they prove that, in the
case of linear regression, this method is equivalent to `2 regularization (i.e., ridge regression).
Rather than an exponential moving average of SGD iterates, Stochastic Weight Averaging
(SWA) [Izm+18] uses an equal average in conjunction with a modified learning rate schedule. In
contrast to standard Polyak-Ruppert averaging, which was motivated for faster convergence rates,
SWA exploits the flatness in objectives used to train deep neural networks, to find solutions which
provide better generalization.
8.4.5 Variance reduction *
In this section, we discuss various ways to reduce the variance in SGD. In some cases, this can
improve the theoretical convergence rate from sublinear to linear (i.e., the same as full-batch gradient
descent) [SLRB17; JZ13; DBLJ14]. These methods reduce the variance of the gradients, rather than
the parameters themselves and are designed to work for finite sum problems.
8.4.5.1 SVRG
The basic idea of stochastic variance reduced gradient (SVRG) [JZ13] is to use a control
variate, in which we estimate a baseline value of the gradient based on the full batch, which we then
use to compare the stochastic gradients to.
More precisely, ever so often (e.g., once per epoch), we compute the full gradient at a “snapshot”
of the model parameters θ˜; the corresponding “exact” gradient is therefore ∇L(θ˜). At step t, we
compute the usual stochastic gradient at the current parameters, ∇Lt(θt), but also at the snapshot
parameters, ∇Lt(θ˜), which we use as a baseline. We can then use the following improved gradient
estimate
gt = ∇Lt(θt) − ∇Lt(θ˜) + ∇L(θ˜) (8.66)
to compute θt+1. This is unbiased because E
h
∇Lt(θ˜)
i
= ∇L(θ˜). Furthermore, the update only
involves two gradient computations, since we can compute ∇L(θ˜) once per epoch. At the end of the
epoch, we update the snapshot parameters, θ˜, based on the most recent value of θt, or a running
average of the iterates, and update the expected baseline. (We can compute snapshots less often, but
then the baseline will not be correlated with the objective and can hurt performance, as shown in
[DB18].)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license292 Chapter 8. Optimization
Iterations of SVRG are computationally faster than those of full-batch GD, but SVRG can still
match the theoretical convergence rate of GD.
8.4.5.2 SAGA
In this section, we describe the stochastic averaged gradient accelerated (SAGA) algorithm
of [DBLJ14]. Unlike SVRG, it only requires one full batch gradient computation, at the start of
the algorithm. However, it “pays” for this saving in time by using more memory. In particular, it
must store N gradient vectors. This enables the method to maintain an approximation of the global
gradient by removing the old local gradient from the overall sum and replacing it with the new local
gradient. This is called an aggregated gradient method.
More precisely, we first initialize by computing g
local
n = ∇Ln(θ0) for all n, and the average,
g
avg =
1
N
PN
n=1 g
local
n
. Then, at iteration t, we use the gradient estimate
gt = ∇Ln(θt) − g
local
n + g
avg (8.67)
where n ∼ Unif{1, . . . , N} is the example index sampled at iteration t. We then update g
local
n =
∇Ln(θt) and g
avg by replacing the old g
local
n by its new value.
This has an advantage over SVRG since it only has to do one full batch sweep at the start. (In
fact, the initial sweep is not necessary, since we can compute g
avg “lazily”, by only incorporating
gradients we have seen so far.) The downside is the large extra memory cost. However, if the features
(and hence gradients) are sparse, the memory cost can be reasonable. Indeed, the SAGA algorithm is
recommended for use in the sklearn logistic regression code when N is large and x is sparse.3
8.4.5.3 Application to deep learning
Variance reduction methods are widely used for fitting ML models with convex objectives, such as
linear models. However, there are various difficulties associated with using SVRG with conventional
deep learning training practices. For example, the use of batch normalization (Section 14.2.4.1), data
augmentation (Section 19.1) and dropout (Section 13.5.4) all break the assumptions of the method,
since the loss will differ randomly in ways that depend not just on the parameters and the data index
n. For more details, see e.g., [DB18; Arn+19].
8.4.6 Preconditioned SGD
In this section, we consider preconditioned SGD, which involves the following update:
θt+1 = θt − ηtM−1
t gt, (8.68)
where Mt is a preconditioning matrix, or simply the preconditioner, typically chosen to be
positive-definite. Unfortunately the noise in the gradient estimates make it difficult to reliably
estimate the Hessian, which makes it difficult to use the methods from Section 8.3. In addition,
it is expensive to solve for the update direction with a full preconditioning matrix. Therefore
most practitioners use a diagonal preconditioner Mt. Such preconditioners do not necessarily use
second-order information, but often result in speedups compared to vanilla SGD. (See also [Roo+21]
for a probabilitic interpretation of these heuristics.)
3. See https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.4. Stochastic gradient descent 293
8.4.6.1 AdaGrad
The AdaGrad (short for “adaptive gradient”) method of [DHS11] was originally designed for
optimizing convex objectives where many elements of the gradient vector are zero; these might
correspond to features that are rarely present in the input, such as rare words. The update has the
following form
θt+1,d = θt,d − ηt
1
√
st,d + 
gt,d (8.69)
where
st,d =
Xt
t=1
g
2
t,d (8.70)
is the sum of the squared gradients and  > 0 is a small term to avoid dividing by zero. Equivalently
we can write the update in vector form as follows:
∆θt = −ηt
1
√
st + 
gt (8.71)
where the square root and division is performed elementwise. Viewed as preconditioned SGD, this is
equivalent to taking Mt = diag(st + )
1/2
. This is an example of an adaptive learning rate; the
overall stepsize ηt still needs to be chosen, but the results are less sensitive to it compared to vanilla
GD. In particular, we usually fix ηt = η0.
8.4.6.2 RMSProp and AdaDelta
A defining feature of AdaGrad is that the term in the denominator gets larger over time, so the
effective learning rate drops. While it is necessary to ensure convergence, it might hurt performance
as the denominator gets large too fast.
An alternative is to use an exponentially weighted moving average (EWMA, Section 4.4.2.2) of the
past squared gradients, rather than their sum:
st+1,d = βst,d + (1 − β)g
2
t,d (8.72)
In practice we usually use β ∼ 0.9, which puts more weight on recent examples. In this case,
√
st,d ≈ RMS(g1:t,d) =
vuut
1
t
Xt
τ=1
g
2
τ,d (8.73)
where RMS stands for “root mean squared”. Hence this method, (which is based on the earlier
RPROP method of [RB93]) is known as RMSProp [Hin14]. The overall update of RMSProp
is
∆θt = −ηt
1
√
st + 
gt. (8.74)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license294 Chapter 8. Optimization
The AdaDelta method was independently introduced in [Zei12], and is similar to RMSprop.
However, in addition to accumulating an EWMA of the gradients in sˆ, it also keeps an EWMA of
the updates δt to obtain an update of the form
∆θt = −ηt
p
δt−1 + 
√
st + 
gt (8.75)
where
δt = βδt−1 + (1 − β)(∆θt)
2
(8.76)
and st is the same as in RMSProp. This has the advantage that the “units” of the numerator and
denominator cancel, so we are just elementwise-multiplying the gradient by a scalar. This eliminates
the need to tune the learning rate ηt, which means one can simply set ηt = 1, although popular
implementations of AdaDelta still keep ηt as a tunable hyperparameter. However, since these
adaptive learning rates need not decrease with time (unless we choose ηt to explicitly do so), these
methods are not guaranteed to converge to a solution.
8.4.6.3 Adam
It is possible to combine RMSProp with momentum. In particular, let us compute an EWMA of
the gradients (as in momentum) and squared gradients (as in RMSProp)
mt = β1mt−1 + (1 − β1)gt (8.77)
st = β2st−1 + (1 − β2)g
2
t
(8.78)
We then perform the following update:
∆θt = −ηt
1
√
st + 
mt (8.79)
The resulting method is known as Adam, which stands for “adaptive moment estimation” [KB15].
The standard values for the various constants are β1 = 0.9, β2 = 0.999 and  = 10−6
. (If we set
β1 = 0 and no bias-correction, we recover RMSProp, which does not use momentum.) For the
overall learning rate, it is common to use a fixed value such as ηt = 0.001. Again, as the adaptive
learning rate may not decrease over time, convergence is not guaranteed (see Section 8.4.6.4).
If we initialize with m0 = s0 = 0, then initial estimates will be biased towards small values. The
authors therefore recommend using the bias-corrected moments, which increase the values early in
the optimization process. These estimates are given by
mˆ t = mt/(1 − β
t
1
) (8.80)
sˆt = st/(1 − β
t
2
) (8.81)
The advantage of bias-correction is shown in Figure 4.3.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.5. Constrained optimization 295
8.4.6.4 Issues with adaptive learning rates
When using diagonal scaling methods, the overall learning rate is determined by η0M−1
t
, which
changes with time. Hence these methods are often called adaptive learning rate methods. However,
they still require setting the base learning rate η0.
Since the EWMA methods are typically used in the stochastic setting where the gradient estimates
are noisy, their learning rate adaptation can result in non-convergence even on convex problems
[RKK18]. Various solutions to this problem have been proposed, including AMSGrad [RKK18],
Padam [CG18; Zho+18], and Yogi [Zah+18]. For example, the Yogi update modifies Adam by
replacing
st = β2st−1 + (1 − β2)g
2
t = st−1 + (1 − β2)(g
2
t − st−1) (8.82)
with
st = st−1 + (1 − β2)g
2
t  sgn(g
2
t − st−1) (8.83)
8.4.6.5 Non-diagonal preconditioning matrices
Although the methods we have discussed above can adapt the learning rate of each parameter, they
do not solve the more fundamental problem of ill-conditioning due to correlation of the parameters,
and hence do not always provide as much of a speed boost over vanilla SGD as one may hope.
One way to get faster convergence is to use the following preconditioning matrix, known as
full-matrix Adagrad [DHS11]:
Mt = [(GtGT
t
)
1
2 + ID]
−1
(8.84)
where
Gt = [gt, . . . , g1] (8.85)
Here gi = ∇ψc(ψi
) is the D-dimensional gradient vector computed at step i. Unfortunately, Mt is a
D × D matrix, which is expensive to store and invert.
The Shampoo algorithm [GKS18] makes a block diagonal approximation to M, one per layer
of the model, and then exploits kronecker product structure to efficiently invert it. (It is called
“shampoo” because it uses a conditioner.) Recently, [Ani+20] scaled this method up to fit very large
deep models in record time.
8.5 Constrained optimization
In this section, we consider the following constrained optimization problem:
θ
∗ = arg min
θ∈C
L(θ) (8.86)
where the feasible set, or constraint set, is
C = {θ ∈ R
D : hi(θ) = 0, i ∈ E, gj (θ) ≤ 0, j ∈ I} (8.87)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license296 Chapter 8. Optimization
� * = (1/2 , 1/2)
�₁ + �₂ = 1
�₂
�₁
f(�) = �₁
² + �₂
²
0
�₂ − �₁ ≤ 1
−�₂ − �₁ ≤ 1 �₁ − �₂ ≤ 1
�₁ + �₂ ≤ 1
�₂
�₁
(3/2 , 1/8)
Figure 8.20: Illustration of some constrained optimization problems. Red contours are the level sets of the
objective function L(θ). Optimal constrained solution is the black dot, (a) Blue line is the equality constraint
h(θ) = 0. (b) Blue lines denote the inequality constraints |θ1| + |θ2| ≤ 1. (Compare to Figure 11.8 (left).)
where E is the set of equality constraints, and I is the set of inequality constraints.
For example, suppose we have a quadratic objective, L(θ) = θ
2
1 + θ
2
2
, subject to a linear equality
constraint, h(θ) = 1 − θ1 − θ2 = 0. Figure 8.20(a) plots the level sets of L, as well as the constraint
surface. What we are trying to do is find the point θ
∗
that lives on the line, but which is closest to
the origin. It is clear from the geometry that the optimal solution is θ = (0.5, 0.5), indicated by the
solid black dot.
In the following sections, we briefly describe some of the theory and algorithms underlying
constrained optimization. More details can be found in other books, such as [BV04; NW06; Ber15;
Ber16].
8.5.1 Lagrange multipliers
In this section, we discuss how to solve equality contrained optimization problems. We initially
assume that we have just one equality constraint, h(θ) = 0.
First note that for any point on the constraint surface, ∇h(θ) will be orthogonal to the constraint
surface. To see why, consider another point nearby, θ + , that also lies on the surface. If we make a
first-order Taylor expansion around θ we have
h(θ + ) ≈ h(θ) + 
T∇h(θ) (8.88)
Since both θ and θ +  are on the constraint surface, we must have h(θ) = h(θ + ) and hence

T∇h(θ) ≈ 0. Since  is parallel to the constraint surface, ∇h(θ) must be perpendicular to it.
We seek a point θ
∗ on the constraint surface such that L(θ) is minimized. We just showed that it
must satisfy the condition that ∇h(θ
∗
) is orthogonal to the constraint surface. In addition, such a
point must have the property that ∇L(θ) is also orthogonal to the constraint surface, as otherwise
we could decrease L(θ) by moving a short distance along the constraint surface. Since both ∇h(θ)
and ∇L(θ) are orthogonal to the constraint surface at θ
∗
, they must be parallel (or anti-parallel) to
each other. Hence there must exist a constant λ
∗ ∈ R such that
∇L(θ
∗
) = λ
∗∇h(θ
∗
) (8.89)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.5. Constrained optimization 297
(We cannot just equate the gradient vectors, since they may have different magnitudes.) The constant
λ
∗
is called a Lagrange multiplier, and can be positive, negative, or zero. This latter case occurs
when ∇L(θ
∗
) = 0.
We can convert Equation (8.89) into an objective, known as the Lagrangian, that we should find
a stationary point of the following:
L(θ, λ) , L(θ) + λh(θ) (8.90)
At a stationary point of the Lagrangian, we have
∇θ,λL(θ, λ) = 0 ⇐⇒ λ∇θh(θ) = ∇L(θ), h(θ) = 0 (8.91)
This is called a critical point, and satisfies the original constraint h(θ) = 0 and Equation (8.89).
If we have m > 1 constraints, we can form a new constraint function by addition, as follows:
L(θ,λ) = L(θ) +Xm
j=1
λjhj (θ) (8.92)
We now have D+m equations in D+m unknowns and we can use standard unconstrained optimization
methods to find a stationary point. We give some examples below.
8.5.1.1 Example: 2d Quadratic objective with one linear equality constraint
Consider minimizing L(θ) = θ
2
1 + θ
2
2
subject to the constraint that θ1 + θ2 = 1.
(This is the problem illustrated in Figure 8.20(a).) The Lagrangian is
L(θ1, θ2, λ) = θ
2
1 + θ
2
2 + λ(θ1 + θ2 − 1) (8.93)
We have the following conditions for a stationary point:
∂
∂θ1
L(θ1, θ2, λ) = 2θ1 + λ = 0 (8.94)
∂
∂θ2
L(θ1, θ2, λ) = 2θ2 + λ = 0 (8.95)
∂
∂λL(θ1, θ2, λ) = θ1 + θ2 − 1 = 0 (8.96)
From Equations 8.94 and 8.95 we find 2θ1 = −λ = 2θ2, so θ1 = θ2. Also, from Equation (8.96), we
find 2θ1 = 1. So θ
∗ = (0.5, 0.5), as we claimed earlier. Furthermore, this is the global minimum since
the objective is convex and the constraint is affine.
8.5.2 The KKT conditions
In this section, we generalize the concept of Lagrange multipliers to additionally handle inequality
constraints.
First consider the case where we have a single inequality constraint g(θ) ≤ 0. To find the optimum,
one approach would be to consider an unconstrained problem where we add the penalty as an infinite
step function:
Lˆ(θ) = L(θ) + ∞I(g(θ) > 0) (8.97)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license298 Chapter 8. Optimization
However, this is a discontinuous function that is hard to optimize.
Instead, we create a lower bound of the form µg(θ), where µ ≥ 0. This gives us the following
Lagrangian:
L(θ, µ) = L(θ) + µg(θ) (8.98)
Note that the step function can be recovered using
Lˆ(θ) = max
µ≥0
L(θ, µ) = (
∞ if g(θ) > 0,
L(θ) otherwise
(8.99)
Thus our optimization problem becomes
min
θ
max
µ≥0
L(θ, µ) (8.100)
Now consider the general case where we have multiple inequality constraints, g(θ) ≤ 0, and
multiple equality constraints, h(θ) = 0. The generalized Lagrangian becomes
L(θ, µ,λ) = L(θ) +X
i
µigi(θ) +X
j
λjhj (θ) (8.101)
(We are free to change −λjhj to +λjhj since the sign is arbitrary.) Our optimization problem
becomes
min
θ
max
µ≥0,λ
L(θ, µ,λ) (8.102)
When L and g are convex, then all critical points of this problem must satisfy the following criteria
(under some conditions [BV04, Sec.5.2.3]):
• All constraints are satisfied (this is called feasibility):
g(θ) ≤ 0, h(θ) = 0 (8.103)
• The solution is a stationary point:
∇L(θ
∗
) +X
i
µi∇gi(θ
∗
) +X
j
λj∇hj (θ
∗
) = 0 (8.104)
• The penalty for the inequality constraint points in the right direction (this is called dual feasi￾bility):
µ ≥ 0 (8.105)
• The Lagrange multipliers pick up any slack in the inactive constraints, i.e., either µi = 0 or
gi(θ
∗
) = 0, so
µ  g = 0 (8.106)
This is called complementary slackness.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.5. Constrained optimization 299
x
x
(a) (b)
Figure 8.21: (a) A convex polytope in 2d defined by the intersection of linear constraints. (b) Depiction of
the feasible set as well as the linear objective function. The red line is a level set of the objective, and the
arrow indicates the direction in which it is improving. We see that the optimal solution lies at a vertex of the
polytope.
To see why the last condition holds, consider (for simplicity) the case of a single inequality
constraint, g(θ) ≤ 0. Either it is active, meaning g(θ) = 0, or it is inactive, meaning g(θ) < 0.
In the active case, the solution lies on the constraint boundary, and g(θ) = 0 becomes an equality
constraint; then we have ∇L = µ∇g for some constant µ 6= 0, because of Equation (8.89). In the
inactive case, the solution is not on the constraint boundary; we still have ∇L = µ∇g, but now
µ = 0.
These are called called the Karush-Kuhn-Tucker (KKT) conditions. If L is a convex function,
and the constraints define a convex set, the KKT conditions are sufficient for (global) optimality, as
well as necessary.
8.5.3 Linear programming
Consider optimizing a linear function subject to linear constraints. When written in standard form,
this can be represented as
min
θ
c
Tθ s.t. Aθ ≤ b, θ ≥ 0 (8.107)
The feasible set defines a convex polytope, which is a convex set defined as the intersection of
half spaces. See Figure 8.21(a) for a 2d example. Figure 8.21(b) shows a linear cost function that
decreases as we move to the bottom right. We see that the lowest point that is in the feasible set is a
vertex. In fact, it can be proved that the optimum point always occurs at a vertex of the polytope,
assuming the solution is unique. If there are multiple solutions, the line will be parallel to a face.
There may also be no optima inside the feasible set; in this case, the problem is said to be infeasible.
8.5.3.1 The simplex algorithm
It can be shown that the optima of an LP occur at vertices of the polytope defining the feasible set
(see Figure 8.21(b) for an example). The simplex algorithm solves LPs by moving from vertex to
vertex, each time seeking the edge which most improves the objective.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license300 Chapter 8. Optimization
In the worst-case scenario, the simplex algorithm can take time exponential in D, although in
practice it is usually very efficient. There are also various polynomial-time algorithms, such as the
interior point method, although these are often slower in practice.
8.5.3.2 Applications
There are many applications of linear programming in science, engineering and business. It is also
useful in some machine learning problems. For example, Section 11.6.1.1 shows how to use it to solve
robust linear regression. It is also useful for state estimation in graphical models (see e.g., [SGJ11]).
8.5.4 Quadratic programming
Consider minimizing a quadratic objective subject to linear equality and inequality constraints. This
kind of problem is known as a quadratic program or QP, and can be written as follows:
min
θ
1
2
θ
THθ + c
Tθ s.t. Aθ ≤ b, Aeqθ = beq (8.108)
If H is positive semidefinite, then this is a convex optimization problem.
8.5.4.1 Example: 2d quadratic objective with linear inequality constraints
As a concrete example, suppose we want to minimize
L(θ) = (θ1 −
3
2
)
2 + (θ2 −
1
8
)
2 =
1
2
θ
THθ + c
Tθ + const (8.109)
where H = 2I and c = −(3, 1/4), subject to
|θ1| + |θ2| ≤ 1 (8.110)
See Figure 8.20(b) for an illustration.
We can rewrite the constraints as
θ1 + θ2 ≤ 1, θ1 − θ2 ≤ 1, −θ1 + θ2 ≤ 1, −θ1 − θ2 ≤ 1 (8.111)
which we can write more compactly as
Aθ − b ≤ 0 (8.112)
where b = 1 and
A =


1 1
1 −1
−1 1
−1 −1


(8.113)
This is now in the standard QP form.
From the geometry of the problem, shown in Figure 8.20(b), we see that the constraints corre￾sponding to the two left faces of the diamond) are inactive (since we are trying to get as close to the
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.6. Proximal gradient method * 301
center of the circle as possible, which is outside of, and to the right of, the constrained feasible region).
Denoting gi(θ) as the inequality constraint corresponding to row i of A, this means g3(θ
∗
) > 0 and
g4(θ
∗
) > 0, and hence, by complementarity, µ
∗
3 = µ
∗
4 = 0. We can therefore remove these inactive
constraints.
From the KKT conditions we know that
Hθ + c + ATµ = 0 (8.114)
Using these for the actively constrained subproblem, we get


2 0 1 1
0 2 1 −1
1 1 0 0
1 −1 0 0




θ1
θ2
µ1
µ2

 =


3
1/4
1
1


(8.115)
Hence the solution is
θ∗ = (1, 0)T
, µ∗ = (0.625, 0.375, 0, 0)T
(8.116)
Notice that the optimal value of θ occurs at one of the vertices of the `1 “ball” (the diamond shape).
8.5.4.2 Applications
There are several applications of quadratic programming in ML. For example, in Section 11.4,
we discuss the lasso method for sparse linear regression, which amounts to optimizing L(w) =
||Xw − y||2
2 + λ||w||1, which can be reformulated into a QP as shown in ??. And in Section 17.3, we
show how to use QP for SVMs (support vector machines).
8.5.5 Mixed integer linear programming *
Integer linear programming or ILP corresponds to minimizing a linear objective, subject to
linear constraints, where the optimization variables are discrete integers instead of reals. In standard
form, the problem is as follows:
min
θ
c
Tθ s.t. Aθ ≤ b, θ ≥ 0, θ ∈ Z
D (8.117)
where Z is the set of integers. If some of the optimization variables are real-valued, it is called a
mixed ILP, often called a MIP for short. (If all of the variables are real-valued, it becomes a
standard LP.)
MIPs have a large number of applications, such as in vehicle routing, scheduling and packing.
They are also useful for some ML applications, such as formally verifying the behavior of certain
kinds of deep neural networks [And+18], and proving robustness properties of DNNs to adversarial
(worst-case) perturbations [TXT19].
8.6 Proximal gradient method *
We are often interested in optimizing an objective of the form
L(θ) = Ls(θ) + Lr(θ) (8.118)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license302 Chapter 8. Optimization
where Ls is differentiable (smooth), and Lr is convex but not necessarily differentiable (i.e., it may be
non-smooth or “rough”). For example, Ls might be the negative log likelihood (NLL), and Lr might
be an indicator function that is infinite if a constraint is violated (see Section 8.6.1), or Lr might be
the `1 norm of some parameters (see Section 8.6.2), or Lr might measure how far the parameters are
from a set of allowed quantized values (see Section 8.6.3).
One way to tackle such problems is to use the proximal gradient method (see e.g., [PB+14;
PSW15]). Roughly speaking, this takes a step of size η in the direction of the gradient, and then
projects the resulting parameter update into a space that respects Lr. More precisely, the update is
as follows
θt+1 = proxηtLr
(θt − ηt∇Ls(θt)) (8.119)
where proxηf (θ) is the proximal operator of Lr (scaled by η) evaluated at θ:
proxηLr
(θ) , argmin
z

Lr(z) + 1
2η
||z − θ||2
2

(8.120)
(The factor of 1
2
is an arbitrary convention.) We can rewrite the proximal operator as solving a
constrained opimtization problem, as follows:
proxηLr
(θ) = argmin
z
Lr(z) s.t. ||z − θ||2 ≤ ρ (8.121)
where the bound ρ depends on the scaling factor η. Thus we see that the proximal projection
minimizes the function while staying close to (i.e., proximal to) the current iterate. We give some
examples below.
8.6.1 Projected gradient descent
Suppose we want to solve the problem
argmin
θ
Ls(θ) s.t. θ ∈ C (8.122)
where C is a convex set. For example, we may have the box constraints C = {θ : l ≤ θ ≤ u},
where we specify lower and upper bounds on each element. These bounds can be infinite for certain
elements if we don’t want to constrain values along that dimension. For example, if we just want to
ensure the parameters are non-negative, we set ld = 0 and ud = ∞ for each dimension d.
We can convert the constrained optimization problem into an unconstrained one by adding a
penalty term to the original objective:
L(θ) = Ls(θ) + Lr(θ) (8.123)
where Lr(θ) is the indicator function for the convex set C, i.e.,
Lr(θ) = IC(θ) = (
0 if θ ∈ C
∞ if θ 6∈ C
(8.124)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.6. Proximal gradient method * 303
C ⇢ RD
w
w0
PC(w0
)
￾rL(w)
Figure 8.22: Illustration of projected gradient descent. w is the current parameter estimate, w0
is the update
after a gradient step, and PC(w0
) projects this onto the constraint set C. From https: // bit. ly/ 3eJ3BhZ
Used with kind permission of Martin Jaggi.
We can use proximal gradient descent to solve Equation (8.123). The proximal operator for the
indicator function is equivalent to projection onto the set C:
projC
(θ) = argmin
θ0∈C
||θ
0 − θ||2 (8.125)
This method is known as projected gradient descent. See Figure 8.22 for an illustration.
For example, consider the box constraints C = {θ : l ≤ θ ≤ u}. The projection operator in this
case can be computed elementwise by simply thresholding at the boundaries:
projC
(θ)d =



ld if θd ≤ ld
θd if ld ≤ θd ≤ ud
ud if θd ≥ ud
(8.126)
For example, if we want to ensure all elements are non-negative, we can use
projC
(θ) = θ+ = [max(θ1, 0), . . . , max(θD, 0)] (8.127)
See Section 11.4.9.2 for an application of this method to sparse linear regression.
8.6.2 Proximal operator for `1-norm regularizer
Consider a linear predictor of the form f(x; θ) = PD
d=1 θdxd. If we have θd = 0 for any dimension
d, we ignore the corresponding feature xd. This is a form of feature selection, which can be
useful both as a way to reduce overfitting as well as way to improve model interpretability. We can
encourage weights to be zero (and not just small) by penalizing the `1 norm,
||θ||1 =
X
D
d=1
|θd| (8.128)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license304 Chapter 8. Optimization
This is called a sparsity inducing regularizer.
To see why this induces sparsity, consider two possible parameter vectors, one which is sparse,
θ = (1, 0), and one which is non-sparse, θ
0 = (1/
√
2, 1/
√
2). Both have the same `2 norm
||(1, 0)||2
2 = ||(1/
√
2, 1/
√
2)||2
2 = 1 (8.129)
Hence `2 regularization (Section 4.5.3) will not favor the sparse solution over the dense solution.
However, when using `1 regularization, the sparse solution is cheaper, since
||(1, 0)||1 = 1 < ||(1/
√
2, 1/
√
2)||1 =
√
2 (8.130)
See Section 11.4 for more details on sparse regression.
If we combine this regularizer with our smooth loss, we get
L(θ) = NLL(θ) + λ||θ||1 (8.131)
We can optimize this objective using proximal gradient descent. The key question is how to compute
the prox operator for the function f(θ) = ||θ||1. Since this function decomposes over dimensions d,
the proximal projection can be computed componentwise. From Equation (8.120), with η = 1, we
have
proxλf (θ) = argmin
z
|z| +
1
2λ
(z − θ)
2 = argmin
z
λ|z| +
1
2
(z − θ)
2
(8.132)
In Section 11.4.3, we show that the solution to this is given by
proxλf (θ) =



θ − λ if θ ≥ λ
0 if |θ| ≤ λ
θ + λ if θ ≤ −λ
(8.133)
This is known as the soft thresholding operator, since values less than λ in absolute value are
set to 0 (thresholded), but in a continuous way. Note that soft thresholding can be written more
compactly as
SoftThreshold(θ, λ) = sign(θ) (|θ| − λ)+ (8.134)
where θ+ = max(θ, 0) is the positive part of θ. In the vector case, we perform this elementwise:
SoftThreshold(θ, λ) = sign(θ)  (|θ| − λ)+ (8.135)
See Section 11.4.9.3 for an application of this method to sparse linear regression.
8.6.3 Proximal operator for quantization
In some applications (e.g., when training deep neural networks to run on memory-limited edge
devices, such as mobile phones) we want to ensure that the parameters are quantized. For
example, in the extreme case where each parameter can only be -1 or +1, the state space becomes
C = {−1, +1}
D.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.6. Proximal gradient method * 305
Let us define a regularizer that measures distance to the nearest quantized version of the parameter
vector:
Lr(θ) = inf
θ0∈C
||θ − θ0||1 (8.136)
(We could also use the `2 norm.) In the case of C = {−1, +1}
D, this becomes
Lr(θ) = X
D
d=1
inf
[θ0]d∈{±1}
|θd − [θ0]d| =
X
D
d=1
min{|θd − 1|, |θd + 1|} = ||θ − sign(θ)||1 (8.137)
Let us define the corresponding quantization operator to be
q(θ) = projC
(θ) = argminLr(θ) = sign(θ) (8.138)
The core difficulty with quantized learning is that quantization is not a differentiable operation. A
popular solution to this is to use the straight-through estimator, which uses the approximation
∂L
∂q(θ) ≈
∂L
∂θ
(see e.g., [Yin+19]). The corresponding update can be done in two steps: first compute the
gradient vector at the quantized version of the current parameters, and then update the unconstrained
parameters using this approximate gradient:
θ˜
t = projC
(θt) = q(θt) (8.139)
θt+1 = θt − ηt∇Ls(θ˜
t) (8.140)
When applied to C = {−1, +1}
D, this is known as the binary connect method [CBD15].
We can get better results using proximal gradient descent, in which we treat quantization as a
regularizer, rather than a hard constraint; this is known as ProxQuant [BWL19]. The update
becomes
θ˜
t = proxλLr
(θt − ηt∇Ls(θt)) (8.141)
In the case that C = {−1, +1}
D, one can show that the proximal operator is a generalization of the
soft thresholding operator in Equation (8.135):
proxλLr
(θ) = SoftThreshold(θ, λ,sign(θ)) (8.142)
= sign(θ) + sign(θ − sign(θ))  (|θ − sign(θ)| − λ)+ (8.143)
This can be generalized to other forms of quantization; see [Yin+19] for details.
8.6.4 Incremental (online) proximal methods
Many ML problems have an objective function which is a sum of losses, one per example. Such
problems can be solved incrementally; this is a special case of online learning. It is possible to
extend proximal methods to this setting. For a probabilistic perspective on such methods (in terms
of Kalman filtering), see [AEM18; Aky+19].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license306 Chapter 8. Optimization
8.7 Bound optimization *
In this section, we consider a class of algorithms known as bound optimization or MM algorithms.
In the context of minimization, MM stands for majorize-minimize. In the context of maximization,
MM stands for minorize-maximize. We will discuss a special case of MM, known as expectation
maximization or EM, in Section 8.7.2.
8.7.1 The general algorithm
In this section, we give a brief outline of MM methods. (More details can be found in e.g., [HL04;
Mai15; SBP17; Nad+19].) To be consistent with the literature, we assume our goal is to maximize
some function LL(θ), such as the log likelihood, wrt its parameters θ. The basic approach in MM
algorithms is to construct a surrogate function Q(θ, θ
t
) which is a tight lowerbound to LL(θ)
such that Q(θ, θ
t
) ≤ LL(θ) and Q(θ
t
, θ
t
) = LL(θ
t
). If these conditions are met, we say that Q
minorizes LL. We then perform the following update at each step:
θ
t+1 = argmax
θ
Q(θ, θ
t
) (8.144)
This guarantees us monotonic increases in the original objective:
LL(θ
t+1) ≥ Q(θ
t+1
, θ
t
) ≥ Q(θ
t
, θ
t
) = LL(θ
t
) (8.145)
where the first inequality follows since Q(θ
t+1
, θ
0
) is a lower bound on LL(θ
t+1) for any θ
0
; the
second inequality follows from Equation (8.144); and the final equality follows the tightness property.
As a consequence of this result, if you do not observe monotonic increase of the objective, you must
have an error in your math and/or code. This is a surprisingly powerful debugging tool.
This process is sketched in Figure 8.23. The dashed red curve is the original function (e.g., the
log-likelihood of the observed data). The solid blue curve is the lower bound, evaluated at θ
t
; this
touches the objective function at θ
t
. We then set θ
t+1 to the maximum of the lower bound (blue
curve), and fit a new bound at that point (dotted green curve). The maximum of this new bound
becomes θ
t+2, etc.
If Q is a quadratic lower bound, the overall method is similar to Newton’s method, which repeatedly
fits and then optimizes a quadratic approximation, as shown in Figure 8.14(a). The difference is that
optimizing Q is guaranteed to lead to an improvement in the objective, even if it is not convex, whereas
Newton’s method may overshoot or lead to a decrease in the objective, as shown in Figure 8.24, since
it is a quadratic approximation and not a bound.
8.7.2 The EM algorithm
In this section, we discuss the expectation maximization (EM) algorithm [DLR77; MK97], which
is a bound optimization algorithm designed to compute the MLE or MAP parameter estimate for
probability models that have missing data and/or hidden variables. We let yn be the visible
data for example n, and zn be the hidden data.
The basic idea behind EM is to alternate between estimating the hidden variables (or missing
values) during the E step (expectation step), and then using the fully observed data to compute the
MLE during the M step (maximization step). Of course, we need to iterate this process, since the
expected values depend on the parameters, but the parameters depend on the expected values.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.7. Bound optimization * 307
Q(θ,θ
t
)
Q(θ,θ
t+1)
l(θ)
θ
t θ
t+1 θ
t+2
Figure 8.23: Illustration of a bound optimization algorithm. Adapted from Figure 9.14 of [Bis06]. Generated
by code at figures.probml.ai/book1/8.23.
Figure 8.24: The quadratic lower bound of an MM algorithm (solid) and the quadratic approximation of
Newton’s method (dashed) superimposed on an empirical density esitmate (dotted). The starting point of
both algorithms is the circle. The square denotes the outcome of one MM update. The diamond denotes the
outcome of one Newton update. (a) Newton’s method overshoots the global maximum. (b) Newton’s method
results in a reduction of the objective. From Figure 4 of [FT05]. Used with kind permission of Carlo Tomasi.
In Section 8.7.2.1, we show that EM is an MM algorithm, which implies that this iterative procedure
will converge to a local maximum of the log likelihood. The speed of convergence depends on the
amount of missing data, which affects the tightness of the bound [XJ96; MD97; SRG03; KKS20].
8.7.2.1 Lower bound
The goal of EM is to maximize the log likelihood of the observed data:
LL(θ) = X
N
n=1
log p(yn|θ) = X
N
n=1
log "X
zn
p(yn, zn|θ)
#
(8.146)
where yn are the visible variables and zn are the hidden variables. Unfortunately this is hard to
optimize, since the log cannot be pushed inside the sum.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license308 Chapter 8. Optimization
EM gets around this problem as follows. First, consider a set of arbitrary distributions qn(zn) over
each hidden variable zn. The observed data log likelihood can be written as follows:
LL(θ) = X
N
n=1
log "X
zn
qn(zn)
p(yn, zn|θ)
qn(zn)
#
(8.147)
Using Jensen’s inequality (Equation (6.34)), we can push the log (which is a concave function)
inside the expectation to get the following lower bound on the log likelihood:
LL(θ) ≥
X
n
X
zn
qn(zn) log p(yn, zn|θ)
qn(zn)
(8.148)
=
X
n
Eqn
[log p(yn, zn|θ)] + H(qn)
| {z }
Ł(θ,qn|yn)
(8.149)
=
X
n
Ł(θ, qn|yn) , Ł(θ, {qn}|D) (8.150)
where H(q) is the entropy of probability distribution q, and Ł(θ, {qn}|D) is called the evidence
lower bound or ELBO, since it is a lower bound on the log marginal likelihood, log p(y1:N |θ), also
called the evidence. Optimizing this bound is the basis of variational inference, which we discuss in
Section 4.6.8.3.
8.7.2.2 E step
We see that the lower bound is a sum of N terms, each of which has the following form:
Ł(θ, qn|yn) = X
zn
qn(zn) log p(yn, zn|θ)
qn(zn)
(8.151)
=
X
zn
qn(zn) log p(zn|yn, θ)p(yn|θ)
qn(zn)
(8.152)
=
X
zn
qn(zn) log p(zn|yn, θ)
qn(zn)
+
X
zn
qn(zn) log p(yn|θ) (8.153)
= −DKL (qn(zn)kp(zn|yn, θ)) + log p(yn|θ) (8.154)
where DKL (qkp) ,
P
z
q(z)log q(z)
p(z)
is the Kullback-Leibler divergence (or KL divergence for short)
between probability distributions q and p. We discuss this in more detail in Section 6.2, but the key
property we need here is that DKL (qkp) ≥ 0 and DKL (qkp) = 0 iff q = p. Hence we can maximize
the lower bound Ł(θ, {qn}|D) wrt {qn} by setting each one to q
∗
n = p(zn|yn, θ). This is called the E
step. This ensures the ELBO is a tight lower bound:
Ł(θ, {q
∗
n}|D) = X
n
log p(yn|θ) = LL(θ|D) (8.155)
To see how this connects to bound optimization, let us define
Q(θ, θ
t
) = Ł(θ, {p(zn|yn; θ
t
)}) (8.156)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.7. Bound optimization * 309
Then we have Q(θ, θ
t
) ≤ LL(θ) and Q(θ
t
, θ
t
) = LL(θ
t
), as required.
However, if we cannot compute the posteriors p(zn|yn; θ
t
) exactly, we can still use an approximate
distribution q(zn|yn; θ
t
); this will yield a non-tight lower-bound on the log-likelihood. This generalized
version of EM is known as variational EM [NH98]. See the sequel to this book, [Mur22], for details.
8.7.2.3 M step
In the M step, we need to maximize Ł(θ, {q
t
n}) wrt θ, where the q
t
n are the distributions computed
in the E step at iteration t. Since the entropy terms H(qn) are constant wrt θ, so we can drop them
in the M step. We are left with
LLt
(θ) = X
n
Eq
t
n(zn)
[log p(yn, zn|θ)] (8.157)
This is called the expected complete data log likelihood. If the joint probability is in the
exponential family (Section 3.4), we can rewrite this as
LLt
(θ) = X
n
E

T (yn, zn)
Tθ − A(θ)

=
X
n
(E [T (yn, zn)]T
θ − A(θ)) (8.158)
where E [T (yn, zn)] are called the expected sufficient statistics.
In the M step, we maximize the expected complete data log likelihood to get
θ
t+1 = arg max
θ
X
n
Eq
t
n
[log p(yn, zn|θ)] (8.159)
In the case of the exponential family, the maximization can be solved in closed-form by matching the
moments of the expected sufficient statistics.
We see from the above that the E step does not in fact need to return the full set of posterior
distributions
P
{q(zn)}, but can instead just return the sum of the expected sufficient statistics,
n Eq(zn)
[T (yn, zn)]. This will become clearer in the examples below.
8.7.3 Example: EM for a GMM
In this section, we show how to use the EM algorithm to compute MLE and MAP estimates of the
parameters for a Gaussian mixture model (GMM).
8.7.3.1 E step
The E step simply computes the responsibility of cluster k for generating data point n, as estimated
using the current parameter estimates θ
(t)
:
r
(t)
nk = p
∗
(zn = k|yn, θ
(t)
) = π
(t)
k
p(yn|θ
(t)
k
)
P
k0 π
(t)
k0 p(yn|θ
(t)
k0 )
(8.160)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license310 Chapter 8. Optimization
8.7.3.2 M step
The M step maximizes the expected complete data log likelihood, given by
LLt
(θ) = E
"X
n
log p(zn|π) + log p(yn|zn, θ)
#
(8.161)
= E
"X
n
log Y
k
π
znk
k
!
+ log Y
k
N (yn|µk, Σk)
znk!# (8.162)
=
X
n
X
k
E [znk] log πk +
X
n
X
k
E [znk] log N (yn|µk, Σk) (8.163)
=
X
n
X
k
r
(t)
nk log(πk) −
1
2
X
n
X
k
r
(t)
nk 
log |Σk| + (yn − µk)
TΣ
−1
k
(yn − µk)

+ const
(8.164)
where znk = I(zn = k) is a one-hot encoding of the categorical value zn. This objective is just a
weighted version of the standard problem of computing the MLEs of an MVN (see Section 4.2.6).
One can show that the new parameter estimates are given by
µ
(t+1)
k =
P
n
r
(t)
nkyn
r
(t)
k
(8.165)
Σ
(t+1)
k =
P
n
r
(t)
nk(yn − µ
(t+1)
k
)(yn − µ
(t+1)
k
)
T
r
(t)
k
=
P
n
r
(t)
nkyny
T
n
r
(t)
k
− µ
(t+1)
k
(µ
(t+1)
k
)
T
(8.166)
where r
(t)
k ,
P
n
r
(t)
nk is the weighted number of points assigned to cluster k. The mean of cluster k is
just the weighted average of all points assigned to cluster k, and the covariance is proportional to the
weighted empirical scatter matrix.
The M step for the mixture weights is simply a weighted form of the usual MLE:
π
(t+1)
k =
1
N
X
n
r
(t)
nk =
r
(t)
k
N
(8.167)
8.7.3.3 Example
An example of the algorithm in action is shown in Figure 8.25 where we fit some 2d data with a
2 component GMM. The data set, from [Bis06], is derived from measurements of the Old Faithful
geyser in Yellowstone National Park. In particular, we plot the time to next eruption in minutes
versus the duration of the eruption in minutes. The data was standardized, by removing the mean
and dividing by the standard deviation, before processing; this often helps convergence. We start
with µ1 = (−1, 1), Σ1 = I, µ2 = (1, −1), Σ2 = I. We then show the cluster assignments, and
corresponding mixture components, at various iterations.
For more details on applying GMMs for clustering, see Section 21.4.1.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.7. Bound optimization * 311
1 0 1
2
1
0
1
Iteration 0
1 0 1
2
1
0
1
Iteration 10
1 0 1
2
1
0
1
Iteration 25
1 0 1
2
1
0
1
Iteration 30
1 0 1
2
1
0
1
Iteration 35
1 0 1
2
1
0
1
Iteration 40
Figure 8.25: Illustration of the EM for a GMM applied to the Old Faithful data. The degree of redness
indicates the degree to which the point belongs to the red cluster, and similarly for blue; thus purple points have
a roughly 50/50 split in their responsibilities to the two clusters. Adapted from [Bis06] Figure 9.8. Generated
by code at figures.probml.ai/book1/8.25.
8.7.3.4 MAP estimation
Computing the MLE of a GMM often suffers from numerical problems and overfitting. To see why,
suppose for simplicity that Σk = σ
2
k
I for all k. It is possible to get an infinite likelihood by assigning
one of the centers, say µk, to a single data point, say yn, since then the likelihood of that data point
is given by
N (yn|µk = yn, σ2
k
I) = 1
p
2πσ2
k
e
0
(8.168)
Hence we can drive this term to infinity by letting σk → 0, as shown in Figure 8.26(a). We call this
the “collapsing variance problem”.
An easy solution to this is to perform MAP estimation. Fortunately, we can still use EM to find
this MAP estimate. Our goal is now to maximize the expected complete data log-likelihood plus the
log prior:
LLt
(θ) = "X
n
X
k
r
(t)
nk log πnk +
X
n
X
k
r
(t)
nk log p(yn|θk)
#
+ log p(π) +X
k
log p(θk) (8.169)
Note that the E step remains unchanged, but the M step needs to be modified, as we now explain.
For the prior on the mixture weights, it is natural to use a Dirichlet prior (Section 4.6.3.2),
π ∼ Dir(α), since this is conjugate to the categorical distribution. The MAP estimate is given by
π˜
(t+1)
k =
r
(t)
k + αk − 1
N +
P
k αk − K
(8.170)
If we use a uniform prior, αk = 1, this reduces to the MLE.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license312 Chapter 8. Optimization
x
p(x)
(a)
20 40 60 80 100
dimensionality
0.0
0.2
0.4
0.6
0.8
1.0
fraction of times EM for GMM fails
MLE
MAP
(b)
Figure 8.26: (a) Illustration of how singularities can arise in the likelihood function of GMMs. Here K = 2,
but the first mixture component is a narrow spike (with σ1 ≈ 0) centered on a single data point x1. Adapted
from Figure 9.7 of [Bis06]. Generated by code at figures.probml.ai/book1/8.26. (b) Illustration of the benefit
of MAP estimation vs ML estimation when fitting a Gaussian mixture model. We plot the fraction of times
(out of 5 random trials) each method encounters numerical problems vs the dimensionality of the problem, for
N = 100 samples. Solid red (upper curve): MLE. Dotted black (lower curve): MAP. Generated by code at
figures.probml.ai/book1/8.26.
For the prior on the mixture components, let us consider a conjugate prior of the form
p(µk, Σk) = NIW(µk, Σk| m` ,
`κ,
`ν,
`
S) (8.171)
This is called the Normal-Inverse-Wishart distribution (see the sequel to this book, [Mur22],
for details.) Suppose we set the hyper-parameters for µ to be `κ= 0, so that the µk are unregularized;
thus the prior will only influence our estimate of Σk. In this case, the MAP estimates are given by
µ˜
(t+1)
k = µˆ
(t+1)
k
(8.172)
Σ˜
(t+1)
k =
`
S +Σˆ
(t+1)
k
`ν +r
(t)
k + D + 2
(8.173)
where µˆk is the MLE for µk from Equation (8.165), and Σˆ
k is the MLE for Σk from Equation (8.166).
Now we discuss how to set the prior covariance, `
S. One possibility (suggested in [FR07, p163]) is
to use
`
S=
1
K1/D diag(s
2
1
, . . . , s2
D) (8.174)
where sd = (1/N)
PN
n=1(xnd −xd)
2
is the pooled variance for dimension d. The parameter `ν controls
how strongly we believe this prior. The weakest prior we can use, while still being proper, is to set
`ν= D + 2, so this is a common choice.
We now illustrate the benefits of using MAP estimation instead of ML estimation in the context of
GMMs. We apply EM to some synthetic data with N = 100 samples in D dimensions, using either
ML or MAP estimation. We count the trial as a “failure” if there are numerical issues involving
singular matrices. For each dimensionality, we conduct 5 random trials. The results are illustrated in
Figure 8.26(b). We see that as soon as D becomes even moderately large, ML estimation crashes and
burns, whereas MAP with an appropriate prior estimation rarely encounters numerical problems.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20228.8. Blackbox and derivative free optimization 313
−25 −20 −15 −10 −5 0 5 10 15 20 25
0
5
10
15
20
25
30
35
(a)
µ
1
µ
2
−15.5 −10.5 −5.5 −0.5 4.5 9.5 14.5 19.5
−15.5
−10.5
−5.5
−0.5
4.5
9.5
14.5
19.5
(b)
Figure 8.27: Left: N = 200 data points sampled from a mixture of 2 Gaussians in 1d, with πk = 0.5, σk = 5,
µ1 = −10 and µ2 = 10. Right: Likelihood surface p(D|µ1, µ2), with all other parameters set to their true
values. We see the two symmetric modes, reflecting the unidentifiability of the parameters. Generated by code
at figures.probml.ai/book1/8.27.
8.7.3.5 Nonconvexity of the NLL
The likelihood for a mixture model is given by
LL(θ) = X
N
n=1
log "X
K
zn=1
p(yn, zn|θ)
#
(8.175)
In general, this will have multiple modes, and hence there will not be a unique global optimum.
Figure 8.27 illustrates this for a mixture of 2 Gaussians in 1d. We see that there are two equally
good global optima, corresponding to two different labelings of the clusters, one in which the left
peak corresponds to z = 1, and one in which the left peak corresponds to z = 2. This is called the
label switching problem; see Section 21.4.1.2 for more details.
The question of how many modes there are in the likelihood function is hard to answer. There are
K! possible labelings, but some of the peaks might get merged, depending on how far apart the µk
are. Nevertheless, there can be an exponential number of modes. Consequently, finding any global
optimum is NP-hard [Alo+09; Dri+04]. We will therefore have to be satisfied with finding a local
optimum. To find a good local optimum, we can use Kmeans++ (Section 21.3.4) to initialize EM.
8.8 Blackbox and derivative free optimization
In some optimization problems, the objective function is a blackbox, meaning that its functional
form is unknown. This means we cannot use gradient-based methods to optimize it. Instead,
solving such problems require blackbox optimization (BBO) methods, also called derivative
free optimization (DFO).
In ML, this kind of problem often arises when performing model selection. For example, suppose
we have some hyper-parameters, λ ∈ Λ, which control the type or complexity of a model. We often
define the objective function L(λ) to be the loss on a validation set (see Section 4.5.4). Since the
validation loss depends on the optimal model parameters, which are computed using a complex
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license314 Chapter 8. Optimization
algorithm, this objective function is effectively a blackbox.4 A simple approach to such problems
is to use grid search, where we evaluate each point in the parameter space, and pick the one
with the lowest loss. Unfortunately, this does not scale to high dimensions, because of the curse of
dimensionality. In addition, even in low dimensions this can be expensive if evaluate the blackbox
objective is expensive (e.g., if it first requires training the model before computing the validation
loss). Various solutions to this problem have been proposed. See the sequel to this book, [Mur22],
for details.
8.9 Exercises
Exercise 8.1 [Subderivative of the hinge loss function *]
Let f(x) = (1 − x)+ be the hinge loss function, where (z)+ = max(0, z). What are ∂f(0), ∂f(1), and ∂f(2)?
Exercise 8.2 [EM for the Student distribution]
Derive the EM equations for computing the MLE for a multivariate Student distribution. Consider the case
where the dof parameter is known and unknown separately. Hint: write the Student distribution as a scale
mixture of Gaussians.
4. If the optimal parameters are computed using a gradient-based optimizer, we can “unroll” the gradient steps, to
create a deep circuit that maps from the training data to the optimal parameters and hence to the validation loss. We
can then optimize through the optimizer (see e.g., [Fra+17]. However, this technique can only be applied in limited
settings.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022Part II
Linear Models9 Linear Discriminant Analysis
9.1 Introduction
In this chapter, we consider classification models of the following form:
p(y = c|x; θ) = p(x|y = c; θ)p(y = c; θ)
P
c
0 p(x|y = c
0
; θ)p(y = c
0
; θ)
(9.1)
The term p(y = c; θ) is the prior over class labels, and the term p(x|y = c; θ) is called the class
conditional density for class c.
The overall model is called a generative classifier, since it specifies a way to generate the features
x for each class c, by sampling from p(x|y = c; θ). By contrast, a discriminative classifier directly
models the class posterior p(y|x; θ). We discuss the pros and cons of these two approaches to
classification in Section 9.4.
If we choose the class conditional densities in a special way, we will see that the resulting posterior
over classes is a linear function of x, i.e., log p(y = c|x; θ) = wTx + const, where w is derived from
θ. Thus the overall method is called linear discriminant analysis or LDA.
1
9.2 Gaussian discriminant analysis
In this section, we consider a generative classifier where the class conditional densities are multivariate
Gaussians:
p(x|y = c, θ) = N (x|µc, Σc) (9.2)
The corresponding class posterior therefore has the form
p(y = c|x, θ) ∝ πcN (x|µc, Σc) (9.3)
where πc = p(y = c) is the prior probability of label c. (Note that we can ignore the normalization
constant in the denominator of the posterior, since it is independent of c.) We call this model
Gaussian discriminant analysis or GDA.
1. This term is rather confusing for two reaons. First, LDA is a generative, not discriminative, classifier. Second,
LDA also stands for “latent Dirichlet allocation”, which is a popular unsupervised generative model for bags of words
[BNJ03].318 Chapter 9. Linear Discriminant Analysis
4 2 0 2 4 6
2
0
2
4
6
(a)
4 2 0 2 4 6
4
2
0
2
4
6
(b)
Figure 9.1: (a) Some 2d data from 3 different classes. (b) Fitting 2d Gaussians to each class. Generated by
code at figures.probml.ai/book1/9.1.
4 2 0 2 4 6
4
2
0
2
4
6
QDA
(a)
4 2 0 2 4 6
4
2
0
2
4
6
LDA
(b)
Figure 9.2: Gaussian discriminant analysis fit to data in Figure 9.1. (a) Unconstrained covariances induce
quadratic decision boundaries. (b) Tied covariances induce linear decision boundaries. Generated by code at
figures.probml.ai/book1/9.2.
9.2.1 Quadratic decision boundaries
From Equation (9.3), we see that the log posterior over class labels is given by
log p(y = c|x, θ) = log πc −
1
2
log |2πΣc| − 1
2
(x − µc)
TΣ
−1
c
(x − µc) + const (9.4)
This is called the discriminant function. We see that the decision boundary between any two classes,
say c and c
0
, will be a quadratic function of x. Hence this is known as quadratic discriminant
analysis (QDA).
For example, consider the 2d data from 3 different classes in Figure 9.1a. We fit full covariance
Gaussian class-conditionals (using the method explained in Section 9.2.4), and plot the results in
Figure 9.1b. We see that the features for the blue class are somewhat correlated, whereas the features
for the green class are independent, and the features for the red class are independent and isotropic
(spherical covariance). In Figure 9.2a, we see that the resulting decision boundaries are quadratic
functions of x.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20229.2. Gaussian discriminant analysis 319
Figure 9.3: Geometry of LDA in the 2 class case where Σ1 = Σ2 = I.
9.2.2 Linear decision boundaries
Now we consider a special case of Gaussian discriminant analysis in which the covariance matrices are
tied or shared across classes, so Σc = Σ. If Σ is independent of c, we can simplify Equation (9.4)
as follows:
log p(y = c|x, θ) = log πc −
1
2
(x − µc)
TΣ
−1
(x − µc) + const (9.5)
= log πc −
1
2
µ
T
cΣ
−1µc
| {z }
γc
+x
T Σ
−1µc
| {z }
βc
+const −
1
2
x
TΣ
−1x
| {z }
κ
(9.6)
= γc + x
Tβc + κ (9.7)
The final term is independent of c, and hence is an irrelevant additive constant that can be dropped.
Hence we see that the discriminant function is a linear function of x, so the decision boundaries will
be linear. Hence this method is called linear discriminant analysis or LDA. See Figure 9.2b for
an example.
9.2.3 The connection between LDA and logistic regression
In this section, we derive an interesting connection between LDA and logistic regression, which we
introduced in Section 2.5.3. From Equation (9.7) we can write
p(y = c|x, θ) = e
β
T
cx+γc
P
c
0 e
βT
c0x+γc0
=
e
wT
c
[1,x]
P
c
0 e
wT
c0
[1,x]
(9.8)
where wc = [γc, βc
]. We see that Equation (9.8) has the same form as the multinomial logistic
regression model. The key difference is that in LDA, we first fit the Gaussians (and class prior) to
maximize the joint likelihood p(x, y|θ), as discussed in Section 9.2.4, and then we derive w from θ.
By contrast, in logistic regression, we estimate w directly to maximize the conditional likelihood
p(y|x, w). In general, these can give different results (see Exercise 10.3).
To gain further insight into Equation (9.8), let us consider the binary case. In this case, the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license320 Chapter 9. Linear Discriminant Analysis
posterior is given by
p(y = 1|x, θ) = e
β
T
1x+γ1
e
βT
1x+γ1 + e
βT
0x+γ0
=
1
1 + e
(β0−β1
)
Tx+(γ0−γ1)
(9.9)
= σ
￾
(β1 − β0
)
Tx + (γ1 − γ0)

(9.10)
where σ(η) refers to the sigmoid function.
Now
γ1 − γ0 = −
1
2
µ
T
1Σ
−1µ1 +
1
2
µ
T
0Σ
−1µ0 + log(π1/π0) (9.11)
= −
1
2
(µ1 − µ0)
TΣ
−1
(µ1 + µ0) + log(π1/π0) (9.12)
So if we define
w = β1 − β0 = Σ
−1
(µ1 − µ0) (9.13)
x0 =
1
2
(µ1 + µ0) − (µ1 − µ0)
log(π1/π0)
(µ1 − µ0)
TΣ
−1
(µ1 − µ0)
(9.14)
then we have wTx0 = −(γ1 − γ0), and hence
p(y = 1|x, θ) = σ(wT
(x − x0)) (9.15)
This has the same form as binary logistic regression. Hence the MAP decision rule is
yˆ(x) = 1 iff wTx > c (9.16)
where c = wTx0. If π0 = π1 = 0.5, then the threshold simplifies to c =
1
2wT(µ1 + µ0).
To interpret this equation geometrically, suppose Σ = σ
2
I. In this case, w = σ
−2
(µ1 − µ0),
which is parallel to a line joining the two centroids, µ0 and µ1. So we can classify a point by
projecting it onto this line, and then checking if the projection is closer to µ0 or µ1, as illustrated in
Figure 9.3. The question of how close it has to be depends on the prior over classes. If π1 = π0, then
x0 =
1
2
(µ1 + µ0), which is halfway between the means. If we make π1 > π0, we have to be closer to
µ0 than halfway in order to pick class 0. And vice versa if π0 > π1. Thus we see that the class prior
just changes the decision threshold, but not the overall shape of the decision boundary. (A similar
argument applies in the multi-class case.)
9.2.4 Model fitting
We now discuss how to fit a GDA model using maximum likelihood estimation. The likelihood
function is as follows
p(D|θ) = Y
N
n=1
Cat(yn|π)
Y
C
c=1
N (xn|µc, Σc)
I(yn=c)
(9.17)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2029.2. Gaussian discriminant analysis 321
Hence the log-likelihood is given by
log p(D|θ) = "X
N
n=1
X
C
c=1
I(yn = c) log πc
#
+
X
C
c=1 " X
n:yn=c
log N (xn|µc, Σc)
#
(9.18)
Thus we see that we can optimize π and the (µc, Σc) terms separately.
From Section 4.2.4, we have that the MLE for the class prior is πˆc =
Nc
N
. Using the results from
Section 4.2.6, we can derive the MLEs for the Gaussians as follows:
µˆ c =
1
Nc
X
n:yn=c
xn (9.19)
Σˆ
c =
1
Nc
X
n:yn=c
(xn − µˆ c)(xn − µˆ c)
T
(9.20)
Unfortunately the MLE for Σˆ
c can easily overfit (i.e., the estimate may not be well-conditioned) if
Nc is small compared to D, the dimensionality of the input features. We discuss some solutions to
this below.
9.2.4.1 Tied covariances
If we force Σc = Σ to be tied, we will get linear decision boundaries, as we have seen. This also
usually results in a more reliable parameter estimate, since we can pool all the samples across classes:
Σˆ =
1
N
X
C
c=1
X
n:yn=c
(xn − µˆ c)(xn − µˆ c)
T
(9.21)
9.2.4.2 Diagonal covariances
If we force Σc to be diagonal, we reduce the number of parameters from O(CD2
) to O(CD), which
avoids the overfitting problem. However, this loses the ability to capture correlations between the
features. (This is known as the naive Bayes assumption, which we discuss further in Section 9.3.)
Despite this approximation, this approach scales well to high dimensions.
We can further restrict the model capacity by using a shared (tied) diagonal covariace matrix.
This is called “diagonal LDA” [BL04].
9.2.4.3 MAP estimation
Forcing the covariance matrix to be diagonal is a rather strong assumption. An alternative approach
is to perform MAP estimation of a (shared) full covariance Gaussian, rather than using the MLE.
Based on the results of Section 4.5.2, we find that the MAP estimate is
Σˆ map = λdiag(Σˆ mle) + (1 − λ)Σˆ mle (9.22)
where λ controls the amount of regularization. This technique is known as regularized discriminant
analysis or RDA [HTF09, p656].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license322 Chapter 9. Linear Discriminant Analysis
9.2.5 Nearest centroid classifier
If we assume a uniform prior over classes, we can compute the most probable class label as follows:
yˆ(x) = argmax
c
log p(y = c|x, θ) = argmin
c
(x − µc)
TΣ
−1
(x − µc) (9.23)
This is called the nearest centroid classifier, or nearest class mean classifier (NCM), since
we are assigning x to the class with the closest µc, where distance is measured using (squared)
Mahalanobis distance.
We can replace this with any other distance metric to get the decision rule
yˆ(x) = argmin
c
d
2
(x, µc) (9.24)
We discuss how to learn distance metrics in Section 16.2, but one simple approach is to use
d
2
(x, µc) = ||x − µc||2
W = (x − µc)
T
(WWT
)(x − µc) = ||W(x − µc)||2
(9.25)
The corresponding class posterior becomes
p(y = c|x, µ,W) = exp(−
1
2
||W(x − µc)||2
2
)
PC
c
0=1 exp(−
1
2
||W(x − µc
0 )||2
2
)
(9.26)
We can optimize W using gradient descent applied to the discriminative loss. This is called nearest
class mean metric learning [Men+12]. The advantage of this technique is that it can be used for
one-shot learning of new classes, since we just need to see a single labeled prototype µc per class
(assuming we have learned a good W already).
9.2.6 Fisher’s linear discriminant analysis *
Discriminant analysis is a generative approach to classification, which requires fitting an MVN to
the features. As we have discussed, this can be problematic in high dimensions. An alternative
approach is to reduce the dimensionality of the features x ∈ R
D and then fit an MVN to the
resulting low-dimensional features z ∈ R
K. The simplest approach is to use a linear projection
matrix, z = Wx, where W is a K × D matrix. One approach to finding W would be to use principal
components analysis or PCA (Section 20.1). However, PCA is an unsupervised technique that does
not take class labels into account. Thus the resulting low dimensional features are not necessarily
optimal for classification, as illustrated in Figure 9.4.
An alternative approach is to use gradient based methods to optimize the log likelihood, derived
from the class posterior in the low dimensional space, as we discussed in Section 9.2.5.
A third approach (which relies on an eigendecomposition, rather than a gradient-based optimizer)
is to find the matrix W such that the low-dimensional data can be classified as well as possible using
a Gaussian class-conditional density model. The assumption of Gaussianity is reasonable since we
are computing linear combinations of (potentially non-Gaussian) features. This approach is called
Fisher’s linear discriminant analysis, or FLDA.
FLDA is an interesting hybrid of discriminative and generative techniques. The drawback of this
technique is that it is restricted to using K ≤ C − 1 dimensions, regardless of D, for reasons that we
will explain below. In the two-class case, this means we are seeking a single vector w onto which we
can project the data. Below we derive the optimal w in the two-class case. We then generalize to
the multi-class case, and finally we give a probabilistic interpretation of this technique.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20229.2. Gaussian discriminant analysis 323
2 0 2 4 6 8
0.5
1.0
1.5
2.0
2.5
3.0
3.5
Male
Female
PCA vector
(a)
2 0 2 4 6 8
0.5
1.0
1.5
2.0
2.5
3.0
3.5
Male
Female
FisherLDA vector
(b)
4 2 0 2 4 6 8
0
5
10
15
20
Projection of points onto PCA vector
(c)
80 60 40 20 0
0
5
10
15
20
Projection of points onto Fisher vector
(d)
Figure 9.4: Linear disciminant analysis applied to two class dataset in 2d, representing (standardized) height
and weight for male and female adults (a) PCA direction. (b) FLDA direction. (c) Projection onto PCA
direction shows poor class separation. (d) Projection onto FLDA direction shows good class separation.
Generated by code at figures.probml.ai/book1/9.4.
9.2.6.1 Derivation of the optimal 1d projection
We now derive this optimal direction w, for the two-class case, following the presentation of [Bis06,
Sec 4.1.4]. Define the class-conditional means as
µ1 =
1
N1
X
n:yn=1
xn, µ2 =
1
N2
X
n:yn=2
xn (9.27)
Let mk = wTµk be the projection of each mean onto the line w. Also, let zn = wTxn be the
projection of the data onto the line. The variance of the projected points is proportional to
s
2
k =
X
n:yn=k
(zn − mk)
2
(9.28)
The goal is to find w such that we maximize the distance between the means, m2 − m1, while also
ensuring the projected clusters are “tight”, which we can do by minimizing their variance. This
suggests the following objective:
J(w) = (m2 − m1)
2
s
2
1 + s
2
2
(9.29)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license324 Chapter 9. Linear Discriminant Analysis
We can rewrite the right hand side of the above in terms of w as follows
J(w) = wTSBw
wTSW w
(9.30)
where SB is the between-class scatter matrix given by
SB = (µ2 − µ1)(µ2 − µ1)
T
(9.31)
and SW is the within-class scatter matrix, given by
SW =
X
n:yn=1
(xn − µ1)(xn − µ1)
T +
X
n:yn=2
(xn − µ2)(xn − µ2)
T
(9.32)
To see this, note that
wTSBw = wT
(µ2 − µ1)(µ2 − µ1)
Tw = (m2 − m1)(m2 − m1) (9.33)
and
wTSW w =
X
n:yn=1
wT
(xn − µ1)(xn − µ1)
Tw+
X
n:yn=2
wT
(xn − µ2)(xn − µ2)
Tw (9.34)
=
X
n:yn=1
(zn − m1)
2 +
X
n:yn=2
(zn − m2)
2
(9.35)
Equation (9.30) is a ratio of two scalars; we can take its derivative with respect to w and equate to
zero. One can show (Exercise 9.1) that J(w) is maximized when
SBw = λSW w (9.36)
where
λ =
wTSBw
wTSW w
(9.37)
Equation (9.36) is called a generalized eigenvalue problem. If SW is invertible, we can convert it
to a regular eigenvalue problem:
S
−1
W SBw = λw (9.38)
However, in the two class case, there is a simpler solution. In particular, since
SBw = (µ2 − µ1)(µ2 − µ1)
Tw = (µ2 − µ1)(m2 − m1) (9.39)
then, from Equation (9.38) we have
λ w = S
−1
W (µ2 − µ1)(m2 − m1) (9.40)
w ∝ S
−1
W (µ2 − µ1) (9.41)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20229.2. Gaussian discriminant analysis 325
4 3 2 1 0 1 2 3
3
2
1
0
1
2
PCA projection of vowel data to 2d
(a)
4.0 3.5 3.0 2.5 2.0 1.5 1.0 0.5
3.0
2.5
2.0
1.5
1.0
0.5
0.0
FLDA projection of vowel data to 2d
(b)
Figure 9.5: (a) PCA projection of vowel data to 2d. (b) FLDA projection of vowel data to 2d. We see there
is better class separation in the FLDA case. Adapted from Figure 4.11 of [HTF09]. Generated by code at
figures.probml.ai/book1/9.5.
Since we only care about the directionality, and not the scale factor, we can just set
w = S
−1
W (µ2 − µ1) (9.42)
This is the optimal solution in the two-class case. If SW ∝ I, meaning the pooled covariance matrix
is isotropic, then w is proportional to the vector that joins the class means. This is an intuitively
reasonable direction to project onto, as shown in Figure 9.3.
9.2.6.2 Extension to higher dimensions and multiple classes
We can extend the above idea to multiple classes, and to higher dimensional subspaces, by finding a
projection matrix W which maps from D to K. Let zn = Wxn be the low dimensional projection
of the n’th data point. Let mc =
1
Nc
P
n:yn=c
zn be the corresponding mean for the c’th class and
m =
1
N
PC
c=1 Ncmc be the overall mean, both in the low dimensional space. We define the following
scatter matrices:
S˜W =
X
C
c=1
X
n:yn=c
(zn − mc)(zn − mc)
T
(9.43)
S˜B =
X
C
c=1
Nc(mc − m)(mc − m)
T
(9.44)
Finally, we define the objective function as maximizing the following:2
J(W) = |S˜B|
|S˜W |
=
|WTSBW|
|WTSWW|
(9.45)
2. An alternative criterion that is sometimes used [Fuk90] is J(W) = tr n
S˜−1
W S˜B
o
= tr 
(WSWWT)−1
(WSBWT)
	
.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license326 Chapter 9. Linear Discriminant Analysis
where SW and SB are defined in the original high dimensional space in the obvious way (namely using
xn instead of zn, µc instead of mc, and µ instead of m). The solution can be shown [DHS01] to be
W = S
− 1
2
W U, where U are the K leading eigenvectors of S
− 1
2
W SBS
− 1
2
W , assuming SW is non-singular.
(If it is singular, we can first perform PCA on all the data.)
Figure 9.5 gives an example of this method applied to some D = 10 dimensional speech data,
representing C = 11 different vowel sounds. We project to K = 2 dimensions in order to visualize
the data. We see that FLDA gives better class separation than PCA.
Note that FLDA is restricted to finding at most a K ≤ C − 1 dimensional linear subspace, no
matter how large D, because the rank of the between class scatter matrix SB is C − 1. (The -1 term
arises because of the µ term, which is a linear function of the µc.) This is a rather severe restriction
which limits the usefulness of FLDA.
9.3 Naive Bayes classifiers
In this section, we discuss a simple generative approach to classification in which we assume the features
are conditionally independent given the class label. This is called the naive Bayes assumption.
The model is called “naive” since we do not expect the features to be independent, even conditional on
the class label. However, even if the naive Bayes assumption is not true, it often results in classifiers
that work well [DP97]. One reason for this is that the model is quite simple (it only has O(CD)
parameters, for C classes and D features), and hence it is relatively immune to overfitting.
More precisely, the naive Bayes assumption corresponds to using a class conditional density of the
following form:
p(x|y = c, θ) = Y
D
d=1
p(xd|y = c, θdc) (9.46)
where θdc are the parameters for the class conditional density for class c and feature d. Hence the
posterior over class labels is given by
p(y = c|x, θ) = p(y = c|π)
QD
d=1 p(xd|y = c, θdc)
P
c
0 p(y = c
0
|π)
QD
d=1 p(xd|y = c
0
, θdc0 )
(9.47)
where πc is the prior probability of class c, and θ = (π, {θdc}}) are all the parameters. This is known
as a naive Bayes classifier or NBC.
9.3.1 Example models
We still need to specify the form of the probability distributions in Equation (9.46). This depends on
what type of feature xd is. We give some examples below:
• In the case of binary features, xd ∈ {0, 1}, we can use the Bernoulli distribution: p(x|y = c, θ) =
QD
d=1 Ber(xd|θdc), where θdc is the probability that xd = 1 in class c. This is sometimes called
the multivariate Bernoulli naive Bayes model. For example, Figure 9.6 shows the estimated
parameters for each class when we fit this model to a binarized version of MNIST. This approach
does surprisingly well, and has a test set accuracy of 84.3%. (See Figure 9.7 for some sample
predictions.)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20229.3. Naive Bayes classifiers 327
Figure 9.6: Visualization of the Bernoulli class conditional densities for a naive Bayes classifier fit to a
binarized version of the MNIST dataset. Generated by code at figures.probml.ai/book1/9.6.
1 4 9 4 9
Figure 9.7: Visualization of the predictions made by the model in Figure 9.6 when applied to some bi￾narized MNIST test images. The title shows the most probable predicted class. Generated by code at
figures.probml.ai/book1/9.7.
• In the case of categorical features, xd ∈ {1, . . . , K}, we can use the categorical distribution:
p(x|y = c, θ) = QD
d=1 Cat(xd|θdc), where θdck is the probability that xd = k given that y = c.
• In the case of real-valued features, xd ∈ R, we can use the univariate Gaussian distribution:
p(x|y = c, θ) = QD
d=1 N (xd|µdc, σ2
dc), where µdc is the mean of feature d when the class label is
c, and σ
2
dc is its variance. (This is equivalent to Gaussian discriminant analysis using diagonal
covariance matrices.)
9.3.2 Model fitting
In this section, we discuss how to fit a naive Bayes classifier using maximum likelihood estimation.
We can write the likelihood as follows:
p(D|θ) = Y
N
n=1
Cat(yn|π)
Y
D
d=1
p(xnd|yn, θd) (9.48)
=
Y
N
n=1
Cat(yn|π)
Y
D
d=1
Y
C
c=1
p(xnd|θd,c)
I(yn=c)
(9.49)
so the log-likelihood is given by
log p(D|θ) = "X
N
n=1
X
C
c=1
I(yn = c) log πc
#
+
X
C
c=1
X
D
d=1 " X
n:yn=c
log p(xnd|θdc)
#
(9.50)
We see that this decomposes into a term for π, and CD terms for each θdc:
log p(D|θ) = log p(Dy|π) +X
c
X
d
log p(Ddc|θdc) (9.51)
where Dy = {yn : n = 1 : N} are all the labels, and Ddc = {xnd : yn = c} are all the values of feature
d for examples from class c. Hence we can estimate these parameters separately.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license328 Chapter 9. Linear Discriminant Analysis
In Section 4.2.4, we show that the MLE for π is the vector of empirical counts, πˆc =
Nc
N
. The
MLEs for θdc depend on the choice of the class conditional density for feature d. We discuss some
common choices below.
• In the case of discrete features, we can use a categorical distribution. A straightforward extension
of the results in Section 4.2.4 gives the following expression for the MLE:
ˆθdck =
Ndck
PK
k0=1 Ndck0
=
Ndck
Nc
(9.52)
where Ndck =
PN
n=1 I(xnd = k, yn = c) is the number of times that feature d had value k in
examples of class c.
• In the case of binary features, the categorical distribution becomes the Bernoulli, and the MLE
becomes
ˆθdc =
Ndc
Nc
(9.53)
which is the empirical fraction of times that feature d is on in examples of class c.
• In the case of real-valued features, we can use a Gaussian distribution. A straightforward extension
of the results in Section 4.2.5 gives the following expression for the MLE:
µˆdc =
1
Nc
X
n:yn=c
xnd (9.54)
σˆ
2
dc =
1
Nc
X
n:yn=c
(xnd − µˆdc)
2
(9.55)
Thus we see that fitting a naive Bayes classifier is extremely simple and efficient.
9.3.3 Bayesian naive Bayes
In this section, we extend our discussion of MLE estimation for naive Bayes classifiers from Section 9.3.2
to compute the posterior distribution over the parameters. For simplicity, let us assume we have
categorical features, so p(xd|θdc) = Cat(xd|θdc), where θdck = p(xd = k|y = c). In Section 4.6.3.2,
we show that the conjugate prior for the categorical likelihood is the Dirichlet distribution, p(θdc) =
Dir(θdc|βdc), where βdck can be interpereted as a set of “pseudo counts”, corresponding to counts
Ndck that come from prior data. Similarly we use a Dirichlet prior for the label frequencies,
p(π) = Dir(π|α). By using a conjugate prior, we can compute the posterior in closed form, as we
explain in Section 4.6.3. In particular, we have
p(θ|D) = Dir(π|
aα)
Y
D
d=1
Y
C
c=1
Dir(θdc|
a
βdc) (9.56)
where aαc=
`αc +Nc and a
βdck=
`
βdck +Ndck.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20229.3. Naive Bayes classifiers 329
Using the results from Section 4.6.3.4, we can derive the posterior predictive distribution as follows.
The prior over the label is given by p(y|D) = Cat(y|π), where πc =
aαc /
P
c
0
aαc
0 . For the features,
we have p(xd = k|y = c, D) = θdck, where
θdck =
a
P
βdck
k0
a
βdck0
=
`
βdck +Ndck
P
k0
`
βdck0 +Ndck0
(9.57)
is the posterior mean of the parameters.
If `
βdck= 0, this reduces to the MLE in Equation (9.52). By contrast, if we set `
βdck= 1, we add
1 to all the empirical counts before normalizing. This is called add-one smoothing or Laplace
smoothing. For example, in the binary case, this gives
θdc =
`
βdc1 +Ndc1
`
βdc0 +Ndc0+
`
βdc1 +Ndc1
=
1 + Ndc1
2 + Nc
(9.58)
Once we have estimated the parameter posterior, we can compute the predicted distribution over
the label as follows:
p(y = c|x, D) ∝ p(y = c|D)
Y
d
p(xd|y = c, D) = πc
Y
d
Y
k
θ
I(xd=k)
dck (9.59)
This gives us a fully Bayesian form of naive Bayes, in which we have integrated out all the parameters.
(In this case, the predictive distribution can be obtained merely by plugging in the posterior mean
parameters.)
9.3.4 The connection between naive Bayes and logistic regression
In this section, we show that the class posterior p(y|x, θ) for a NBC model has the same form as
multinomial logistic regression. For simplicity, we assume that the features are all discrete, and each
has K states, although the result holds for arbitrary feature distributions in the exponential family.
Let xdk = I(xd = k), so xd is a one-hot encoding of feature d. Then the class conditional density
can be written as follows:
p(x|y = c, θ) = Y
D
d=1
Cat(xd|y = c, θ) = Y
D
d=1
Y
K
k=1
θ
xdk
dck (9.60)
Hence the posterior over classes is given by
p(y = c|x, θ) = πc
Q
d
Q
k
θ
xdk
P
dck
c
0 πc
0
Q
d
Q
k
θ
xdk
dc0k
=
exp[log πc +
P
d
P
k
xdk log θdck]
P
c
0 exp[log πc
0 +
P
d
P
k
xdk log θdc0k]
(9.61)
This can be written as a softmax
p(y = c|x, θ) = e
β
T
cx+γc
PC
c
0=1 e
βT
c0x+γc0
(9.62)
by suitably defining βc and γc. This has exactly the same form as multinomial logistic regression in
Section 2.5.3. The difference is that with naive Bayes we optimize the joint likelihood Q
n
p(yn, xn|θ),
whereas with logistic regression, we optimize the conditional likelihood Q
n
p(yn|xn, θ). In general,
these can give different results (see Exercise 10.3).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license330 Chapter 9. Linear Discriminant Analysis
0.0 0.2 0.4 0.6 0.8 1.0
x
0
1
2
3
4
class conditional densities
p(x|y=1)
p(x|y=2)
(a)
0.0 0.2 0.4 0.6 0.8 1.0
0.0
0.2
0.4
0.6
0.8
1.0
1.2
p(y=1|x) p(y=2|x)
(b)
Figure 9.8: The class-conditional densities p(x|y = c) (left) may be more complex than the class posteriors
p(y = c|x) (right). Adapted from Figure 1.27 of [Bis06]. Generated by code at figures.probml.ai/book1/9.8.
9.4 Generative vs discriminative classifiers
A model of the form p(x, y) = p(y)p(x|y) is called a generative classifier, since it can be used
to generate examples x from each class y. By contrast, a model of the form p(y|x) is called a
discriminative classifier, since it can only be used to discriminate between different classes. Below
we discuss various pros and cons of the generative and discriminative approaches to classification.
9.4.1 Advantages of discriminative classifiers
The main advantages of discriminative classifiers are as follows:
• Better predictive accuracy. Discriminative classifiers are often much more accurate than
generative classifiers [NJ02]. The reason is that the conditional distribution p(y|x) is often much
simpler (and therefore easier to learn) than the joint distribution p(y, x), as illustrated in Figure 9.8.
In particular, discriminative models do not need to “waste effort” modeling the distribution of the
input features.
• Can handle feature preprocessing. A big advantage of discriminative methods is that they
allow us to preprocess the input in arbitrary ways. For example, we can perform a polynomial
expansion of the input features, and we can replace a string of words with embedding vectors (see
Section 20.5). It is often hard to define a generative model on such pre-processed data, since the
new features can be correlated in complex ways which are hard to model.
• Well-calibrated probabilities. Some generative classifiers, such as naive Bayes (described in
Section 9.3), make strong independence assumptions which are often not valid. This can result
in very extreme posterior class probabilities (very near 0 or 1). Discriminative models, such as
logistic regression, are often better calibrated in terms of their probability estimates, although
they also sometimes need adjustment (see e.g., [NMC05]).
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20229.4. Generative vs discriminative classifiers 331
9.4.2 Advantages of generative classifiers
The main advantages of generative classifiers are as follows:
• Easy to fit. Generative classifiers are often very easy to fit. For example, in Section 9.3.2, we
show how to fit a naive Bayes classifier by simple counting and averaging. By contrast, logistic
regression requires solving a convex optimization problem (see Section 10.2.3 for the details), and
neural nets require solving a non-convex optimization problem, both of which are much slower.
• Can easily handle missing input features. Sometimes some of the inputs (components of x)
are not observed. In a generative classifier, there is a simple method for dealing with this, as we
show in Section 1.5.5. However, in a discriminative classifier, there is no principled solution to
this problem, since the model assumes that x is always available to be conditioned on.
• Can fit classes separately. In a generative classifier, we estimate the parameters of each class
conditional density independently (as we show in Section 9.3.2), so we do not have to retrain
the model when we add more classes. In contrast, in discriminative models, all the parameters
interact, so the whole model must be retrained if we add a new class.
• Can handle unlabeled training data. It is easy to use generative models for semi-supervised
learning, in which we combine labeled data Dxy = {(xn, yn)} and unlabeled data, Dx = {xn}.
However, this is harder to do with discriminative models, since there is no uniquely optimal way
to exploit Dx.
• May be more robust to spurious features. A discriminative model p(y|x) may pick up on
features of the input x that can discriminate different values of y in the training set, but which are
not robust and do not generalize beyond the training set. These are called spurious features
(see e.g., [Arj21; Zho+21]). By contrast, a generative model p(x|y) may be better able to capture
the causal mechanisms of the underlying data generating process; such causal models can be more
robust to distribution shift (see e.g., [Sch19; LBS19; LN81]).
9.4.3 Handling missing features
Sometimes we are missing parts of the input x during training and/or testing. In a generative
classifier, we can handle this situation by marginalizing out the missing values. (We assume that
the missingness of a feature is not informative about its potential value.) By contrast, when using
a discriminative model, there is no unique best way to handle missing inputs, as we discuss in
Section 1.5.5.
For example, suppose we are missing the value of x1. We just have to compute
p(y = c|x2:D, θ) ∝ p(y = c|π)p(x2:D|y = c, θ) (9.63)
= p(y = c|π)
X
x1
p(x1, x2:D|y = c, θ) (9.64)
In Gaussian discriminant analysis, we can marginalize out x1 using the equations from Section 3.2.3.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license332 Chapter 9. Linear Discriminant Analysis
If we make the naive Bayes assumption, things are even easier, since we can just ignore the
likelihood term for x1. This follows because
X
x1
p(x1, x2:D|y = c, θ) = "X
x1
p(x1|θ1c)
# Y
D
d=2
p(xd|θdc) = Y
D
d=2
p(xd|θdc) (9.65)
where we exploited the fact that P
x1
p(x1|y = c, θ1c) = 1.
9.5 Exercises
Exercise 9.1 [Derivation of Fisher’s linear discriminant]
Show that the maximum of J(w) = wT SBw
wT SW w
is given by SBw = λSW w
where λ =
wT SBw
wT SW w
. Hint: recall that the derivative of a ratio of two scalars is given by d
dx
f(x)
g(x) =
f
0g−fg0
g2 ,
where f
0 =
d
dx f(x) and g
0 =
d
dx g(x). Also, recall that d
dx
x
T Ax = (A + AT
)x.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210 Logistic Regression
10.1 Introduction
Logistic regression is a widely used discriminative classification model p(y|x; θ), where x ∈ R
D
is a fixed-dimensional input vector, y ∈ {1, . . . , C} is the class label, and θ are the parameters. If
C = 2, this is known as binary logistic regression, and if C > 2, it is known as multinomial
logistic regression, or alternatively, multiclass logistic regression. We give the details below.
10.2 Binary logistic regression
Binary logistic regression corresponds to the following model
p(y|x; θ) = Ber(y|σ(wTx + b)) (10.1)
where σ is the sigmoid function defined in Section 2.4.2, w are the weights, b is the bias, and
θ = (w, b) are all the parameters. In other words,
p(y = 1|x; θ) = σ(a) = 1
1 + e−a
(10.2)
where a = wTx + b is the log-odds, log(
p/1 − p), where p = p(y = 1|x; θ), as explained in Section 2.4.2.
(In ML, the quantity a is usually called the logit or the pre-activation.)
Sometimes we choose to use the labels y˜ ∈ {−1, +1} instead of y ∈ {0, 1}. We can compute the
probability of these alternative labels using
p(˜y|x, θ) = σ(˜ya) (10.3)
since σ(−a) = 1 − σ(a). This slightly more compact notation is widely used in the ML literature.
10.2.1 Linear classifiers
The sigmoid gives the probability that the class label is y = 1. If the loss for misclassifying each class
is the same, then the optimal decision rule is to predict y = 1 iff class 1 is more likely than class 0, as
we explained in Section 5.1.2.2. Thus
f(x) = I(p(y = 1|x) > p(y = 0|x)) = I

log p(y = 1|x)
p(y = 0|x)
> 0

= I(a > 0) (10.4)334 Chapter 10. Logistic Regression
(x, y, z)
(x , y , z ) 0 0 0
w 1
w 2
w 3
w = []
x
z
y
(a)
3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0
Petal length
1.00
1.25
1.50
1.75
2.00
2.25
2.50
Petal width
Not Iris-Virginica
Iris-Virginica
(b)
Figure 10.1: (a) Visualization of a 2d plane in a 3d space with surface normal w going through point
x0 = (x0, y0, z0). See text for details. (b) Visualization of optimal linear decision boundary induced by logistic
regression on a 2-class, 2-feature version of the iris dataset. Generated by code at figures.probml.ai/book1/10.1.
Adapted from Figure 4.24 of [Gér19].
where a = wTx + b.
Thus we can write the prediction function as follows:
f(x; θ) = b + wTx = b +
X
D
d=1
wdxd (10.5)
where wTx = hw, xi is the inner product between the weight vector w and the feature vector x.
This function defines a linear hyperplane, with normal vector w ∈ R
D and an offset b ∈ R from
the origin.
Equation (10.5) can be understood by looking at Figure 10.1a. Here we show a plane in a 3d
feature space going through the point x0 with surface normal w. Points on the surface satisfy
wT(x − x0) = 0. If we define b = −wTx0, we can rewrite this as wTx + b = 0. This plane separates
3d space into two half spaces. This linear plane is known as a decision boundary. If we can
perfectly separate the training examples by such a linear boundary (without making any classification
errors on the training set), we say the data is linearly separable. From Figure 10.1b, we see that
the two-class, two-feature version of the iris dataset is not linearly separable.
In general, there will be uncertainty about the correct class label, so we need to predict a probability
distribution over labels, and not just decide which side of the decision boundary we are on. In
Figure 10.2, we plot p(y = 1|x1, x2; w) = σ(w1x1 + w2x2) for different weight vectors w. The vector
w defines the orientation of the decision boundary, and its magnitude, ||w|| =
qPD
d=1 w2
d
, controls
the steepness of the sigmoid, and hence the confidence of the predictions.
10.2.2 Nonlinear classifiers
We can often make a problem linearly separable by preprocessing the inputs in a suitable way. In
particular, let φ(x) be a transformed version of the input feature vector. For example, suppose we
use φ(x1, x2) = [1, x2
1
, x2
2
], and we let w = [−R2
, 1, 1]. Then wTφ(x) = x
2
1 + x
2
2 − R2
, so the decision
boundary (where f(x) = 0) defines a circle with radius R, as shown in Figure 10.3. The resulting
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210.2. Binary logistic regression 335
4 2 0 2 4
4
2
0
2
4
10
5
0
10 10
5
0
10
0.0
0.5
1.0
W=(-3,-3)
10
5
0
10 10
5
0
10
0.0
0.5
1.0
W=(0,-3)
10
5
0
10 10
5
0
10
0.0
0.5
1.0
W=(3,-3)
10
5
0
10 10
5
0
10
0.0
0.5
1.0
W=(-3,0)
10
5
0
10 10
5
0
10
0.0
0.5
1.0
W=(0,0.5)
10
5
0
10 10
5
0
10
0.0
0.5
1.0
W=(3,0)
10
5
0
10 10
5
0
10
0.0
0.5
1.0
W=(-3,3)
10
5
0
10 10
5
0
10
0.0
0.5
1.0
W=(0,3)
10
5
0
10 10
5
0
10
0.0
0.5
1.0
W=(3,3)
Figure 10.2: Plots of σ(w1x1 + w2x2). Here w = (w1, w2) defines the normal to the decision boundary.
Points to the right of this have σ(wTx) > 0.5, and points to the left have σ(wTx) < 0.5. Adapted from Figure
39.3 of [Mac03]. Generated by code at figures.probml.ai/book1/10.2.
R 2
x1
x2
x1
x2
2
Figure 10.3: Illustration of how we can transform a quadratic decision boundary into a linear one by
transforming the features from x = (x1, x2) to φ(x) = (x
2
1, x2
2). Used with kind permission of Jean-Philippe
Vert.
function f is still linear in the parameters w, which is important for simplifying the learning problem,
as we will see in Section 10.2.3. However, we can gain even more power by learning the parameters
of the feature extractor φ(x) in addition to linear weights w; we discuss how to do this in Part III.
In Figure 10.3, we used a quadratic expansion of the features. We can also use a higher order
polynomial, as in Section 1.2.2.2. In Figure 1.7, we show the effects of using polynomial expansion
up to degree K on a 2d logistic regression problem. As in Figure 1.7, we see that the model becomes
more complex as the number of parameters increases, and eventually results in overfitting. We discuss
ways to reduce overfitting in Section 10.2.7.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license336 Chapter 10. Logistic Regression
10.2.3 Maximum likelihood estimation
In this section, we discuss how to estimate the parameters of a logistic regression model using
maximum likelihood estimation.
10.2.3.1 Objective function
The negative log likelihood (scaled by the dataset size N) is given by the following (we assume the
bias term b is absorbed into the weight vector w):
NLL(w) = −
1
N
log p(D|w) = −
1
N
log Y
N
n=1
Ber(yn|µn) (10.6)
= −
1
N
X
N
n=1
log[µ
yn
n × (1 − µn)
1−yn ] (10.7)
= −
1
N
X
N
n=1
[yn log µn + (1 − yn) log(1 − µn)] (10.8)
=
1
N
X
N
n=1
H(yn, µn) (10.9)
where µn = σ(an) is the probability of class 1, an = wTxn is the logit, and H(yn, µn) is the binary
cross entropy defined by
H(p, q) = − [p log q + (1 − p) log(1 − q)] (10.10)
If we use y˜n ∈ {−1, +1} instead of yn ∈ {0, 1}, then we can rewrite this as follows:
NLL(w) = −
1
N
X
N
n=1
[I(˜yn = 1) log(σ(an)) + I(˜yn = −1) log(σ(−an))] (10.11)
= −
1
N
X
N
n=1
log(σ(˜ynan)) (10.12)
=
1
N
X
N
n=1
log(1 + exp(−y˜nan)) (10.13)
However, in this book, we will mostly use the yn ∈ {0, 1} notation, since it is easier to generalize to
the multiclass case (Section 10.3), and makes the connection with cross-entropy easier to see.
10.2.3.2 Optimizing the objective
To find the MLE, we must solve
∇wNLL(w) = g(w) = 0 (10.14)
We can use any gradient-based optimization algorithm to solve this, such as those we discuss in
Chapter 8. We give a specific example in Section 10.2.4. But first we must derive the gradient, as we
explain below.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210.2. Binary logistic regression 337
(a) (b)
(c) (d)
Figure 10.4: Polynomial feature expansion applied to a two-class, two-dimensional logistic regression problem.
(a) Degree K = 1. (b) Degree K = 2. (c) Degree K = 4. (d) Train and test error vs degree. Generated by
code at figures.probml.ai/book1/10.4.
10.2.3.3 Deriving the gradient
Although we can use automatic differentiation methods (Section 13.3) to compute the gradient of
the NLL, it is also easy to do explicitly, as we show below. Fortunately the resulting equations will
turn out to have a simple and intuitive interpretation, which can be used to derive other methods, as
we will see.
To start, note that
dµn
dan
= σ(an)(1 − σ(an)) (10.15)
where an = wTxn and µn = σ(an). Hence by the chain rule (and the rules of vector calculus,
discussed in Section 7.8) we have
∂
∂wd
µn =
∂
∂wd
σ(wTxn) = ∂
∂an
σ(an)
∂an
∂wd
= µn(1 − µn)xnd (10.16)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license338 Chapter 10. Logistic Regression
The gradient for the bias term can be derived in the same way, by using the input xn0 = 1 in the
above equation. However, we will ignore the bias term for simplicity. Hence
∇w log(µn) = 1
µn
∇wµn = (1 − µn)xn (10.17)
Similarly,
∇w log(1 − µn) = −µn(1 − µn)xn
1 − µn
= −µnxn (10.18)
Thus the gradient vector of the NLL is given by
∇wNLL(w) = −
1
N
X
N
n=1
[yn(1 − µn)xn − (1 − yn)µnxn] (10.19)
= −
1
N
X
N
n=1
[ynxn − ynxnµn − xnµn + ynxnµn)] (10.20)
=
1
N
X
N
n=1
(µn − yn)xn (10.21)
If we interpret en = µn − yn as an error signal, we can see that the gradient weights each input xn
by its error, and then averages the result. Note that we can rewrite the gradient in matrix form as
follows:
∇wNLL(w) = 1
N
(1
T
N (diag(µ − y)X))T
(10.22)
10.2.3.4 Deriving the Hessian
Gradient-based optimizers will find a stationary point where g(w) = 0. This could either be a global
optimum or a local optimum. To be sure the stationary point is the global optimum, we must show
that the objective is convex, for reasons we explain in Section 8.1.1.1. Intuitvely this means that
the NLL has a bowl shape, with a unique lowest point, which is indeed the case, as illustrated in
Figure 10.5b.
More formally, we must prove that the Hessian is positive semi-definite, which we now do. (See
Chapter 7 for relevant background information on linear algebra.) One can show that the Hessian is
given by
H(w) = ∇w∇T
wNLL(w) = 1
N
X
N
n=1
(µn(1 − µn)xn)x
T
n =
1
N
XTSX (10.23)
where
S , diag(µ1(1 − µ1), . . . , µN (1 − µN )) (10.24)
We see that H is positive definite, since for any nonzero vector v, we have
v
TXTSXv = (v
TXTS
1
2 )(S
1
2 Xv) = ||v
TXTS
1
2 ||2
2 > 0 (10.25)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210.2. Binary logistic regression 339
−7.5 −5.0 −2.5 0.0 2.5 5.0 7.5
w
−10
−5
0
5
10
b
Loss function surface
0.0
2.4
4.8
7.2
9.6
12.0
14.4
16.8
NLL
(a)
−7.5−5.0−2.5
0.0
2.5
5.0
7.5 −15
−10−5
0
5
10
15
2
4
6
8
10
12
14
16
(b)
Figure 10.5: NLL loss surface for binary logistic regression applied to Iris dataset with 1 feature and 1 bias
term. The goal is to minimize the function. Generated by code at figures.probml.ai/book1/10.5.
This follows since µn > 0 for all n, because of the use of the sigmoid function. Consequently the
NLL is strictly convex. However, in practice, values of µn which are close to 0 or 1 might cause
the Hessian to be close to singular. We can avoid this by using `2 regularization, as we discuss in
Section 10.2.7.
10.2.4 Stochastic gradient descent
Our goal is to solve the following optimization problem
wˆ , argmin
w
L(w) (10.26)
where L(w) is the loss function, in this case the negative log likelihood:
NLL(w) = −
1
N
X
N
n=1
[yn log µn + (1 − yn) log(1 − µn)] (10.27)
where µn = σ(an) is the probability of class 1, and an = wTxn is the log odds.
There are many algorithms we could use to solve Equation (10.26), as we discuss in Chapter 8.
Perhaps the simplest is to use stochastic gradient descent (Section 8.4). If we use a minibatch of size
1, then we get the following simple update equation:
wt+1 = wt − ηt∇wNLL(wt) = wt − ηt(µn − yn)xn (10.28)
where we replaced the average over all N examples in the gradient of Equation (10.21) with a single
stochastically chosen sample n. (The index n changes with t.)
Since we know the objective is convex (see Section 10.2.3.4), then one can show that this procedure
will converge to the global optimum, provided we decay the learning rate at the appropriate rate (see
Section 8.4.3). We can improve the convergence speed using variance reduction techniques such as
SAGA (Section 8.4.5.2).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license340 Chapter 10. Logistic Regression
10.2.5 Perceptron algorithm
A perceptron, first introduced in [Ros58], is a deterministic binary classifier of the following form:
f(xn; θ) = I
￾
wTxn + b > 0

(10.29)
This can be seen to be a limiting case of a binary logistic regression classifier, in which the sigmoid
function σ(a) is replaced by the Heaviside step function H(a) , I(a > 0). See Figure 2.10 for a
comparison of these two functions.
Since the Heaviside function is not differentiable, we cannot use gradient-based optimization
methods to fit this model. However, Rosenblatt proposed the perceptron learning algorithm
instead. The basic idea is to start with random weights, and then iteratively update them whenever
the model makes a prediction mistake. More precisely, we update the weights using
wt+1 = wt − ηt(ˆyn − yn)xn (10.30)
where (xn, yn) is the labeled example sampled at iteration t, and ηt is the learning rate or step
size. (We can set the step size to 1, since the magnitude of the weights does not affect the decision
boundary.) See code.probml.ai/book1/perceptron_demo_2d for a simple implementation of this
algorithm.
The perceptron update rule in Equation (10.30) has an intuitive interpretation: if the prediction is
correct, no change is made, otherwise we move the weights in a direction so as to make the correct
answer more likely. More precisely, if yn = 1 and yˆn = 0, we have wt+1 = wt + xn, and if yn = 0
and yˆn = 1, we have wt+1 = wt − xn.
By comparing Equation (10.30) to Equation (10.28), we see that the perceptron update rule is
equivalent to the SGD update rule for binary logistic regression using the approximation where we
replace the soft probabilities µn = p(yn = 1|xn) with hard labels yˆn = f(xn). The advantage of the
perceptron method is that we don’t need to compute probabilities, which can be useful when the
label space is very large. The disadvantage is that the method will only converge when the data is
linearly separable [Nov62], whereas SGD for minimizing the NLL for logistic regression will always
converge to the globally optimal MLE, even if the data is not linearly separable.
In Section 13.2, we will generalize perceptrons to nonlinear functions, thus significantly enhancing
their usefulness.
10.2.6 Iteratively reweighted least squares
Gradient descent is a first order optimization method, which means it only uses first order gradients
to navigate through the loss landscape. This can be slow, especially when some directions of space
point steeply downhill, whereas other have a shallower gradient, as is the case in Figure 10.5a. In
such problems, it can be much faster to use a second order optimization method, that takes the
curvature of the space into account.
We discuss such methods in more detail in Section 8.3. Here we just consider a simple second order
method that works well for logistic regression. We focus on the full batch setting (so we assume N
is small), since it is harder to make second order methods work in the stochastic setting (see e.g.,
[Byr+16; Liu+18b] for some methods).
The classic second-order method is Newton’s method. This consists of updates of the form
wt+1 = wt − ηtH−1
t gt (10.31)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20210.2. Binary logistic regression 341
where
Ht , ∇2L(w)|wt = ∇2L(wt) = H(wt) (10.32)
is assumed to be positive-definite to ensure the update is well-defined. If the Hessian is exact, we can
set the step size to ηt = 1.
We now apply this method to logistic regression. Recall from Section 10.2.3.3 that the gradient
and Hessian are given by
∇wNLL(w) = 1
N
X
N
n=1
(µn − yn)xn (10.33)
H =
1
N
XTSX (10.34)
S , diag(µ1(1 − µ1), . . . , µN (1 − µN )) (10.35)
Hence the Newton update has the form
wt+1 = wt − H−1
gt (10.36)
= wt + (XTStX)
−1XT
(y − µt) (10.37)
= (XTStX)
−1

(XTStX)wt + XT
(y − µt)

(10.38)
= (XTStX)
−1XT
[StXwt + y − µt] (10.39)
= (XTStX)
−1XTStzt (10.40)
where we have defined the working response as
zt , Xwt + S
−1
t
(y − µt) (10.41)
and St = diag(µt,n(1 − µt,n)). Since St is a diagonal matrix, we can rewrite the targets in component
form as follows:
zt,n = wT
t xn +
yn − µt,n
µt,n(1 − µt,n)
(10.42)
Equation (10.40) is an example of a weighted least squares problem (Section 11.2.2.4), which is a
minimizer of
X
N
n=1
St,n(zt,n − wT
t xn)
2
(10.43)
The overall method is therefore known as the iteratively reweighted least squares (IRLS)
algorithm, since at each iteration we solve a weighted least squares problem, where the weight matrix
St changes at each iteration. See Algorithm 2 for some pseudocode.
Note that Fisher scoring is the same as IRLS except we replace the Hessian of the actual
log-likelihood with its expectation, i.e., we use the Fisher information matrix (Section 4.7.2) instead
of H. Since the Fisher information matrix is independent of the data, it can be precomputed, unlike
the Hessian, which must be reevaluated at every iteration. This can be faster for problems with
many parameters.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license342 Chapter 10. Logistic Regression
Algorithm 2: Iteratively reweighted least squares (IRLS)
1 w = 0;
2 repeat
3 for n = 1 : N do
4 an = wTxn;
5 µn = σ(an);
6 sn = µn(1 − µn) ;
7 zn = an +
yn−µn
sn
;
8 S = diag(s1:N ) ;
9 w = (XTSX)
−1XTSz;
10 until converged;
10.2.7 MAP estimation
In Figure 10.4, we saw how logistic regression can overfit when there are too many parameters
compared to training examples. This is a consequence of the ability of maximum likelihood to find
weights that force the decision boundary to “wiggle” in just the right way so as to curve around the
examples. To get this behavior, the weights often need to be set to large values. For example, in
Figure 10.4, when we use degree K = 1, we find that the MLE for the two input weights (ignoring
the bias) is
wˆ = [0.51291712, 0.11866937] (10.44)
When we use degree K = 2, we get
wˆ = [2.27510513, 0.05970325, 11.84198867, 15.40355969, 2.51242311] (10.45)
And when K = 4, we get
wˆ = [−3.07813766, · · · , −59.03196044, 51.77152431, 10.25054164] (10.46)
One way to reduce such overfitting is to prevent the weights from becoming so large. We can do
this by using a zero-mean Gaussian prior, p(w) = N (w|0, CI), and then using MAP estimation, as
we discussed in Section 4.5.3. The new training objective becomes
L(w) = NLL(w) + λ||w||2
2
(10.47)
where ||w||2
2 =
PD
d=1 w
2
d
and λ = 1/C. This is called `2 regularization or weight decay. The
larger the value of λ, the more the parameters are penalized for being “large” (deviating from the
zero-mean prior), and thus the less flexible the model. See Figure 10.6 for an illustration.
We can compute the MAP estimate by slightly modifying the input to the above gradient-based
optimization algorithms. The gradient and Hessian of the penalized negative log likelihood have the
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210.2. Binary logistic regression 343
(a) (b)
(c)
10
0 10
1 10
2 10
3 10
4 10
5
Inverse regularization
0.15
0.20
0.25
0.30
0.35
0.40
error rate
train
test
(d)
Figure 10.6: Weight decay with variance C applied to two-class, two-dimensional logistic regression problem
with a degree 4 polynomial. (a) C = 1. (b) C = 316. (c) C = 100, 000. (d) Train and test error vs C.
Generated by code at figures.probml.ai/book1/10.6.
following forms:
PNLL(w) = NLL(w) + λwTw (10.48)
∇wPNLL(w) = g(w) + 2λw (10.49)
∇2
wPNLL(w) = H(w) + 2λI (10.50)
where g(w) is the gradient and H(w) is the Hessian of the unpenalized NLL.
For an interesting exercise related to `2 regularized logistic regression, see Exercise 10.2.
10.2.8 Standardization
In Section 10.2.7, we use an isotropic prior N (w|0, λ−1
I) to prevent overfitting. This implicitly
encodes the assumption that we expect all weights to be similar in magnitude, which in turn encodes
the assumption we expect all input features to be similar in magnitude. However, in many datasets,
input features are on different scales. In such cases, it is common to standardize the data, to ensure
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license344 Chapter 10. Logistic Regression
each feature has mean 0 and variance 1. We can do this by subtracting the mean and dividing by
the standard deviation of each feature, as follows:
standardize(xnd) = xnd − µˆd
σˆd
(10.51)
µˆd =
1
N
X
N
n=1
xnd (10.52)
σˆ
2
d =
1
N
X
N
n=1
(xnd − µˆd)
2
(10.53)
An alternative is to use min-max scaling, in which we rescale the inputs so they lie in the interval
[0, 1]. Both methods ensure the features are comparable in magnitude, which can help with model
fitting and inference, even if we don’t use MAP estimation. (See Section 11.7.5 for a discussion of
this point.)
10.3 Multinomial logistic regression
Multinomial logistic regression is a discriminative classification model of the following form:
p(y|x; θ) = Cat(y|S(Wx + b)) (10.54)
where x ∈ R
D is the input vector, y ∈ {1, . . . , C} is the class label, S() is the softmax function
(Section 2.5.2), W is a C × D weight matrix, b is C-dimensional bias vector, θ = (W, b) are all the
parameters. We will henceforth ignore the bias term b; we assume we prepend each x with a 1, and
add b to the first column of W. Thus θ = W.
If we let a = Wx be the C-dimensional vector of logits, then we can rewrite the above as follows:
p(y = c|x; θ) = e
ac
PC
c
0=1 e
ac0
(10.55)
Because of the normalization condition PC
c=1 p(yn = c|xn; θ) = 1, we can set wC = 0. (For example,
in binary logistic regression, where C = 2, we only learn a single weight vector.) Therefore the
parameters θ correspond to a weight matrix W of size (C − 1) × D, where xn ∈ R
D.
Note that this model assumes the labels are mutually exclusive, i.e., there is only one true label. For
some applications (e.g., image tagging), we want to predict one or more labels for an input; in this
case, the output space is the set of subsets of {1, . . . , C}. This is called multi-label classification,
as opposed to multi-class classification. This can be viewed as a bit vector, Y = {0, 1}
C , where
the c’th output is set to 1 if the c’th tag is present. We can tackle this using a modified version of
binary logistic regression with multiple outputs:
p(y|x; θ) = Y
C
c=1
Ber(yc|σ(wT
cx)) (10.56)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210.3. Multinomial logistic regression 345
(a) (b)
Figure 10.7: Example of 3-class logistic regression with 2d inputs. (a) Original features. (b) Quadratic
features. Generated by code at figures.probml.ai/book1/10.7.
10.3.1 Linear and nonlinear classifiers
Logistic regression computes linear decision boundaries in the input space, as shown in Figure 10.7(a)
for the case where x ∈ R
2 and we have C = 3 classes. However, we can always transform the inputs
in some way to create nonlinear boundaries. For example, suppose we replace x = (x1, x2) by
φ(x) = [1, x1, x2, x2
1
, x2
2
, x1x2] (10.57)
This lets us create quadratic decision boundaries, as illustrated in Figure 10.7(b).
10.3.2 Maximum likelihood estimation
In this section, we discuss how to compute the maximum likelihood estimate (MLE) by minimizing
the negative log likelihood (NLL).
10.3.2.1 Objective
The NLL is given by
NLL(θ) = −
1
N
log Y
N
n=1
Y
C
c=1
µ
ync
nc = −
1
N
X
N
n=1
X
C
c=1
ync log µnc =
1
N
X
N
n=1
H(yn, µn) (10.58)
where µnc = p(ync = 1|xn, θ) = S(f(xn; θ))c, yn is the one-hot encoding of the label (so ync =
I(yn = c)), and H(yn, µn) is the cross-entropy:
H(p, q) = −
X
C
c=1
pc log qc (10.59)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license346 Chapter 10. Logistic Regression
10.3.2.2 Optimizing the objective
To find the optimum, we need to solve ∇wNLL(w) = 0, where w is a vectorized version of the weight
matrix W, and where we are ignoring the bias term for notational simplicity. We can find such a
stationary point using any gradient-based optimizer; we give some examples below. But first we
derive the gradient and Hessian, and then prove that the objective is convex.
10.3.2.3 Deriving the gradient
To derive the gradient of the NLL, we need to use the Jacobian of the softmax function, which is as
follows (see Exercise 10.1 for the proof):
∂µc
∂aj
= µc(δcj − µj ) (10.60)
where δcj = I(c = j). For example, if we have 3 classes, the Jacobian matrix is given by

∂µc
∂aj

cj
=


µ1(1 − µ1) −µ1µ2 −µ1µ3
−µ2µ1 µ2(1 − µ2) −µ2µ3
−µ3µ1 −µ3µ2 µ3(1 − µ3)

 (10.61)
In matrix form, this can be written as
∂µ
∂a
= (µ1
T
)  (I − 1µ
T
) (10.62)
where  is elementwise product, µ1
T copies µ across each column, and 1µ
T copies µ across each
row.
We now derive the gradient of the NLL for a single example, indexed by n. To do this, we flatten
the D × C weight matrix into a vector w of size CD (or (C − 1)D if we freeze one of the classes to
have zero weight) by concatenating the rows, and then transposing into a column vector. We use wj
to denote the vector of weights associated with class j. The gradient wrt this vector is giving by the
following (where we use the Kronecker delta notation, δjc, which equals 1 if j = c and 0 otherwise):
∇wjNLLn =
X
c
∂NLLn
∂µnc
∂µnc
∂anj
∂anj
∂wj
(10.63)
= −
X
c
ync
µnc
µnc(δjc − µnj )xn (10.64)
=
X
c
ync(µnj − δjc)xn (10.65)
= (X
c
ync)µnjxn −
X
c
δjcynjxn (10.66)
= (µnj − ynj )xn (10.67)
We can repeat this computation for each class, to get the full gradient vector. The gradient of the
overall NLL is obtained by summing over examples, to give the D × C matrix
g(w) = 1
N
X
N
n=1
xn(µn − yn)
T
(10.68)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210.3. Multinomial logistic regression 347
This has the same form as in the binary logistic regression case, namely an error term times the
input.
10.3.2.4 Deriving the Hessian
Exercise 10.1 asks you to show that the Hessian of the NLL for multinomial logistic regression is
given by
H(w) = 1
N
X
N
n=1
(diag(µn) − µnµ
T
n
) ⊗ (xnx
T
n
) (10.69)
where A ⊗ B is the Kronecker product (Section 7.2.5). In other words, the block c, c0
submatrix is
given by
Hc,c0 (w) = 1
N
X
n
µnc(δc,c0 − µn,c0 )xnx
T
n
(10.70)
For example, if we have 3 features and 2 classes, this becomes
H(w) = 1
N
X
n

µn1 − µ
2
n1 −µn1µn2
−µn1µn2 µn2 − µ
2
n2

⊗


xn1xn1 xn1xn2 xn1xn3
xn2xn1 xn2xn2 xn2xn3
xn3xn1 xn3xn2 xn3xn3

 (10.71)
=
1
N
X
n

(µn1 − µ
2
n1
)Xn −µn1µn2Xn
−µn1µn2Xn (µn2 − µ
2
n2
)Xn

(10.72)
where Xn = xnx
T
n
. Exercise 10.1 also asks you to show that this is a positive definite matrix, so the
objective is convex.
10.3.3 Gradient-based optimization
It is straightforward to use the gradient in Section 10.3.2.3 to derive the SGD algorithm. Similarly,
we can use the Hessian in Section 10.3.2.4 to derive a second-order optimization method. However,
computing the Hessian can be expensive, so it is common to approximate it using quasi-Newton
methods, such as limited memory BFGS. (BFGS stands for Broyden, Fletcher, Goldfarb and Shanno.)
See Section 8.3.2 for details. Another approach, which is similar to IRLS, is described in Section 10.3.4.
All of these methods rely on computing the gradient of the log-likelihood, which in turn requires
computing normalized probabilities, which can be computed from the logits vector a = Wx using
p(y = c|x) = exp(ac − lse(a)) (10.73)
where lse is the log-sum-exp function defined in Section 2.5.4. For this reason, many software libraries
define a version of the cross-entropy loss that takes unnormalized logits as input.
10.3.4 Bound optimization
In this section, we consider an approach for fitting logistic regression using a class of algorithms
known as bound optimization, which we describe in Section 8.7. The basic idea is to iteratively
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license348 Chapter 10. Logistic Regression
construct a lower bound on the function you want to maximize, and then to update the bound, so it
“pushes up” on the true function. Optimizing the bound is often easier than updating the function
directly.
If LL(θ) is a concave function we want to maximize, then one way to obtain a valid lower bound
is to use a bound on its Hessian, i.e., to find a negative definite matrix B such that H(θ)  B. In
this case, one can show that
LL(θ) ≥ LL(θ
t
) + (θ − θ
t
)
T
g(θ
t
) + 1
2
(θ − θ
t
)
TB(θ − θ
t
) (10.74)
where g(θ
t
) = ∇LL(θ
t
). Defining Q(θ, θ
t
) as the right-hand-side of Equation (10.74), the update
becomes
θ
t+1 = θ
t − B
−1
g(θ
t
) (10.75)
This is similar to a Newton update, except we use B, which is a fixed matrix, rather than H(θ
t
),
which changes at each iteration. This can give us some of the advantages of second order methods at
lower computational cost.
Let us now apply this to logistic regression, following [Kri+05], Let µn(w) = [p(yn = 1|xn, w), . . . , p(yn =
C|xn, w)] and yn = [I(yn = 1), . . . ,I(yn = C)]. We want to maximize the log-likelihood, which is
as follows:
LL(w) = X
N
n=1 "X
C
c=1
yncwT
cxn − logX
C
c=1
exp(wT
cxn)
#
(10.76)
The gradient is given by the following (see Section 10.3.2.3 for details of the derivation):
g(w) = X
N
n=1
(yn − µn(w)) ⊗ xn (10.77)
where ⊗ denotes kronecker product (which, in this case, is just outer product of the two vectors).
The Hessian is given by the following (see Section 10.3.2.4 for details of the derivation):
H(w) = −
X
N
n=1
(diag(µn(w)) − µn(w)µn(w)
T
) ⊗(xnx
T
n
) (10.78)
We can construct a lower bound on the Hessian, as shown in [Boh92]:
H(w)  −
1
2
[I − 11T
/C] ⊗
 X
N
n=1
xnx
T
n
!
, B (10.79)
where I is a C-dimensional identity matrix, and 1 is a C-dimensional vector of all 1s.1
In the binary
case, this becomes
H(w)  −
1
2

1 −
1
2
 X
N
n=1
xnx
T
n
!
= −
1
4
XTX (10.80)
1. If we enforce that wC = 0, we can use C − 1 dimensions for these vectors / matrices.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210.3. Multinomial logistic regression 349
This follows since µn ≤ 0.5 so −(µn − µ
2
n
) ≥ −0.25.
We can use this lower bound to construct an MM algorithm to find the MLE. The update becomes
wt+1 = wt − B
−1
g(wt
) (10.81)
This iteration can be faster than IRLS (Section 10.2.6) since we can precompute B−1
in time
independent of N, rather than having to invert the Hessian at each iteration. For example, let us
consider the binary case, so g
t = ∇LL(wt
) = XT(y − µ
t
), where µ
t = [pn(wt
),(1 − pn(wt
))]N
n=1.
The update becomes
wt+1 = wt − 4(XTX)
−1
g
t
(10.82)
Compare this to Equation (10.37), which has the following form:
wt+1 = wt − H−1
g(wt
) = wt − (XTS
tX)
−1
g
t
(10.83)
where S
t = diag(µ
t (1 − µ
t
)). We see that Equation (10.82) is faster to compute, since we can
precompute the constant matrix (XTX)
−1
.
10.3.5 MAP estimation
In Section 10.2.7 we discussed the benefits of `2 regularization for binary logistic regression. These
benefits hold also in the multi-class case. However, there is also an additional, and surprising, benefit
to do with identifiability of the parameters, as pointed out in [HTF09, Ex.18.3]. (We say that the
parameters are identifiable if there is a unique value that maximizes the likelihood; equivalently, we
require that the NLL be strictly convex.)
To see why identifiability is an issue, recall that multiclass logistic regression has the form
p(y = c|x,W) = exp(wT
c x)
PC
k=1 exp(wT
k x)
(10.84)
where W is a C × D weight matrix. We can arbitrarily define wc = 0 for one of the classes, say
c = C, since p(y = C|x,W) = 1 −
PC−1
c=1 p(y = c|x, w). In this case, the model has the form
p(y = c|x,W) = exp(wT
c x)
1 + PC−1
k=1 exp(wT
k x)
(10.85)
If we don’t “clamp” one of the vectors to some constant value, the parameters will be unidentifiable.
However, suppose we don’t clamp wc = 0, so we are using Equation 10.84, but we add `2
regularization by optimizing
PNLL(W) = −
X
N
n=1
log p(yn|xn,W) + λ
X
C
c=1
||wc||2
2
(10.86)
where we have absorbed the 1/N term into λ. At the optimum we have PC
c=1 wˆcj = 0 for j = 1 : D,
so the weights automatically satisfy a sum-to-zero constraint, thus making them uniquely identifiable.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license350 Chapter 10. Logistic Regression
To see why, note that at the optimum we have
∇NLL(w) + 2λw = 0 (10.87)
X
n
(yn − µn) ⊗ xn = λw (10.88)
Hence for any feature dimension j we have
λ
X
c
wcj =
X
n
X
c
(ync − µnc)xnj =
X
n
(
X
c
ync −
X
c
µnc)xnj =
X
n
(1 − 1)xnj = 0 (10.89)
Thus if λ > 0 we have P
c wˆcj = 0, so the weights will sum to zero across classes for each feature
dimension.
10.3.6 Maximum entropy classifiers
Recall that the multinomial logistic regression model can be written as
p(y = c|x,W) = exp(wT
cx)
Z(w, x)
=
exp(wT
cx)
PC
c
0=1 exp(wT
c
0x)
(10.90)
where Z(w, x) = P
c
exp(wT
cx) is the partition function (normalization constant). This uses the
same features, but a different weight vector, for every class. There is a slight extension of this model
that allows us to use features that are class-dependent. This model can be written as
p(y = c|x, w) = 1
Z(w, x)
exp(wTφ(x, c)) (10.91)
where φ(x, c) is the feature vector for class c. This is called a maximum entropy classifer, or
maxent classifier for short. (The origin of this term is explained in Section 3.4.4.)
Maxent classifiers include multinomial logistic regression as a special case. To see this let w =
[w1, . . . , wC ], and define the feature vector as follows:
φ(x, c) = [0, . . . , x, . . . , 0] (10.92)
where x is embedded in the c’th block, and the remaining blocks are zero. In this case, wTφ(x, c) =
wT
cx, so we recover multinomial logistic regression.
Maxent classifiers are very widely used in the field of natural language processing. For example,
consider the problem of semantic role labeling, where we classify a word x into a semantic role y,
such as person, place or thing. We might define (binary) features such as the following:
φ1(x, y) = I(y = person ∧ x occurs after “Mr.” or “Mrs”) (10.93)
φ2(x, y) = I(y = person ∧ x is in whitelist of common names) (10.94)
φ3(x, y) = I(y = place ∧ x is in Google maps) (10.95)
.
.
.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210.3. Multinomial logistic regression 351
Mammals
Dog
Golden
Retriever
German
Shepherd Tabby Siamese
Cat
Birds ...
...
... ...
Figure 10.8: A simple example of a label hierarchy. Nodes within the same ellipse have a mutual exclusion
relationship between them.
We see that the features we use depend on the label.
There are two main ways of creating these features. The first is to manually specify many possibly
useful features using various templates, and then use a feature selection algorithm, such as the group
lasso method of Section 11.4.7. The second is to incrementally add features to the model, using a
heuristic feature generation method.
10.3.7 Hierarchical classification
Sometimes the set of possible labels can be structured into a hierarchy or taxonomy. For example,
we might want to predict what kind of an animal is in an image: it could be a dog or a cat; if it is a
dog, it could be a golden retriever or a German shepherd, etc. Intuitively, it makes sense to try to
predict the most precise label for which we are confident [Den+12], that is, the system should “hedge
its bets”.
One simple way to achieve this, proposed in [RF17], is as follows. First, create a model with
a binary output label for every possible node in the tree. Before training the model, we will use
label smearing, so that a label is propagated to all of its parents (hypernyms). For example, if
an image is labeled “golden retriever”, we will also label it “dog”. If we train a multi-label classifier
(which produces a vector p(y|x) of binary labels) on such smeared data, it will perform hierarchical
classification, predicting a set of labels at different levels of abstraction.
However, this method could predict “golden retriever”, “cat” and “bird” all with probability 1.0,
since the model does not capture the fact that some labels are mutually exclusive. To prevent this,
we can add a mutual exclusion constraint between all label nodes which are siblings, as shown in
Figure 10.8. For example, this model enforces that p(mammal|x) + p(bird|x) = 1, since these two
labels are children of the root node. We can further partition the mammal probability into dogs and
cats, so we have p(dog|x) + p(cat|x) = p(mammal|x).
[Den+14; Din+15] generalize the above method by using a conditional graphical model where
the graph structure can be more complex than a tree. In addition, they allow for soft constraints
between labels, in addition to hard constraints.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license352 Chapter 10. Logistic Regression
“What”
p(w | C)
“I’m”
0.11 0.28 0.03 0.15 0.09 0.17 0.05 0.11
“Horse” “Why”
Context C
“Huh” “No” “Yes” “Sup”
(a)
“What”
p(w | C)
“I’m”
0.28 0.72 0.17 0.83 0.37
0.32
0.57 0.43
0.68 0.62 0.38
0.63 0.31 0.69
“Horse” “Why”
Context C
“Huh” “No” “Yes” “Sup”
(b)
Figure 10.9: A flat and hierarchical softmax model p(w|C), where C are the input features (context) and w is
the output label (word). Adapted from https: // www. quora. com/ What-is-hierarchical-softmax .
10.3.8 Handling large numbers of classes
In this section, we discuss some issues that arise when there are a large number of potential labels,
e.g., if the labels correspond to words from a language.
10.3.8.1 Hierarchical softmax
In regular softmax classifiers, computing the normalization constant, which is needed to compute
the gradient of the log likelihood, takes O(C) time, which can become the bottleneck if C is large.
However, if we structure the labels as a tree, we can compute the probability of any label in O(log C)
time, by multiplying the probabilities of each edge on the path from the root to the leaf. For example,
consider the tree in Figure 10.9. We have
p(y = I’m|C) = 0.57 × 0.68 × 0.72 = 0.28 (10.96)
Thus we replace the “flat” output softmax with a tree-structured sequence of binary classifiers. This
is called hierarchical softmax [Goo01; MB05].
A good way to structure such a tree is to use Huffman encoding, where the most frequent labels
are placed near the top of the tree, as suggested in [Mik+13a]. (For a different appproach, based on
clustering the most common labels together, see [Gra+17]. And for yet another approach, based on
sampling labels, see [Tit16].)
10.3.8.2 Class imbalance and the long tail
Another issue that often arises when there are a large number of classes is that for most classes, we
may have very few examples. More precisely, if Nc is the number of examples of class c, then the
empirical distribution p(N1, . . . , NC ) may have a long tail. The result is an extreme form of class
imbalance (see e.g., [ASR15]). Since the rare classes will have a smaller effect on the overall loss
than the common classes, the model may “focus its attention” on the common classes.
One method that can help is to set the bias terms b such that S(b)c = Nc/N; such a model will
match the empirical label prior even when using weights of w = 0. As the weights are adjusted, the
model can learn input-dependent deviations from this prior.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210.4. Robust logistic regression * 353
Another common approach is to resample the data to make it more balanced, before (or during)
training. In particular, suppose we sample a datapoint from class c with probability
pc =
Nq
c PC
i N
q
i
(10.97)
If we set q = 1, we recover standard instance-balanced sampling, where pc ∝ Nc; the common
classes will be sampled more than rare classes. If we set q = 0, we recover class-balanced sampling,
where pc = 1/C; this can be thought of as first sampling a class uniformly at random, and then
sampling an instance of this class. Finally, we can consider other options, such as q = 0.5, which is
known as square-root sampling [Mah+18].
Yet another method that is simple and can easily handle the long tail is to use the nearest class
mean classifier. This has the form
f(x) = argmin
c
||x − µc||2
2
(10.98)
where µc =
1
Nc
P
n:yn=c xn is the mean of the features belonging to class c. This induces a softmax
posterior, as we discussed in Section 9.2.5. We can get much better results if we first use a neural
network (see Part III) to learn good features, by training a DNN classifier with cross-entropy loss
on the original unbalanced data. We then replace x with φ(x) in Equation (10.98). This simple
approach can give very good performance on long-tailed distributions [Kan+20].
10.4 Robust logistic regression *
Sometimes we have outliers in our data, which are often due to labeling errors, also called label
noise. To prevent the model from being adversely affected by such contamination, we will use
robust logistic regression. In this section, we discuss some approaches to this problem. (Note
that the methods can also be applied to DNNs. For a more thorough survey of label noise, and how
it impacts deep learning, see [Han+20].)
10.4.1 Mixture model for the likelihood
One of the simplest ways to define a robust logistic regression model is to modify the likelihood so
that it predicts that each output label y is generated uniformly at random with probability π, and
otherwise is generated using the usual conditional model. In the binary case, this becomes
p(y|x) = πBer(y|0.5) + (1 − π)Ber(y|σ(wTx)) (10.99)
This approach, of using a mixture model for the observation model to make it robust, can be applied
to many different models (e.g., DNNs).
We can fit this model using standard methods, such as SGD or Bayesian inference methods such
as MCMC. For example, let us create a “contaminated” version of the 1d, two-class Iris dataset that
we discussed in Section 4.6.7.2. We will add 6 examples of class 1 (Versicolor) with abnormally
low sepal length. In Figure 10.10a, we show the results of fitting a standard (Bayesian) logistic
regression model to this dataset. In Figure 10.10b, we show the results of fitting the above robust
model. In the latter case, we see that the decision boundary is similar to the one we inferred from
non-contaminated data, as shown in Figure 4.20b. We also see that the posterior uncertainty about
the decision boundary’s location is smaller than when using a non-robust model.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license354 Chapter 10. Logistic Regression
3.9 4.4 4.9 5.4 5.9 6.4 6.9
sepal_length
0.0
0.2
0.4
0.6
0.8
1.0
p(y=1)
(a)
3.9 4.4 4.9 5.4 5.9 6.4 6.9
sepal_length
0.0
0.2
0.4
0.6
0.8
1.0
p(y=1)
(b)
Figure 10.10: (a) Logistic regression on some data with outliers (denoted by x). Training points have been
(vertically) jittered to avoid overlapping too much. Vertical line is the decision boundary, and its posterior
credible interval. (b) Same as (a) but using robust model, with a mixture likelihood. Adapted from Figure 4.13
of [Mar18]. Generated by code at figures.probml.ai/book1/10.10.
10.4.2 Bi-tempered loss
In this section, we present an approach to robust logistic regression proposed in [Ami+19].
The first observation is that examples that are far from the decision boundary, but mislabeled, will
have undue adverse affect on the model if the loss function is convex [LS10]. This can be overcome by
replacing the usual cross entropy loss with a “tempered” version, that uses a temperature parameter
0 ≤ t1 < 1 to ensure the loss from outliers is bounded. In particular, consider the standard relative
entropy loss function:
L(y, yˆ) = H(y, yˆ) = X
c
yc log ˆyc (10.100)
where y is the true label distribution (often one-hot) and yˆ is the predicted distribution. We define
the tempered cross entropy loss as follows:
L(y, yˆ) = X
c

yc(logt1
yc − logt1
yˆc) −
1
2 − t1
(y
2−t1
c − yˆ
2−t1
c
)

(10.101)
which simplifes to the following when the true distribution y is one-hot, with all its mass on class c:
L(c, yˆ) = − logt1
yˆc −
1
2 − t1
 
1 −
X
C
c
0=1
yˆ
2−t1
c
0
!
(10.102)
Here logt
is tempered version of the log function:
logt
(x) ,
1
1 − t
(x
1−t − 1) (10.103)
This is mononotically increasing and concave, and reduces to the standard (natural) logarithm when
t = 1. (Similarly, tempered cross entropy reduces to standard cross entropy when t = 1.) However,
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210.4. Robust logistic regression * 355
(a) (b)
Figure 10.11: (a) Illustration of logistic and tempered logistic loss with t1 = 0.8. (b) Illustration of sigmoid
and tempered sigmoid transfer function with t2 = 2.0. From https: // ai. googleblog. com/ 2019/ 08/
bi-tempered-logistic-loss-for-training. html . Used with kind permission of Ehsan Amid.
the tempered log function is bounded from below by −1/(1 − t) for 0 ≤ t < 1, and hence the cross
entropy loss is bounded from above (see Figure 10.11).
The second observation is that examples that are near the decision boundary, but mislabeled, need
to use a transfer function (that maps from activations R
C to probabilities [0, 1]C ) that has heavier
tails than the softmax, which is based on the exponential, so it can “look past” the neighborhood of
the immediate examples. In particular, the standard softmax is defined by
yˆc =
ac PC
c
0=1 exp(ac
0 )
= exp "
ac − log X
C
c
0=1
exp(ac
0 )
#
(10.104)
where a is the logits vector. We can make a heavy tailed version by using the tempered softmax,
which uses a temperature parameter t2 > 1 > t1 as follows:
yˆc = expt2
(ac − λt2
(a)) (10.105)
where
expt
(x) , [1 + (1 − t)x]
1/(1−t)
+ (10.106)
is a tempered version of the exponential function. (This reduces to the standard exponental function
as t → 1.) In Figure 10.11(right), we show that the tempered softmax (in the two-class case) has
heavier tails, as desired.
All that remains is a way to compute λt2
(a). This must satisfy the following fixed point equation:
X
C
c=1
expt2
(ac − λ(a)) = 1 (10.107)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license356 Chapter 10. Logistic Regression
Algorithm 3: Iterative algorithm for computing λ(a) in Equation (10.107). From [AWS19].
1 Input: logits a, temperature t > 1 ;
2 µ := max(a) ;
3 a := a − µ ;
4 while a not converged do
5 Z(a) := PC
c=1 expt
(ac) ;
6 a := Z(a)
1−t
(a − µ1) ;
7 Return − logt
1
Z(a) + µ
Figure 10.12: Illustration of standard and bi-tempered logistic regression on data with label noise. From
https: // ai. googleblog. com/ 2019/ 08/ bi-tempered-logistic-loss-for-training. html . Used with
kind permission of Ehsan Amid.
We can solve for λ using binary search, or by using the iterative procedure in Algorithm 3.
Combining the tempered softmax with the tempered cross entropy results in a method called
bi-tempered logistic regression. In Figure 10.12, we show an example of this in 2d. The top
row is standard logistic regression, the bottom row is bi-tempered. The first column is clean data.
The second column has label noise near the boundary. The robust version uses t1 = 1 (standard
cross entropy) but t2 = 4 (tempered softmax with heavy tails). The third column has label noise far
from the boundary. The robust version uses t1 = 0.2 (tempered cross entropy with bounded loss)
but t2 = 1 (standard softmax). The fourth column has both kinds of noise; in this case, the robust
version uses t1 = 0.2 and t2 = 4.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210.5. Bayesian logistic regression * 357
10.5 Bayesian logistic regression *
So far we have focused on point estimates of the parameters, either the MLE or the MAP estimate.
However, in some cases we want to compute the posterior, p(w|D), in order to capture our uncertainty.
This can be particularly useful in settings where we have little data, and where choosing the wrong
decision may be costly.
Unlike with linear regression, it is not possible to compute the posterior exactly for a logistic
regression model. A wide range of approximate algorithms can be used,. In this section, we use one
of the simplest, known as the Laplace approximation (Section 4.6.8.2). See the sequel to this book,
[Mur22] for more advanced approximations.
10.5.1 Laplace approximation
As we discuss in Section 4.6.8.2, the Laplace approximation approximates the posterior using a
Gaussian. The mean of the Gaussian is equal to the MAP estimate wˆ , and the covariance is equal to
the inverse Hessian H computed at the MAP estimate, i.e., p(w|D) ≈ N (w|wˆ , H−1
), We can find
the mode using a standard optimization method (see Section 10.2.7), and then we can use the results
from Section 10.2.3.4 to compute the Hessian at the mode.
As an example, consider the data illustrated in Figure 10.13(a). There are many parameter settings
that correspond to lines that perfectly separate the training data; we show 4 example lines. The
likelihood surface is shown in Figure 10.13(b). The diagonal line connects the origin to the point in
the grid with maximum likelihood, wˆ mle = (8.0, 3.4). (The unconstrained MLE has ||w|| = ∞, as we
discussed in Section 10.2.7; this point can be obtained by following the diagonal line infinitely far to
the right.)
For each decision boundary in Figure 10.13(a), we plot the corresponding parameter vector in
Figure 10.13(b). These parameters values are w1 = (3, 1), w2 = (4, 2), w3 = (5, 3), and w4 = (7, 3).
These points all approximately satisfy wi(1)/wi(2) ≈ wˆ mle(1)/wˆ mle(2), and hence are close to the
orientation of the maximum likelihood decision boundary. The points are ordered by increasing
weight norm (3.16, 4.47, 5.83, and 7.62).
To ensure a unique solution, we use a (spherical) Gaussian prior centered at the origin, N (w|0, σ2
I).
The value of σ
2
controls the strength of the prior. If we set σ
2 = 0, we force the MAP estimate to be
w = 0; this will result in maximally uncertain predictions, since all points x will produce a predictive
distribution of the form p(y = 1|x) = 0.5. If we set σ
2 = ∞, the prior becomes uninformative,
and MAP estimate becomes the MLE, resulting in minimally uncertain predictions. (In particular,
all positively labeled points will have p(y = 1|x) = 1.0, and all negatively labeled points will have
p(y = 1|x) = 0.0, since the data is separable.) As a compromise (to make a nice illustration), we
pick the value σ
2 = 100.
Multiplying this prior by the likelihood results in the unnormalized posterior shown in Fig￾ure 10.13(c). The MAP estimate is shown by the blue dot. The Laplace approximation to this
posterior is shown in Figure 10.13(d). We see that it gets the mode correct (by construction), but
the shape of the posterior is somewhat distorted. (The southwest-northeast orientation captures
uncertainty about the magnitude of w, and the southeast-northwest orientation captures uncertainty
about the orientation of the decision boundary.)
In Figure 10.14, we show contours of the posterior predictive distribution. Figure 10.14(a) shows the
plugin approximation using the MAP estimate. We see that there is no uncertainty about the decision
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license358 Chapter 10. Logistic Regression
−8 −6 −4 −2 0 2 4 6
−8
−6
−4
−2
0
2
4
6
data
(a)
−8 −6 −4 −2 0 2 4 6
−8
−6
−4
−2
0
2
4
6
1
2
3 4
Log-Likelihood
(b)
−8 −6 −4 −2 0 2 4 6
−8
−6
−4
−2
0
2
4
6
Log-Unnormalised Posterior
(c)
−8 −6 −4 −2 0 2 4 6
−8
−6
−4
−2
0
2
4
6
Laplace Approximation to Posterior
(d)
Figure 10.13: (a) Illustration of the data. (b) Log-likelihood for a logistic regression model. The line is drawn
from the origin in the direction of the MLE (which is at infinity). The numbers correspond to 4 points in
parameter space, corresponding to the lines in (a). (c) Unnormalized log posterior (assuming vague spherical
prior). (d) Laplace approximation to posterior. Adapted from a figure by Mark Girolami. Generated by code
at figures.probml.ai/book1/10.13.
boundary, even though we are generating probabilistic predictions over the labels. Figure 10.14(b)
shows what happens when we plug in samples from the Gaussian posterior. Now we see that there is
considerable uncertainty about the orientation of the “best” decision boundary. Figure 10.14(c) shows
the average of these samples. By averaging over multiple predictions, we see that the uncertainty in
the decision boundary “splays out” as we move further from the training data. Figure 10.14(d) shows
that the probit approximation gives very similar results to the Monte Carlo approximation.
10.5.2 Approximating the posterior predictive
The posterior p(w|D) tells us everything we know about the parameters of the model given the data.
However, in machine learning applications, the main task of interest is usually to predict an output y
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210.5. Bayesian logistic regression * 359
−8 −6 −4 −2 0 2 4 6
−8
−6
−4
−2
0
2
4
6
p(y=1|x, wMAP)
(a)
−8 −6 −4 −2 0 2 4 6
−8
−6
−4
−2
0
2
4
6
Decision boundary for sampled w
(b)
−8 −6 −4 −2 0 2 4 6
−8
−6
−4
−2
0
2
4
6
MC approx of p(y=1|x)
(c)
−8 −6 −4 −2 0 2 4 6
−8
−6
−4
−2
0
2
4
6
Deterministic approx of p(y=1|x)
(d)
Figure 10.14: Posterior predictive distribution for a logistic regression model in 2d. (a): contours of
p(y = 1|x, wˆ map). (b): samples from the posterior predictive distribution. (c): Averaging over these samples.
(d): moderated output (probit approximation). Adapted from a figure by Mark Girolami. Generated by code at
figures.probml.ai/book1/10.14.
given an input x, rather than to try to understand the parameters of our model. Thus we need to
compute the posterior predictive distribution
p(y|x, D) = Z
p(y|x, w)p(w|D)dw (10.108)
As we discussed in Section 4.6.7.1, a simple approach to this is to first compute a point estimate wˆ
of the parameters, such as the MLE or MAP estimate, and then to ignore all posterior uncertainty,
by assuming p(w|D) = δ(w − wˆ ). In this case, the above integral reduces to the following plugin
approximation:
p(y|x, D) ≈
Z
p(y|x, w)δ(w − wˆ )dw = p(y|x, wˆ ) (10.109)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license360 Chapter 10. Logistic Regression
However, if we want to compute uncertainty in our predictions, we should use a non-degenerate
posterior. It is common to use a Gaussian posterior, as we will see. But we still need to approximate
the integral in Equation (10.108). We discuss some approaches to this below.
10.5.2.1 Monte Carlo approximation
The simplest approach is to use a Monte Carlo approximation to the integral. This means we
draw S samples from the posterior, ws ∼ p(w|D). and then compute
p(y = 1|x, D) ≈
1
S
X
S
s=1
σ(wT
sx) (10.110)
10.5.2.2 Probit approximation
Although the Monte Carlo approximation is simple, it can be slow, since we need to draw S samples
at test time for each input x. Fortunately, if p(w|D) = N (w|µ, Σ), there is a simple yet accurate
deterministic approximation, first suggested in [SL90]. To explain this approximation, we follow
the presentation of [Bis06, p219]. The key observation is that the sigmoid function σ(a) is similar
in shape to the Gaussian cdf (see Section 2.6.1) Φ(a). In particular we have σ(a) ≈ Φ(λa), where
λ
2 = π/8 ensures the two functions have the same slope at the origin. This is useful since we can
integrate a Gaussian cdf wrt a Gaussian pdf exactly:
Z
Φ(λa)N (a|m, v)da = Φ 
m
(λ−2 + v)
1
2

= Φ 
λm
(1 + λ2v)
1
2

≈ σ(κ(v)m) (10.111)
where we have defined
κ(v) , (1 + πv/8)− 1
2 (10.112)
Thus if we define a = x
Tw, we have
p(y = 1|x, D) ≈ σ(κ(v)m) (10.113)
m = E [a] = x
Tµ (10.114)
v = V [a] = V

x
Tw

= x
TΣx (10.115)
where we used Equation (2.165) in the last line. Since Φ is the inverse of the probit function, we will
call this the probit approximation.
Using Equation (10.113) results in predictions that are less extreme (in terms of their confidence)
than the plug-in estimate. To see this, note that 0 < κ(v) < 1 and hence κ(v)m < m, so σ(κ(v)m) is
closer to 0.5 than σ(m) is. However, the decision boundary itself will not be affected. To see this,
note that the decision boundary is the set of points x for which p(y = 1|x, D) = 0.5. This implies
κ(v)m = 0, which implies m = wTx = 0; but this is the same as the decision boundary from the
plugin estimate. Thus “being Bayesian” doesn’t change the misclassification rate (in this case), but
it does change the confidence estimates of the model, which can be important, as we illustrate in
Section 10.5.1.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210.6. Exercises 361
In the multiclass case we can use the generalized probit approximation [Gib97]:
p(y = c|x, D) ≈
exp(κ(vc)mc)
P
c
0 exp(κ(vc
0 )mc
0 )
(10.116)
mc = mT
cx (10.117)
vc = x
TVc,cx (10.118)
where κ is defined in Equation (10.112). Unlike the binary case, taking into account posterior
covariance gives different predictions than the plug-in approach (see Exercise 3.10.3 of [RW06]).
For further approximations of Gaussian integrals combined with sigmoid and softmax functions,
see [Dau17].
10.6 Exercises
Exercise 10.1 [Gradient and Hessian of log-likelihood for multinomial logistic regression]
a. Let µik = S(ηi
)k, where ηi = wT xi. Show that the Jacobian of the softmax is
∂µik
∂ηij
= µik(δkj − µij ) (10.119)
where δkj = I(k = j).
b. Hence show that the gradient of the NLL is given by
∇wc
` =
X
i
(yic − µic)xi (10.120)
Hint: use the chain rule and the fact that P
c
yic = 1.
c. Show that the block submatrix of the Hessian for classes c and c
0
is given by
Hc,c0 = −
X
i
µic(δc,c0 − µi,c0 )xix
T
i (10.121)
Hence show that the Hessian of the NLL is positive definite.
Exercise 10.2 [Regularizing separate terms in 2d logistic regression *]
(Source: Jaakkola.)
a. Consider the data in Figure 10.15a, where we fit the model p(y = 1|x, w) = σ(w0 +w1x1 +w2x2). Suppose
we fit the model by maximum likelihood, i.e., we minimize
J(w) = −`(w, Dtrain) (10.122)
where `(w, Dtrain) is the log likelihood on the training set. Sketch a possible decision boundary corre￾sponding to wˆ . (Copy the figure first (a rough sketch is enough), and then superimpose your answer
on your copy, since you will need multiple versions of this figure). Is your answer (decision boundary)
unique? How many classification errors does your method make on the training set?
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license362 Chapter 10. Logistic Regression
(a)
−2 −1.5 −1 −0.5 0 0.5 1 1.5 2 −1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
c
k
w
k
1
2
3
(b)
Figure 10.15: (a) Data for logistic regression question. (b) Plot of wˆk vs amount of correlation ck for three
different estimators.
b. Now suppose we regularize only the w0 parameter, i.e., we minimize
J0(w) = −`(w, Dtrain) + λw2
0 (10.123)
Suppose λ is a very large number, so we regularize w0 all the way to 0, but all other parameters are
unregularized. Sketch a possible decision boundary. How many classification errors does your method
make on the training set? Hint: consider the behavior of simple linear regression, w0 + w1x1 + w2x2 when
x1 = x2 = 0.
c. Now suppose we heavily regularize only the w1 parameter, i.e., we minimize
J1(w) = −`(w, Dtrain) + λw2
1 (10.124)
Sketch a possible decision boundary. How many classification errors does your method make on the
training set?
d. Now suppose we heavily regularize only the w2 parameter. Sketch a possible decision boundary. How
many classification errors does your method make on the training set?
Exercise 10.3 [Logistic regression vs LDA/QDA *]
(Source: Jaakkola.) Suppose we train the following binary classifiers via maximum likelihood.
a. GaussI: A generative classifier, where the class-conditional densities are Gaussian, with both covariance
matrices set to I (identity matrix), i.e., p(x|y = c) = N (x|µc, I). We assume p(y) is uniform.
b. GaussX: as for GaussI, but the covariance matrices are unconstrained, i.e., p(x|y = c) = N (x|µc, Σc).
c. LinLog: A logistic regression model with linear features.
d. QuadLog: A logistic regression model, using linear and quadratic features (i.e., polynomial basis function
expansion of degree 2).
After training we compute the performance of each model M on the training set as follows:
L(M) = 1
n
Xn
i=1
log p(yi|xi, θˆ, M) (10.125)
(Note that this is the conditional log-likelihood p(y|x, θˆ) and not the joint log-likelihood p(y, x|θˆ).) We now
want to compare the performance of each model. We will write L(M) ≤ L(M0
) if model M must have lower
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202210.6. Exercises 363
(or equal) log likelihood (on the training set) than M0
, for any training set (in other words, M is worse than
M0
, at least as far as training set logprob is concerned). For each of the following model pairs, state whether
L(M) ≤ L(M0
), L(M) ≥ L(M0
), or whether no such statement can be made (i.e., M might sometimes be
better than M0
and sometimes worse); also, for each question, briefly (1-2 sentences) explain why.
a. GaussI, LinLog.
b. GaussX, QuadLog.
c. LinLog, QuadLog.
d. GaussI, QuadLog.
e. Now suppose we measure performance in terms of the average misclassification rate on the training set:
R(M) = 1
n
Xn
i=1
I(yi 6= ˆy(xi)) (10.126)
Is it true in general that L(M) > L(M0
) implies that R(M) < R(M0
)? Explain why or why not.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license11 Linear Regression
11.1 Introduction
In this chapter, we discuss linear regression, which is a very widely used method for predicting
a real-valued output (also called the dependent variable or target) y ∈ R, given a vector of
real-valued inputs (also called independent variables, explanatory variables, or covariates)
x ∈ R
D. The key property of the model is that the expected value of the output is assumed to be a
linear function of the input, E [y|x] = wTx, which makes the model easy to interpret, and easy to fit
to data. We discuss nonlinear extensions later in this book.
11.2 Least squares linear regression
In this section, we discuss the most common form of linear regression model.
11.2.1 Terminology
The term “linear regression” usually refers to a model of the following form:
p(y|x, θ) = N (y|w0 + wTx, σ2
) (11.1)
where θ = (w0, w, σ2
) are all the parameters of the model. (In statistics, the parameters w0 and w
are usually denoted by β0 and β.)
The vector of parameters w1:D are known as the weights or regression coefficients. Each
coefficient wd specifies the change in the output we expect if we change the corresponding input
feature xd by one unit. For example, suppose x1 is the age of a person, x2 is their education level
(represented as a continuous number), and y is their income. Thus w1 corresponds to the increase
in income we expect as someone becomes one year older (and hence get more experience), and w2
corresponds to the increase in income we expect as someone’s education level increases by one level.
The term w0 is the offset or bias term, and specifies the output value if all the inputs are 0. This
captures the unconditional mean of the response, w0 = E [y], and acts as a baseline. We will usually
assume that x is written as [1, x1, . . . , xD], so we can absorb the offset term w0 into the weight vector
w.
If the input is one-dimensional (so D = 1), the model has the form f(x; w) = ax + b, where b = w0
is the intercept, and a = w1 is the slope. This is called simple linear regression. If the input is
multi-dimensional, x ∈ R
D where D > 1, the method is called multiple linear regression. If the366 Chapter 11. Linear Regression
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
10
5
0
5
10
15
degree 1
(a)
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
10
5
0
5
10
15
degree 2
(b)
Figure 11.1: Polynomial of degrees 1 and 2 fit to 21 datapoints. Generated by code at fig￾ures.probml.ai/book1/11.1.
output is also multi-dimensional, y ∈ R
J
, where J > 1, it is called multivariate linear regression,
p(y|x,W) = Y
J
j=1
N (yj |wT
j x, σ2
j
) (11.2)
See Exercise 11.1 for a simple numerical example.
In general, a straight line will not provide a good fit to most data sets. However, we can always
apply a nonlinear transformation to the input features, by replacing x with φ(x) to get
p(y|x, θ) = N (y|wTφ(x), σ2
) (11.3)
As long as the parameters of the feature extractor φ are fixed, the model remains linear in the
parameters, even if it is not linear in the inputs. (We discuss ways to learn the feature extractor, and
the final linear mapping, in Part III.)
As a simple example of a nonlinear transformation, consider the case of polynomial regression,
which we introduced in Section 1.2.2.2. If the input is 1d, and we use a polynomial expansion of
degree d, we get φ(x) = [1, x, x2
, . . . , xd
]. See Figure 11.1 for an example. (See also Section 11.5
where we discuss splines.)
11.2.2 Least squares estimation
To fit a linear regression model to data, we will minimize the negative log likelihood on the training
set. The objective function is given by
NLL(w, σ2
) = −
X
N
n=1
log "
1
2πσ2
1
2
exp 
−
1
2σ
2
(yn − wTxn)
2
#
(11.4)
=
1
2σ
2
X
N
n=1
(yn − yˆn)
2 +
N
2
log(2πσ2
) (11.5)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.2. Least squares linear regression 367
where we have defined the predicted response yˆn , wTxn. The MLE is the point where ∇w,σNLL(w, σ2
) =
0. We can first optimize wrt w, and then solve for the optimal σ.
In this section, we just focus on estimating the weights w. In this case, the NLL is equal (up to
irrelevant constants) to the residual sum of squares, which is given by
RSS(w) = 1
2
X
N
n=1
(yn − wTxn)
2 =
1
2
||Xw − y||2
2 =
1
2
(Xw − y)
T
(Xw − y) (11.6)
We discuss how to optimize this below.
11.2.2.1 Ordinary least squares
From Equation (7.264) we can show that the gradient is given by
∇wRSS(w) = XTXw − XTy (11.7)
Setting the gradient to zero and solving gives
XTXw = XTy (11.8)
These are known as the normal equations, since, at the optimal solution, y − Xw is normal
(orthogonal) to the range of X, as we explain in Section 11.2.2.2. The corresponding solution wˆ is
the ordinary least squares (OLS) solution, which is given by
wˆ = (XTX)
−1XTy (11.9)
The quantity X† = (XTX)
−1XT is the (left) pseudo inverse of the (non-square) matrix X (see
Section 7.5.3 for more details).
We can check that the solution is unique by showing that the Hessian is positive definite. In this
case, the Hessian is given by
H(w) = ∂
2
∂x2
RSS(w) = XTX (11.10)
If X is full rank (so the columns of X are linearly independent), then H is positive definite, since for
any v > 0, we have
v
T
(XTX)v = (Xv)
T
(Xv) = ||Xv||2 > 0 (11.11)
Hence in the full rank case, the least squares objective has a unique global minimum. See Figure 11.2
for an illustration.
11.2.2.2 Geometric interpretation of least squares
The normal equations have an elegant geometrical interpretation, deriving from Section 7.7, as we
now explain. We will assume N > D, so there are more observations than unknowns. (This is known
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license368 Chapter 11. Linear Regression
−8 −7 −6 −5 −4 −3 −2 −1 0 −0.50
−0.25
0.00
0.25
0.50
0.75
1.00
1.25
1.50
(a)
−8 −7 −6 −5 −4 −3 −2 −1 0 −0.50 −0.25 0.000.250.500.751.001.251.50
1000
2000
3000
4000
5000
(b)
Figure 11.2: (a) Contours of the RSS error surface for the example in Figure 11.1a. The blue cross represents
the MLE. (b) Corresponding surface plot. Generated by code at figures.probml.ai/book1/11.2.
a2
a1 b
b
0
-1 0
0.5
1
0
1
0.2
0.4
0.6
0.8
1
^
Figure 11.3: Graphical interpretation of least squares for m = 3 equations and n = 2 unknowns when solving
the system Ax = b. a1 and a2 are the columns of A, which define a 2d linear subspace embedded in R
3
. The
target vector b is a vector in R
3
; its orthogonal projection onto the linear subspace is denoted bˆ. The line
from b to bˆ is the vector of residual errors, whose norm we want to minimize.
as an overdetermined system.) We seek a vector yˆ ∈ R
N that lies in the linear subspace spanned
by X and is as close as possible to y, i.e., we want to find
argmin
yˆ∈span({x:,1,...,x:,d})
ky − yˆk2. (11.12)
where x:,d is the d’th column of X. Since yˆ ∈ span(X), there exists some weight vector w such that
yˆ = w1x:,1 + · · · + wnx:,D = Xw (11.13)
To minimize the norm of the residual, y − yˆ, we want the residual vector to be orthogonal to every
column of X. Hence
x
T
:,d(y − yˆ) = 0 ⇒ XT
(y − Xw) = 0 ⇒ w = (XTX)
−1XTy (11.14)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.2. Least squares linear regression 369
Hence our projected value of y is given by
yˆ = Xw = X(XTX)
−1XTy (11.15)
This corresponds to an orthogonal projection of y onto the column space of X. For example,
consider the case where we have N = 3 training examples, each of dimensionality D = 2. The
training data defines a 2d linear subspace, defined by the 2 columns of X, each of which is a point in
3d. We project y, which is also a point in 3d, onto this 2d subspace, as shown in Figure 11.3.
The projection matrix
Proj(X) , X(XTX)
−1XT
(11.16)
is sometimes called the hat matrix, since yˆ = Proj(X)y. In the special case that X = x is a column
vector, the orthogonal projection of y onto the line x becomes
Proj(x)y = x
x
Ty
xTx
(11.17)
11.2.2.3 Algorithmic issues
Recall that the OLS solution is
wˆ = X†y = (XTX)
−1XTy (11.18)
However, even if it is theoretically possible to compute the pseudo-inverse by inverting XTX, we
should not do so for numerical reasons, since XTX may be ill conditioned or singular.
A better (and more general) approach is to compute the pseudo-inverse using the SVD. Indeed, if
you look at the source code for the function sklearn.linear_model.fit, you will see that it uses the
scipy.linalg.lstsq function, which in turns calls DGELSD, which is an SVD-based solver implemented
by the LAPACK library, written in Fortran.1
However, if X is tall and skinny (i.e., N  D), it can be quicker to use QR decomposition
(Section 7.6.2). To do this, let X = QR, where QTQ = I. In Section 7.7, we show that OLS is
equivalent to solving the system of linear equations Xw = y in a way that minimizes ||Xw − y||2
2
.
(If N = D and X is full rank, the equations have a unique solution, and the error will be 0.) Using
QR decomposition, we can rewrite this system of equations as follows:
(QR)w = y (11.19)
QTQRw = QTy (11.20)
w = R−1
(QTy) (11.21)
Since R is upper triangular, we can solve this last set of equations using backsubstitution, thus
avoiding matrix inversion. See code.probml.ai/book1/linsys_solve_demo for a demo.
An alternative to the use of direct methods based on matrix decomposition (such as SVD and QR)
is to use iterative solvers, such as the conjugate gradient method (which assumes X is symmetric
1. Note that a lot of the “Python” scientific computing stack sits on top of source code that is written in Fortran
or C++, for reasons of speed. This makes it hard to change the underlying algorithms. By contrast, the scientific
computing libraries in the Julia language are written in Julia itself, aiding clarity without sacrificing speed.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license370 Chapter 11. Linear Regression
positive definite), and the GMRES (generalized minimal residual method), that works for general
X. (In SciPy, this is implemented by sparse.linalg.gmres.) These methods just require the ability
to perform matrix-vector multiplications (i.e., an implementation of a linear operator), and thus
are well-suited to problems where X is sparse or structured. For details, see e.g., [TB97].
A final important issue is that it is usually essential to standardize the input features before
fitting the model, to ensure that they are zero mean and unit variance. We can do this using
Equation (10.51).
11.2.2.4 Weighted least squares
In some cases, we want to associate a weight with each example. For example, in heteroskedastic
regression, the variance depends on the input, so the model has the form
p(y|x; θ) = N (y|wTx, σ2
(x)) = 1
p
2πσ2(x)
exp 
−
1
2σ
2(x)
(y − wTx)
2

(11.22)
Thus
p(y|x; θ) = N (y|Xw, Λ
−1
) (11.23)
where Λ = diag(1/σ2
(xn)). This is known as weighted linear regression. One can show that the
MLE is given by
wˆ = (XTΛX)
−1XTΛy (11.24)
This is known as the weighted least squares estimate.
11.2.3 Other approaches to computing the MLE
In this section, we discuss other approaches for computing the MLE.
11.2.3.1 Solving for offset and slope separately
Typically we use a model of the form p(y|x, θ) = N (y|w0 + wTx, σ2
), where w0 is an offset or “bias”
term. We can compute (w0, w) at the same time by adding a column of 1s to X, and the computing
the MLE as above. Alternatively, we can solve for w and w0 separately. (This will be useful later.)
In particular, one can show that
wˆ = (XT
cXc)
−1XT
cyc =
"X
N
i=1
(xn − x)(xn − x)
T
#−1 "X
N
i=1
(yn − y)(xn − x)
#
(11.25)
wˆ0 =
1
N
X
n
yn −
1
N
X
n
x
T
nwˆ = y − x
Twˆ (11.26)
where Xc is the centered input matrix containing x
c
n = xn − x along its rows, and yc = y − y is the
centered output vector. Thus we can first compute wˆ on centered data, and then estimate w0 using
y − x
Twˆ .
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.2. Least squares linear regression 371
11.2.3.2 Simple linear regression (1d inputs)
In the case of 1d (scalar) inputs, the results from Section 11.2.3.1 reduce to the following simple
form, which may be familiar from basic statistics classes:
wˆ1 =
P
n
(xn − x)(yn − y¯)
P
n
(xn − x¯)
2
=
Cxy
Cxx
(11.27)
wˆ0 = ¯y − wˆ1x¯ = E [y] − w1E [x] (11.28)
where Cxy = Cov [X, Y ] and Cxx = Cov [X, X] = V [X]. We will use this result below.
11.2.3.3 Partial regression
From Equation (11.27), we can compute the regression coefficient of Y on X as follows:
RY X ,
∂
∂xE [Y |X = x] = w1 =
Cxy
Cxx
(11.29)
This is the slope of the linear prediction for Y given X.
Now consider the case where we have 2 inputs, so Y = w0 + w1X1 + w2X2 + , where E [] = 0.
One can show that the optimal regression coefficient for w1 is given by RY X1·X2
, which is the partial
regression coefficient of Y on X1, keeping X2 constant:
w1 = RY X1·X2 =
∂
∂xE [Y |X1 = x, X2] (11.30)
Note that this quantity is invariant to the specific value of X2 we condition on.
We can derive w2 in a similar manner. Indeed, we can extend this to multiple input variables. In
each case, we find the optimal coefficients are equal to the partial regression coefficients. This means
that we can interpret the j’th coefficient wˆj as the change in output y we expect per unit change in
input xj , keeping all the other inputs constant.
11.2.3.4 Recursively computing the MLE
OLS is a batch method for computing the MLE. In some applications, the data arrives in a continual
stream, so we want to compute the estimate online, or recursively, as we discussed in Section 4.4.2.
In this section, we show how to do this for the case of simple (1d) linear regession.
Recall from Section 11.2.3.2 that the batch MLE for simple linear regression is given by
wˆ1 =
P
n
(xn − x)(yn − y¯)
P
n
(xn − x¯)
2
=
Cxy
Cxx
(11.31)
wˆ0 = ¯y − wˆ1x¯ (11.32)
where Cxy = Cov [X, Y ] and Cxx = Cov [X, X] = V [X].
We now discuss how to compute these results in a recursive fashion. To do this, let us define the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license372 Chapter 11. Linear Regression
following sufficient statistics:
x
(n) =
1
n
Xn
i=1
xi
, y
(n) =
1
n
Xn
i=1
yi (11.33)
C
(n)
xx =
1
n
Xn
i=1
(xi − x)
2
, C(n)
xy =
1
n
Xn
i=1
(xi − x)(yi − y), C(n)
yy =
1
n
Xn
i=1
(yi − y)
2
(11.34)
We can update the means online using
x
(n+1) = x
(n) +
1
n + 1
(xn+1 − x
(n)
), y
(n+1) = y
(n) +
1
n + 1
(yn+1 − y
(n)
) (11.35)
To update the covariance terms, let us first rewrite C
(n)
xy as follows:
C
(n)
xy =
1
n
"
(
Xn
i=1
xiyi) + (Xn
i=1
x
(n)
y
(n)
) − x
(n)
(
Xn
i=1
yi) − y
(n)
(
Xn
i=1
xi)
#
(11.36)
=
1
n
"
(
Xn
i=1
xiyi) + nx
(n)
y
(n) − x
(n)ny
(n) − y
(n)nx
(n)
#
(11.37)
=
1
n
"
(
Xn
i=1
xiyi) − nx
(n)
y
(n)
#
(11.38)
Hence
Xn
i=1
xiyi = nC(n)
xy + nx
(n)
y
(n)
(11.39)
and so
C
(n+1)
xy =
1
n + 1
h
xn+1yn+1 + nC(n)
xy + nx
(n)
y
(n) − (n + 1)x
(n+1)y
(n+1)i
(11.40)
We can derive the update for C
(n+1)
xx in a similar manner.
See Figure 11.4 for a simple illustration of these equations in action for a 1d regression model.
To extend the above analysis to D-dimensional inputs, the easiest approach is to use SGD. The
resulting algorithm is called the least mean squares algorithm; see Section 8.4.2 for details.
11.2.3.5 Deriving the MLE from a generative perspective
Linear regression is a discriminative model of the form p(y|x). However, we can also use generative
models for regression, by analogy to how we use generative models for classification in Chapter 9,
The goal is to compute the conditional expectation
f(x) = E [y|x] = Z
y p(y|x)dy =
R
y p(x, y)dy
R
p(x, y)dy
(11.41)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.2. Least squares linear regression 373
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
time
−6
−4
−2
0
2
4
weights
linregOnlineDemo
w0
w1
w0 batch
w1 batch
Figure 11.4: Regression coefficients over time for the 1d model in Figure 1.7a(a). Generated by code at
figures.probml.ai/book1/11.4.
Suppose we fit p(x, y) using an MVN. The MLEs for the parameters of the joint distribution are the
empiricial means and covariances (see Section 4.2.6 for a proof of this result):
µx =
1
N
X
n
xn (11.42)
µy =
1
N
X
n
yn (11.43)
Σxx =
1
N
X
n
(xn − x)(xn − x)
T =
1
N
XT
cXc (11.44)
Σxy =
1
N
X
n
(xn − x)(yn − y) = 1
N
XT
cyc (11.45)
Hence from Equation (3.28), we have
E [y|x] = µy + Σ
T
xyΣ
−1
xx (x − µx) (11.46)
We can rewrite this as E [y|x] = w0 + wTx by defining
w0 = µy − wTµx = y − wTx (11.47)
w = Σ
−1
xx Σxy =
￾
XT
cXc
−1 XT
cyc (11.48)
This matches the MLEs for the discriminative model as we showed in Section 11.2.3.1. Thus we see
that fitting the joint model, and then conditioning it, yields the same result as fitting the conditional
model. However, this is only true for Gaussian models (see Section 9.4 for further discussion of this
point).
11.2.3.6 Deriving the MLE for σ
2
After estimating wˆ mle using one of the above methods, we can estimate the noise variance. It is easy
to show that the MLE is given by
σˆ
2
mle = argmin
σ2
NLL(wˆ , σ2
) = 1
N
X
N
n=1
(yn − x
T
nwˆ )
2
(11.49)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens374 Chapter 11. Linear Regression
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
x
6
4
2
0
2
4
6
residual
degree 1. Predictions on the training set
(a)
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
x
6
4
2
0
2
4
6
residual
degree 2. Predictions on the training set
(b)
Figure 11.5: Residual plot for polynomial regression of degree 1 and 2 for the functions in Figure 1.7a(a-b).
Generated by code at figures.probml.ai/book1/11.5.
10 5 0 5 10 15 20
true y
4
2
0
2
4
6
predicted y
degree 1. R2 on Test = 0.473
(a)
10 5 0 5 10 15 20
true y
5.0
2.5
0.0
2.5
5.0
7.5
10.0
12.5
predicted y
degree 2. R2 on Test = 0.813
(b)
Figure 11.6: Fit vs actual plots for polynomial regression of degree 1 and 2 for the functions in Figure 1.7a(a-b).
Generated by code at figures.probml.ai/book1/11.6.
This is just the MSE of the residuals, which is an intuitive result.
11.2.4 Measuring goodness of fit
In this section, we discuss some simple ways to assess how well a regression model fits the data
(which is known as goodness of fit).
11.2.4.1 Residual plots
For 1d inputs, we can check the reasonableness of the model by plotting the residuals, rn = yn − yˆn,
vs the input xn. This is called a residual plot. The model assumes that the residuals have a
N (0, σ2
) distribution, so the residual plot should be a cloud of points more or less equally above and
below the horizontal line at 0, without any obvious trends.
As an example, in Figure 11.5(a), we plot the residuals for the linear model in Figure 1.7a(a). We
see that there is some curved structure to the residuals, indicating a lack of fit. In Figure 11.5(b), we
plot the residuals for the quadratic model in Figure 1.7a(b). We see a much better fit.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.3. Ridge regression 375
To extend this approach to multi-dimensional inputs, we can plot predictions yˆn vs the true output
yn, rather than plotting vs xn. A good model will have points that lie on a diagonal line. See
Figure 11.6 for some examples.
11.2.4.2 Prediction accuracy and R2
We can assess the fit quantitatively by computing the RSS (residual sum of squares) on the dataset:
RSS(w) = PN
n=1(yn − wTxn)
2
. A model with lower RSS fits the data better. Another measure that
is used is root mean squared error or RMSE:
RMSE(w) ,
r
1
N
RSS(w) (11.50)
A more interpretable measure can be computed using the coefficient of determination, denoted
by R2
:
R
2 , 1 −
PN
n=1(ˆyn − yn)
2
PN
n=1(y − yn)
2
= 1 −
RSS
TSS (11.51)
where y =
1
N
PN
n=1 yn is the empirical mean of the response, RSS =
PN
n=1(yn − yˆn)
2
is the residual
sum of squares, and TSS =
PN
n=1(yn − y)
2
is the total sum of squares. Thus we see tht R2 measures
the variance in the predictions relative to a simple constant prediction of yˆn = y. One can show that
0 ≤ R2 ≤ 1, where larger values imply a greater reduction in variance (better fit). This is illustrated
in Figure 11.6.
11.3 Ridge regression
Maximum likelihood estimation can result in overfitting, as we discussed in Section 1.2.2.2. A
simple solution to this is to use MAP estimation with a zero-mean Gaussian prior on the weights,
p(w) = N (w|0, λ−1
I), as we discused in Section 4.5.3. This is called ridge regression.
In more detail, we compute the MAP estimate as follows:
wˆ map = argmin
1
2σ
2
(y − Xw)
T
(y − Xw) + 1
2τ
2 wTw (11.52)
= argmin RSS(w) + λ||w||2
2
(11.53)
where λ ,
σ
2
τ
2 is proportional to the strength of the prior, and
||w||2 ,
vuutX
D
d=1
|wd|
2 =
√
wTw (11.54)
is the `2 norm of the vector w. Thus we are penalizing weights that become too large in magnitude.
In general, this technique is called `2 regularization or weight decay, and is very widely used.
See Figure 4.5 for an illustration.
Note that we do not penalize the offset term w0, since that only affects the global mean of the
output, and does not contribute to overfitting. See Exercise 11.2.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license376 Chapter 11. Linear Regression
11.3.1 Computing the MAP estimate
In this section, we discuss algorithms for computing the MAP estimate.
The MAP estimate corresponds to minimizing the following penalized objective:
J(w) = (y − Xw)
T
(y − Xw) + λ||w||2
2
(11.55)
where λ = σ
2/τ 2
is the strength of the regularizer. The derivative is given by
∇wJ(w) = 2 ￾
XTXw − XTy + λw

(11.56)
and hence
wˆ map = (XTX + λID)
−1XTy = (X
n
xnx
T
n + λID)
−1
(
X
n
ynxn) (11.57)
11.3.1.1 Solving using QR
Naively computing the primal estimate w = (XTX + λI)
−1XTy using matrix inversion is a bad idea,
since it can be slow and numerically unstable. In this section, we describe a way to convert the
problem to a standard least squares problem, to which we can apply QR decomposition, as discussed
in Section 11.2.2.3.
We assume the prior has the form p(w) = N (0, Λ
−1
), where Λ is the precision matrix. In the case
of ridge regression, Λ = (1/τ 2
)I. We can emulate this prior by adding “virtual data” to the training
set to get
X˜ =

X/σ
√
Λ

, y˜ =

y/σ
0D×1

(11.58)
where Λ =
√
Λ
√
Λ
T
is a Cholesky decomposition of Λ. We see that X˜ is (N + D) × D, where the
extra rows represent pseudo-data from the prior.
We now show that the RSS on this expanded data is equivalent to penalized RSS on the original
data:
f(w) = (y˜ − X˜ w)
T
(y˜ − X˜ w) (11.59)
=
y/σ
0

−

X/σ
√
Λ

w
T y/σ
0

−

X/σ
√
Λ

w

(11.60)
=
 1
σ
(y − Xw)
−
√
Λw
T  1
σ
(y − Xw)
−
√
Λw

(11.61)
=
1
σ
2
(y − Xw)
T
(y − Xw) + (√
Λw)
T
(
√
Λw) (11.62)
=
1
σ
2
(y − Xw)
T
(y − Xw) + wTΛw (11.63)
Hence the MAP estimate is given by
wˆ map = (X˜ TX˜ )
−1X˜ Ty˜ (11.64)
which can be solved using standard OLS methods. In particular, we can compute the QR decomposi￾tion of X˜ , and then proceed as in Section 11.2.2.3. This takes O((N + D)D2
) time.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20211.3. Ridge regression 377
11.3.1.2 Solving using SVD
In this section, we assume D > N, which is the usual case when using ridge regression. In this case,
it is faster to use SVD than QR. To see how this works, let X = USVT be the SVD of X, where
VTV = IN , UUT = UTU = IN , and S is a diagonal N × N matrix. Now let R = US be an N × N
matrix. One can show (see Exercise 18.4 of [HTF09]) that
wˆ map = V(RTR + λIN )
−1RTy (11.65)
In other words, we can replace the D-dimensional vectors xi with the N-dimensional vectors ri and
perform our penalized fit as before. The overall time is now O(DN2
) operations, which is less than
O(D3
) if D > N.
11.3.2 Connection between ridge regression and PCA
In this section, we discuss an interesting connection between ridge regression and PCA (which we
describe in Section 20.1), in order to gain further insight into why ridge regression works well. Our
discussion is based on [HTF09, p66].
Let X = USVT be the SVD of X, where VTV = IN , UUT = UTU = IN , and S is a diagonal
N × N matrix. Using Equation (11.65) we can see that the ridge predictions on the training set are
given by
yˆ = Xwˆ map = USVTV(S
2 + λI)
−1SUTy (11.66)
= USU˜ Ty =
X
D
j=1
ujS˜
jju
T
j y (11.67)
where
S˜
jj , [S(S
2 + λI)
−1S]jj =
σ
2
j
σ
2
j + λ
(11.68)
and σj are the singular values of X. Hence
yˆ = Xwˆ map =
X
D
j=1
uj
σ
2
j
σ
2
j + λ
u
T
j y (11.69)
In contrast, the least squares prediction is
yˆ = Xwˆ mle = (USVT
)(VS−1UTy) = UUTy =
X
D
j=1
uju
T
j y (11.70)
If σ
2
j
is small compared to λ, then direction uj will not have much effect on the prediction. In view
of this, we define the effective number of degrees of freedom of the model as follows:
dof(λ) = X
D
j=1
σ
2
j
σ
2
j + λ
(11.71)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license378 Chapter 11. Linear Regression
prior mean
MAP Estimate
ML Estimate
w1
w2
prior mean
MAP Estimate
ML Estimate
w1
w2
Figure 11.7: Geometry of ridge regression. The likelihood is shown as an ellipse, and the prior is
shown as a circle centered on the origin. Adapted from Figure 3.15 of [Bis06]. Generated by code at
figures.probml.ai/book1/11.7.
When λ = 0, dof(λ) = D, and as λ → ∞, dof(λ) → 0.
Let us try to understand why this behavior is desirable. In Section 11.7, we show that Cov [w|D] ∝
(XTX)
−1
, if we use a uniform prior for w. Thus the directions in which we are most uncertain about
w are determined by the eigenvectors of (XTX)
−1 with the largest eigenvalues, as shown in Figure 7.6;
these correspond to the eigenvectors of XTX with the smallest eigenvalues. In Section 7.5.2, we show
that the squared singular values σ
2
j
are equal to the eigenvalues of XTX. Hence small singular values
σj correspond to directions with high posterior variance. It is these directions which ridge shrinks
the most.
This process is illustrated in Figure 11.7. The horizontal w1 parameter is not-well determined
by the data (has high posterior variance), but the vertical w2 parameter is well-determined. Hence
wmap(2) is close to wmle(2), but wmap(1) is shifted strongly towards the prior mean, which is 0. In
this way, ill-determined parameters are reduced in size towards 0. This is called shrinkage.
There is a related, but different, technique called principal components regression, which is
a supervised version of PCA, which we explain in Section 20.1. The idea is this: first use PCA to
reduce the dimensionality to K dimensions, and then use these low dimensional features as input to
regression. However, this technique does not work as well as ridge regression in terms of predictive
accuracy [HTF01, p70]. The reason is that in PC regression, only the first K (derived) dimensions
are retained, and the remaining D − K dimensions are entirely ignored. By contrast, ridge regression
uses a “soft” weighting of all the dimensions.
11.3.3 Choosing the strength of the regularizer
To find the optimal value of λ, we can try a finite number of distinct values, and use cross validation
to estimate their expected loss, as discussed in Section 4.5.5.2. See Figure 4.5d for an example.
This approach can be quite expensive if we have many values to choose from. Fortunately, we can
often warm start the optimization procedure, using the value of wˆ (λk) as an initializer for wˆ (λk+1),
where λk+1 < λk; in other words, we start with a highly constrained model (strong regularizer), and
then gradually relax the constraints (decrease the amount of regularization). The set of parameters
wˆ k that we sweep out in this way is known as the regularization path. See Figure 11.10(a) for an
example.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.4. Lasso regression 379
We can also use an empirical Bayes approach to choose λ. In particular, we choose the hyperpa￾rameter by computing λˆ = argmaxλ
log p(D|λ), where p(D|λ) is the marginal likelihood or evidence.
Figure 4.7b shows that this gives essentially the same result as the CV estimate. However, the
Bayesian approach has several advantages: computing p(D|λ) can be done by fitting a single model,
whereas CV has to fit the same model K times; and p(D|λ) is a smooth function of λ, so we can use
gradient-based optimization instead of discrete search.
11.4 Lasso regression
In Section 11.3, we assumed a Gaussian prior for the regression coefficients when fitting linear
regression models. This is often a good choice, since it encourages the parameters to be small, and
hence prevents overfitting. However, sometimes we want the parameters to not just be small, but to
be exactly zero, i.e., we want wˆ to be sparse, so that we minimize the L0-norm:
||w||0 =
X
D
d=1
I(|wd| > 0) (11.72)
This is useful because it can be used to perform feature selection. To see this, note that the
prediction has the form f(x; w) = PD
d=1 wdxd, so if any wd = 0, we ignore the corresponding feature
xd. (The same idea can be applied to nonlinear models, such as DNNs, by encouraging the first layer
weights to be sparse.)
11.4.1 MAP estimation with a Laplace prior (`1 regularization)
There are many ways to compute such sparse estimates (see e.g., [Bha+19]). In this section we focus
on MAP estimation using the Laplace distribution (which we discussed in Section 11.6.1) as the
prior:
p(w|λ) = Y
D
d=1
Lap(wd|0, 1/λ) ∝
Y
D
d=1
e
−λ|wd|
(11.73)
where λ is the sparsity parameter, and
Lap(w|µ, b) ,
1
2b
exp 
−
|w − µ|
b

(11.74)
Here µ is a location parameter and b > 0 is a scale parameter. Figure 2.15 shows that Lap(w|0, b)
puts more density on 0 than N (w|0, σ2
), even when we fix the variance to be the same.
To perform MAP estimation of a linear regression model with this prior, we just have to minimize
the following objective:
PNLL(w) = − log p(D|w) − log p(w|λ) = ||Xw − y||2
2 + λ||w||1 (11.75)
where ||w||1 ,
PD
d=1 |wd| is the `1 norm of w. This method is called lasso, which stands for “least
absolute shrinkage and selection operator” [Tib96]. (We explain the reason for this name below.)
More generally, MAP estimation with a Laplace prior is called `1-regularization.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license380 Chapter 11. Linear Regression
Figure 11.8: Illustration of `1 (left) vs `2 (right) regularization of a least squares problem. Adapted from
Figure 3.12 of [HTF01].
Note also that we could use other norms for the weight vector. In general, the q-norm is defined as
follows:
kwkq =
 X
D
d=1
|wd|
q
!1/q
(11.76)
For q < 1, we can get even sparser solutions. In the limit where q = 0, we get the `0-norm:
kwk0 =
X
D
d=1
I(|wd| > 0) (11.77)
However, one can show that for any q < 1, the problem becomes non-convex (see e.g., [HTW15]).
Thus `1-norm is the tightest convex relaxation of the `0-norm.
11.4.2 Why does `1 regularization yield sparse solutions?
We now explain why `1 regularization results in sparse solutions, whereas `2 regularization does not.
We focus on the case of linear regression, although similar arguments hold for other models.
The lasso objective is the following non-smooth objective (see Section 8.1.4 for a discussion of
smoothness):
min
w
NLL(w) + λ||w||1 (11.78)
This is the Lagrangian for the following quadratic program (see Section 8.5.4):
min
w
NLL(w) s.t. ||w||1 ≤ B (11.79)
where B is an upper bound on the `1-norm of the weights: a small (tight) bound B corresponds to a
large penalty λ, and vice versa.
Similarly, we can write the ridge regression objective minw NLL(w) + λ||w||2
2
in bound constrained
form:
min
w
NLL(w) s.t. ||w||2
2 ≤ B (11.80)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.4. Lasso regression 381
In Figure 11.8, we plot the contours of the NLL objective function, as well as the contours of the
`2 and `1 constraint surfaces. From the theory of constrained optimization (Section 8.5) we know
that the optimal solution occurs at the point where the lowest level set of the objective function
intersects the constraint surface (assuming the constraint is active). It should be geometrically clear
that as we relax the constraint B, we “grow” the `1 “ball” until it meets the objective; the corners of
the ball are more likely to intersect the ellipse than one of the sides, especially in high dimensions,
because the corners “stick out” more. The corners correspond to sparse solutions, which lie on the
coordinate axes. By contrast, when we grow the `2 ball, it can intersect the objective at any point;
there are no “corners”, so there is no preference for sparsity.
11.4.3 Hard vs soft thresholding
The lasso objective has the form L(w) = NLL(w) + λ||w||1. One can show (Exercise 11.3) that the
gradient for the smooth NLL part is given by
∂
∂wd
NLL(w) = adwd − cd (11.81)
ad =
X
N
n=1
x
2
nd (11.82)
cd =
X
N
n=1
xnd(yn − wT
−dxn,−d) (11.83)
where w−d is w without component d, and similarly xn,−d is feature vector xn without component
d. We see that cd is proportional to the correlation between d’th column of features, x:,d, and the
residual error obtained by predicting using all the other features, r−d = y − X:,−dw−d. Hence the
magnitude of cd is an indication of how relevant feature d is for predicting y, relative to the other
features and the current parameters. Setting the gradient to 0 gives the optimal update for wd,
keeping all other weights fixed:
wd = cd/ad =
x
T
:,dr−d
||x:,d||2
2
(11.84)
The corresponding new prediction for r−d becomes rˆ−d = wdx:,d, which is the orthogonal projection
of the residual onto the column vector x:,d, consistent with Equation (11.15).
Now we add in the `1 term. Unfortunately, the ||w||1 term is not differentiable whenever wd = 0.
Fortunately, we can still compute a subgradient at this point. Using Equation (8.14) we find that
∂wd L(w) = (adwd − cd) + λ∂wd
||w||1 (11.85)
=



{adwd − cd − λ} if wd < 0
[−cd − λ, −cd + λ] if wd = 0
{adwd − cd + λ} if wd > 0
(11.86)
Depending on the value of cd, the solution to ∂wd L(w) = 0 can occur at 3 different values of wd,
as follows:
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license382 Chapter 11. Linear Regression
(a) (b)
Figure 11.9: Left: soft thresholding. Right: hard thresholding. In both cases, the horizontal axis is the residual
error incurred by making predictions using all the coefficients except for wk, and the vertical axis is the
estimated coefficient wˆk that minimizes this penalized residual. The flat region in the middle is the interval
[−λ, +λ].
1. If cd < −λ, so the feature is strongly negatively correlated with the residual, then the subgradient
is zero at wˆd =
cd+λ
ad
< 0.
2. If cd ∈ [−λ, λ], so the feature is only weakly correlated with the residual, then the subgradient is
zero at wˆd = 0.
3. If cd > λ, so the feature is strongly positively correlated with the residual, then the subgradient is
zero at wˆd =
cd−λ
ad
> 0.
In summary, we have
wˆd(cd) =



(cd + λ)/ad if cd < −λ
0 if cd ∈ [−λ, λ]
(cd − λ)/ad if cd > λ
(11.87)
We can write this as follows:
wˆd = SoftThreshold( cd
ad
, λ/ad) (11.88)
where
SoftThreshold(x, δ) , sign(x) (|x| − δ)+ (11.89)
and x+ = max(x, 0) is the positive part of x. This is called soft thresholding (see also Section 8.6.2).
This is illustrated in Figure 11.9(a), where we plot wˆd vs cd. The dotted black line is the line
wd = cd/ad corresponding to the least squares fit. The solid red line, which represents the regularized
estimate wˆd, shifts the dotted line down (or up) by λ, except when −λ ≤ cd ≤ λ, in which case it
sets wd = 0.
By contrast, in Figure 11.9(b), we illustrate hard thresholding. This sets values of wd to 0 if
−λ ≤ cd ≤ λ, but it does not shrink the values of wd outside of this interval. The slope of the soft
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.4. Lasso regression 383
0 5 10 15 20 25 30
−0.2
−0.1
0
0.1
0.2
0.3
0.4
0.5
0.6
lcavol
lweight
age
lbph
svi
lcp
gleason
pgg45
(a)
0 0.5 1 1.5 2
−0.2
−0.1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
τ
lcavol
lweight
age
lbph
svi
lcp
gleason
pgg45
(b)
Figure 11.10: (a) Profiles of ridge coefficients for the prostate cancer example vs bound B on `2 norm of w, so
small B (large λ) is on the left. The vertical line is the value chosen by 5-fold CV using the 1 standard error
rule. Adapted from Figure 3.8 of [HTF09]. Generated by code at figures.probml.ai/book1/11.10. (b) Same as
(a) but using `1 norm of w. The x-axis shows the critical values of λ = 1/B, where the regularization path is
discontinuous. Adapted from Figure 3.10 of [HTF09]. Generated by code at figures.probml.ai/book1/11.10.
thresholding line does not coincide with the diagonal, which means that even large coefficients are
shrunk towards zero. This is why lasso stands for “least absolute selection and shrinkage operator”.
Consequently, lasso is a biased estimator (see Section 4.7.6.1).
A simple solution to the biased estimate problem, known as debiasing, is to use a two-stage
estimation process: we first estimate the support of the weight vector (i.e., identify which elements
are non-zero) using lasso; we then re-estimate the chosen coefficients using least squares. For an
example of this in action, see Figure 11.13.
11.4.4 Regularization path
If λ = 0, we get the OLS solution. which will be dense. As we increase λ, the solution vector wˆ (λ)
will tend to get sparser. If λ is bigger than some critical value, we get wˆ = 0. This critical value is
obtained when the gradient of the NLL cancels out with the gradient of the penalty:
λmax = max
d
|∇wdNLL(0)| = max
d
cd(w = 0) = max
d
|y
Tx:,d| = ||XTy||∞ (11.90)
Alternatively, we can work with the bound B on the `1 norm. When B = 0, we get wˆ = 0. As we
increase B, the solution becomes denser. The largest value of B for which any component is zero is
given by Bmax = ||wˆ mle||1.
As we increase λ, the solution vector wˆ gets sparser, although not necessarily monotonically. We can
plot the values wˆd vs λ (or vs the bound B) for each feature d; this is known as the regularization
path. This is illustrated in Figure 11.10(b), where we apply lasso to the prostate cancer regression
dataset from [HTF09]. (We treat features gleason and svi as numeric, not categorical.) On the left,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license384 Chapter 11. Linear Regression
0 0 0 0 0 0 0 0
0.4279 0 0 0 0 0 0 0
0.5015 0.0735 0 0 0 0 0 0
0.5610 0.1878 0 0 0.0930 0 0 0
0.5622 0.1890 0 0.0036 0.0963 0 0 0
0.5797 0.2456 0 0.1435 0.2003 0 0 0.0901
0.5864 0.2572 -0.0321 0.1639 0.2082 0 0 0.1066
0.6994 0.2910 -0.1337 0.2062 0.3003 -0.2565 0 0.2452
0.7164 0.2926 -0.1425 0.2120 0.3096 -0.2890 -0.0209 0.2773
Table 11.1: Values of the coefficients for linear regression model fit to prostate cancer dataset as we vary the
strength of the `1 regularizer. These numbers are plotted in Figure 11.10(b).
when B = 0, all the coefficients are zero. As we increase B, the coefficients gradually “turn on”.2 The
analogous result for ridge regression is shown in Figure 11.10(a). For ridge, we see all coefficients are
non-zero (assuming λ > 0), so the solution is not sparse.
Remarkably, it can be shown that the lasso solution path is a piecewise linear function of λ [Efr+04;
GL15]. That is, there are a set of critical values of λ where the active set of non-zero coefficients
changes. For values of λ between these critical values, each non-zero coefficient increases or decreases
in a linear fashion. This is illustrated in Figure 11.10(b). Furthermore, one can solve for these critical
values analytically [Efr+04]. In Table 11.1. we display the actual coefficient values at each of these
critical steps along the regularization path (the last line is the least squares solution).
By changing λ from λmax to 0, we can go from a solution in which all the weights are zero to a
solution in which all weights are non-zero. Unfortunately, not all subset sizes are achievable using
lasso. In particular, one can show that, if D > N, the optimal solution can have at most N variables
in it, before reaching the complete set corresponding to the OLS solution of minimal `1 norm. In
Section 11.4.8, we will see that by using an `2 regularizer as well as an `1 regularizer (a method
known as the elastic net), we can achieve sparse solutions which contain more variables than training
cases. This lets us explore model sizes between N and D.
11.4.5 Comparison of least squares, lasso, ridge and subset selection
In this section, we compare least squares, lasso, ridge and subset selection. For simplicity, we assume
all the features of X are orthonormal, so XTX = I. In this case, the NLL is given by
NLL(w) = ||y − Xw||2 = y
Ty + wTXTXw − 2wTXTy (11.91)
= const +X
d
w
2
d − 2
X
d
X
n
wdxndyn (11.92)
so we see this factorizes into a sum of terms, one per dimension. Hence we can write down the MAP
and ML estimates analytically for each wd separately, as given below.
• MLE From Equation (11.85), the OLS solution is given by
wˆ
mle
d = cd/ad = x
T
:dy (11.93)
where x:d is the d’th column of X.
2. It is common to plot the solution versus the shrinkage factor, defined as s(B) = B/Bmax, rather than against B.
This merely affects the scale of the horizontal axis, not the shape of the curves.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.4. Lasso regression 385
Term OLS Best Subset Ridge Lasso
intercept 2.465 2.477 2.467 2.465
lcalvol 0.676 0.736 0.522 0.548
lweight 0.262 0.315 0.255 0.224
age -0.141 0.000 -0.089 0.000
lbph 0.209 0.000 0.186 0.129
svi 0.304 0.000 0.259 0.186
lcp -0.287 0.000 -0.095 0.000
gleason -0.021 0.000 0.025 0.000
pgg45 0.266 0.000 0.169 0.083
Test error 0.521 0.492 0.487 0.457
Std error 0.176 0.141 0.157 0.146
Figure 11.11: Results of different methods on the prostate cancer data, which has 8 features and 67 training
cases. Methods are: OLS = ordinary least squares, Subset = best subset regression, Ridge, Lasso. Rows
represent the coefficients; we see that subset regression and lasso give sparse solutions. Bottom row is the
mean squared error on the test set (30 cases). Adapted from Table 3.3. of [HTF09]. Generated by code at
figures.probml.ai/book1/11.11.
• Ridge One can show that the ridge estimate is given by
wˆ
ridge
d =
wˆ
mle
d
1 + λ
(11.94)
• Lasso From Equation (11.88), and using the fact that wˆ
mle
d = cd/ad, we have
wˆ
lasso
d = sign( ˆw
mle
d
)
￾
|wˆ
mle
d
| − λ

+
(11.95)
This corresponds to soft thresholding, shown in Figure 11.9(a).
• Subset selection If we pick the best K features using subset selection, the parameter estimate
is as follows
wˆ
ss
d =

wˆ
mle
d
if rank(|wˆ
mle
d
|) ≤ K
0 otherwise (11.96)
where rank refers to the location in the sorted list of weight magnitudes. This corresponds to
hard thresholding, shown in Figure 11.9(b).
We now experimentally compare the prediction performance of these methods on the prostate cancer
regression dataset from [HTF09]. (We treat features gleason and svi as numeric, not categorical.)
Figure 11.11 shows the estimated coefficients at the value of λ (or K) chosen by cross-validation;
we see that the subset method is the sparsest, then lasso. In terms of predictive performance, all
methods are very similar, as can be seen from Figure 11.12.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens386 Chapter 11. Linear Regression
LS Best Subset Ridge Lasso
0.00
0.25
0.50
0.75
1.00
1.25
1.50
1.75
2.00
Figure 11.12: Boxplot displaying (absolute value of) prediction errors on the prostate cancer test set for
different regression methods. Generated by code at figures.probml.ai/book1/11.12.
11.4.6 Variable selection consistency
It is common to use `1 regularization to estimate the set of relevant variables, a process known as
variable selection. A method that can recover the true set of relevant variables (i.e., the support
of w∗
) in the N → ∞ limit is called model selection consistent. (This is a theoretical notion
that assumes the data comes from the model.)
Let us give an example. We first generate a sparse signal w∗ of size D = 4096, consisting of 160
randomly placed ±1 spikes. Next we generate a random design matrix X of size N × D, where
N = 1024. Finally we generate a noisy observation y = Xw∗ + , where n ∼ N (0, 0.012
). We then
estimate w from y and X. The original w∗
is shown in the first row of Figure 11.13. The second
row is the `1 estimate wˆ L1 using λ = 0.1λmax. We see that this has “spikes” in the right places, so
it has correctly identified the relevant variables. However, although we see that wˆ L1 has correctly
identified the non-zero components, but they are too small, due to shrinkage. In the third row, we
show the results of using the debiasing technique discussed in Section 11.4.3. This shows that we
can recover the original weight vector. By contrast, the final row shows the OLS estimate, which is
dense. Furthermore, it is visually clear that there is no single threshold value we can apply to wˆ mle
to recover the correct sparse weight vector.
To use lasso to perform variable selection, we have to pick λ. It is common to use cross validation
to pick the optimal value on the regularization path. However, it is important to note that cross
validation is picking a value of λ that results in good predictive accuracy. This is not usually the same
value as the one that is likely to recover the “true” model. To see why, recall that `1 regularization
performs selection and shrinkage, that is, the chosen coefficients are brought closer to 0. In order to
prevent relevant coefficients from being shrunk in this way, cross validation will tend to pick a value
of λ that is not too large. Of course, this will result in a less sparse model which contains irrelevant
variables (false positives). Indeed, it was proved in [MB06] that the prediction-optimal value of λ
does not result in model selection consistency. However, various extensions to the basic method have
been devised that are model selection consistent (see e.g., [BG11; HTW15]).
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.4. Lasso regression 387
0 1000 2000 3000 4000
−1
0
1
Original (D = 4096, number of nonzeros = 160)
0 1000 2000 3000 4000
−1
0
1
L1 reconstruction (K0 = 1024, lambda = 0.0516, MSE = 0.0027)
0 1000 2000 3000 4000
−1
0
1
Debiased (MSE = 3.26e−005)
0 1000 2000 3000 4000
−0.5
0
0.5
Minimum norm solution (MSE = 0.0292)
Figure 11.13: Example of recovering a sparse signal using lasso. See text for details. Adapted from Figure 1
of [FNW07]. Generated by code at figures.probml.ai/book1/11.13.
11.4.7 Group lasso
In standard `1 regularization, we assume that there is a 1:1 correspondence between parameters
and variables, so that if wˆd = 0, we interpret this to mean that variable d is excluded. But in more
complex models, there may be many parameters associated with a given variable. In particular,
each variable d may have a vector of weights wd associated with it, so the overall weight vector has
block structure, w = [w1, w2, . . . , wD]. If we want to exclude variable d, we have to force the whole
subvector wd to go to zero. This is called group sparsity.
11.4.7.1 Applications
Here are some examples where group sparsity is useful:
• Linear regression with categorical inputs: If the d’th variable is categorical with K possible levels,
then it will be represented as a one-hot vector of length K (Section 1.5.3.1), so to exclude variable
d, we have to set the whole vector of incoming weights to 0.
• Multinomial logistic regression: The d’th variable will be associated with C different weights, one
per class (Section 10.3), so to exclude variable d, we have to set the whole vector of outgoing
weights to 0.
• Neural networks: the k’th neuron will have multiple inputs, so if we want to “turn the neuron
off”, we have to set all the incoming weights to zero. This allows us to use group sparsity to learn
neural network structure (for details, see e.g., [GEH19]).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license388 Chapter 11. Linear Regression
• Multi-task learning: each input feature is associated with C different weights, one per output task.
If we want to use a feature for all of the tasks or none of the tasks, we should select weights at
the group level [OTJ07].
11.4.7.2 Penalizing the two-norm
To encourage group sparsity, we partition the parameter vector into G groups, w = [w1, . . . , wG].
Then we minimize the following objective
PNLL(w) = NLL(w) + λ
X
G
g=1
||wg||2 (11.97)
where ||wg||2 =
qP
d∈g w2
d
is the 2-norm of the group weight vector. If the NLL is least squares,
this method is called group lasso [YL06; Kyu+10].
Note that if we had used the sum of the squared 2-norms in Equation (11.97), then the model
would become equivalent to ridge regression, since
X
G
g=1
||wg||2
2 =
X
g
X
d∈g
w
2
d = ||w||2
2
(11.98)
By using the square root, we are penalizing the radius of a ball containing the group’s weight vector:
the only way for the radius to be small is if all elements are small.
Another way to see why the square root version enforces sparsity at the group level is to consider
the gradient of the objective. Suppose there is only one group of two variables, so the penalty has
the form p
w2
1 + w2
2
. The derivative wrt w1 is
∂
∂w1
(w
2
1 + w
2
2
)
1
2 = p
w1
w2
1 + w2
2
(11.99)
If w2 is close to zero, then the derivative approaches 1, and w1 is driven to zero as well, with force
proportional to λ. If, however, w2 is large, the derivative approaches 0, and w1 is free to stay large
as well. So all the coefficients in the group will have similar size.
11.4.7.3 Penalizing the infinity norm
A variant of this technique replaces the 2-norm with the infinity-norm [TVW05; ZRY05]:
||wg||∞ = max
d∈g
|wd| (11.100)
It is clear that this will also result in group sparsity, since if the largest element in the group is forced
to zero, all the smaller ones will be as well.
11.4.7.4 Example
An illustration of these techniques is shown in Figure 11.14 and Figure 11.15. We have a true signal
w of size D = 212 = 4096, divided into 64 groups each of size 64. We randomly choose 8 groups
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.4. Lasso regression 389
0 500 1000 1500 2000 2500 3000 3500 4000
-3
-2
-1
0
1
2
3 Original (D = 4096, number groups = 64, active groups = 8)
(a)
0 500 1000 1500 2000 2500 3000 3500 4000
-3
-2
-1
0
1
2
3
Standard L1 (debiased 1, tau = 0.427, MSE = 0.08415)
(b)
0 500 1000 1500 2000 2500 3000 3500 4000
-3
-2
-1
0
1
2
3
Block-L2 (debiased 1, tau = 0.427, MSE = 0.000378)
(c)
0 500 1000 1500 2000 2500 3000 3500 4000
-3
-2
-1
0
1
2
3
Block-Linf (debiased 1, tau = 0.427, MSE = 0.0613)
(d)
Figure 11.14: Illustration of group lasso where the original signal is piecewise Gaussian. (a) Original signal.
(b) Vanilla lasso estimate. (c) Group lasso estimate using an `2 norm on the blocks. (d) Group lasso
estimate using an `∞ norm on the blocks. Adapted from Figures 3-4 of [WNF09]. Generated by code at
figures.probml.ai/book1/11.14.
of w and assign them non-zero values. In Figure 11.14 the values are drawn from a N (0, 1); in
Figure 11.15, the values are all set to 1. We then sample a random design matrix X of size N × D,
where N = 210 = 1024. Finally, we generate y = Xw + , where  ∼ N (0, 10−4
IN ). Given this data,
we estimate the support of w using `1 or group `1, and then estimate the non-zero values using least
squares (debiased estimate).
We see from the figures that group lasso does a much better job than vanilla lasso, since it respects
the known group structure. We also see that the `∞ norm has a tendency to make all the elements
within a block to have similar magnitude. This is appropriate in the second example, but not the
first. (The value of λ was the same in all examples, and was chosen by hand.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license390 Chapter 11. Linear Regression
0 500 1000 1500 2000 2500 3000 3500 4000
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Original (D = 4096, number groups = 64, active groups = 8)
(a)
0 500 1000 1500 2000 2500 3000 3500 4000
0
0.2
0.4
0.6
0.8
1
Standard L1 (debiased 1, tau = 0.361, MSE = 0.1232)
(b)
0 500 1000 1500 2000 2500 3000 3500 4000
0
0.2
0.4
0.6
0.8
1
Block-L2 (debiased 1, tau = 0.361, MSE = 0.000386)
(c)
0 500 1000 1500 2000 2500 3000 3500 4000
0
0.2
0.4
0.6
0.8
1
Block-Linf (debiased 1, tau = 0.361, MSE = 0.000635)
(d)
Figure 11.15: Same as Figure 11.14, except the original signal is piecewise constant. Generated by code at
figures.probml.ai/book1/11.15.
11.4.8 Elastic net (ridge and lasso combined)
In group lasso, we need to specify the group structure ahead of time. For some problems, we don’t
know the group structure, and yet we would still like highly correlated coefficients to be treated as an
implicit group. One way to achieve this effect, proposed in [ZH05], is to use the elastic net, which is
a hybrid between lasso and ridge regression.3 This corresponds to minimizing the following objective:
L(w, λ1, λ2) = ||y − Xw||2 + λ2||w||2
2 + λ1||w||1 (11.101)
This penalty function is strictly convex (assuming λ2 > 0) so there is a unique global minimum, even
if X is not full rank. It can be shown [ZH05] that any strictly convex penalty on w will exhibit a
grouping effect, which means that the regression coefficients of highly correlated variables tend to
3. It is apparently called the “elastic net” because it is “like a stretchable fishing net that retains all the big fish” [ZH05].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.4. Lasso regression 391
be equal. In particular, if two features are identically equal, so X:j = X:k, one can show that their
estimates are also equal, wˆj = wˆk. By contrast, with lasso, we may have that wˆj = 0 and wˆk 6= 0 or
vice versa, resulting in less stable estimates.
In addition to its soft grouping behavior, elastic net has other advantages. In particular, if D > N,
the maximum number of non-zero elements that can be selected (excluding the MLE, which has D
non-zero elements) is N. By contrast, elastic net can select more than N non-zero variables on its
path to the dense estimate, thus exploring more possible subsets of variables.
11.4.9 Optimization algorithms
A large variety of algorithms have been proposed to solve the lasso problem, and other `1-regularized
convex objectives. In this section, we briefly mention some of the most popular methods.
11.4.9.1 Coordinate descent
Sometimes it is hard to optimize all the variables simultaneously, but it easy to optimize them one
by one. In particular, we can solve for the j’th coefficient with all the others held fixed as follows:
w
∗
j = argmin
η
L(w + ηej ) (11.102)
where ej is the j’th unit vector. This is called coordinate descent. We can either cycle through
the coordinates in a deterministic fashion, or we can sample them at random, or we can choose to
update the coordinate for which the gradient is steepest.
This method is particularly appealing if each one-dimensional optimization problem can be solved
analytically, as is the case for lasso (see Equation (11.87)). This is known as the shooting algorithm
[Fu98; WL08]. (The term “shooting” is a reference to cowboy theme inspired by the term “lasso”.)
See Algorithm 4 for details.
This coordinate descent method has been generalized to the GLM case in [FHT10], and is the
basis of the popular glmnet software library.
Algorithm 4: Coordinate descent for lasso (aka shooting algorithm)
1 Initialize w = (XTX + λI)
−1XTy;
2 repeat
3 for d = 1, . . . , D do
4 ad =
PN
n=1 x
2
nd;
5 cd =
PN
n=1 xnd(yn − wTxn + wdxnd) ;
6 wd = SoftThreshold( cd
ad
, λ/ad);
7 until converged;
11.4.9.2 Projected gradient descent
In this section, we convert the non-differentiable `1 penalty into a smooth regularizer. To do
this, we first use the split variable trick to define w = w+ − w−, where w+ = max{w, 0} and
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license392 Chapter 11. Linear Regression
w− = − min{w, 0}. Now we can replace ||w||1 with P
d
(w
+
d + w
−
d
). We also have to replace NLL(w)
with NLL(w+ + w−). Thus we get the following smooth, but constrained, optimization problem:
min
w+≥0,w−≥0
NLL(w+ − w−) + λ
X
D
d=1
(w
+
d + w
−
d
) (11.103)
In this case of a Gaussian likelihood, the NLL becomes a least squares loss, and the objective
becomes a quadratic program (Section 8.5.4). One way to solve such problems is to use projected
gradient descent (Section 8.6.1). Specifically, we can enforce the constraint by projecting onto the
positive orthant, which we can do using wd := max(wd, 0); this operation is denoted by P+. Thus
the projected gradient update takes the following form:

w
+
t+1
w
−
t+1
= P+
w
+
t − ηt∇NLL(w
+
t − w
−
t
) − ηtλe
w
−
t + ηt∇NLL(w
+
t − w
−
t
) − ηtλe
 (11.104)
where e is the unit vector of all ones.
11.4.9.3 Proximal gradient descent
In Section 8.6, we introduced proximal gradient descent, which can be used to optimize smooth
functions with non-smooth penalties, such as `1. In Section 8.6.2, we showed that the proximal
operator for the `1 penalty corresponds to soft thresholding. Thus the proximal gradient descent
update can be written as
wt+1 = SoftThreshold(wt − ηt∇NLL(wt), ηtλ) (11.105)
where the soft thresholding operator (Equation (8.134)) is applied elementwise. This is called the
iterative soft thresholding algorithm or ISTA [DDDM04; Don95]. If we combine this with
Nesterov acceleration, we get the method known as “fast ISTA” or FISTA [BT09], which is widely
used to fit sparse linear models.
11.4.9.4 LARS
In this section, we discuss methods that can generate a set of solutions for different values of λ,
starting with the empty set, i.e., they compute the full regularization path (Section 11.4.4). These
algorithms exploit the fact that one can quickly compute wˆ (λk) from wˆ (λk−1) if λk ≈ λk−1; this is
known as warm starting. In fact, even if we only want the solution for a single value of λ, call it λ∗,
it can sometimes be computationally more efficient to compute a set of solutions, from λmax down
to λ∗, using warm-starting; this is called a continuation method or homotopy method. This is
often much faster than directly “cold-starting” at λ∗; this is particularly true if λ∗ is small.
The LARS algorithm [Efr+04], which stands for “least angle regression and shrinkage”, is an
example of a homotopy method for the lasso problem. This can compute wˆ (λ) for all possible values
of λ in an efficient manner. (A similar algorithm was independently invented in [OPT00b; OPT00a]).
LARS works as follows. It starts with a large value of λ, such that only the variable that is most
correlated with the response vector y is chosen. Then λ is decreased until a second variable is found
which has the same correlation (in terms of magnitude) with the current residual as the first variable,
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.5. Regression splines * 393
where the residual at step k on the path is defined as rk = y − X:,Fkwk, where Fk is the current
active set (cf., Equation (11.83)). Remarkably, one can solve for this new value of λ analytically,
by using a geometric argument (hence the term “least angle”). This allows the algorithm to quickly
“jump” to the next point on the regularization path where the active set changes. This repeats until
all the variables are added.
It is necessary to allow variables to be removed from the current active set, even as we increase λ,
if we want the sequence of solutions to correspond to the regularization path of lasso. If we disallow
variable removal, we get a slightly different algorithm called least angle regression or LAR. LAR
is very similar to greedy forward selection, and a method known as least squares boosting
(see e.g., [HTW15]).
11.5 Regression splines *
We have seen how we can use polynomial basis functions to create nonlinear mappings from input to
output, even though the model remains linear in the parameters. One problem with polynomials is
that they are a global approximation to the function. We can achieve more flexibility by using a
series of local approximations. To do this, we just need to define a set of basis functions that have
local support. The notion of “locality” is hard to define in high-dimensional input spaces, so in this
section, we restrict ourselves to 1d inputs. We can then approximate the function using
f(x; θ) = Xm
i=1
wiBi(x) (11.106)
where Bi
is the i’th basis function.
A common way to define such basis functions is to use B-splines. (“B” stands for “basis”, and the
term “spline” refers to a flexible piece of material used by artists to draw curves.) We discuss this in
more detail in Section 11.5.1.
11.5.1 B-spline basis functions
A spline is a piecewise polynomial of degree D, where the locations of the pieces are defined by a set
of knots, t1 < · · · < tm. More precisely, the polynomial is defined on each of the intervals (−∞, t1),
[t1, t2], · · · , [tm, ∞). The function is continuous and has continuous derivatives of orders 1, . . . , D − 1
at its knot points. It is common to use cubic splines, in which D = 3. This ensures the function is
continuous, and has continuous first and second derivatives at each knot.
We will skip the details on how B-splines are computed, since it is not relevant to our purposes.
Suffice it to say that we can call the patsy.bs function to convert the N × 1 data matrix X into an
N ×(K +D+ 1) design matrix B, where K is the number of knots and D is the degree. (Alternatively,
you can specify the desired number of basis functions, and let patsy work out the number and locations
of the knots.)
Figure 11.16 illustrates this approach, where we use B-splines of degree 0, 1 and 3, with 3 knots.
By taking a weighted combination of these basis functions, we can get increasingly smooth functions,
as shown in the bottom row.
We see from Figure 11.16 that each individual basis function has local support. At any given input
point x, only D + 1 basis functions will be “active”. This is more obvious if we plot the design matrix
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license394 Chapter 11. Linear Regression
0.00
0.25
0.50
0.75
1.00
Piecewise constant Piecewise linear Cubic spline
0.0 0.5 1.0
0.0
0.5
1.0
1.5
0.0 0.5 1.0 0.0 0.5 1.0
Figure 11.16: Illustration of B-splines of degree 0, 1 and 3. Top row: unweighted basis functions. Dots
mark the locations of the 3 internal knots at [0.25, 0.5, 0.75]. Bottom row: weighted combination of basis
functions using random weights. Generated by code at figures.probml.ai/book1/11.16. Adapted from Figure
5.4 of [MKL11]. Used with kind permission of Osvaldo Martin.
0 1 2 3
0.0
0.1
0.1
0.2
0.2
0.3
0.3
0.4
0.4
0.5
0.5
0.6
0.6
0.7
0.7
0.8
0.8
0.9
0.9
1.0
Piecewise constant
(a)
0 1 2 3 4
0.0
0.1
0.1
0.2
0.2
0.3
0.3
0.4
0.4
0.5
0.5
0.6
0.6
0.7
0.7
0.8
0.8
0.9
0.9
1.0
Piecewise linear
(b)
0 1 2 3 4 5 6
0.0
0.1
0.1
0.2
0.2
0.3
0.3
0.4
0.4
0.5
0.5
0.6
0.6
0.7
0.7
0.8
0.8
0.9
0.9
1.0
Cubic spline
(c)
Figure 11.17: Design matrix for B-splines of degree (a) 0, (b) 1 and (c) 3. We evaluate the splines on 20
inputs ranging from 0 to 1. Generated by code at figures.probml.ai/book1/11.17. Adapted from Figure 5.6 of
[MKL11]. Used with kind permission of Osvaldo Martin.
B itself. Let us first consider the piecewise constant spline, shown in Figure 11.17(a). The first
B-spline (column 1) is 1 for the first 5 observations, and otherwise 0. The second B-spline (column
0) is 0 for the first 5 observations, 1 for the second 5, and then 0 again. And so on. Now consider
the linear spline, shown in Figure 11.17(b). The first B-spline (column 0) goes from 1 to 0, the next
three splines go from 0 to 1 and back to 0; and the last spline (column 4) goes from 0 to 1; this
reflects the triangular shapes shown in the top middle panel of Figure 11.16. Finally consider the
cubic spline, shown in Figure 11.17(c). Here the pattern of activations is smoother, and the resulting
model fits will be smoother too.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.5. Regression splines * 395
800 1000 1200 1400 1600 1800 2000
year
5
6
7
8
temp
Figure 11.18: Fitting a cubic spline regression model with 15 knots to a 1d dataset. Generated by code at
figures.probml.ai/book1/11.18. Adapted from Figure 5.3 of [McE20].
11.5.2 Fitting a linear model using a spline basis
Once we have computed the design matrix B, we can use it to fit a linear model using least squares
or ridge regression. (It is usually best to use some regularization.) As an example, we consder a
dataset from [McE20, Sec 4.5], which records the the first day of the year, and the corresponding
temperature, that marks the start of the cherry blossom season in Japan. (We use this dataset since
it has interesting semi-periodic structure.) We fit the data using a cubic spline. We pick 15 knots,
spaced according to quantiles of the data. The results are shown in Figure 11.18. We see that the fit
is reasonable. Using more knots would improve the quality of the fit, but would eventually result in
overfitting. We can select the number of knots using a model selection method, such as grid search
plus cross validation.
11.5.3 Smoothing splines
Smoothing splines are related to regression splines, but use N knots, where N is the number of
datapoints. That is, they are non-parametric models, since the number of parameters grows with the
size of the data, rather than being fixed a priori. To avoid overfitting, smoothing splines rely on `2
regularization. This technique is closely related to Gaussian process regression, which we discuss in
Section 17.2.
11.5.4 Generalized additive models
A generalized additive model or GAM extends spline regression to the case of multidimensional
inputs [HT90]. It does this by ignoring interactions between the inputs, and assuming the function
has the following additive form:
f(x; θ) = α +
X
D
d=1
fd(xd) (11.107)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license396 Chapter 11. Linear Regression
0 0.2 0.4 0.6 0.8 1
-6
-5
-4
-3
-2
-1
0
1
2
3
4
least squares
laplace
student, 8=0.6
Huber, /=1.0
(a)
−3 −2 −1 0 1 2 3
−0.5
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
L2
L1
huber
(b)
Figure 11.19: (a) Illustration of robust linear regression. Generated by code at figures.probml.ai/book1/11.19.
(b) Illustration of `2, `1, and Huber loss functions with δ = 1.5. Generated by code at fig￾ures.probml.ai/book1/11.19.
where each fd is a regression or smoothing spline. This model can be fit using backfitting, which
iteratively fits each fd to the partial residuals generated by the other terms. We can extend GAMs
beyond the regression case (e.g., to classification) by using a link function, as in generalized linear
models (Chapter 12).
11.6 Robust linear regression *
It is very common to model the noise in regression models using a Gaussian distribution with zero
mean and constant variance, rn ∼ N (0, σ2
), where rn = yn − wTxn. In this case, maximizing
likelihood is equivalent to minimizing the sum of squared residuals, as we have seen. However, if
we have outliers in our data, this can result in a poor fit, as illustrated in Figure 11.19(a). (The
outliers are the points on the bottom of the figure.) This is because squared error penalizes deviations
quadratically, so points far from the line have more effect on the fit than points near to the line.
One way to achieve robustness to outliers is to replace the Gaussian distribution for the response
variable with a distribution that has heavy tails. Such a distribution will assign higher likelihood
to outliers, without having to perturb the straight line to “explain” them. We discuss several possible
alternative probability distributions for the response variable below; see Table 11.2 for a summary.
11.6.1 Laplace likelihood
In Section 2.7.3, we noted that the Laplace distribution is also robust to outliers. If we use this as
our observation model for regression, we get the following likelihood:
p(y|x, w, b) = Lap(y|wTx, b) ∝ exp(−
1
b
|y − wTx|) (11.108)
The robustness arises from the use of |y − wTx| instead of (y − wTx)
2
. Figure 11.19(a) gives an
example of the method in action.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.6. Robust linear regression * 397
Likelihood Prior Posterior Name Section
Gaussian Uniform Point Least squares 11.2.2
Student Uniform Point Robust regression 11.6.2
Laplace Uniform Point Robust regression 11.6.1
Gaussian Gaussian Point Ridge 11.3
Gaussian Laplace Point Lasso 11.4
Gaussian Gauss-Gamma Gauss-Gamma Bayesian lin. reg 11.7
Table 11.2: Summary of various likelihoods, priors and posteriors used for linear regression. The likelihood
refers to the distributional form of p(y|x, w, σ2
), and the prior refers to the distributional form of p(w). The
posterior refers to the distributional form of p(w|D). “Point” stands for the degenerate distribution δ(w − wˆ ),
where wˆ is the MAP estimate. MLE is equivalent to using a point posterior and a uniform prior.
11.6.1.1 Computing the MLE using linear programming
We can compute the MLE for this model using linear programming. As we explain in Section 8.5.3,
this is a way to solve a constrained optimization problems of the form
argmin
v
c
Tv s.t. Av ≤ b (11.109)
where v ∈ R
n is the set of n unknown parameters, c
Tv is the linear objective function we want to
minimize, and a
T
i v ≤ bi
is a set of m linear constraints we must satisfy. To apply this to our problem,
let us define v = (w1, . . . , wD, e1, . . . , eN ) ∈ R
D+N , where ei = |yi − yˆi
| is the residual error for
example i. We want to minimize the sum of the residuals, so we define c = (0, · · · , 0, 1, · · · , 1) ∈ R
D+N ,
where the first D elements are 0, and the last N elements are 1.
We need to enforce the constraint that ei = |yˆi −yi
|. In fact it is sufficient to enforce the constraint
that |wTxi − yi
| ≤ ei
, since minimizing the sum of the ei
’s will “push down” on this constraint
and make it tight. Since |a| ≤ b =⇒ −b ≤ a ≤ b, we can encode |wTxi − yi
| ≤ ei as two linear
constraints:
ei ≥ wTxi − yi (11.110)
ei ≥ −(wTxi − yi) (11.111)
We can write Equation (11.110) as
￾
xi
, 0, · · · , 0, −1, 0, · · · , 0
T
v ≤ yi (11.112)
where the first D entries are filled with xi
, and the −1 is in the (D + i)’th entry of the vector.
Similarly we can write Equation (11.111) as
￾
−xi
, 0, · · · , 0, −1, 0, · · · , 0
T
v ≤ −yi (11.113)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licen398 Chapter 11. Linear Regression
We can write these constraints in the form Av ≤ b by defining A ∈ R
2N×(N+D) as follows:
A =


x1 −1 0 0 · · · 0
−x1 −1 0 0 · · · 0
x2 0 −1 0 · · · 0
−x2 0 −1 0 · · · 0
.
.
.


(11.114)
and defining b ∈ R
2N as
b =
￾
y1, −y1, y2, −y2, · · · , yN , −yN

(11.115)
11.6.2 Student-t likelihood
In Section 2.7.1, we discussed the robustness properties of the Student distribution. To use this in a
regression context, we can just make the mean be a linear function of the inputs, as proposed in
[Zel76]:
p(y|x, w, σ2
, ν) = T (y|wTx, σ2
, ν) (11.116)
We can fit this model using SGD or EM (see [Mur22] for details).
11.6.3 Huber loss
An alternative to minimizing the NLL using a Laplace or Student likelihood is to use the Huber
loss, which is defined as follows:
`huber(r, δ) = 
r
2/2 if |r| ≤ δ
δ|r| − δ
2/2 if |r| > δ (11.117)
This is equivalent to `2 for errors that are smaller than δ, and is equivalent to `1 for larger errors.
See Figure 5.3 for a plot.
The advantage of this loss function is that it is everywhere differentiable. Consequently optimizing
the Huber loss is much faster than using the Laplace likelihood, since we can use standard smooth
optimization methods (such as SGD) instead of linear programming. Figure 11.19 gives an illustration
of the Huber loss function in action. The results are qualitatively similiar to the Laplace and Student
methods.
The parameter δ, which controls the degree of robustness, is usually set by hand, or by cross￾validation. However, [Bar19] shows how to approximate the Huber loss such that we can optimize δ
by gradient methods.
11.6.4 RANSAC
In the computer vision community, a common approach to robust regression is to use RANSAC,
which stands for “random sample consensus” [FB81]. This works as follows: we sample a small initial
set of points, fit the model to them, identify outliers wrt this model (based on large residuals), remove
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20211.7. Bayesian linear regression * 399
the outliers, and then refit the model to the inliers. We repeat this for many random initial sets and
pick the best model.
A deterministic alternative to RANSAC is the following iterative scheme: intially we assume that
all datapoints are inliers, and we fit the model to compute wˆ 0; then, for each iteration t, we identify
the outlier points as those with large residual under the model wˆ t, remove them, and refit the model
to the remaining points to get wˆ t+1. Even though this hard thresholding scheme makes the problem
nonconvex, this simple scheme can be proved to rapidly converge to the optimal estimate under some
reasonable assumptions [Muk+19; Sug+19].
11.7 Bayesian linear regression *
We have seen how to compute the MLE and MAP estimate for linear regression models under various
priors. In this section, we discuss how to compute the posterior over the parameters, p(θ|D). For
simplicity, we assume the variance is known, so we just want to compute p(w|D, σ2
). See the sequel
to this book, [Mur22], for the general case.
11.7.1 Priors
For simplicity, we will use a Gaussian prior:
p(w) = N (w|
`w,
`
Σ) (11.118)
This is a small generalization of the prior that we use in ridge regression (Section 11.3). See the
sequel to this book, [Mur22], for a discussion of other priors.
11.7.2 Posteriors
We can rewrite the likelihood in terms of an MVN as follows:
p(D|w, σ2
) = Y
N
n=1
p(yn|wTx, σ2
) = N (y|Xw, σ2
IN ) (11.119)
where IN is the N × N identity matrix. We can then use Bayes rule for Gaussians (Equation (3.37))
to derive the posterior, which is as follows:
p(w|X, y, σ2
) ∝ N (w|
`w,
`
Σ)N (y|Xw, σ2
IN ) = N (w|
aw,
a
Σ) (11.120)
aw ,
a
Σ (
`
Σ
−1 `w +
1
σ
2 XTy) (11.121)
a
Σ , (
`
Σ
−1
+
1
σ
2 XTX)
−1
(11.122)
where aw is the posterior mean, and a
Σ is the posterior covariance.
If `w= 0 and `
Σ= τ
2
I, then the posterior mean becomes aw=
1
σ2
a
Σ XTy. If we define λ =
σ
2
τ
2 , we
recover the ridge regression estimate, aw= (λI + XTX)
−1XTy, which matches Equation (11.57).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license400 Chapter 11. Linear Regression
11.7.3 Example
Suppose we have a 1d regression model of the form f(x; w) = w0 + w1x1, where the true parameters
are w0 = −0.3 and w1 = 0.5. We now perform inference p(w|D) and visualize the 2d prior and
posterior as the size of the training set N increases.
In particular, in Figure 11.20 (which inspired the front cover of this book), we plot the likelihood,
the posterior, and an approximation to the posterior predictive distribution.4 Each row plots these
distributions as we increase the amount of training data, N. We now explain each row:
• In the first row, N = 0, so the posterior is the same as the prior. In this case, our predictions are
“all over the place”, since our prior is essentially uniform.
• In the second row, N = 1, so we have seen one data point (the blue circle in the plot in the third
column). Our posterior becomes constrained by the corresponding likelihood, and our predictions
pass close to the observed data. However, we see that the posterior has a ridge-like shape, reflecting
the fact that there are many possible solutions, with different slopes/intercepts. This makes sense
since we cannot uniquely infer two parameters (w0 and w1) from one observation.
• In the third row, N = 2. In this case, the posterior becomes much narrower since we have two
constraints from the likelihood. Our predictions about the future are all now closer to the training
data.
• In the fourth (last) row, N = 100. Now the posterior is essentially a delta function, centered on
the true value of w∗ = (−0.3, 0.5), indicated by a white cross in the plots in the first and second
columns. The variation in our predictions is due to the inherent Gaussian noise with magnitude
σ
2
.
This example illustrates that, as the amount of data increases, the posterior mean estimate,
aµ= E [w|D], converges to the true value w∗ that generated the data. We thus say that the Bayesian
estimate is a consistent estimator (see Section 5.3.2 for more details). We also see that our posterior
uncertainty decreases over time. This is what we mean when we say we are “learning” about the
parameters as we see more data.
11.7.4 Computing the posterior predictive
We have discussed how to compute our uncertainty about the parameters of the model, p(w|D).
But what about the uncertainty associated with our predictions about future outputs? Using
Equation (3.38), we can show that the posterior predictive distribution at a test point x is also
Gaussian:
p(y|x, D, σ2
) = Z
N (y|x
Tw, σ2
)N (w|
aµ,
a
Σ)dw (11.123)
= N (y|
aµ
T
x,
aσ
2
(x)) (11.124)
4. To approximate this, we draw some samples from the posterior, ws ∼ N (µ, Σ), and then plot the line E [y|x, ws],
where x ranges over [−1, 1], for each sampled parameter value.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.7. Bayesian linear regression * 401
likelihood
1 0 1
w0
1
0
1
w1
prior/posterior
1 0 1
x
1
0
1
y
data space
1 0 1
w0
1
0
1
w1
1 0 1
w0
1
0
1
w1
1 0 1
x
1
0
1
y
1 0 1
w0
1
0
1
w1
1 0 1
w0
1
0
1
w1
1 0 1
x
1
0
1
y
1 0 1
w0
1
0
1
w1
1 0 1
w0
1
0
1
w1
1 0 1
x
1
0
1
y
Figure 11.20: Sequential Bayesian inference of the parameters of a linear regression model p(y|x) = N (y|w0 +
w1x1, σ2
). Left column: likelihood function for current data point. Middle column: posterior given first N
data points, p(w0, w1|x1:N , y1:N , σ2
). Right column: samples from the current posterior predictive distribution.
Row 1: prior distribution (N = 0). Row 2: after 1 data point. Row 3: after 2 data points. Row 4: after 100
data points. The white cross in columns 1 and 2 represents the true parameter value; we see that the mode
of the posterior rapidly converges to this point. The blue circles in column 3 are the observed data points.
Adapted from Figure 3.7 of [Bis06]. Generated by code at figures.probml.ai/book1/11.20.
where aσ
2
(x) , σ
2 + x
T a
Σ x is the variance of the posterior predictive distribution at point x
after seeing the N training examples. The predicted variance depends on two terms: the variance
of the observation noise, σ
2
, and the variance in the parameters, a
Σ. The latter translates into
variance about observations in a way which depends on how close x is to the training data D. This is
illustrated in Figure 11.21(b), where we see that the error bars get larger as we move away from the
training points, representing increased uncertainty. This can be important for certain applications,
such as active learning, where we choose where to collect training data (see Section 19.4).
In some cases, it is computationally intractable to compute the parameter posterior, p(w|D). In
such cases, we may choose to use a point estimate, wˆ , and then to use the plugin approximation.
This gives
p(y|x, D, σ2
) = Z
N (y|x
Tw, σ2
)δ(w − wˆ )dw = p(y|x
Twˆ , σ2
). (11.125)
We see that the posterior predictive variance is constant, and independent of the data, as illustrated in
Figure 11.21(a). If we sample a parameter from this posterior, we will always recover a single function,
as shown in Figure 11.21(c). By contrast, if we sample from the true posterior, ws ∼ p(w|D, σ2
), we
will get a range of different functions, as shown in Figure 11.21(d), which more accurately reflects
our uncertainty.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license402 Chapter 11. Linear Regression
6 4 2 0 2 4 6
20
40
60
80
100
Plugin approximation
prediction
training data
(a)
6 4 2 0 2 4 6
20
40
60
80
100
120
Posterior predictive
prediction
training data
(b)
6 4 2 0 2 4 6
20
40
60
80
100
functions sampled from plugin approximation to posterior
(c)
6 4 2 0 2 4 6
0
20
40
60
80
100
120
140
functions sampled from posterior
(d)
Figure 11.21: (a) Plugin approximation to predictive density (we plug in the MLE of the parameters) when
fitting a second degree polynomial to some 1d data. (b) Posterior predictive density, obtained by integrating
out the parameters. Black curve is posterior mean, error bars are 2 standard deviations of the posterior
predictive density. (c) 10 samples from the plugin approximation to posterior predictive distribution. (d) 10
samples from the true posterior predictive distribution. Generated by code at figures.probml.ai/book1/11.21.
11.7.5 The advantage of centering
The astute reader might notice that the shape of the 2d posterior in Figure 11.20 is an elongated
ellipse (which eventually collapses to a point as N → ∞). This implies that there is a lot of posterior
correlation between the two parameters, which can cause computational difficulties.
To understand why this happens, note that each data point induces a likelihood function corre￾sponding to a line which goes through that data point. When we look at all the data together, we see
that predictions with maximum likelihood must correspond to lines that go through the mean of the
data, (x, y). There are many such lines, but if we increase the slope, we must decrease the intercept.
Thus we can think of the set of high probability lines as spinning around the data mean, like a wheel
of fortune.5 This correlation between w0 and w1 is why the posterior has the form of a diagonal line.
(The Gaussian prior converts this into an elongated ellipse, but the posterior correlation still persists
until the sample size causes the posterior to shrink to a point.)
It can be hard to compute such elongated posteriors. One simple solution is to center the input
data, i.e., by using x
0
n = xn − x. Now the lines can pivot around the origin, reducing the posterior
5. This analogy is from [Mar18, p96].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.7. Bayesian linear regression * 403
(a) (b)
Figure 11.22: Posterior samples of p(w0, w1|D) for 1d linear regression model p(y|x, θ) = N (y|w0 +
w1x, σ2
) with a Gaussian prior. (a) Original data. (b) Centered data. Generated by code at fig￾ures.probml.ai/book1/11.22.
correlation between w0 and w1. See Figure 11.22 for an illustration. (We may also choose to divide
each xn by the standard deviation of that feature, as discussed in Section 10.2.8.)
Note that we can convert the posterior derived from fitting to the centered data back to the original
coordinates by noting that
y
0 = w
0
0 + w
0
1x
0 = w
0
0 + w
0
1
(x − x) = (w
0
0 − w
0
1x) + w
0
1x (11.126)
Thus the parameters on the uncentered data are w0 = w
0
0 − w
0
1x and w1 = w
0
1
.
11.7.6 Dealing with multicollinearity
In many datasets, the input variables can be highly correlated with each other. Including all of
them does not generally harm predictive accuracy (provided you use a suitable prior or regularizer to
prevent overfitting). However, it can make interpretation of the coefficients more difficult.
To illustrate this, we use a toy example from [McE20, Sec 6.1]. Suppose we have a dataset of N
people in which we record their heights hi
, as well as the length of their left legs li and right legs ri
.
Suppose hi ∼ N (10, 2), so the average height is h = 10 (in unspecified units). Suppose the length of
the legs is some fraction ρi ∼ Unif(0.4, 0.5) of the height, plus a bit of Gaussian noise, specifically
li ∼ N (ρihi
, 0.02) and ri ∼ N (ρihi
, 0.02).
Now suppose we want to predict the height of a person given measurement of their leg lengths.
(I did mention this is a toy example!) Since both left and right legs are noisy measurements
of the unknown quantity, it is useful to use both of them. So we use linear regression to fit
p(h|l, r) = N (h|α + βl
l + βrr, σ2
). We use vague priors, α, βl
, βr ∼ N (0, 100), and σ ∼ Expon(1).
Since the average leg length is l = 0.45h = 4.5, we might expect each β coefficient to be around
h/l = 10/4.5 = 2.2. However, the posterior marginals shown in Figure 11.23 tell a different story: we
see that the posterior mean of βl
is near 2.6, but βr is near -0.6. Thus it seems like the right leg feature
is not needed. This is because the regression coefficient for feature j encodes the value of knowing xj
given that all the other features x−j are already known, as we discussed in Section 11.2.2.1. If we
already know the left leg, the marginal value of also knowing the right leg is small. However, if we
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license404 Chapter 11. Linear Regression
4 2 0 2 4 6
sigma
br
bl
a
95.0% HDI
(a)
Figure 11.23: Posterior marginals for the parameters in the multi-leg example. Generated by code at
figures.probml.ai/book1/11.23.
7.5 5.0 2.5 0.0 2.5 5.0 7.5
br
5.0
2.5
0.0
2.5
5.0
7.5
10.0
bl
(a)
1.8 1.9 2.0 2.1 2.2
0
1
2
3
4
5 sum of bl and br
(b)
Figure 11.24: Posteriors for the multi-leg example. (a) Joint posterior p(βl, βr|D) (b) Posterior of p(βl +
βr|data). Generated by code at figures.probml.ai/book1/11.24.
rerun this example with slightly different data, we may reach the opposite conclusion, and favor the
right leg over the left.
We can gain more insight by looking at the joint distribution p(βl
, βr|D), shown in Figure 11.24a.
We see that the parameters are very highly correlated, so if βr is large, then βl
is small, and vice
versa. The marginal distribution for each parameter does not capture this. However, it does show
that there is a lot of uncertainty about each parameter, showing that they are non-identifiable.
However, their sum is well-determined, as can be seen from Figure 11.24b, where we plot p(βl +βr|D);
this is centered on 2.2, as we might expect.
This example goes to show that we must be careful trying to interpret the significance of individual
coefficient estimates in a model, since they do not mean much in isolation.
11.7.7 Automatic relevancy determination (ARD) *
Consider a linear regression model with known observation noise but unknown regression weights,
N (y|Xw, σ2
I). Suppose we use a Gaussian prior for the weights, wj ∼ N (0, 1/αj ), where αj is the
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.8. Exercises 405
precision of the j’th parameter. Now suppose we estimate the prior precisions as follows:
αˆ = argmax
α
p(y|X, α) (11.127)
where
p(y|X, α) = Z
p(y|Xw, σ2
)p(w|0, diag(α)
−1
)dw (11.128)
is the marginal likelihood. This is an example of empirical Bayes, since we are estimating the prior
from data. We can view this as as a computational shortcut to a fully Bayesian approach. However,
there are additional advantages. In particular, suppose, after estimating α, we compute the MAP
estimate
wˆ = argmax
w
N (w|0, αˆ
−1
) (11.129)
This results in a sparse estimate for wˆ , which is perhaps surprising given that the Gaussian prior for
w is not sparsity promoting. The reasons for this are explained in the sequel to this book.
This technique is known as sparse Bayesian learning [Tip01] or automatic relevancy deter￾mination (ARD) [Mac95; Nea96]. It was originally developed for neural networks (where sparsity
is applied to the first layer weights), but here we apply it to linear models. See also Section 17.4.1,
where we apply it kernelized linear models.
11.8 Exercises
Exercise 11.1 [Multi-output linear regression *]
(Source: Jaakkola.)
Consider a linear regression model with a 2 dimensional response vector yi ∈ R
2
. Suppose we have some
binary input data, xi ∈ {0, 1}. The training data is as follows:
x y
0 (−1, −1)T
0 (−1, −2)T
0 (−2, −1)T
1 (1, 1)T
1 (1, 2)T
1 (2, 1)T
Let us embed each xi into 2d using the following basis function:
φ(0) = (1, 0)T
, φ(1) = (0, 1)T
(11.130)
The model becomes
yˆ = WT φ(x) (11.131)
where W is a 2 × 2 matrix. Compute the MLE for W from the above data.
Exercise 11.2 [Centering and ridge regression]
Assume that x = 0, so the input data has been centered. Show that the optimizer of
J(w, w0) = (y − Xw − w01)
T
(y − Xw − w01) + λw
T w (11.132)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license406 Chapter 11. Linear Regression
is
wˆ0 = y (11.133)
w = (X
T X + λI)
−1X
T
y (11.134)
Exercise 11.3 [Partial derivative of the RSS *]
Let RSS(w) = ||Xw − y||2
2 be the residual sum of squares.
a. Show that
∂
∂wk
RSS(w) = akwk − ck (11.135)
ak = 2Xn
i=1
x
2
ik = 2||x:,k||2
(11.136)
ck = 2Xn
i=1
xik(yi − w
T
−kxi,−k) = 2x
T
:,krk (11.137)
where w−k = w without component k, xi,−k is xi without component k, and rk = y − wT
−kx:,−k is the
residual due to using all the features except feature k. Hint: Partition the weights into those involving k
and those not involving k.
b. Show that if ∂
∂wk
RSS(w) = 0, then
wˆk =
x
T
:,krk
||x:,k||2
(11.138)
Hence when we sequentially add features, the optimal weight for feature k is computed by computing
orthogonally projecting x:,k onto the current residual.
Exercise 11.4 [Reducing elastic net to lasso]
Define
J1(w) = |y − Xw|
2 + λ2|w|
2 + λ1|w|1 (11.139)
and
J2(w) = |y˜ − X˜ w˜ |
2 + cλ1|w|1 (11.140)
where c = (1 + λ2)
− 1
2 and
X˜ = c

X
√
λ2Id

, y˜ =

y
0d×1

(11.141)
Show
argmin J1(w) = c(argmin J2(w)) (11.142)
i.e.
J1(cw) = J2(w) (11.143)
and hence that one can solve an elastic net problem using a lasso solver on modified data.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202211.8. Exercises 407
Exercise 11.5 [Shrinkage in linear regression *]
(Source: Jaakkola.) Consider performing linear regression with an orthonormal design matrix, so ||x:,k||2
2 = 1
for each column (feature) k, and x
T
:,kx:,j = 0, so we can estimate each parameter wk separately.
Figure 10.15b plots wˆk vs ck = 2y
T x:,k, the correlation of feature k with the response, for 3 different
estimation methods: ordinary least squares (OLS), ridge regression with parameter λ2, and lasso with
parameter λ1.
a. Unfortunately we forgot to label the plots. Which method does the solid (1), dotted (2) and dashed (3)
line correspond to?
b. What is the value of λ1?
c. What is the value of λ2?
Exercise 11.6 [EM for mixture of linear regression experts]
Derive the EM equations for fitting a mixture of linear regression experts.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license12 Generalized Linear Models *
12.1 Introduction
In Chapter 10, we discussed logistic regression, which, in the binary case, corresponds to the model
p(y|x, w) = Ber(y|σ(wTx)). In Chapter 11, we discussed linear regression, which corresponds to the
model p(y|x, w) = N (y|wTx, σ2
). These are obviously very similar to each other. In particular, the
mean of the output, E [y|x, w], is a linear function of the inputs x in both cases.
It turns out that there is a broad family of models with this property, known as generalized
linear models or GLMs [MN89].
A GLM is a conditional version of an exponential family distribution (Section 3.4), in which the
natural parameters are a linear function of the input. More precisely, the model has the following
form:
p(yn|xn, w, σ2
) = exp 
ynηn − A(ηn)
σ
2
+ log h(yn, σ2
)

(12.1)
where ηn , wTxn is the (input dependent) natural parameter, A(ηn) is the log normalizer, T (y) = y
is the sufficient statistic, and σ
2
is the dispersion term.1
We will denote the mapping from the linear inputs to the mean of the output using µn = `
−1
(ηn),
where the function ` is known as the link function, and `
−1
is known as the mean function.
Based on the results in Section 3.4.3, we can show that the mean and variance of the response
variable are as follows:
E

yn|xn, w, σ2

= A
0
(ηn) , `
−1
(ηn) (12.2)
V

yn|xn, w, σ2

= A
00(ηn)σ
2
(12.3)
12.2 Examples
In this section, we give some examples of widely used GLMs.
1. Technically speaking, GLMs use a slight extension of the natural exponential family known as the exponential
dispersion family. For a scalar variable, this has the form p(y|η, σ2
) = h(y, σ2
) exp h
ηy−A(η)
σ2
i
. Here σ
2
is called
the dispersion parameter. For fixed σ
2
, this is a natural exponential family.410 Chapter 12. Generalized Linear Models *
12.2.1 Linear regression
Recall that linear regression has the form
p(yn|xn, w, σ2
) = 1
√
2πσ2
exp(−
1
2σ
2
(yn − wTxn)
2
) (12.4)
Hence
log p(yn|xn, w, σ2
) = −
1
2σ
2
(yn − ηn)
2 −
1
2
log(2πσ2
) (12.5)
where ηn = wTxn. We can write this in GLM form as follows:
log p(yn|xn, w, σ2
) = ynηn −
η
2
n
2
σ
2
−
1
2

y
2
n
σ
2
+ log(2πσ2
)

(12.6)
We see that A(ηn) = η
2
n/2 and hence
E [yn] = ηn = wTxn (12.7)
V [yn] = σ
2
(12.8)
12.2.2 Binomial regression
If the response variable is the number of successes in Nn trials, yn ∈ {0, . . . , Nn}, we can use
binomial regression, which is defined by
p(yn|xn, Nn, w) = Bin(yn|σ(wTxn), Nn) (12.9)
We see that binary logistic regression is the special case when Nn = 1.
The log pdf is given by
log p(yn|xn, Nn, w) = yn log µn + (Nn − yn) log(1 − µn) + log 
Nn
yn

(12.10)
= yn log( µn
1 − µn
) + Nn log(1 − µn) + log 
Nn
yn

(12.11)
where µn = σ(ηn). To rewrite this in GLM form, let us define
ηn , log 
µn
(1 − µn)

= log "
1
1 + e−wTxn
1 + e
−wTxn
e−wTxn
#
= log 1
e−wTxn
= wTxn (12.12)
Hence we can write binomial regression in GLM form as follows
log p(yn|xn, Nn, w) = ynηn − A(ηn) + h(yn) (12.13)
where h(yn) = log 
Nn
yn

and
A(ηn) = −Nn log(1 − µn) = Nn log(1 + e
ηn ) (12.14)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202212.3. GLMs with non-canonical link functions 411
Hence
E [yn] = dA
dηn
=
Nne
ηn
1 + e
ηn
=
Nn
1 + e−ηn
= Nnµn (12.15)
and
V [yn] = d
2A
dη2
n
= Nnµn(1 − µn) (12.16)
12.2.3 Poisson regression
If the response variable is an integer count, yn ∈ {0, 1, . . .}, we can use Poisson regression, which
is defined by
p(yn|xn, w) = Poi(yn| exp(wTxn)) (12.17)
where
Poi(y|µ) = e
−µ µ
y
y!
(12.18)
is the Poisson distribution. Poisson regression is widely used in bio-statistical applications, where
yn might represent the number of diseases of a given person or place, or the number of reads at a
genomic location in a high-throughput sequencing context (see e.g., [Kua+09]).
The log pdf is given by
log p(yn|xn, w) = yn log µn − µn − log(yn!) (12.19)
where µn = exp(wTxn). Hence in GLM form we have
log p(yn|xn, w) = ynηn − A(ηn) + h(yn) (12.20)
where ηn = log(µn) = wTxn, A(ηn) = µn = e
ηn , and h(yn) = − log(yn!). Hence
E [yn] = dA
dηn
= e
ηn = µn (12.21)
and
V [yn] = d
2A
dη2
n
= e
ηn = µn (12.22)
12.3 GLMs with non-canonical link functions
We have seen how the mean parameters of the output distribution are given by µ = `
−1
(η), where
the function ` is the link function. There are several choices for this function, as we now discuss.
The canonical link function ` satisfies the property that θ = `(µ), where θ are the canonical
(natural) parameters. Hence
θ = `(µ) = `(`
−1
(η)) = η (12.23)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license412 Chapter 12. Generalized Linear Models *
This is what we have assumed so far. For example, for the Bernoulli distribution, the canonical
parameter is the log-odds θ = log(µ/(1 − µ)), which is given by the logit transform
θ = `(µ) = logit(µ) = log 
µ
1 − µ

(12.24)
The inverse of this is the sigmoid or logistic funciton µ = σ(θ) = 1/(1 + e
−θ
).
However, we are free to use other kinds of link function. For example, the probit link function
has the form
η = `(µ) = Φ−1
(µ) (12.25)
Another link function that is sometimes used for binary responses is the complementary log-log
function
η = `(µ) = log(− log(1 − µ)) (12.26)
This is used in applications where we either observe 0 events (denoted by y = 0) or one or more
(denoted by y = 1), where events are assumed to be governed by a Poisson distribution with rate λ.
Let E be the number of events. The Poisson assumption means p(E = 0) = exp(−λ) and hence
p(y = 0) = (1 − µ) = p(E = 0) = exp(−λ) (12.27)
Thus λ = − log(1 − µ). When λ is a function of covariates, we need to ensure it is positive, so we use
λ = e
η
, and hence
η = log(λ) = log(− log(1 − µ)) (12.28)
12.4 Maximum likelihood estimation
GLMs can be fit using similar methods to those that we used to fit logistic regression. In particular,
the negative log-likelihood has the following form (ignoring constant terms):
NLL(w) = − log p(D|w) = −
1
σ
2
X
N
n=1
`n (12.29)
where
`n , ηnyn − A(ηn) (12.30)
where ηn = wTxn. For notational simplicity, we will assume σ
2 = 1.
We can compute the gradient for a single term as follows:
gn ,
∂`n
∂w
=
∂`n
∂ηn
∂ηn
∂w
= (yn − A
0
(ηn))xn = (yn − µn)xn (12.31)
where µn = f(wTx), and f is the inverse link function that maps from canonical parameters to
mean parameters. For example, in the case of logistic regression, f(ηn) = σ(ηn), so we recover
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202212.5. Worked example: predicting insurance claims 413
0 5 10 15 20 25 30
y (observed Frequency)
10
0
10
1
10
2
10
3
10
4
10
5
#samples
Data
1 0 1 2 3 4
y_pred (predicted expected Frequency)
DummyRegressor
1 0 1 2 3 4
y_pred (predicted expected Frequency)
Ridge
1 0 1 2 3 4
y_pred (predicted expected Frequency)
PoissonRegressor
Figure 12.1: Predictions of insurance claim rates on the test set. (a) Data. (b) Constant predictor. (c) Linear
regression. (d) Poisson regression. Generated by code at figures.probml.ai/book1/12.1.
Equation (10.21). This gradient expression can be used inside SGD, or some other gradient method,
in the obvious way.
The Hessian is given by
H =
∂
2
∂w∂wT
NLL(w) = −
X
N
n=1
∂gn
∂wT
(12.32)
where
∂gn
∂wT
=
∂gn
∂µn
∂µn
∂wT
= −xnf
0
(wTxn)x
T
n
(12.33)
Hence
H =
X
N
n=1
f
0
(ηn)xnx
T
n
(12.34)
For example, in the case of logistic regression, f(ηn) = σ(ηn), and f
0
(ηn) = σ(ηn)(1 − σ(ηn)), so we
recover Equation (10.23). In general, we see that the Hessian is positive definite, since f
0
(ηn) > 0;
hence the negative log likelihood is convex, so the MLE for a GLM is unique (assuming f(ηn) > 0
for all n).
Based on the above results, we can fit GLMs using gradient based solvers in a manner that is very
similar to how we fit logistic regression models.
12.5 Worked example: predicting insurance claims
In this section, we give an example of predicting insurance claims using linear and Poisson regression.2
.
The goal is to predict the expected number of insurance claims per year following car accidents. The
dataset consists of 678k examples with 9 features, such as driver age, vehicle age, vehicle power,
2. This example is from https://scikit-learn.org/stable/auto_examples/linear_model/plot_poisson_
regression_non_normal_loss.html
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license414 Chapter 12. Generalized Linear Models *
Name MSE MAE Deviance
Dummy 0.564 0.189 0.625
Ridge 0.560 0.177 0.601
Poisson 0.560 0.186 0.594
Table 12.1: Performance metrics on the test set. MSE = mean squared error. MAE = mean absolute error.
Deviance = Poisson deviance.
etc. The target is the frequency of claims, which is the number of claims per policy divided by the
exposure (i.e., the duration of the policy in years).
We plot the test set in Figure 12.1(a). We see that for 94% of the policies, no claims are made, so
the data has lots of 0s, as is typical for count and rate data. The average frequency of claims is 10%.
This can be converted into a dummy model, which always predicts this constant. This results in the
predictions shown in Figure 12.1(b). The goal is to do better than this.
A simple approach is to use linear regression, combined with some simple feature engineering
(binning the continuous values, and one-hot encoding the categoricals). (We use a small amount of `2
regularization, so technically this is ridge regression.) This gives the results shown in Figure 12.1(c).
This is better than the baseline, but still not very good. In particular, it can predict negative
outcomes, and fails to capture the long tail.
We can do better using Poisson regression, using the same features but a log link function. The
results are shown in Figure 12.1(d). We see that predictions are much better.
An interesting question is how to quantify performance in this kind of problem. If we use mean
squared error, or mean absolute error, we may conclude from Table 12.1 that ridge regression is
better than Poisson regression, but this is clearly not true, as shown in Figure 12.1. Instead it is
more common to measure performance using the deviance, which is defined as
D(y, µˆ) = 2X
i
(log p(yi
|µ
∗
i
) − log p(yi
|µi)) (12.35)
where µi
is the predicted parameters for the i’th example (based on the input features xi and the
training set D), and µ
∗
i
is the optimal parameter estimated by fitting the model just to the true
output yi
. (This is the so-called saturated model, that perfectly fits the test set.) In the case of
Poisson regression, we have µ
∗
i = yi
. Hence
D(y, µ) = 2X
i
[(yi
log yi − yi − log(yi
!)) − (yi
log ˆµi − µˆi − log(yi
!))] (12.36)
= 2X
i

(yi
log yi
µˆi
+ ˆµi − yi

(12.37)
By this metric, the Poisson model is clearly better (see last column of Table 12.1).
We can also compute a calibration plot, which plots the actual frequency vs the predicted
frequency. To compute this, we bin the predictions into intervals, and then count the empirical
frequency of claims for all examples whose predicted frequency falls into that bin. The results
are shown in Figure 12.2. We see that the constant baseline is well calibrated, but of course it is
not very accurate. The ridge model is miscalibrated in the low frequency regime. In particular, it
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202212.5. Worked example: predicting insurance claims 415
0.0 0.2 0.4 0.6 0.8 1.0
Fraction of samples sorted by y_pred
0.0
0.1
0.2
0.3
0.4
0.5
Mean Frequency (y_pred)
DummyRegressor()
predictions
observations
0.0 0.2 0.4 0.6 0.8 1.0
Fraction of samples sorted by y_pred
0.0
0.1
0.2
0.3
0.4
0.5
Mean Frequency (y_pred)
Ridge(alpha=1e-06)
predictions
observations
0.0 0.2 0.4 0.6 0.8 1.0
Fraction of samples sorted by y_pred
0.0
0.1
0.2
0.3
0.4
0.5
Mean Frequency (y_pred)
PoissonRegressor(alpha=1e-12, max_iter=300)
predictions
observations
Figure 12.2: Calibration plot for insurance claims prediction. Generated by code at fig￾ures.probml.ai/book1/12.2.
underestimates the total number of claims in the test set to be 10,693, whereas the truth is 11,935.
The Poisson model is better calibrated (i.e., when it predicts examples will have a high claim rate,
they do in fact have a high claim rate), and it predicts the total number of claims to be 11,930.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensePart III
Deep Neural Networks13 Neural Networks for Structured Data
13.1 Introduction
In Part II, we discussed linear models for regression and classification. In particular, in Chapter 10,
we discussed logistic regression, which, in the binary case, corresponds to the model p(y|x, w) =
Ber(y|σ(wTx)), and in the multiclass case corresponds to the model p(y|x,W) = Cat(y|S(Wx)). In
Chapter 11, we discussed linear regression, which corresponds to the model p(y|x, w) = N (y|wTx, σ2
).
And in Chapter 12, we discussed generalized linear models, which generalizes these models to other
kinds of output distributions, such as Poisson. However, all these models make the strong assumption
that the input-output mapping is linear.
A simple way of increasing the flexibility of such models is to perform a feature transformation, by
replacing x with φ(x). For example, we can use a polynomial transform, which in 1d is given by
φ(x) = [1, x, x2
, x3
, . . .], as we discussed in Section 1.2.2.2. This is sometimes called basis function
expansion. The model now becomes
f(x; θ) = Wφ(x) + b (13.1)
This is still linear in the parameters θ = (W, b), which makes model fitting easy (since the negative
log-likelihood is convex). However, having to specify the feature transformation by hand is very
limiting.
A natural extension is to endow the feature extractor with its own parameters, θ2, to get
f(x; θ) = Wφ(x; θ2) + b (13.2)
where θ = (θ1, θ2) and θ1 = (W, b). We can obviously repeat this process recursively, to create more
and more complex functions. If we compose L functions, we get
f(x; θ) = fL(fL−1(· · ·(f1(x))· · ·)) (13.3)
where f`(x) = f(x; θ`) is the function at layer `. This is the key idea behind deep neural networks
or DNNs.
The term “DNN” actually encompasses a larger family of models, in which we compose differentiable
functions into any kind of DAG (directed acyclic graph), mapping input to output. Equation (13.3) is
the simplest example where the DAG is a chain. This is known as a feedforward neural network
(FFNN) or multilayer perceptron (MLP).
An MLP assumes that the input is a fixed-dimensional vector, say x ∈ R
D. It is common to
call such data “structured data” or “tabular data”, since the data is often stored in an N × D420 Chapter 13. Neural Networks for Structured Data
x1 x2 y
0 0 0
0 1 1
1 0 1
1 1 0
Table 13.1: Truth table for the XOR (exclusive OR) function, y = x1 Y x2.
design matrix, where each column (feature) has a specific meaning, such as height, weight, age,
etc. In later chapters, we discuss other kinds of DNNs that are more suited to “unstructured
data” such as images and text, where the input data is variable sized, and each individual element
(e.g., pixel or word) is often meaningless on its own.1
In particular, in Chapter 14, we discuss
convolutional neural networks (CNN), which are designed to work with images; in Chapter 15,
we discuss recurrent neural networks (RNN) and transformers, which are designed to work
with sequences; and in Chapter 23, we discuss graph neural networks (GNN), which are designed
to work with graphs.
Although DNNs can work well, there are often a lot of engineering details that need to be addressed
to get good performance. Some of these details are discussed in the supplementary material to
this book, available at probml.ai. There are also various other books that cover this topic in more
depth (e.g., [Zha+20; Cho21; Gér19; GBC16]), as well as a multitude of online courses. For a more
theoretical treatment, see e.g., [Ber+21; Cal20; Aro+21; RY21].
13.2 Multilayer perceptrons (MLPs)
In Section 10.2.5, we explained that a perceptron is a deterministic version of logistic regression.
Specifically, it is a mapping of the following form:
f(x; θ) = I
￾
wTx + b ≥ 0

= H(wTx + b) (13.4)
where H(a) is the heaviside step function, also known as a linear threshold function. Since
the decision boundaries represented by perceptrons are linear, they are very limited in what they can
represent. In 1969, Marvin Minsky and Seymour Papert published a famous book called Perceptrons
[MP69] in which they gave numerous examples of pattern recognition problems which perceptrons
cannot solve. We give a specific example below, before discussing how to solve the problem.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20213.2. Multilayer perceptrons (MLPs) 421
−0.2 0.0 0.2 0.4 0.6 0.8 1.0 1.2 −0.2
0.0
0.2
0.4
0.6
0.8
1.0
1.2
Activation function: heaviside
(a)
-1.5 +1 +1 +1 +1 -0.5
-0.5 -1 +1
1 x1 x2 1
1 h1 h2
y
(b)
Figure 13.1: (a) Illustration of the fact that the XOR function is not linearly separable, but can be separated
by the two layer model using Heaviside activation functions. Adapted from Figure 10.6 of [Gér19]. Generated
by code at figures.probml.ai/book1/13.1. (b) A neural net with one hidden layer, whose weights have been
manually constructed to implement the XOR function. h1 is the AND function and h2 is the OR function.
The bias terms are implemented using weights from constant nodes with the value 1.
13.2.1 The XOR problem
One of the most famous examples from the Perceptrons book is the XOR problem. Here the goal
is to learn a function that computes the exclusive OR of its two binary inputs. The truth table for
this function is given in Table 13.1. We visualize this function in Figure 13.1a. It is clear that the
data is not linearly separable, so a perceptron cannot represent this mapping.
However, we can overcome this problem by stacking multiple perceptrons on top of each other.
This is called a multilayer perceptron (MLP). For example, to solve the XOR problem, we can
use the MLP shown in Figure 13.1b. This consists of 3 perceptrons, denoted h1, h2 and y. The nodes
marked x are inputs, and the nodes marked 1 are constant terms. The nodes h1 and h2 are called
hidden units, since their values are not observed in the training data.
The first hidden unit computes h1 = x1 ∧ x2 by using appropriately set weights. (Here ∧ is the
AND operation.) In particular, it has inputs from x1 and x2, both weighted by 1.0, but has a bias
term of -1.5 (this is implemented by a “wire” with weight -1.5 coming from a dummy node whose
value is fixed to 1). Thus h1 will fire iff x1 and x2 are both on, since then
wT
1x − b1 = [1.0, 1.0]T
[1, 1] − 1.5 = 0.5 > 0 (13.5)
1. The term “unstructured data” is a bit misleading, since images and text do have structure. For example, neighboring
pixels in an image are highly correlated, as are neighboring words in a sentence. Indeed, it is precisely this structure
that is exploited (assumed) by CNNs and RNNs. By contrast, MLPs make no assumptions about their inputs. This is
useful for applications such as tabular data, where the structure (dependencies between the columns) is usually not
obvious, and thus needs to be learned. We can also apply MLPs to images and text, as we will see, but performance
will usually be worse compared to specialized models, such as as CNNs and RNNs. (There are some exceptions, such
as the MLP-mixer model of [Tol+21], which is an unstructured model that can learn to perform well on image and
text data, but such models need massive datasets to overcome their lack of inductive bias.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license422 Chapter 13. Neural Networks for Structured Data
Similarly, the second hidden unit computes h2 = x1 ∨ x2, where ∨ is the OR operation, and the third
computes the output y = h1 ∧ h2, where h = ¬h is the NOT (logical negation) operation. Thus y
computes
y = f(x1, x2) = (x1 ∧ x2) ∧ (x1 ∨ x2) (13.6)
This is equivalent to the XOR function.
By generalizing this example, we can show that an MLP can represent any logical function.
However, we obviously want to avoid having to specify the weights and biases by hand. In the rest of
this chapter, we discuss ways to learn these parameters from data.
13.2.2 Differentiable MLPs
The MLP we discussed in Section 13.2.1 was defined as a stack of perceptrons, each of which involved
the non-differentiable Heaviside function. This makes such models difficult to train, which is why
they were never widely used. However, suppose we replace the Heaviside function H : R → {0, 1}
with a differentiable activation function ϕ : R → R. More precisely, we define the hidden units
zl at each layer l to be a linear transformation of the hidden units at the previous layer passed
elementwise through this activation function:
zl = fl(zl−1) = ϕl (bl + Wlzl−1) (13.7)
or, in scalar form,
zkl = ϕl

bkl +
K
Xl−1
j=1
wjklzjl−1

 (13.8)
The quantity that is passed to the activation function is called the pre-activations:
al = bl + Wlzl−1 (13.9)
so zl = ϕl(al).
If we now compose L of these functions together, as in Equation (13.3), then we can compute
the gradient of the output wrt the parameters in each layer using the chain rule, also known as
backpropagation, as we explain in Section 13.3. (This is true for any kind of differentiable activation
function, although some kinds work better than others, as we discuss in Section 13.2.3.) We can
then pass the gradient to an optimizer, and thus minimize some training objective, as we discuss in
Section 13.4. For this reason, the term “MLP” almost always refers to this differentiable form of the
model, rather than the historical version with non-differentiable linear threshold units.
13.2.3 Activation functions
We are free to use any kind of differentiable activation function we like at each layer. However, if we
use a linear activation function, ϕ`(a) = c`a, then the whole model reduces to a regular linear model.
To see this, note that Equation (13.3) becomes
f(x; θ) = WLcL(WL−1cL−1(· · ·(W1x)· · ·)) ∝ WLWL−1 · · ·W1x = W0x (13.10)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.2. Multilayer perceptrons (MLPs) 423
4 2 0 2 4
0.2
0.0
0.2
0.4
0.6
0.8
1.0
1.2
Saturating
Saturating
Linear
Sigmoid activation function
(a)
4 2 0 2 4
1.0
0.5
0.0
0.5
1.0
Activation functions
Sigmoid
Tanh
ReLU
(b)
Figure 13.2: (a) Illustration of how the sigmoid function is linear for inputs near 0, but saturates for large
positive and negative inputs. Adapted from 11.1 of [Gér19]. (b) Plots of some neural network activation
functions. Generated by code at figures.probml.ai/book1/13.2.
where we dropped the bias terms for notational simplicity. For this reason, it is important to use
nonlinear activation functions.
In the early days of neural networks, a common choice was to use a sigmoid (logistic) function,
which can be seen as a smooth approximation to the Heaviside function used in a perceptron:
σ(a) = 1
1 + e−a
(13.11)
However, as shown in Figure 13.2a, the sigmoid function saturates at 1 for large positive inputs,
and at 0 for large negative inputs. Another common choice is the tanh function, which has a similar
shape, but saturates at -1 and +1. See Figure 13.2b.
In the saturated regimes, the gradient of the output wrt the input will be close to zero, so any
gradient signal from higher layers will not be able to propagate back to earlier layers. This is called
the vanishing gradient problem, and it makes it hard to train the model using gradient descent
(see Section 13.4.2 for details). One of the keys to being able to train very deep models is to use
non-saturating activation functions. Several different functions have been proposed. The most
common is rectified linear unit or ReLU, proposed in [GBB11; KSH12]. This is defined as
ReLU(a) = max(a, 0) = aI(a > 0) (13.12)
The ReLU function simply “turns off” negative inputs, and passes positive inputs unchanged: see
Figure 13.2b for a plot, and Section 13.4.3 for more details.
13.2.4 Example models
MLPs can be used to perform classification and regression for many kinds of data. We give some
examples below.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license424 Chapter 13. Neural Networks for Structured Data
Figure 13.3: An MLP with 2 hidden layers applied to a set of 2d points from 2 classes, shown in the top left
corner. The visualizations associated with each hidden unit show the decision boundary at that part of the
network. The final output is shown on the right. The input is x ∈ R
2
, the first layer activations are z1 ∈ R
4
, the
second layer activations are z2 ∈ R
2
, and the final logit is a3 ∈ R, which is converted to a probability using the
sigmoid function. This is a screenshot from the interactive demo at http: // playground. tensorflow. org .
13.2.4.1 MLP for classifying 2d data into 2 categories
Figure 13.3 gives an illustration of an MLP with two hidden layers applied to a 2d input vector,
corresponding to points in the plane, coming from two concentric circles. This model has the following
form:
p(y|x; θ) = Ber(y|σ(a3)) (13.13)
a3 = wT
3 z2 + b3 (13.14)
z2 = ϕ(W2z1 + b2) (13.15)
z1 = ϕ(W1x + b1) (13.16)
Here a3 is the final logit score, which is converted to a probability via the sigmoid (logistic) function.
The value a3 is computed by taking a linear combination of the 2 hidden units in layer 2, using
a3 = wT
3 z2 + b3. In turn, layer 2 is computed by taking a nonlinear combination of the 4 hidden units
in layer 1, using z2 = ϕ(W2z1+b2). Finally, layer 1 is computed by taking a nonlinear combination of
the 2 input units, using z1 = ϕ(W1x+b1). By adjusting the parameters, θ = (W1, b1,W2, b2, w3, b3),
to minimize the negative log likelihood, we can fit the training data very well, despite the highly
nonlinear nature of the decision boundary. (You can find an interactive version of this figure at
http://playground.tensorflow.org.)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.2. Multilayer perceptrons (MLPs) 425
Model: "sequential"
_________________________________________________________________
Layer (type) Output Shape Param #
=================================================================
flatten (Flatten) (None, 784) 0
_________________________________________________________________
dense (Dense) (None, 128) 100480
_________________________________________________________________
dense_1 (Dense) (None, 128) 16512
_________________________________________________________________
dense_2 (Dense) (None, 10) 1290
=================================================================
Total params: 118,282
Trainable params: 118,282
Non-trainable params: 0
Table 13.2: Structure of the MLP used for MNIST classification. Note that 100, 480 = (784 + 1) × 128, and
16, 512 = (128 + 1) × 128. Generated by mlp_mnist_tf.ipynb.
13.2.4.2 MLP for image classification
To apply an MLP to image classification, we need to “flatten” the 2d input into 1d vector. We can
then use a feedforward architecture similar to the one described in Section 13.2.4.1. For example,
consider building an MLP to classifiy MNIST digits (Section 3.5.2). These are 28 × 28 = 784-
dimensional. If we use 2 hidden layers with 128 units each, followed by a final 10 way softmax layer,
we get the model shown in Table 13.2.
We show some predictions from this model in Figure 13.4. We train it for just two “epochs” (passes
over the dataset), but already the model is doing quite well, with a test set accuracy of 97.1%.
Furthermore, the errors seem sensible, e.g., 9 is mistaken as a 3. Training for more epochs can further
improve test accuracy.
In Chapter 14 we discuss a different kind of model, called a convolutional neural network, which
is better suited to images. This gets even better performance and uses fewer parameters, by
exploiting prior knowledge about the spatial structure of images. By contrast, with an MLP, we
can randomly shuffle (permute) the pixels without affecting the output (assuming we use the same
random permutation for all inputs).
13.2.4.3 MLP for text classification
To apply MLPs to text classification, we need to convert the variable-length sequence of words
v1, . . . , vT (where each vt is a one-hot vector of length V , where V is the vocabulary size) into a
fixed dimensional vector x. The easiest way to do this is as follows. First we treat the input as an
unordered bag of words (Section 1.5.4.1), {vt}. The first layer of the model is a E × V embedding
matrix W1, which converts each sparse V -dimensional vector to a dense E-dimensional embedding,
et = W1vt (see Section 20.5 for more details on word embeddings). Next we convert this set of T
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license426 Chapter 13. Neural Networks for Structured Data
(a) (b)
Figure 13.4: Results of applying an MLP (with 2 hidden layers with 128 units and 1 output layer with 10
units) to some MNIST images (cherry picked to include some errors). Red is incorrect, blue is correct. (a)
After 1 epoch of training. (b) After 2 epochs. Generated by code at figures.probml.ai/book1/13.4.
E-dimensional embeddings into a fixed-sized vector using global average pooling, e =
1
T
PT
t=1 et.
This can then be passed as input to an MLP. For example, if we use a single hidden layer, and a
logistic output (for binary classification), we get
p(y|x; θ) = Ber(y|σ(wT
3h + b3)) (13.17)
h = ϕ(W2e + b2) (13.18)
e =
1
T
X
T
t=1
et (13.19)
et = W1vt (13.20)
If we use a vocabulary size of V = 1000, an embedding size of E = 16, and a hidden layer of size
16, we get the model shown in Table 13.3. If we apply this to the IMDB movie review sentiment
classification dataset discussed in Section 1.5.2.1, we get 86% on the validation set.
We see from Table 13.3 that the model has a lot of parameters, which can result in overfitting,
since the IMDB training set only has 25k examples. However, we also see that most of the parameters
are in the embedding matrix, so instead of learning these in a supervised way, we can perform
unsupervised pre-training of word embedding models, as we discuss in Section 20.5. If the embedding
matrix W1 is fixed, we just have to fine-tune the parameters in layers 2 and 3 for this specific labeled
task, which requires much less data. (See also Chapter 19, where we discuss general techniques for
training with limited labeled data.)
13.2.4.4 MLP for heteroskedastic regression
We can also use MLPs for regression. Figure 13.5 shows how we can make a model for heteroskedastic
nonlinear regression. (The term “heteroskedastic” just means that the predicted output variance
is input-dependent, as discussed in Section 2.6.3.) This function has two outputs which compute
fµ(x) = E [y|x, θ] and fσ(x) = p
V [y|x, θ]. We can share most of the layers (and hence parameters)
between these two functions by using a common “backbone” and two output “heads”, as shown in
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.2. Multilayer perceptrons (MLPs) 427
Model: "sequential"
_________________________________________________________________
Layer (type) Output Shape Param #
=================================================================
embedding (Embedding) (None, None, 16) 160000
_________________________________________________________________
global_average_pooling1d (Gl (None, 16) 0
_________________________________________________________________
dense (Dense) (None, 16) 272
_________________________________________________________________
dense_1 (Dense) (None, 1) 17
=================================================================
Total params: 160,289
Trainable params: 160,289
Non-trainable params: 0
Table 13.3: Structure of the MLP used for IMDB review classification. We use a vocabulary size of V = 1000,
an embedding size of E = 16, and a hidden layer of size 16. The embedding matrix W1 has size 10, 000 × 16,
the hidden layer (labeled “dense”) has a weight matrix W2 of size 16 × 16 and bias b2 of size 16 (note that
16 × 16 + 16 = 272), and the final layer (labeled “dense_1”) has a weight vector w3 of size 16 and a bias b3
of size 1. The global average pooling layer has no free parameters. Generated by mlp_imdb_tf.ipynb.
y
σ
x µ
Figure 13.5: Illustration of an MLP with a shared “backbone” and two output “heads”, one for predicting
the mean and one for predicting the variance. From https: // brendanhasz. github. io/ 2019/ 07/ 23/
bayesian-density-net. html . Used with kind permission of Brendan Hasz.
Figure 13.5. For the µ head, we use a linear activation, ϕ(a) = a. For the σ head, we use a softplus
activation, ϕ(a) = σ+(a) = log(1 + e
a
). If we use linear heads and a nonlinear backbone, the overall
model is given by
p(y|x, θ) = N
￾
y|wT
µf(x; wshared), σ+(wT
σf(x; wshared))
(13.21)
Figure 13.6 shows the advantage of this kind of model on a dataset where the mean grows linearly
over time, with seasonal oscillations, and the variance increases quadratically. (This is a simple
example of a stochastic volatility model; it can be used to model financial data, as well as the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens428 Chapter 13. Neural Networks for Structured Data
20 10 0 10 20 30 40 50 60
2
0
2
4
6
8
(a)
20 10 0 10 20 30 40 50 60
2
0
2
4
6
8
(b)
Figure 13.6: Illustration of predictions from an MLP fit using MLE to a 1d regression dataset with growing
noise. (a) Output variance is input-dependent, as in Figure 13.5. (b) Mean is computed using same model as
in (a), but output variance is treated as a fixed parameter σ
2
, which is estimated by MLE after training, as in
Section 11.2.3.6. Generated by code at figures.probml.ai/book1/13.6.
(a) (b)
Figure 13.7: A decomposition of R
2
into a finite set of linear decision regions produced by an MLP with
ReLU activations with (a) one hidden layer of 25 hidden units and (b) two hidden layers. From Figure 1 of
[HAB19]. Used with kind permission of Maksym Andriuschenko.
global temperature of the earth, which (due to climate change) is increasing in mean and in variance.)
We see that a regression model where the output variance σ
2
is treated as a fixed (input-independent)
parameter will sometimes be underconfident, since it needs to adjust to the overall noise level, and
cannot adapt to the noise level at each point in input space.
13.2.5 The importance of depth
One can show that an MLP with one hidden layer is a universal function approximator, meaning
it can model any suitably smooth function, given enough hidden units, to any desired level of accuracy
[HSW89; Cyb89; Hor91]. Intuitively, the reason for this is that each hidden unit can specify a half
plane, and a sufficiently large combination of these can “carve up” any region of space, to which we
can associate any response (this is easiest to see when using piecewise linear activation functions, as
shown in Figure 13.7).
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.2. Multilayer perceptrons (MLPs) 429
However, various arguments, both experimental and theoretical (e.g., [Has87; Mon+14; Rag+17;
Pog+17]), have shown that deep networks work better than shallow ones. The reason is that later
layers can leverage the features that are learned by earlier layers; that is, the function is defined in a
compositional or hierarchical way. For example, suppose we want to classify DNA strings, and
the positive class is associated with the regular expression *AA??CGCG??AA*. Although we could fit
this with a single hidden layer model, intuitively it will be easier to learn if the model first learns
to detect the AA and CG “motifs” using the hidden units in layer 1, and then uses these features
to define a simple linear classifier in layer 2, analogously to how we solved the XOR problem in
Section 13.2.1.
13.2.6 The “deep learning revolution”
Although the ideas behind DNNs date back several decades, it was not until the 2010s that they
started to become very widely used. The first area to adopt these methods was the field of automatic
speech recognition (ASR), based on breakthrough results in [Dah+11]. This approach rapidly became
the standard paradigm, and was widely adopted in academia and industry [Hin+12].
However, the moment that got the most attention was when [KSH12] showed that deep CNNs
could significantly improve performance on the challenging ImageNet image classification benchmark,
reducing the error rate from 26% to 16% in a single year (see Figure 1.14b); this was a huge jump
compared to the previous rate of progress of about 2% reduction per year.
The “explosion” in the usage of DNNs has several contributing factors. One is the availability
of cheap GPUs (graphics processing units); these were originally developed to speed up image
rendering for video games, but they can also massively reduce the time it takes to fit large CNNs,
which involve similar kinds of matrix-vector computations. Another is the growth in large labeled
datasets, which enables us to fit complex function approximators with many parameters without
overfitting. (For example, ImageNet has 1.3M labeled images, and is used to fit models that have
millions of parameters.) Indeed, if deep learning systems are viewed as “rockets”, then large datasets
have been called the fuel.2
Motivated by the outstanding empirical success of DNNs, various companies started to become
interested in this technology. This had led to the development of high quality open-source software
libraries, such as Tensorflow (made by Google), PyTorch (made by Facebook), and MXNet (made
by Amazon). These libraries support automatic differentiation (see Section 13.3) and scalable
gradient-based optimization (see Section 8.4) of complex differentiable functions. We will use some
of these libraries in various places throughout the book to implement a variety of models, not just
DNNs.3
More details on the history of the “deep learning revolution” can be found in e.g., [Sej18; Met21].
13.2.7 Connections with biology
In this section, we discuss the connections between the kinds of neural networks we have discussed
above, known as artificial neural networks or ANNs, and real neural networks. The details on
2. This popular analogy is due to Andrew Ng, who mentioned it in a keynote talk at the GPU Technology Conference
(GTC) in 2015. His slides are available at https://bit.ly/38RTxzH.
3. Note, however, that some have argued (see e.g., [BI19]) that current libraries are too inflexible, and put too much
emphasis on methods based on dense matrix-vector multiplication, as opposed to more general algorithmic primitives.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license430 Chapter 13. Neural Networks for Structured Data
Figure 13.8: Illustration of two neurons connected together in a “circuit”. The output axon of the left neuron
makes a synaptic connection with the dendrites of the cell on the right. Electrical charges, in the form of ion
flows, allow the cells to communicate. From https: // en. wikipedia. org/ wiki/ Neuron . Used with kind
permission of Wikipedia author BruceBlaus.
how real biological brains work are quite complex (see e.g., [Kan+12]), but we can give a simple
“cartoon”.
We start by considering a model of a single neuron. To a first approximation, we can say that
whether neuron k fires, denoted by hk ∈ {0, 1}, depends on the activity of its inputs, denoted by
x ∈ R
D, as well as the strength of the incoming connections, which we denote by wk ∈ R
D. We
can compute a weighted sum of the inputs using ak = wT
kx. These weights can be viewed as “wires”
connecting the inputs xd to neuron hk; these are analogous to dendrites in a real neuron (see
Figure 13.8). This weighted sum is then compared to a threshold, bk, and if the activation exceeds
the threshold, the neuron fires; this is analogous to the neuron emitting an electrical output or
action potential. Thus we can model the behavior of the neuron using hk(x) = H(wT
kx − bk),
where H(a) = I(a > 0) is the Heaviside function. This is called the McCulloch-Pitts model of
the neuron, and was proposed in 1943 [MP43].
We can combine multiple such neurons together to make an ANN. The result has sometimes been
viewed as a model of the brain. However, ANNs differs from biological brains in many ways, including
the following:
• Most ANNs use backpropagation to modify the strength of their connections (see Section 13.3).
However, real brains do not use backprop, since there is no way to send information backwards
along an axon [Ben+15b; BS16; KH19]. Instead, they use local update rules for adjusting synaptic
strengths.
• Most ANNs are strictly feedforward, but real brains have many feedback connections. It is believed
that this feedback acts like a prior, which can be combined with bottom up likelihoods from the
sensory system to compute a posterior over hidden states of the world, which can then be used for
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.2. Multilayer perceptrons (MLPs) 431
1950 1985 2000 2015 2056
Year
10−2
10−1
100
101
102
103
104
105
106
107
108
109
1010
1011
Number of neurons (logarithmic scale)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16 17
18
19 20
Sponge
Roundworm
Leech
Ant
Bee
Frog
Octopus
Human
Figure 13.9: Plot of neural network sizes over time. Models 1, 2, 3 and 4 correspond to the perceptron
[Ros58], the adaptive linear unit [WH60] the neocognitron [Fuk80], and the first MLP trained by backprop
[RHW86]. Approximate number of neurons for some living organisms are shown on the right scale (the sponge
has 0 neurons), based on https: // en. wikipedia. org/ wiki/ List_ of_ animals_ by_ number_ of_ neurons .
From Figure 1.11 of [GBC16]. Used with kind permission of Ian Goodfellow.
optimal decision making (see e.g., [Doy+07]).
• Most ANNs use simplified neurons consisting of a weighted sum passed through a nonlinearity,
but real biological neurons have complex dendritic tree structures (see Figure 13.8), with complex
spatio-temporal dynamics.
• Most ANNs are smaller in size and number of connections than biological brains (see Figure 13.9).
Of course, ANNs are getting larger every week, fueled by various new hardware accelerators,
such as GPUs and TPUs (tensor processing units), etc. However, even if ANNs match
biological brains in terms of number of units, the comparison is misleading since the processing
capability of a biological neuron is much higher than an artificial neuron (see point above).
• Most ANNs are designed to model a single function, such as mapping an image to a label, or a
sequence of words to another sequence of words. By contrast, biological brains are very complex
systems, composed of multiple specialized interacting modules, which implement different kinds
of functions or behaviors such as perception, control, memory, language, etc (see e.g., [Sha88;
Kan+12]).
Of course, there are efforts to make realistic models of biological brains (e.g., the Blue Brain
Project [Mar06; Yon19]). However, an interesting question is whether studying the brain at this
level of detail is useful for “solving AI”. It is commonly believed that the low level details of biological
brains do not matter if our goal is to build “intelligent machines”, just as aeroplanes do not flap their
wings. However, presumably “AIs” will follow similar “laws of intelligence” to intelligent biological
agents, just as planes and birds follow the same laws of aerodynamics.
Unfortunately, we do not yet know what the “laws of intelligence” are, or indeed if there even are
such laws. In this book we make the assumption that any intelligent agent should follow the basic
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license432 Chapter 13. Neural Networks for Structured Data
principles of information processing and Bayesian decision theory, which is known to be the optimal
way to make decisions under uncertainty (see Section 5.1).
In practice, the optimal Bayesian approach is often computationally intractable. In the natural
world, biological agents have evolved various algorithmic “shortcuts” to the optimal solution; this
can explain many of the heuristics that people use in everyday reasoning [KST82; GTA00; Gri20].
As the tasks we want our machines to solve become harder, we may be able to gain insights from
neuroscience and cognitive science for how to solve such tasks in an approximate way (see e.g.,
[MWK16; Has+17; Lak+17; HG21]). However, we should also bear in mind that AI/ML systems are
increasingly used for safety-critical applications, in which we might want and expect the machine
to do better than a human. In such cases, we may want more than just heuristic solutions that
often work; instead we may want provably reliable methods, similar to other engineering fields (see
Section 1.6.3 for further discussion).
13.3 Backpropagation
This section is coauthored with Mathieu Blondel.
In this section, we describe the famous backpropagation algorithm, which can be used to
compute the gradient of a loss function applied to the output of the network wrt the parameters
in each layer. This gradient can then be passed to a gradient-based optimization algorithm, as we
discuss in Section 13.4.
The backpropagation algorithm was originally discovered in [BH69], and independently in [Wer74].
However, it was [RHW86] that brought the algorithm to the attention of the “mainstream” ML
community. See the wikipedia page4
for more historical details.
We initially assume the computation graph is a simple linear chain of stacked layers, as in an
MLP. In this case, backprop is equivalent to repeated applications of the chain rule of calculus
(see Equation (7.261)). However, the method can be generalized to arbitrary directed acyclic
graphs (DAGs), as we discuss in Section 13.3.4. This general procedure is often called automatic
differentiation or autodiff.
13.3.1 Forward vs reverse mode differentiation
Consider a mapping of the form o = f(x), where x ∈ R
n and o ∈ R
m. We assume that f is defined
as a composition of functions:
f = f4 ◦ f3 ◦ f2 ◦ f1 (13.22)
where f1 : R
n → R
m1
, f2 : R
m1 → R
m2
, f3 : R
m2 → R
m3
, and f4 : R
m3 → R
m. The intermediate
steps needed to compute o = f(x) are x2 = f1(x), x3 = f2(x2), x4 = f3(x3), and o = f4(x4).
We can compute the Jacobian Jf (x) = ∂o
∂xT ∈ R
m×n using the chain rule:
∂o
∂x
=
∂o
∂x4
∂x4
∂x3
∂x3
∂x2
∂x2
∂x
=
∂f4(x4)
∂x4
∂f3(x3)
∂x3
∂f2(x2)
∂x2
∂f1(x)
∂x
(13.23)
= Jf4
(x4)Jf3
(x3)Jf2
(x2)Jf1
(x) (13.24)
4. https://en.wikipedia.org/wiki/Backpropagation#History
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.3. Backpropagation 433
x = x1 f1
θ1
f2
x2
θ2
f3
x3
θ3
f4
x4
θ4
o
Figure 13.10: A simple linear-chain feedforward model with 4 layers. Here x is the input and o is the output.
From [Blo20].
We now discuss how to compute the Jacobian Jf (x) efficiently. Recall that
Jf (x) = ∂f(x)
∂x
=


∂f1
∂x1
· · ·
∂f1
∂xn
.
.
.
.
.
.
.
.
.
∂fm
∂x1
· · ·
∂fm
∂xn

 =


∇f1(x)
T
.
.
.
∇fm(x)
T

 =

∂f
∂x1
, · · · ,
∂f
∂xn

∈ R
m×n
(13.25)
where ∇fi(x)
T ∈ R
1×n is the i’th row (for i = 1 : m) and ∂f
∂xj
∈ R
m is the j’th column (for j = 1 : n).
Note that, in our notation, when m = 1, the gradient, denoted ∇f(x), has the same shape as x. It
is therefore a column vector, while Jf (x) is a row vector. In this case, we therefore technically have
∇f(x) = Jf (x)
T.
We can extract the i’th row from Jf (x) by using a vector Jacobian product (VJP) of the form
e
T
i Jf (x), where ei ∈ R
m is the unit basis vector. Similarly, we can extract the j’th column from
Jf (x) by using a Jacobian vector product (JVP) of the form Jf (x)ej , where ej ∈ R
n. This shows
that the computation of Jf (x) reduces to either n JVPs or m VJPs.
If n < m, it is more efficient to compute Jf (x) for each column j = 1 : n by using JVPs in a
right-to-left manner. The right multiplication with a column vector v is
Jf (x)v = Jf4
(x4)
| {z }
m×m3
Jf3
(x3)
| {z }
m3×m2
Jf2
(x2)
| {z }
m2×m1
Jf1
(x1)
| {z }
m1×n
v
|{z}
n×1
(13.26)
This can be computed using forward mode differentiation; see Algorithm 5 for the pseudocode.
Assuming m = 1 and n = m1 = m2 = m3, the cost of computing Jf (x) is O(n
3
).
Algorithm 5: Foward mode differentiation
1 x1 := x
2 vj := ej ∈ R
n for j = 1 : n
3 for k = 1 : K do
4 xk+1 = fk(xk)
5 vj := Jfk
(xk)vj for j = 1 : n
6 Return o = xK+1, [Jf (x)]:,j = vj for j = 1 : n
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license434 Chapter 13. Neural Networks for Structured Data
If n > m (e.g., if the output is a scalar), it is more efficient to compute Jf (x) for each row i = 1 : m
by using VJPs in a left-to-right manner. The left multiplication with a row vector u
T is
u
TJf (x) = u
T
|{z}
1×m
Jf4
(x4)
| {z }
m×m3
Jf3
(x3)
| {z }
m3×m2
Jf2
(x2)
| {z }
m2×m1
Jf1
(x1)
| {z }
m1×n
(13.27)
This can be done using reverse mode differentiation; see Algorithm 6 for the pseudocode.
Assuming m = 1 and n = m1 = m2 = m3, the cost of computing Jf (x) is O(n
2
).
Algorithm 6: Reverse mode differentiation
1 x1 := x
2 for k = 1 : K do
3 xk+1 = fk(xk)
4 ui
:= ei ∈ R
m for i = 1 : m
5 for k = K : 1 do
6 u
T
i
:= u
T
i Jfk
(xk) for i = 1 : m
7 Return o = xK+1, [Jf (x)]i,: = u
T
i
for i = 1 : m
Both Algorithms 5 and 6 can be adapted to compute JVPs and VJPs against any collection of
input vectors, by accepting {vj}j=1,...,n and {ui}i=1,...,m as respective inputs. Initializing these
vectors to the standard basis is useful specifically for producing the complete Jacobian as output.
13.3.2 Reverse mode differentiation for multilayer perceptrons
In the previous section, we considered a simple linear-chain feedforward model where each layer does
not have any learnable parameters. In this section, each layer can now have (optional) parameters
θ1, . . . , θ4. See Figure 13.10 for an illustration. We focus on the case where the mapping has the
form L : R
n → R, so the output is a scalar. For example, consider `2 loss for a MLP with one hidden
layer:
L((x, y), θ) = 1
2
||y − W2ϕ(W1x)||2
2
(13.28)
we can represent this as the following feedforward model:
L = f4 ◦ f3 ◦ f2 ◦ f1 (13.29)
x2 = f1(x, θ1) = W1x (13.30)
x3 = f2(x2, ∅) = ϕ(x2) (13.31)
x4 = f3(x3, θ3) = W2x3 (13.32)
L = f4(x4, y) = 1
2
||x4 − y||2
(13.33)
We use the notation fk(xk, θk) to denote the function at layer k, where xk is the previous output
and θk are the optional parameters for this layer.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.3. Backpropagation 435
In this example, the final layer returns a scalar, since it corresponds to a loss function L ∈ R.
Therefore it is more efficient to use reverse mode differentation to compute the gradient vectors.
We first discuss how to compute the gradient of the scalar output wrt the parameters in each layer.
We can easily compute the gradient wrt the predictions in the final layer ∂L
∂x4
. For the gradient wrt
the parameters in the earlier layers, we can use the chain rule to get
∂L
∂θ3
=
∂L
∂x4
∂x4
∂θ3
(13.34)
∂L
∂θ2
=
∂L
∂x4
∂x4
∂x3
∂x3
∂θ2
(13.35)
∂L
∂θ1
=
∂L
∂x4
∂x4
∂x3
∂x3
∂x2
∂x2
∂θ1
(13.36)
where each ∂L
∂θk
= (∇θk L)
T is a dk-dimensional gradient row vector, where dk is the number of
parameters in layer k. We see that these can be computed recursively, by multiplying the gradient
row vector at layer k by the Jacobian ∂xk
∂xk−1
which is an nk × nk−1 matrix, where nk is the number
of hidden units in layer k. See Algorithm 7 for the pseudocode.
This algorithm computes the gradient of the loss wrt the parameters at each layer. It also computes
the gradient of the loss wrt the input, ∇xL ∈ R
n, where n is the dimensionality of the input. This
latter quantity is not needed for parameter learning, but can be useful for generating inputs to a
model (see Section 14.6 for some applications).
Algorithm 7: Backpropagation for an MLP with K layers
1 // Forward pass
2 x1 := x
3 for k = 1 : K do
4 xk+1 = fk(xk, θk)
5 // Backward pass
6 uK+1 := 1
7 for k = K : 1 do
8 gk := u
T
k+1
∂fk(xk,θk)
∂θk
9 u
T
k
:= u
T
k+1
∂fk(xk,θk)
∂xk
10 // Output
11 Return L = xK+1, ∇xL = u1, {∇θk L = gk : k = 1 : K}
All that remains is to specify how to compute the vector Jacobian product (VJP) of all supported
layers. The details of this depend on the form of the function at each layer. We discuss some examples
below.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license436 Chapter 13. Neural Networks for Structured Data
13.3.3 Vector-Jacobian product for common layers
Recall that the Jacobian for a layer of the form f : R
n → R
m. is defined by
Jf (x) = ∂f(x)
∂x
=


∂f1
∂x1
· · ·
∂f1
∂xn
.
.
.
.
.
.
.
.
.
∂fm
∂x1
· · ·
∂fm
∂xn

 =


∇f1(x)
T
.
.
.
∇fm(x)
T

 =

∂f
∂x1
, · · · ,
∂f
∂xn

∈ R
m×n
(13.37)
where ∇fi(x)
T ∈ R
n is the i’th row (for i = 1 : m) and ∂f
∂xj
∈ R
m is the j’th column (for j = 1 : n).
In this section, we describe how to compute the VJP u
TJf (x) for common layers.
13.3.3.1 Cross entropy layer
Consider a cross-entropy loss layer taking logits x and target labels y as input, and returning a
scalar:
z = f(x) = CrossEntropyWithLogits(y, x) = −
X
c
yc log(S(x)c) = −
X
c
yc log pc (13.38)
where p = S(x) = e
xc PC
c0=1 e
xc0 are the predicted class probabilites, and y is the true distribution over
labels (often a one-hot vector). The Jacobian wrt the input is
J =
∂z
∂x
= (p − y)
T ∈ R
1×C (13.39)
To see this, assume the target label is class c. We have
z = f(x) = − log(pc) = − log 
e
xc
P
j
e
xj
!
= log


X
j
e
xj

 − xc (13.40)
Hence
∂z
∂xi
=
∂
∂xi
logX
j
e
xj −
∂
∂xi
xc =
e
xi
P
j
e
xj
−
∂
∂xi
xc = pi − I(i = c) (13.41)
If we define y = [I(i = c)], we recover Equation (13.39). Note that the Jacobian of this layer is a row
vector, since the output is a scalar.
13.3.3.2 Elementwise nonlinearity
Consider a layer that applies an elementwise nonlinearity, z = f(x) = ϕ(x), so zi = ϕ(xi). The (i, j)
element of the Jacobian is given by
∂zi
∂xj
=
(
ϕ
0
(xi) if i = j
0 otherwise
(13.42)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.3. Backpropagation 437
where ϕ
0
(a) = d
daϕ(a). In other words, the Jacobian wrt the input is
J =
∂f
∂x
= diag(ϕ
0
(x)) (13.43)
For an arbitrary vector u, we can compute u
TJ by elementwise multiplication of the diagonal elements
of J with u. For example, if
ϕ(a) = ReLU(a) = max(a, 0) (13.44)
we have
ϕ
0
(a) = (
0 a < 0
1 a > 0
(13.45)
The subderivative (Section 8.1.4.1) at a = 0 is any value in [0, 1]. It is often taken to be 0. Hence
ReLU0
(a) = H(a) (13.46)
where H is the Heaviside step function.
13.3.3.3 Linear layer
Now consider a linear layer, z = f(x,W) = Wx, where W ∈ R
m×n, so x ∈ R
n and z ∈ R
m. We
can compute the Jacobian wrt the input vector, J =
∂z
∂x
∈ R
m×n, as follows. Note that
zi =
Xn
k=1
Wikxk (13.47)
So the (i, j) entry of the Jacobian will be
∂zi
∂xj
=
∂
∂xj
Xn
k=1
Wikxk =
Xn
k=1
Wik
∂
∂xj
xk = Wij (13.48)
since ∂
∂xj
xk = I(k = j). Hence the Jacobian wrt the input is
J =
∂z
∂x
= W (13.49)
The VJP between u
T ∈ R
1×m and J ∈ R
m×n is
u
T ∂z
∂x
= u
TW ∈ R
1×n
(13.50)
Now consider the Jacobian wrt the weight matrix, J =
∂z
∂W. This can be represented as a m×(m×n)
matrix, which is complex to deal with. So instead, let us focus on taking the gradient wrt a single
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license438 Chapter 13. Neural Networks for Structured Data
x1 f3
x2 f4
x3
f5
x4
f6
x5
f7
x6
x4
x7 = o
Figure 13.11: An example of a computation graph with 2 (scalar) inputs and 1 (scalar) output. From [Blo20].
weight, Wij . This is easier to compute, since ∂z
∂Wij
is a vector. To compute this, note that
zk =
Xm
l=1
Wklxl (13.51)
∂zk
∂Wij
=
Xm
l=1
xl
∂
∂Wij
Wkl =
Xm
l=1
xlI(i = k and j = l) (13.52)
Hence
∂z
∂Wij
=
￾
0 · · · 0 xj 0 · · · 0
T
(13.53)
where the non-zero entry occurs in location i. The VJP between u
T ∈ R
1×m and ∂z
∂W ∈ R
m×(m×n)
can be represented as a matrix of shape 1 × (m × n). Note that
u
T ∂z
∂Wij
=
Xm
k=1
uk
∂zk
∂Wij
= uixj (13.54)
Therefore

u
T ∂z
∂W

1,:
= uxT ∈ R
m×n
(13.55)
13.3.3.4 Putting it all together
For an exercise that puts this all together, see Exercise 13.1.
13.3.4 Computation graphs
MLPs are a simple kind of DNN in which each layer feeds directly into the next, forming a chain
structure, as shown in Figure 13.10. However, modern DNNs can combine differentiable components in
much more complex ways, to create a computation graph, analogous to how programmers combine
elementary functions to make more complex ones. (Indeed, some have suggested that “deep learning”
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20213.3. Backpropagation 439
be called “differentiable programming”.) The only restriction is that the resulting computation
graph corresponds to a directed ayclic graph (DAG), where each node is a differentiable function
of all its inputs.
For example, consider the function
f(x1, x2) = x2e
x1
√
x1 + x2e
x1 (13.56)
We can compute this using the DAG in Figure 13.11, with the following intermediate functions:
x3 = f3(x1) = e
x1
(13.57)
x4 = f4(x2, x3) = x2x3 (13.58)
x5 = f5(x1, x4) = x1 + x4 (13.59)
x6 = f6(x5) = √
x5 (13.60)
x7 = f7(x4, x6) = x4x6 (13.61)
Note that we have numbered the nodes in topological order (parents before children). During the
backward pass, since the graph is no longer a chain, we may need to sum gradients along multiple
paths. For example, since x4 influences x5 and x7, we have
∂o
∂x4
=
∂o
∂x5
∂x5
∂x4
+
∂o
∂x7
∂x7
∂x4
(13.62)
We can avoid repeated computation by working in reverse topological order. For example,
∂o
∂x7
=
∂x7
∂x7
= Im (13.63)
∂o
∂x6
=
∂o
∂x7
∂x7
∂x6
(13.64)
∂o
∂x5
=
∂o
∂x6
∂x6
∂x5
(13.65)
∂o
∂x4
=
∂o
∂x5
∂x5
∂x4
+
∂o
∂x7
∂x7
∂x4
(13.66)
In general, we use
∂o
∂xj
=
X
k∈children(j)
∂o
∂xk
∂xk
∂xj
(13.67)
where the sum is over all children k of node j, as shown in Figure 13.12. The ∂o
∂xk
gradient vector
has already been computed for each child k; this quantity is called the adjoint. This gets multiplied
by the Jacobian ∂xk
∂xj
of each child.
The computation graph can be computed ahead of time, by using an API to define a static graph.
(This is how Tensorflow 1 worked.) Alternatively, the graph can be computed “just in time”, by
tracing the execution of the function on an input argument. (This is how Tensorflow eager mode
works, as well as JAX and PyTorch.) The latter approach makes it easier to work with a dynamic
graph, whose shape can change depending on the values computed by the function.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license440 Chapter 13. Neural Networks for Structured Data
fi
fj
xi
fk
xj xk
parents children
Figure 13.12: Notation for automatic differentiation at node j in a computation graph. From [Blo20].
Figure 13.13: Computation graph for an MLP with input x, hidden layer h, output o, loss function L = `(o, y),
an `2 regularizer s on the weights, and total loss J = L + s. From Figure 4.7.1 of [Zha+20]. Used with kind
permission of Aston Zhang.
Figure 13.13 shows a computation graph corresponding to an MLP with one hidden layer with
weight decay. More precisely, the model computes the linear pre-activations z = W(1)x, the
hidden activations h = φ(z), the linear outputs o = W(2)h, the loss L = `(o, y), the regularizer
s =
λ
2
(||W(1)||2
F + ||W(2)||2
F
), and the total loss J = L + s.
13.4 Training neural networks
In this section, we discuss how to fit DNNs to data. The standard approach is to use maximum
likelihood estimation, by minimizing the NLL:
L(θ) = − log p(D|θ) = −
X
N
n=1
log p(yn|xn; θ) (13.68)
It is also common to add a regularizer (such as the negative log prior), as we discuss in Section 13.5.
In principle we can just use the backprop algorithm (Section 13.3) to compute the gradient of
this loss and pass it to an off-the-shelf optimizer, such as those discussed in Chapter 8. (The Adam
optimizer of Section 8.4.6.3 is a popular choice, due to its ability to scale to large datasets (by
virtue of being an SGD-type algorithm), and to converge fairly quickly (by virtue of using diagonal
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.4. Training neural networks 441
preconditioning and momentum).) However, in practice this may not work well. In this section,
we discuss various problems that may arise, as well as some solutions. For more details on the
practicalities of training DNNs, see various other books, such as [HG20; Zha+20; Gér19].
In addition to practical issues, there are important theoretical issues. In particular, we note that
the DNN loss is not a convex objective, so in general we will not be able to find the global optimum.
Nevertheless, SGD can often find suprisingly good solutions. The research into why this is the case is
still being conducted; see [Bah+20] for a recent review of some of this work.
13.4.1 Tuning the learning rate
It is important to tune the learning rate (step size), to ensure convergence to a good solution. We
discuss this issue in Section 8.4.3.
13.4.2 Vanishing and exploding gradients
When training very deep models, the gradient tends to become either very small (this is called the
vanishing gradient problem) or very large (this is called the exploding gradient problem),
because the error signal is being passed through a series of layers which either amplify or diminish it
[Hoc+01]. (Similar problems arise in RNNs on long sequences, as we explain in Section 15.2.6.)
To explain the problem in more detail, consider the gradient of the loss wrt a node at layer l:
∂L
∂zl
=
∂L
∂zl+1
∂zl+1
∂zl
= Jlgl+1 (13.69)
where Jl =
∂zl+1
∂zl
is the Jacobian matrix, and gl+1 =
∂L
∂zl+1
is the gradient at the next layer. If Jl
is
constant across layers, it is clear that the contribution of the gradient from the final layer, gL, to
layer l will be J
L−lgL. Thus the behavior of the system depends on the eigenvectors of J.
Although J is a real-valued matrix, it is not (in general) symmetric, so its eigenvalues and
eigenvectors can be complex-valued, with the imaginary components corresponding to oscillatory
behavior. Let λ be the spectral radius of J, which is the maximum of the absolute values of the
eigenvalues. If this is greater than 1, the gradient can explode; if this is less than 1, the gradient can
vanish. (Similarly, the spectral radius of W, connecting zl to zl+1, determines the stability of the
dynamical system when run in forwards mode.)
The exploding gradient problem can be ameliorated by gradient clipping, in which we cap the
magnitude of the gradient if it becomes too large, i.e., we use
g
0 = min(1,
c
||g||)g (13.70)
This way, the norm of g
0
can never exceed c, but the vector is always in the same direction as g.
However, the vanishing gradient problem is more difficult to solve. There are various solutions,
such as the following:
• Modify the the activation functions at each layer to prevent the gradient from becoming too large
or too small; see Section 13.4.3.
• Modify the architecture so that the updates are additive rather than multiplicative; see Sec￾tion 13.4.4.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license442 Chapter 13. Neural Networks for Structured Data
Name Definition Range Reference
Sigmoid σ(a) = 1
1+e−a [0, 1]
Hyperbolic tangent tanh(a) = 2σ(2a) − 1 [−1, 1]
Softplus σ+(a) = log(1 + e
a
) [0, ∞] [GBB11]
Rectified linear unit ReLU(a) = max(a, 0) [0, ∞] [GBB11; KSH12]
Leaky ReLU max(a, 0) + α min(a, 0) [−∞, ∞] [MHN13]
Exponential linear unit max(a, 0) + min(α(e
a − 1), 0) [−∞, ∞] [CUH16]
Swish aσ(a) [−∞, ∞] [RZL17]
GELU aΦ(a) [−∞, ∞] [HG16]
Table 13.4: List of some popular activation functions for neural networks.
4 3 2 1 0 1 2 3 4
0.5
0.0
0.5
1.0
1.5
2.0
Activation function
sigmoid
leaky-relu
elu
swish
gelu
(a)
4 3 2 1 0 1 2 3 4
0.50
0.25
0.00
0.25
0.50
0.75
1.00
1.25
1.50
Gradient of activation function
sigmoid
leaky-relu
elu
swish
gelu
(b)
Figure 13.14: (a) Some popular activation functions. (b) Plot of their gradients. Generated by code at
figures.probml.ai/book1/13.14.
• Modify the architecture to standardize the activations at each layer, so that the distribution of
activations over the dataset remains constant during training; see Section 14.2.4.1.
• Carefully choose the initial values of the parameters; see Section 13.4.5.
13.4.3 Non-saturating activation functions
In Section 13.2.3, we mentioned that the sigmoid activation function saturates at 0 for large negative
inputs, and at 1 for large positive inputs. It turns out that the gradient signal in these regimes is 0,
preventing backpropagation from working.
To see why the gradient vanishes, consider a layer which computes z = σ(Wx), where
ϕ(a) = σ(a) = 1
1 + exp(−a)
(13.71)
If the weights are initialized to be large (positive or negative), then it becomes very easy for a = Wx
to take on large values, and hence for z to saturate near 0 or 1, since the sigmoid saturates, as shown
in Figure 13.14a. Now let us consider the gradient of the loss wrt the inputs x (from an earlier layer)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.4. Training neural networks 443
and the parameters W. The derivative of the activation function is given by
ϕ
0
(a) = σ(a)(1 − σ(a)) (13.72)
See Figure 13.14b for a plot. In Section 13.3.3, we show that the gradient of the loss wrt the inputs
is
∂L
∂x
= WT
δ = WTz(1 − z) (13.73)
and the gradient of the loss wrt the parameters is
∂L
∂W
= δxT = z(1 − z)x
T
(13.74)
Hence, if z is near 0 or 1, the gradients will go to 0.
One of the keys to being able to train very deep models is to use non-saturating activation
functions. Several different functions have been proposed: see Table 13.4 for a summary, and
https://mlfromscratch.com/activation-functions-explained for more details.
13.4.3.1 ReLU
The most common is rectified linear unit or ReLU, proposed in [GBB11; KSH12]. This is defined
as
ReLU(a) = max(a, 0) = aI(a > 0) (13.75)
The ReLU function simply “turns off” negative inputs, and passes positive inputs unchanged. The
gradient has the following form:
ReLU0
(a) = I(a > 0) (13.76)
Now suppose we use this in a layer to compute z = ReLU(Wx). In Section 13.3.3, we show that the
gradient wrt the inputs has the form
∂L
∂x
= WT
I(z > 0) (13.77)
and wrt the parameters has the form
∂L
∂W
= I(z > 0) x
T
(13.78)
Hence the gradient will not vanish, as long a z is positive.
Unfortunately, if the weights are initialized to be large and negative, then it becomes very easy for
(some components of) a = Wx to take on large negative values, and hence for z to go to 0. This
will cause the gradient for the weights to go to 0. The algorithm will never be able to escape this
situation, so the hidden units (components of z) will stay permanently off. This is called the “dead
ReLU” problem [Lu+19].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license444 Chapter 13. Neural Networks for Structured Data
13.4.3.2 Non-saturating ReLU
The problem of dead ReLU’s can be solved by using non-saturating variants of ReLU. One alternate
is the leaky ReLU, proposed in [MHN13]. This is defined as
LReLU(a; α) = max(αa, a) (13.79)
where 0 < α < 1. The slope of this function is 1 for positive inputs, and α for negative inputs, thus
ensuring there is some signal passed back to earlier layers, even when the input is negative. See
Figure 13.14b for a plot. If we allow the parameter α to be learned, rather than fixed, the leaky
ReLU is called parametric ReLU [He+15].
Another popular choice is the ELU, proposed in [CUH16]. This is defined by
ELU(a; α) = (
α(e
a − 1) if a ≤ 0
a if a > 0
(13.80)
This has the advantage over leaky ReLU of being a smooth function. See Figure 13.14 for plot.
A slight variant of ELU, known as SELU (self-normalizing ELU), was proposed in [Kla+17]. This
has the form
SELU(a; α, λ) = λELU(a; α) (13.81)
Surprisingly, they prove that by setting α and λ to carefully chosen values, this activation function
is guaranteed to ensure that the output of each layer is standardized (provided the input is also
standardized), even without the use of techniques such as batchnorm (Section 14.2.4.1). This can
help with model fitting.
13.4.3.3 Other choices
As an alternative to manually discovering good activation functions, we can use blackbox optimization
methods to search over the space of functional forms. Such an approach was used in [RZL17], where
they discovered a function they call swish that seems to do well on some image classification
benchmarks. It is defined by
swish(a; β) = aσ(βa) (13.82)
(The same function, under the name SiLU (for Sigmoid Linear Unit), was independently proposed
in [HG16].) See Figure 13.14 for plot.
Another popular activation function is GELU, which stands for “Gaussian Error Linear Unit”
[HG16]. This is defined as follows:
GELU(a) = aΦ(a) (13.83)
where Φ(a) is the cdf of a standard normal:
Φ(a) = Pr(N (0, 1) ≤ a) = 1
2

1 + erf(a/√
2)
(13.84)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.4. Training neural networks 445
identity
weight layer
weight layer
relu
relu F(x) + x
x
F(x) x
(a)
X Layer blocking
backpropagation 
= Layer not Learning
X
=
X
+
+
+
Residual
Units
(b)
Figure 13.15: (a) Illustration of a residual block. (b) Illustration of why adding residual connections can help
when training a very deep model. Adapted from Figure 14.16 of [Gér19].
We see from Figure 13.14 that this is not a convex or monontonic function, unlike most other
activation functions.
We can think of GELU as a “soft” version of ReLU, since it replaces the step function I(a > 0)
with the Gaussian cdf, Φ(a). Alternatively, the GELU can be motivated as an adaptive version of
dropout (Section 13.5.4), where we multiply the input by a binary scalar mask, m ∼ Ber(Φ(a)),
where the probability of being dropped is given by 1 − Φ(a). Thus the expected output is
E[a] = Φ(a) × a + (1 − Φ(a)) × 0 = aΦ(a) (13.85)
We can approximate GELU using swish with a particular parameter setting, namely
GELU(a) ≈ aσ(1.702a) (13.86)
13.4.4 Residual connections
One solution to the vanishing gradient problem for DNNs is to use a residual network or ResNet
[He+16a]. This is a feedforward model in which each layer has the form of a residual block, defined
by
F
0
l
(x) = Fl(x) + x (13.87)
where Fl
is a standard shallow nonlinear mapping (e.g., linear-activation-linear). The inner Fl
function computes the residual term or delta that needs to be added to the input x to generate
the desired output; it is often easier to learn to generate a small perturbation to the input than to
directly predict the output. (Residual connections are usually used in conjunction with CNNs, as
discussed in Section 14.3.4, but can also be used in MLPs.)
A model with residual connections has the same number of parameters as a model without residual
connections, but it is easier to train. The reason is that gradients can flow directly from the output
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license446 Chapter 13. Neural Networks for Structured Data
to earlier layers, as sketched in Figure 13.15b. To see this, note that the activations at the output
layer can be derived in terms of any previous layer l using
zL = zl +
L
X−1
i=l
Fi(zi
; θi). (13.88)
We can therefore compute the gradient of the loss wrt the parameters of the l’th layer as follows:
∂L
∂θl
=
∂zl
∂θl
∂L
∂zl
(13.89)
=
∂zl
∂θl
∂L
∂zL
∂zL
∂zl
(13.90)
=
∂zl
∂θl
∂L
∂zL
 
1 +
L
X−1
i=l
∂Fi(zi
; θi)
∂zl
!
(13.91)
=
∂zl
∂θl
∂L
∂zL
+ otherterms (13.92)
Thus we see that the gradient at layer l depends directly on the gradient at layer L in a way that is
independent of the depth of the network.
13.4.5 Parameter initialization
Since the objective function for DNN training is non-convex, the way that we initialize the parameters
of a DNN can play a big role on what kind of solution we end up with, as well as how easy the
function is to train (i.e., how well information can flow forwards and backwards through the model).
In the rest of this section, we present some common heuristic methods that are used for initializing
parameters.
13.4.5.1 Heuristic initialization schemes
In [GB10], they show that sampling parameters from a standard normal with fixed variance can
result in exploding activations or gradients. To see why, consider a linear unit with no activation
function given by oi =
Pnin
j=1 wijxj ; suppose wij ∼ N (0, σ2
), and E [xj ] = 0 and V [xj ] = γ
2
, where
we assume xj are independent of wij . The mean and variance of the output is given by
E [oi
] = Xnin
j=1
E [wijxj ] = Xnin
j=1
E [wij ] E [xj ] = 0 (13.93)
V [oi
] = E

o
2
i

− (E [oi
])2 =
Xnin
j=1
E

w
2
ijx
2
j

− 0 = Xnin
j=1
E

w
2
ij 
E

x
2
j

= ninσ
2
γ
2
(13.94)
To keep the output variance from blowing up, we need to ensure ninσ
2 = 1 (or some other constant),
where nin is the fan-in of a unit (number of incoming connections).
Now consider the backwards pass. By analogous reasoning, we see that the variance of the gradients
can blow up unless noutσ
2 = 1, where nout is the fan-out of a unit (number of outgoing connections).
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.4. Training neural networks 447
To satisfy both requirements at once, we set 1
2
(nin + nout)σ
2 = 1, or equivalently
σ
2 =
2
nin + nout
(13.95)
This is known as Xavier initialization or Glorot initialization, named after the first author of
[GB10].
A special case arises if we use σ
2 = 1/nin; this is known as LeCun initialization, named after
Yann LeCun, who proposed it in the 1990s. This is equivalent to Glorot initialization when nin = nout.
If we use σ
2 = 2/nin, the method is called He initialization, named after Ximing He, who proposed
it in [He+15].
Note that it is not necessary to use a Gaussian distribution. Indeed, the above derivation just
worked in terms of the first two moments (mean and variance), and made no assumptions about
Gaussianity. For example, suppose we sample weights from a uniform distribution, wij ∼ Unif(−a, a).
The mean is 0, and the variance is σ
2 = a
2/3. Hence we should set a =
q 6
nin+nout
.
Although the above derivation assumes a linear output unit, the technique works well empirically
even for nonlinear units. The best choice of initialization method depends on which activation
function you use. For linear, tanh, logistic, and softmax, Glorot is recommended. For ReLU and
variants, He is recommended. For SELU, LeCun is recommended. See e.g., [Gér19] for more heuristics,
and e.g., [HDR19] for some theory.
13.4.5.2 Data-driven initializations
We can also adopt a data-driven approach to parameter initialization. For example, [MM16] proposed
a simple but effective scheme known as layer-sequential unit-variance (LSUV) initialization,
which works as follows. First we initialize the weights of each (fully connected or convolutional)
layer with orthonormal matrices, as proposed in [SMG14]. (This can be achieved by drawing from
w ∼ N (0, I), reshaping to w to a matrix W, and then computing an orthonormal basis using QR or
SVD decomposition.) Then, for each layer l, we compute the variance vl of the activations across a
minibatch; we then rescale using Wl
:= Wl/
√
vl
. This scheme can be viewed as an orthonormal
initialization combined with batch normalization performed only on the first mini-batch. This is
faster than full batch normalization, but can sometimes work just as well.
13.4.6 Parallel training
It can be quite slow to train large models on large datasets. One way to speed this process up is to
use specialized hardware, such as graphics processing units (GPUs), which are very efficient at
performing matrix-matrix multiplication. If we have multiple GPUs, we can sometimes further speed
things up. There are two main approaches: model parallelism, in which we partition the model
between machines, and data parallelism, in which each machine has its own copy of the model,
and applies it to a different set of data.
Model parallelism can be quite complicated, since it requires tight communication between machines
to ensure they compute the correct answer. We will not discuss this further. Data parallelism is
generally much simpler, since it is embarassingly parallel. To use this to speed up training, at
each training step t, we do the following: 1) we partition the minibatch across the K machines to
get Dk
t
; 2) each machine k computes its own gradient, g
k
t = ∇θL(θ; Dk
t
); 3) we collect all the local
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license448 Chapter 13. Neural Networks for Structured Data
Figure 13.16: Calculation of minibatch stochastic gradient using data parallelism and two GPUs. From Figure
12.5.2 of [Zha+20]. Used with kind permission of Aston Zhang.
gradients on a central machine (e.g., device 0) and sum them using gt =
PK
k=1 g
k
t
; 4) we broadcast
the summed gradient back to all devices, so g˜
k
t = gt; 5) each machine updates its own copy of the
parameters using θ
k
t
:= θ
k
t − ηtg˜
k
t
. See Figure 13.16 for an illustration.
Note that steps 3 and 4 are usually combined into one atomic step; this is known as an all-reduce
operation (where we use sum to reduce the set of (gradient) vectors into one). If each machine
blocks until receiving the centrally aggregated gradient, gt, the method is known as synchronous
training. This will give the same results as training with one machine (with a larger batchsize),
only faster (assuming we ignore any batch normalization layers). If we let each machine update
its parameters using its own local gradient estimate, and not wait for the broadcast to/from the
other machines, the method is called asynchronous training. This is not guaranteed to work,
since the different machines may get out of step, and hence will be updating different versions of the
parameters; this approach has therefore been called hogwild training [Niu+11]. However, if the
updates are sparse, so each machine “touches” a different part of the parameter vector, one can prove
that hogwild training behaves like standard synchronous SGD.
13.5 Regularization
In Section 13.4 we discussed computational issues associated with training (large) neural networks.
In this section, we discuss statistical issues. In particular, we focus on ways to avoid overfitting. This
is crucial, since large neural networks can easily have millions of parameters.
13.5.1 Early stopping
Perhaps the simplest way to prevent overfitting is called early stopping, which refers to the
heuristic of stopping the training procedure when the error on the validation set starts to increase
(see Figure 4.8 for an example). This method works because we are restricting the ability of the
optimization algorithm to transfer information from the training examples to the parameters, as
explained in [AS19].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.5. Regularization 449
(a)
4 2 0 2 4
4
2
0
2
4
Deep Neural Net
Data
(b)
Figure 13.17: (a) A deep but sparse neural network. The connections are pruned using `1 regularization. At
each level, nodes numbered 0 are clamped to 1, so their outgoing weights correspond to the offset/bias terms.
(b) Predictions made by the model on the training set. Generated by code at figures.probml.ai/book1/13.17.
13.5.2 Weight decay
A common approach to reduce overfitting is to impose a prior on the parameters, and then use
MAP estimation. It is standard to use a Gaussian prior for the weights N (w|0, α2
I) and biases,
N (b|0, β2
I). This is equivalent to `2 regularization of the objective. In the neural networks literature,
this is called weight decay, since it encourages small weights, and hence simpler models, as in ridge
regression (Section 11.3).
13.5.3 Sparse DNNs
Since there are many weights in a neural network, it is often helpful to encourage sparsity. This
allows us to perform model compression, which can save memory and time. To do this, we can
use `1 regularization (as in Section 11.4), or ARD (as in Section 11.7.7), or several other methods
(see e.g., [Hoe+21; Bha+20] for recent reviews). As a simple example, Figure 13.17 shows a 5 layer
MLP which has been fit to some 1d regression data using an `1 regularizer on the weights. We see
that the resulting graph topology is sparse.
Despite the intuitive appeal of sparse topology, in practice these methods are not widely used,
since modern GPUs are optimized for dense matrix multiplication, and there are few computational
benefits to sparse weight matrices. However, if we use methods that encourage group sparsity, we can
prune out whole layers of the model. This results in block sparse weight matrices, which can result in
speedups and memory savings (see e.g., [Sca+17; Wen+16; MAV17; LUW17]).
13.5.4 Dropout
Suppose that we randomly (on a per-example basis) turn off all the outgoing connections from
each neuron with probability p, as illustrated in Figure 13.18. This technique is known as dropout
[Sri+14].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license450 Chapter 13. Neural Networks for Structured Data
(a) (b)
Figure 13.18: Illustration of dropout. (a) A standard neural net with 2 hidden layers. (b) An example of a
thinned net produced by applying dropout with p0 = 0.5. Units that have been dropped out are marked with an
x. From Figure 1 of [Sri+14]. Used with kind permission of Geoff Hinton.
Dropout can dramatically reduce overfitting and is very widely used. Intuitively, the reason dropout
works well is that it prevents complex co-adaptation of the hidden units. In other words, each unit
must learn to perform well even if some of the other units are missing at random. This prevents the
units from learning complex, but fragile, dependencies on each other.5 A more formal explanation,
in terms of Gaussian scale mixture priors, can be found in [NHLS19].
We can view dropout as estimating a noisy version of the weights, θlij = wlij li, where li ∼
Ber(1 − p) is a Bernoulli noise term. (So if we sample li = 0, then all of the weights going out of
unit i in layer l − 1 into any j in layer l will be set to 0.) At test time, we usually turn the noise off.
To ensure the weights have the same expectation at test time as they did during training (so the
input activation to the neurons is the same, on average), at test time we should use wlij = θlijE [li].
For Bernoulli noise, we have E [] = 1 − p, so we should multiply the weights by the keep probability,
1 − p, before making predictions.
We can, however, use dropout at test time if we wish. The result is an ensemble of networks,
each with slightly different sparse graph structures. This is called Monte Carlo dropout [GG16;
KG17], and has the form
p(y|x, D) ≈
1
S
X
S
s=1
p(y|x,Wˆ 
s + ˆb) (13.96)
where S is the number of samples, and we write Wˆ 
s
to indicate that we are multiplying all
the estimated weight matrices by a sampled noise vector. This can sometimes provide a good
approximation to the Bayesian posterior predictive distribution p(y|x, D), especially if the noise rate
is optimized [GHK17].
5. Geoff Hinton, who invented dropout, said he was inspired by a talk on sexual reproduction, which encourages genes
to be individually useful (or at most depend on a small number of other genes), even when combined with random
other genes.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.5. Regularization 451
Figure 13.19: Flat vs sharp minima. From Figures 1 and 2 of [HS97a]. Used with kind permission of Jürgen
Schmidhuber.
13.5.5 Bayesian neural networks
Modern DNNs are usually trained using a (penalized) maximum likelihood objective to find a single
setting of parameters. However, with large models, there are often many more parameters than data
points, so there may be multiple possible models which fit the training data equally well, yet which
generalize in different ways. It is often useful to capture the induced uncertainty in the posterior
predictive distribution. This can be done by marginalizing out the parameters by computing
p(y|x, D) = Z
p(y|x, θ)p(θ|D)dθ (13.97)
The result is known as a Bayesian neural network or BNN. It can be thought of as an infinite
ensemble of differently weight neural networks. By marginalizing out the parameters, we can avoid
overfitting [Mac95]. Bayesian marginalization is challenging for large neural networks, but also can
lead to significant performance gains [WI20]. For more details on the topic of Bayesian deep
learning, see the sequel to this book, [Mur22].
13.5.6 Regularization effects of (stochastic) gradient descent *
Some optimization methods (in particular, second-order batch methods) are able to find “needles
in haystacks”, corresponding to narrow but deep “holes” in the loss landscape, corresponding to
parameter settings with very low loss. These are known as sharp minima, see Figure 13.19(right).
From the point of view of minimizing the empirical loss, the optimizer has done a good job. However,
such solutions generally correspond to a model that has overfit the data. It is better to find points
that correspond to flat minima, as shown in Figure 13.19(left); such solutions are more robust and
generalize better. To see why, note that flat minima correspond to regions in parameter space where
there is a lot of posterior uncertainty, and hence samples from this region are less able to precisely
memorize irrelevant details about the training set [AS17]. SGD often finds such flat minima by
virtue of the addition of noise, which prevents it from “entering” narrow regions of the loss landscape
(see e.g., [SL18]). This is called implicit regularization. It is also possible to explicitly encourage
SGD to find such flat minima, using entropy SGD [Cha+17], sharpness aware minimization
[For+21], stochastic weight averaging (SWA) [Izm+18], and other related techniques.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license452 Chapter 13. Neural Networks for Structured Data
10.0 7.5 5.0 2.5 0.0 2.5 5.0 7.5 10.0
0
5
10
15
20
25
30
Low gradient variance
(a)
10.0 7.5 5.0 2.5 0.0 2.5 5.0 7.5 10.0
0
5
10
15
20
25
30
High gradient variance
(b)
Figure 13.20: Each curve shows how the loss varies across parameter values for a given minibatch. (a) A
stable local minimum. (b) An unstable local minimum. Generated by code at figures.probml.ai/book1/13.20.
Adapted from https: // bit. ly/ 3wTc1L6 .
Of course, the loss landscape depends not just on the parameter values, but also on the data. Since
we usually cannot afford to do full-batch gradient descent, we will get a set of loss curves, one per
minibatch. If each one of these curves corresponds to a wide basin, as shown in Figure 13.20a, we
are at a point in parameter space that is robust to perturbations, and will likely generalize well.
However, if the overall wide basin is the result of averaging over many different narrow basins, as
shown in Figure 13.20b, the resulting estimate will likely generalize less well.
This can be formalized using the analysis in [Smi+21; BD21]. Specifically, they consider continuous
time gradient flow which approximates the behavior of (S)GD. In [BD21], they consider full-batch
GD, and show that the flow has the form w˙ = −∇wL˜GD(w), where
L˜GD(w) = L(w) + 
4
||∇L(w)||2
(13.98)
where L(w) is the original loss,  is the learning rate, and the second term is an implicit regularization
term that penalizes solutions with large gradients (high curvature).
In [Smi+21], they extend this analysis to the SGD case. They show that the flow has the form
w˙ = −∇wL˜
SGD(w), where
L˜
SGD(w) = L(w) + 
4
Xm
k=1
||∇Lk(w)||2
(13.99)
where m is the number of minibatches, and Lk(w) is the loss on the k’th such minibatch. Comparing
this to the full-batch GD loss, we see
L˜
SGD(w) = L˜GD(w) + 
4
Xm
k=1
||∇Lk(w) − L(w)||2
(13.100)
The second term estimates the variance of the minibatch gradients, which is a measure of stability,
and hence of generalization ability.
The above analysis shows that SGD not only has computational advantages (since it is faster than
full-batch GD or second-order methods), but also statistical advantages.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.6. Other kinds of feedforward networks * 453
13.6 Other kinds of feedforward networks *
13.6.1 Radial basis function networks
Consider a 1 layer neural net where the hidden layer is given by the feature vector
φ(x) = [K(x, µ1), . . . , K(x, µK)] (13.101)
where µk ∈ X are a set of K centroids or exemplars, and K(x, µ) ≥ 0 is a kernel function.
We describe kernel functions in detail in Section 17.1. Here we just give an example, namely the
Gaussian kernel
Kgauss(x, c) , exp 
−
1
2σ
2
||c − x||2
2

(13.102)
The parameter σ is known as the bandwidth of the kernel. Note that this kernel is shift invariant,
meaning it is only a function of the distance r = ||x − c||2, so we can equivalently write this as
Kgauss(r) , exp 
−
1
2σ
2
r
2

(13.103)
This is therefore called a radial basis function kernel or RBF kernel.
A 1 layer neural net in which we use Equation (13.101) as the hidden layer, with RBF kernels, is
called an RBF network [BL88]. This has the form
p(y|x; θ) = p(y|wTφ(x)) (13.104)
where θ = (µ, w). If the centroids µ are fixed, we can solve for the optimal weights w using
(regularized) least squares, as discussed in Chapter 11. If the centroids are unknown, we can estimate
them by using an unsupervised clustering method, such as K-means (Section 21.3). Alternatively, we
can associate one centroid per data point in the training set, to get µn = xn, where now K = N.
This is an example of a non-parametric model, since the number of parameters grows (in this case
linearly) with the amount of data, and is not independent of N. If K = N, the model can perfectly
interpolate the data, and hence may overfit. However, by ensuring that the output weight vector
w is sparse, the model will only use a finite subset of the input examples; this is called a sparse
kernel machine, and will be discussed in more detail in Section 17.4.1 and Section 17.3. Another
way to avoid overfitting is to adopt a Bayesian approach, by integrating out the weights w; this gives
rise to a model called a Gaussian process, which will be discussed in more detail in Section 17.2.
13.6.1.1 RBF network for regression
We can use RBF networks for regression by defining p(y|x, θ) = N (wT φ(x), σ2
). For example,
Figure 13.22 shows a 1d data set fit with K = 10 uniformly spaced RBF prototypes, but with the
bandwidth ranging from small to large. Small values lead to very wiggly functions, since the predicted
function value will only be non-zero for points x that are close to one of the prototypes µk. If the
bandwidth is very large, the design matrix reduces to a constant matrix of 1’s, since each point is
equally close to every prototype; hence the corresponding function is just a straight line.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license454 Chapter 13. Neural Networks for Structured Data
(a)
poly10
(b)
rbf prototypes
(c)
Figure 13.21: (a) xor truth table. (b) Fitting a linear logistic regression classifier using degree 10 polynomial
expansion. (c) Same model, but using an RBF kernel with centroids specified by the 4 black crosses. Generated
by code at figures.probml.ai/book1/13.21.
13.6.1.2 RBF network for classification
We can use RBF networks for binary classification by defining p(y|x, θ) = Ber(σ(wT φ(x))). As an
example, consider the data coming from the exclusive or function. This is a binary-valued function
of two binary inputs. Its truth table is shown in Figure 13.21(a). In Figure 13.1(b), we have shown
some data labeled by the xor function, but we have jittered the points to make the picture clearer.6
We see we cannot separate the data even using a degree 10 polynomial. However, using an RBF
kernel and just 4 prototypes easily solves the problem as shown in Figure 13.1(c).
13.6.2 Mixtures of experts
When considering regression problems, it is common to assume a unimodal output distribution, such
as a Gaussian or Student distribution, where the mean and variance is some function of the input,
i.e.,
p(y|x) = N (y|fµ(x), diag(σ+(fσ(x)))) (13.105)
where the f functions may be MLPs (possibly with some shared hidden units, as in Figure 13.5).
However, this will not work well for one-to-many functions, in which each input can have multiple
possible outputs.
Figure 13.23a gives a simple example of such a function. We see that in the middle of the plot there
are certain x values for which there are two equally probable y values. There are many real world
problems of this form, e.g., 3d pose prediction of a person from a single image [Bo+08], colorization
of a black and white image [Gua+17], predicting future frames of a video sequence [VT17], etc. Any
model which is trained to maximize likelihood using a unimodal output density — even if the model
is a flexible nonlinear model, such as neural network — will work poorly on one-to-many functions
such as these, since it will just produce a blurry average output.
6. Jittering is a common visualization trick in statistics, wherein points in a plot/display that would otherwise land on
top of each other are dispersed with uniform additive noise.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.6. Other kinds of feedforward networks * 455
0 5 10 15 20
10
5
0
5
10
15
20
0 5 10 15 20
0.0
0.2
0.4
0.6
0.8
1.0
2 4 6 8
20
15
10
5
0 5 10 15 20
10
5
0
5
10
15
20
0 5 10 15 20
0.2
0.4
0.6
0.8
1.0
2 4 6 8
20
15
10
5
0 5 10 15 20
10
5
0
5
10
15
20
0 5 10 15 20
0.92
0.93
0.94
0.95
0.96
0.97
0.98
0.99
1.00
2 4 6 8
20
15
10
5
Figure 13.22: Linear regression using 10 equally spaced RBF basis functions in 1d. Left column: fitted function.
Middle column: basis functions evaluated on a grid. Right column: design matrix. Top to bottom we show dif￾ferent bandwidths for the kernel function: σ = 0.5, 10, 50. Generated by code at figures.probml.ai/book1/13.22.
To prevent this problem of regression to the mean, we can use a conditional mixture model.
That is, we assume the output is a weighted mixture of K different outputs, corresponding to different
modes of the output distribution for each input x. In the Gaussian case, this becomes
p(y|x) = X
K
k=1
p(y|x, z = k)p(z = k|x) (13.106)
p(y|x, z = k) = N (y|fµ,k(x), diag(fσ,k(x))) (13.107)
p(z = k|x) = Cat(z|S(fz(x))) (13.108)
Here fµ,k predicts the mean of the k’th Gaussian, fσ,k predicts its variance terms, and fz predicts
which mixture component to use. This model is called a mixture of experts (MoE) [Jac+91;
JJ94; YWG12; ME14]. The idea is that the k’th submodel p(y|x, z = k) is considered to be an
“expert” in a certain region of input space. The function p(z = k|x) is called a gating function,
and decides which expert to use, depending on the input values. By picking the most likely expert
for a given input x, we can “activate” just a subset of the model. This is an example of conditional
computation, since we decide what expert to run based on the results of earlier computations from
the gating network [Sha+17].
We can train this model using SGD, or using the EM algorithm (see Section 8.7.3 for details on
the latter method).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license456 Chapter 13. Neural Networks for Structured Data
0.0 0.2 0.4 0.6 0.8 1.0
0.0
0.2
0.4
0.6
0.8
1.0
Inverse problem
(a)
0.0 0.2 0.4 0.6 0.8 1.0
0.0
0.2
0.4
0.6
0.8
1.0
Gating functions
(b)
0.0 0.2 0.4 0.6 0.8 1.0
0.0
0.2
0.4
0.6
0.8
1.0
Expert-predictions
(c)
0.0 0.2 0.4 0.6 0.8 1.0
0.0
0.2
0.4
0.6
0.8
1.0
prediction
mode
mean
(d)
Figure 13.23: (a) Some data from a one-to-many function. Horizontal axis is the input x, vertical axis is the
target y = f(x). (b) The responsibilities of each expert for the input domain. (c) Prediction of each expert
(colored lines) superimposed on the training data. (d) Overall prediction. Mean is red cross, mode is black
square. Adapted from Figures 5.20 and 5.21 of [Bis06]. Generated by code at figures.probml.ai/book1/13.23.
13.6.2.1 Mixture of linear experts
In this section, we consider a simple example in which we use linear regression experts and a linear
classification gating function, i.e., the model has the form:
p(y|x, z = k, θ) = N (y|wT
kx, σ2
k
) (13.109)
p(z = k|x, θ) = Cat(z|Sk(Vx)) (13.110)
where Sk is the k’th output from the softmax function. The individual weighting term p(z = k|x) is
called the responsibility for expert k for input x. In Figure 13.23b, we see how the gating networks
softly partitions the input space amongst the K = 3 experts.
Each expert p(y|x, z = k) corresponds to a linear regression model with different parameters.
These are shown in Figure 13.23c.
If we take a weighted combination of the experts as our output, we get the red curve in Figure 13.23a,
which is clearly is a bad predictor. If instead we only predict using the most active expert (i.e., the
one with the highest responsibility), we get the discontinuous black curve, which is a much better
predictor.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.7. Exercises 457
Figure 13.24: Deep MOE with m experts, represented as a neural network. From Figure 1 of [CGG17]. Used
with kind permission of Jacob Goldberger.
13.6.2.2 Mixture density networks
The gating function and experts can be any kind of conditional probabilistic model, not just a linear
model. If we make them both DNNs, then resulting model is called a mixture density network
(MDN) [Bis94; ZS14] or a deep mixture of experts [CGG17]. See Figure 13.24 for a sketch of
the model.
13.6.2.3 Hierarchical MOEs
If each expert is itself an MoE model, the resulting model is called a hierarchical mixture of
experts [JJ94]. See Figure 13.25 for an illustration of such a model with a two level hierarchy.
An HME with L levels can be thought of as a “soft” decision tree of depth L, where each example
is passed through every branch of the tree, and the final prediction is a weighted average. (We discuss
decision trees in Section 18.1.)
13.7 Exercises
Exercise 13.1 [Backpropagation for a MLP]
(Based on an exercise by Kevin Clark.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license458 Chapter 13. Neural Networks for Structured Data
Expert
Network
Gating 
Network
Expert
Network
Expert
Network
Expert
Network
Gating 
Network
Gating 
Network
x x x x
x
x
x
y
Figure 13.25: A 2-level hierarchical mixture of experts as a neural network. The top gating network chooses
between the left and right expert, shown by the large boxes; the left and right experts themselves choose between
their left and right sub-experts.
Consider the following classification MLP with one hidden layer:
x = input ∈ R
D (13.111)
z = Wx + b1 ∈ R
K (13.112)
h = ReLU(z) ∈ R
K (13.113)
a = Vh + b2 ∈ R
C
(13.114)
L = CrossEntropy(y, S(a)) ∈ R (13.115)
where x ∈ R
D, b1 ∈ R
K, W ∈ R
K×D, b2 ∈ R
C , V ∈ R
C×K, where D is the size of the input, K is the
number of hidden units, and C is the number of classes. Show that the gradients for the parameters and
input are as follows:
∇VL =

∂L
∂V

1,:
= u2h
T ∈ R
C×K (13.116)
∇b2L =

∂L
∂b2
T
= u2 ∈ R
C
(13.117)
∇WL =

∂L
∂W

1,:
= u1x
T ∈ R
K×D (13.118)
∇b1L =

∂L
∂b1
T
= u1 ∈ R
K (13.119)
∇xL =

∂L
∂x
T
= WT u1 ∈ R
D (13.120)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202213.7. Exercises 459
where the gradients of the loss wrt the two layers (logit and hidden) are given by the following:
u2 = ∇aL =

∂L
∂a
T
= (p − y) ∈ R
C
(13.121)
u1 = ∇zL =

∂L
∂z
T
= (V
T u2)  H(z) ∈ R
K (13.122)
with H is the Heaviside function. Note that, in our notation, the gradient (which has the same shape as the
variable with respect to which we differentiate) is equal to the Jacobian’s transpose when the variable is a
vector and to the first slice of the Jacobian when the variable is a matrix.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license14 Neural Networks for Images
14.1 Introduction
In Chapter 13, we discussed multilayered perceptrons (MLPs) as a way to learn functions mapping
“unstructured” input vectors x ∈ R
D to outputs. In this chapter, we extend this to the case where the
input x has 2d spatial structure. (Similar ideas apply to 1d temporal structure, or 3d spatio-temporal
structure.)
To see why it is not a good idea to apply MLPs directly to image data, recall that the core
operation in an MLP at each hidden layer is computing the activations z = ϕ(Wx), where x is the
input to a layer, W are the weights, and ϕ() is the nonlinear activation function. Thus the j’th
element of the hidden layer has value zj = ϕ(wT
j x). We can think of this inner product operation
as comparing the input x to a learned template or pattern wj ; if the match is good (large positive
inner product), the activation of that unit will be large (assuming a ReLU nonlinearity), signalling
that the j’th pattern is present in the input.
However, this does not work well if the input is a variable-sized image, x ∈ RWHC , where W is the
width, H is the height, and C is the number of input channels (e.g., C = 3 for RGB color). The
problem is that we would need to learn a different-sized weight matrix W for every size of input
image. In addition, even if the input was fixed size, the number of parameters needed would be
prohibitive for reasonably sized images, since the weight matrix would have size (W × H × C) × D,
where D is the number of outputs (hidden units). The final problem is that a pattern that occurs
in one location may not be recognized when it occurs in a different location — that is, the model
may not exhibit translation invariance — because the weights are not shared across locations (see
Figure 14.1).
To solve these problems, we will use convolutional neural networks (CNNs), in which we
replace matrix multiplication with a convolution operation. We explain this in detail in Section 14.2,
but the basic idea is to divide the input into overlapping 2d image patches, and to compare each
patch with a set of small weight matrices, or filters, which represent parts of an object; this is
illustrated in Figure 14.2. We can think of this as a form of template matching. We will learn
these templates from data, as we explain below. Because the templates are small (often just 3x3 or
5x5), the number of parameters is significantly reduced. And because we use convolution to do the
template matching, instead of matrix multiplication, the model will be translationally invariant. This
is useful for tasks such as image classification, where the goal is to classify if an object is present,
regardless of its location.
CNNs have many other applications besides image classification, as we will discuss later in this
chapter. They can also be applied to 1d inputs (see Section 15.3) and 3d inputs; however, we mostly462 Chapter 14. Neural Networks for Images
1 1 1 0
0 1 0 0
0 0 0 0
0 1 0 0
5 1 1 1 0
0 1 0 0
0 0 0 0
0 1 0 0
1
OUTPUT
WEIGHTS WEIGHTS
0
1
0
1
1
1
0
0
1
0
0
0
0
0
0
0
0
1
0
1
1
1
0
0
1
0
0
0
0
0
0
0
X + +
0
0
1
0
0
1
1
1
0
0
1
0
0
0
0
0
0
1
0
1
1
1
0
0
1
0
0
0
0
0
0
0
X
Figure 14.1: Detecting patterns in 2d images using unstructured MLPs does not work well, because the method
is not translation invariant. We can design a weight vector to act as a matched filter for detecting the
desired cross-shape. This will give a strong response of 5 if the object is on the left, but a weak response of 1
if the object is shifted over to the right. Adapted from Figure 7.16 of [SAV20].
Figure 14.2: We can classify a digit by looking for certain discriminative features (image templates) occuring
in the correct (relative) locations. From Figure 5.1 of [Cho17]. Used with kind permission of Francois Chollet.
focus on the 2d case in this chapter.
14.2 Common layers
In this section, we discuss the basics of CNNs.
14.2.1 Convolutional layers
We start by describing the basics of convolution in 1d, and then in 2d, and then describe how they
are used as a key component of CNNs.
14.2.1.1 Convolution in 1d
The convolution between two functions, say f, g : R
D → R, is defined as
[f ~ g](z) = Z
RD
f(u)g(z − u)du (14.1)
Now suppose we replace the functions with finite-length vectors, which we can think of as functions
defined on a finite set of points. For example, suppose f is evaluated at the points {−L, −L +
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.2. Common layers 463
- - 1 2 3 4 - -
7 6 5 - - - - - z0 = x0w0 = 5
- 7 6 5 - - - - z1 = x0w1 + x1w0 = 16
- - 7 6 5 - - - z2 = x0w2 + x1w1 + x2w0 = 34
- - - 7 6 5 - - z3 = x1w2 + x2w1 + x3w0 = 52
- - - - 7 6 5 - z4 = x2w2 + x3w1 = 45
- - - - - 7 6 5 z5 = x3w2 = 28
Figure 14.3: Discrete convolution of x = [1, 2, 3, 4] with w = [5, 6, 7] to yield z = [5, 16, 34, 52, 45, 28]. We
see that this operation consists of “flipping” w and then “dragging” it over x, multiplying elementwise, and
adding up the results.
as
Figure 14.4: 1d cross correlation. From Figure 15.3.2 of [Zha+20]. Used with kind permission of Aston
Zhang.
1, . . . , 0, 1, . . . , L} to yield the weight vector (also called a filter or kernel) w−L = f(−L) up to
wL = f(L). Now let g be evaluated at points {−N, . . . , N} to yield the feature vector x−N = g(−N)
up to xN = g(N). Then the above equation becomes
[w ~ x](i) = w−Lxi+L + · · · + w−1xi+1 + w0xi + w1xi−1 + · · · + wLxi−L (14.2)
(We discuss boundary conditions (edge effects) later on.) We see that we “flip” the weight vector w
(since indices of w are reversed), and then “drag” it over the x vector, summing up the local windows
at each point, as illustrated in Figure 14.3.
There is a very closely related operation, in which we do not flip w first:
[w ∗ x](i) = w−Lxi−L + · · · + w−1xi−1 + w0xi + w1xi+1 + · · · + wLxi+L (14.3)
This is called cross correlation; If the weight vector is symmetric, as is often the case, then cross
correlation and convolution are the same. In the deep learning literature, the term “convolution” is
usually used to mean cross correlation; we will follow this convention.
We can also evaluate the weights w on domain {0, 1, . . . , L − 1} and the features x on domain
{0, 1, . . . , N − 1}, to eliminate negative indices. Then the above equation becomes
[w ~ x](i) =
L
X−1
u=0
wuxi+u (14.4)
See Figure 14.4 for an example.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license464 Chapter 14. Neural Networks for Images
Figure 14.5: Illustration of 2d cross correlation. Generated by code at figures.probml.ai/book1/14.5. Adapted
from Figure 6.2.1 of [Zha+20].
Figure 14.6: Convolving a 2d image (left) with a 3 × 3 filter (middle) produces a 2d response map (right).
The bright spots of the response map correspond to locations in the image which contain diagonal lines sloping
down and to the right. From Figure 5.3 of [Cho17]. Used with kind permission of Francois Chollet.
14.2.1.2 Convolution in 2d
In 2d, Equation (14.4) becomes
[W~ X](i, j) =
H
X−1
u=0
W
X−1
v=0
wu,vxi+u,j+v (14.5)
where the 2d filter W has size H × W. For example, consider convolving a 3 × 3 input X with a
2 × 2 kernel W to compute a 2 × 2 output Y:
Y =

w1 w2
w3 w4

~


x1 x2 x3
x4 x5 x6
x7 x8 x9

 (14.6)
=

(w1x1 + w2x2 + w3x4 + w4x5) (w1x2 + w2x3 + w3x5 + w4x6)
(w1x4 + w2x5 + w3x7 + w4x8) (w1x5 + w2x6 + w3x8 + w4x9)

(14.7)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.2. Common layers 465
See Figure 14.5 for a visualization of this process.
We can think of 2d convolution as template matching, since the output at a point (i, j) will
be large if the corresponding image patch centered on (i, j) is similar to W. If the template W
corresponds to an oriented edge, then convolving with it will cause the output heat map to “light up”
in regions that contain edges that match that orientation, as shown in Figure 14.6. More generally,
we can think of convolution as a form of feature detection. The resulting output Y = W~ X is
therefore called a feature map.
14.2.1.3 Convolution as matrix-vector multiplication
Since convolution is a linear operator, we can represent it by matrix multiplication. For example,
consider Equation (14.7). We can rewrite this as matrix-vector mutiplication by flattening the 2d
matrix X into a 1d vector x, and multiplying by a Toeplitz-like matrix C derived from the kernel
W, as follows:
y = Cx =


w1 w2 0 w3 w4 0 0 0 0
0 w1 w2 0 w3 w4 0 0 0
0 0 0 w1 w2 0 w3 w4 0
0 0 0 0 w1 w2 0 w3 w4




x1
x2
x3
x4
x5
x6
x7
x8
x9


(14.8)
=


w1x1 + w2x2 + w3x4 + w4x5
w1x2 + w2x3 + w3x5 + w4x6
w1x4 + w2x5 + w3x7 + w4x8
w1x5 + w2x6 + w3x8 + w4x9


(14.9)
We can recover the 2 × 2 output by reshaping the 4 × 1 vector y back to Y.
1
Thus we see that CNNs are like MLPs where the weight matrices have a special sparse structure,
and the elements are tied across spatial locations. This implements the idea of translation invariance,
and massively reduces the number of parameters compared to a weight matrix in a standard fully
connected or dense layer, as used in MLPs.
14.2.1.4 Boundary conditions and padding
In Equation (14.7), we saw that convolving a 3 × 3 image with a 2 × 2 filter resulted in a 2 × 2
output. In general, convolving a fh × fw filter over an image of size xh × xw produces an output of
size (xh − fh + 1) × (xw − fw + 1); this is called valid convolution, since we only apply the filter to
“valid” parts of the input, i.e., we don’t let it “slide off the ends”. If we want the output to have the
same size as the input, we can use zero-padding, which means we add a border of 0s to the image,
as illustrated in Figure 14.7. This is called same convolution.
1. See code.probml.ai/book1/conv2d_torch for a demo.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license466 Chapter 14. Neural Networks for Images
1 1 1 0 0
0 1 0 1 0
0 0 0 0
0 0 0 0
0 1 0
1 1 1 0
0 1 0 0 0
1 1 1 0 0
0 1 0
0 1 0 0
1 1 1 1 0
0 1 0 0 0
0 0 0 0
0 1 0 0 0
0 1 0 1 0
1 1 1 0 0
0 1 0 0 0
0 0 0 0
1 1 1 0
0 1 0 0
0 1 0 0
0 0 0 0
0 1 0
1 1 1 0
0 1 0 0
1 1 1 0
0 1 0
0 1 0 0
1 1 1 0
0 1 0 0
0 0 0 0
0 1 0 0
0 1 0 0
1 1 1 0
0 1 0 0
0 1 0 0
0 1 1 1
1 0 1 0
0 1 0 0
0 0 0 0
0 1 0
1 1 1 0
0 0 1 0
0 1 1 1
0 1 0
0 1 0 0
1 1 1 1
0 0 1 0
0 0 0 0
0 0 1 0
1 0 1 0
0 1 1 1
0 0 1 0
0 1 0 0
0 1 1 1 1
1 1 0 1 0
0 1 0 0
0 0 0 0
0 1 0
1 1 1 0
0 1 0 1 0
0 0 1 1 1
0 1 0
0 1 0 0
1 1 1 1 1
0 1 0 1 0
0 0 0 0
0 1 0 1 0
1 1 0 1 0
0 1 1 1 1
0 0 0 1 0
0 1 0 0
2
2
2
0
0
1
0
0
2
2
2
0
2
5
2
1
Zeros
outside
OUTPUT
Figure 14.7: Same-convolution (using zero-padding) ensures the output is the same size as the input. Adapted
from Figure 8.3 of [SAV20].
i
j
f
f
h
w
= 3
= 3 Zero Padding
(a)
Sw = 2
Sh = 2 (b)
Figure 14.8: Illustration of padding and strides in 2d convolution. (a) We apply “same convolution” to a
5 × 7 input (with zero padding) using a 3 × 3 filter to create a 5 × 7 output. (b) Now we use a stride of 2, so
the output has size 3 × 4. Adapted from Figures 14.3–14.4 of [Gér19].
In general, if the input has size xh × xw, we use a kernel of size fh × fw, we use zero padding on
each side of size ph and pw, then the output has the following size [DV16]:
(xh + 2ph − fh + 1) × (xw + 2pw − fw + 1) (14.10)
For example, consider Figure 14.8a. We have p = 1, f = 3, xh = 5 and xw = 7, so the output has
size
(5 + 2 − 3 + 1) × (7 + 2 − 3 + 1) = 5 × 7 (14.11)
If we set 2p = f − 1, then the output will have the same size as the input.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.2. Common layers 467
Figure 14.9: Illustration of 2d convolution applied to an input with 2 channels. Generated by code at
figures.probml.ai/book1/14.9. Adapted from Figure 6.4.1 of [Zha+20].
14.2.1.5 Strided convolution
Since each output pixel is generated by a weighted combination of inputs in its receptive field
(based on the size of the filter), neighboring outputs will be very similar in value, since their inputs
are overlapping. We can reduce this redundancy (and speedup computation) by skipping every s’th
input. This is called strided convolution. This is illustrated in Figure 14.8b, where we convolve a
5 × 7 image with a 3 × 3 filter with stride 2 to get a 3 × 4 output.
In general, if the input has size xh × xw, we use a kernel of size fh × fw, we use zero padding on
each side of size ph and pw, and we use strides of size sh and sw, then the output has the following
size [DV16]:

xh + 2ph − fh + sh
sh

×

xw + 2pw − fw + sw
sw

(14.12)
For example, consider Figure 14.8b, where we set the stride to s = 2. Now the output is smaller than
the input.

b
5 + 2 − 3 + 2
2
c, b
7 + 2 − 3 + 2
2
c

=

b
6
2
c, b
4
1
c

= 3 × 4 (14.13)
14.2.1.6 Multiple input and output channels
In Figure 14.6, the input was a gray-scale image. In general, the input will have multiple channels
(e.g., RGB, or hyper-spectral bands for satellite images). We can extend the definition of convolution
to this case by defining a kernel for each input channel; thus now W is a 3d weight matrix or tensor.
We compute the output by convolving channel c of the input with kernel W:,:,c, and then summing
over channels:
zi,j = b +
H
X−1
u=0
W
X−1
v=0
C
X−1
c=0
xsi+u,sj+v,cwu,v,c (14.14)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license468 Chapter 14. Neural Networks for Images
Feature 
map 1
map 2
Map 2
Feature
Map 1
Covolutional 
Layer 2
Covolutional 
Layer 1
Input Layer 
Filters
Channels Red
Blue
Green
Figure 14.10: Illustration of a CNN with 2 convolutional layers. The input has 3 color channels. The feature
maps at internal layers have multiple channels. The cylinders correspond to hypercolumns, which are feature
vectors at a certain location. Adapted from Figure 14.6 of [Gér19].
where s is the stride (which we assume is the same for both height and width, for simplicity), and b
is the bias term. This is illustrated in Figure 14.9.
Each weight matrix can detect a single kind of feature. We typically want to detect multiple kinds
of features, as illustrated in Figure 14.2. We can do this by making W into a 4d weight matrix. The
filter to detect feature type d in input channel c is stored in W:,:,c,d. We extend the definition of
convolution to this case as follows:
zi,j,d = bd +
H
X−1
u=0
W
X−1
v=0
C
X−1
c=0
xsi+u,sj+v,cwu,v,c,d (14.15)
This is illustrated in Figure 14.10. Each vertical cylindrical column denotes the set of output features
at a given location, zi,j,1:D; this is sometimes called a hypercolumn. Each element is a different
weighted combination of the C features in the receptive field of each of the feature maps in the layer
below.2
14.2.1.7 1 × 1 (pointwise) convolution
Sometimes we just want to take a weighted combination of the features at a given location, rather
than across locations. This can be done using 1x1 convolution, also called pointwise convolution.
2. In Tensorflow, a filter for 2d CNNs has shape (H, W, C, D), and a minibatch of feature maps has shape (batch-size,
image-height, image-width, image-channels); this is called NHWC format. Other systems use different data layouts.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.2. Common layers 469
Figure 14.11: Mapping 3 channels to 2 using convolution with a filter of size 1 × 1 × 3 × 2. Adapted from
Figure 6.4.2 of [Zha+20].
Figure 14.12: Illustration of maxpooling with a 2x2 filter and a stride of 1. Adapted from Figure 6.5.1 of
[Zha+20].
This changes the number of channels from C to D, without changing the spatial dimensionality:
zi,j,d = bd +
C
X−1
c=0
xi,j,cw0,0,c,d (14.16)
This can be thought of as a single layer MLP applied to each feature column in parallel.
14.2.2 Pooling layers
Convolution will preserve information about the location of input features (modulo reduced resolution),
a property known as equivariance. In some case we want to be invariant to the location. For
example, when performing image classification, we may just want to know if an object of interest
(e.g., a face) is present anywhere in the image.
One simple way to achieve this is called max pooling, which just computes the maximum over
its incoming values, as illustrated in Figure 14.12. An alternative is to use average pooling, which
replaces the max by the mean. In either case, the output neuron has the same response no matter
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license470 Chapter 14. Neural Networks for Images
CAR
TRUCK
VAN
BICYCLE
INPUT CONVOLUTION + RELU POOLING CONVOLUTION + RELU POOLING FLATTEN SOFTMAX FULLY
CONNECTED
FEATURE LEARNING CLASSIFICATION
Figure 14.13: A simple CNN for classifying images. Adapted from https: // blog. floydhub. com/
building-your-first-convnet/ .
where the input pattern occurs within its receptive field. (Note that we apply pooling to each feature
channel independently.)
If we average over all the locations in a feature map, the method is called global average pooling.
Thus we can convert a H × W × D feature map into a 1 × 1 × D dimensional feature map; this can
be reshaped to a D-dimensional vector, which can be passed into a fully connected layer to map it
to a C-dimensional vector before passing into a softmax output. The use of global average pooling
means we can apply the classifier to an image of any size, since the final feature map will always be
converted to a fixed D-dimensional vector before being mapped to a distribution over the C classes.
14.2.3 Putting it all together
A common design pattern is to create a CNN by alternating convolutional layers with max pooling
layers, followed by a final linear classification layer at the end. This is illustrated in Figure 14.13.
(We omit normalization layers in this example, since the model is quite shallow.) This design pattern
first appeared in Fukushima’s neocognitron [Fuk75], and was inspired by Hubel and Wiesel’s model
of simple and complex cells in the human visual cortex [HW62]. In 1998 Yann LeCun used a similar
design in his eponynous LeNet model [LeC+98], which used backpropagation and SGD to esitmate
the parameters. This design pattern continues to be popular in neurally-inspired models of visual
object recognition [RP99], as well as various practical applications (see Section 14.3 and Section 14.5).
14.2.4 Normalization layers
The basic design in Figure 14.13 works well for shallow CNNs, but it can be difficult to scale it to
deeper models, due to problems with vanishing or exploding gradients, as explained in Section 13.4.2.
A common solution to this problem is to add extra layers to the model, to standardize the statistics
of the hidden units (i.e., to ensure they are zero mean and unit variance), just like we do to the
inputs of many models. We discuss various kinds of normalization layers below.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.2. Common layers 471
14.2.4.1 Batch normalization
The most popular normalization layer is called batch normalization (BN) [IS15]. This ensures
the distribution of the activations within a layer has zero mean and unit variance, when averaged
across the samples in a minibatch. More precisely, we replace the activation vector zn (or sometimes
the pre-activation vector an) for example n (in some layer) with z˜n, which is computed as follows:
z˜n = γ  zˆn + β (14.17)
zˆn = p
zn − µB
σ
2
B + 
(14.18)
µB =
1
|B|
X
z∈B
z (14.19)
σ
2
B =
1
|B|
X
z∈B
(z − µB)
2
(14.20)
where B is the minibatch containing example n, µB is the mean of the activations for this batch3
, σ
2
B
is the corresponding variance, zˆn is the standardized activation vector, z˜n is the shifted and scaled
version (the output of the BN layer), β and γ are learnable parameters for this layer, and  > 0 is a
small constant. Since this transformation is differentiable, we can easily pass gradients back to the
input of the layer and to the BN parameters β and γ.
When applied to the input layer, batch normalization is equivalent to the usual standardization
procedure we discussed in Section 10.2.8. Note that the mean and variance for the input layer
can be computed once, since the data is static. However, the empirical means and variances of
the internal layers keep changing, as the parameters adapt. (This is sometimes called “internal
covariate shift”.) This is why we need to recompute µ and σ
2 on each minibatch.
At test time, we may have a single input, so we cannot compute batch statistics. The standard
solution to this is as follows: after training, compute µl and σ
2
l
for layer l across all the examples
in the training set (i.e. using the full batch), and then “freeze” these parameters, and add them
to the list of other parameters for the layer, namely βl and γl
. At test time, we then use these
frozen training values for µl and σ
2
l
, rather than computing statistics from the test batch. Thus
when using a model with BN, we need to specify if we are using it for inference or training. (See
batchnorm_torch.ipynb for some sample code.)
For speed, we can combine a frozen batch norm layer with the previous layer. In particular suppose
the previous layer computes XW + b; combining this with BN gives γ (XW + b − µ)/σ + β. If
we define W0 = γ W/σ and b
0 = γ (b − µ)/σ + β, then we can write the combined layers as
XW0 + b
0
. This is called fused batchnorm. Similar tricks can be developed to speed up BN during
training [Jun+19].
The benefits of batch normalization (in terms of training speed and stability) can be quite dramatic,
especially for deep CNNs. The exact reasons for this are still unclear, but BN seems to make the
optimization landscape significantly smoother [San+18b]. It also reduces the sensitivity to the
learning rate [ALL18]. In addition to computational advantages, it has statistical advantages. In
3. When applied to a convolutional layer, we average across spatial locations and across examples, but not across
channels (so the length of µ is the number of channels). When applied to a fully connected layer, we just average
across examples (so the length of µ is the width of the layer).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license472 Chapter 14. Neural Networks for Images
H, W
C N
Batch Norm
H, W
C N
Layer Norm
H, W
C N
Instance Norm
H, W
C N
Group Norm
Figure 14.14: Illustration of different activation normalization methods for a CNN. Each subplot shows a
feature map tensor, with N as the batch axis, C as the channel axis, and (H, W) as the spatial axes. The
pixels in blue are normalized by the same mean and variance, computed by aggregating the values of these
pixels. Left to right: batch norm, layer norm, instance norm, and group norm (with 2 groups of 3 channels).
From Figure 2 of [WH18]. Used with kind permission of Kaiming He.
particular, BN acts like a regularizer; indeed it can be shown to be equivalent to a form of approximate
Bayesian inference [TAS18; Luo+19].
However, the reliance on a minibatch of data causes several problems. In particular, it can result
in unstable estimates of the parameters when training with small batch sizes, although a more
recent version of the method, known as batch renormalization [Iof17], partially addresses this.
We discuss some other alternatives to batch norm below.
14.2.4.2 Other kinds of normalization layer
In Section 14.2.4.1 we discussed batch normalization, which standardizes all the activations within
a given feature channel to be zero mean and unit variance. This can significantly help with training,
and allow for a larger learning rate. (See code.probml.ai/book1/batchnorm_torch for some sample
code.)
Although batch normalization works well, it struggles when the batch size is small, since the
estimated mean and variance parameters can be unreliable. One solution is to compute the mean
and variance by pooling statistics across other dimensions of the tensor, but not across examples
in the batch. More precisely, let zi refer to the i’th element of a tensor; in the case of 2d images,
the index i has 4 components, indicating batch, height, width and channel, i = (iN , iH, iW , iC ). We
compute the mean and standard deviation for each index zi as follows:
µi =
1
|Si
|
X
k∈Si
zk, σi =
s
1
|Si
|
X
k∈Si
(zk − µi)
2 +  (14.21)
where Si
is the set of elements we average over. We then compute zˆi = (zi −µi)/σi and z˜i = γczˆi +βc,
where c is the channel corresponding to index i.
In batch norm, we pool over batch, height, width, so Si
is the set of all location in the tensor
that match the channel index of i. To avoid problems with small batches, we can instead pool over
channel, height and width, but match on the batch index. This is known as layer normalization
[BKH16]. (See code.probml.ai/book1/layer_norm_torch for some sample code.) Alternatively, we
can have separate normalization parameters for each example in the batch and for each channel.
This is known as instance normalization [UVL16].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.3. Common architectures for image classification 473
A natural generalization of the above methods is known as group normalization [WH18], where
we pool over all locations whose channel is in the same group as i’s. This is illustrated in Figure 14.14.
Layer normalization is a special case in which there is a single group, containing all the channels.
Instance normalization is a special case in which there are C groups, one per channel. In [WH18],
they show experimentally that it can be better (in terms of training speed, as well as training and test
accuracies) to use groups that are larger than individual channels, but smaller than all the channels.
More recently, [SK20] proposed filter response normalization which is an alternative to batch
norm that works well even with a minibatch size of 1. The idea is to define each group as all locations
with a single channel and batch sample (as in instance normalization), but then to just divide by
the mean squared norm instead of standardizing. That is, if the input (for a given channel and
batch entry) is z = Zb,:,:,c ∈ R
N , we compute zˆ = z/
√
ν
2 + , where ν
2 =
P
ij z
2
bijc/N, and then
z˜ = γczˆ + βc. Since there is no mean centering, the activations can drift away from 0, which can
have detrimental effects, especially with ReLU activations. To compensate for this, the authors
propose to add a thresholded linear unit at the output. This has the form y = max(x, τ ), where
τ is a learnable offset. The combination of FRN and TLU results in good performance on image
classification and object detection even with a batch size of 1.
14.2.4.3 Normalizer-free networks
Recently, [Bro+21] have proposed a method called normalizer-free networks, which is a way to
train deep residual networks without using batchnorm or any other form of normalization layer.
The key is to replace it with adaptive gradient clipping, as an alternative way to avoid training
instabilities. That is, we use Equation (13.70), but adapt the clipping strength dynamically. The
resulting model is faster to train, and more accurate, than other competitive models trained with
batchnorm.
14.3 Common architectures for image classification
It is common to use CNNs to perform image classification, which is the task of estimating the function
f : R
H×W×K → {0, 1}
C , where K is the number of input channels (e.g., K = 3 for RGB images),
and C is the number of class labels.
In this section, we briefly review various CNNs that have been developed over the years to
solve image classification tasks. See e.g., [Kha+20] for a more extensive review of CNNs, and e.g.,
https://github.com/rwightman/pytorch-image-models for an up-to-date repository of code and
models (in PyTorch).
14.3.1 LeNet
One of the earliest CNNs, created in 1998, is known as LeNet [LeC+98], named after its creator,
Yann LeCun. It was designed to classify images of handwritten digits, and was trained on the MNIST
dataset introduced in Section 3.5.2. The model is shown in Figure 14.15. (See also Figure 14.16a for a
more compact representation of the model.) Some predictions of this model are shown in Figure 14.17.
After just 1 epoch, the test accuracy is already 98.8%. By contrast, the MLP in Section 13.2.4.2 had
an accuracy of 95.9% after 1 epoch. More rounds of training can further increase accuracy to a point
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license474 Chapter 14. Neural Networks for Images
Figure 14.15: LeNet5, a convolutional neural net for classifying handwritten digits. From Figure 6.6.1 of
[Zha+20]. Used with kind permission of Aston Zhang.
Dense (120)
Dense (84)
Dense (10)
2x2 AvgPool, stride 2
5x5 Conv (16)
2x2 AvgPool, stride 2
5x5 Conv (6), pad 2
Image (28x28)
(a)
Dense (4096)
Dense (4096)
Dense (1000)
3x3 MaxPool, stride 2
3x3 Conv (384), pad 1
3x3 Conv (384), pad 1
5x5 Conv (256), pad 2
3x3 Conv (384), pad 1
3x3 MaxPool, stride 2
11x11 Conv (96), stride 4
Image (3x224x224)
3x3 MaxPool, stride 2
(b)
Figure 14.16: (a) LeNet5. We assume the input has size 1 × 28 × 28, as is the case for MNIST. From Figure
6.6.2 of [Zha+20]. Used with kind permission of Aston Zhang. (b) AlexNet. We assume the input has size
3×224×224, as is the case for (cropped and rescaled) images from ImageNet. From Figure 7.1.2 of [Zha+20].
Used with kind permission of Aston Zhang.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.3. Common architectures for image classification 475
(a) (b)
Figure 14.17: Results of applying a CNN to some MNIST images (cherry picked to include some errors).
Red is incorrect, blue is correct. (a) After 1 epoch of training. (b) After 2 epochs. Generated by code at
figures.probml.ai/book1/14.17.
where performance is indistinguishable from label noise. (See code.probml.ai/book1/lenet_torch for
some sample code.)
Of course, classifying isolated digits is of limited applicability: in the real world, people usually
write strings of digits or other letters. This requires both segmentation and classification. LeCun
and colleagues devised a way to combine convolutional neural networks with a model similar to a
conditional random field to solve this problem. The system was deployed by the US postal service.
See [LeC+98] for a more detailed account of the system.
14.3.2 AlexNet
Although CNNs have been around for many years, it was not until the paper of [KSH12] in 2012
that mainstream computer vision researchers paid attention to them. In that paper, the authors
showed how to reduce the (top 5) error rate on the ImageNet challenge (Section 1.5.1.2) from the
previous best of 26% to 15%, which was a dramatic improvement. This model became known as
AlexNet model, named after its creator, Alex Krizhevsky.
Figure 14.16b(b) shows the architecture. It is very similar to LeNet, shown in Figure 14.16a, with
the following differences: it is deeper (8 layers of adjustable parameters (i.e., excluding the pooling
layers) instead of 5); it uses ReLU nonlinearities instead of tanh (see Section 13.2.3 for why this is
important); it uses dropout (Section 13.5.4) for regularization instead of weight decay; and it stacks
several convolutional layers on top of each other, rather than strictly alternating between convolution
and pooling. Stacking multiple convolutional layers together has the advantage that the receptive
fields become larger as the output of one layer is fed into another (for example, three 3 × 3 filters in
a row will have a receptive field size of 7 × 7). This is better than using a single layer with a larger
receptive field, since the multiple layers also have nonlinearities in between. Also, three 3 × 3 filters
have fewer parameters than one 7 × 7.
Note that AlexNet has 60M free parameters (which is much more than the 1M labeled examples),
mostly due to the three fully connected layers at the output. Fitting this model relied on using two
GPUs (due to limited memory of GPUs at that time), and is widely considered an engineering tour
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license476 Chapter 14. Neural Networks for Images
Figure 14.18: Inception module. The 1 × 1 convolutional layers reduce the number of channels, keeping the
spatial dimensions the same. The parallel pathways through convolutions of different sizes allows the model to
learn which filter size to use for each layer. The final depth concatenation block combines the outputs of all
the different pathways (which all have the same spatial size). From Figure 7.4.1 of [Zha+20]. Used with kind
permission of Aston Zhang.
de force.
4 Figure 1.14a shows some predictions made by the model on some images from ImageNet.
14.3.3 GoogLeNet (Inception)
Google who developed a model known as GoogLeNet [Sze+15b]. (The name is a pun on Google and
LeNet.) The main difference from earlier models is that GoogLeNet used a new kind of block, known
as an inception block5
, that employs multiple parallel pathways, each of which has a convolutional
filter of a different size. See Figure 14.18 for an illustration. This lets the model learn what the
optimal filter size should be at each level. The overall model consists of 9 inception blocks followed by
global average pooling. See Figure 14.19 for an illustration. Since this model first came out, various
extensions were proposed; details can be found in [IS15; Sze+15a; SIV17].
14.3.4 ResNet
The winner of the 2015 ImageNet classification challenge was a team at Microsoft, who proposed a
model known as ResNet [He+16a]. The key idea is to replace xl+1 = Fl(xl) with
xl+1 = ϕ(xl + Fl(xl)) (14.22)
This is known as a residual block, since Fl only needs to learn the residual, or difference, between
input and output of this layer, which is a simpler task. In [He+16a], F has the form conv-BN-relu￾conv-BN, where conv is a convolutional layer, and BN is a batch norm layer (Section 14.2.4.1). See
Figure 14.20(left) for an illustration.
4. The 3 authors of the paper (Alex Krizhevsky, Ilya Sutskever and Geoff Hinton) were subsequently hired by Google,
although Ilya left in 2015, and Alex left in 2017. For more historical details, see https://en.wikipedia.org/wiki/
AlexNet. Note that AlexNet was not the first CNN implemented on a GPU; that honor goes to a group at Microsoft
[CPS06], who got a 4x speedup over CPUs, and then [Cir+11], who got a 60x speedup.
5. This term comes from the movie Inception, in which the phrase “We need to go deeper” was uttered. This became a
popular meme in 2014.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.3. Common architectures for image classification 477
Figure 14.19: GoogLeNet (slightly simplified from the original). Input is on the left. From Figure 7.4.2 of
[Zha+20]. Used with kind permission of Aston Zhang.
ReLu
Batch Norm
3X3 Conv
ReLu
+
x
Batch Norm
3X3 Conv
1x1 Conv
ReLu
Batch Norm
3X3 Conv
ReLu
+
x
Batch Norm
3X3 Conv
Figure 14.20: A residual block for a CNN. Left: standard version. Right: version with 1x1 convolution, to
allow a change in the number of channels between the input to the block and the output. From Figure 7.6.3 of
[Zha+20]. Used with kind permission of Aston Zhang
Figure 14.21: The ResNet-18 architecture. Each dotted module is a residual block shown in Figure 14.20.
From Figure 7.6.4 of [Zha+20]. Used with kind permission of Aston Zhang
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license478 Chapter 14. Neural Networks for Images
We can ensure the spatial dimensions of the output Fl(xl) of the convolutional layer match those
of the input xl by using padding. However, if we want to allow for the output of the convolutional
layer to have a different number of channels, we need to add 1 × 1 convolution to the skip connection
on xl
. See Figure 14.20(right) for an illustration.
The use of residual blocks allows us to train very deep models. The reason this is possible is that
gradient can flow directly from the output to earlier layers, via the skip connections, for reasons
explained in Section 13.4.4.
In [He+16a] trained a 152 layer ResNet on ImageNet. However, it is common to use shallower
models. For example, Figure 14.21 shows the ResNet-18 architecture, which has 18 trainable layers:
there are 2 3x3 conv layers in each residual block, and there are 8 such blocks, with an initial 7x7
conv (stride 2) and a final fully connected layer. Symbolically, we can define the model as follows:
(Conv : BN : Max) : (R : R) : (R’ : R) : (R’ : R) : (R’ : R) : Avg : FC
where R is a residual block, R’ is a residual block with skip connection (due to the change in the
number of channels) with stride 2, FC is fully connected (dense) layer, and : denotes concatenation.
Note that the input size gets reduced spatially by a factor of 2
5 = 32 (factor of 2 for each R’ block,
plus the initial Conv-7x7(2) and Max-pool), so a 224x224 images becomes a 7x7 image before going
into the global average pooling layer.
By using various tricks, we can achieve 89% top-1 accuracy on the CIFAR test set after 20 training
epochs.6
In [He+16b], they showed how a small modification of the above scheme allows us to train
models with up to 1001 layers. The key insight is that the signal on the skip connections is
still being attentuated due to the use of the nonlinear activation function after the addition step,
xl+1 = ϕ(xl + F(xl)). They showed that it is better to use
xl+1 = xl + ϕ(Fl(xl)) (14.23)
This is called a preactivation resnet or PreResnet for short. Now it is very easy for the network
to learn the identity function at a given layer: if we use ReLU activations, we just need to ensure
that Fl(xl) = 0, which we can do by setting the weights and biases to 0.
An alternative to using a very deep model is to use a very “wide” model, with lots of feature
channels per layer. This is the idea behind the wide resnet model [ZK16], which is quite popular.
14.3.5 DenseNet
In a residual net, we add the output of each function to its input. An alternative approach would
be to concatenate the output with the input, as illustrated in Figure 14.22a. If we stack a series of
such blocks, we can get an architecture similar to Figure 14.22b. This is known as a DenseNets
[Hua+17a], since each layer densely depends on all previous layers. Thus the overall model is
computing a function of the form
x → [x, f1(x), f2(x, f1(x)), f3(x, f1(x), f2(x, f1(x))), . . .] (14.24)
6. The tricks are data augmentation (Section 19.1), consisting of random crops and horizontal flips, and to use one-cycle
learning rate schedule (Section 8.4.3). If you use 50 epochs, and stochastic weight averaging (Section 8.4.4), you can
get to ∼ 94% accuracy. See code.probml.ai/book1/cifar10_cnn_lightning for the code.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.4. Other forms of convolution * 479
(a) (b)
Figure 14.22: (a) Left: a residual block adds the output to the input. Right: a densenet block concatenates the
output with the input. (b) Illustration of a densenet. From Figures 7.7.1–7.7.2 of [Zha+20]. Used with kind
permission of Aston Zhang.
The dense connectivity increases the number of parameters, since the channels get stacked depthwise.
We can compensate for this by adding 1 × 1 convolution layers in between. We can also add pooling
layers with a stride of 2 to reduce the spatial resolution. (See code.probml.ai/book1/densenet_torch
for some sample code.)
DenseNets can perform better than ResNets, since all previously computed features are directly
accessible to the output layer. However, they can be more computationally expensive.
14.3.6 Neural architecture search
We have seen how many CNNs are fairly similar in their design, and simply rearrange various building
blocks (such as convolutional or pooling layers) in different topologies, and with different parameter
settings (e.g., stride or number of channels). We can automate this design process using blackbox
(derivative free) optimization methods to find architectures that minimize the validation loss. This is
called Auto-ML; in the context of neural nets, it is called neural architecture search (NAS).
When performing NAS, we can optimize for multiple objectives at the same time, such as accuracy,
model size, training or inference speed, etc (this is how EfficientNetv2 is created [TL21]). The
main challenge arises due to the expense of computing the objective (since it requires training each
candidate point in model space). One way to reduce the number of calls to the objective function
is to use Bayesian optimization (see e.g., [WNS19]). Another approach is to create differentiable
approximations to the loss (see e.g., [LSY19; Wan+21]), or to convert the architecture into a kernel
function (using the neural tangent kernel method, Section 17.2.8), and then to analyze properties of
its eigenvalues, which can predict performance without actually training the model [CGW21]. The
field of NAS is very large and still growing. See [EMH19] for a more thorough review.
14.4 Other forms of convolution *
We discussed the basics of convolution in Section 14.2. In this section, we discuss some extensions,
which are needed for applications such as image segmentation and image generation.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license480 Chapter 14. Neural Networks for Images
Figure 14.23: Dilated convolution with a 3x3 filter using rate 1, 2 and 3. From Figure 1 of [Cui+19]. Used
with kind permission of Ximin Cui.
14.4.1 Dilated convolution
Convolution is an operation that combines the pixel values in a local neighborhood. By using striding,
and stacking many layers of convolution together, we can enlarge the receptive field of each neuron,
which is the region of input space that each neuron responds to. However, we would need many
layers to give each neuron enough context to cover the entire image (unless we used very large filters,
which would be slow and require too many parameters).
As an alternative, we can use convolution with holes [Mal99], sometimes known by the French
term à trous algorithm, and recently renamed dilated convolution [YK16]. This method simply
takes every r’th input element when performing convolution, where r is known as the rate or
dilation factor. For example, in 1d, convolving with filter w using rate r = 2 is equivalent to regular
convolution using the filter w˜ = [w1, 0, w2, 0, w3], where we have inserted 0s to expand the receptive
field (hence the term “convolution with holes”). This allows us to get the benefit of increased receptive
fields without increasing the number of parameters or the amount of compute. See Figure 14.23 for
an illustration.
More precisely, dilated convolution in 2d is defined as follows:
zi,j,d = bd +
H
X−1
u=0
W
X−1
v=0
C
X−1
c=0
xi+ru,j+rv,cwu,v,c,d (14.25)
where we assume the same rate r for both height and width, for simplicity. Compare this to
Equation (14.15), where the stride parameter uses xsi+u,sj+v,c.
14.4.2 Transposed convolution
In convolution, we reduce from a large input X to a small output Y by taking a weighted combination
of the input pixels and the convolutional kernel K. This is easiest to explain in code:
def conv(X, K):
h, w = K.shape
Y = zeros((X.shape[0] - h + 1, X.shape[1] - w + 1))
for i in range(Y.shape[0]):
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.4. Other forms of convolution * 481
Figure 14.24: Transposed convolution with 2x2 kernel. From Figure 13.10.1 of [Zha+20]. Used with kind
permission of Aston Zhang.
DeConvolution
* =
(s,p)
** =
Convolution Transposed Convolution
** =
(s,p)
Figure 14.25: Convolution, deconvolution and transposed convolution. Here s is the stride and p is the
padding. From https: // tinyurl. com/ ynxcxsut . Used with kind permission of Aqeel Anwar.
for j in range(Y.shape[1]):
Y[i, j] = (X[i:i + h, j:j + w] * K).sum()
return Y
In transposed convolution, we do the opposite, in order to produce a larger output from a smaller
input:
def trans_conv(X, K):
h, w = K.shape
Y = zeros((X.shape[0] + h - 1, X.shape[1] + w - 1))
for i in range(X.shape[0]):
for j in range(X.shape[1]):
Y[i:i + h, j:j + w] += X[i, j] * K
return Y
This is equivalent to padding the input image with (h − 1, w − 1) 0s (on the bottom right), where
(h, w) is the kernel size, then placing a weighted copy of the kernel on each one of the input locations,
where the weight is the corresponding pixel value, and then adding up. This process is illustrated in
Figure 14.24. We can think of the kernel as a “stencil” that is used to generate the output, modulated
by the weights in the input.
The term “transposed convolution” comes from the interpretation of convolution as matrix multi￾plication, which we discussed in Section 14.2.1.3. If W is the matrix derived from kernel K using
the process illustrated in Equation (14.9), then one can show that Y = transposed-conv(X, K) is
equivalent to Y = reshape(WTvec(X)). See code.probml.ai/book1/transposed_conv_torch for a
demo.
Note that transposed convolution is also sometimes called deconvolution, but this is an incorrect
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license482 Chapter 14. Neural Networks for Images
input (C)
output (D)
filters
2d convolution
per channel 
1x1 convolution 
maps from C to D dimensions 
Figure 14.26: Depthwise separable convolutions: each of the C input channels undergoes a 2d convolution to
produce C output channels, which get combined pointwise (via 1x1 convolution) to produce D output channels.
From https: // bit. ly/ 2L9fm2o . Used with kind permission of Eugenio Culurciello.
usage of the term: deconvolution is the process of “undoing” the effect of convolution with a known
filter, such as a blur filter, to recover the original input, as illustrated in Figure 14.25.
14.4.3 Depthwise separable convolution
Standard convolution uses a filter of size H × W × C × D, which requires a lot of data to learn and a
lot of time to compute with. A simplification, known as depthwise separable convolution, first
convolves each input channel by a corresponding 2d filter w, and then maps these C channels to D
channels using 1 × 1 convolution w0
:
zi,j,d = bd + w
0
c,d
C
X−1
c=0 H
X−1
u=0
W
X−1
v=0
xi+u,j+v,cwu,v!
(14.26)
See Figure 14.26 for an illustration.
To see the advantage of this, let us consider a simple numerical example.7 Regular convolution of a
12 × 12 × 3 input with a 5 × 5 × 3 × 256 filter gives a 8 × 8 × 256 output (assuming valid convolution:
12-5+1=8), as illustrated in Figure 14.13. With separable convolution, we start with 12 × 12 × 3
input, convolve with a 5 × 5 × 1 × 1 filter (across space but not channels) to get 8 × 8 × 3, then
pointwise convolve (across channels but not space) with a 1 × 1 × 3 × 256 filter to get a 8 × 8 × 256
output. So the output has the same size as before, but we used many fewer parameters to define the
layer, and used much less compute. For this reason, separable convolution is often used in lightweight
CNN models, such as the MobileNet model [How+17; San+18a] and other edge devices.
7. This example is from https://bit.ly/2Uj64Vo by Chi-Feng Wang.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.5. Solving other discriminative vision tasks with CNNs * 483
14.5 Solving other discriminative vision tasks with CNNs *
In this section, we briefly discuss how to tackle various other vision tasks using CNNs. Each task
also introduces a new architectural innovation to the library of basic building blocks we have already
seen. More details on CNNs for computer vision can be found in e.g., [Bro19].
14.5.1 Image tagging
Image classification associates a single label with the whole image, i.e., the outputs are assumed to
be mutually exclusive. In many problems, there may be multiple objects present, and we want to
label all of them. This is known as image tagging, and is an application of multi-label prediction.
In this case, we define the output space as Y = {0, 1}
C , where C is the number of tag types. Since
the output bits are independent (given the image), we should replace the final softmax with a set of
C logistic units.
Users of social media sites like Instagram often create hashtags for their images; this therefore
provides a “free” way of creating large supervised datasets. Of course, many tags may be quite
sparsely used, and their meaning may not be well-defined visually. (For example, someone may take
a photo of themselves after they get a COVID test and tag the image “#covid”; however, visually
it just looks like any other image of a person.) Thus this kind of user-generated labeling is usually
considered quite noisy. However, it can be useful for “pre-training”, as discussed in [Mah+18].
Finally, it is worth noting that image tagging is often a much more sensible objective than image
classification, since many images have multiple objects in them, and it can be hard to know which one
we should be labeling. Indeed, Andrej Karpathy, who created the “human performance benchmark”
on ImageNet, noted the following:8
Both [CNNs] and humans struggle with images that contain multiple ImageNet classes (usually
many more than five), with little indication of which object is the focus of the image. This error
is only present in the classification setting, since every image is constrained to have exactly one
correct label. In total, we attribute 16% of human errors to this category.
14.5.2 Object detection
In some cases, we want to produce a variable number of outputs, corresponding to a variable number
of objects of interest that may be present in the image. (This is an example of an open world
problem, with an unknown number of objects.)
A canonical example of this is object detection, in which we must return a set of bounding
boxes representing the locations of objects of interest, together with their class labels. A special
case of this is face detection, where there is only one class of interest. This is illustrated in
Figure 14.27a.
9
The simplest way to tackle such detection problems is to convert it into a closed world problem, in
which there is a finite number of possible locations (and orientations) any object can be in. These
candidate locations are known as anchor boxes. We can create boxes at multiple locations, scales
8. Source: https://bit.ly/3cFbALk
9. Note that face detection is different from face recognition, which is a classification task that tries to predict the
identity of a person from a set or “gallery” of possible people. Face recognition is usually solved by applying the
classifier to all the patches that are detected as containing faces.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license484 Chapter 14. Neural Networks for Images
(a) (b)
Figure 14.27: (a) Illustration of face detection, a special case of object detection. (Photo of author and his
wife Margaret, taken at Filoli in California in Feburary, 2018. Image processed by Jonathan Huang using
SSD face model.) (b) Illustration of anchor boxes. Adapted from [Zha+20, Sec 12.5].
and aspect ratios, as illustrated in Figure 14.27b. For each box, we train the system to predict what
category of object it contains (if any); we can also perform regression to predict the offset of the
object location from the center of the anchor. (These residual regression terms allow sub-grid spatial
localization.)
Abstractly, we are learning a function of the form
fθ : R
H×W×K → [0, 1]A×A × {1, . . . , C}
A×A × (R
4
)
A×A (14.27)
where K is the number of input channels, A is the number of anchor boxes in each dimension, and C
is the number of object types (class labels). For each box location (i, j), we predict three outputs:
an object presence probability, pij ∈ [0, 1], an object category, yij ∈ {1, . . . , C}, and two 2d offset
vectors, δij ∈ R
4
, which can be added to the centroid of the box to get the top left and bottom right
corners.
Several models of this type have been proposed, including the single shot detector model of
[Liu+16], and the YOLO (you only look once) model of [Red+16]. Many other methods for object
detection have been proposed over the years. These models make different tradeoffs between speed,
accuracy, simplicity, etc. See [Hua+17b] for an empirical comparison, and [Zha+18] for a more recent
review.
14.5.3 Instance segmentation
In object detection, we predict a label and bounding box for each object. In instance segmentation,
the goal is to predict the label and 2d shape mask of each object instance in the image, as illustrated
in Figure 14.28. This can be done by applying a semantic segmentation model to each detected box,
which has to label each pixel as foreground or background. (See Section 14.5.4 for more details on
semantic segmentation.)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.5. Solving other discriminative vision tasks with CNNs * 485
Figure 14.28: Illustration of object detection and instance segmentation using Mask R-CNN. From https:
// github. com/ matterport/ Mask_ RCNN . Used with kind permission of Waleed Abdulla.
Convolutional Encoder-Decoder
Pooling Indices
Input
Segmentation
Output
Conv + Batch Normalisation + ReLU
Pooling Upsampling Softmax
RGB Image
Figure 14.29: Illustration of an encoder-decoder (aka U-net) CNN for semantic segmentation. The encoder
uses convolution (which downsamples), and the decoder uses transposed convolution (which upsamples). From
Figure 1 of [BKC17]. Used with kind permission of Alex Kendall.
14.5.4 Semantic segmentation
In semantic segmentation, we have to predict a class label yi ∈ {1, . . . , C} for each pixel, where
the classes may represent things like sky, road, car, etc. In contrast to instance segmentation, which
we discussed in Section 14.5.3, all car pixels get the same label, so semantic segmentation does not
differentiate between objects. We can combine semantic segmentation of “stuff” (like sky, road) and
instance segmentation of “things” (like car, person) into a coherent framework called “panoptic
segmentation” [Kir+19].
A common way to tackle semantic segmentation is to use an encoder-decoder architecture, as
illustrated in Figure 14.29. The encoder uses standard convolution to map the input into a small 2d
bottleneck, which captures high level properties of the input at a coarse spatial resolution. (This
typically uses a technique called dilated convolution that we explain in Section 14.4.1, to capture a
large field of view, i.e., more context.) The decoder maps the small 2d bottleneck back to a full-sized
output image using a technique called transposed convolution that we explain in Section 14.4.2. Since
the bottleneck loses information, we can also add skip connections from input layers to output layers.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license486 Chapter 14. Neural Networks for Images
copy and crop
input
image
tile
output 
segmentation 
map
1 64
128
256
512
1024
max pool 2x2
up-conv 2x2
conv 3x3, ReLU
572 x 572
284² 64
128
256
512
570 x 570
568 x 568
282²
280² 140²
138²
136² 68²
66²
64² 32²
28²
56²
54²
52²
512
104²
102²
100² 200²
30²
198²
196² 392 x 392
390 x 390
388 x 388
388 x 388
1024
512 256
256 128
128 64 64 2
conv 1x1
Figure 14.30: Illustration of the U-Net model for semantic segmentation. Each blue box corresponds to a
multi-channel feature map. The number of channels is shown on the top of the box, and the height/width is
shown in the bottom left. White boxes denote copied feature maps. The different colored arrows correspond to
different operations. From Figure 1 from [RFB15]. Used with kind permission of Olaf Ronenberg.
Figure 14.31: Illustration of a multi-task dense prediction problem. From Based on Figure 1 of [EF15]. Used
with kind permission of Rob Fergus.
We can redraw this model as shown in Figure 14.30. Since the overall structure resembles the letter
U, this is also known as a U-net [RFB15].
A similar encoder-decoder architecture can be used for other dense prediction or image-to￾image tasks, such as depth prediction (predict the distance from the camera, zi ∈ R, for each
pixel i), surface normal prediction (predict the orientation of the surface, zi ∈ R
3
, at each image
patch), etc. We can of course train one model to solve all of these tasks simultaneously, using multiple
output heads, as illustrated in Figure 14.31. (See e.g., [Kok17] for details.)
14.5.5 Human pose estimation
We can train an object detector to detect people, and to predict their 2d shape, as represented by a
mask. However, we can also train the model to predict the location of a fixed set of skeletal keypoints,
e.g., the location of the head or hands. This is called human pose estimation. See Figure 14.32
for an example. There are several techniques for this, e.g., PersonLab [Pap+18] and OpenPose
[Cao+18]. See [Bab19] for a recent review.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.6. Generating images by inverting CNNs * 487
Figure 14.32: Illustration of keypoint detection for body, hands and face using the OpenPose system. From
Figure 8 of [Cao+18]. Used with kind permission of Yaser Sheikh.
We can also predict 3d properties of each detected object. The main limitation is the ability to
collect enough labeled training data, since it is difficult for human annotators to label things in 3d.
However, we can use computer graphics engines to create simulated images with infinite ground
truth 3d annotations (see e.g., [GNK18]).
14.6 Generating images by inverting CNNs *
A CNN trained for image classification is a discriminative model of the form p(y|x), which takes as
input an image, and returns as output a probability distribution over C class labels. In this section we
discuss how to “invert” this model, by converting it into a (conditional) generative image model
of the form p(x|y). This will allow us to generate images that belong to a specific class. (We discuss
more principled approaches to creating generative models for images in the sequel to this book,
[Mur22].)
14.6.1 Converting a trained classifier into a generative model
We can define a joint distribution over images and labels using p(x, y) = p(x)p(y|x), where p(y|x)
is the CNN classifier, and p(x) is some prior over images. If we then clamp the class label to a
specific value, we can create a conditional generative model using p(x|y) ∝ p(x)p(y|x). Note that the
discriminative classifier p(y|x) was trained to “throw away” information, so p(y|x) is not an invertible
function. Thus the prior term p(x) will play an important role in regularizing this process, as we see
in Section 14.6.2.
One way to sample from this model is to use the Metropolis Hastings algorithm (Section 4.6.8.4),
treating Ec(x) = log p(y = c|x) + log p(x) as the energy function. Since gradient information is
available, we can use a proposal of the form q(x
0
|x) = N (µ(x), I), where µ(x) = x +

2∇ log Ec(x).
This is called the Metropolis-adjusted Langevin algorithm (MALA). As an approximation, we
can ignore the rejection step, and accept every proposal. This is called the unadjusted Langevin
algorithm, and was used in [Ngu+17] for conditional image generation. In addition, we can scale
the gradient of the log prior and log likelihood independently. Thus we get an update over the space
of images that looks like a noisy version of SGD, except we take derivatives wrt the input pixels
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license488 Chapter 14. Neural Networks for Images
(using Equation (13.50)), instead of the parameters:
xt+1 = xt + 1
∂ log p(xt)
∂xt
+ 2
∂ log p(y = c|xt)
∂xt
+ N (0, 2
3
I) (14.28)
We can interpret each term in this equation as follows: the 1 term ensures the image is plausible
under the prior, the 2 term ensures the image is plausible under the likelihood, and the 3 term is a
noise term, in order to generate diverse samples. If we set 3 = 0, the method becomes a deterministic
algorithm to (approximately) generate the “most likely image” for this class.
14.6.2 Image priors
In this section, we discuss various kinds of image priors that we can use to regularize the ill-posed
problem of inverting a classifier. These priors, together with the image that we start the optimization
from, will determine the kinds of outputs that we generate.
14.6.2.1 Gaussian prior
Just specifying the class label is not enough information to specify the kind of images we want. We
also need a prior p(x) over what constitutes a “plausible” image. The prior can have a large effect on
the quality of the resulting image, as we show below.
Arguably the simplest prior is p(x) = N (x|0, I), as suggested in [SVZ14]. (This assumes the image
pixels have been centered.) This can prevent pixels from taking on extreme values. In this case, the
update due to the prior term has the form
∇x log p(xt) = ∇x

−
1
2
||xt − 0||2
2

= −xt (14.29)
Thus the overall update (assuming 2 = 1 and 3 = 0) has the form
xt+1 = (1 − 1)xt +
∂ log p(y = c|xt)
∂xt
(14.30)
See Figure 14.33 for some samples generated by this method.
14.6.2.2 Total variation (TV) prior
We can generate slightly more realistic looking images if we use additional regularizers. [MV15;
MV16] suggested computing the total variation or TV norm of the image. This is equal to the
integral of the per-pixel gradients, which can be approximated as follows:
TV(x) = X
ijk
(xijk − xi+1,j,k)
2 + (xijk − xi,j+1,k)
2
(14.31)
where xijk is the pixel value in row i, column j and channel k (for RGB images). We can rewrite
this in terms of the horizontal and vertical Sobel edge detector applied to each channel:
TV(x) = X
k
||H(x:,:,k)||2
F + ||V(x:,:,k)||2
F (14.32)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.6. Generating images by inverting CNNs * 489
Figure 14.33: Images that maximize the probability of ImageNet classes “goose” and “ostrich” under a simple
Gaussian prior. From http: // yosinski. com/ deepvis . Used with kind permission of Jeff Clune.
(a) (b) (c)
Figure 14.34: Illustration of total variation norm. (a) Input image: a green sea turtle (Used with kind
permission of Wikimedia author P. Lindgren). (b) Horizontal deltas. (c) Vertical deltas. Adapted from
https: // www. tensorflow. org/ tutorials/ generative/ style_ transfer .
See Figure 14.34 for an illustration of these edge detectors. Using p(x) ∝ exp(−TV(x)) discourages
images from having high frequency artefacts. In [Yos+15], they use Gaussian blur instead of TV
norm, but this has a similar effect.
In Figure 14.35 we show some results of optimizing log p(y = c, x) using a TV prior and a CNN
likelihood for different class labels c starting from random noise.
14.6.3 Visualizing the features learned by a CNN
It is interesting to ask what the “neurons” in a CNN are learning. One way to do this is to start with
a random image, and then to optimize the input pixels so as to maximize the average activation of a
particular neuron. This is called activation maximization (AM), and uses the same technique as
in Section 14.6.1 but fixes an internal node to a specific value, rather than clamping the output class
label.
Figure 14.36 illustrates the output of this method (with the TV prior) when applied to the AlexNet
CNN trained on Imagenet classification. We see that, as the depth increases, neurons are learning to
recognize simple edges/blobs, then texture patterns, then object parts, and finally whole objects.
This is believed to be roughly similar to the hierarchical structure of the visual cortex (see e.g.,
[Kan+12]).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license490 Chapter 14. Neural Networks for Images
Figure 14.35: Images that maximize the probability of certain ImageNet classes under a TV prior. From
https: // research. googleblog. com/ 2015/ 06/ inceptionism-going-deeper-into-neural. html . Used
with kind permission of Alexander Mordvintsev.
Figure 14.36: We visualize “optimal stimuli” for neurons in layers Conv 1, 3, 5 and fc8 in the AlexNet
architecture, trained on the ImageNet dataset. For Conv5, we also show retrieved real images (under the
column “data driven”) that produce similar activations. Based on the method in [MV16]. Used with kind
permission of Donglai Wei.
An alternative to optimizing in pixel space is to search the training set for images that maximally
activate a given neuron. This is illustrated in Figure 14.36 for the Conv5 layer.
For more information on feature visualization see e.g., [OMS17].
14.6.4 Deep Dream
So far we have focused on generating images which maximize the class label or some other neuron of
interest. In this section we tackle a more artistic application, in which we want to generate versions
of an input image that emphasize certain features.
To do this, we view our pre-trained image classifier as a feature extractor. Based on the results
in Section 14.6.3, we know the activity of neurons in different layers correspond to different kinds
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.6. Generating images by inverting CNNs * 491
(a) (b) (c)
Figure 14.37: Illustration of DeepDream. The CNN is an Inception classifier trained on ImageNet. (a)
Starting image of an Aurelia aurita (also called moon jelly). (b) Image generated after 10 iterations. (c)
Image generated after 50 iterations. From https: // en. wikipedia. org/ wiki/ DeepDream . Used with kind
permission of Wikipedia author Martin Thoma.
of features in the image. Suppose we are interested in “amplifying” features from layers l ∈ L.
We can do this be defining an energy or loss function of the form L(x) = P
l∈L φl
(x), where
φl =
1
HW C
P
hwc φlhwc(x) is the feature vector for layer l. We can now use gradient descent to
optimize this energy. The resulting process is called DeepDream [MOT15], since the model amplifies
features that were only hinted at in the original image and then creates images with more and more
of them.10
Figure 14.37 shows an example. We start with an image of a jellyfish, which we pass into a CNN
that was trained to classify ImageNet images. After several iterations, we generate some image which
is a hybrid of the input and the kinds of “hallucinations” we saw in Figure 14.33; these hallucinations
involve dog parts, since ImageNet has so many kinds of dogs in its label set. See [Tho16] for details,
and https://deepdreamgenerator.com for a fun web-based demo.
14.6.5 Neural style transfer
The DeepDream system in Figure 14.37 shows one way that CNNs can be used to create “art”.
However, it is rather creepy. In this section, we discuss a related approach that gives the user more
control. In particular, the user has to specify a reference “style image” xs and “content image” xc.
The system will then try to generate a new image x that “re-renders” xc in the style of xs. This is
called neural style transfer, and is illustrated in Figure 14.38 and Figure 14.39. This technique
was first proposed in [GEB16], and there are now many papers on this topic; see [Jin+17] for a recent
review.
14.6.5.1 How it works
Style transfer works by optimizing the following energy function:
L(x|xs, xc) = λT V LTV(x) + λcLcontent(x, xc) + λsLstyle(x, xs) (14.33)
See Figure 14.40 for a high level illustration.
10. The method was originally called Inceptionism, since it uses the inception CNN (Section 14.3.3).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license492 Chapter 14. Neural Networks for Images
(a) (b) (c)
Figure 14.38: Example output from a neural style transfer system. (a) Content image: a green sea turtle (Used
with kind permission of Wikimedia author P. Lindgren). (b) Style image: a painting by Wassily Kandinsky
called “Composition 7”. (c) Output of neural style generation. Adapted from https: // www. tensorflow.
org/ tutorials/ generative/ style_ transfer .
Figure 14.39: Neural style transfer applied to photos of the “production team”, who helped create code and
demos for this book and its sequel. From top to bottom, left to right: Kevin Murphy (the author), Mahmoud
Soliman, Aleyna Kara, Srikar Jilugu, Drishti Patel, Ming Liang Ang, Gerardo Durán-Martín, Coco (the
team dog). Each content photo used a different artistic style. Adapted from https: // www. tensorflow. org/
tutorials/ generative/ style_ transfer .
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.6. Generating images by inverting CNNs * 493
Conv Layer
Conv Layer
Conv Layer
Conv Layer
Conv Layer
Conv Layer
Conv Layer
Conv Layer
Conv Layer
Style loss
Content loss
Style loss
Content
Image
Composite
Image
Style
Image
Total Variation loss
Figure 14.40: Illustration of how neural style transfer works. Adapted from Figure 12.12.2 of [Zha+20].
Image 1
Image 2
Image 3
Feature 1
(green detector)
Feature 2
(spikiness detector)
Feature 3
(brown detector)
Figure 14.41: Schematic representation of 3 kinds of feature maps for 3 different input images. Adapted from
Figure 5.16 of [Fos19].
The first term in Equation (14.33) is the total variation prior discussed in Section 14.6.2.2. The
second term measures how similar x is to xc by comparing feature maps of a pre-trained CNN φ(x)
in the relevant “content layer” l:
Lcontent(x, xc) = 1
C`H`W`
||φ`
(x) − φ`
(xc)||2
2
(14.34)
Finally we have to define the style term. We can interpret visual style as the statistical distribution
of certain kinds of image features. The location of these features in the image may not matter, but
their co-occurence does. This is illustrated in Figure 14.41. It is clear (to a human) that image 1 is
more similar in style to image 2 than to image 3. Intuitively this is because both image 1 and image
2 have spiky green patches in them, whereas image 3 has spiky things that are not green.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license494 Chapter 14. Neural Networks for Images
To capture the co-occurence statistics we compute the Gram matrix for an image using feature
maps from a specific layer `:
G`(x)c,d =
1
H`W`
X
H`
h=1
X
W`
w=1
φ`
(x)h,w,c φ`
(x)h,w,d (14.35)
The Gram matrix is a C` × C` matrix which is proportional to the uncentered covariance of the
C`-dimensional feature vectors sampled over each of the H`W` locations.
Given this, we define the style loss for layer ` as follows:
L
`
style(x, xs) = ||G`(x) − G`(xs)||2
F (14.36)
Finally, we define the overall style loss as a sum over the losses for a set S of layers:
Lstyle(x, xs) = X
`∈S
L
`
style(x, xs) (14.37)
For example, in Figure 14.40, we compute the style loss at layers 1 and 3. (Lower layers will capture
visual texture, and higher layers will capture object layout.)
14.6.5.2 Speeding up the method
In [GEB16], they used L-BFGS (Section 8.3.2) to optimize Equation (14.33), starting from white
noise. We can get faster results if we use an optimizer such as Adam instead of BFGS, and initialize
from the content image instead of white noise. Nevertheless, running an optimizer for every new
style and content image is slow. Several papers (see e.g., [JAFF16; Uly+16; UVL16; LW16]) have
proposed to train a neural network to directly predict the outcome of this optimization, rather than
solving it for each new image pair. (This can be viewed as a form of amortized optimization.) In
particular, for every style image xs, we fit a model fs such that fs(xc) = argminx L(x|xs, xc). We
can then apply this model to new content images without having to reoptimize.
More recently, [DSK16] has shown how it is possible to train a single network that takes as
input both the content and a discrete representation s of the style, and then produces f(xc, s) =
argminx L(x|s, xc) as the output. This avoids the need to train a separate network for every style
image. The key idea is to standardize the features at a given layer using scale and shift parameters
that are style specific. In particular, we use the following conditional instance normalization
transformation:
CIN(φ(xc), s) = γs

φ(xc) − µ(φ(xc))
σ(φ(xc)) 
+ βs (14.38)
where µ(φ(xc)) is the mean of the features in a given layer, σ(φ(xc)) is the standard deviation,
and βs and γs are parameters for style type s. (See Section 14.2.4.2 for more details on instance
normalization.) Surprisingly, this simple trick is enough to capture many kinds of styles.
The drawback of the above technique is that it only works for a fixed number of discrete styles.
[HB17] proposed to generalize this by replacing the constants βs and γs by the output of another CNN,
which takes an arbitrary style image xs as input. That is, in Equation (14.38), we set βs = fβ(φ(xs))
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202214.6. Generating images by inverting CNNs * 495
and γs = fγ(φ(xs)), and we learn the parameters β and γ along with all the other parameters. The
model becomes
AIN(φ(xc), φ(xs)) = fγ(φ(xs)) 
φ(xc) − µ(φ(xc))
σ(φ(xc)) 
+ fβ(φ(xs)) (14.39)
They call their method adaptive instance normalization.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license15 Neural Networks for Sequences
15.1 Introduction
In this chapter, we discuss various kinds of neural networks for sequences. We will consider the
case where the input is a sequence, the output is a sequence, or both are sequences. Such models
have many applications, such as machine translation, speech recognition, text classification, image
captioning, etc. Our presentation borrows from parts of [Zha+20], which should be consulted for
more details.
15.2 Recurrent neural networks (RNNs)
A recurrent neural network or RNN is a neural network which maps from an input space of
sequences to an output space of sequences in a stateful way. That is, the prediction of output yt
depends not only on the input xt, but also on the hidden state of the system, ht, which gets updated
over time, as the sequence is processed. Such models can be used for sequence generation, sequence
classification, and sequence translation, as we explain below.1
15.2.1 Vec2Seq (sequence generation)
In this section, we discuss how to learn functions of the form fθ : R
D → R
N∞C , where D is the
size of the input vector, and the output is an arbitrary-length sequence of vectors, each of size C.
(Note that words are discrete tokens, but can be converted to real-valued vectors as we discuss in
Section 1.5.4.) We call these vec2seq models, since they map a vector to a sequence.
The output sequence y1:T is generated one token at a time. At each step we sample y˜t from the
hidden state ht of the model, and then “feed it back in” to the model to get the new state ht+1
(which also depends on the input x). See Figure 15.1 for an illustration. In this way the model
defines a conditional generative model of the form p(y1:T |x), which captures dependencies between
the output tokens. We explain this in more detail below.
1. For a more detailed introduction, see http://karpathy.github.io/2015/05/21/rnn-effectiveness/.498 Chapter 15. Neural Networks for Sequences
x
h1 h2 h3
y1 y2 y3
Figure 15.1: Recurrent neural network (RNN) for generating a variable length output sequence y1:T given an
optional fixed length input vector x.
15.2.1.1 Models
For notational simplicity, let T be the length of the output (with the understanding that this is
chosen dynamically). The RNN then corresponds to the following conditional generative model:
p(y1:T |x) = X
h1:T
p(y1:T , h1:T |x) = X
h1:T
Y
T
t=1
p(yt|ht)p(ht|ht−1, yt−1, x) (15.1)
where ht is the hidden state, and where we define p(h1|h0, y0, x) = p(h1|x) as the initial hidden
state distribution (often deterministic).
The output distribution is usually given by
p(yt|ht) = Cat(yt|S(Whyht + by)) (15.2)
where Why are the hidden-to-output weights, and by is the bias term. However, for real-valued
outputs, we can use
p(yt|ht) = N (yt|Whyht + by, σ2
I) (15.3)
We assume the hidden state is computed deterministically as follows:
p(ht|ht−1, yt−1, x) = I(ht = f(ht−1, yt−1, x)) (15.4)
for some deterministic function f. The update function f is usually given by
ht = ϕ(Wxh[x; yt−1] + Whhht−1 + bh) (15.5)
where Whh are the hidden-to-hidden weights, Wxh are the input-to-hidden weights, and bh are the
bias terms. See Figure 15.1 for an illustration, and code.probml.ai/book1/rnn_torch for some code.
Note that yt depends on ht, which depends on yt−1, which depends on ht−1, and so on. Thus yt
implicitly depends on all past observations (as well as the optional fixed input x). Thus an RNN
overcomes the limitations of standard Markov models, in that they can have unbounded memory.
This makes RNNs theoretically as powerful as a Turing machine [SS95; PMB19]. In practice,
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.2. Recurrent neural networks (RNNs) 499
the githa some thong the time traveller held in his hand was a glitteringmetallic framework scarcely larger than a
small clock and verydelicately made there was ivory in it and the latter than s bettyre tat howhong s ie time thave ler
simk you a dimensions le ghat dionthat shall travel indifferently in any direction of space and timeas the driver
determinesfilby contented himself with laughterbut i have experimental verification said the time travellerit would be
remarkably convenient for the histo
Figure 15.2: Example output of length 500 generated from a character level RNN when given the prefix “the”.
We use greedy decoding, in which the most likely character at each step is computed, and then fed back into
the model. The model is trained on the book The Time Machine by H. G. Wells. Generated by code at
figures.probml.ai/book1/15.2.
however, the memory length is determined by the size of the latent state and the strength of the
parameters; see Section 15.2.7 for further discussion of this point.
When we generate from an RNN, we sample from y˜t ∼ p(yt|ht), and then “feed in” the sampled
value into the hidden state, to deterministically compute ht+1 = f(ht, y˜t, x), from which we sample
y˜t+1 ∼ p(yt+1|ht+1), etc. Thus the only stochasticity in the system comes from the noise in the
observation (output) model, which is fed back to the system in each step. (However, there is a variant,
known as a variational RNN [Chu+15], that adds stochasticity to the dynamics of ht independent
of the observation noise.)
15.2.1.2 Applications
RNNs can be used to generate sequences unconditionally (by setting x = ∅) or conditionally on x.
Unconditional sequence generation is often called language modeling; this refers to learning joint
probability distributions over sequences of discrete tokens, i.e., models of the form p(y1, . . . , yT ). (See
also Section 3.6.1.2, where we discuss using Markov chains for language modeling.)
Figure 15.2 shows a sequence generated from a simple RNN trained on the book The Time Machine
by H. G. Wells. (This is a short science fiction book, with just 32,000 words and 170k characters.) We
see that the generated sequence looks plausible, even though it is not very meaningful. By using more
sophisticated RNN models (such as those that we discuss in Section 15.2.7.1 and Section 15.2.7.2),
and by training on more data, we can create RNNs that give state-of-the-art performance on the
language modeling task [CNB17]. (In the language modeling community, performance is usually
measured by perplexity, which is just the exponential of the average per-token negative log likelihood;
see Section 6.1.5 for more information.)
We can also make the generated sequence depend on some kind of input vector x. For example,
consider the task of image captioning: in this case, x is some embedding of the image computed
by a CNN, as illustrated in Figure 15.3. See e.g., [Hos+19; LXW19] for a review of image captioning
methods, and https://bit.ly/2Wvs1GK for a tutorial with code.
It is also possible to use RNNs to generate sequences of real-valued feature vectors, such as pen
strokes for hand-written characters [Gra13] and hand-drawn shapes [HE18]. This can also be useful
for time series forecasting real-value sequences.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license500 Chapter 15. Neural Networks for Sequences
Figure 15.3: Illustration of a CNN-RNN model for image captioning. The pink boxes labeled “LSTM” refer to
a specific kind of RNN that we discuss in Section 15.2.7.2. The pink boxes labeled Wemb refer to embedding
matrices for the (sampled) one-hot tokens, so that the input to the model is a real-valued vector. From
https: // bit. ly/ 2FKnqHm . Used with kind permission of Yunjey Choi.
x1 x2 x3
h1 h2 h3
y
(a)
x1 x2 x3
h→
1 h→
2 h→
3
h←
1 h←
2 h←
3
h1 h2 h3
y
(b)
Figure 15.4: (a) RNN for sequence classification. (b) Bi-directional RNN for sequence classification.
15.2.2 Seq2Vec (sequence classification)
In this section, we assume we have a single fixed-length output vector y we want to predict, given a
variable length sequence as input. Thus we want to learn a function of the form fθ : R
TD → R
C . We
call this a seq2vec model. We will focus on the case where the output is a class label, y ∈ {1, . . . , C},
for notational simplicity.
The simplest approach is to use the final state of the RNN as input to the classifier:
p(y|x1:T ) = Cat(y|S(WhT )) (15.6)
See Figure 15.4a for an illustration.
We can often get better results if we let the hidden states of the RNN depend on the past and
future context. To do this, we create two RNNs, one which recursively computes hidden states in the
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.2. Recurrent neural networks (RNNs) 501
x1 x2 x3
h1 h2 h3
y1 y2 y3
(a)
x1 x2 x3
h→
1 h→
2 h→
3
h←
1 h←
2 h←
3
y1 y2 y3
(b)
Figure 15.5: (a) RNN for transforming a sequence to another, aligned sequence. (b) Bi-directional RNN for
the same task.
forwards direction, and one which recursively computes hidden states in the backwards direction.
This is called a bidirectional RNN [SP97]. More precisely, the model is defined as follows:
h
→
t = ϕ(W→
xhxt + W→
hhh
→
t−1 + b
→
h
) (15.7)
h
←
t = ϕ(W←
xhxt + W←
hhh
←
t+1 + b
←
h
) (15.8)
We can then define ht = [h→
t
, h←
t
] to be the representation of the state at time t, taking into account
past and future information. Finally we average pool over these hidden states to get the final classifier:
p(y|x1:T ) = Cat(y|WS(h)) (15.9)
h =
1
T
X
T
t=1
ht (15.10)
See Figure 15.4b for an illustration, and code.probml.ai/book1/rnn_sentiment_torch for some code.
(This is similar to the 1d CNN text classifier1 in Section 15.3.1.)
15.2.3 Seq2Seq (sequence translation)
In this section, we consider learning functions of the form fθ : R
TD → R
T
0C . We consider two cases:
one in which T
0 = T, so the input and output sequences have the same length (and hence are aligned),
and one in which T
0 =6 T, so the input and output sequences have different lengths. This is called a
seq2seq problem.
15.2.3.1 Aligned case
In this section, we consider the case where the input and output sequences are aligned. We can also
think of it as dense sequence labeling, since we predict one label per location. It is straightforward
to modify an RNN to solve this task, as shown in Figure 15.5a. This corresponds to
p(y1:T |x1:T ) = X
h1:T
Y
T
t=1
p(yt|ht)I(ht = f(ht−1, xt)) (15.11)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license502 Chapter 15. Neural Networks for Sequences
0
H
X
1
1
1
0
H
H
X
2
2
2
2
0
H
H
X
3
3
3
3
0
H
X
T
T
T
(L) (L) (L)
H1
(1) (1) (1) (1)
H1
(2)
H2
(2)
H3
(2)
HT
(2)
HT
(L)
… … … …
…
…
…
…
Figure 15.6: Illustration of a deep RNN. Adapted from Figure 9.3.1 of [Zha+20].
x1 x2
h
e
1 h
e
2 c
y1 y2 y3
h
d
1 h
d
2 h
d
3
Figure 15.7: Encoder-decoder RNN architecture for mapping sequence x1:T to sequence y1:T 0 .
where we define h1 = f(h0, x1) = f0(x1) to be the initial state.
Note that yt depends on ht which only depends on the past inputs, x1:t. We can get better results
if we let the decoder look into the “future” of x as well as the past, by using a bidirectional RNN, as
shown in Figure 15.5b.
We can create more expressive models by stacking multiple hidden chains on top of each other, as
shown in Figure 15.6. The hidden units for layer l at time t are computed using
h
l
t = ϕl(Wl
xhh
l−1
t + Wl
hhh
l
t−1 + b
l
h
) (15.12)
The output is given by
ot = Whoh
L
t + bo (15.13)
15.2.3.2 Unaligned case
In this section, we discuss how to learn a mapping from one sequence of length T to another of length
T
0
. We first encode the input sequence to get the context vector c = fe(x1:T ), using the last state of
an RNN (or average pooling over a biRNN). We then generate the output sequence using an RNN
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.2. Recurrent neural networks (RNNs) 503
(a) (b)
Figure 15.8: (a) Illustration of a seq2seq model for translating English to French. The - character represents
the end of a sentence. From Figure 2.4 of [Luo16]. Used with kind permission of Minh-Thang Luong. (b)
Illustration of greedy decoding. The most likely French word at each step is highlighted in green, and then
fed in as input to the next step of the decoder. From Figure 2.5 of [Luo16]. Used with kind permission of
Minh-Thang Luong.
decoder y1:T0 = fd(c). This is called an encoder-decoder architecture [SVL14; Cho+14b]. See
Figure 15.7 for an illustration.
An important application of this is machine translation. When this is tackled using RNNs,
it is called neural machine translation (as opposed to the older approach called statistical
machine translation, that did not use neural networks). See Figure 15.8a for the basic idea, and
code.probml.ai/book1/nmt_torch for some code which has more details. For a review of the NMT
literature, see [Luo16; Neu17].
15.2.4 Teacher forcing
When training a language model, the likelihood of a sequence of words w1, w2, . . . , wT , is given by
p(w1:T ) = Y
T
t=1
p(wt|w1:t−1) (15.14)
In an RNN, we therefore set the input to xt = wt−1 and the output to yt = wt. Note that we
condition on the ground truth labels from the past, w1:t−1, not labels generated from the model.
This is called teacher forcing, since the teacher’s values are “force fed” into the model as input at
each step (i.e., xt is set to wt−1).
Unfortunately, teacher forcing can sometimes result in models that perform poorly at test time.
The reason is that the model has only ever been trained on inputs that are “correct”, so it may not
know what to do if, at test time, it encounters an input sequence w1:t−1 generated from the previous
step that deviates from what it saw in training.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license504 Chapter 15. Neural Networks for Sequences
x
x
x
3
2
1
h3
h
h
h
2
1
W , W 0 W
O
O
O
3
2
1
y
y
y
3
2
1
L
hx hh oh
Figure 15.9: An RNN unrolled (vertically) for 3 time steps, with the target output sequence and loss node
shown explicitly. From Figure 8.7.2 of [Zha+20]. Used with kind permission of Aston Zhang.
A common solution to this is known as scheduled sampling [Ben+15a]. This starts off using
teacher forcing, but at random time steps, feeds in samples from the model instead; the fraction of
time this happens is gradually increased.
An alternative solution is to use other kinds of models where MLE training works better, such as
1d CNNs (Section 15.3) and transformers (Section 15.5).
15.2.5 Backpropagation through time
We can compute the maximum likelihood estimate of the parameters for an RNN by solving
θ
∗ = argmaxθ p(y1:T |x1:T , θ), where we have assumed a single training sequence for notational
simplicity. To compute the MLE, we have to compute gradients of the loss wrt the parameters.
To do this, we can unroll the computation graph, as shown in Figure 15.9, and then apply the
backpropagation algorithm. This is called backpropagation through time (BPTT) [Wer90].
More precisely, consider the following model:
ht = Whxxt + Whhht−1 (15.15)
ot = Whoht (15.16)
where ot are the output logits, and where we drop the bias terms for notational simplicity. We
assume yy are the true target labels for each time step, so we define the loss to be
L =
1
T
X
T
t=1
`(yt, ot) (15.17)
We need to compute the derivatives ∂L
∂Whx
,
∂L
∂Whh
, and ∂L
∂Who
. The latter term is easy, since it is
local to each time step. However, the first two terms depend on the hidden state, and thus require
working backwards in time.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.2. Recurrent neural networks (RNNs) 505
We simplify the notation by defining
ht = f(xt, ht−1, wh) (15.18)
ot = g(ht, wo) (15.19)
where wh is the flattened version of Whh and Whx stacked together. We focus on computing ∂L
∂wh
.
By the chain rule, we have
∂L
∂wh
=
1
T
X
T
t=1
∂`(yt, ot)
∂wh
=
1
T
X
T
t=1
∂`(yt, ot)
∂ot
∂g(ht, wo)
∂ht
∂ht
∂wh
(15.20)
We can expand the last term as follows:
∂ht
∂wh
=
∂f(xt, ht−1, wh)
∂wh
+
∂f(xt, ht−1, wh)
∂ht−1
∂ht−1
∂wh
(15.21)
If we expand this recursively, we find the following result (see the derivation in [Zha+20, Sec 8.7]):
∂ht
∂wh
=
∂f(xt, ht−1, wh)
∂wh
+
Xt−1
i=1


Yt
j=i+1
∂f(xj , hj−1, wh)
∂hj−1


∂f(xi
, hi−1, wh)
∂wh
(15.22)
Unfortunately, this takes O(T) time to compute per time step, for a total of O(T
2
) overall. It is
therefore standard to truncate the sum to the most recent K terms. It is possible to adaptively pick
a suitable truncation parameter K [AFF19]; however, it is usually set equal to the length of the
subsequence in the current minibatch.
When using truncated BPTT, we can train the model with batches of short sequences, usually
created by extracting non-overlapping subsequences (windows) from the original sequence. If the
previous subsequence ends at time t − 1, and the current subsequence starts at time t, we can “carry
over” the hidden state of the RNN across batch updates during training. However, if the subsequences
are not ordered, we need to reset the hidden state. See code.probml.ai/book1/rnn_torch for some
sample code that illustrates these details.
15.2.6 Vanishing and exploding gradients
Unforunately, the activations in an RNN can decay or explode as we go forwards in time, since
we multiply by the weight matrix Whh at each time step. Similarly, the gradients in an RNN can
decay or explode as we go backwards in time, since we multiply the Jacobians at each time step (see
Section 13.4.2 for details). A simple heuristic is to use gradient clipping (Equation (13.70)). More
sophisticated methods attempt to control the spectral radius λ of the forward mapping, Whh, as
well as the backwards mapping, given by the Jacobian Jhh.
The simplest way to control the spectral radius is to randomly initialize Whh in such a way as
to ensure λ ≈ 1, and then keep it fixed (i.e., we do not learn Whh). In this case, only the output
matrix Who needs to be learned, resulting in a convex optimization problem. This is called an echo
state network [JH04]. A closely related approach, known as a liquid state machine [MNM02],
uses binary-valued (spiking) neurons instead of real-valued neurons. A generic term for both ESNs
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license506 Chapter 15. Neural Networks for Sequences
X +
1- X
tanh
X
FC layer with
Activation function Element-wise
Operator Copy Concatenate
Hidden state
H
Reset
gate
R
Update
gate
Z
t-1
t t
Candidate
Hidden state
~
Ht
Ht
Input Xt
Figure 15.10: Illustration of a GRU. Adapted from Figure 9.1.3 of [Zha+20].
and LSMs is reservoir computing [LJ09]. Another approach to this problem is use constrained
optimization to ensure the Whh matrix remains orthogonal [Vor+17].
An alternative to explicitly controlling the spectral radius is to modify the RNN architecture itself,
to use additive rather than multiplicative updates to the hidden states, as we discuss in Section 15.2.7.
This significantly improves training stability.
15.2.7 Gating and long term memory
RNNs with enough hidden units can in principle remember inputs from long in the past. However, in
practice “vanilla” RNNs fail to do this because of the vanishing gradient problem (Section 13.4.2). In
this section we give a solution to this in which we update the hidden state in an additive way, similar
to a residual net (Section 14.3.4).
15.2.7.1 Gated recurrent units (GRU)
In this section, we discuss models which use gated recurrent units (GRU), as proposed in
[Cho+14b]. The key idea is to learn when to update the hidden state, by using a gating unit. This
can be used to selectively “remember” important pieces of information when they are first seen. The
model can also learn when to reset the hidden state, and thus forget things that are no longer useful.
To explain the model in more detail, we present it in two steps, following the presentation of
[Zha+20, Sec 8.8]. We assume Xt is a N × D matrix, where N is the batch size, and D is the
vocabulary size. Similarly, Ht is a N × H matrix, where H is the number of hidden units at time t.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.2. Recurrent neural networks (RNNs) 507
The reset gate Rt ∈ R
N×H and update gate Zt ∈ R
N×H are computed using
Rt = σ(XtWxr + Ht−1Whr + br) (15.23)
Zt = σ(XtWxz + Ht−1Whz + bz) (15.24)
where the weight matrix Note that each element of Rt and Zt is in [0, 1], because of the sigmoid
function.
Given this, we we define a “candidate” next state vector using
H˜
t = tanh(XtWxh + (Rt  Ht−1)Whh + bh) (15.25)
This combines the old memories that are not reset (computed using Rt  Ht−1) with the new inputs
Xt. We pass the resulting linear combination through a tanh function to ensure the hidden units
remain in the interval (−1, 1). If the entries of the reset gate Rt are close to 1, we recover the
standard RNN update rule. If the entries are close to 0, the model acts more like an MLP applied to
Xt. Thus the reset gate can capture new, short-term information.
Once we have computed the candidate new state, the model computes the actual new state by
using the dimensions from the candidate state H˜
t chosen by the update gate, 1 − Zt, and keeping
the remaining dimensions at their old values of Ht−1:
Ht = Zt  Ht−1 + (1 − Zt)  H˜
t (15.26)
When Ztd = 1, we pass Ht−1,d through unchanged, and ignore Xt. Thus the update gate can capture
long-term dependencies.
See Figure 15.10 for an illustration of the overall architecture, and code.probml.ai/book1/gru_torch
for some sample code.
15.2.7.2 Long short term memory (LSTM)
In this section, we discuss the long short term memory (LSTM) model of [HS97b], which is a
more sophisticated version of the GRU (and pre-dates it by almost 20 years). For a more detailed
introduction, see https://colah.github.io/posts/2015-08-Understanding-LSTMs.
The basic idea is to augment the hidden state ht with a memory cell ct. We need three gates to
control this cell: the output gate Ot determines what gets read out; the input gate It determines
what gets read in; and the forget gate Ft determines when we should reset the cell. These gates
are computed as follows:
Ot = σ(XtWxo + Ht−1Who + bo) (15.27)
It = σ(XtWxi + Ht−1Whi + bi) (15.28)
Ft = σ(XtWxf + Ht−1Whf + bf ) (15.29)
We then compute a candidate cell state:
C˜
t = tanh(XtWxc + Ht−1Whc + bc) (15.30)
The actual update to the cell is either the candidate cell (if the input gate is on) or the old cell (if
the not-forget gate is on):
Ct = Ft  Ct−1 + It  C˜
t (15.31)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license508 Chapter 15. Neural Networks for Sequences
t
X
C
FC layer with
Activation function Element-wise
Operator Copy Concatenate
Memory
C t-1
H t
C t
tanh
tanh
X
X +
Hidden state
Ht-1
Input Xt
Forget 
Gate
F
Input
Gate
l
Candidate
Memory
~
Output
Gate
O
Ct
t t t
Figure 15.11: Illustration of an LSTM. Adapted from Figure 9.2.4 of [Zha+20].
If Ft = 1 and It = 0, this can remember long term memories.2
Finally, we compute the hidden state to be a transformed version of the cell, provided the output
gate is on:
Ht = Ot  tanh(Ct) (15.32)
Note that Ht is used as the output of the unit as well as the hidden state for the next time step.
This lets the model remember what it has just output (short-term memory), whereas the cell
Ct acts as a long-term memory. See Figure 15.11 for an illustration of the overall model, and
code.probml.ai/book1/lstm_torch for some sample code.
Sometimes we add peephole connections, where we pass the cell state as an additional input
to the gates. Many other variants have been proposed. In fact, [JZS15] used genetic algorithms to
test over 10,000 different architectures. Some of these worked better than LSTMs or GRUs, but in
general, LSTMs seemed to do consistently well across most tasks. Similar conclusions were reached
in [Gre+17]. More recently, [ZL17] used an RNN controller to generate strings which specify RNN
architectures, and then trained the controller using reinforcement learning. This resulted in a novel
cell structure that outperformed LSTM. However, it is rather complex and has not been adopted by
the community.
2. One important detail pointed out in [JZS15] is that we need to initialize the bias term for the forget gate bf to
be large, so the sigmoid is close to 1. This ensures that information can easily pass through the C chain over time.
Without this trick, performance is often much worse.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.2. Recurrent neural networks (RNNs) 509
(a) (b)
Figure 15.12: Conditional probabilities of generating each token at each step for two different sequences. From
Figures 9.8.1–9.8.2 of [Zha+20]. Used with kind permission of Aston Zhang.
15.2.8 Beam search
The simplest way to generate from an RNN is to use greedy decoding, in which we compute
yˆt = argmaxy p(yt = y|yˆ1:t, x) at each step. We can repeat this process until we generate the
end-of-sentence token. See Figure 15.8b for an illustration of this method applied to NMT.
Unfortunately greedy decoding will not generate the MAP sequence, which is defined by y
∗
1:T =
argmaxy1:T
p(y1:T |x). The reason is that the locally optimal symbol at step t might not be on the
globally optimal path.
As an example, consider Figure 15.12a. We greedily pick the MAP symbol at step 1, which is A.
Conditional on this, suppose we have p(y2|y1 = A) = [0.1, 0.4, 0.3, 0.3], as shown. We greedily pick
the MAP symbol from this, which is B. Conditional on this, suppose we have p(y3|y1 = A, y2 = B) =
[0.2, 0.2, 0.4, 0.2], as shown. We greedily pick the MAP symbol from this, which is C. Conditional
on this, suppose we have p(y4|y1 = A, y2 = B, y3 = C) = [0.0, 0.2, 0.2, 0.6], as shown. We greedily
pick the MAP symbol from this, which is eos (end of sentence), so we stop generating. The overall
probability of the generated sequence is 0.5 × 0.4 × 0.4 × 0.6 = 0.048.
Now consider Figure 15.12b. At step 2, suppose we pick the second most probable token, namely
C. Conditional on this, suppose we have p(y3|y1 = A, y2 = C) = [0.1, 0.6, 0.2, 0.1], as shown.
We greedily pick the MAP symbol from this, which is B. Conditional on this, suppose we have
p(y4|y1 = A, y2 = C, y3 = B) = [0.0, 0.2, 0.2, 0.6], as shown. We greedily pick the MAP symbol from
this, which is eos (end of sentence), so we stop generating. The overall probability of the generated
sequence is 0.5 × 0.3 × 0.6 × 0.6 = 0.054. So by being less greedy, we found a sequence with overall
higher likelihood.
For hidden Markov models, we can use an algorithm called Viterbi decoding (which is an example
of dynamic programming) to compute the globally optimal sequence in O(T V 2
) time, where V is
the number of words in the vocabulary. (See [Mur22] for details.) But for RNNs, computing the
global optimum takes O(V
T
), since the hidden state is not a sufficient statistic for the data.
Beam search is a much faster heuristic method. In this approach, we compute the top K
candidate outputs at each step; we then expand each one in all V possible ways, to generate V K
candidates, from which we pick the top K again. This process is illustrated in Figure 15.13.
It is also possible to extend the algorithm to sample the top K sequences without replacement
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license510 Chapter 15. Neural Networks for Sequences
A
B
C
D
E
A
B
C
D
E
A
B
C
D
E
A
B
C
D
E
A
B
C
D
E
A
C
AB
CE
[]
A
C
B
E
D
D
ABD
CED
Time Step 1
Candidates
Time Step 2
Candidates
Time Step 3
Candidates Figure 15.13: Illustration of beam search using a beam of size K = 2. The vocabulary is Y = {A, B, C, D, E},
with size V = 5. We assume the top 2 symbols at step 1 are A,C. At step 2, we evaluate p(y1 = A, y2 = y)
and p(y1 = C, y2 = y) for each y ∈ Y. This takes O(KV ) time. We then pick the top 2 partial paths, which
are (y1 = A, y2 = B) and (y1 = C, y2 = E), and continue in the obvious way. Adapted from Figure 9.8.3 of
[Zha+20].
(i.e., pick the top one, renormalize, pick the new top one, etc.), using a method called stochastic
beam search. This perturbs the model’s partial probabilities at each step with Gumbel noise. See
[KHW19] for details. and [SBS20] for a sequential alternative. These sampling methods can improve
diversity of the outputs. (See also the deterministic diverse beam search method of [Vij+18].)
15.3 1d CNNs
Convolutional neural networks (Chapter 14) compute a function of some local neighborhood for each
input using tied weights, and return an output. They are usually used for 2d inputs, but can also be
applied in the 1d case, as we discuss below. They are an interesting alternative to RNNs that are
much easier to train, because they don’t have to maintain long term hidden state.
15.3.1 1d CNNs for sequence classification
In this section, we discuss the use of 1d CNNs for learning a mapping from variable-length sequences
to a fixed length output, i.e., a function of the form fθ : R
DT → R
C , where T is the length of the
input, D is the number of features per input, and C is the size of the output vector (e.g., class logits).
A basic 1d convolution operation applied to a 1d sequence is shown in Figure 14.4. Typically the
input sequence will have D > 1 input channels (feature dimensions). In this case, we can convolve
each channel separately and add up the result, using a different 1d filter (kernel) for each input
channel to get zi =
P
d x
T
i−k:i+k,dwd, where k is size of the 1d receptive field, and wd is the filter for
input channel d. This produces a 1d vector z ∈ R
T
encoding the input (ignoring boundary effects).
We can create a vector representation for each location using a different weight vector for each output
channel c to get zic =
P
d x
T
i−k:i+k,dwd,c. This implements a mapping from T D to T C. To reduce
this to a fixed sized vector, z ∈ R
C , we can use max-pooling over time to get zc = maxi zic. We can
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.3. 1d CNNs 511
#output sentiment polarities: 2
(with fully-connected layer)
#outputs: 5
(Max pooling over time
For each channel)
#channels: 5
Width: 11 – 4 + 1 = 8
(kernel width: 4)
Width: 11 words
#channels: 6
(each word is represented by a 6D vector)
#outputs: 4
(Max pooling over time
for each channel)
#channels: 4
Width: 11 – 2 + 1 = 10
(kernel width: 2)
This
was
a
great
movie
until
the
part
where
Figure 15.14: Illustration of the TextCNN model for binary sentiment classification. Adapted from Figure
15.3.5 of [Zha+20].
then pass this into a softmax layer.
In [Kim14], they applied this model to sequence classification. The idea is to embed each word
using an embedding layer, and then to compute various features using 1d kernels of different
widths, to capture patterns of different length scales. We then apply max pooling over time, and
concatenate the results, and pass to a fully connected layer. See Figure 15.14 for an illustration, and
code.probml.ai/book1/cnn1d_sentiment_torch for some code.
15.3.2 Causal 1d CNNs for sequence generation
To use 1d CNNs in a generative setting, we must convert them to a causal CNN, in which each
output variable only depends on previously generated variables. (This is also called a convolutional
Markov model.) In particular, we define the model as follows:
p(y) = Y
T
t=1
p(yt|y1:t−1) = Y
T
t=1
Cat(yt|S(ϕ(
Xt−k
τ=1
wTyτ:τ+k))) (15.33)
where w is the convolutional filter of size k, and we have assumed a single nonlinearity ϕ and
categorical output, for notational simplicity. This is like regular 1d convolution except we “mask out”
future inputs, so that yt only depends on the past values, rather than past and future values. This is
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license512 Chapter 15. Neural Networks for Sequences
Because models with causal convolutions do not have recurrent connections, they are typically faster
to train than RNNs, especially when applied to very long sequences. One of the problems of causal
convolutions is that they require many layers, or large filters to increase the receptive field. For
example, in Fig. 2 the receptive field is only 5 (= #layers + filter length - 1). In this paper we use
dilated convolutions to increase the receptive field by orders of magnitude, without greatly increasing
computational cost.
A dilated convolution (also called a trous ` , or convolution with holes) is a convolution where the
filter is applied over an area larger than its length by skipping input values with a certain step. It is
equivalent to a convolution with a larger filter derived from the original filter by dilating it with zeros,
but is significantly more efficient. A dilated convolution effectively allows the network to operate on
a coarser scale than with a normal convolution. This is similar to pooling or strided convolutions, but
here the output has the same size as the input. As a special case, dilated convolution with dilation
1 yields the standard convolution. Fig. 3 depicts dilated causal convolutions for dilations 1, 2, 4,
and 8. Dilated convolutions have previously been used in various contexts, e.g. signal processing
(Holschneider et al., 1989; Dutilleux, 1989), and image segmentation (Chen et al., 2015; Yu &
Koltun, 2016).
Input
Hidden Layer
Dilation = 1
Hidden Layer
Dilation = 2
Hidden Layer
Dilation = 4
Output
Dilation = 8
Figure 3: Visualization of a stack of dilated causal convolutional layers.
Stacked dilated convolutions enable networks to have very large receptive fields with just a few lay￾ers, while preserving the input resolution throughout the network as well as computational efficiency.
In this paper, the dilation is doubled for every layer up to a limit and then repeated: e.g.
1, 2, 4,..., 512, 1, 2, 4,..., 512, 1, 2, 4,..., 512.
The intuition behind this configuration is two-fold. First, exponentially increasing the dilation factor
results in exponential receptive field growth with depth (Yu & Koltun, 2016). For example each
1, 2, 4,..., 512 block has receptive field of size 1024, and can be seen as a more efficient and dis￾criminative (non-linear) counterpart of a 1⇥1024 convolution. Second, stacking these blocks further
increases the model capacity and the receptive field size.
2.2 SOFTMAX DISTRIBUTIONS
One approach to modeling the conditional distributions p (xt | x1,...,xt￾1) over the individual
audio samples would be to use a mixture model such as a mixture density network (Bishop, 1994)
or mixture of conditional Gaussian scale mixtures (MCGSM) (Theis & Bethge, 2015). However,
van den Oord et al. (2016a) showed that a softmax distribution tends to work better, even when the
data is implicitly continuous (as is the case for image pixel intensities or audio sample values). One
of the reasons is that a categorical distribution is more flexible and can more easily model arbitrary
distributions because it makes no assumptions about their shape.
Because raw audio is typically stored as a sequence of 16-bit integer values (one per timestep), a
softmax layer would need to output 65,536 probabilities per timestep to model all possible values.
To make this more tractable, we first apply a µ-law companding transformation (ITU-T, 1988) to
the data, and then quantize it to 256 possible values:
f (xt) = sign(xt)
ln (1 + µ |xt|)
ln (1 + µ) ,
3
Figure 15.15: Illustration of the wavenet model using dilated (atrous) convolutions, with dilation factors of 1,
2, 4 and 8. From Figure 3 of [oor+16]. Used with kind permission of Aaron van den Oord.
called causal convolution. We can of course use deeper models, and we can condition on input
features x.
In order to capture long-range dependencies, we can use dilated convolution (Section 14.4.1), as
illustrated in Figure 15.15. This model has been successfully used to create a state of the art text
to speech (TTS) synthesis system known as wavenet [oor+16]. In particular, they stack 10 causal
1d convolutional layers with dilation rates 1, 2, 4, . . . , 256, 512 to get a convolutional block with an
effective receptive field of 1024. (They left-padded the input sequences with a number of zeros equal
to the dilation rate before every layer, so that every layer has the same length.) They then repeat
this block 3 times to compute deeper features.
In wavenet, the conditioning information x is a set of linguistic features derived from an input
sequence of words; the model then generates raw audio using the above model. It is also possible to
create a fully end-to-end approach, which starts with raw words rather than linguistic features (see
[Wan+17]).
Although wavenet produces high quality speech, it is too slow for use in production systems.
However, it can be “distilled” into a parallel generative model [Oor+18]. We discuss these kinds of
parallel generative models in the sequel to this book, [Mur22].
15.4 Attention
In all of the neural networks we have considered so far, the hidden activations are a linear combination
of the input activations, followed by a nonlinearity: z = ϕ(Wv), where v ∈ R
v are the hidden feature
vectors, and W ∈ R
v
0×v are a fixed set of weights that are learned on a training set.
However, we can imagine a more flexible model in which we have a set of m feature vectors or
values V ∈ R
m×v
, and the model dynamically decides (in an input dependenent way) which one to
use, based on how similar the input query vector q ∈ R
q
is to a set of m keys K ∈ R
m×k
. If q is
most similar to key i, then we use value vi
. This is the basic idea behind attention mechanisms.
This idea was originally developed for sequence models, and we will therefore explain it in this
context. However, it can be more generally applied. Our presentation in the following sections is
based on [Zha+20, Chap 10.].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.4. Attention 513
Figure 15.16: Attention computes a weighted average of a set of values, where the weights are derived by
comparing the query vector to a set of keys. From Figure 10.3.1 of [Zha+20]. Used with kind permission of
Aston Zhang.
15.4.1 Attention as soft dictionary lookup
We can think of attention as a dictionary lookup, in which we compare the query q to each key ki
,
and then retrieve the corresponding value vi
. To make this lookup operation differentiable, instead
of retrieving a single value vi
, we compute a convex combination of the values, as follows:
Attn(q,(k1, v1), . . . ,(km, vm)) = Attn(q,(k1:m, v1:m)) = Xm
i=1
αi(q, k1:m)vi ∈ R
v
(15.34)
where αi(q, k1:m) is the i’th attention weight; these weights satisfy 0 ≤ αi(q, k1:m) ≤ 1 for each i
and P
i αi(q, k1:m) = 1.
The attention weights can be computed from an attention score function a(q, ki) ∈ R, that
computes the similarity of query q to key ki
. We will discuss several such score function below.
Given the scores, we can compute the attention weights using the softmax function:
αi(q, k1:m) = Si([a(q, k1), . . . , a(q, km)]) = exp(a(q, ki))
Pm
j=1 exp(a(q, kj )) (15.35)
See Figure 15.16 for an illustration.
In some cases, we want to restrict attention to a subset of the dictionary, corresponding to valid
entries. For example, we might want to pad sequences to a fixed length (for efficient minibatching),
in which case we should “mask out” the padded locations. This is called masked attention. We
can implement this efficiently by setting the attention score for the masked entries to a large negative
number, such as −106
, so that the corresponding softmax weights will be 0. (This is analogous to
causal convolution, discussed in Section 15.3.2.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license514 Chapter 15. Neural Networks for Sequences
15.4.2 Kernel regression as non-parametric attention
In Section 16.3.5, we discuss kernel regression, which is a nonparametric model of the form
f(x) = Xn
i=1
αi(x, x1:n)yi (15.36)
where αi(x, x1:n) ≥ 0 measures the normalized similarity of test input x to training input xi
. This
similarity measure is usually computed by defining the attention score in terms of a density kernel,
such as the Gaussian:
Kσ(u) = 1
√
2πσ2
e
− 1
2σ2 u
2
(15.37)
where σ is called the bandwidth. We then define a(x, xi) = Kσ(x − xi).
Because the scores are normalized, we can drop the √
1
2πσ2
term. In addition, to maintain notation
consistency with [Zha+20, Ch. 10], we rewrite the term inside the exponential as follows:
K(x; w) = exp(−
w
2
2
u
2
) (15.38)
Plugging this in to Equation (15.36), we get
f(x) = Xn
i=1
αi(x, x1:n)yi (15.39)
=
Xn
i=1
exp[−
1
2
((x − xi)w)
2
]
Pn
j=1 exp[−
1
2
((x − xj )w)
2]
yi (15.40)
=
Xn
i=1
Si

−
1
2
((x − x1)w)
2
, · · · , −
1
2
((x − xn)w)
2

yi (15.41)
We can interpret this as a form of nonparametric attention, where the queries are the test points
x, the keys are the training inputs xi
, and the values are the training labels yi
.
If we set w = 1, the resulting attention matrix Aji = αi(xj , x1:n) for test input j is shown in
Figure 15.17a. The resulting predicted curve is shown in Figure 15.17b.
The size of the diagonal band in Figure 15.17a, and hence the sparsity of the attention mechanism,
dependends on the parameter w. If we increase w, corresponding to reducing the kernel bandwidth,
the band will get narrower, but the model will start to overfit.
15.4.3 Parametric attention
In Section 15.4.2, we defined the attention score in terms of the Gaussian kernel, comparing a scalar
query (test point) to each of the scalar values in the training set. This does not scale well to large
training sets, or high-dimensional inputs. We will therefore turn our attention to parametric models,
where we have a fixed set of keys and values, and where we compare queries and keys in a learned
embedding space.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.4. Attention 515
0 20 40
Sorted training inputs
0
10
20
30
40
Sorted testing inputs
0.025
0.050
0.075
(a)
0 1 2 3 4 5
x
1
0
1
2
3
4
5
y
Truth
Pred
(b)
Figure 15.17: Kernel regression in 1d. (a) Kernel weight matrix. (b) Resulting predictions on a dense grid of
test points. Generated by code at figures.probml.ai/book1/15.17.
There are several ways to do this. In the general case, the query q ∈ R
q and the key k ∈ R
k may
have different sizes. To compare them, we can map them to a common embedding space of size h by
computing Wqq and Wkk. where Wq ∈ R
h×q and Wk ∈ R
h×k
. We can then pass these into an
MLP to get the following additive attention scoring function:
a(q, k) = wT
v
tanh(Wqq + Wkk) ∈ R (15.42)
A more computationally efficient approach is to assume the queries and keys both have length
d, so we can compute q
Tk directly. If we assume these are independent random variables with 0
mean and unit variance, the mean of their inner product is 0, and the variance is d. (This follows
from Equation (2.34) and Equation (2.39).) To ensure the variance of the inner product remains
1 regardless of the size of the inputs, it is standard to divide by √
d. This gives rise to the scaled
dot-product attention:
a(q, k) = q
Tk/
√
d ∈ R (15.43)
In practice, we usually deal with minibatches of n vectors at a time. Let the corresponding matrices
of queries, keys and values be denoted by Q ∈ R
n×d
, K ∈ R
m×d
, V ∈ R
m×v
. Then we can compute
the attention-weighted outputs as follows:
Attn(Q, K, V) = S(
QKT
√
d
)V ∈ R
n×v
(15.44)
where the softmax function S is applied row-wise. See code.probml.ai/book1/attention_torch for
some sample code.
15.4.4 Seq2Seq with attention
Recall the seq2seq model from Section 15.2.3. This uses an RNN decoder of the form h
d
t =
fd(h
d
t−1
, yt−1, c), where c is a fixed-length context vector, representing the encoding of the input
x1:T . Usually we set c = h
e
T
, which is the final state of the encoder RNN (or we use a bidirectional
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license516 Chapter 15. Neural Networks for Sequences
Figure 15.18: Illustration of seq2seq with attention for English to French translation. Used with kind permission
of Minh-Thang Luong.
(a) (b)
Figure 15.19: Illustration of the attention heatmaps generated while translating two sentences from Spanish to
English. (a) Input is “hace mucho frio aqui.”, output is “it is very cold here.”. (b) Input is “¿todavia estan en
casa?”, output is “are you still at home?”. Note that when generating the output token “home”, the model
should attend to the input token “casa”, but in fact it seems to attend to the input token “?”. Adapted from
https: // www. tensorflow. org/ tutorials/ text/ nmt_ with_ attention .
RNN with average pooling). However, for tasks such as machine translation, this can result in poor
performance, since the output does not have access to the input words themselves. We can avoid
this bottleneck by allowing the output words to directly “look at” the input words. But which inputs
should it look at? After all, word order is not always preserved across languages (e.g., German often
puts verbs at the end of a sentence), so we need to infer the alignment between source and target.
We can solve this problem (in a differentiable way) by using (soft) attention, as first proposed
in [BCB15; LPM15]. In particular, we can replace the fixed context vector c in the decoder with a
dynamic context vector ct computed as follows:
ct =
X
T
i=1
αi(h
d
t−1
, h
e
1:T
)h
e
i
(15.45)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.4. Attention 517
Figure 15.20: Example of an electronic health record. In this example, 24h after admission to the hospital, the
RNN classifier predicts the risk of death as 19.9%; the patient ultimately died 10 days after admission. The
“relevant” keywords from the input clinical notes are shown in red, as identified by an attention mechanism.
From Figure 3 of [Raj+18]. Used with kind permission of Alvin Rakomar.
This uses attention where the query is the hidden state of the decoder at the previous step, h
d
t−1
,
the keys are all the hidden states from the encoder, and the values are also the hidden states from
the encoder. (When the RNN has multiple hidden layers, we usually take the top layer from the
encoder, as the keys and values, and the top layer of the decoder as the query.) This context vector
is concatenated with the input vector of the decoder, yt−1, and fed into the decoder, along with the
previous hidden state h
d
t−1
, to create h
d
t
. See Figure 15.18 for an illustration of the overall model.
We can train this model in the usual way on sentence pairs, and then use it to perform machine
translation. (See code.probml.ai/book1/nmt_attention_torch for some sample code.) We can also
visualize the attention weights computed at each step of decoding, to get an idea of which parts
of the input the model thinks are most relevant for generating the corresponding output. Some
examples are shown in Figure 15.19.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license518 Chapter 15. Neural Networks for Sequences
Figure 15.21: Illustration of sentence pair entailment classification using an MLP with attention to align
the premise (“I do need sleep”) with the hypothesis (“I am tired”). White squares denote active attention
weights, blue squares are inactive. (We are assuming hard 0/1 attention for simplicity.) From Figure 15.5.2
of [Zha+20]. Used with kind permission of Aston Zhang.
15.4.5 Seq2vec with attention (text classification)
We can also use attention with sequence classifiers. For example [Raj+18] apply an RNN classifier
to the problem of predicting if a patient will die or not. The input is a set of electronic health
records, which is a time series containing structured data, as well as unstructured text (clinical
notes). Attention is useful for identifying “relevant” parts of the input, as illustrated in Figure 15.20.
15.4.6 Seq+Seq2Vec with attention (text pair classification)
Suppose we see the sentence “A person on a horse jumps over a log” (call this the premise) and
then we later read “A person is outdoors on a horse” (call this the hypothesis). We may reasonably
say that the premise entails the hypothesis, meaning that the hypothesis is more likely given the
premise.3 Now suppose the hypothesis is “A person is at a diner ordering an omelette”. In this case,
we would say that the premise contradicts the hypothesis, since the hypothesis is less likely given
the premise. Finally, suppose the hypothesis is “A person is training his horse for a competition”.
In this case, we see that the relationship between premise and hypothesis is neutral, since the
hypothesis may or may not follow from the premise. The task of classifying a sentence pair into these
three categories is known as textual entailment or “natural language inference”. A standard
benchmark in this area is the Stanford Natural Language Inference or SNLI corpus [Bow+15].
This consists of 550,000 labeled sentence pairs.
An interesting solution to this classification problem was presented in [Par+16a]; at the time, it
was the state of the art on the SNLI dataset. The overall approach is sketched in Figure 15.21. Let
A = (a1, . . . , am) be the premise and B = (b1, . . . , bn) be the hypothesis, where ai
, bj ∈ R
E are
3. Note that the premise does not logically imply the hypothesis, since the person could be horse-back riding indoors,
but generally people ride horses outdoors. Also, we are assuming the phrase “a person” refers to the same person in
the two sentences.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.4. Attention 519
embedding vectors for the words. The model has 3 steps. First, each word in the premise, ai
, attends
to each word in the hypothesis, bj , to compute an attention weight
eij = f(ai)
T
f(bj ) (15.46)
where f : R
E → R
D is an MLP; we then compute a weighted average of the matching words in the
hypothesis,
βi =
Xn
j=1
exp(eij )
Pn
k=1 exp(eik)
bj (15.47)
Next, we compare ai with βi by mapping their concatenation to a hidden space using an MLP
g : R
2E → R
H:
vA,i = g([ai
, βi
]), i = 1, . . . , m (15.48)
Finally, we aggregate over the comparisons to get an overall similarity of premise to hypothesis:
vA =
Xm
i=1
vA,i (15.49)
We can similarly compare the hypothesis to the premise using
αj =
Xm
i=1
exp(eij )
Pm
k=1 exp(ekj )
ai (15.50)
vB,j = g([bj , αj ]), j = 1, . . . , n (15.51)
vB =
Xn
j=1
vB,j (15.52)
At the end, we classify the output using another MLP h : R
2H → R
3
:
yˆ = h([vA, vB]) (15.53)
See code.probml.ai/book1/entailment_attention_mlp_torch for some sample code.
We can modify this model to learn other kinds of mappings from sentence pairs to output labels.
For example, in the semantic textual similarity task, the goal is to predict how semantically
related two input sentences are. A standard dataset for this is the STS Benchmark [Cer+17],
where relatedness ranges from 0 (meaning unrelated) to 5 (meaning maximally related).
15.4.7 Soft vs hard attention
If we force the attention heatmap to be sparse, so that each output can only attend to one input
location instead of a weighted combination of all of them, the method is called hard attention. We
compare these two approaches for an image captioning problem in Figure 15.22. Unfortunately, hard
attention results in a nondifferentiable training objective, and requires methods such as reinforcement
learning to fit the model. See [Xu+15] for the details.
It seems from the above examples that these attention heatmaps can “explain” why the model
generates a given output. However, the interpretability of attention is controversial (see e.g., [JW19;
WP19; SS19; Bru+19] for discussion).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license520 Chapter 15. Neural Networks for Sequences
(a) (b)
Figure 15.22: Image captioning using attention. (a) Soft attention. Generates “a woman is throwing a frisbee
in a park”. (b) Hard attention. Generates “a man and a woman playing frisbee in a field”. From Figure 6 of
[Xu+15]. Used with kind permission of Kelvin Xu.
15.5 Transformers
The transformer model [Vas+17] is a seq2seq model which uses attention in the encoder as well as
the decoder, thus eliminating the need for RNNs, as we explain below. Transformers have been used
for many (conditional) sequence generation tasks, such as machine translation [Vas+17], constituency
parsing [Vas+17], music generation [Hua+18], protein sequence generation [Mad+20; Cho+20b],
abstractive text summarization [Zha+19a], image generation [Par+18] (treating the image as a
rasterized 1d sequence), etc.
The transformer is a rather complex model that uses several new kinds of building blocks or layers.
We introduce these new blocks below, and then discuss how to put them all together.4
15.5.1 Self-attention
In Section 15.4.4 we showed how the decoder of an RNN could use attention to the input sequence in
order to capture contexual embeddings of each input. However, rather than the decoder attending to
the encoder, we can modify the model so the encoder attends to itself. This is called self attention
[CDL16; Par+16b].
In more detail, given a sequence of input tokens x1, . . . , xn, where xi ∈ R
d
, self-attention can
generate a sequence of outputs of the same size using
yi = Attn(xi
,(x1, x1), . . . ,(xn, xn)) (15.54)
where the query is xi
, and the keys and values are all the (valid) inputs x1, . . . , xn.
To use this in a decoder, we can set xi = yi−1, and n = i − 1, so all the previously generated
outputs are available. At training time, all the outputs are already known, so we can evaluate the
above function in parallel, overcoming the sequential bottleneck of using RNNs.
In addition to improved speed, self-attention can give improved representations of context. As
an example, consider translating the English sentences “The animal didn’t cross the street because
4. For a more detailed introduction, see https://huggingface.co/course/chapter1.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.5. Transformers 521
Figure 15.23: Illustration of how encoder self-attention for the word “it” differs depending on the input
context. From https: // ai. googleblog. com/ 2017/ 08/ transformer-novel-neural-network. html . Used
with kind permission of Jakob Uszkoreit.
Dense
Concat
Attention Attention
Dense Dense Dense Dense Dense Dense
Queries Keys Values
…
Figure 15.24: Multi-head attention. Adapted from Figure 9.3.3 of [Zha+20].
it was too tired” and “The animal didn’t cross the street because it was too wide” into French. To
generate a pronoun of the correct gender in French, we need to know what “it” refers to (this is called
coreference resolution). In the first case, the word “it” refers to the animal. In the second case,
the word “it” now refers to the street.
Figure 15.23 illustrates how self attention applied to the English sentence is able to resolve this
ambiguity. In the first sentence, the representation for “it” depends on the earlier representations of
“animal”, whereas in the latter, it depends on the earlier representations of “street”.
15.5.2 Multi-headed attention
If we think of an attention matrix as like a kernel matrix (as discussed in Section 15.4.2), it is natural
to want to use multiple attention matrices, to capture different notions of similarity. This is the
basic idea behind multi-headed attention (MHA). In more detail, query a given q ∈ R
dq
, keys
kj ∈ R
dk , and values vj ∈ R
dv , we define the i’th attention head to be
hi = Attn(W(q)
i
q, {W(k)
i kj ,W(v)
i vj}) ∈ R
pv
(15.55)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license522 Chapter 15. Neural Networks for Sequences
where W(q)
i ∈ R
pq×dq
, W(k)
i ∈ R
pk×dk , and W(v)
i ∈ R
pv×dv are projection matrices. We then stack
the h heads together, and project to R
po using
h = MHA(q, {kj , vj}) = Wo


h1
.
.
.
hh


∈ R
po
(15.56)
where hi
is defined in Equation (15.55), and Wo ∈ R
po×hpv . If we set pqh = pkh = pvh = po, we can
compute all the output heads in parallel. See code.probml.ai/book1/multi_head_attention for some
sample code.
15.5.3 Positional encoding
The performance of “vanilla” self-attention can be low, since attention is permutation invariant, and
hence ignores the input word ordering. To overcome this, we can concatenate the word embeddings
with a positional embedding, so that the model knows what order the words occur in.
One way to do this is to represent each position by an integer. However, neural networks cannot
natively handle integers. To overcome this, we can encode the integer in binary form. For example,
if we assume the sequence length is n = 3, we get the following sequence of d = 3-dimensional bit
vectors for each location: 000, 001, 010, 011, 100, 101, 110, 111. We see that the right most index
toggles the fastest (has highest frequency), whereas the left most index (most significant bit) toggles
the slowest. (We could of course change this, so that the left most bit toggles fastest.) We can
represent this as a position matrix P ∈ R
n×d
.
We can think of the above representation as using a set of basis functions (corresponding to powers
of 2), where the coefficients are 0 or 1. We can obtain a more compact code by using a different set
of basis functions, and real-valued weights. [Vas+17] propose to use a sinusoidal basis, as follows:
pi,2j = sin 
i
C2j/d 
, pi,2j+1 = cos 
i
C2j/d 
, (15.57)
where C = 10, 000 corresponds to some maximum sequence length. For example, if d = 4, the i’t row
is
pi = [sin( i
C0/4
), cos( i
C0/4
),sin( i
C2/4
), cos( i
C2/4
)] (15.58)
Figure 15.25a shows the corresponding position matrix for n = 60 and d = 32. In this case, the
left-most columns toggle fastest. We see that each row has a real-valued “fingerprint” representing
its location in the sequence. Figure 15.25b shows some of the basis functions (column vectors) for
dimensions 6 to 9.
The advantage of this representation is two-fold. First, it can be computed for arbitrary length
inputs (up to T ≤ C), unlike a learned mapping from integers to vectors. Second, the representation
of one location is linearly predictable from any other, given knowledge of their relative distance. In
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.5. Transformers 523
0 20
Column (encoding dimension)
0
10
20
30
40
50
Row (position)
1.0
0.5
0.0
0.5
1.0
(a)
0 10 20 30 40 50 60
Row (position)
1.0
0.5
0.0
0.5
1.0
Col 6
Col 7
Col 8
Col 9
(b)
Figure 15.25: (a) Positional encoding matrix for a sequence of length n = 60 and an embedding dimension of
size d = 32. (b) Basis functions for columsn 6 to 9. Generated by code at figures.probml.ai/book1/15.25.
particular, we have pt+φ = f(pt), where f is a linear transformation. To see this, note that

sin(ωk(t + φ))
cos(ωk(t + φ))
=

sin(ωkt) cos(ωkφ) + cos(ωkt) sin(ωkφ)
cos(ωkt) cos(ωkφ) − sin(ωt) sin(ωkφ)

(15.59)
=

cos(ωkφ) sin(ωkφ)
− sin(ωkφ) cos(ωkφ)
 sin(ωkt)
cos(ωkt)

(15.60)
So if φ is small, then pt+φ ≈ pt. This provides a useful form of inductive bias.
Once we have computed the positional emebddings P, we need to combine them with the original
word embeddings X using the following:5
POS(Embed(X)) = X + P. (15.61)
15.5.4 Putting it all together
A transformer is a seq2seq model that uses self-attention for the encoder and decoder rather than
an RNN. The encoder uses a series of encoder blocks, each of which uses multi-headed attention
(Section 15.5.2), residual connections (Section 13.4.4), and layer normalization (Section 14.2.4.2).
More precisely, the encoder block can be defined as follows:
def EncoderBlock(X):
Z = LayerNorm(MultiHeadAttn(Q=X, K=X, V=X) + X)
E = LayerNorm(FeedForward(Z) + Z)
return E
The overall encoder is defined by applying positional encoding to the embedding of the input sequence,
following by N copies of the encoder block, where N controls the depth of the block:
5. A more obvious combination scheme would be to concatenate, X and P, but adding takes less space. Furthermore,
since the X embeddings are learned, the model could emulate concatentation by setting the first K dimensions of X,
and the last D − K dimensions of P, to 0, where K is defined implicitly by the sparsity pattern. For more discussion,
see https://bit.ly/3rMG1at.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license524 Chapter 15. Neural Networks for Sequences
Figure 15.26: The transformer. From [Wen18]. Used with kind permission of Lilian Weng. Adapted from
Figures 1–2 of [Vas+17].
def Encoder(X, N):
E = POS(Embed(X))
for n in range(N):
E = EncoderBlock(E)
return E
See the LHS of Figure 15.26 for an illustration.
The decoder has a somewhat more complex structure. It is given access to the encoder via
another multi-head attention block. But it is also given access to previously generated outputs: these
are shifted, and then combined with a positional embedding, and then fed into a masked (causal)
multi-head attention model. Finally the output distribution over tokens at each location is computed
in parallel.
In more detail, the decoder block is defined as follows:
def DecoderBlock(Y, E):
Z = LayerNorm(MultiHeadAttn(Q=Y, K=Y, V=Y) + Y)
Z’ = LayerNorm(MultiHeadAttn(Q=Z, K=E, V=E) + Z)
D = LayerNorm(FeedForward(Z’) + Z’)
return D
The overall decoder is defined by N copies of the decoder block:
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.5. Transformers 525
Figure 15.27: Comparison of (1d) CNNs, RNNs and self-attention models. From Figure 10.6.1 of [Zha+20].
Used with kind permission of Aston Zhang.
def Decoder(Y, E, N):
D = POS(Embed(Y))
for n in range(N):
D = DecoderBlock(D,E)
return D
See the RHS of Figure 15.26 for an illustration.
During training time, all the inputs Y to the decoder are known in advance, since they are derived
from embedding the lagged target output sequence. During inference (test) time, we need to decode
sequentially, and use masked attention, where we feed the generated output into the embedding
layer, and add it to the set of keys/values that can be attended to. (We initialize by feeding in the
start-of-sequence token.) See code.probml.ai/book1/transformers_torch for some sample code, and
[Rus18; Ala18] for a detailed tutorial on this model.
15.5.5 Comparing transformers, CNNs and RNNs
In Figure 15.27, we visually compare three different architectures for mapping a sequence x1:n to
another sequence y1:n: a 1d CNN, an RNN, and an attention-based model. Each model makes
different tradeoffs in terms of speed and expressive power, where the latter can be quantified in terms
of the maximum path length between any two inputs. See Table 15.1 for a summary.
For a 1d CNN with kernel size k and d feature channels, the time to compute the output is O(knd2
),
which can be done in parallel. We need a stack of n/k layers, or logk
(n) if we use dilated convolution,
to ensure all pairs can communicate. For example, in Figure 15.27, we see that x1 and x5 are initially
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license526 Chapter 15. Neural Networks for Sequences
Layer type Complexity Sequential ops. Max. path length
Self-attention O(n
2d) O(1) O(1)
Recurrent O(nd2
) O(n) O(n)
Convolutional O(knd2
) O(1) O(logk n)
Table 15.1: Comparison of the transformer with other neural sequential generative models. n is the sequence
length, d is the dimensionality of the input features, and k is the kernel size for convolution. Based on Table
1 of [Vas+17].
5 apart, and then 3 apart in layer 1, and then connected in layer 2.
For an RNN, the computational complexity is O(nd2
), for a hidden state of size d, since we have
to perform matrix-vector multiplication at each step. This is an inherently sequential operation. The
maximum path length is O(n).
Finally, for self-attention models, every output is directly connected to every input, so the maximum
path length is O(1). However, the computational cost is O(n
2d). For short sequences, we typically
have n  d, so this is fine. For longer sequences, we discuss various fast versions of attention in
Section 15.6.
15.5.6 Transformers for images *
CNNs (Chapter 14) are the most common model type for processing image data, since they have
useful built-in inductive bias, such as locality (due to small kernels), equivariance (due to weight
tying), and invariance (due to pooling). Suprisingly, it has been found that transformers can also do
well at image classification, at least if trained on enough data. (They need a lot of data to overcome
their lack of relevant inductive bias.)
In particular, [Dos+21] present the ViT model (vision transformer), that chops the input up into
16x16 patches, projects each patch into an embedding space, and then passes this set of embeddings
x1:T to a transformer, analogous to the way word embeddings are passed to a transformer. The
input is also prepended with a special [CLASS] embedding, x0. The output of the transformer is a
set of encodings e0:T ; the model maps e0 to the target class label y, and is trained in a supervised
way. See Figure 15.28 for an illustration.
After supervised pretraining, the model is fine-tuned on various downstream classification tasks,
an approach known as transfer learning (see Section 19.2 for more details). When trained on “small”
datasets such as ImageNet (which has 1k classes and 1.3M images), they find that they cannot
outperform a pretrained CNN ResNet model (Section 14.3.4) known as BiT (big transfer) [Kol+20].
However, when trained on larger datasets, such as ImageNet-21k (with 21k classes and 14M images),
or the Google-internal JFT dataset (with 18k classes and 303M images), they find that ViT does
better than BiT at transfer learning. It is also cheaper to train than ResNet at this scale. (However,
training is still expensive: the large ViT model on ImageNet-21k takes 30 days on a Google Cloud
TPUv3 with 8 cores!)
15.5.7 Other transformer variants *
Many extensions of transformers have been published in the last few years. For example, the Gshard
paper [Lep+21] shows how to scale up transformers to even more parameters by replacing some of
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.6. Efficient transformers * 527
Transformer Encoder
MLP
Head
Vision Transformer (ViT)
*
Linear Projection of Flattened Patches
* Extralearnable
[ cl ass] embedding
1 2 3 4 5 6 7 8 9 Patch + Position 0 Embedding
Class
Bird
Ball
Car
...
Embedded
Patches
Multi-Head
Attention
Norm
MLP
Norm
+
L x
+
Transformer Encoder
Figure 15.28: The Vision Transformer (ViT) model. This treats an image as a set of input patches. The
input is prepended with the special CLASS embedding vector (denoted by *) in location 0. The class label for
the image is derived by applying softmax to the final ouput encoding at location 0. From Figure 1 of [Dos+21].
Used with kind permission of Alexey Dosovitskiy
the feed forward dense layers with a mixture of experts (Section 13.6.2) regression module. This
allows for sparse conditional computation, in which only a subset of the model capacity (chosen by
the gating network) is used for any given input.
As another example, the conformer paper [Gul+20] showed how to add convolutional layers
inside the transformer architecture, which was shown to be helpful for various speech recognition
tasks.
15.6 Efficient transformers *
This section is written by Krzysztof Choromanski.
Regular transformers take O(N2
) time and space complexity, for a sequence of length N, which
makes them impractical to apply to long sequences. In the past few years, researchers have proposed
several more efficient variants of transformers to bypass this difficulty. In this section, we give a
brief survey of some of these methods (see Figure 15.29 for a summary). For more details, see e.g.,
[Tay+20a; Tay+20b; Lin+21].
15.6.1 Fixed non-learnable localized attention patterns
The simplest modification of the attention mechanism is to constrain it to a fixed non-learnable
localized window, in other words restrict each token to attend only to a pre-selected set of other
tokens. If for instance, each sequence is chunked into K blocks, each of length N
K
, and attention
is conducted only within a block, then space/time complexity is reduced from O(N2
) to N2
K
. For
K  1 this constitutes substantial overall computational improvements. Such an approach is applied
in particular in [Qiu+19a; Par+18]. The attention patterns do not need to be in the form of blocks.
Other approaches involve strided / dilated windows, or hybrid patterns, where several fixed attention
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license528 Chapter 15. Neural Networks for Sequences
Performer 
(Choromanski et al., 2020)
Linformer
(Wang et al., 2020b)
Linear 
Transformer
(Katharopoulos et al., 2020)
Set Transformer 
(Lee et al., 2019)
Transformer-XL
(Dai et al., 2019) 
Memory 
Compressed
(Liu et al., 2018)
ETC
(Ainslie et al., 2020)
Sparse Transformer
(Child et al., 2019) Image Transformer
(Parmar et al., 2018)
Routing
Transformer
(Roy et al., 2020) Synthesizer
(Tay et al., 2020a)
Longformer
(Beltagy et al., 2020)
Big Bird
(Zaheer et al., 2020) 
Axial Transformer
(Ho et al., 2019)
Blockwise Transformer
(Qiu et al., 2019)
Sinkhorn
Transformer 
(Tay et al., 2020b)
Reformer
(Kitaev et al., 2020)
Compressive 
Transformer
(Rae et al., 2018)
Figure 15.29: Venn diagram presenting the taxonomy of different efficient transformer architectures. From
[Tay+20a]. Used with kind permission of Yi Tay.
patterns are combined together [Chi+19b; BPC20].
15.6.2 Learnable sparse attention patterns
A natural extension of the above approach is to allow the above compact patterns to be learned. The
attention is still restricted to pairs of tokens within a single partition of some partitioning of the set
of all the tokens, but now those partitionings are trained. In this class of methods we can distinguish
two main approaches: based on hashing and clustering. In the hashing scenario all tokens are hashed
and thus different partitions correspond to different hashing-buckets. This is the case for instance for
the Reformer architecture [KKL20], where locality sensitive hashing (LSH) is applied. That leads
to time complexity O(NM2
log(M)) of the attention module, where M stands for the dimenionsality
of tokens’ embeddings.
Hashing approaches require the set of queries to be identical to the set of keys. Furthermore,
the number of hashes needed for precise partitioning (which in the above expression is treated as a
constant) can be a large constant. In the clustering approach, tokens are clustered using standard
clustering algorithms such as K-means (Section 21.3); this is known as the “clustering transformer”
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.6. Efficient transformers * 529
[Roy+20]. As in the block-case, if K equal-size clusters are used then space complexity of the
attention module is reduced to O(
N2
K
). In practice K is often taken to be of order K = Θ(√
N), yet
imposing that the clusters be similar in size is in practice difficult.
15.6.3 Memory and recurrence methods
In some approaches, a side memory module can access several tokens simultaneously. This method is
often instantiated in the form of a global memory algorithm as used in [Lee+19; Zah+20].
Another approach is to connect different local blocks via recurrence. A flagship example of this
approach is the class of Transformer-XL methods [Dai+19].
15.6.4 Low-rank and kernel methods
In this section, we discuss methods that approximate attention using low rank matrices. In [She+18;
Kat+20] they approximate the attention matrix A directly by a low rank matrix, so that
Aij = φ(qi)
Tφ(kj ) (15.62)
where φ(x) ∈ RM is some finite-dimensional vector with M < D. One can leverage this structure to
compute AV in O(N) time. Unfortunately, for softmax attention, the A is not low rank.
In Linformer [Wan+20a], they instead transform the keys and values via random Gaussian pro￾jections. They then apply the theory of the Johnson-Lindenstrauss Transform [AL13] to approximate
softmax attention in this lower dimensional space.
In Performer [Cho+20a; Cho+20b], they show that the attention matrix can be computed using
a (positive definite) kernel function. We define kernel functions in Section 17.1, but the basic idea
is that K(q, k) ≥ 0 is some measure of similarity between q ∈ R
D and k ∈ R
D. For example, the
Gaussian kernel, also called the radial basis function kernel, has the form
Kgauss(q, k) = exp 
−
1
2σ
2
||q − k||2
2

(15.63)
To see how this can be used to compute an attention matrix, note that [Cho+20a] show the following:
Ai,j = exp(q
T
i kj
√
D
) = exp(−kqi − kjk
2
2
2
√
D
) × exp(kqik
2
2
2
√
D
) × exp(kkjk
2
2
2
√
D
). (15.64)
The first term in the above expression is equal to Kgauss(qiD−1/4
, kjD−1/4
) with σ = 1, and the
other two terms are just independent scaling factors.
So far we have not gained anything computationally. However, we will show in Section 17.2.9.3
that the Gaussian kernel can be written as the expectation of a set of random features:
Kgauss(x, y) = E

η(x)
Tη(y)

(15.65)
where η(x) ∈ RM is a random feature vector derived from x, either based on trigonometric functions
Equation (17.60) or exponential functions Equation (17.61). (The latter has the advantage that all
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license530 Chapter 15. Neural Networks for Sequences
Figure 15.30: Attention matrix A rewritten as a product of two lower rank matrices Q0
and (K0
)
T with random
feature maps φ(qi) ∈ R
M and φ(vk) ∈ R
M for the corresponding queries/keys stored in the rows/columns.
Used with kind permission of Krzysztof Choromanski.
Figure 15.31: Decomposition of the attention matrix A can be leveraged to improve attention computations
via matrix associativity property. To compute AV, we first calculate G = (k
0
)
TV and then q
0G, resulting in
linear in N space and time complexity. Used with kind permission of Krzysztof Choromanski.
the features are positive, which gives much better results [Cho+20b].) Therefore for the regular
softmax attention, Ai,j can be rewritten as
Ai,j = E[φ(qi)
Tφ(kj )] (15.66)
where φ is defined as:
φ(x) , exp 
kxk
2
2
2
√
D

η

x
D
1
4

. (15.67)
We can write the full attention matrix as follows
A = E[Q0
(K0
)
T
] (15.68)
where Q0
, K0 ∈ R
N×M have rows encoding random feature maps corresponding to the queries and
keys. (Note that we can get better performance if we ensure these random features are orthogonal,
see [Cho+20a] for the details.) See Figure 15.30 for an illustration.
We can create an approximation to A by using a single sample of the random features φ(qi) and
φ(kj ), and using a small value of M, say M = O(D log(D)). We can then approximate the entire
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.7. Language models and unsupervised representation learning 531
attention operator in O(N) time using
attention( \ Q, K, V) = diag−1
(Q0
((K0
)
T1N ))(Q0
((K0
)
TV)) (15.69)
This can be shown to be an unbiased approximation to the exact softmax attention operator. See
Figure 15.31 for an illustration. (For details on how to generalize this to masked (causal) attention,
see [Cho+20a].)
15.7 Language models and unsupervised representation learning
We have discussed how RNNs and autoregressive (decoder-only) transformers can be used as language
models, which are generative sequence models of the form p(x1, . . . , xT ) = QT
t=1 p(xt|x1:t−1), where
each xt is a discrete token, such as a word or wordpiece. (See Section 1.5.4 for a discussion of
text preprocessing methods.) The latent state of these models can then be used as a continuous
vector representation of the text. That is, instead of using the one-hot vector xt, or a learned
embedding of it (such as those discussed in Section 20.5), we use the hidden state ht, which depends
on all the previous words in the sentence. These vectors can then be used as contextual word
embeddings, for purposes such as text classification or seq2seq tasks (see e.g. [LKB20] for a review).
The advantage of this approach is that we can pre-train the language model in an unsupervised
way, on a large corpus of text, and then we can fine-tune the model in a supervised way on a small
labeled task-specific dataset. (This general approach is called transfer learning, see Section 19.2
for details.)
If our primary goal is to compute useful representations for transfer learning, as opposed to
generating text, we can replace the generative sequence model with non-causal models that can
compute a representation of a sentence, but cannot generate it. These models have the advantage
that now the hidden state ht can depend on the past, y1:t−1, present yt, and future, yt+1:T . This
can sometimes result in better representations, since it takes into account more context.
In the sections below, we briefly discuss some unsupervised models for representation learning on
text, using both causal and non-causal models.
15.7.1 ELMo
In [Pet+18], they present a method called ELMo, which is short for “Embeddings from Language
Model”. The basic idea is to fit two RNN language models, one left-to-right, and one right-to-left,
and then to combine their hidden state representations to come up with an embedding for each
word. Unlike a biRNN (Section 15.2.2), which needs an input-output pair, ELMo is trained in an
unsupervised way, to minimize the negative log likelihood of the input sentence x1:T :
L(θ) = −
X
T
t=1
[log p(xt|x1:t−1; θe, θ
→, θs) + log p(xt|xt+1:T ; θe, θ
←, θs)] (15.70)
where θe are the shared parameters of the embedding layer, θs are the shared parameters of the
softmax output layer, and θ→ and θ← are the parameters of the two RNN models. (They use LSTM
RNNs, described in Section 15.2.7.2.) See Figure 15.32 for an illustration.
After training, we define the contextual representation rt = [et, h→
t,1:L
, h←
t,1:L
], where L is the
number of layers in the LSTM. We then learn a task-specific set of linear weights to map this to
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license532 Chapter 15. Neural Networks for Sequences
Figure 15.32: Illustration of ELMo bidrectional language model. Here yt = xt+1 when acting as the target for
the forwards LSTM, and yt = xt−1 for the backwards LSTM. (We add bos and eos sentinels to handle the
edge cases.) From [Wen19]. Used with kind permission of Lilian Weng.
the final context-specific embedding of each token: r
j
t = r
T
t wj
, where j is the task id. If we are
performing a syntactic task like part-of-speech (POS) tagging (i.e., labeling each word as a noun,
verb, adjective, etc), then the task will learn to put more weight on lower layers. If we are performing
a semantic task like word sense disambiguation (WSD), then the task will learn to put more
weight on higher layers. In both cases, we only need a small amount of task-specific labeled data,
since we are just learning a single weight vector, to map from r1:T to the target labels y1:T .
15.7.2 BERT
In this section, we describe the BERT model (Bidirectional Encoder Representations from Transform￾ers) of [Dev+19]. Like ELMo, this is a non-causal model, that can be used to create representations
of text, but not to generate text. In particular, it uses a transformer model to map a modified version
of a sequence back to the unmodified form. The modified input at location t omits all words except
for the t’th, and the task is to predict the missing word. This is called the fill-in-the-blank or
cloze task.
15.7.2.1 Masked language model task
More precisely, the model is trained to minimize the negative log pseudo-likelihood:
L = Ex∼DEm
X
i∈m
− log p(xi
|x−m) (15.71)
where m is a random binary mask. For example, if we train the model on transcripts from cooking
videos, we might create a training sentence of the form
Let’s make [MASK] chicken! [SEP] It [MASK] great with orange sauce.
where [SEP] is a separator token inserted between two sentences. The desired target labels for the
masked words are “some” and “tastes”. (This example is from [Sun+19a].)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.7. Language models and unsupervised representation learning 533
BERT 
Trm Trm Trm
Trm Trm Trm
...
...
 T1 T2 TN
...
 E1 E2
 E ... N
(a)
Trm Trm Trm
Trm Trm Trm
...
...
GPT
 T1 T2
 TN
...
 E1 E2
 EN
...
(b)
Figure 15.33: Illustration of (a) BERT and (b) GPT. Et is the embedding vector for the input token at
location t, and Tt is the output target to be predicted. From Figure 3 of [Dev+19]. Used with kind permission
of Ming-Wei Chang.
The conditional probability is given by applying a softmax to the final layer hidden vector at
location i:
p(xi
|xˆ) = exp(h(xˆ)
T
i e(xi))
P
x0 exp(h(xˆ)
T
i
e(x
0)) (15.72)
where xˆ = x−m is the masked input sentence, and e(x) is the embedding for token x. This is used
to compute the loss at the masked locations; this is therefore called a masked language model.
(This is similar to a denoising autoencoder, Section 20.3.2). See Figure 15.33a for an illustration of
the model.
15.7.2.2 Next sentence prediction task
In addition to the masked language model objective, the original BERT paper added an additional
objective, in which the model is trained to classify if one sentence follows another. More precisely,
the model is fed as input
CLS A1 A2; . . . Am; SEP B1 B2; . . . ; Bn SEP (15.73)
where SEP is a special separator token, and CLS is a special token marking the class. If sentence B
follows A in the original text, we set the target label to y = 1, but if B is a randomly chosen sentence,
we set the target label to y = 0. This is called the next sentence prediction task. This kind of
pre-training can be useful for sentence-pair classification tasks, such as textual entailment or textual
similarity, which we discussed in Section 15.4.6. (Note that this kind of pre-training is considered
unsupervised, or self-supervised, since the target labels are automatically generated.)
When performing next sentence prediction, the input to the model is specified using 3 different
embeddings: one per token, one for each segment label (sentence A or B), and one per location
(using a learned positional embedding). These are then added. See Figure 15.34 for an illustration.
BERT then uses a transformer encoder to learn a mapping from this input embedding sequence to
an output embedding sequence, which gets decoded into word labels (for the masked locations) or a
class label (for the CLS location).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license534 Chapter 15. Neural Networks for Sequences
Figure 15.34: Illustration of how a pair of input sequences, denoted A and B, are encoded before feeding to
BERT. From Figure 14.8.2 of [Zha+20]. Used with kind permission of Aston Zhang.
15.7.2.3 Fine-tuning BERT for NLP applications
After pre-training BERT in an unsupervised way, we can use it for various downtream tasks by perform￾ing supervised fine-tuning. (See Section 19.2 for more background on such transfer learning methods.)
Figure 15.35 illustrates how we can modify a BERT model to perform different tasks, by simply
adding one or more new output heads to the final hidden layer. See code.probml.ai/book1/bert_torch
for some sample code.
In Figure 15.35(a), we show how we can tackle single sentence classification (e.g., sentiment
analysis): we simply take the feature vector associated with the dummy CLS token and feed it into an
MLP. Since each output attends to all inputs, this hidden vector will summarize the entire sentence.
The MLP then learns to map this to the desired label space.
In Figure 15.35(b), we show how we can tackle sentence-pair classification (e.g., textual entail￾ment, as discussed in Section 15.4.6): we just feed in the two input sentences, formatted as in
Equation (15.73), and then classify the CLS token.
In Figure 15.35(c), we show how we can tackle single sentence tagging, in which we associate a
label or tag with each word, instead of just the entire sentence. A common application of this is part
of speech tagging, in which we annotate each words a noun, verb, adjective, etc. Another application
of this is noun phrase chunking, also called shallow parsing, in which we must annotate the
span of each noun phrase. The span is encoded using the BIO notation, in which B is the beginning
of an entity, I-x is for inside, and O is for outside any entity. For example, consider the following
sentence:
B I O O O B I O B I I
British Airways rose after announcing its withdrawl from the UAI deal
We see that there are 3 noun phrases, “British Airways”, “its withdrawl” and “the UAI deal”. (We
require that the B, I and O labels occur in order, so this a prior constraint that can be included in
the model.)
We can also associate types with each noun phrase, for example distinguishing person, location,
organization, and other. Thus the label space becomes {B-Per, I-Per, B-Loc, I-Loc, B-Org, I-Org,
Outside }. This is called named entity recognition, and is a key step in information extraction.
For example, consider the following sentence:
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.7. Language models and unsupervised representation learning 535
(a) (b)
(c) (d)
Figure 15.35: Illustration of how BERT can be used for different kinds of supervised NLP tasks. (a) Single
sentence classification (e.g., sentiment analysis); (b) Sentence-pair classification (e.g., textual entailment);
(d) Single sentence tagging (e.g., shallow parsing); (d) Question answering. From Figure 4 of [Dev+19]. Used
with kind permission of Ming-Wei Chang.
BP IP O O O BL IL BP O O O O
Mrs Green spoke today in New York. Green chairs the finance committee.
From this, we infer that the first sentence has two named entities, namely “Mrs Green” (of type
Person) and “New York” (of type Location). The second sentence mentions another person, “Green”,
that most likely is the same as the first person, although this across-sentence entity resolution is not
part of the basic NER task.
Finally, in Figure 15.35(d), we show how we can tackle question answering. Here the first input
sentence is the question, the second is the background text, and the output is required to specifying
the start and end locations of the relevant part of the background that contains the answer (see
Table 1.4). The start location s and end location e are computed by applying 2 different MLPs to a
pooled version of the output encodings for the background text; the output of the MLPs is a softmax
over all locations. At test time, we can extract the span (i, j) which maximizes the sum of scores
si + ej for i ≤ j.
BERT achieves state-of-the-art performance on many NLP tasks. Interestingly, [TDP19] shows
that BERT implicitly rediscovers the standard NLP pipeline, in which different layers perform tasks
such as part of speech (POS) tagging, parsing, named entity relationship (NER) detection, semantic
role labeling (SRL), coreference resolution, etc. More details on NLP can be found in [JM20].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license536 Chapter 15. Neural Networks for Sequences
15.7.3 GPT
In [Rad+18], they propose a model called GPT, which is short for “Generative Pre-training Trans￾former”. This is a causal (generative) model, that uses a masked transformer as the decoder. See
Figure 15.33b for an illustration.
In the original GPT paper, they jointly optimize on a large unlabeled dataset, and a small la￾beled dataset. In the classification setting, the loss is given by L = Lcls + λLLM, where Lcls =
−
P
(x,y)∈DL
log p(y|x) is the classification loss on the labeled data, and LLM = −
P
x∈DU
P
t
p(xt|x1:t−1)
is the language modeling loss on the unlabeled data.
In [Rad+19], they propose GPT-2, which is a larger version of GPT, trained on a large web
corpus called WebText. They also eliminate any task-specific training, and instead just train it
as a language model. More recently, OpenAI released GPT-3 [Bro+20], which is an even larger
version of GPT-2, but based on the same principles. An open-source version of the model is available
at https://huggingface.co/EleutherAI, which was trained on an 800GB English-language web
corpus called “The Pile” [Gao+20].
15.7.3.1 Applications of GPT
GPT can generate text given an initial input prompt. The prompt can specify a task; if the
generated response fulfills the task “out of the box”, we say the model is performing zero-shot task
transfer (see Section 19.6 for details).
For example, to perform abstractive summarization of some input text x1:T (as opposed
to extractive summarization, which just selects a subset of the input words), we sample from
p(xT +1:T +100|[x1:T ; TL;DR]), where TL;DR is a special token added to the end of the input text,
which tells the system the user wants a summary. TL;DR stands for “too long; didn’t read” and
frequently occurs in webtext followed by a human-created summary. By adding this token to the
input, the user hopes to “trigger” the transformer decoder into a state in which it enters summarization
mode. (A better way to tell the model what task to perform is to train it on input-output pairs, as
discussed in Section 15.7.4.)
15.7.4 T5
Many models are trained in an unsupervised way, and then fine-tuned on specific tasks. It is also
possible to train a single model to perform multiple tasks, by telling the system what task to perform
as part of the input sentence, and then training it as a seq2seq model, as illustrated in Figure 15.36.
This is the approach used in T5 [Raf+19], which stands for “Text-to-text Transfer Transformer”. The
model is a standard seq2seq transformer, that is pretrained on unsupervised (x
0
, x
00) pairs, where x
0
is a masked version of x and x
00 are the missing tokens that need to be predicted, and then fine-tuned
on multiple supervised (x, y) pairs.
The unsupervised data comes from C4, or the “Colossal Clean Crawled Corpus”, a 750GB corpus
of web text. This is used for pretraining using a BERT-like denoising objective. For example, the
sentence x =“Thank you for inviting me to your party last week” may get converted to the input x
0 =
“Thank you <X> me to your party <Y> week” and the output (target) x
00 = “<X> for inviting <Y>
last <EOS>”, where < X > and < Y > are tokens that are unique to this example. The supervised
datasets are manually created, and are taken from the literature. This approach is currently the
state-of-the-art on many NLP tasks.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202215.7. Language models and unsupervised representation learning 537
"translate English to German: That is good."
"cola sentence: The 
course is jumping well."
"summarize: state authorities 
dispatched emergency crews tuesday to 
survey the damage after an onslaught 
of severe weather in mississippi…"
"stsb sentence1: The rhino grazed 
on the grass. sentence2: A rhino 
is grazing in a field."
T5
"Das ist gut."
"not acceptable"
"six people hospitalized after 
a storm in attala county."
"3.8"
Figure 15.36: Illustration of how the T5 model (“Text-to-text Transfer Transformer”) can be used to perform
multiple NLP tasks, such as translating English to German; determining if a sentence is linguistic valid or
not (CoLA stands for “Corpus of Linguistic Acceptability”); determining the degree of semantic similarity
(STSB stands for “Semantic Textual Similarity Benchmark”); and abstractive summarization. From Figure 1
of [Raf+19]. Used with kind permission of Colin Raffel.
15.7.5 Discussion
Giant language models, such as BERT and GPT-3, have recently generated a lot of interest, and have
even made their way into the mainstream media.6 However, there is some doubt about whether such
systems “understand” language in any meaningful way, beyond just rearranging word patterns seen
in their massive training sets. For example, [NK19] show that the ability of BERT to perform almost
as well as humans on the Argument Reasoning Comprehension Task is “entirely accounted for by
exploitation of spurious statistical cues in the dataset”. By slightly tweaking the dataset, performance
can be reduced to chance levels. For other criticisms of such models, see e.g., [BK20; Mar20].
6. See e.g., https://www.nytimes.com/2020/11/24/science/artificial-intelligence-ai-gpt3.html.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensePart IV
Nonparametric Models16 Exemplar-based Methods
So far in this book, we have mostly focused on parametric models, either unconditional p(y|θ)
or conditional p(y|x, θ), where θ is a fixed-dimensional vector of parameters. The parameters are
estimated from a variable-sized dataset, D = {(xn, yn) : n = 1 : N}, but after model fitting, the data
is thrown away.
In this section we consider various kinds of nonparametric models, that keep the training data
around. Thus the effective number of parameters of the model can grow with |D|. We focus on
models that can be defined in terms of the similarity between a test input, x, and each of the
training inputs, xn. Alternatively, we can define the models in terms of a dissimilarity or distance
function d(x, xn). Since the models keep the training examples around at test time, we call them
exemplar-based models. (This approach is also called instance-based learning [AKA91], or
memory-based learning.)
16.1 K nearest neighbor (KNN) classification
In this section, we discuss one of the simplest kind of classifier, known as the K nearest neighbor
(KNN) classifier. The idea is as follows: to classify a new input x, we find the K closest examples
to x in the training set, denoted NK(x, D), and then look at their labels, to derive a distribution
over the outputs for the local region around x. More precisely, we compute
p(y = c|x, D) = 1
K
X
n∈NK(x,D)
I(yn = c) (16.1)
We can then return this distribution, or the majority label.
The two main parameters in the model are the size of the neighborhood, K, and the distance
metric d(x, x
0
). For the latter, it is common to use the Mahalanobis distance
dM(x, µ) = q
(x − µ)
TM(x − µ) (16.2)
where M is a positive definite matrix. If M = I, this reduces to Euclidean distance. We discuss how
to learn the distance metric in Section 16.2.
Despite the simplicity of KNN classifiers, it can be shown that this approach becomes within a
factor of 2 of the Bayes error (which measures the performance of the best possible classifier) if
N → ∞ [CH67; CD14]. (Of course the convergence rate to this optimal performance may be poor in
practice, for reasons we discuss in Section 16.1.2.)542 Chapter 16. Exemplar-based Methods
(a)
0.0 0.2 0.4 0.6 0.8 1.0
0.0
0.2
0.4
0.6
0.8
1.0
(b)
Figure 16.1: (a) Illustration of a K-nearest neighbors classifier in 2d for K = 5. The nearest neighbors of test
point x have labels {1, 1, 1, 0, 0}, so we predict p(y = 1|x, D) = 3/5. (b) Illustration of the Voronoi tesselation
induced by 1-NN. Adapted from Figure 4.13 of [DHS01]. Generated by code at figures.probml.ai/book1/16.1.
16.1.1 Example
We illustrate the KNN classifier in 2d in Figure 16.1(a) for K = 5. The test point is marked as
an “x”. 3 of the 5 nearest neighbors have label 1, and 2 of the 5 have label 0. Hence we predict
p(y = 1|x, D) = 3/5 = 0.6.
If we use K = 1, we just return the label of the nearest neighbor, so the predictive distribution
becomes a delta function. A KNN classifier with K = 1 induces a Voronoi tessellation of the
points (see Figure 16.1(b)). This is a partition of space which associates a region V (xn) with each
point xn in such a way that all points in V (xn) are closer to xn than to any other point. Within
each cell, the predicted label is the label of the corresponding training point. Thus the training error
will be 0 when K = 1. However, such a model is usually overfitting the training set, as we show
below.
Figure 16.2 gives an example of KNN applied to a 2d dataset, in which we have three classes. We
see how, with K = 1, the method makes zero errors on the training set. As K increases, the decision
boundaries become smoother (since we are averaging over larger neighborhoods), so the training
error increases, as we start to underfit. This is shown in Figure 16.2(d). The test error shows the
usual U-shaped curve.
16.1.2 The curse of dimensionality
The main statistical problem with KNN classifiers is that they do not work well with high dimensional
inputs, due to the curse of dimensionality.
The basic problem is that the volume of space grows exponentially fast with dimension, so you
might have to look quite far away in space to find your nearest neighbor. To make this more precise,
consider this example from [HTF09, p22]. Suppose we apply a KNN classifier to data where the
inputs are uniformly distributed in the D-dimensional unit cube. Suppose we estimate the density of
class labels around a test point x by “growing” a hyper-cube around x until it contains a desired
fraction p of the data points. The expected edge length of this cube will be eD(s) , p
1/D; this
function is plotted in Figure 16.3(b). If D = 10, and we want to base our estimate on 10% of the
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202216.1. K nearest neighbor (KNN) classification 543
20 15 10 5 0 5 10 15 20
20
10
0
10
20
30
k=1
(a)
20 15 10 5 0 5 10 15 20
20
10
0
10
20
30
k=2
(b)
20 15 10 5 0 5 10 15 20
20
10
0
10
20
30
k=5
(c)
0 10 20 30 40 50 60 70 80
k
0.0
0.1
0.2
0.3
0.4
0.5
misclassification rate
train
test
(d)
Figure 16.2: Decision boundaries induced by a KNN classifier. (a) K = 1. (b) K = 2. (c) K = 5. (d) Train
and test error vs K. Generated by code at figures.probml.ai/book1/16.2.
(a)
0 0.2 0.4 0.6 0.8 1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Fraction of data in neighborhood
Edge length of cube
d=1
d=3
d=5
d=7
d=10
(b)
Figure 16.3: Illustration of the curse of dimensionality. (a) We embed a small cube of side s inside a
larger unit cube. (b) We plot the edge length of a cube needed to cover a given volume of the unit cube as
a function of the number of dimensions. Adapted from Figure 2.6 from [HTF09]. Generated by code at
figures.probml.ai/book1/16.3.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license544 Chapter 16. Exemplar-based Methods
data, we have e10(0.1) = 0.8, so we need to extend the cube 80% along each dimension around x.
Even if we only use 1% of the data, we find e10(0.01) = 0.63. Since the range of the data is only 0 to
1 along each dimension, we see that the method is no longer very local, despite the name “nearest
neighbor”. The trouble with looking at neighbors that are so far away is that they may not be good
predictors about the behavior of the function at a given point.
There are two main solutions to the curse: make some assumptions about the form of the function
(i.e., use a parametric model), and/or use a metric that only cares about a subset of the dimensions
(see Section 16.2).
16.1.3 Reducing the speed and memory requirements
KNN classifiers store all the training data. This is obviously very wasteful of space. Various heuristic
pruning techniques have been proposed to remove points that do not affect the decision boundaries,
see e.g., [WM00]. In Section 17.4, we discuss a more principled approach based on a sparsity
promoting prior; the resulting method is called a sparse kernel machine, and only keeps a subset of
the most useful exemplars.
In terms of running time, the challenge is to find the K nearest neighbors in less than O(N)
time, where N is the size of the training set. Finding exact nearest neighbors is computationally
intractable when the dimensionality of the space goes above about 10 dimensions, so most methods
focus on finding the approximate nearest neighbors. There are two main classes of techniques, based
on partitioning space into regions, or using hashing.
For partitioning methods, one can either use some kind of k-d tree, which divides space into
axis-parallel regions, or some kind of clustering method, which uses anchor points. For hashing
methods, locality sensitive hashing (LSH) [GIM99] is widely used, although more recent methods
learn the hashing function from data (see e.g., [Wan+15]). See [LRU14] for a good introduction to
hashing methods.
An open-source library called FAISS, for efficient exact and approximate nearest neighbor search
(and K-means clustering) of dense vectors, is available at https://github.com/facebookresearch/
faiss, and described in [JDJ17].
16.1.4 Open set recognition
Ask not what this is called, ask what this is like. — Moshe Bar.[Bar09]
In all of the classification problems we have considered so far, we have assumed that the set of
classes C is fixed. (This is an example of the closed world assumption, which assumes there is a
fixed number of (types of) things.) However, many real world problems involve test samples that
come from new categories. This is called open set recognition, as we discuss below.
16.1.4.1 Online learning, OOD detection and open set recognition
For example, suppose we train a face recognition system to predict the identity of a person from a
fixed set or gallery of face images. Let Dt = {(xn, yn) : xn ∈ X , yn ∈ Ct, n = 1 : Nt} be the labeled
dataset at time t, where X is the set of (face) images, and Ct = {1, . . . , Ct} is the set of people known
to the system at time t (where Ct ≤ t). At test time, the system may encounter a new person that
it has not seen before. Let xt+1 be this new image, and yt+1 = Ct+1 be its new label. The system
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202216.2. Learning distance metrics 545
needs to recognize that the input is from a new category, and not accidentally classify it with a
label from Ct. This is called novelty detection. In this case, the input is being generated from the
distribution p(x|y = Ct+1), where Ct+1 6∈ Ct is the new “class label”. Detecting that xt+1 is from a
novel class may be hard if the appearance of this new image is similar to the appearance of any of
the existing images in Dt.
If the system is succesful at detecting that xt+1 is novel, then it may ask for the id of this new
instance, call it Ct+1. It can then add the labeled pair (xt+1, Ct+1) to the dataset to create Dt+1, and
can grow the set of unique classes by adding Ct+1 to Ct (c.f., [JK13]). This is called incremental
learning, online learning, life-long learning, or continual learning. At future time points,
the system may encounter an image sampled from p(x|y = c), where c is an existing class, or where c
is a new class, or the image may be sampled from some entirely different kind of distribution p
0
(x)
unrelated to faces (e.g., someone uploads a photo of their dog). (Detecting this latter kind of event is
called out-of-distribution or OOD detection.)
In this online setting, we often only get a few (sometimes just one) example of each class. Prediction
in this setting is known as few-shot classification, and is discussed in more detail in Section 19.6.
KNN classifiers are well-suited to this task. For example, we can just store all the instances of each
class in a gallery of examples, as we explained above. At time t + 1, when we get input xt+1, rather
than predicting a label for xt+1 by comparing it to some parametric model for each class, we just
find the example in the gallery that is nearest (most similar) to xt+1, call it x
0
. We then need to
determine if x
0 and xt+1 are sufficiently similar to constitute a match. (In the context of person
classification, this is known as person re-identification or face verification, see e.g., [WSH16]).)
If there is no match, we can declare the input to be novel or OOD.
The key ingredient for all of the above problems is the (dis)similarity metric between inputs. We
discuss ways to learn this in Section 16.2.
16.1.4.2 Other open world problems
The problem of open-set recognition, and incremental learning, are just examples of problems that
require the open world assumption c.f., [Rus15]. There are many other examples of such problems.
For example, consider the problem of entity resolution, called entity linking. In this problem,
we need to determine if different strings (e.g., “John Smith” and “Jon Smith”) refer to the same entity
or not. See e.g. [SHF15] for details.
Another important application is in multi-object tracking. For example, when a radar system
detects a new “blip”, is it due to an existing missile that is being tracked, or is it a new objective
that has entered the airspace? An elegant mathematical framework for dealing with such problems,
known as random finite sets, is described in [Mah07; Mah13; Vo+15].
16.2 Learning distance metrics
Being able to compute the “semantic distance” between a pair of points, d(x, x
0
) ∈ R
+ for x, x
0 ∈ X ,
or equivalently their similarity s(x, x
0
) ∈ R
+, is of crucial importance to tasks such as nearest
neighbor classification (Section 16.1), self-supervised learning (Section 19.2.4.4), similarity-based
clustering (Section 21.5), content-based retrieval, visual tracking, etc.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license546 Chapter 16. Exemplar-based Methods
When the input space is X = R
D, the most common distance metric is the Mahalanobis distance
dM(x, x
0
) = q
(x − x0)
TM(x − x0) (16.3)
We discuss some methods to learn the matrix M in Section 16.2.1. For high dimensional inputs, or
structured inputs, it is better to first learn an embedding e = f(x), and then to compute distances
in embedding space. When f is a DNN, this is called deep metric learning; we discuss this in
Section 16.2.2.
16.2.1 Linear and convex methods
In this section, we discuss some methods that try to learn the Mahalanobis distance matrix M, either
directly (as a convex problem), or indirectly via a linear projection. For other approaches to metric
learning, see e.g., [Kul13; Kim19] for more details.
16.2.1.1 Large margin nearest neighbors
In [WS09], they propose to learn the Mahalanobis matrix M so that the resulting distance metric
works well when used by a nearest neighbor classifier. The resulting method is called large margin
nearest neighbor or LMNN.
This works as follows. For each example data point i, let Ni be a set of target neighbors; these
are usually chosen to be the set of K points with the same class label that are closest in Euclidean
distance. We now optimize M so that we minimize the distance between each point i and all of its
target neighbors j ∈ Ni
:
Lpull(M) = X
N
i=1
X
j∈Ni
dM(xi
, xj )
2
(16.4)
We also want to ensure that examples with incorrect labels are far away. To do this, we ensure that
each example i is closer (by some margin m ≥ 0) to its target neighbors j than to other points l with
different labels (so-called impostors). We can do this by minimizing
Lpush(M) = X
N
i=1
X
j∈Ni
X
N
l=1
I(yi 6= yl) [m + dM(xi
, xj )
2 − dM(xi
, xl)
2
]+ (16.5)
where [z]+ = max(z, 0) is the hinge loss function (Section 4.3.2). The overall objective is L(M) =
(1 − λ)Lpull(M) + λLpush(M), where 0 < λ < 1. This is a convex function defined over a convex set,
which can be minimized using semidefinite programming. Alternatively, we can parameterize
the problem using M = WTW, and then minimize wrt W using unconstrained gradient methods.
This is no longer convex, but allows us to use a low-dimensional mapping W.
For large datasets, we need to tackle the O(N3
) cost of computing Equation (16.5). We discuss
some speedup tricks in Section 16.2.5.
16.2.1.2 Neighborhood components analysis
Another way to learn a linear mapping W such that M = WTW is known as neighborhood
components analysis or NCA [Gol+05]. This defines the probability that sample xi has xj as its
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202216.2. Learning distance metrics 547
z
z'
x
x'
y
x
 x' z'
z
W, y
x
 x' z'
z
W, y
N
Figure 16.4: Illustration of latent coincidence analysis (LCA) as a directed graphical model. The inputs
x, x
0 ∈ R
D are mapped into Gaussian latent variables z, z
0 ∈ R
L
via a linear mapping W. If the two latent
points coincide (within length scale κ) then we set the similarity label to y = 1, otherwise we set it to y = 0.
From Figure 1 of [DS12]. Used with kind permission of Lawrence Saul.
nearest neighbor using the linear softmax function
pW
ij =
exp(−||Wxi − Wxj ||2
2
)
P
l6=i
exp(−||Wxi − Wxl
||2
2
)
(16.6)
(This is a supervised version of stochastic neighborhood embeddings discussed in Section 20.4.10.1.)
The expected number of correctly classified examples according for a 1NN classifier using distance
W is given by J(W) = PN
i=1
P
j6=i:yj=yi
pW
ij . Let L(W) = 1 − J(W)/N be the leave one out error.
We can minimize L wrt W using gradient methods.
16.2.1.3 Latent coincidence analysis
Yet another way to learn a linear mapping W such that M = WTW is known as latent coincidence
analysis or LCA [DS12]. This defines a conditional latent variable model for mapping a pair of
inputs, x and x
0
, to a label y ∈ {0, 1}, which specifies if the inputs are similar (e.g., have same class
label) or dissimilar. Each input x ∈ R
D is mapped to a low dimensional latent point z ∈ R
L using
a stochastic mapping p(z|x) = N (z|Wx, σ2
I), and p(z
0
|x
0
) = N (z
0
|Wx
0
, σ2
I). (Compare this to
factor analysis, discussed in Section 20.2.) We then define the probability that the two inputs are
similar using p(y = 1|z, z
0
) = exp(−
1
2κ2 ||z − z
0
||). See Figure 16.4 for an illustration of the modeling
assumptions.
We can maximize the log marginal likelihood `(W, σ2
, κ2
) = P
n
log p(yn|xn, x
0
n
) using the EM
algorithm (Section 8.7.2). (We can set κ = 1 WLOG, since it just changes the scale of W.) More
precisely, in the E step, we compute the posterior p(z, z
0
|x, x
0
, y) (which can be done in closed
form), and in the M step, we solve a weighted least squares problem (c.f., Section 13.6.2). EM will
monotonically increase the objective, and does not need step size adjustment, unlike the gradient based
methods used in NCA (Section 16.2.1.2). (It is also possible to use variational Bayes (Section 4.6.8.3)
to fit this model, as well as various sparse and nonlinear extensions, as discussed in [ZMY19].)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license548 Chapter 16. Exemplar-based Methods
16.2.2 Deep metric learning
When measuring the distance between high-dimensional or structured inputs, it is very useful to first
learn an embedding to a lower dimensional “semantic” space, where distances are more meaningful, and
less subject to the curse of dimensionality (Section 16.1.2). Let e = f(x; θ) ∈ R
L be an embedding
of the input that preserves the “relevant” semantic aspects of the input, and let eˆ = e/||e||2 be the
`2-normalized version. This ensures that all points lie on a hyper-sphere. We can then measure the
distance between two points using the normalized Euclidean distance
d(xi
, xj ; θ) = ||eˆi − eˆj ||2
2
(16.7)
where smaller values means more similar, or the cosine similarity
d(xi
, xj ; θ) = eˆ
T
i eˆj (16.8)
where larger values means more similar. (Cosine similarity measures the angle between the two
vectors, as illustrated in Figure 20.43.) These quantities are related via
||eˆi − eˆj ||2
2 = (eˆi − eˆj )
T
(eˆi − eˆj ) = 2 − 2eˆ
T
i eˆj (16.9)
This overall approach is called deep metric learning or DML.
The basic idea in DML is to learn the embedding function such that similar examples are closer than
dissimilar examples. More precisely, we assume we have a labeled dataset, D = {(xi
, yi) : i = 1 : N},
from which we can derive a set of similar pairs, S = {(i, j) : yi = yj}. If (i, j) ∈ S but (i, k) 6∈ S,
then we assume that xi and xj should be close in embedding space, whereas xi and xk should be
far. We discuss various ways to enforce this property below. Note that these methods also work
when we do not have class labels, provided we have some other way of defining similar pairs. For
example, in Section 19.2.4.3, we discuss self-supervised approaches to representation learning, that
automatically create semantically similar pairs, and learn embeddings to force these pairs to be closer
than unrelated pairs.
Before discussing DML in more detail, it is worth mentioning that many recent approaches to
DML are not as good as they claim to be, as pointed out in [MBL20; Rot+20]. (The claims in
some of these papers are often invalid due to improper experimental comparisons, a common flaw in
contemporary ML research, as discussed in e.g., [BLV19; LS19b].) We therefore focus on (slightly)
older and simpler methods, that tend to be more robust.
16.2.3 Classification losses
Suppose we have labeled data with C classes. Then we can fit a classification model in O(NC) time,
and then reuse the hidden features as an embedding function. (It is common to use the second-to-last
layer, since it generalizes better to new classes than the final layer.) This approach is simple and
scalable. However, it only learns to embed examples on the correct side of a decision boundary, which
does not necessarily result in similar examples being placed close together and dissimilar examples
being placed far apart. In addition, this method cannot be used if we do not have labeled training
data.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202216.2. Learning distance metrics 549
||GW(X1) –GW(X2)||
W
Similar Images
Minimize the distance
The Siamese Network
Maximize the distance
Dissimilar Images
x1 x2
GW(X1) W GW(X2)
DW
|| GW(X1) –GW(X2) ||
GW(X1) GW(X2)
(a) (b)
Figure 16.5: Networks for deep metric learning. (a) Siamese network. (b) Triplet network. Adapted from
Figure 5 of [KB19].
16.2.4 Ranking losses
In this section, we consider minimizing ranking loss, to ensure that similar examples are closer
than dissimilar examples. Most of these methods do not need class labels (although we sometimes
assume that labels exist as a notationally simple way to define similarity).
16.2.4.1 Pairwise (contrastive) loss and Siamese networks
One of the earliest approaches to representation learning from similar/dissimilar pairs was based on
minimizing the following contrastive loss [CHL05]:
L(θ; xi
, xj ) = I(yi = yj ) d(xi
, xj )
2 + I(yi 6= yj ) [m − d(xi
, xj )]2
+ (16.10)
where [z]+ = max(0, z) is the hinge loss and m > 0 is a margin parameter. Intuitively, we want to
force positive pairs (with the same label) to be close, and negative pairs (with different labels) to be
further apart than some minimal safety margin. We minimize this loss over all pairs of data. Naively
this takes O(N2
) time; see Section 16.2.5 for some speedups.
Note that we use the same feature extractor f(·; θ) for both inputs, xi and xj . when computing
the distance, as illustrated in Figure 16.5a. The resulting network is therefore called a Siamese
network (named after Siamese twins).
16.2.4.2 Triplet loss
One disadvantage of pairwise losses is that the optimization of the positive pairs is independent of
the negative pairs, which can make their magnitudes incomparable. A solution to this is to use the
triplet loss [SKP15]. This is defined as follows. For each example i (known as an anchor), we
find a similar (positive) example x
+
i
and a dissimilar (negative) example x
−
i
. We then minimize the
following loss, averaged overall all triples:
L(θ; xi
, x
+
i
, x
−
i
) = [dθ(xi
, x
+
i
)
2 − dθ(xi
, x
−
i
)
2 + m]+ (16.11)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license550 Chapter 16. Exemplar-based Methods
Intuitively this says we want the distance from the anchor to the positive to be less (by some safety
margin m) than the distance from the anchor to the negative. We can compute the triplet loss using
a triplet network as shown in Figure 16.5b.
Naively minimizing triplet loss takes O(N3
) time. In practice we compute the loss on a minibatch
(chosen so that there is at least one similar and one dissimilar example for the anchor point, often
taken to be the first entry in the minibatch). Nevertheless the method can be slow. We discuss some
speedups in Section 16.2.5.
16.2.4.3 N-pairs loss
One problem with the triplet loss is that each anchor is only compared to one negative example at a
time. This might not provide a strong enough learning signal. One solution to this is to create a
multi-class classification problem in which we create a set of N − 1 negatives and 1 positive for every
anchor. This is called the N-pairs loss [Soh16]. More precisely, we define the following loss for each
set:
L(θ; xi
, x
+
j
, {x
−
k
}
N−1
k=1 ) = − log 
1 +
N
X−1
k=1
exp(eˆθ(xi)
Teˆθ(x
−
k
) − eˆθ(xi)
Teˆθ(x
+
j
))!
(16.12)
= − log
exp(eˆθ(xi)
Teˆθ(x
+
j
))
exp(eˆθ(xi)
Teˆθ(x
+
j
)) + PN−1
k=1 exp(eˆθ(xi)
Teˆθ(x
−
k
))
(16.13)
Note that the N-pairs loss is the same as the InfoNCE loss used in the CPC paper [OLV18]. In
[Che+20a], they propose a version where they scale the similarities by a temperature term; they call
this the NT-Xent (normalized temperature-scaled cross-entropy) loss. We can view the temperature
parameter as scaling the radius of the hypersphere on which the data lives.
When N = 2, the loss reduces to the logistic loss
L(θ; x, x
+, x
−) = log ￾
1 + exp(eˆθ(x)
Teˆθ(x
−) − eˆθ(x)
Teˆθ(x
+))
(16.14)
Compare this to the margin loss used by triplet learning (when m = 1):
L(θ; x, x
+, x
−) = max ￾
0, eˆ(x)
Teˆ(x
−) − eˆ(x)
Teˆ(x
+) + 1
(16.15)
See Figure 4.2 for a comparison of these two functions.
16.2.5 Speeding up ranking loss optimization
The main disadvantage of ranking loss is the O(N2
) or O(N3
) cost of computing the loss function,
due to the need to compare all pairs or triples of examples. In this section, we discuss various speedup
tricks.
16.2.5.1 Mining techniques
A key insight is that we don’t need to consider all negative examples for each anchor, since most
will be uniformative (i.e., will incur zero loss). Instead we can focus attention on negative examples
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2016.2. Learning distance metrics 551
a
n1
p
n2
n3 Easy negative: d(a,p) + m < d(a,n3)
Hard negative: d(a,n1) < d(a,p)
Semi-hard negative: d(a,p) < d(a,n2) < d(a,p) + m
Margin m
(a) (b)
Figure 16.6: Speeding up triplet loss minimization. (a) Illustration of hard vs easy negatives. Here a is the
anchor point, p is a positive point, and ni are negative points. Adapted from Figure 4 of [KB19]. (b) Standard
triplet loss would take 8 × 3 × 4 = 96 calculations, whereas using a proxy loss (with one proxy per class) takes
8 × 2 = 16 calculations. From Figure 1 of [Do+19]. Used with kind permission of Gustavo Cerneiro.
which are closer to the anchor than its nearest positive example. These are called hard negatives,
and are particularly useful for speeding up triplet loss.
More precisely, if a is an anchor and p is its nearest positive example, we say that n is a hard
negative (for a) if d(xa, xn) < d(xa, xp) and yn 6= ya. Sometimes an anchor may not have any hard
negatives. We can therefore increase the pool of candidates by considering semi-hard negatives,
for which
d(xa, xp) < d(xa, xn) < d(xa, xp) + m (16.16)
where m > 0 is a margin parameter. See Figure 16.6a for an illustration. This is the technique used
by Google’s FaceNet model [SKP15], which learns an embedding function for faces, so it can cluster
similar looking faces together, to which the user can attach a name.
In practice, the hard negatives are usually chosen from within the minibatch. This therefore
requires large batch sizes to ensure sufficient diversity. Alternatively, we can have a separate process
that continually updates the set of candidate hard negatives, as the distance measure evolves during
training.
16.2.5.2 Proxy methods
Triplet loss minimization is expensive even with hard negative mining (Section 16.2.5.1). Ideally we
can find a method that is O(N) time, just like classification loss.
One such method, proposed in [MA+17], measures the distance between each anchor and a set
of P proxies that represent each class, rather than directly measuring distance between examples.
These proxies need to be updated online as the distance metric evolves during learning. The overall
procedure takes O(NP2
) time, where P ∼ C.
More recently, [Qia+19] proposed to represent each class with multiple prototypes, while still
achieving linear time complexity, using a soft triple loss.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license552 Chapter 16. Exemplar-based Methods
16.2.5.3 Optimizing an upper bound
[Do+19] proposed a simple and fast method for optimizing the triplet loss. The key idea is to define
one fixed proxy or centroid per class, and then to use distance to the proxy as an upper bound on
the triplet loss.
More precisely, consider a simplified form of the triplet loss, without the margin term:
`t(xi
, xj , xk) = ||eˆi − eˆj || − ||eˆi − eˆk|| (16.17)
where eˆi = eˆθ(xi), etc. Using the triangle inequality we have
||eˆi − eˆj || ≤ ||eˆi − cyi
|| + ||eˆj − cyi
|| (16.18)
||eˆi − eˆk|| ≥ ||eˆi − cyk
|| − ||eˆk − cyk
|| (16.19)
Hence
`t(xi
, xj , xk) ≤ `u(xi
, xj , xk) , ||eˆi − cyi
|| − ||eˆi − cyk
|| + ||eˆj − cyi
|| + ||eˆk − cyk
|| (16.20)
We can use this to derive a tractable upper bound on the triplet loss as follows:
Lt(D, S) = X
(i,j)∈S,(i,k)6∈S,i,j,k∈{1,...,N}
`t(xi
, xj , xk) ≤
X
(i,j)∈S,(i,k)6∈S,i,j,k∈{1,...,N}
`u(xi
, xj , xk)
(16.21)
= C
0X
N
i=1

||xi − cyi
|| − 1
3(C − 1)
X
C
m=1,m6=yi
||xi − cm||

 , Lu(D, S) (16.22)
where C
0 = 3(C − 1)( N
C − 1) N
C
is a constant. It is clear that Lu can be computed in O(NC) time.
See Figure 16.6b for an illustration.
In [Do+19], they show that 0 ≤ Lt − Lu ≤
N3
C2 K, where K is some constant that depends on the
spread of the centroids. To ensure the bound is tight, the centroids should be as far from each other
as possible, and the distances between them should be as similar as possible. An easy way to ensure
is to define the cm vectors to be one-hot vectors, one per class. These vectors already have unit
norm, and are orthogonal to each other. The distance between each pair of centroids is √
2, which
ensures the upper bound is fairly tight.
The downside of this approach is that it assumes the embedding layer is L = C dimensional. There
are two solutions to this. First, after training, we can add a linear projection layer to map from C
to L 6= C, or we can take the second-to-last layer of the embedding network. The second approach
is to sample a large number of points on the L-dimensional unit hyper-sphere (which we can do
by sampling from the standard normal, and then normalizing [Mar72]), and then running K-means
clustering (Section 21.3) with K = C. In the experiments reported in [Do+19], these two approaches
give similar results.
Interestingly, in [Rot+20], they show that increasing πintra/πinter results in improved downstream
performance on various retrieval tasks, where
πintra =
1
Zintra
X
C
c=1
X
i6=j:yi=yj=c
d(xi
, xj ) (16.23)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202216.2. Learning distance metrics 553
average
norm
average
norm
learning with 
spherical 
embedding 
constraint
(SEC)
embeddings of three different classes
Figure 16.7: Adding spherical embedding constraint to a deep metric learning method. Used with kind
permission of Dingyi Zhang.
is the average intra-class distance, and
πinter =
1
Zinter
X
C
c=1
X
C
c
0=1
d(µc, µc
0 ) (16.24)
is the average inter-class distance, where µc =
1
Zc
P
i:yi=c
eˆi
is the mean embedding for examples
from class c. This suggests that we should not only keep the centroids far apart (in order to maximize
the numerator), but we should also prevent examples from getting too close to their centroids (in
order to minimize the denominator); this latter term is not captured in the method of [Do+19].
16.2.6 Other training tricks for DML
Besides the speedup tricks in Section 16.2.5, there are a lot of other details that are important to get
right in order to ensure good DML performance. Many of these details are discussed in [MBL20;
Rot+20]. Here we just briefly mention a few.
One important issue is how the minibatches are created. In classification problems (at least with
balanced classes), selecting examples at random from the training set is usually sufficient. However,
for DML, we need to ensure that each example has some other examples in the minibatch that are
similar to it, as well as some others that are dissimilar to it. One approach is to use hard mining
techniques (Section 16.2.5.1). Another idea is to use coreset methods applied to previously learned
embeddings to select a diverse minibatch at each step [Sin+20]. However, [Rot+20] show that the
following simple strategy also works well for creating each batch: pick B/n classes, and then pick Nc
examples randomly from each class, where B is the batch size, and Nc = 2 is a tuning parameter.
Another important issue is avoiding overfitting. Since most datasets used in the DML literature
are small, it is standard to use an image classifier, such as GoogLeNet (Section 14.3.3) or ResNet
(Section 14.3.4), which has been pre-trained on ImageNet, and then to fine-tune the model using the
DML loss. (See Section 19.2 for more details on this kind of transfer learning.) In addition, it is
standard to use data augmentation (see Section 19.1). (Indeed, with some self-supervised learning
methods, data aug is the only way to create similar pairs.)
In [ZLZ20], they propose to add a spherical embedding constraint (SEC), which is an additional
batchwise regularization term, which encourages all the examples to have the same norm. That is,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license554 Chapter 16. Exemplar-based Methods
the regularizer is just the empirical variance of the norms of the (unnormalized) embeddings in that
batch. See Figure 16.7 for an illustration. This regularizer can be added to any of the existing DML
losses to modestly improve training speed and stability, as well as final performance, analogously to
how batchnorm (Section 14.2.4.1) is used.
16.3 Kernel density estimation (KDE)
In this section, we consider a form of non-parametric density estimation known as kernel density
estimation or KDE. This is a form of generative model, since it defines a probability distribution
p(x) that can be evaluated pointwise, and which can be sampled from to generate new data.
16.3.1 Density kernels
Before explaining KDE, we must define what we mean by a “kernel”. This term has several different
meanings in machine learning and statistics.1
In this section, we use a specific kind of kernel which
we refer to as a density kernel. This is a function K : R → R+ such that R
K(x)dx = 1 and
K(−x) = K(x). This latter symmetry property implies the R
xK(x)dx = 0, and hence
Z
xK(x − xn)dx = xn (16.25)
A simple example of such a kernel is the boxcar kernel, which is the uniform distribution within
the unit interval around the origin:
K(x) , 0.5I(|x| ≤ 1) (16.26)
Another example is the Gaussian kernel:
K(x) = 1
(2π)
1
2
e
−x
2/2
(16.27)
We can control the width of the kernel by introducing a bandwidth parameter h:
Kh(x) ,
1
h
K(
x
h
) (16.28)
We can generalize to vector valued inputs by defining a radial basis function or RBF kernel:
Kh(x) ∝ Kh(||x||) (16.29)
In the case of the Gaussian kernel, this becomes
Kh(x) = 1
hD(2π)D/2
Y
D
d=1
exp(−
1
2h
2
x
2
d
) (16.30)
Although Gaussian kernels are popular, they have unbounded support. Some alternative kernels,
which have compact support (which can be computationally faster), are listed in Table 16.1. See
Figure 16.8 for a plot of these kernel functions.
1. For a good blog post on this, see https://francisbach.com/cursed-kernels/.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202216.3. Kernel density estimation (KDE) 555
−1.5 −1 −0.5 0 0.5 1 1.5
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
Boxcar
Epanechnikov
Tricube
Gaussian
Figure 16.8: A comparison of some popular normalized kernels. Generated by code at fig￾ures.probml.ai/book1/16.8.
Name Definition Compact Smooth Boundaries
Gaussian K(x) = (2π)
− 1
2 e
−x
2/2 0 1 1
Boxcar K(x) = 1
2
I(|x| ≤ 1) 1 0 0
Epanechnikov kernel K(x) = 3
4
(1 − x
2
)I(|x| ≤ 1) 1 1 0
Tri-cube kernel K(x) = 70
81 (1 − |x|
3
)
3
I(|x| ≤ 1) 1 1 1
Table 16.1: List of some popular normalized kernels in 1d. Compact=1 means the function is non-zero
for a finite range of inputs. Smooth=1 means the function is differentiable over the range of its support.
Boundaries=1 means the function is also differentiable at the boundaries of its support.
16.3.2 Parzen window density estimator
To explain how to use kernels to define a nonparametric density estimate, recall the form of the
Gaussian mixture model from Section 3.5.1. If we assume a fixed spherical Gaussian covariance and
uniform mixture weights, we get
p(x|θ) = 1
K
X
K
k=1
N (x|µk, σ2
I) (16.31)
One problem with this model is that it requires specifying the number K of clusters, as well as their
locations µk. An alternative to estimating these parameters is to allocate one cluster center per data
point. In this case, the model becomes
p(x|θ) = 1
N
X
N
n=1
N (x|xn, σ2
I) (16.32)
We can generalize Equation (16.32) by writing
p(x|D) = 1
N
X
N
n=1
Kh (x − xn) (16.33)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license556 Chapter 16. Exemplar-based Methods
−5 0 5 10
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
unif, h=1.000
(a)
−5 0 5 10
0
0.02
0.04
0.06
0.08
0.1
0.12
0.14
unif, h=2.000
(b)
−5 0 5 10
0
0.02
0.04
0.06
0.08
0.1
0.12
0.14
0.16
gauss, h=1.000
(c)
−5 0 5 10
0
0.01
0.02
0.03
0.04
0.05
0.06
gauss, h=2.000
(d)
Figure 16.9: A nonparametric (Parzen) density estimator in 1d estimated from 6 data points, denoted by x.
Top row: uniform kernel. Bottom row: Gaussian kernel. Left column: bandwidth parameter h = 1. Right
column: bandwidth parameter h = 2. Adapted from http: // en. wikipedia. org/ wiki/ Kernel_ density_
estimation . Generated by code at figures.probml.ai/book1/16.9.
where Kh is a density kernel. This is called a Parzen window density estimator, or kernel
density estimator (KDE).
The advantage over a parametric model is that no model fitting is required (except for choosing
h, discussed in Section 16.3.3), and there is no need to pick the number of cluster centers. The
disadvantage is that the model takes a lot of memory (you need to store all the data) and a lot of
time to evaluate.
Figure 16.9 illustrates KDE in 1d for two kinds of kernel. On the top, we use a boxcar kernel; the
resulting model just counts how many data points land within an interval of size h around each xn
to get a piecewise constant density. On the bottom, we use a Gaussian kernel, which results in a
smoother density.
16.3.3 How to choose the bandwidth parameter
We see from Figure 16.9 that the bandwidth parameter h has a large effect on the learned distribution.
We can view this as controlling the complexity of the model.
In the case of 1d data, where the “true” data generating distribution is assumed to be a Gaussian,
one can show [BA97a] that the optimal bandwidth for a Gaussian kernel (from the point of view of
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202216.3. Kernel density estimation (KDE) 557
minimizing frequentist risk) is given by h = σ
￾
4
3N
1/5
. We can compute a robust approximation to the
standard deviation by first computing the median absolute deviation, median(|x − median(x)|),
and then using σˆ = 1.4826 MAD. If we have D dimensions, we can estimate hd separately for each
dimension, and then set h = (QD
d=1 hd)
1/D.
16.3.4 From KDE to KNN classification
In Section 16.1, we discussed the K nearest neighbor classifier as a heuristic approach to classification.
Interestingly, we can derive it as a generative classifier in which the class conditional densities
p(x|y = c) are modeled using KDE. Rather than using a fixed bandwidth and counting how many
data points fall within the hyper-cube centered on a datapoint, we will allow the bandwidth or
volume to be different for each data point. Specifically, we will “grow” a volume around x until we
encounter K data points, regardless of their class label. This is called a balloon kernel density
estimator [TS92]. Let the resulting volume have size V (x) (this was previously h
D), and let there
be Nc(x) examples from class c in this volume. Then we can estimate the class conditional density
as follows:
p(x|y = c, D) = Nc(x)
NcV (x)
(16.34)
where Nc is the total number of examples in class c in the whole data set. If we take the class prior
to be p(y = c) = Nc/N, then the class posterior is given by
p(y = c|x, D) =
Nc(x)
NcV (x)
Nc
N
P
c
0
Nc0 (x)
Nc0V (x)
Nc0
N
=
Nc(x)
P
c
0 Nc
0 (x)
=
Nc(x)
K
=
1
K
X
n∈NK(x,D)
I(yn = c) (16.35)
where we used the fact that P
c Nc(x) = K, since we choose a total of K points (regardless of class)
around every point. This matches 16.1.
16.3.5 Kernel regression
Just as KDE can be used for generative classifiers (see Section 16.1), it can also be used for generative
models for regression, as we discuss below.
16.3.5.1 Nadaraya-Watson estimator for the mean
In regression, our goal is to compute the conditional expectation
E [y|x, D] = Z
y p(y|x, D)dy =
R
y p(x, y|D)dy
R
p(x, y|D)dy
(16.36)
If we use an MVN for p(y, x|D), we derive a result which is equivalent to linear regression, as we
showed in Section 11.2.3.5. However, the assumption that p(y, x|D) is Gaussian is rather limiting.
We can use KDE to more accurately approximate the joint density p(x, y|D) as follows:
p(y, x|D) ≈
1
N
X
N
n=1
Kh(x − xn)Kh(y − yn) (16.37)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens558 Chapter 16. Exemplar-based Methods
−1.5 −1.0 −0.5 0.0 0.5 1.0 1.5
−0.4
−0.2
0.0
0.2
0.4
0.6
0.8
1.0 true
data
estimate
Figure 16.10: An example of kernel regression in 1d using a Gaussian kernel. Generated by code at
figures.probml.ai/book1/16.10.
Hence
E [y|x, D] =
1
N
PN
n=1 Kh(x − xn)
R
yKh(y − yn)dy
1
N
PN
n=1 Kh(x − xn)
R
Kh(y − yn)dy
(16.38)
We can simplify the numerator using the fact that R
yKh(y−yn)dy = yn (from Equation (16.25)). We
can simplify the denominator using the fact that density kernels integrate to one, i.e., R
Kh(y−yn)dy =
1. Thus
E [y|x, D] =
PN
n=1 Kh(x − xn)yn PN
n=1 Kh(x − xn)
=
X
N
n=1
ynwn(x) (16.39)
wn(x) ,
Kh(x − xn)
PN
n0=1 Kh(x − xn0 )
(16.40)
We see that the prediction is just a weighted sum of the outputs at the training points, where the
weights depend on how similar x is to the stored training points. This method is called kernel
regression, kernel smoothing, or the Nadaraya-Watson (N-W) model. See Figure 16.10 for an
example, where we use a Gaussian kernel.
In Section 17.2.3, we discuss the connection between kernel regression and Gaussian process
regression.
16.3.5.2 Estimator for the variance
Sometimes it is useful to compute the predictive variance, as well as the predictive mean. We can do
this by noting that
V [y|x, D] = E

y
2
|x, D

− µ(x)
2
(16.41)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202216.3. Kernel density estimation (KDE) 559
where µ(x) = E [y|x, D] is the N-W estimate. If we use a Gaussian kernel with variance σ
2
, we can
compute E

y
2
|x, D

as follows:
E

y
2
|x, D

=
PN
n=1 Kh(x − xn)
R
y
2Kh(y − yn)dy
PN
n=1 Kh(x − xn)
R
Kh(y − yn)dy
(16.42)
=
PN
n=1 Kh(x − xn)(σ
2 + y
2
n
)
PN
n=1 Kh(x − xn)
(16.43)
where we used the fact that
Z
y
2N (y|yn, σ2
)dy = σ
2 + y
2
n
(16.44)
Combining Equation (16.43) with Equation (16.41) gives
V [y|x, D] = σ
2 +
X
N
n=1
wn(x)y
2
n − µ(x)
2
(16.45)
This matches Eqn. 8 of [BA10] (modulo the initial σ
2
term).
16.3.5.3 Locally weighted regression
We can drop the normalization term from Equation (16.39) to get
µ(x) = X
N
n=1
ynKh(x − xn) (16.46)
This is just a weighted sum of the observed responses, where the weights depend on how similar the
test input x is to the training points xn.
Rather than just interpolating the stored responses yn, we can fit a locally linear model around
each training point:
µ(x) = min
β
X
N
n=1
[yn − β
Tφ(xn)]2 Kh(x − xn) (16.47)
where φ(x) = [1, x]. This is called locally linear regression (LRR) or locally-weighted scat￾terplot smoothing, and is commonly known by the acronym LOWESS or LOESS [CD88]. This
is often used when annotating scatter plots with local trend lines.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license17 Kernel Methods *
In this chapter, we consider nonparametric methods for regression and classification. Such
methods do not assume a fixed parametric form for the prediction function, but instead try to
estimate the function itself (rather than the parameters) directly from data. The key idea is that we
observe the function value at a fixed set of N points, namely yn = f(xn) for n = 1 : N, where f
is the unknown function, so to predict the function value at a new point, say x∗, we just have to
compare how “similar” x∗ is to each of the N training points, {xn}, and then we can predict that
f(x∗) is some weighted combination of the {f(xn)} values. Thus we may need to “remember” the
entire training set, D = {(xn, yn)}, in order to make predictions at test time — we cannot “compress”
D into a fixed-sized parameter vector.
The weights that are used for prediction are determined by the similarity between x∗ and each xn,
which is computed using a special kind of function known as kernel function, K(xn, x∗) ≥ 0, which
we explain in Section 17.1. This approach is similar to RBF networks (Section 13.6.1), except we use
the datapoints xn themselves as the “anchors”, rather than learning centroid µn.
In Section 17.2, we discuss an approach called Gaussian processes, which allows us to use the kernel
to define a prior over functions, which we can update given data to get a posterior over functions.
Alternatively we can use the same kernel with a method called Support Vector Machines to compute
a MAP estimate of the function, as we explain in Section 17.3.
17.1 Mercer kernels
The key to nonparametric methods is that we need a way to encode prior knowledge about the
similarity of two input vectors. If we know that xi
is similar to xj , then we can encourage the model
to make the predicted output at both locations (i.e., f(xi) and f(xj )) to be similar.
To define similarity, we introduce the notion of a kernel function. The word “kernel” has many
different meanings in mathematics, including density kernels (Section 16.3.1), transition kernels of a
Markov chain (Section 3.6.1.2), and convolutional kernels (Section 14.1). Here we consider a Mercer
kernel, also called a positive definite kernel. This is any symmetric function K : X × X → R
+
such that
X
N
i=1
X
N
j=1
K(xi
, xj )cicj ≥ 0 (17.1)
for any set of N (unique) points xi ∈ X , and any choice of numbers ci ∈ R. (We assume K(xi
, xj ) > 0,
so that we can only achieve equality in the above equation if ci = 0 for all i.)562 Chapter 17. Kernel Methods *
Another way to understand this condition is the following. Given a set of N datapoints, let us
define the Gram matrix as the following N × N similarity matrix:
K =


K(x1, x1) · · · K(x1, xN )
.
.
.
K(xN , x1) · · · K(xN , xN )

 (17.2)
We say that K is a Mercer kernel iff the Gram matrix is positive definite for any set of (distinct)
inputs {xi}
N
i=1.
The most widely used kernel for real-valued inputs is the squared exponential kernel (SE
kernel), also called the exponentiated quadratic, Gaussian kernel RBF kernel. It is defined
by
K(x, x
0
) = exp 
−
||x − x
0
||2
2`
2

(17.3)
Here ` corresponds to the length scale of the kernel, i.e., the distance over which we expect differences
to matter. This is known as the bandwidth parameter. The RBF kernel measures similarity between
two vectors in R
D using (scaled) Euclidean distance. In Section 17.1.2, we will discuss several other
kinds of kernel.
In Section 17.2, we show how to use kernels to define priors and posteriors over functions. The
basic idea is this: if K(x, x
0
) is large, meaning the inputs are similar, then we expect the output of
the function to be similar as well, so f(x) ≈ f(x
0
). More precisely, information we learn about f(x)
will help us predict f(x
0
) for all x
0 which are correlated with x, and hence for which K(x, x
0
) is large.
In Section 17.3, we show how to use kernels to generalize from Euclidean distance to a more general
notion of distance, so that we can use geometric methods such as linear discriminant analysis in an
implicit feature space instead of input space.
17.1.1 Mercer’s theorem
Recall from Section 7.4 that any positive definite matrix K can be represented using an eigendecom￾position of the form K = UTΛU, where Λ is a diagonal matrix of eigenvalues λi > 0, and U is a
matrix containing the eigenvectors. Now consider element (i, j) of K:
kij = (Λ
1
2 U:i)
T
(Λ
1
2 U:j ) (17.4)
where U:i
is the i’th column of U. If we define φ(xi) = Λ
1
2 U:i
, then we can write
kij = φ(xi)
Tφ(xj ) = X
m
φm(xi)φm(xj ) (17.5)
Thus we see that the entries in the kernel matrix can be computed by performing an inner product
of some feature vectors that are implicitly defined by the eigenvectors of the kernel matrix. This
idea can be generalized to apply to kernel functions, not just kernel matrices; this result is known as
Mercer’s theorem.
For example, consider the quadratic kernel K(x, x
0
) = hx, x
0
i
2
. In 2d, we have
K(x, x
0
) = (x1x
0
1 + x2x
0
2
)
2 = x
2
1
(x
0
1
)
2 + 2x1x2x
0
1x
0
2 + x
2
2
(x
0
2
)
2
(17.6)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.1. Mercer kernels 563
input x1
−3
−2
−1
0
1
2
3
input x2
−3
−2
−1
0
1
2
3
output y
−1.5
−1.0
−0.5
0.0
0.5
1.0
1.5
(a)
input x1
−3
−2
−1
0
1
2
3
input x2
−3
−2
−1
0
1
2
3
output y
−3
−2
−1
0
1
2
(b)
Figure 17.1: Function samples from a GP with an ARD kernel. (a) `1 = `2 = 1. Both dimensions contribute
to the response. (b) `1 = 1, `2 = 5. The second dimension is essentially ignored. Adapted from Figure 5.1 of
[RW06]. Generated by code at figures.probml.ai/book1/17.1.
We can write this as K(x, x
0
) = φ(x)
Tφ(x) if we define φ(x1, x2) = [x
2
1
,
√
2x1x2, x2
2
] ∈ R
3
. So we
embed the 2d inputs x into a 3d feature space φ(x).
Now consider the RBF kernel. In this case, the corresponding feature representation is infinite
dimensional (see Section 17.2.9.3 for details). However, by working with kernel functions, we can
avoid having to deal with infinite dimensional vectors.
17.1.2 Some popular Mercer kernels
In the sections below, we describe some popular Mercer kernels. More details can be found at [Wil14]
and https://www.cs.toronto.edu/~duvenaud/cookbook/.
17.1.2.1 Stationary kernels for real-valued vectors
For real-valued inputs, X = R
D, it is common to use stationary kernels, which are functions of
the form K(x, x
0
) = K(||x − x
0
||); thus the value only depends on the elementwise difference between
the inputs. The RBF kernel is a stationary kernel. We give some other examples below.
ARD kernel
We can generalize the RBF kernel by replacing Euclidean distance with Mahalanobis distance, as
follows:
K(r) = σ
2
exp 
−
1
2
r
TΣ
−1
r

(17.7)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license564 Chapter 17. Kernel Methods *
matern_kernel_5
(a)
matern_kernel_1
(b)
Figure 17.2: Functions sampled from a GP with a Matern kernel. (a) ν = 5/2. (b) ν = 1/2. Generated by
code at figures.probml.ai/book1/17.2.
where r = x − x
0
. If Σ is diagonal, this can be written as
K(r; `, σ2
) = σ
2
exp 
−
1
2
X
D
d=1
1
`
2
d
r
2
d
!
=
Y
D
d=1
K(rd; `d, σ2/d) (17.8)
where
K(r; `, τ 2
) = τ
2
exp 
−
1
2
1
`
2
r
2

(17.9)
We can interpret σ
2 as the overall variance, and `d as defining the characteristic length scale of
dimension d. If d is an irrelevant input dimension, we can set `d = ∞, so the corresponding dimension
will be ignored. This is known as automatic relevancy determination or ARD (Section 11.7.7).
Hence the corresponding kernel is called the ARD kernel. See Figure 17.1 for an illustration of
some 2d functions sampled from a GP using this prior.
Matern kernels
The SE kernel gives rise to functions that are infinitely differentiable, and therefore are very smooth.
For many applications, it is better to use the Matern kernel, which gives rise to “rougher” functions,
which can better model local “wiggles” without having to make the overall length scale very small.
The Matern kernel has the following form:
K(r; ν, `) = 2
1−ν
Γ(ν)
 √
2νr
`
!ν
Kν
 √
2νr
`
!
(17.10)
where Kν is a modified Bessel function and ` is the length scale. Functions sampled from this GP
are k-times differentiable iff ν > k. As ν → ∞, this approaches the SE kernel.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.1. Mercer kernels 565
per_kernel
(a) Periodic kernel.
cos_kernel
(b) Cosine kernel.
Figure 17.3: Functions sampled from a GP using various stationary periodic kernels. Generated by code at
figures.probml.ai/book1/17.3.
For values ν ∈ { 1
2
,
3
2
,
5
2
}, the function simplifies as follows:
K(r;
1
2
, `) = exp(−
r
`
) (17.11)
K(r;
3
2
, `) = 
1 +
√
3r
`
!
exp 
−
√
3r
`
!
(17.12)
K(r;
5
2
, `) = 
1 +
√
5r
`
+
5r
2
3`
2
!
exp 
−
√
5r
`
!
(17.13)
The value ν =
1
2
corresponds to the Ornstein-Uhlenbeck process, which describes the velocity
of a particle undergoing Brownian motion. The corresponding function is continuous but not
differentiable, and hence is very “jagged”. See Figure 17.2b for an illustration.
Periodic kernels
The periodic kernel captures repeating structure, and has the form
Kper(r; `, p) = exp 
−
2
`
2
sin2
(π
r
p
)

(17.14)
where p is the period. See Figure 17.3a for an illustration.
A related kernel is the cosine kernel:
K(r; p) = cos 
2π
r
p

(17.15)
See Figure 17.3b for an illustration.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license566 Chapter 17. Kernel Methods *
17.1.2.2 Making new kernels from old
Given two valid kernels K1(x, x
0
) and K2(x, x
0
), we can create a new kernel using any of the following
methods:
K(x, x
0
) = cK1(x, x
0
), for any constant c > 0 (17.16)
K(x, x
0
) = f(x)K1(x, x
0
)f(x
0
), for any function f (17.17)
K(x, x
0
) = q(K1(x, x
0
)) for any function polynomial q with nonneg. coef. (17.18)
K(x, x
0
) = exp(K1(x, x
0
)) (17.19)
K(x, x
0
) = x
TAx
0
, for any psd matrix A (17.20)
For example, suppose we start with the linear kernel K(x, x
0
) = x
Tx
0
. We know this is a valid
Mercer kernel, since the corresponding Gram matrix is just the (scaled) covariance matrix of the
data. From the above rules, we can see that the polynomial kernel K(x, x
0
) = (x
Tx
0
)M is a valid
Mercer kernel. This contains all monomials of order M. For example, if M = 2 and the inputs are
2d, we have
(x
Tx
0
)
2 = (x1x
0
1 + x2x
0
2
)
2 = (x1x
0
1
)
2 + (x2x2)
2 + (x1x
0
1
)(x2x
0
2
) (17.21)
We can generalize this to contain all terms up to degree M by using the kernel K(x, x
0
) = (x
Tx
0+c)M.
For example, if M = 2 and the inputs are 2d, we have
(x
Tx
0 + 1)2 = (x1x
0
1
)
2 + (x1x
0
1
)(x2x
0
2
) + (x1x
0
1
)
+ (x2x2)(x1x
0
1
) + (x2x
0
2
)
2 + (x2x
0
2
)
+ (x1x
0
1
) + (x2x
0
2
) + 1 (17.22)
We can also use the above rules to establish that the Gaussian kernel is a valid kernel. To see this,
note that
||x − x
0
||2 = x
Tx + (x
0
)
Tx
0 − 2x
Tx
0
(17.23)
and hence
K(x, x
0
) = exp(−||x − x
0
||2
/2σ
2
) = exp(−x
Tx/2σ
2
) exp(x
Tx
0
/σ2
) exp(−(x
0
)
Tx
0
/2σ
2
) (17.24)
is a valid kernel.
17.1.2.3 Combining kernels by addition and multiplication
We can also combine kernels using addition or multiplication:
K(x, x
0
) = K1(x, x
0
) + K2(x, x
0
) (17.25)
K(x, x
0
) = K1(x, x
0
) × K2(x, x
0
) (17.26)
Multiplying two positive-definite kernels together always results in another positive definite kernel.
This is a way to get a conjunction of the individual properties of each kernel, as illustrated in
Figure 17.4.
In addition, adding two positive-definite kernels together always results in another positive definite
kernel. This is a way to get a disjunction of the individual properties of each kernel, as illustrated in
Figure 17.5.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.1. Mercer kernels 567
Figure 17.4: Examples of 1d structures obtained by multiplying elementary kernels. Top row shows K(x, x0 = 1).
Bottom row shows some functions sampled from GP(f|0, K). From Figure 2.2 of [Duv14]. Used with kind
permission of David Duvenaud.
Figure 17.5: Examples of 1d structures obtained by adding elementary kernels. Here SE(short) and SE(long)
are two SE kernels with different length scales. From Figure 2.4 of [Duv14]. Used with kind permission of
David Duvenaud.
17.1.2.4 Kernels for structured inputs
Kernels are particularly useful when the inputs are structured objects, such as strings and graphs,
since it is often hard to “featurize” variable-sized inputs. For example, we can define a string kernel
which compares strings in terms of the number of n-grams they have in common [Lod+02; BC17].
We can also define kernels on graphs [KJM19]. For example, the random walk kernel conceptually
performs random walks on two graphs simultaneously, and then counts the number of paths that
were produced by both walks. This can be computed efficiently as discussed in [Vis+10]. For more
details on graph kernels, see [KJM19].
For a review of kernels on structured objects, see e.g., [Gär03].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license568 Chapter 17. Kernel Methods *
x1 x2 x!
f1 f2 f!
y1 y2 y!
Figure 17.6: A Gaussian process for 2 training points, x1 and x2, and 1 testing point, x∗, represented as
a graphical model representing p(y, fX|X) = N (fX|m(X), K(X)) Q
i
p(yi|fi). The hidden nodes fi = f(xi)
represent the value of the function at each of the data points. These hidden nodes are fully interconnected
by undirected edges, forming a Gaussian graphical model; the edge strengths represent the covariance terms
Σij = K(xi, xj ). If the test point x∗ is similar to the training points x1 and x2, then the value of the hidden
function f∗ will be similar to f1 and f2, and hence the predicted output y∗ will be similar to the training
values y1 and y2.
17.2 Gaussian processes
In this section, we discuss Gaussian processes, which is a way to define distributions over functions
of the form f : X → R, where X is any domain. The key assumption is that the function values at a set
of M > 0 inputs, f = [f(x1), . . . , f(xM)], is jointly Gaussian, with mean (µ = m(x1), . . . , m(xM))
and covariance Σij = K(xi
, xj ), where m is a mean function and K is a positive definite (Mercer)
kernel. Since we assume this holds for any M > 0, this includes the case where M = N + 1,
containing N training points xn and 1 test point x∗. Thus we can infer f(x∗) from knowledge of
f(x1), . . . , f(xn) by manipulating the joint Gaussian distribution p(f(x1), . . . , f(xN ), f(x∗)), as we
explain below. We can also extend this to work with the case where we observe noisy functions of
f(xn), such as in regression or classification problems.
17.2.1 Noise-free observations
Suppose we observe a training set D = {(xn, yn) : n = 1 : N}, where yn = f(xn) is the noise-free
observation of the function evaluated at xn. If we ask the GP to predict f(x) for a value of x that it
has already seen, we want the GP to return the answer f(x) with no uncertainty. In other words, it
should act as an interpolator of the training data.
Now we consider the case of predicting the outputs for new inputs that may not be in D. Specifically,
given a test set X∗ of size N∗ × D, we want to predict the function outputs f∗ = [f(x1), . . . , f(xN∗
)].
By definition of the GP, the joint distribution p(fX, f∗|X, X∗) has the following form

fX
f∗

∼ N µX
µ∗

,

KX,X KX,∗
KT
X,∗ K∗,∗
 (17.27)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.2. Gaussian processes 569
−4 −2 0 2 4
−1.0
−0.5
0.0
0.5
1.0
1.5
2.0
(a)
−4 −2 0 2 4
−2
−1
0
1
2
N=1
(b)
−4 −2 0 2 4
−3
−2
−1
0
1
2
N=2
(c)
−4 −2 0 2 4
−2.0
−1.5
−1.0
−0.5
0.0
0.5
1.0
1.5
2.0
N=4
(d)
Figure 17.7: (a) some functions sampled from a GP prior with squared exponential kernel. (b-d) : some samples
from a GP posterior, after conditioning on 1,2, and 4 noise-free observations. The shaded area represents
E [f(x)]±2std [f(x)]. Adapted from Figure 2.2 of [RW06]. Generated by code at figures.probml.ai/book1/17.7.
where µX = [m(x1), . . . , m(xN )], µ∗ = [m(x
∗
1
), . . . , m(x
∗
N∗
)], KX,X = K(X, X) is N × N, KX,∗ =
K(X, X∗) is N × N∗, and K∗,∗ = K(X∗, X∗) is N∗ × N∗. See Figure 17.6 for an illustration. By the
standard rules for conditioning Gaussians (Section 3.2.3), the posterior has the following form
p(f∗|X∗, D) = N (f∗|µ∗, Σ∗) (17.28)
µ∗ = m(X∗) + KT
X,∗K−1
X,X(fX − m(X)) (17.29)
Σ∗ = K∗,∗ − KT
X,∗K−1
X,XKX,∗ (17.30)
This process is illustrated in Figure 17.7. On the left we show some samples from the prior, p(f),
where we use an RBF kernel (Section 17.1) and a zero mean function. On the right, we show samples
from the posterior, p(f|D). We see that the model perfectly interpolates the training data, and that
the predictive uncertainty increases as we move further away from the observed data.
17.2.2 Noisy observations
Now let us consider the case where what we observe is a noisy version of the underlying function,
yn = f(xn) + n, where n ∼ N (0, σ2
y
). In this case, the model is not required to interpolate the data,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license570 Chapter 17. Kernel Methods *
but it must come “close” to the observed data. The covariance of the observed noisy responses is
Cov [yi
, yj ] = Cov [fi
, fj ] + Cov [i
, j ] = K(xi
, xj ) + σ
2
y
δij (17.31)
where δij = I(i = j). In other words
Cov [y|X] = KX,X + σ
2
y
IN , Kσ (17.32)
The joint density of the observed data and the latent, noise-free function on the test points is given
by

y
f∗

∼ N µX
µ∗

,

Kσ KX,∗
KT
X,∗ K∗,∗
 (17.33)
Hence the posterior predictive density at a set of test points X∗ is
p(f∗|D, X∗) = N (f∗|µ∗|X, Σ∗|X) (17.34)
µ∗|X = µ∗ + KT
X,∗K−1
σ
(y − µX) (17.35)
Σ∗|X = K∗,∗ − KT
X,∗K−1
σ KX,∗ (17.36)
In the case of a single test input, this simplifies as follows
p(f∗|D, x∗) = N (f∗|m∗ + k
T
∗K−1
σ
(y − µX), k∗∗ − k
T
∗K−1
σ k∗) (17.37)
where k∗ = [K(x∗, x1), . . . , K(x∗, xN )] and k∗∗ = K(x∗, x∗). If the mean function is zero, we can
write the posterior mean as follows:
µ∗|X = k
T
∗
(K−1
σ y) , k
T
∗α =
X
N
n=1
K(x∗, xn)αn (17.38)
This is identical to the predictions from kernel ridge regression in Equation (17.108).
17.2.3 Comparison to kernel regression
In Section 16.3.5, we discussed kernel regression, which is a generative approach to regression in
which we approximate p(y, x) using kernel density estimation. In particular, Equation (16.39) gives
us
E [y|x, D] =
PN
n=1 Kh(x − xn)yn PN
n=1 Kh(x − xn)
=
X
N
n=1
ynwn(x) (17.39)
wn(x) ,
Kh(x − xn)
PN
n0=1 Kh(x − xn0 )
(17.40)
This is very similar to Equation (17.38). However, there are a few important differences. Firstly, in
a GP, we use a positive definite (Mercer) kernel instead of a density kernel; Mercer kernels can be
defined on structured objects, such as strings and graphs, which is harder to do for density kernels.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.2. Gaussian processes 571
Second, a GP is an interpolator (at least when σ
2 = 0), so E [y|xn, D] = yn. By contrast, kernel
regression is not an interpolator (although it can be made into one by iteratively fitting the residuals,
as in [KJ16]). Third, a GP is a Bayesian method, which means we can estimate hyperparameters
(of the kernel) by maximizing the marginal likelihood; by contrast, in kernel regression we must use
cross-validation to estimate the kernel parameters, such as the bandwidth. Fourth, computing the
weights wn for kernel regression takes O(N) time, where N = |D|, whereas computing the weights
αn for GP regression takes O(N3
) time (although there are approximation methods that can reduce
this to O(NM2
), as we discuss in Section 17.2.9).
17.2.4 Weight space vs function space
In this section, we show how Bayesian linear regression is a special case of a GP.
Consider the linear regression model y = f(x) + , where f(x) = wTφ(x) and  ∼ N (0, σ2
y
). If we
use a Gaussian prior p(w) = N (w|0, Σw), then the posterior is as follows (see Section 11.7.2 for the
derivation):
p(w|D) = N (w|
1
σ
2
y
A−1Φ
T y, A−1
) (17.41)
where Φ is the N × D design matrix, and
A = σ
−2
y Φ
TΦ + Σ
−1
w (17.42)
The posterior predictive distribution for f∗ = f(x∗) is therefore
p(f∗|D, x∗) = N (f∗|
1
σ
2
y
φ
T
∗A−1Φ
Ty, φ
T
∗A−1φ∗
) (17.43)
where φ∗ = φ(x∗). This views the problem of inference and prediction in weight space.
We now show that this is equivalent to the predictions made by a GP using a kernel of the form
K(x, x
0
) = φ(x)
TΣwφ(x
0
). To see this, let K = ΦΣwΦ
T
, k∗ = ΦΣwφ∗
, and k∗∗ = φ
T
∗Σwφ∗
. Using
this notation, and the matrix inversion lemma, we can rewrite Equation (17.43) as follows
p(f∗|D, x∗) = N (f∗|µ∗|X, Σ∗|X) (17.44)
µ∗|X = φ
T
∗ΣwΦ
T
(K + σ
2
y
I)
−1y = k
T
∗K−1
σ y (17.45)
Σ∗|X = φ
T
∗Σwφ∗ − φ
T
∗ΣwΦ
T
(K + σ
2
y
I)
−1ΦΣwφ∗ = k∗∗ − k
T
∗K−1
σ k∗ (17.46)
which matches the results in Equation (17.37), assuming m(x) = 0. (Non-zero mean can be captured
by adding a constant feature with value 1 to φ(x).)
Thus we can derive a GP from Bayesian linear regression. Note, however, that linear regression
assumes φ(x) is a finite length vector, whereas a GP allows us to work directly in terms of kernels,
which may correspond to infinite length feature vectors (see Section 17.1.1). That is, a GP works in
function space.
17.2.5 Numerical issues
In this section, we discuss computational and numerical issues which arise when implementing the
above equations. For notational simplicity, we assume the prior mean is zero, m(x) = 0.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license572 Chapter 17. Kernel Methods *
−10.0 −7.5 −5.0 −2.5 0.0 2.5 5.0 7.5 10.0
−2
0
2
4
6
(l, sigma_f, sigma_y)=1.0, 1.0, 0.1
Mean
Data
Confidence
(a)
−10.0 −7.5 −5.0 −2.5 0.0 2.5 5.0 7.5 10.0
−3
−2
−1
0
1
2
3
4
(l, sigma_f, sigma_y)=3.0, 1.16, 0.89
Mean
Data
Confidence
(b)
Figure 17.8: Some 1d GPs with SE kernels but different hyper-parameters fit to 20 noisy observations. The
hyper-parameters (`, σf , σy) are as follows: (a) (1,1,0.1) (b) (3.0, 1.16, 0.89). Adapted from Figure 2.5 of
[RW06]. Generated by code at figures.probml.ai/book1/17.8.
The posterior predictive mean is given by µ∗ = k
T
∗K−1
σ y. For reasons of numerical stability, it is
unwise to directly invert Kσ. A more robust alternative is to compute a Cholesky decomposition,
Kσ = LLT, which takes O(N3
) time. Then we compute α = L
T \ (L \ y), where we have used the
backslash operator to represent backsubstitution (Section 7.7.1). Given this, we can compute the
posterior mean for each test case in O(N) time using
µ∗ = k
T
∗K−1
σ y = k
T
∗L
−T
(L
−1y) = k
T
∗α (17.47)
We can compute the variance in O(N2
) time for each test case using
σ
2
∗ = k∗∗ − k
T
∗L
−TL
−1k∗ = k∗∗ − v
Tv (17.48)
where v = L \ k∗.
Finally, the log marginal likelihood (needed for kernel learning, Section 17.2.6) can be computed
using
log p(y|X) = −
1
2
y
Tα −
X
N
n=1
log Lnn −
N
2
log(2π) (17.49)
17.2.6 Estimating the kernel
Most kernels have some free parameters, which can have a large effect on the predictions from the
model. For example, suppose we are performing 1d regression using a GP with an RBF kernel of the
form
K(xp, xq) = σ
2
f
exp(−
1
2`
2
(xp − xq)
2
) (17.50)
Here ` is the horizontal scale over which the function changes, σ
2
f
controls the vertical scale of the
function. We assume observation noise with variance σ
2
y
.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.2. Gaussian processes 573
We sampled 20 observations from an MVN with a covariance given by Σ = K(xi
, xj ) for a grid of
points {xi}, and added observation noise of value σy. We then fit this data using a GP with the
same kernel, but with a range of hyperparmameters. Figure 17.8 illustrates the effects of changing
these parameters. In Figure 17.8(a), we use (`, σf , σy) = (1, 1, 0.1), and the result is a good fit.
In Figure 17.8(b), we reduce the length scale to ` = 0.3 (the other parameters were optimized by
maximum (marginal) likelihood, a technique we discuss below); now the function looks more “wiggly”.
Also, the uncertainty goes up faster, since the effective distance from the training points increases
more rapidly. In Figure 17.8(c), we increase the length scale to ` = 3; now the function looks
smoother.
17.2.6.1 Empirical Bayes
To estimate the kernel parameters θ (sometimes called hyperparameters), we could use exhaustive
search over a discrete grid of values, with validation loss as an objective, but this can be quite
slow. (This is the approach used by nonprobabilistic methods, such as SVMs (Section 17.3) to tune
kernels.) Here we consider an empirical Bayes approach (Section 4.6.5.3), which will allow us to use
gradient-based optimization methods, which are much faster. In particular, we will maximize the
marginal likelihood
p(y|X, θ) = Z
p(y|f, X)p(f|X, θ)df (17.51)
(The reason it is called the marginal likelihood, rather than just likelihood, is because we have
marginalized out the latent Gaussian vector f.)
For notational simplicity, we assume the mean function is 0. Since p(f|X) = N (f|0, K), and
p(y|f) = QN
n=1 N (yn|fn, σ2
y
), the marginal likelihood is given by
log p(y|X, θ) = log N (y|0, Kσ) = −
1
2
y
TK−1
σ y −
1
2
log |Kσ| − N
2
log(2π) (17.52)
where the dependence of Kσ = KX,X + σ
2
2
IN on θ is implicit. The first term is a data fit term, the
second term is a model complexity term, and the third term is just a constant. To understand the
tradeoff between the first two terms, consider a SE kernel in 1D, as we vary the length scale ` and
hold σ
2
y fixed. For short length scales, the fit will be good, so y
TK−1
σ y will be small. However, the
model complexity will be high: K will be almost diagonal, (as in Figure 13.22, top right), since most
points will not be considered “near” any others, so the log |Kσ| term will be large. For long length
scales, the fit will be poor but the model complexity will be low: K will be almost all 1’s, (as in
Figure 13.22, bottom right), so log |Kσ| will be small.
We now discuss how to maximize the marginal likelihood. One can show that
∂
∂θj
log p(y|X, θ) = 1
2
y
TK−1
σ
∂Kσ
∂θj
K−1
σ y −
1
2
tr(K−1
σ
∂Kσ
∂θj
) (17.53)
=
1
2
tr 
(ααT − K−1
σ
)
∂Kσ
∂θj

(17.54)
where α = K−1
σ y. It takes O(N3
) time to compute K−1
σ
, and then O(N2
) time per hyper-parameter
to compute the gradient.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license574 Chapter 17. Kernel Methods *
10
0 10
1
characteristic length scale
10
−1
10
0
noise standard deviation
(a)
−6 −4 −2 0 2 4 6
−2.0
−1.5
−1.0
−0.5
0.0
0.5
1.0
1.5
2.0
2.5
(b)
−6 −4 −2 0 2 4 6
−2.0
−1.5
−1.0
−0.5
0.0
0.5
1.0
1.5
2.0
2.5
(c)
Figure 17.9: Illustration of local minima in the marginal likelihood surface. (a) We plot the log marginal
likelihood vs kernel length scale ` and observation noise σy, for fixed signal level σf = 1, using the 7
data points shown in panels b and c. (b) The function corresponding to the lower left local minimum,
(`, σy) ≈ (1, 0.2). This is quite “wiggly” and has low noise. (c) The function corresponding to the top right
local minimum, (`, σy) ≈ (10, 0.8). This is quite smooth and has high noise. The data was generated using
(`, σf , σy) = (1, 1, 0.1). Adapted from Figure 5.5 of [RW06]. Generated by code at figures.probml.ai/book1/17.9.
The form of ∂Kσ
∂θj
depends on the form of the kernel, and which parameter we are taking derivatives
with respect to. Often we have constraints on the hyper-parameters, such as σ
2
y ≥ 0. In this case, we
can define θ = log(σ
2
y
), and then use the chain rule.
Given an expression for the log marginal likelihood and its derivative, we can estimate the kernel
parameters using any standard gradient-based optimizer. However, since the objective is not convex,
local minima can be a problem, as we illustrate below, so we may need to use multiple restarts.
As an example, consider the RBF in Equation (17.50) with σ
2
f = 1. In Figure 17.9(a), we plot
log p(y|X, `, σ2
y
) (where X and y are the 7 data points shown in panels b and c) as we vary ` and
σ
2
y
. The two local optima are indicated by +. The bottom left optimum corresponds to a low-noise,
short-length scale solution (shown in panel b). The top right optimum corresponds to a high-noise,
long-length scale solution (shown in panel c). With only 7 data points, there is not enough evidence
to confidently decide which is more reasonable, although the more complex model (panel b) has a
marginal likelihood that is about 60% higher than the simpler model (panel c). With more data, the
more complex model would become even more preferred.
Figure 17.9 illustrates some other interesting (and typical) features. The region where σ
2
y ≈ 1
(top of panel a) corresponds to the case where the noise is very high; in this regime, the marginal
likelihood is insensitive to the length scale (indicated by the horizontal contours), since all the data
is explained as noise. The region where ` ≈ 0.5 (left hand side of panel a) corresponds to the case
where the length scale is very short; in this regime, the marginal likelihood is insensitive to the noise
level (indicated by the vertical contours), since the data is perfectly interpolated. Neither of these
regions would be chosen by a good optimizer.
17.2.6.2 Bayesian inference
When we have a small number of datapoints (e.g., when using GPs for Bayesian optimization), using
a point estimate of the kernel parameters can give poor results [Bul11; WF14]. In such cases, we may
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.2. Gaussian processes 575
4.0 4.5 5.0 5.5 6.0 6.5 7.0
sepal_length
0.0
0.2
0.4
0.6
0.8
1.0
(a)
4.0 4.5 5.0 5.5 6.0 6.5 7.0
sepal_length
0.0
0.2
0.4
0.6
0.8
1.0
(b)
Figure 17.10: GP classifier for a binary classification problem on Iris flowers (Setosa vs Versicolor) using
a single input feature (sepal length). The fat vertical line is the credible interval for the decision boundary.
(a) SE kernel. (b) SE plus linear kernel. Adapted from Figures 7.11–7.12 of [Mar18]. Generated by code at
figures.probml.ai/book1/17.10.
wish to approximate the posterior over the kernel parameters. Several methods can be used. For
example, [MA10] shows how to use slice sampling, [Hen+15] shows how to use Hamiltonian Monte
Carlo, and [BBV11] shows how to use sequential Monte Carlo.
17.2.7 GPs for classification
So far, we have focused on GPs for regression using Gaussian likelihoods. In this case, the posterior
is also a GP, and all computation can be performed analytically. However, if the likelihood is
non-Gaussian, such as the Bernoulli likelihood for binary classification, we can no longer compute
the posterior exactly.
There are various approximations we can make. some of which we discuss in the sequel to this
book, [Mur22]. In this section, we use the Hamiltonian Monte Carlo method (Section 4.6.8.4), both
for the latent Gaussian function f as well as the kernel hyperparameters θ. The basic idea is to
specify the negative log joint
−E(f, θ) = log p(f, θ|X, y) = log N (f|0, K(X, X)) + X
N
n=1
log Ber(yn|fn(xn)) + log p(θ) (17.55)
We then use autograd to compute ∇f E(f, θ) and ∇θE(f, θ), and use these gradients as inputs to a
Gaussian proposal distribution.
Let us consider a 1d example from [Mar18]. This is similar to the Bayesian logistic regression
example from Figure 4.20, where the goal is to classify iris flowers as being Setosa or Versicolor,
yn ∈ {0, 1}, given information about the sepal length, xn. We will use an SE kernel with length scale
`. We put a Ga(2, 0.5) prior on `.
Figure 17.10a shows the results using the SE kernel. This is similar to the results of linear logistic
regression (see Figure 4.20), except that at the edges (away from the data), the probability curves
towards 0.5. This is because the prior mean function is m(x) = 0, and σ(0) = 0.5. We can eliminate
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license576 Chapter 17. Kernel Methods *
0 10 20 30 40 50 60 70 80
age
healthy
sick
space_flu
(a)
0 10 20 30 40 50 60 70 80
age
healthy
sick
(b)
Figure 17.11: (a) Fictitious “space flu” binary classification problem. (b) Fit from a GP with SE kernel.
Adapted from Figures 7.13–7.14 of [Mar18]. Generated by code at figures.probml.ai/book1/17.11.
this artefact by using a more flexible kernel, which encodes the prior knowledge that we expect the
output to be monotonically increasing or decreasing in the input. We can do this using a linear
kernel,
K(x, x0
) = (x − c)(x
0 − c) (17.56)
We can scale and add this to the SE kernel to get
K(x, x0
) = τ (x − c)(x
0 − c) + exp 
−
(x − x
0
)
2
2`
2

(17.57)
The results are shown in Figure 17.10b, and look more reasonable.
One might wonder why we bothered to use a GP, when the results are no better than a simple
linear logistic regression model. The reason is that the GP is much more flexible, and makes fewer a
priori assumptions, beyond smoothness. For example, suppose the data looked like Figure 17.11a.
In this case, a linear logistic regression model could not fit the data. We could in principle use a
neural network, but it may not work well since we only have 60 data points. However, GPs are well
designed to handle the small sample setting. In Figure 17.11b, we show the results of fitting a GP
with an SE kernel to this data. The results look reasonable.
17.2.8 Connections with deep learning
It turns out that there are many interesting connections and similarities between GPs and deep
neural networks. For example, one can show that an RBF network with one hidden layer, which
is infinitely wide, is equivalent to a GP with an RBF kernel. (This follows from the fact that
the RBF kernel can be expressed as the inner product of an infinite number of features.) More
generally, we can interpret many kinds of DNNs as GPs using a specific kind of kernel derived from
the architecture of the model; this is known as the neural tangent kernel [JGH18]. See the sequel
to this book, [Mur22], for details.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.2. Gaussian processes 577
17.2.9 Scaling GPs to large datasets
The main disadvantage of GPs (and other kernel methods, such as SVMs, which we discuss in
Section 17.3) is that inverting the N × N kernel matrix takes O(N3
) time, making the method too
slow for big datasets. Many different approximate schemes have been proposed to speedup GPs (see
e.g., [Liu+18a] for a review). In this section, we briefly mention some of them. For more details, see
the sequel to this book, [Mur22].
17.2.9.1 Sparse (inducing-point) approximations
A simple approach to speeding up GP inference is to use less data. A better approach is to try to
“summarize” the N training points X into M  N inducing points or pseudo inputs Z. This
lets us replace p(f|fX) with p(f|fZ), where fX = {f(x) : x ∈ X} is the vector of observed function
values at the training points, and fZ = {f(x) : xinZ} is the vector of estimated function values at
the inducing points. By optimizing (Z, fZ) we can learn to “compress” the training data (X, fX)
into a “bottleneck” (Z, fZ), thus speeding up computation from O(N3
) to O(M3
). This is called a
sparse GP. This whole process can be made rigorous using the framework of variational inference.
For details, see the sequel to this book, [Mur22].
17.2.9.2 Exploiting parallelization and kernel matrix structure
It takes O(N3
) time to compute the Cholesky decomposition of KX,X, which is needed to solve
the linear system Kσα = y and to compute |KX,X|, where Kσ = KX,X + σ
2
IN . An alternative to
Cholesky decomposition is to use linear algebra methods, often called Krylov subspace methods,
which are based just on matrix vector multiplication or MVM. These approaches are often
much faster, since they can naturally exploit structure in the kernel matrix. Moreover, even if the
kernel matrix does not have special structure, matrix multiplies are trivial to parallelize, and can
thus be greatly accelerated by GPUs, unlike Cholesky based methods which are largely sequential.
This is the basis of the popular GPyTorch package [Gar+18]. For more details, see the sequel to
this book, [Mur22].
17.2.9.3 Random feature approximation
Although the power of kernels resides in the ability to avoid working with featurized representations
of the inputs, such kernelized methods take O(N3
) time, in order to invert the Gram matrix K.
This can make it difficult to use such methods on large scale data. Fortunately, we can approximate
the feature map for many (shift invariant) kernels using a randomly chosen finite set of M basis
functions, thus reducing the cost to O(NM + M3
). We briefly discuss this idea below. For more
details, see e.g., [Liu+20].
Random features for RBF kernel
We will focus on the case of the Gaussian RBF kernel. One can show that
K(x, x
0
) ≈ φ(x)
Tφ(x
0
) (17.58)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license578 Chapter 17. Kernel Methods *
where the (real-valued) feature vector is given by
φ(x) ,
1
√
T
[(sin(ω
T
1x), ...,sin(ω
T
T x), cos(ω
T
1x), ..., cos(ω
T
T x))] (17.59)
=
1
√
T
[sin(Ωx), cos(Ωx)] (17.60)
where T = M/2, and Ω ∈ R
T ×D is a random Gaussian matrix, where the entries are sampled iid
from N (0, 1/σ2
), where σ is the kernel bandwidth. The bias of the approximation decreases as we
increase M. In practice, we use a finite M, and compute a single sample Monte Carlo approximation
to the expectation by drawing a single random matrix. The features in Equation (17.60) are called
random Fourier features (RFF) [RR08] or “weighted sums of random kitchen sinks” [RR09].
We can also use positive random features, rather than trigonometric random features, which can be
preferable in some applications, such as models which use attention (see Section 15.6.4). In particular,
we can use
φ(x) , e
−||x||2/2
1
√
M

(exp(ω
T
1x), · · · ,(exp(ω
T
Mx)

(17.61)
where ωm are sampled as before. For details, see [Cho+20b].
Regardless of whether we use trigonometric or positive features, we can obtain a lower variance
estimate by ensuring that the rows of Z are random but orthogonal; these are called orthogonal
random features. Such sampling can be conducted efficiently via Gram-Schmidt orthogonalization
of the unstructured Gaussian matrices [Yu+16], or several approximations that are even faster (see
[CRW17; Cho+19]).
Fastfood approximation
Unfortunately, storing the random matrix Ω takes O(DM) space, and computing Ωx takes O(DM)
time, where D is the input dimensionality, and M is the number of random features. This can be
prohibitive if M  D, which it may need to be in order to get any benefits over using the original set
of features. Fortunately, we can use the fast Hadamard transform to reduce the memory from
O(MD) to O(M), and reduce the time from O(MD) to O(M log D). This approach has been called
fastfood [LSS13], a reference to the original term “kitchen sinks”.
Extreme learning machines
We can use the random features approximation to the kernel to convert a GP into a linear model of
the form
f(x; θ) = Wφ(x) = Wh(Zx) (17.62)
where h(a) = p
1/M[sin(a), cos(a)] for RBF kernels. This is equivalent to a one-layer MLP with
random (and fixed) input-to-hidden weights. When M > N, this corresponds to an over-parameterized
model, which can perfectly interpolate the training data.
In [Cur+17], they apply this method to fit a logistic regression model of the form f(x; θ) =
WTh(Zˆx) + b using SGD; they call the resulting method “McKernel”. We can also optimize Z as
well as W, as discussed in [Alb+17], although now the problem is no longer convex.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.3. Support vector machines (SVMs) 579
+ 
+ 
+
+ 
+ 
+ 
+
+ 
Figure 17.12: Illustration of the large margin principle. Left: a separating hyper-plane with large margin.
Right: a separating hyper-plane with small margin.
Alternatively, we can use M < N, but stack many such random nonlinear layers together, and just
optimize the output weights. This has been called an extreme learning machine or ELM (see
e.g., [Hua14]), although this work is controversial.1
17.3 Support vector machines (SVMs)
In this section, we discuss a form of (non-probabilistic) predictors for classification and regression
problems which have the form
f(x) = X
N
i=1
αiK(x, xi) (17.63)
By adding suitable constraints, we can ensure that many of the αi coefficients are 0, so that predictions
at test time only depend on a subset of the training points. The surving points are called “ support
vectors”, and the resulting model is called a support vector machine or SVM. We give a brief
summary below. More details, can be found in e.g., [VGS97; SS01],
17.3.1 Large margin classifiers
Consider a binary classifier of the form h(x) = sign(f(x)), where the decision boundary is given by
the following linear function:
f(x) = wTx + w0 (17.64)
(In the SVM literature, it is common to assume the class labels are −1 and +1, rather than 0 and 1.
To avoid confusion, we denote such target labels by y˜ rather than y.) There may be many lines that
separate the data. However, intuitively we would like to pick the one that has maximum margin,
which is the distance of the closest point to the decision boundary, since this will give us the most
1. The controversy has arisen because the inventor Guang-Bin Huang has been accused of not citing related prior
work, such as the equivalent approach based on random feature approximations to kernels. For details, see https:
//en.wikipedia.org/wiki/Extreme_learning_machine#Controversy.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license580 Chapter 17. Kernel Methods *
R1
R0
y = 0
y > 0
y < 0
w
x
r =
f(x)
x⊥ kwk
−w0
kwk
(a)
y = 0
y = 1
y = −1
ξ > 1
ξ < 1
ξ = 0
ξ = 0
(b)
Figure 17.13: (a) Illustration of the geometry of a linear decision boundary in 2d. A point x is classified as
belonging in decision region R1 if f(x) > 0, otherwise it belongs in decision region R0; w is a vector which is
perpendicular to the decision boundary. The term w0 controls the distance of the decision boundary from the
origin. x⊥ is the orthogonal projection of x onto the boundary. The signed distance of x from the boundary
is given by f(x)/||w||. Adapted from Figure 4.1 of [Bis06]. (b) Points with circles around them are support
vectors, and have dual variables αn > 0. In the soft margin case, we associate a slack variable ξn with each
example. If 0 < ξn < 1, the point is inside the margin, but on the correct side of the decision boundary. If
ξn > 1, the point is on the wrong side of the boundary. Adapted from Figure 7.3 of [Bis06].
robust solution. This idea is illustrated in Figure 17.12: the solution on the left has larger margin
than the one on the right, and intuitively is is better, since it will be less sensitive to perturbations
of the data.
How can we compute such a large margin classifier? First we need to derive an expression for
the distance of a point to the decision boundary. Referring to Figure 17.13(a), we see that
x = x⊥ + r
w
||w|| (17.65)
where r is the distance of x from the decision boundary whose normal vector is w, and x⊥ is the
orthogonal projection of x onto this boundary.
We would like to maximize r, so we need to express it as a function of w. First, note that
f(x) = wTx + w0 = (wTx⊥ + w0) + r
wTw
||w|| = (wTx⊥ + w0) + r||w|| (17.66)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.3. Support vector machines (SVMs) 581
0 1 2 3 4 5 6
x0
0
20
40
60
80
x1
Unscaled
2 1 0 1 2
x0
2
1
0
1
2
x
0
1
Scaled
Figure 17.14: Illustration of the benefits of scaling the input features before computing a max margin classifier.
Adapted from Figure 5.2 of [Gér19]. Generated by code at figures.probml.ai/book1/17.14.
Since 0 = f(x⊥) = wTx⊥ + w0, we have f(x) = r||w|| and hence r =
f(x)
||w|| .
Since we want to ensure each point is on the correct side of the boundary, we also require
f(xn)y˜n > 0. We want to maximize the distance of the closest point, so our final objective becomes
max
w,w0
1
||w||
N
min
n=1

y˜n(wTxn + w0)

(17.67)
Note that by rescaling the parameters using w → kw and w0 → kw0, we do not change the distance
of any point to the boundary, since the k factor cancels out when we divide by ||w||. Therefore let
us define the scale factor such that y˜nfn = 1 for the point that is closest to the decision boundary.
Hence we require y˜nfn ≥ 1 for all n. Finally, note that maximizing 1/||w|| is equivalent to minimizing
||w||2
. Thus we get the new objective
min
w,w0
1
2
||w||2
s.t. y˜n(wTxn + w0) ≥ 1, n = 1 : N (17.68)
(The factor of 1
2
is added for convenience and doesn’t affect the optimal parameters.) The constraint
says that we want all points to be on the correct side of the decision boundary with a margin of at
least 1.
Note that it is important to scale the input variables before using an SVM, otherwise the margin
measures distance of a point to the boundary using all input dimensions equally. See Figure 17.14
for an illustration.
17.3.2 The dual problem
The objective in Equation (17.68) is a standard quadratic programming problem (Section 8.5.4),
since we have a quadratic objective subject to linear constraints. This has N + D + 1 variables
subject to N constraints, and is known as a primal problem.
In convex optimization, for every primal problem we can derive a dual problem. Let α ∈ R
N be
the dual variables, corresponding to Lagrange multipliers that enforce the N inequality constraints.
The generalized Lagrangian is given below (see Section 8.5.2 for relevant background information on
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license582 Chapter 17. Kernel Methods *
constrained optimization):
L(w, w0, α) = 1
2
wTw −
X
N
n=1
αn(˜yn(wTxn + w0) − 1) (17.69)
To optimize this, we must find a stationary point that satisfies
(wˆ , wˆ0, αˆ ) = min
w,w0
max
α
L(w, w0, α) (17.70)
We can do this by computing the partial derivatives wrt w and w0 and setting to zero. We have
∇wL(w, w0, α) = w −
X
N
n=1
αny˜nxn (17.71)
∂
∂w0
L(w, w0, α) = −
X
N
n=1
αny˜n (17.72)
and hence
wˆ =
X
N
n=1
αˆny˜nxn (17.73)
0 = X
N
n=1
αˆny˜n (17.74)
Plugging these into the Lagrangian yields the following
L(wˆ , wˆ0, α) = 1
2
wˆ
Twˆ −
X
N
n=1
αny˜nwˆ
Txn −
X
N
n=1
αny˜nw0 +
X
N
n=1
αn (17.75)
=
1
2
wˆ
Twˆ − wˆ
Twˆ − 0 + X
N
n=1
αn (17.76)
= −
1
2
X
N
i=1
X
N
j=1
αiαjy˜iy˜jx
T
i xj +
X
N
n=1
αn (17.77)
This is called the dual form of the objective. We want to maximize this wrt α subject to the
constraints that PN
n=1 αny˜n = 0 and 0 ≤ αn for n = 1 : N.
The above objective is a quadratic problem in N variables. Standard QP solvers take O(N3
) time.
However, specialized algorithms, which avoid the use of generic QP solvers, have been developed for
this problem, such as the sequential minimal optimization or SMO algorithm [Pla98], which
takes O(N) to O(N2
) time.
Since this is a convex objective, the solution must satisfy the KKT conditions (Section 8.5.2),
which tell us that the following properties hold:
αn ≥ 0 (17.78)
y˜nf(xn) − 1 ≥ 0 (17.79)
αn(˜ynf(xn) − 1) = 0 (17.80)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.3. Support vector machines (SVMs) 583
Hence either αn = 0 (in which case example n is ignored when computing wˆ ) or the constraint
y˜n(wˆ
Txn + wˆ0) = 1 is active. This latter condition means that example n lies on the decision
boundary; these points are are known as the support vectors, as shown in Figure 17.13(b). We
denote the set of support vectors by S.
To perform prediction, we use
f(x; wˆ , wˆ0) = wˆ
Tx + ˆw0 =
X
n∈S
αny˜nx
T
nx + ˆw0 (17.81)
To solve for wˆ0 we can use the fact that for any support vector, we have y˜nf(x; wˆ , wˆ0) = 1. Multiplying
both sides by y˜n, and exploiting the fact that y˜
2
n = 1, we get wˆ0 = y˜n − wˆ
Txn. In practice we get
better results by averaging over all the support vectors to get
wˆ0 =
1
|S|
X
n∈S
(˜yn − wˆ
Txn) = 1
|S|
X
n∈S
(˜yn −
X
m∈S
αmy˜mx
T
mxn) (17.82)
17.3.3 Soft margin classifiers
If the data is not linearly separable, there will be no feasible solution in which y˜nfn ≥ 1 for all n.
We therefore introduce slack variables ξn ≥ 0 and replace the hard constraints that y˜nfn ≥ 0 with
the soft margin constraints that y˜nfn ≥ 1 − ξn. The new objective becomes
min
w,w0,ξ
1
2
||w||2 + C
X
N
n=1
ξn s.t. ξn ≥ 0, y˜n(x
T
nw + w0) ≥ 1 − ξn (17.83)
where C ≥ 0 is a hyper parameter controlling how many points we allow to violate the margin
constraint. (If C = ∞, we recover the unregularized, hard-margin classifier.)
The corresponding Lagrangian for the soft margin classifier becomes
L(w, w0, α, ξ, µ) = 1
2
wTw + C
X
N
n=1
ξn −
X
N
n=1
αn(˜yn(wTxn + w0) − 1 + ξn) −
X
N
n=1
µnξn (17.84)
where αn ≥ 0 and µn ≥ 0 are the Lagrange multipliers. Optimizing out w, w0 and ξ gives the dual
form
L(α) = X
N
i=1
αi −
1
2
X
N
i=1
X
N
j=1
αiαjy˜iy˜jx
T
i xj (17.85)
This is identical to the hard margin case; however, the constraints are different. In particular, the
KKT conditions imply
0 ≤ αn ≤ C (17.86)
X
N
n=1
αny˜n = 0 (17.87)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license584 Chapter 17. Kernel Methods *
If αn = 0, the point is ignored. If 0 < αn < C then ξn = 0, so the point lies on the margin. If αn = C,
the point can lie inside the margin, and can either be correctly classified if ξn ≤ 1, or misclassified if
ξn > 1. See Figure 17.13(b) for an illustration. Hence P
n
ξn is an upper bound on the number of
misclassified points.
As before, the bias term can be computed using
wˆ0 =
1
|M|
X
n∈M
(˜yn −
X
m∈S
αmy˜mx
T
mxn) (17.88)
where M is the set of points having 0 < αn < C.
There is an alternative formulation of the soft margin SVM known as the ν-SVM classifier
[Sch+00]. This involves maximizing
L(α) = −
1
2
X
N
i=1
X
N
j=1
αiαjy˜iy˜jx
T
i xj (17.89)
subject to the constraints that
0 ≤ αn ≤ 1/N (17.90)
X
N
n=1
αny˜n = 0 (17.91)
X
M
n=1
αn ≥ ν (17.92)
This has the advantage that the parameter ν, which replaces C, can be interpreted as an upper
bound on the fraction of margin errors (points for which ξn > 0), as well as a lower bound on the
number of support vectors.
17.3.4 The kernel trick
So far we have converted the large margin binary classification problem into a dual problem in
N unknowns (α) which (in general) takes O(N3
) time to solve, which can be slow. However, the
principal benefit of the dual problem is that we can replace all inner product operations x
Tx
0 with a
call to a positive definite (Mercer) kernel function, K(x, x
0
). This is called the kernel trick.
In particular, we can rewrite the prediction function in Equation (17.81) as follows:
f(x) = wˆ
Tx + ˆw0 =
X
n∈S
αny˜nx
T
nx + ˆw0 =
X
n∈S
αny˜nK(xn, x) + ˆw0 (17.93)
We also need to kernelize the bias term. This can be done by kernelizing Equation (17.82) as follows:
wˆ0 =
1
|S|
X
i∈S

y˜i − (
X
j∈S
αˆjy˜jxj )
Txi

 =
1
|S|
X
i∈S

y˜i − (
X
j∈S
αˆjy˜jK(xj , xi)

 (17.94)
The kernel trick allows us to avoid having to deal with an explicit feature representation of our
data, and allows us to easily apply classifiers to structured objects, such as strings and graphs.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.3. Support vector machines (SVMs) 585
0.4 0.6 0.8 1 1.2
−6
−4
−2
0
2
4
6 Correct log−odds
RVM y(x)
SVM y(x)
Figure 17.15: Log-odds vs x for 3 different methods. Adapted from Figure 10 of [Tip01]. Used with kind
permission of Mike Tipping.
17.3.5 Converting SVM outputs into probabilities
An SVM classifier produces a hard-labeling, yˆ(x) = sign(f(x)). However, we often want a measure
of confidence in our prediction. One heuristic approach is to interpret f(x) as the log-odds ratio,
log p(y=1|x)
p(y=0|x)
. We can then convert the output of an SVM to a probability using
p(y = 1|x, θ) = σ(af(x) + b) (17.95)
where a, b can be estimated by maximum likelihood on a separate validation set. (Using the training
set to estimate a and b leads to severe overfitting.) This technique was first proposed in [Pla00], and
is known as Platt scaling.
However, the resulting probabilities are not particularly well calibrated, since there is nothing in
the SVM training procedure that justifies interpreting f(x) as a log-odds ratio. To illustrate this,
consider an example from [Tip01]. Suppose we have 1d data where p(x|y = 0) = Unif(0, 1) and
p(x|y = 1) = Unif(0.5, 1.5). Since the class-conditional distributions overlap in the [0.5, 1] range, the
log-odds of class 1 over class 0 should be zero in this region, and infinite outside this region. We
sampled 1000 points from the model, and then fit a probabilistic kernel classifier (an RVM, described
in Section 17.4.1) and an SVM with a Gaussian kernel of width 0.1. Both models can perfectly
capture the decision boundary, and achieve a generalization error of 25%, which is Bayes optimal in
this problem. The probabilistic output from the RVM is a good approximation to the true log-odds,
but this is not the case for the SVM, as shown in Figure 17.15.
17.3.6 Connection with logistic regression
We have seen that data points that are on the correct side of the decision boundary have ξn = 0; for
the others, we have ξn = 1 − y˜nf(xn). Therefore we can rewrite the objective in Equation (17.83) as
follows:
L(w) = X
N
n=1
`hinge(˜yn, f(xn))) + λ|w||2
(17.96)
where λ = (2C)
−1 and `hinge(y, η) is the hinge loss function defined by
`hinge(˜y, η) = max(0, 1 − yη˜ ) (17.97)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license586 Chapter 17. Kernel Methods *
?
R1 R2
C1 R3
Not C1
C2
Not C2
(a) (b)
Figure 17.16: (a) The one-versus-rest approach. The green region is predicted to be both class 1 and class 2.
(b) The one-versus-one approach. The label of the green region is ambiguous. Adapted from Figure 4.2 of
[Bis06].
As we see from Figure 4.2, this is a convex, piecewise differentiable upper bound to the 0-1 loss, that
has the shape of a partially open door hinge.
By contrast, (penalized) logistic regression optimizes
L(w) = X
N
n=1
`ll(˜yn, f(xn))) + λ|w||2
(17.98)
where the log loss is given by
`ll(˜y, η) = − log p(y|η) = log(1 + e
−yη˜
) (17.99)
This is also plotted in Figure 4.2. We see that it is similar to the hinge loss, but with two important
differences. First the hinge loss is piecewise linear, so we cannot use regular gradient methods to
optimize it. (We can, however, compute the subgradient at yη˜ = 1.) Second, the hinge loss has a
region where it is strictly 0; this results in sparse estimates.
We see that both functions are convex upper bounds on the 0-1 loss, which is given by
`01(˜y, yˆ) = I(˜y 6= ˆy) = I(˜y y <ˆ 0) (17.100)
These upper bounds are easier to optimize and can be viewed as surrogates for the 0-1 loss. See
Section 4.3.2 for details.
17.3.7 Multi-class classification with SVMs
SVMs are inherently a binary classifier. One way to convert them to a multi-class classification
model is to train C binary classifiers, where the data from class c is treated as positive, and the
data from all the other classes is treated as negative. We then use the rule yˆ(x) = arg maxc fc(x) to
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.3. Support vector machines (SVMs) 587
1.0
0.5
0.0
0.5
1.0
1.5
x2
= 0.1, C = 0.001 = 0.1, C = 1000
1.5 1.0 0.5 0.0 0.5 1.0 1.5 2.0
x1
1.0
0.5
0.0
0.5
1.0
1.5
x2
= 5, C = 0.001
1.5 1.0 0.5 0.0 0.5 1.0 1.5 2.0
x1
= 5, C = 1000
Figure 17.17: SVM classifier with RBF kernel with precision γ and regularizer C applied to two moons data.
Adapted from Figure 5.9 of [Gér19]. Generated by code at figures.probml.ai/book1/17.17.
predict the final label, where fc(x) = log p(c=1|x)
p(c=0|x)
is the score given by classifier c. This is known as
the one-versus-the-rest approach (also called one-vs-all).
Unfortunately, this approach has several problems. First, it can result in regions of input space
which are ambiguously labeled. For example, the green region at the top of Figure 17.16(a) is
predicted to be both class 2 and class 1. A second problem is that the magnitude of the fc’s scores
are not calibrated with each other, so it is hard to compare them. Finally, each binary subproblem is
likely to suffer from the class imbalance problem (Section 10.3.8.2). For example, suppose we have 10
equally represented classes. When training f1, we will have 10% positive examples and 90% negative
examples, which can hurt performance.
Another approach is to use the one-versus-one or OVO approach, also called all pairs, in which
we train C(C − 1)/2 classifiers to discriminate all pairs fc,c0 . We then classify a point into the class
which has the highest number of votes. However, this can also result in ambiguities, as shown in
Figure 17.16(b). Also, this requires fitting O(C
2
) models.
17.3.8 How to choose the regularizer C
SVMs require that you specify the kernel function and the parameter C. Typically C is chosen by
cross-validation. Note, however, that C interacts quite strongly with the kernel parameters. For
example, suppose we are using an RBF kernel with precision γ =
1
2σ2 . If γ is large, corresponding to
narrow kernels, we may need heavy regularization, and hence small C. If γ is small, a larger value of
C should be used. So we see that γ and C are tightly coupled, as illustrated in Figure 17.17.
The authors of libsvm [HCL09] recommend using CV over a 2d grid with values C ∈ {2
−5
, 2
−3
, . . . , 2
15}
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license588 Chapter 17. Kernel Methods *
log(C)
2
0
2
4
6
8
log( )
2
1
0
1
2
Cv_error
0.18
0.20
0.22
0.24
0.26
0.28
0.30
0.32
(a)
10
1 10
0 10
1 10
2 10
3
0.18
0.19
0.20
0.21
0.22
0.23
0.24
0.25
Cross-validation score
bayeserror
lowest point
(b)
Figure 17.18: (a) A cross validation estimate of the 0-1 error for an SVM classifier with RBF kernel with
different precisions γ = 1/(2σ
2
) and different regularizer λ = 1/C, applied to a synthetic data set drawn from
a mixture of 2 Gaussians. (b) A slice through this surface for γ = 5 The red dotted line is the Bayes optimal
error, computed using Bayes rule applied to the model used to generate the data. Adapted from Figure 12.6 of
[HTF09]. Generated by code at figures.probml.ai/book1/17.18.
and γ ∈ {2
−15
, 2
−13
, . . . , 2
3}. See Figure 17.18 which shows the CV estimate of the 0-1 risk as a
function of C and γ.
To choose C efficiently, one can develop a path following algorithm in the spirit of lars (Sec￾tion 11.4.4). The basic idea is to start with C small, so that the margin is wide, and hence all points
are inside of it and have αi = 1. By slowly increasing C, a small set of points will move from inside
the margin to outside, and their αi values will change from 1 to 0, as they cease to be support vectors.
When C is maximal, the margin becomes empty, and no support vectors remain. See [Has+04] for
the details.
17.3.9 Kernel ridge regression
Recall the equation for ridge regression from Equation (11.55):
wˆ map = (XTX + λID)
−1XTy = (X
n
xnx
T
n + λID)
−1
(
X
n
y˜nxn) (17.101)
Using the matrix inversion lemma (Section 7.3.3), we can rewrite the ridge estimate as follows
w = XT
(XXT + λIN )
−1y =
X
n
xn((X
n
x
T
nxn + λIN )
−1y)n (17.102)
Let us define the following dual variables:
α , (XXT + λIN )
−1y = (X
n
x
T
nxn + λIN )
−1y (17.103)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.3. Support vector machines (SVMs) 589
Then we can rewrite the primal variables as follows
w = XTα =
X
N
n=1
αnxn (17.104)
This tells us that the solution vector is just a linear sum of the N training vectors. When we plug
this in at test time to compute the predictive mean, we get
f(x; w) = wTx =
X
N
n=1
αnx
T
nx (17.105)
We can then use the kernel trick to rewrite this as
f(x; w) = X
N
n=1
αnK(xn, x) (17.106)
where
α = (K + λIN )
−1y (17.107)
In other words,
f(x; w) = k
T
(K + λIN )
−1y (17.108)
where k = [K(x, x1), . . . , K(x, xN )]. This is called kernel ridge regression.
The trouble with the above approach is that the solution vector α is not sparse, so predictions at
test time will take O(N) time. We discuss a solution to this in Section 17.3.10.
17.3.10 SVMs for regression
Consider the following `2-regularized ERM problem:
J(w, λ) = λ||w||2 +
X
N
n=1
`(˜yn, yˆn) (17.109)
where yˆn = wTxn + w0. If we use the quadratic loss, `(y, yˆ) = (y − yˆ)
2
, where y, yˆ ∈ R, we recover
ridge regression (Section 11.3). If we then apply the kernel trick, we recover kernel ridge regression
(Section 17.3.9).
The problem with kernel ridge regression is that the solution depends on all N training points,
which makes it computationally intractable. However, by changing the loss function, we can make
the optimal set of basis function coefficients, α∗
, be sparse, as we show below.
In particular, consider the following variant of the Huber loss function (Section 5.1.5.3) called the
epsilon insensitive loss function:
L(y, yˆ) ,

0 if |y − yˆ| < 
|y − yˆ| −  otherwise (17.110)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license590 Chapter 17. Kernel Methods *
−3 −2 −1 0 1 2 3
−0.5
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
L2
ε−insensitive
huber
(a)
x
y(x)
y − ǫ
y
y + ǫ
ξ− > 0
ξ+ > 0
1
(b)
Figure 17.19: (a) Illustration of `2, Huber and -insensitive loss functions, where  = 1.5. Generated by code
at figures.probml.ai/book1/17.19. (b) Illustration of the -tube used in SVM regression. Points above the
tube have ξ
+
i > 0 and ξ
−
i = 0. Points below the tube have ξ
+
i = 0 and ξ
−
i > 0. Points inside the tube have
ξ
+
i = ξ
−
i = 0. Adapted from Figure 7.7 of [Bis06].
This means that any point lying inside an -tube around the prediction is not penalized, as in
Figure 17.19.
The corresponding objective function is usually written in the following form
J =
1
2
||w||2 + C
X
N
n=1
L(˜yn, yˆn) (17.111)
where yˆn = f(xn) = wTxn + w0 and C = 1/λ is a regularization constant. This objective is convex
and unconstrained, but not differentiable, because of the absolute value function in the loss term.
As in Section 11.4.9, where we discussed the lasso problem, there are several possible algorithms we
could use. One popular approach is to formulate the problem as a constrained optimization problem.
In particular, we introduce slack variables to represent the degree to which each point lies outside
the tube:
y˜n ≤ f(xn) +  + ξ
+
n
(17.112)
y˜n ≥ f(xn) −  − ξ
−
n
(17.113)
Given this, we can rewrite the objective as follows:
J =
1
2
||w||2 + C
X
N
n=1
(ξ
+
n + ξ
−
n
) (17.114)
This is a quadratic function of w, and must be minimized subject to the linear constraints in
Equations 17.112-17.113, as well as the positivity constraints ξ
+
n ≥ 0 and ξ
−
n ≥ 0. This is a standard
quadratic program in 2N + D + 1 variables.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.4. Sparse vector machines 591
By forming the Lagrangian and optimizing, as we did above, one can show that the optimal solution
has the following form
wˆ =
X
n
αnxn (17.115)
where αn ≥ 0 are the dual variables. (See e.g., [SS02] for details.) Fortunately, the α vector is sparse,
meaning that many of its entries are equal to 0. This is because the loss doesn’t care about errors
which are smaller than . The degree of sparsity is controlled by C and .
The xn for which αn > 0 are called the support vectors; these are points for which the errors lie
on or outside the  tube. These are the only training examples we need to keep for prediction at test
time, since
f(x) = ˆw0 + wˆ
Tx = ˆw0 +
X
n:αn>0
αnx
T
nx (17.116)
Finally, we can use the kernel trick to get
f(x) = ˆw0 +
X
n:αn>0
αnK(xn, x) (17.117)
This overall technique is called support vector machine regression or SVM regression for
short, and was first proposed in [VGS97].
In Figure 17.20, we give an example where we use an RBF kernel with γ = 1. When C is small,
the model is heavily regularized; when C is large, the model is less regularized and can fit the data
better. We also see that when  is small, the tube is smaller, so there are more support vectors.
17.4 Sparse vector machines
GPs are very flexible models, but incur an O(N) time cost at prediction time, which can be prohibitive.
SVMs solve that problem by estimating a sparse weight vector. However, SVMs do not give calibrated
probabilistic outputs.
We can get the best of both worlds by using parametric models, where the feature vector is defined
using basis functions centered on each of the training points, as follows:
φ(x) = [K(x, x1), . . . , K(x, xN )] (17.118)
where K is any similarity kernel, not necessarily a Mercer kernel. Equation (17.118) maps x ∈ X
into φ(x) ∈ R
N . We can plug this new feature vector into any discriminative model, such as logistic
regression. Since we have D = N parameters, we need to use some kind of regularization, to prevent
overfitting. If we fit such a model using `2 regularization (which we will call L2VM, for `2-vector
machine), the result often has good predictive performance, but the weight vector w will be dense,
and will depend on all N training points. A natural solution is to impose a sparsity-promoting
prior on w, so that not all the exemplars need to be kept. We call such methods sparse vector
machines.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license592 Chapter 17. Kernel Methods *
1.0 0.5 0.0 0.5 1.0
x1
0.0
0.2
0.4
0.6
0.8
1.0
y
C = 100, = 0.1
1.0 0.5 0.0 0.5 1.0
x1
C = 0.01, = 0.1
1.0 0.5 0.0 0.5 1.0
x1
0.0
0.2
0.4
0.6
0.8
1.0
y
C = 100, = 0.05
1.0 0.5 0.0 0.5 1.0
x1
C = 0.01, = 0.05
Figure 17.20: Illustration of support vector regression. Adapted from Figure 5.11 of [Gér19]. Generated by
code at figures.probml.ai/book1/17.20.
17.4.1 Relevance vector machines (RVMs)
The simplest way to ensure w is sparse is to use `1 regularization, as in Section 11.4. We call this
L1VM or Laplace vector machine, since this approach is equivalent to using MAP estimation
with a Laplace prior for w.
However, sometimes `1 regularization does not result in a sufficient level of sparsity for a given
level of accuracy. An alternative approach is based on the use of ARD or automatic relevancy
determination, which uses type II maximum likelihood (aka empirical Bayes) to estimate a sparse
weight vector [Mac95; Nea96]. If we apply this technique to a feature vector defined in terms of
kernels, as in Equation (17.118), we get a method called the relevance vector machine or RVM
[Tip01; TF03].
17.4.2 Comparison of sparse and dense kernel methods
In Figure 17.21, we compare L2VM, L1VM, RVM and an SVM using an RBF kernel on a binary
classification problem in 2d. We use cross validation to pick C = 1/λ for the SVM (see Section 17.3.8),
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.4. Sparse vector machines 593
−2 −1 0 1 2 3
−1
0
1
2
logregL2, nerr= 27
(a)
−2 −1 0 1 2 3
−1
0
1
2
logregL1, nerr=20, nsupport=88
(b)
−2 −1 0 1 2 3
−1
0
1
2
RVM, nerr=17, nsupport=12
(c)
−2 −1 0 1 2 3
−1
0
1
2
SVM, nerr=22, nsupport=65
(d)
Figure 17.21: Example of non-linear binary classification using an RBF kernel with bandwidth σ = 0.3.
(a) L2VM. (b) L1VM. (c) RVM. (d) SVM. Black circles denote the support vectors. Generated by code at
figures.probml.ai/book1/17.21.
and then use the same value of the regularizer for L2VM and L1VM. We see that all the methods
give similar predictive performance. However, we see that the RVM is the sparsest model, so it will
be the fastest at run time.
In Figure 17.22, we compare L2VM, L1VM, RVM and an SVM using an RBF kernel on a 1d
regression problem. Again, we see that predictions are quite similar, but RVM is the sparsest, then
L1VM, then SVM. This is further illustrated in Figure 17.23.
Beyond these small empirical examples, we provide a more general summary of the different
methods in Table 17.1. The columns of this table have the following meaning:
• Optimize w: a key question is whether the objective L(w) = − log p(D|w) − log p(w) is convex or
not. L2VM, L1VM and SVMs have convex objectives. RVMs do not. GPs are Bayesian methods
that integrate out the weights w.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license594 Chapter 17. Kernel Methods *
1.5 1.0 0.5 0.0 0.5 1.0 1.5
0.4
0.2
0.0
0.2
0.4
0.6
0.8
1.0
linregL2
(a)
1.5 1.0 0.5 0.0 0.5 1.0 1.5
0.4
0.2
0.0
0.2
0.4
0.6
0.8
1.0
linregL1
(b)
1.5 1.0 0.5 0.0 0.5 1.0 1.5
0.4
0.2
0.0
0.2
0.4
0.6
0.8
1.0
RVM
(c)
1.5 1.0 0.5 0.0 0.5 1.0 1.5
0.4
0.2
0.0
0.2
0.4
0.6
0.8
1.0
SVM
(d)
Figure 17.22: Model fits for kernel based regression on the noisy sinc function using an RBF kernel with
bandwidth σ = 0.3. (a) L2VM with λ = 0.5. (b) L1VM with λ = 0.5. (c) RVM. (d) SVM regression with
C = 1/λ. chosen by cross validation. Red circles denote the retained training exemplars. Generated by code
at figures.probml.ai/book1/17.22.
• Optimize kernel: all the methods require that we “tune” the kernel parameters, such as the
bandwidth of the RBF kernel, as well as the level of regularization. For methods based on
Gaussian priors, including L2VM, RVMs and GPs, we can use efficient gradient based optimizers
to maximize the marginal likelihood. For SVMs and L1VMs, we must use cross validation, which
is slower (see Section 17.3.8).
• Sparse: L1VM, RVMs and SVMs are sparse kernel methods, in that they only use a subset of
the training examples. GPs and L2VM are not sparse: they use all the training examples. The
principle advantage of sparsity is that prediction at test time is usually faster. However, this
usually results in overconfidence in the predictions.
• Probabilistic: All the methods except for SVMs produce probabilistic output of the form p(y|x).
SVMs produce a “confidence” value that can be converted to a probability, but such probabilities
are usually very poorly calibrated (see Section 17.3.5).
• Multiclass: All the methods except for SVMs naturally work in the multiclass setting, by using a
categorical distribution instead of a Bernoulli. The SVM can be made into a multiclass classifier,
but there are various difficulties with this approach, as discussed in Section 17.3.7.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202217.5. Exercises 595
0 20 40 60 80 100
0.4
0.3
0.2
0.1
0.0
0.1
0.2
linregL2
(a)
0 20 40 60 80 100
1.5
1.0
0.5
0.0
0.5
1.0
linregL1
(b)
0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0
0.2
0.0
0.2
0.4
0.6
0.8
RVM
(c)
0 5 10 15 20 25 30
7.5
5.0
2.5
0.0
2.5
5.0
7.5
SVM
(d)
Figure 17.23: Estimated coefficients for the models in Figure 17.22. Generated by code at fig￾ures.probml.ai/book1/17.23.
Method Opt. w Opt. kernel Sparse Prob. Multiclass Non-Mercer Section
SVM Convex CV Yes No Indirectly No 17.3
L2VM Convex EB No Yes Yes Yes 17.4.1
L1VM Convex CV Yes Yes Yes Yes 17.4.1
RVM Not convex EB Yes Yes Yes Yes 17.4.1
GP N/A EB No Yes Yes No 17.2.7
Table 17.1: Comparison of various kernel based classifiers. EB = empirical Bayes, CV = cross validation.
See text for details.
• Mercer kernel: SVMs and GPs require that the kernel is positive definite; the other techniques do
not, since the kernel function in Equation (17.118) can be an arbitrary function of two inputs.
17.5 Exercises
Exercise 17.1 [Fitting an SVM classifier by hand *]
(Source: Jaakkola.) Consider a dataset with 2 points in 1d: (x1 = 0, y1 = −1) and (x2 =
√
2, y2 = 1).
Consider mapping each point to 3d using the feature vector φ(x) = [1,
√
2x, x2
]
T
. (This is equivalent to using
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license596 Chapter 17. Kernel Methods *
a second order polynomial kernel.) The max margin classifier has the form
min ||w||2
s.t. (17.119)
y1(w
T
φ(x1) + w0) ≥ 1 (17.120)
y2(w
T
φ(x2) + w0) ≥ 1 (17.121)
a. Write down a vector that is parallel to the optimal vector w. Hint: recall from Figure 7.8 (12Apr10
version) that w is perpendicular to the decision boundary between the two points in the 3d feature space.
b. What is the value of the margin that is achieved by this w? Hint: recall that the margin is the distance
from each support vector to the decision boundary. Hint 2: think about the geometry of 2 points in space,
with a line separating one from the other.
c. Solve for w, using the fact that the margin is equal to 1/||w||.
d. Solve for w0 using your value for w and Equations 17.119 to 17.121. Hint: the points will be on the
decision boundary, so the inequalities will be tight.
e. Write down the form of the discriminant function f(x) = w0 + wT φ(x) as an explicit function of x.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202218 Trees, Forests, Bagging, and Boosting
18.1 Classification and regression trees (CART)
Classification and regression trees or CART models [BFO84], also called decision trees
[Qui86; Qui93], are defined by recursively partitioning the input space, and defining a local model in
each resulting region of input space. The overall model can be represented by a tree, with one leaf
per region, as we explain below.
18.1.1 Model definition
We start by considering regression trees, where all inputs are real-valued. The tree consists of a set
of nested decision rules. At each node i, the feature dimension di of the input vector x is compared
to a threshold value ti
, and the input is then passed down to the left or right branch, depending on
whether it is above or below threshold. At the leaves of the tree, the model specifies the predicted
output for any input that falls into that part of the input space.
For example, consider the regression tree in Figure 18.1(a). The first node asks if x1 is less than
some threshold t1. If yes, we then ask if x2 is less than some other threshold t2. If yes, we enter the
bottom left leaf node. This corresponds to the region of space defined by
R1 = {x : x1 ≤ t1, x2 ≤ t2} (18.1)
We can associate this region with the predicted output computing using other branches of the tree
define different regions in terms of axis parallel splits. The overall result is that we partition the
2d input space into 5 regions, as shown in Figure 18.1(b).1 We can now associate a mean response
with each of these regions, resulting in the piecewise constant surface shown in Figure 18.1(b). For
example, the output for region 1 can be estimated using
w1 =
PN
n=1 ynI(xn ∈ R1)
PN
n=1 I(xn ∈ R1)
(18.2)
Formally, a regression tree can be defined by
f(x; θ) = X
J
j=1
wj I(x ∈ Rj ) (18.3)
1. By using enough splits (i.e., deep enough trees), we can make a piecewise linear approximation to decision boundaries
with more complex shapes, but it may require a lot of data to fit such a model.598 Chapter 18. Trees, Forests, Bagging, and Boosting
X1 ≤ t1
X2 ≤ t2
R1 X1 ≤ t3
R4 R5
X2 ≤ t4
R2 R3
(a)
X1
0
2
4
6
8
10
X2
0
2
4
6
8
10
Y
2
3
4
5
6
7
8
9
10
(b)
Figure 18.1: (a) A regression tree on two inputs. (b) Corresponding piecewise constant surface. Adapted from
Figure 9.2 of [HTF09]. Generated by code at figures.probml.ai/book1/18.1.
(a) (b)
Figure 18.2: (a) A set of shapes with corresponding binary labels. The features are: color (values “blue”, “red”,
“other”), shape (values “ellipse”, “other”), and size (real-valued). (b) A hypothetical classification tree fitted to
this data. A leaf labeled as (n1, n0) means that there are n1 positive examples that fall into this partition, and
n0 negative examples.
where Rj is the region specified by the j’th leaf node, wj is the predicted output for that node, and
θ = {(Rj , wj ) : j = 1 : J}, where J is the number of nodes. The regions themselves are defined
by the feature dimensions that are used in each split, and the corresponding thresholds, on the
path from the root to the leaf. For example, in Figure 18.1(a), we have R1 = [(d1 ≤ t1),(d2 ≤ t2)],
R2 = [(d1 ≤ t1),(d2 > t2),(d3 ≤ t3)], etc. (For categorical inputs, we can define the splits based
on comparing feature di to each of the possible values for that feature, rather than comparing to a
numeric threshold.) We discuss how to learn these regions in Section 18.1.2.
For classification problems, the leaves contain a distribution over the class labels, rather than just
the mean response. See Figure 18.2 for an example of a classification tree.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202218.1. Classification and regression trees (CART) 599
18.1.2 Model fitting
To fit the model, we need to minimize the following loss:
L(θ) = X
N
n=1
`(yn, f(xn; θ)) = X
J
j=1
X
xn∈Rj
`(yn, wj ) (18.4)
Unfortunately, this is not differentiable, because of the need to learn the discrete tree structure.
Indeed, finding the optimal partitioning of the data is NP-complete [HR76]. The standard practice is
to use a greedy procedure, in which we iteratively grow the tree one node at a time. This approach is
used by CART [BFO84], C4.5 [Qui93], and ID3 [Qui86], which are three popular implementations
of the method.
The idea is as follows. Suppose we are at node i; let Di = {(xn, yn) ∈ Ni} be the set of examples
that reach this node. We will consider how to split this node into a left branch and right branch so
as to minimize the error in each child subtree.
If the j’the feature is a real-valued scalar, we can partition the data at node i by comparing to a
threshold t. The set of possible thresholds Tj for feature j can be obtained by sorting the unique values
of {xnj}. For example, if feature 1 has the values {4.5, −12, 72, −12}, then we set T1 = {−12, 4.5, 72}.
For each possible threshold, we define the left and right splits, DL
i
(j, t) = {(xn, yn) ∈ Ni
: xn,j ≤ t}
and DR
i
(j, t) = {(xn, yn) ∈ Ni
: xn,j > t}.
If the j’th feature is categorical, with Kj possible values, then we check if the feature is equal to
each of those values or not. This defines a set of Kj possible binary splits: DL
i
(j, t) = {(xn, yn) ∈ Ni
:
xn,j = t} and DR
i
(j, t) = {(xn, yn) ∈ Ni
: xn,j 6= t}.) (Alternatively, we could allow for a multi-way
split, as in Figure 18.2(b). However, this may cause data fragmentation, in which too little data
might “fall” into each subtree, resulting in overfitting. Therefore it is more common to use binary
splits.)
Once we have computed DL
i
(j, t) and DR
i
(j, t) for each j and t at node i, we choose the best feature
ji to split on, and the best value for that feature, ti
, as follows:
(ji
, ti) = arg min
j∈{1,...,D}
min
t∈Tj
|DL
i
(j, t)|
|Di
|
c(D
L
i
(j, t)) + |DR
i
(j, t)|
|Di
|
c(D
R
i
(j, t)) (18.5)
We now discuss the cost function c(Di) which is used to evaluate the cost of node i. For regression,
we can use the mean squared error
cost(Di) = 1
|D|
X
n∈Di
(yn − y)
2
(18.6)
where y =
1
|D|
P
n∈Di
yn is the mean of the response variable for examples reaching node i.
For classification, we first compute the empirical distribution over class labels for this node:
πˆic =
1
|Di
|
X
n∈Di
I(yn = c) (18.7)
Given this, we can then compute the Gini index
Gi =
X
C
c=1
πˆic(1 − πˆic) = X
c
πˆic −
X
c
πˆ
2
ic = 1 −
X
c
πˆ
2
ic (18.8)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license600 Chapter 18. Trees, Forests, Bagging, and Boosting
This is the expected error rate. To see this, note that πˆic is the probability a random entry in the
leaf belongs to class c, and 1 − πˆic is the probability it would be misclassified.
Alternatively we can define cost as the entropy or deviance of the node:
Hi = H(πˆi) = −
X
C
c=1
πˆic log ˆπic (18.9)
A node that is pure (i.e., only has examples of one class) will have 0 entropy.
Given one of the above cost functions, we can use Equation (18.5) to pick the best feature, and
best threshold at each node. We then partition the data, and call the fitting algorithm recursively on
each subset of the data.
18.1.3 Regularization
If we let the tree become deep enough, it can achieve 0 error on the training set (assuming no label
noise), by partioning the input space into sufficiently small regions where the output is constant.
However, this will typically result in overfitting. To prevent this, there are two main approaches. The
first is to stop the tree growing process according to some heuristic, such as having too few examples
at a node, or reaching a maximum depth. The second approach is to grow the tree to its maximum
depth, where no more splits are possible, and then to prune it back, by merging split subtrees back
into their parent (see e.g., [BA97b]). This can partially overcome the greedy nature of top-down tree
growing. (For example, consider applying the top-down approach to the xor data in Figure 13.1:
the algorithm would never make any splits, since each feature on its own has no predictive power.)
However, forward growing and backward pruning is slower than the greedy top-down approach.
18.1.4 Handling missing input features
In general, it is hard for discriminative models, such as neural networks, to handle missing input
features, as we discussed in Section 1.5.5. However, for trees, there are some simple heuristics that
can work well.
The standard heuristic for handling missing inputs in decision trees is to look for a series of “backup”
variables, which can induce a similar partition to the chosen variable at any given split; these can be
used in case the chosen variable is unobserved at test time. These are called surrogate splits. This
method finds highly correlated features, and can be thought of as learning a local joint model of the
input. This has the advantage over a generative model of not modeling the entire joint distribution
of inputs, but it has the disadvantage of being entirely ad hoc. A simpler approach, applicable to
categorical variables, is to code “missing” as a new value, and then to treat the data as fully observed.
18.1.5 Pros and cons
Tree models are popular for several reasons:
• They are easy to interpret.
• They can easily handle mixed discrete and continuous inputs.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202218.1. Classification and regression trees (CART) 601
(a)
0 1 2 3 4 5 6 7
petal length (cm)
0.5
0.0
0.5
1.0
1.5
2.0
2.5
3.0
petal width (cm)
setosa
versicolor
virginica
(b)
0 1 2 3 4 5 6 7
petal length (cm)
0.5
0.0
0.5
1.0
1.5
2.0
2.5
3.0
petal width (cm)
setosa
versicolor
virginica
(c)
0 1 2 3 4 5 6 7
petal length (cm)
0.5
0.0
0.5
1.0
1.5
2.0
2.5
3.0
petal width (cm)
setosa
versicolor
virginica
(d)
Figure 18.3: (a) A decision tree of depth 2 fit to the iris data, using just the petal length and petal width
features. Leaf nodes are color coded according to the majority class. The number of training samples that pass
from the root to each node is shown inside each box, as well as how many of these values fall into each class.
This can be normalized to get a distribution over class labels for each node. (b) Decision surface induced by
(a). (c) Fit to data where we omit a single data point (shown by red star). (d) Ensemble of the two models in
(b) and (c). Generated by code at figures.probml.ai/book1/18.3.
• They are insensitive to monotone transformations of the inputs (because the split points are based
on ranking the data points), so there is no need to standardize the data.
• They perform automatic variable selection.
• They are relatively robust to outliers.
• They are fast to fit, and scale well to large data sets.
• They can handle missing input features.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license602 Chapter 18. Trees, Forests, Bagging, and Boosting
However, tree models also have some disadvantages. The primary one is that they do not predict
very accurately compared to other kinds of model. This is in part due to the greedy nature of the
tree construction algorithm.
A related problem is that trees are unstable: small changes to the input data can have large effects
on the structure of the tree, due to the hierarchical nature of the tree-growing process, causing errors
at the top to affect the rest of the tree. For example, consider the tree in Figure 18.3b. Omitting
even a single data point from the training set can result in a dramatically different decision surface,
as shown in Figure 18.3c, due to the use of axis parallel splits. (Omitting features can also cause
instability.) In Section 18.3 and Section 18.4, we will turn this instability into a virtue.
18.2 Ensemble learning
In Section 18.1, we saw that decision trees can be quite unstable, in the sense that their predictions
might vary a lot if the training data is perturbed. In other words, decision trees are a high variance
estimator. A simple way to reduce variance is to average multiple models. This is called ensemble
learning. The result model has the form
f(y|x) = 1
|M|
X
m∈M
fm(y|x) (18.10)
where fm is the m’th base model. The ensemble will have similar bias to the base models, but lower
variance, generally resulting in improved overall performance (see Section 4.7.6.3 for details on the
bias-variance tradeoff).
Averaging is a sensible way to combine predictions from regression models. For classifiers, it can
sometimes be better to take a majority vote of the outputs. (This is sometimes called a committee
method.) To see why this can help, suppose each base model is a binary classifier with an accuracy
of θ, and suppose class 1 is the correct class. Let Ym ∈ {0, 1} be the prediction for the m’th model,
and let S =
PM
m=1 Ym be the number of votes for class 1. We define the final predictor to be the
majority vote, i.e., class 1 if S > M/2 and class 0 otherwise. The probability that the ensemble will
pick class 1 is
p = Pr(S > M/2) = 1 − B(M/2, M, θ) (18.11)
where B(x, M, θ) is the cdf of the binomial distribution with parameters M and θ evaluated at x.
For θ = 0.51 and M = 1000, we get p = 0.73 and with M = 10, 000 we get p = 0.97.
The performance of the voting approach is dramatically improved, because we assumed each
predictor made independent errors. In practice, their mistakes may be correlated, but as long as we
ensemble sufficiently diverse models, we can still come out ahead.
18.2.1 Stacking
An alternative to using an unweighted average or majority vote is to learn how to combine the base
models, by using
f(y|x) = X
m∈M
wmfm(y|x) (18.12)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202218.3. Bagging 603
This is called stacking, which stands for “stacked generalization” [Wol92]. Note that the combination
weights used by stacking need to be trained on a separate dataset, otherwise they would put all their
mass on the best performing base model.
18.2.2 Ensembling is not Bayes model averaging
It is worth noting that an ensemble of models is not the same as using Bayes model averaging over
models (Section 4.6), as pointed out in [Min00]. An ensemble considers a larger hypothesis class of
the form
p(y|x, w, θ) = X
m∈M
wmp(y|x, θm) (18.13)
whereas BMA uses
p(y|x, D) = X
m∈M
p(m|D)p(y|x, m, D) (18.14)
The key difference is that in the case of BMA, the weights p(m|D) sum to one, and in the limit of
infinite data, only a single model will be chosen (namely the MAP model). By contrast, the ensemble
weights wm are arbitrary, and don’t collapse in this way to a single model.
18.3 Bagging
In this section, we discuss bagging [Bre96], which stands for “bootstrap aggregating”. This is a
simple form of ensemble learning in which we fit M different base models to different randomly
sampled versions of the data; this encourages the different models to make diverse predictions. The
datasets are sampled with replacement (a technique known as bootstrap sampling, Section 4.7.3), so
a given example may appear multiple times, until we have a total of N examples per model (where
N is the number of original data points).
The disadvantage of bootstrap is that each base model only sees, on average, 63% of the unique
input examples. To see why, note that the chance that a single item will not be selected from a set
of size N in any of N draws is (1 − 1/N)
N . In the limit of large N, this becomes e
−1 ≈ 0.37, which
means only 1 − 0.37 = 0.63 of the data points will be selected.
The 37% of the training instances that are not used by a given base model are called out-of-bag
instances (oob). We can use the predicted performance of the base model on these oob instances as
an estimate of test set performance. This provides a useful alternative to cross validation.
The main advantage of bootstrap is that it prevents the ensemble from relying too much on any
individual training example, which enhances robustness and generalization [Gra04]. For example,
comparing Figure 18.3b and Figure 18.3c, we see that omitting a single example from the training set
can have a large impact on the decision tree that we learn (even though the tree growing algorithm
is otherwise deterministic). By averaging the predictions from both of these models, we get the more
reasonable prediction model in Figure 18.3d. This advantage generally increases with the size of the
ensemble, as shown in Figure 18.4. (Of course, larger ensembles take more memory and more time.)
Bagging does not always improve performance. In particular, it relies on the base models being
unstable estimators, so that omitting some of the data significantly changes the resulting model fit.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license604 Chapter 18. Trees, Forests, Bagging, and Boosting
1.5 1.0 0.5 0.0 0.5 1.0 1.5 2.0
x1
1.0
0.5
0.0
0.5
1.0
1.5
x2
Decision Tree, test accuracy=0.86
(a)
1.5 1.0 0.5 0.0 0.5 1.0 1.5 2.0
x1
1.0
0.5
0.0
0.5
1.0
1.5
x2
Bag of 10 decision trees, test accuracy=0.91
(b)
1.5 1.0 0.5 0.0 0.5 1.0 1.5 2.0
x1
1.0
0.5
0.0
0.5
1.0
1.5
x2
Bag of 50 decision trees, test accuracy=0.91
(c)
1.5 1.0 0.5 0.0 0.5 1.0 1.5 2.0
x1
1.0
0.5
0.0
0.5
1.0
1.5
x2
Random forest of 50 trees, test accuracy=0.90
(d)
Figure 18.4: (a) A single decision tree. (b-c) Bagging ensemble of 10 and 50 trees. (d) Random forest of 50
trees. Adapted from Figure 7.5 of [Gér19]. Generated by code at figures.probml.ai/book1/18.4.
This is the case for decision trees, but not for other models, such as nearest neighbor classifiers. For
neural networks, the story is more mixed. They can be unstable wrt their training set. On the other
hand, deep networks will underperform if they only see 63% of the data, so bagged DNNs do not
usually work well [NTL20].
18.4 Random forests
Bagging relies on the assumption that re-running the same learning algorithm on different subsets of
the data will result in sufficiently diverse base models. The technique known as random forests
[Bre01] tries to decorrelate the base learners even further by learning trees based on a randomly
chosen subset of input variables (at each node of the tree), as well as a randomly chosen subset of
data cases. It does this by modifying Equation (18.5) so the the feature split dimension j is optimized
over a random subset of the features, Si ⊂ {1, . . . , D}. For example, consider the email spam dataset
[HTF09, p301]. This dataset contains 4601 email messages, each of which is classified as spam (1) or
non-spam (0). The data was open sourced by George Forman from Hewlett-Packard (HP) Labs.
There are 57 quantitative (real-valued) features, as follows:
• 48 features corresponding to the percentage of words in the email that match a given word, such
as “remove” or “labs”.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202218.5. Boosting 605
0 100 200 300 400 500
Number of trees
0.0450
0.0475
0.0500
0.0525
0.0550
0.0575
0.0600
0.0625
Test error
RF
Boosting
Bagging
Figure 18.5: Preditive accuracy vs size of tree ensemble for bagging, random forests and gradient boosting
with log loss. Adapted from Figure 15.1 of [HTF09]. Generated by code at figures.probml.ai/book1/18.5.
• 6 features corresponding to the percentage of characters in the email that match a given character,
namely ; . [ ! $ #
• 3 features corresponding to the average length, max length, and sum of lengths of uninterrupted
sequences of capital letters. (These features are called CAPAVE, CAPMAX and CAPTOT.)
Figure 18.5 shows that random forests work much better than bagged decision trees, because many
input features are irrelevant. (We also see that a method called “boosting”, discussed in Section 18.5,
works even better; however, this requires sequentially fitting trees, whereas random forests can be fit
in parallel.)
18.5 Boosting
Ensembles of trees, whether fit by bagging or the random forest algorithm, corresponding to a model
of the form
f(x; θ) = X
M
m=1
βmFm(x; θm) (18.15)
where Fm is the m’th tree, and βm is the corresponding weight, often set to βm = 1. We can
generalize this by allowing the Fm functions to be general function approximators, such as neural
networks, not just trees. The result is called an additive model [HTF09]. We can think of this as a
linear model with adaptive basis functions. The goal, as usual, is to minimize the empirical loss
(with an optional regularizer):
L(f) = X
N
i=1
`(yi
, f(xi)) (18.16)
Boosting [Sch90; FS96] is an algorithm for sequentially fitting additive models where each Fm
is a binary classifier that returns Fm ∈ {−1, +1}. In particular, we first fit F1 on the original data,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license606 Chapter 18. Trees, Forests, Bagging, and Boosting
and then we weight the data samples by the errors made by F1, so misclassified examples get more
weight. Next we fit F2 to this weighted data set. We keep repeating this process until we have fit
the desired number M of components. (M is a hyper-parameter that controls the complexity of the
overall model, and can be chosen by monitoring performance on a validation set, and using early
stopping.)
It can be shown that, as long as each Fm has an accuracy that is better than chance (even on the
weighted dataset), then the final ensemble of classifiers will have higher accuracy than any given
component. That is, if Fm is a weak learner (so its accuracy is only slightly better than 50%),
then we can boost its performance using the above procedure so that the final f becomes a strong
learner. (See e.g., [SF12] for more details on the learning theory approach to boosting.)
Note that boosting reduces the bias of the strong learner, by fitting trees that depend on each
other, whereas bagging and RF reduce the variance by fitting independent trees. In many cases,
boosting can work better. See Figure 18.5 for an example.
The original boosting algorithm focused on binary classification with a particular loss function
that we will explain in Section 18.5.3, and was derived from the PAC learning theory framework
(see Section 5.4.4). In the rest of this section, we focus on a more statistical version of boosting,
due to [FHT00; Fri01], which works with arbitrary loss functions, making the method suitable for
regression, multi-class classification, ranking, etc. Our presentation is based on [HTF09, ch10] and
[BH07], which should be consulted for further details.
18.5.1 Forward stagewise additive modeling
In this section, we discuss forward stagewise additive modeling, in which we sequentially
optimize the objective in Equation (18.16) for general (differentiable) loss functions, where f is an
additive model as in Equation 18.15. That is, at iteration m, we compute
(βm, θm) = argmin
β,θ
X
N
i=1
`(yi
, fm−1(xi) + βF(xi
; θ)) (18.17)
We then set
fm(x) = fm−1(x) + βmF(x; θm) = fm−1(x) + βmFm(x) (18.18)
(Note that we do not adjust the parameters of previously added models.) The details on how to
perform this optimization step depend on the loss function that we choose, and (in some cases) on
the form of the weak learner F, as we discuss below.
18.5.2 Quadratic loss and least squares boosting
Suppose we use squared error loss, `(y, yˆ) = (y − yˆ)
2
. In this case, the i’th term in the objective at
step m becomes
`(yi
, fm−1(xi) + βF(xi
; θ)) = (yi − fm−1(xi) − βF(xi
; θ))2 = (rim − βF(xi
; θ))2
(18.19)
where rim = yi − fm−1(xi) is the residual of the current model on the i’th observation. We can
minimize the above objective by simply setting β = 1, and fitting F to the residual errors. This is
called least squares boosting [BY03].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202218.5. Boosting 607
0.4 0.2 0.0 0.2 0.4
0.0
0.2
0.4
0.6
0.8
y
Residuals and tree predictions
Training set
F1(x1)
0.4 0.2 0.0 0.2 0.4
0.0
0.2
0.4
0.6
0.8
y
Ensemble predictions
Training set
f1(x1) = F1(x1)
0.4 0.2 0.0 0.2 0.4
0.4
0.2
0.0
0.2
0.4
y
f1(x
1)
Residuals
F2(x1)
0.4 0.2 0.0 0.2 0.4
0.0
0.2
0.4
0.6
0.8
y
f2(x1) = F1(x1) + F2(x1)
0.4 0.2 0.0 0.2 0.4
x1
0.4
0.2
0.0
0.2
0.4
y
f2(x
1)
F3(x1)
0.4 0.2 0.0 0.2 0.4
x1
0.0
0.2
0.4
0.6
0.8
y
f3(x1) = F1(x1) + F2(x1) + F3(x1)
Figure 18.6: Illustration of boosting using a regression tree of depth 2 applied to a 1d dataset. Adapted from
Figure 7.9 of [Gér19]. Generated by code at figures.probml.ai/book1/18.6.
We give an example of this process in Figure 18.6, where we use a regression tree of depth 2 as the
weak learner. On the left, we show the result of fitting the weak learner to the residuals, and on the
right, we show the current strong learner. We see how each new weak learner that is added to the
ensemble corrects the errors made by earlier versions of the model.
18.5.3 Exponential loss and AdaBoost
Suppose we are interested in binary classification, i.e., predicting y˜i ∈ {−1, +1}. Let us assume the
weak learner computes
p(y = 1|x) = e
F (x)
e−F (x) + e
F (x)
=
1
1 + e−2F (x)
(18.20)
so F(x) returns half the log odds. We know from Equation (10.13) that the negative log likelihood is
given by
`(˜y, F(x)) = log(1 + e
−2˜yF (x)
) (18.21)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license608 Chapter 18. Trees, Forests, Bagging, and Boosting
−2.0 −1.5 −1.0 −0.5 0.0 0.5 1.0 1.5 2.0
0.0
0.5
1.0
1.5
2.0
2.5
3.0 0-1 loss
hinge loss
log loss
exp loss
Figure 18.7: Illustration of various loss functions for binary classification. The horizontal axis is the
margin m(x) = yF˜ (x), the vertical axis is the loss. The log loss uses log base 2. Generated by code at
figures.probml.ai/book1/18.7.
We can minimize this by ensuring that the margin m(x) = yF˜ (x) is as large as possible. We see
from Figure 18.7 that the log loss is a smooth upper bound on the 0-1 loss. We also see that it
penalizes negative margins more heavily than positive ones, as desired (since positive margins are
already correctly classified).
However, we can also use other loss functions. In this section, we consider the exponential loss
`(˜y, F(x)) = exp(−yF˜ (x)) (18.22)
We see from Figure 18.7 that this is also a smooth upper bound on the 0-1 loss. In the population
setting (with infinite sample size), the optimal solution to the exponential loss is the same as for log
loss. To see this, we can just set the derivative of the expected loss (for each x) to zero:
∂
∂F(x)
E
h
e
−yf˜ (x)
|x
i
=
∂
∂F(x)
[p(˜y = 1|x)e
−F (x) + p(˜y = −1|x)e
F (x)
] (18.23)
= −p(˜y = 1|x)e
−F (x) + p(˜y = −1|x)e
F (x)
(18.24)
= 0 ⇒
p(˜y = 1|x)
p(˜y = −1|x)
= e
2F (x)
(18.25)
However, it turns out that the exponential loss is easier to optimize in the boosting setting, as we
show below. (We consider the log loss case in Section 18.5.4.) We now discuss how to solve for the
m’th weak learner, Fm, when we use exponential loss. We will assume that the base classifier Fm
returns a binary class label; the resulting algorithm is called discrete AdaBoost [FHT00]. If Fm
returns a probability instead, a modified algorithm, known as real AdaBoost, can be used [FHT00].
At step m we have to minimize
Lm(F) = X
N
i=1
exp[−y˜i(fm−1(xi) + βF(xi))] = X
N
i=1
ωi,m exp(−βy˜iF(xi)) (18.26)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202218.5. Boosting 609
where ωi,m , exp(−y˜ifm−1(xi)) is a weight applied to datacase i, and y˜i ∈ {−1, +1}. We can rewrite
this objective as follows:
Lm = e
−β X
y˜i=F (xi)
ωi,m + e
β X
y˜i6=F (xi)
ωi,m (18.27)
= (e
β − e
−β
)
X
N
i=1
ωi,mI(˜yi 6= F(xi)) + e
−β X
N
i=1
ωi,m (18.28)
Consequently the optimal function to add is
Fm = argmin
F
X
N
i=1
ωi,mI(˜yi 6= F(xi)) (18.29)
This can be found by applying the weak learner to a weighted version of the dataset, with weights
ωi,m.
All that remains is to solve for the size of the update, β. Subsituting Fm into Lm and solving for
β we find
βm =
1
2
log 1 − errm
errm
(18.30)
where
errm =
PN
i=1 ωi,mI(˜yi 6= Fm(xi))
PN
i=1 ωi,m
(18.31)
Therefore overall update becomes
fm(x) = fm−1(x) + βmFm(x) (18.32)
After updating the strong learner, we need to recompute the weights for the next iteration, as
follows:
ωi,m+1 = e
−y˜ifm(xi) = e
−y˜ifm−1(xi)−y˜iβmFm(xi) = ωi,me
−y˜iβmFm(xi)
(18.33)
If y˜i = Fm(xi), then y˜iFm(xi) = 1, and if y˜i 6= Fm(xi), then y˜iFm(xi) = −1. Hence −y˜iFm(xi) =
2I(˜yi 6= Fm(xo)) − 1, so the update becomes
ωi,m+1 = ωi,me
βm(2I(˜yi6=Fm(xi))−1) = ωi,me
2βmI(˜yi6=Fm(xi))e
−βm (18.34)
Since the e
−βm is constant across all examples, it can be dropped. If we then define αm = 2βm, the
update becomes
ωi,m+1 =
(
ωi,me
αm if y˜i 6= Fm(xi)
ωi,m otherwise
(18.35)
Thus we see that we exponentially increase weights of misclassified examples. The resulting algorithm
shown in Algorithm 8, and is known as Adaboost.M1 [FS96].
A multiclass generalization of exponential loss, and an adaboost-like algorithm to minimize it,
known as SAMME (stagewise additive modeling using a multiclass exponential loss function), is
described in [Has+09]. This is implemented in scikit learn (the AdaBoostClassifier class).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license610 Chapter 18. Trees, Forests, Bagging, and Boosting
Algorithm 8: Adaboost.M1, for binary classification with exponential loss
1 ωi = 1/N;
2 for m = 1 : M do
3 Fit a classifier Fm(x) to the training set using weights w;
4 Compute errm =
PN
i=1 ωi,mI(˜yi6=Fm(xi))
PN
i=1 ωi,m
;
5 Compute αm = log[(1 − errm)/errm];
6 Set ωi ← ωi exp[αmI(˜yi 6= Fm(xi))];
7 Return f(x) = sgn hPM
m=1 αmFm(x)
i
;
18.5.4 LogitBoost
The trouble with exponential loss is that it puts a lot of weight on misclassified examples, as is
apparent from the exponential blowup on the left hand side of Figure 18.7. This makes the method
very sensitive to outliers (mislabeled examples). In addition, e
−yf˜
is not the logarithm of any pmf
for binary variables y˜ ∈ {−1, +1}; consequently we cannot recover probability estimates from f(x).
A natural alternative is to use log loss, as we discussed in Section 18.5.3. This only punishes
mistakes linearly, as is clear from Figure 18.7. Furthermore, it means that we will be able to extract
probabilities from the final learned function, using
p(y = 1|x) = e
f(x)
e−f(x) + e
f(x)
=
1
1 + e−2f(x)
(18.36)
The goal is to minimze the expected log-loss, given by
Lm(F) = X
N
i=1
log [1 + exp (−2˜yi(fm−1(x) + F(xi)))] (18.37)
By performing a Newton update on this objective (similar to IRLS), one can derive the algorithm
shown in Algorithm 9. This is known as logitBoost [FHT00]. The key subroutine is the ability of
the weak learner F to solve a weighted least squares problem. This method can be generalized to the
multi-class setting, as explained in [FHT00].
18.5.5 Gradient boosting
Rather than deriving new versions of boosting for every different loss function, it is possible to derive
a generic version, known as gradient boosting [Fri01; Mas+00]. To explain this, imagine solving
fˆ = argminf L(f) by performing gradient descent in the space of functions. Since functions are infinite
dimensional objects, we will represent them by their values on the training set, f = (f(x1), . . . , f(xN )).
At step m, let gm be the gradient of L(f) evaluated at f = fm−1:
gim =

∂`(yi
, f(xi))
∂f(xi)

f=fm−1
(18.38)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202218.5. Boosting 611
Algorithm 9: LogitBoost, for binary classification with log-loss
1 ωi = 1/N, πi = 1/2;
2 for m = 1 : M do
3 Compute the working response zi =
y
∗
i −πi
πi(1−πi)
;
4 Compute the weights ωi = πi(1 − πi);
5 Fm = argminF
PN
i=1 ωi(zi − F(xi))2
;
6 Update f(x) ← f(x) + 1
2
Fm(x);
7 Compute πi = 1/(1 + exp(−2f(xi)));
8 Return f(x) = sgn hPM
m=1 Fm(x)
i
;
Name Loss −∂`(yi
, f(xi))/∂f(xi)
Squared error 1
2
(yi − f(xi))2 yi − f(xi)
Absolute error |yi − f(xi)| sgn(yi − f(xi))
Exponential loss exp(−y˜if(xi)) −y˜i exp(−y˜if(xi))
Binary Logloss log(1 + e
−y˜ifi ) yi − πi
Multiclass logloss −
P
c
yic log πic yic − πic
Table 18.1: Some commonly used loss functions, their gradients, and their population minimizers F
∗
. For
binary classification problems, we assume y˜i ∈ {−1, +1}, and πi = σ(2f(xi)). For regression problems, we
assume yi ∈ R. Adapted from [HTF09, p360] and [BH07, p483].
Gradients of some common loss functions are given in Table 18.1. We then make the update
fm = fm−1 − βmgm (18.39)
where βm is the step length, chosen by
βm = argmin
β
L(fm−1 − βgm) (18.40)
In its current form, this is not much use, since it only optimizes f at a fixed set of N points, so we
do not learn a function that can generalize. However, we can modify the algorithm by fitting a weak
learner to approximate the negative gradient signal. That is, we use this update
Fm = argmin
F
X
N
i=1
(−gim − F(xi))2
(18.41)
The overall algorithm is summarized in Algorithm 10. We have omitted the line search step for βm,
which is not strictly necessary, as argued in [BH07]. However, we have introduced a learning rate or
shrinkage factor 0 < ν ≤ 1, to control the size of the updates, for regularization purposes.
If we apply this algorithm using squared loss, we recover L2Boosting, since −gim = yi − fm−1(xi)
is just the residual error. We can also apply this algorithm to other loss functions, such as absolute
loss or Huber loss (Section 5.1.5.3), which is useful for robust regression problems.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license612 Chapter 18. Trees, Forests, Bagging, and Boosting
Algorithm 10: Gradient boosting
1 Initialize f0(x) = argminF
PN
i=1 L(yi
, F(xi));
2 for m = 1 : M do
3 Compute the gradient residual using rim = −
h
∂L(yi,f(xi))
∂f(xi)
i
f(xi)=fm−1(xi)
4 Use the weak learner to compute Fm = argminF
PN
i=1(rim − F(xi))2
;
5 Update fm(x) = fm−1(x) + νFm(x);
6 Return f(x) = fM(x)
For classification, we can use log-loss. In this case, we get an algorithm known as BinomialBoost
[BH07]. The advantage of this over LogitBoost is that it does not need to be able to do weighted
fitting: it just applies any black-box regression model to the gradient vector. To apply this to
multi-class classification, we can fit C separate regression trees, using the pseudo residual of the form
−gicm =
∂`(yi
, f1m(xi), . . . , fCm(xi))
∂fcm(xi)
= I(yi = c) − πic (18.42)
Although the trees are fit separately, their predictions are combined via a softmax transform
p(y = c|x) = e
fc(x)
PC
c
0=1 e
fc0 (x)
(18.43)
When we have large datasets, we can use a stochastic variant in which we subsample (without
replacement) a random fraction of the data to pass to the regression tree at each iteration. This is
called stochastic gradient boosting [Fri99]. Not only is it faster, but it can also generalize better,
because subsampling the data is a form of regularization.
18.5.5.1 Gradient tree boosting
In practice, gradient boosting nearly always assumes that the weak learner is a regression tree, which
is a model of the form
Fm(x) = X
Jm
j=1
wjmI(x ∈ Rjm) (18.44)
where wjm is the predicted output for region Rjm. (In general, wjm could be a vector.) This
combination is called gradient boosted regression trees, or gradient tree boosting. (A
related version is known as MART, which stands for “multivariate additive regression trees” [FM03].)
To use this in gradient boosting, we first find good regions Rjm for tree m using standard regression
tree learning (see Section 18.1) on the residuals; we then (re)solve for the weights of each leaf by
solving
wˆjm = argmin
w
X
xi∈Rjm
`(yi
, fm−1(xi) + w) (18.45)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202218.5. Boosting 613
For squared error (as used by gradient boosting), the optimal weight wˆjm is the just the mean of the
residuals in that leaf.
18.5.5.2 XGBoost
XGBoost (https://github.com/dmlc/xgboost), which stands for “extreme gradient boosting”, is
a very efficient and widely used implementation of gradient boosted trees, that adds a few more
improvements beyond the description in Section 18.5.5.1. The details can be found in [CG16], but
in brief, the extensions are as follows: it adds a regularizer on the tree complexity, it uses a second
order approximation of the loss (from [FHT00]) instead of just a linear approximation, it samples
features at internal nodes (as in random forests), and it uses various computer science methods (such
as handling out-of-core computation for large datasets) to ensure scalability.2
In more detail, XGBoost optimizes the following regularized objective
L(f) = X
N
i=1
`(yi
, f(xi)) + Ω(f) (18.46)
where
Ω(f) = γJ +
1
2
λ
X
J
j=1
w
2
j
(18.47)
is the regularizer, where J is the number of leaves, and γ ≥ 0 and λ ≥ 0 are regularization coefficients.
At the m’th step, the loss is given by
Lm(Fm) = X
N
i=1
`(yi
, fm−1(xi) + Fm(xi)) + Ω(Fm) + const (18.48)
We can compute a second order Taylor expansion of this as follows:
Lm(Fm) ≈
X
N
i=1

`(yi
, fm−1(xi)) + gimFm(xi) + 1
2
himF
2
m(xi)

+ Ω(Fm) + const (18.49)
where him is the Hessian
him =

∂
2
`(yi
, f(xi))
∂f(xi)
2

f=fm−1
(18.50)
In the case of regression trees, we have F(x) = wq(x)
, where q : R
D → {1, . . . , J} specifies which
leaf node x belongs to, and w ∈ R
J are the leaf weights. Hence we can rewrite Equation (18.49) as
2. Some other popular gradient boosted trees packages are CatBoost (https://catboost.ai/) and LightGBM
(https://github.com/Microsoft/LightGBM).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license614 Chapter 18. Trees, Forests, Bagging, and Boosting
follows, dropping terms that are independent of Fm:
Lm(q, w) ≈
X
N
i=1

gimFm(xi) + 1
2
himF
2
m(xi)

+ γJ +
1
2
λ
X
J
j=1
w
2
j
(18.51)
=
X
J
j=1

(
X
i∈Ij
gim)wj +
1
2
(
X
i∈Ij
hi + λ)w
2
j

 + γJ (18.52)
where Ij = {i : q(xi) = j} is the set of indices of data points assigned to the j’th leaf.
Let us define Gjm =
P
i∈Ij
gim and Hjm =
P
i∈Ij
him. Then the above simplifies to
Lm(q, w) = X
J
j=1

Gjmwj +
1
2
(Hjm + λ)w
2
j

+ γJ (18.53)
This is a quadratic in each wjm so the optimal weights are given by
w
∗
j = −
Gjm
Hjm + λ
(18.54)
The loss for evaluating different tree structures q then becomes
Lm(q, w∗
) = −
1
2
X
J
j=1
G2
jm
Hjm + λ
+ γJ (18.55)
We can greedily optimize this using a recursive node splitting procedure, as in Section 18.1.
Specifically, for a given leaf j, we consider splitting it into a left and right half, I = IL ∪ IR. We can
compute the gain (reduction in loss) of such a split as follows:
gain =
1
2

G2
L
HL + λ
+
G2
R
HR + λ
−
(GL + GR)
2
(HL + HR) + λ

− γ (18.56)
where GL =
P
i∈IL
gim, GR =
P
i∈IR
gim, HL =
P
i∈IL
him, and HR =
P
i∈IR
him. Thus we see
that it is not worth splitting a node if the gain is negative (i.e., the first term is less than γ).
A fast approximation for evaluating this objective, that does not require sorting the features (for
choosing the optimal threshold to split on), is described in [CG16].
18.6 Interpreting tree ensembles
Trees are popular because they are interpretable. Unfortunately, ensembles of trees (whether in the
form of bagging, random forests, or boosting) lose that property. Fortunately, there are some simple
methods we can use to interpret what function has been learned.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202218.6. Interpreting tree ensembles 615
Not important
Very important
Figure 18.8: Feature importance of a random forest classifier trained to distinguish MNIST digits from classes
0 and 8. Adapted from Figure 7.6 of [Gér19]. Generated by code at figures.probml.ai/book1/18.8.
18.6.1 Feature importance
For a single decision tree T , [BFO84] proposed the following measure for feature importance of
feature k:
Rk(T) =
J
X−1
j=1
Gj I(vj = k) (18.57)
where the sum is over all non-leaf (internal) nodes, Gj is the gain in accuracy (reduction in cost) at
node j, and vj = k if node j uses feature k. We can get a more reliable estimate by averaging over
all trees in the ensemble:
Rk =
1
M
X
M
m=1
Rk(Tm) (18.58)
After computing these scores, we can normalize them so the largest value is 100%. We give some
examples below.
Figure 18.8 gives an example of estimating feature importance for a classifier trained to distinguish
MNIST digits from classes 0 and 8. We see that it focuses on the parts of the image that differ
between these classes.
In Figure 18.9, we plot the relative importance of each of the features for the spam dataset
(Section 18.4). Not surprisingly, we find that the most important features are the words “george”
(the name of the recipient) and “hp” (the company he worked for), as well as the characters ! and $.
(Note it can be the presence or absence of these features that is informative.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license616 Chapter 18. Trees, Forests, Bagging, and Boosting
0 20 40 60 80 100
Relative Importance
george
hp
ch!
remove
ch$
edu
CAPAVE
free
CAPMAX
CAPTOT
re
your
our
1999
you
business
money
meeting
will
hpl
000
ch(
email
internet
85
receive
project
650
over
conference
pm
order
address
make
ch#
font
cs
people
ch_;
mail
all
lab
original
ch[
data
technology
direct
parts
telnet
labs
report
3d
credit
addresses
table
857
415
Figure 18.9: Feature importance of a gradient boosted classifier trained to distinguish spam from non-spam
email. The dataset has X training examples with Y features, corresponding to token frequency. Adapted from
Figure 10.6 of [HTF09]. Generated by code at figures.probml.ai/book1/18.9.
0.0 0.5 1.0
ch!
0.4
0.2
Partial Dependance
0.0 0.5
remove
0.4
0.2
Partial Dependance
0.0 0.5 1.0
edu
0.8
0.6
0.4
Partial Dependance
0 2
hp
0.75
0.50
Partial Dependance
(a)
hp
0.5 0.0 1.5 1.0 2.5 2.0 3.0
ch!
0.0
0.2
0.4
0.6
0.8
1.0
1.0
0.8
0.6
0.4
0.2
0.0
(b)
Figure 18.10: (a) Partial dependence of log-odds of the spam class for 4 important predictors. The red ticks
at the base of the plot are deciles of the empirical distribution for this feature. (b) Joint partial dependence
of log-odds on the features hp and !. Adapted from Figure 10.6–10.8 of [HTF09]. Generated by code at
figures.probml.ai/book1/18.10.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202218.6. Interpreting tree ensembles 617
18.6.2 Partial dependency plots
After we have identified the most relevant input features, we can try to assess the impact they have
on the output. A partial dependency plot for feature k is a plot of
f k
(xk) = 1
N
X
N
n=1
f(xn,−k, xk) (18.59)
vs xk. Thus we marginalize out all features except k. In the case of a binary classifier, we can
convert this to log odds, log p(y = 1|xk)/p(y = 0|xk), before plotting. We illustrate this for our spam
example in Figure 18.10a for 4 different features. We see that as the frequency of ! and “remove”
increases, so does the probability of spam. Conversely, as the frequency of “edu” or “hp” increases,
the probability of spam decreases.
We can also try to capture interaction effects between features j and k by computing
fjk(xj , xk) = 1
N
X
N
n=1
f(xn,−jk, xj , xk) (18.60)
We illustrate this for our spam example in Figure 18.10b for hp and !. We see that higher frequency
of ! makes it more likely to be spam, but much more so if the word “hp” is missing.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensePart V
Beyond Supervised Learning19 Learning with Fewer Labeled Examples
Many ML models, especially neural networks, often have many more parameters than we have
labeled training examples. For example, a ResNet CNN (Section 14.3.4) with 50 layers has 23 million
parameters. Transformer models (Section 15.5) can be even bigger. Of course these parameters are
highly correlated, so they are not independent “degrees of freedom”. Nevertheless, such big models
are slow to train and, more importantly, they may easily overfit. This is particularly a problem
when you do not have a large labeled training set. In this chapter, we discuss some ways to tackle
this issue, beyond the generic regularization techniques we discussed in Section 13.5 such as early
stopping, weight decay and dropout.
19.1 Data augmentation
Suppose we just have a single small labeled dataset. In some cases, we may be able to create
artificially modified versions of the input vectors, which capture the kinds of variations we expect to
see at test time, while keeping the original labels unchanged. This is called data augmentation.
1
We give some examples below, and then discuss why this approach works.
19.1.1 Examples
For image classification tasks, standard data augmentation methods include random crops, zooms,
and mirror image flips, as illustrated in Figure 19.1. [GVZ16] gives a more sophisticated example,
where they render text characters onto an image in a realistic way, thereby creating a very large
dataset of text “in the wild”. They used this to train a state of the art visual text localization and
reading system. Other examples of data augmentation include artifically adding background noise to
clean speech signals, and artificially replacing characters or words at random in text documents.
If we afford to train and test the model many times using different versions of the data, we can
learn which augmentations work best, using blackbox optimization methods such as RL (see e.g.,
[Cub+19]) or Bayesian optimization (see e.g., [Lim+19]); this is called AutoAugment. We can also
learn to combine multiple augmentations together; this is called AutoAugment [Cub+19].
For some examples of augmentation in NLP, see e.g., [Fen+21].
1. The term “data augmentation” is also used in statistics to mean the addition of auxiliary latent variables to a model
in order to speed up convergence of posterior inference algorithms [DM01].622 Chapter 19. Learning with Fewer Labeled Examples
Figure 19.1: Illustration of random crops and zooms of a image images. Generated by code at fig￾ures.probml.ai/book1/19.1.
19.1.2 Theoretical justification
Data augmentation often significantly improves performance (predictive accuracy, robustness, etc). At
first this might seem like we are getting something for nothing, since we have not provided additional
data. However, the data augmentation mechanism can be viewed as a way to algorithmically inject
prior knowledge.
To see this, recall that in standard ERM training, we minimize the empirical risk
R(f) = Z
`(f(x), y)p
∗
(x, y)dxdy (19.1)
where we approximate p
∗
(x, y) by the empirical distribution
pD(x, y) = 1
N
X
N
n=1
δ(x − xn)δ(y − yn) (19.2)
We can think of data augmentation as replacing the empirical distribution with the following
algorithmically smoothed distribution
pD(x, y|A) = 1
N
X
N
n=1
p(x|xn, A)δ(y − yn) (19.3)
where A is the data augmentation algorithm, which generates a sample x from a training point xn,
such that the label (“semantics”) is not changed. (A very simple example would be a Gaussian kernel,
p(x|xn, A) = N (x|xn, σ2
I).) This has been called vicinal risk minimization [Cha+01], since we
are minimizing the risk in the vicinity of each training point x. For more details on this perspective,
see [Zha+17b; CDL19; Dao+19].
19.2 Transfer learning
This section is coauthored with Colin Raffel.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202219.2. Transfer learning 623
Figure 19.2: Illustration of fine-tuning a model on a new dataset. The final output layer is trained from
scratch, since it might correspond to a different label set. The other layers are initialized at their previous
parameters, and then optionally updated using a small learning rate. From Figure 13.2.1 of [Zha+20]. Used
with kind permission of Aston Zhang.
Many data-poor tasks have some high-level structural similarity to other data-rich tasks. For
example, consider the task of fine-grained visual classification of endangered bird species. Given
that endangered birds are by definition rare, it is unlikely that a large quantity of diverse labeled
images of these birds exist. However, birds bear many structural similarities across species - for
example, most birds have wings, feathers, beaks, claws, etc. We therefore might expect that first
training a model on a large dataset of non-endangered bird species and then continuing to train it on
a small dataset of endangered species could produce better performance than training on the small
dataset alone.
This is called transfer learning, since we are transferring information from one dataset to another,
via a shared set of parameters. More precisely, we first perform a pre-training phase, in which we
train a model with parameters θ on a large source dataset Dp; this may be labeled or unlabeled.
We then perform a second fine-tuning phase on the small labeled target dataset Dq of interest.
We discuss these two phases in more detail below, but for more information, see e.g., [Tan+18;
Zhu+21] for recent surveys.
19.2.1 Fine-tuning
Suppose, for now, that we already have a pretrained classifier, p(y|x, θp), such as a CNN, that works
well for inputs x ∈ Xp (e.g. natural images) and outputs y ∈ Yp (e.g., ImageNet labels), where the
data comes from a distribution p(x, y) similar to the one used in training. Now we want to create a
new model q(y|x, θq) that works well for inputs x ∈ Xq (e.g. bird images) and outputs y ∈ Yq (e.g.,
fine-grained bird labels), where the data comes from a distribution q(x, y) which may be different
from p.
We will assume that the set of possible inputs is the same, so Xq ≈ Xp (e.g., both are RGB images),
or that we can easily transform inputs from domain p to domain q (e.g., we can convert an RGB
image to grayscale by dropping the chrominance channels and just keeping luminance). (If this is not
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license624 Chapter 19. Learning with Fewer Labeled Examples
Multi-headed 
attention
Layer Norm
Transformer 
Layer
+
Adapter
2x Feedforward
layer
Layer Norm
+
Adapter
Nonlinearity
Feedforward 
up-project
Feedforward 
down-project
Adapter 
Layer +
(a) (b)
Figure 19.3: (a) Adding adapter layers to a transformer. From Figure 2 of [Hou+19]. Used with kind
permission of Neil Houlsby. (b) Adding adapter layers to a resnet. From Figure 2 of [RBV18]. Used with
kind permission of Sylvestre-Alvise Rebuffi.
the case, then we may need to use a method called domain adaptation, that modifies models to map
between modalities, as discussed in Section 19.2.5.)
However, the output domains are usually different, i.e., Yq 6= Yp. For example, Yp might be
Imagenet labels and Yq might be medical labels (e.g., types of diabetic retinopathy [Arc+19]). In
this case, we need to “translate” the output of the pre-trained model to the new domain. This
is easy to do with neural networks: we simply “chop off” the final layer of the original model,
and add a new “head” to model the new class labels, as illustrated in Figure 19.2. For example,
suppose p(y|x, θp) = S(y|W2h(x; θ1) + b2), where θp = (W2, b2, θ1). Then we can construct
q(y|θq) = S(y|W3h(x; θ1) + b3), where θq = (W3, b3, θ1) and h(x; θ1) is the shared nonlinear
feature extractor.
After performing this “model surgery”, we can fine-tune the new model with parameters θq =
(θ1, θ3), where θ1 parameterizes the feature extractor, and θ3 parameterizes the final linear layer that
maps features to the new set of labels. If we treat θ1 as “frozen parameters”, then the resulting
model q(y|x, θq) is linear in its parameters, so we have a convex optimization problem for which many
simple and efficient fitting methods exist (see Part II). This is particularly helpful in the long-tail
setting, where some classes are very rare [Kan+20]. However, a linear “decoder” may be too limiting,
so we can also allow θ1 to be fine-tuned as well, but using a lower learning rate, to prevent the values
moving too far from the values estimated on Dp.
19.2.2 Adapters
One disadvantage of fine-tuning all the model parameters of a pre-trained model is that it can be
slow, since there are often many parameters, and we may need to use a small learning rate to prevent
the low-level feature extractors from diverging too far from their prior values. In addition, every new
task requires a new model to be trained, making task sharing hard. An alternative approach is to
keep the pre-trained model untouched, but to add new parameters to modify its internal behavior to
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202219.2. Transfer learning 625
customize the feature extraction process for each task. This idea is called adapters, and has been
explored in several papers (e.g., [RBV17; RBV18; Hou+19]).
Figure 19.3a illustrates adapters for transformer networks (Section 15.5), as proposed in [Hou+19].
The basic idea is to insert two shallow bottleneck MLPs inside each transformer layer, one after
the multi-head attention and once after the feed-forward layers. Note that these MLPs have skip
connections, so that they can be initialized to implement the identity mapping. If the transformer
layer has features of dimensionality D, and the adapter uses a bottleneck of size M, this introduces
O(DM) new parameters per layer. These adapter MLPs, as well as the layer norm parameters
and final output head, are trained for each new task, but the all remaining parameters are frozen.
Empirically on several NLP benchmarks, this is found to give better performance than fine tuning,
while only needing about 1-10% of the original parameters.
Figure 19.3b illustrates adapters for residual networks (Section 14.3.4), as proposed in [RBV17;
RBV18]. The basic idea is to add a 1x1 convolution layer α, which is analogous to the MLP adapter
in the transformer case, to the internal layers of the CNN. This can be added in series or in parallel,
as shown in the diagram. If we denote the adapter layer by ρ(x), we can define the series adapter to
be
ρ(x) = x + diag1
(α) ~ x = diag1
(I + α) ~ x (19.4)
where diag1
(α) ∈ R
1×1×C×D reshapes a matrix α ∈ R
C×D into a matrix that can be applied to each
spatial location in parallel. (We have omitted batch normalization for simplicity.) If we insert this
after a regular convolution layer f ~ x we get
y = ρ(f ~ x) = (diag1
(I + α) ~ f) ~ x (19.5)
This can be interpreted as a low-rank multiplicative perturbation to the original filter f. The parallel
adapter can be defined by
y = f ~ x + diag1
(α) ~ x = (f + diagL(α)) ~ x (19.6)
This can be interpreted as a low-rank additive perturbation to the original filter f. In both cases,
setting α = 0 ensures the adapter layers can be initialized to the identity transformation. In addition,
both methods required O(C
2
) parameters per layer.
19.2.3 Supervised pre-training
The pre-training task may be supervised or unsupervised; the main requirements are that it can
teach the model basic structure about the problem domain and that it is sufficiently similar to
the downstream fine-tuning task. The notion of task similarity is not rigorously defined, but in
practice the domain of the pre-training task is often more broad than that of the fine-tuning task
(e.g., pre-train on all bird species and fine-tune on endangered ones).
The most straightforward form of transfer learning is the case where a large labeled dataset is
suitable for pre-training. For example, it is very common to use the ImageNet dataset (Section 1.5.1.2)
to pretrain CNNs, which can then be used for an a variety of downstream tasks and datasets (see e.g.,
[Kol+19]). Imagenet has 1.28 million natural images, each associated with a label from one of 1,000
classes. The classes constitute a wide variety of different concepts, including animals, foods, buildings,
musical instruments, clothing, and so on. The images themselves are diverse in the sense that they
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license626 Chapter 19. Learning with Fewer Labeled Examples
contain objects from many angles and in many sizes with a wide variety of backgrounds. This diversity
and scale may partially explain why it has become a de-facto pre-training task for transfer learning
in computer vision. (See code.probml.ai/book1/finetune_cnn_torch for some example code.)
However, Imagenet pre-training has been shown to be less helpful when the domain of the fine￾tuning task is quite different from natural images (e.g. medical images [Rag+19]). And in some cases
where it is helpful (e.g., training object detection systems), it seems to be more of a speedup trick
(by warm-starting optimization at a good point) rather than something that is essential, in the sense
that one can achieve comparable performance on the downstream task when training from scratch, if
done for long enough [HGD19].
Supervised pre-training is somewhat less common in non-vision applications. One notable exception
is to pre-train on natural language inference data (i.e. whether a sentence implies or contradicts
another) to learn vector representations of sentences [Con+17], though this approach has largely been
supplanted by unsupervised methods (Section 19.2.4). Another non-vision application of transfer
learning is to pre-train a speech recognition on a large English-labeled corpus before fine-tuning on
low-resource languages [Ard+20].
19.2.4 Unsupervised pre-training (self-supervised learning)
It is increasingly common to use unsupervised pre-training, because unlabeled data is often easy
to acquire, e.g., unlabeled images or text documents from the web.
For a short period of time it was common to pre-train deep neural networks using an unsupervised
objective (e.g., reconstruction error, as discussed in Section 20.3) over the labeled dataset (i.e. ignoring
the labels) before proceeding with standard supervised training [HOT06; Vin+10b; Erh+10]. While
this technique is also called unsupervised pre-training, it differs from the form of pre-training for
transfer learning we discuss in this section, which uses a (large) unlabeled dataset for pre-training
before fine-tuning on a different (smaller) labeled dataset.
Pre-training tasks that use unlabeled data are often called self-supervised rather than unsuper￾vised. This term is used because the labels are created by the algorithm, rather than being provided
externally by a human, as in standard supervised learning. Both supervised and self-supervised
learning are discriminative tasks, since they require predicting outputs given inputs. By contrast,
other unsupervised approaches, such as some of those discussed in Chapter 20, are generative, since
they predict outputs unconditionally.
There are many different self-supervised learning heuristics that have been tried (see e.g., [GR18;
JT19; Ren19] for a review, and https://github.com/jason718/awesome-self-supervised-learning
for an extensive list of papers). We can identify at least three main broad groups, which we discuss
below.
19.2.4.1 Imputation tasks
One approach to self-supervised learning is to solve imputation tasks. In this approach, we partition
the input vector x into two parts, x = (xh, xv), and then try to predict the hidden part xh given
the remaining visible part, xv, using a model of the form xˆh = f(xv, xh = 0). We can think of this
as a “fill-in-the-blank” task; in the NLP community, this is called a cloze task. See Figure 19.4
for some visual examples, and Section 15.7.2 for some NLP examples.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202219.2. Transfer learning 627
(a) (b)
Figure 19.4: (a) Context encoder for self-supervised learning. From [Pat+16]. Used with kind permission
of Deepak Pathak. (b) Some other proxy tasks for self-supervised learning. From [LeC18]. Used with kind
permission of Yann LeCun.
19.2.4.2 Proxy tasks
Another approach to SSL is to solve proxy tasks, also called pretext tasks. In this setup, we
create pairs of inputs, (x1, x2), and then train a Siamese network classifier (Figure 16.5a) of the
form p(y|x1, x2) = p(y|r[f(x1), f(x2)]), where f(x) is some function that performs “representation
learning” [BCV13], and y is some label that captures the relationship between x1 and x2, which
is predicted by r(f1, f2). For example, suppose x1 is an image patch, and x2 = t(x1) is some
transformation of x1 that we control, such as a random rotation; then we define y to be the rotation
angle that we used [GSK18].
19.2.4.3 Contrastive tasks
The currently most popular approach to self-supervised learning is to use various kinds of contrastive
tasks. The basic idea is to create pairs of examples that are semantically similar to each other,
using data augmentation methods (Section 19.1), and then to ensure that the distance between their
representations is closer (in embedding space) than the distance between two unrelated examples.
This is exactly the same idea that is used in deep metric learning (Section 16.2.2) — the only
difference is that the algorithm creates its own similar pairs, rather than relying on an externally
provided measure of similarity, such as labels. We give some examples of this in Section 19.2.4.4 and
Section 19.2.4.5.
19.2.4.4 SimCLR
In this section, we discuss SimCLR, which stands for “Simple contrastive learning of visual repre￾sentations” [Che+20b; Che+20c]. This has shown state of the art performance on transfer learning
and semi-supervised learning. The basic idea is as follows. Each input x ∈ R
D is converted to
two augmented “views’ x1 = t1(x), x2 = t2(x), which are “semantically equivalent” versions of
the input generated by some transformations t1, t2. For example, if x is an image, these could be
small perturbations to the image, such as random crops, as discussed in Section 19.1. In addition,
we sample “negative” examples x
−
1
, . . . , x
−
n ∈ N(x) from the dataset which represent “semantically
different” images (in practice, these are the other examples in the minibatch). Next we define some
feature mapping F : R
D → R
E, where D is the size of the input, and E is the size of the embedding.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license628 Chapter 19. Learning with Fewer Labeled Examples
←− Representation −→
x
x˜i x˜j
hi hj
zi zj
t ∼ T
t
0 ∼ T
r(·) r(·)
g(·) g(·)
Maximize agreement
(a)
A B
(b)
C
D
(c)
Figure 19.5: (a) Illustration of SimCLR training. T is a set of stochastic semantics-preserving transformations
(data augmentations). (b-c) Illustration of the benefit of random crops. Solid rectangles represent the original
image, dashed rectangles are random crops. In (b), the model is forced to predict the local view A from the
global view B (and vice versa). In (c), the model is forced to predict the appearance of adjacent views (C,D).
From Figures 2–3 of [Che+20b]. Used with kind permission of Ting Chen.
(a) (b)
Figure 19.6: Visualization of SimCLR training. Each input image in the minibatch is randomly modified in
two different ways (using cropping (followed by resize), flipping, and color distortion), and then fed into a
Siamese network. The embeddings (final layer) for each pair derived from the same image is forced to be
close, whereas the embeddings for all other pairs are forced to be far. From https: // ai. googleblog. com/
2020/ 04/ advancing-self-supervised-and-semi. html . Used with kind permission of Ting Chen.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202219.2. Transfer learning 629
We then try to maximize the similarity of the similar views, while minimizing the similarity of the
different views, for each input x:
J = F(t1(x))TF(t2(x)) − log X
x
−
i ∈N(x)
exp 
F(x
−
i
)
TF(t1(x))
(19.7)
In practice, we use cosine similarity, so we `2-normalize the representations produced by F before
taking inner products, but this is omitted in the above equation. See Figure 19.5a for an illustration.
(In this figure, we assume F(x) = g(r(x)), where the intermediate representation h = r(x) is the one
that will be later used for fine-tuning, and g is an additional transformation applied during training.)
Interestingly, we can interpret this as a form of conditional energy based model of the form
p(x2|x1) = exp[−E(x2|x1)]
Z(x1)
(19.8)
where E(x2|x1) = −F(x2)
TF(x1) is the energy, and
Z(x) = Z
exp[−E(x
−|x)]dx
− =
Z
exp[F(x
−)
TF(x)]dx
− (19.9)
is the normalization constant, known as the partition function. The conditional log likelihood
under this model has the form
log p(x2|x1) = F(x2)
TF(x1) − log Z
exp[F(x
−)
TF(x1)]dx
− (19.10)
The only difference from Equation (19.7) is that we replace the integral with a Monte Carlo upper
bound derived from the negative samples. Thus we can think of contrastive learning as approximate
maximum likelihood estimation of a conditional energy based generative model [Gra+20]. More
details on such models can be found in the sequel to this book, [Mur22].
A critical ingredient to the success of SimCLR is the choice of data augmentation methods. By
using random cropping, they can force the model to predict local views from global views, as well as
to predict adjacent views of the same image (see Figure 19.5). After cropping, all images are resized
back to the same size. In addition, they randomly flip the image some fraction of the time.2
SimCLR relies on large batch training, in order to ensure a sufficiently diverse set of negatives.
When this is not possible, we can use a memory bank of past (negative) embeddings, which can
be updated using exponential moving averaging (Section 4.4.2.2). This is known as momentum
contrastive learning or MoCo [He+20].
19.2.4.5 CLIP
In this section, we describe CLIP, which stands for “Contrastive Language-Image Pre-training”
[Rad+]. This is an contrastive approach to representation learning which uses a massive corpus of
2. It turns out that distinguishing positive crops (from the same image) from negative crops (from different images) is
often easy to do just based on color histograms. To prevent this kind of “cheating”, they also apply a random color
distortion, thus cutting off this “short circuit”. The combination of random cropping and color distortion is found to
work better than either method alone.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license630 Chapter 19. Learning with Fewer Labeled Examples
(a) (b)
Figure 19.7: Illustration of the CLIP model. From Figure 1 of [Rad+]. Used with kind permission of Alec
Radford.
400M (image, text) pairs extracted from the web. Let xi be the i’th image and yi be its matching
text. Rather than trying to predict the exact words associated with the image, it is simpler to just
determine if yi
is more likely to be the correct text compared to yj , for some other text string j in
the minibatch. Similarly, the model can try to determine if image xi
is more likely to be matched
than xj to a given text yi
.
More precisely, let fI (xi) be the embedding of the image, fT (yj ) be the embedding of the text,
Ii = fI (xi)/||fI (xi)||2 be the unit-norm version of the image embedding, and Tj = fT (yj )/||fT (yj )||2
be the unit-norm version of the text embedding. Define the vector of pairwise logits (similarity scores)
to be
Lij = I
T
i Tj (19.11)
We now train the parameters of the two embedding functions fI and fT to minimize the following
loss, averaged over minibatches of size N:
J =
1
2


X
N
i=1
CE(Li,:
, 1i) +X
N
j=1
CE(L:,j , 1j )

 (19.12)
where CE is the cross entropy loss
CE(p, q) = −
X
K
k=1
pk log qk (19.13)
and 1i
is a one-hot encoding of label i. See Figure 19.7a for an illustration. (In practice, the
normalized embeddings are scaled by a temperature parameter which is also learned; this controls
the sharpness of the softmax.)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202219.2. Transfer learning 631
In their paper, they considered using a ResNet (Section 14.3.4) and a vision transformer (Sec￾tion 15.5.6) for the function fI , and a text transformer (Section 15.5) for fT . They used a very large
minibatch of N ∼ 32k, and trained for many days on 100s of GPUs.
After the model is trained, it can be used for zero-shot classification of an image x as follows.
First each of the K possible class labels for a given dataset is converted into a text string yk that
might occur on the web. For example, “dog” becomes “a photo of a dog”. Second, we compute the
normalized emebddings I ∝ fI (x) and Tk ∝ fT (yk). Third, we compute the softmax probabilites
p(y = k|x) = S([I
TT1, . . . , I
TTk])k (19.14)
See Figure 19.7b for an illustration. (A similar approach was adopted in the visual n-grams paper
[Li+17].)
Remarkably, this approach can perform as well as standard supervised learning on tasks such as
ImageNet classification, without ever being explicitly trained on specific labeled datasets. Of course,
the images in ImageNet come from the web, and were found using text-based web-search, so the
model has seen similar data before. Nevertheless, its generalization to new tasks, and robustness to
distribution shift, are quite impressive (see the paper for examples).
One drawback of the approach, however, is that it is sensitive to how class labels are converted to
textual form. For example, to make the model work on food classification, it is necessary to use text
strings of the form “a photo of guacamole, a type of food”, “a photo of ceviche, a type of food”, etc.
Disambiguating phrases such as “a type of food” are currently added by hand, on a per-dataset basis.
This is called prompt engineering, and is needed since the raw class names can be ambiguous
across (and sometimes within) a dataset.
19.2.5 Domain adaptation
Consider a problem in which we have inputs from different domains, such as a source domain
Xs and target domain Xt, but a common set of output labels, Y. (This is the “dual” of transfer
learning, since the input domains are different, but the output domains the same.) For example, the
domains might be images from a computer graphics system and real images, or product reviews and
movie reviews. We assume we do not have labeled examples from the target domain. Our goal is to
fit the model on the source domain, and then modify its parameters so it works on the target domain.
This is called (unsupervised) domain adaptation (see e.g., [KL21] for a review).
A common approach to this problem is to train the source classifier in such a way that it cannot
distinguish whether the input is coming from the source or target distribution; in this case, it will
only be able to use features that are common to both domains. This is called domain adversarial
learning [Gan+16]. More formally, let dn ∈ {s, t} be a label that specifies if the data example n
comes from domain s or t. We want to optimize
min
φ
max
θ
1
Ns + Nt
X
n∈Ds,Dt
`(dn, fθ(xn)) + 1
Ns
X
m∈Ds
`(ym, gφ(fθ(xm))) (19.15)
where Ns = |Ds|, Nt = |Dt|, f maps Xs ∪ Xt → H, and g maps H → Yt. The objective in
Equation (19.15) minimizes the loss on the desired task of classifying y, but maximizes the loss on
the auxiliary task of classifying the source domain d. This can be implemented by the gradient sign
reversal trick, and is related to GANs (generative adversarial networks). See e.g., [Csu17; Wu+19]
for some other approaches to domain adaptation.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license632 Chapter 19. Learning with Fewer Labeled Examples
(a) (b)
Figure 19.8: Illustration of the benefits of semi-supervised learning for a binary classification problem. Labeled
points from each class are shown as black and white circles respectively. (a) Decision boundary we might
learn given only labeled data. (b) Decision boundary we might learn if we also had a lot of unlabeled data
points, shown as smaller grey circles.
19.3 Semi-supervised learning
This section is co-authored with Colin Raffel.
Many recent successful applications of machine learning are in the supervised learning setting,
where a large dataset of labeled examples are available for training a model. However, in many
practical applications it is expensive to obtain this labeled data. Consider the case of automatic speech
recognition: Modern datasets contain thousands of hours of audio recordings [Pan+15; Ard+20]. The
process of annotating the words spoken in a recording is many times slower than realtime, potentially
resulting in a long (and costly) annotation process. To make matters worse, in some applications
data must be labeled by an expert (such as a doctor in medical applications) which can further
increase costs.
Semi-supervised learning can alleviate the need for labeled data by taking advantage of
unlabeled data. The general goal of semi-supervised learning is to allow the model to learn the
high-level structure of the data distribution from unlabeled data and only rely on the labeled data
for learning the fine-grained details of a given task. Whereas in standard supervised learning we
assume that we have access to samples from the joint distribution of data and labels x, y ∼ p(x, y),
semi-supervised learning assumes that we additionally have access to samples from the marginal
distribution of x, namely x ∼ p(x), as illustrated in Figure 19.8. Further, it is generally assumed that
we have many more of these unlabeled samples since they are typically cheaper to obtain. Continuing
the example of automatic speech recognition, it is often much cheaper to simply record people talking
(which would produce unlabeled data) than it is to transcribe recorded speech. Semi-supervised
learning is a good fit for the scenario where a large amount of unlabeled data has been collected and
the practitioner would like to avoid having to label all of it.
19.3.1 Self-training and pseudo-labeling
An early and straightforward approach to semi-supervised learning is self-training [Scu65; Agr70;
McL75]. The basic idea behind self-training is to use the model itself to infer predictions on unlabeled
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202219.3. Semi-supervised learning 633
data, and then treat these predictions as labels for subsequent training. Self-training has endured
as a semi-supervised learning method because of its simplicity and general applicability; i.e. it is
applicable to any model that can generate predictions for the unlabeled data. Recently, it has become
common to refer to this approach as “pseudo-labeling” [Lee13] because the inferred labels for
unlabeled data are only “pseudo-correct” in comparison with the true, ground-truth targets used in
supervised learning.
Algorithmically, self-training typically follows one of the following two procedures. In the first
approach, pseudo-labels are first predicted for the entire collection of unlabeled data and the model
is re-trained (possibly from scratch) to convergence on the combination of the labeled and (pseudo￾labeled) unlabeled data. Then, the unlabeled data is re-labeled by the model and the process repeats
itself until a suitable solution is found. The second approach instead continually generates predictions
on randomly-chosen batches of unlabeled data and immediately trains the model against these
pseudo-labels. Both approaches are currently common in practice; the first “offline” variant has been
shown to be particularly successful when leveraging giant collections of unlabeled data [Yal+19;
Xie+20] whereas the “online” approach is often used as one component of more sophisticated semi￾supervised learning methods [Soh+20]. Neither variant is fundamentally better than the other. Offline
self-training can result in training the model on “stale” pseudo-labels, since they are only updated
each time the model converges. However, online pseudo-labeling can incur larger computational costs
since it involves constantly “re-labeling” unlabeled data.
Self-training can suffer from an obvious problem: If the model generates incorrect predictions for
unlabeled data and then is re-trained on these incorrect predictions, it can become progressively
worse and worse at the intended classification task until it eventually learns a totally invalid solution.
This issue has been dubbed confirmation bias [TV17] because the model is continually confirming
its own (incorrect) bias about the decision rule.
A common way to mitigate confirmation bias is to use a “selection metric” [RHS05] which
heuristically tries to only retain pseudo-labels that are correct. For example, assuming that a
model outputs probabilities for each possible class, a frequently-used selection metric is to only retain
pseudo-labels whose largest class probability is above a threshold [Yar95; RHS05]. If the model’s
class probability estimates are well-calibrated, then this selection metric will only retain labels that
are highly likely to be correct (according to the model, at least). More sophisticated selection metrics
can be designed according to the problem domain.
19.3.2 Entropy minimization
Self-training has the implicit effect of encouraging the model to output low-entropy (i.e. high￾confidence) predictions. This effect is most apparent in the online setting with a cross-entropy loss,
where the model minimizes the following loss function L on unlabeled data:
L = − max
c
log pθ(y = c|x) (19.16)
where pθ(y|x) is the model’s class probability distribution given input x. This function is minimized
when the model assigns all of its class probability to a single class c
∗
, i.e. p(y = c
∗
|x) = 1 and
p(y 6= c
∗
)|x) = 0.
A closely-related semi-supervised learning method is entropy minimization [GB05], which
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license634 Chapter 19. Learning with Fewer Labeled Examples
8 4 0 4 8
0.0
0.2
0.4
0.6
0.8
Entropy minimization
Self-training
Sharpened (T = ½)
Figure 19.9: Comparison of the entropy minimization, self-training, and “sharpened” entropy minimization
loss functions for a binary classification problem.
minimizes the following loss function:
L = −
X
C
c=1
pθ(y = c|x) log pθ(y = c|x) (19.17)
Note that this function is also minimized when the model assigns all of its class probability to a
single class. We can make the entropy-minimization loss in Equation (19.17) equivalent to the online
self-training loss in Equation (19.16) by replacing the first pθ(y = c|x) term with a “one-hot” vector
that assigns a probability of 1 for the class that was assigned the highest probability. In other words,
online self-training minimizes the cross-entropy between the model’s output and the “hard” target
arg max pθ(y|x), whereas entropy minimization uses the the “soft” target pθ(y|x). One way to trade
off between these two extremes is to adjust the “temperature” of the target distribution by raising
each probability to the power of 1/T and renormalizing; this is the basis of the mixmatch method
of [Ber+19a; Ber+19b; Xie+19]. At T = 1, this is equivalent to entropy minimization; as T → 0, it
becomes hard online self-training. A comparison of these loss functions is shown in Figure 19.9.
19.3.2.1 The cluster assumption
Why is entropy minimization a good idea? A basic assumption of many semi-supervised learning
methods is that the decision boundary between classes should fall in a low-density region of the
data manifold. This effectively assumes that the data corresponding to different classes are clustered
together. A good decision boundary, therefore, should not pass through clusters; it should simply
separate them. Semi-supervised learning methods that make the “cluster assumption” can be
thought of as using unlabeled data to estimate the shape of the data manifold and moving the
decision boundary away from it.
Entropy minimization is one such method. To see why, first assume that the decision boundary
between two classes is “smooth”, i.e. the model does not abruptly change its class prediction anywhere
in its domain. This is true in practice for simple and/or regularized models. In this case, if the
decision boundary passes through a high-density region of data, it will by necessity produce high￾entropy predictions for some samples from the data distribution. Entropy minimization will therefore
encourage the model to place its decision boundary in low-density regions of the input space to
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202219.3. Semi-supervised learning 635
(a) (b)
Figure 19.10: Visualization demonstrating how entropy minimization enforces the cluster assumption. The
classifier assigns a higher probability to class 1 (black dots) or 2 (white dots) in red or blue regions respectively.
The predicted class probabilities for one particular unlabeled datapoint is shown in the bar plot. In (a), the
decision boundary passes through high-density regions of data, so the classifier is forced to output high-entropy
predictions. In (b), the classifier avoids high-density regions and is able to assign low-entropy predictions to
most of the unlabeled data.
avoid transitioning from one class to another in a region of space where data may be sampled. A
visualization of this behavior is shown in Figure 19.10.
19.3.2.2 Input-output mutual information
An alternative justification for the entropy minimization objective was proposed by Bridle, Heading,
and MacKay [BHM92], where it was shown that it naturally arises from maximizing the mutual
information (Section 6.3) between the data and the label (i.e. the input and output of a model).
Denoting x as the input and y as the target, the input-output mutual information can be written as
I(y; x) = Z Z p(y, x) log p(y, x)
p(y)p(x)
dydx (19.18)
=
Z Z p(y|x)p(x) log p(y, x)
p(y)p(x)
dydx (19.19)
=
Z
p(x)dx
Z
p(y|x) log p(y|x)
p(y)
dy (19.20)
=
Z
p(x)dx
Z
p(y|x) log p(y|x)
R
p(x)p(y|x)dx
dy (19.21)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license636 Chapter 19. Learning with Fewer Labeled Examples
Note that the first integral is equivalent to taking an expectation over x, and the second integral is
equivalent to summing over all possible values of the class y. Using these relations, we obtain
I(y; x) = Ex
"X
L
i=1
p(yi
|x) log p(yi
|x)
Ex[p(yi
|x)]#
(19.22)
= Ex
"X
L
i=1
p(yi
|x) log p(yi
|x)
#
− Ex
"X
L
i=1
p(yi
|x) log Ex[p(yi
|x)]#
(19.23)
= Ex
"X
L
i=1
p(yi
|x) log p(yi
|x)
#
−
X
L
i=1
Ex[p(yi
|x) log Ex[p(yi
|x)]] (19.24)
Since we had initially sought to maximize the mutual information, and we typically minimize loss
functions, we can convert this to a suitable loss function by negating it:
I(y; x) = −Ex
"X
L
i=1
p(yi
|x) log p(yi
|x)
#
+
X
L
i=1
Ex[p(yi
|x) log Ex[p(yi
|x)]] (19.25)
The first term is exactly the entropy minimization objective in expectation. The second term specifies
that we should maximize the entropy of the expected class prediction, i.e. the average class prediction
over our training set. This encourages the model to predict each possible class with equal probability,
which is only appropriate when we know a priori that all classes are equally likely.
19.3.3 Co-training
Co-training [BM98] is also similar to self-training, but makes an additional assumption that there
are two complementary “views” (i.e. independent sets of features) of the data, both of which can
be used separately to train a reasonable model. After training two models separately on each view,
unlabeled data is classified by each model to obtain candidate pseudo-labels. If a particular pseudo￾label receives a low-entropy prediction (indicating high confidence) from one model and a high-entropy
prediction (indicating low confidence) from the other, then that pseudo-labeled datapoint is added to
the training set for the low-confidence model. Then, the process is repeated with the new, larger
training datasets. The procedure of only retaining pseudo-labels when one of the models is confident
ideally builds up the training sets with correctly-labeled data.
Co-training makes the strong assumption that there are two informative-but-independent views
of the data, which may not be true for many problems. The Tri-Training algorithm [ZL05]
circumvents this issue by instead using three models that are first trained on independently-sampled
(with replacement) subsets of the labeled data. Ideally, initially training on different collections of
labeled data results in models that do not always agree on their predictions. Then, pseudo-labels are
generated for the unlabeled data independently by each of the three models. For a given unlabeled
datapoint, if two of the models agree on the pseudo-label, it is added to the training set for the
third model. This can be seen as a selection metric, because it only retains pseudo-labels where
two (differently initialized) models agree on the correct label. The models are then re-trained on
the combination of the labeled data and the new pseudo-labels, and the whole process is repeated
iteratively.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202219.3. Semi-supervised learning 637
19.3.4 Label propagation on graphs
If two datapoints are “similar” in some meaningful way, we might expect that they share a label. This
idea has been referred to as the manifold assumption. Label propagation is a semi-supervised
learning technique that leverages the manifold assumption to assign labels to unlabeled data. Label
propagation first constructs a graph where the nodes are the data examples and the edge weights
represent the degree of similarity. The node labels are known for nodes corresponding to labeled data
but are unknown for unlabeled data. Label propagation then propagates the known labels across
edges of the graph in such a way that there is minimal disagreement in the labels of a given node’s
neighbors. This provides label guesses for the unlabeled data, which can then be used in the usual
way for supervised training of a model.
More specifically, the basic label propagation algorithm [ZG02] proceeds as follows: First, let
wi,j denote a non-negative edge weight between xi and xj that provides a measure of similarity for
the two (labeled or unlabeled) datapoints. Assuming that we have M labeled datapoints and N
unlabeled datapoints, define the (M + N) × (M + N) transition matrix T as having entries
Ti,j = P
wi,j
k wk,j
(19.26)
Ti,j represents the probability of propagating the label for node j to node i. Further, define the
(M + N) × C label matrix Y, where C is the number of possible classes. The ith row of Y represents
the class probability distribution of datapoint i. Then, repeat the following steps until the values in
Y do not change significantly: First, use the transition matrix T to propagate labels in Y by setting
Y ← TY. Then, re-normalize the rows of Y by setting Yi,c ← Yi,c/
P
k Yi,k. Finally, replace the
rows of Y corresponding to labeled datapoints with their one-hot representation (i.e. Yi,c = 1 if
datapoint i has ground-truth label c and 0 otherwise). After convergence, guessed labels are chosen
based on the highest class probability for each datapoint in Y.
This algorithm iteratively uses the similarity of datapoints (encoded in the weights used to construct
the transition matrix) to propagate information from the (fixed) labels onto the unlabeled data. At
each iteration, the label distribution for a given datapoint is computed as the weighted average of
the label distributions for all of its connected datapoints, where the weighting corresponds to the
edge weights in T. It can be shown that this procedure converges to a single fixed point, whose
computational cost mainly involves the inversion of the matrix of unlabled-to-unlabled transition
probabilities [ZG02].
The overall approach can be seen as a form of transductive learning, since it is learning to
predict labels for a fixed unlabeled dataset, rather than learning a model that generalizes. However,
given the induced labeling. we can perform inductive learning in the usual way.
The success of label propagation depends heavily on the notion of similarity used to construct the
weights between different nodes (datapoints). For simple data, measuring the Euclidean distance
between datapoints can be sufficient. However, for complex and high-dimensional data the Euclidean
distance might not meaningfully reflect the likelihood that two datapoints share the same class. The
similarity weights can also be set arbitrarily according to problem-specific knowledge. For a few
examples of different ways of constructing the similarity graph, see Zhu [Zhu05, chapter 3]. For some
recent papers that use this approach in conjunction with deep learning, see e.g., [BRR18; Isc+19].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license638 Chapter 19. Learning with Fewer Labeled Examples
19.3.5 Consistency regularization
Consistency regularization leverages the simple idea that perturbing a given datapoint (or the
model itself) should not cause the model’s output to change dramatically. Since measuring consistency
in this way only makes use of the model’s outputs (and not ground-truth labels), it is readily applicable
to unlabeled data and therefore can be used to create appropriate loss functions for semi-supervised
learning. This idea was first proposed under the framework of “learning with pseudo-ensembles”
[BAP14], with similar variants following soon thereafter [LA16; SJT16].
In its most general form, both the model pθ(y|x) and the transformations applied to the input
can be stochastic. For example, in computer vision problems we may transform the input by using
data augmentation like randomly rotating or adding noise the input image, and the network may
include stochastic components like dropout (Section 13.5.4) or weight noise [Gra11]. A common and
simple form of consistency regularization first samples x
0 ∼ q(x
0
|x) (where q(x
0
|x) is the distribution
induced by the stochastic input transformations) and then minimizes the loss kpθ(y|x) − pθ(y|x
0
)k
2
.
In practice, the first term pθ(y|x) is typically treated as fixed (i.e. gradients are not propagated
through it). In the semi-supervised setting, the combined loss function over a batch of labeled data
(x1, y1),(x2, y2), . . . ,(xM, yM) and unlabeled data x1, x2, . . . , xN is
L(θ) = −
X
M
i=1
log pθ(y = yi
|xi) + λ
X
N
j=1
kpθ(y|xj ) − pθ(y|x
0
j
)k
2
(19.27)
where λ is a scalar hyperparameter that balances the importance of the loss on unlabeled data and,
for simplicity, we write x
0
j
to denote a sample drawn from q(x
0
|xj ).
The basic form of consistency regularization in Equation (19.27) reveals many design choices
that impact the success of this semi-supervised learning approach. First, the value chosen for the
λ hyperparameter is important. If it is too large, then the model may not give enough weight to
learning the supervised task and will instead start to reinforce its own bad predictions (as with
confirmation bias in self-training). Since the model is often poor at the start of training before it has
been trained on much labeled data, it is common in practice to initialize set λ to zero and increase
its value over the course of training.
A second important consideration are the random transformations applied to the input, i.e., q(x
0
|x).
Generally speaking, these transformations should be designed so that they do not change the label
of x. As mentioned above, a common choice is to use domain-specific data augmentations. It has
recently been shown that using strong data augmentations that heavily corrupt the input (but,
arguably, still do not change the label) can produce particularly strong results [Xie+19; Ber+19b;
Soh+20].
The use of data augmentation requires expert knowledge to determine what kinds of transformations
are label-preserving and appropriate for a given problem. An alternative technique, called virtual
adversarial training (VAT), instead transforms the input using an analytically-found perturbation
designed to maximally change the model’s output. Specifically, VAT computes a perturbation δ that
approximates δ = argmaxδ DKL (pθ(y|x)kpθ(y|x + δ)). The approximation is done by sampling d
from a multivariate Gaussian distribution, initializing δ = d, and then setting
δ ← ∇δDKL (pθ(y|x)kpθ(y|x + δ))|δ=ξd (19.28)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202219.3. Semi-supervised learning 639
4 2 0 2 4
0.0
0.5
1.0
1.5
2.0
Squared error
KL divergence
Figure 19.11: Comparison of the squared error and KL divergence lossses for a consistency regularization.
This visualization is for a binary classification problem where it is assumed that the model’s output for
the unperturbed input is 1. The figure plots the loss incurred for a particular value of the logit (i.e. the
pre-activation fed into the output sigmoid nonlinearity) for the perturbed input. As the logit grows towards
infinity, the model predicts a class label of 1 (in agreement with the prediction for the unperturbed input); as
it grows towards negative infinity, the model predictions class 0. The squared error loss saturates (and has
zero gradients) when the model predicts one class or the other with high probability, but the KL divergence
grows without bound as the model predicts class 0 with more and more confidence.
where ξ is a small constant, typically 10−6
. VAT then sets
x
0 = x + 
δ
kδk2
(19.29)
and proceeds as usual with consistency regularization (as in Equation (19.27)), where  is a scalar
hyperparameter that sets the L2-norm of the perturbation applied to x.
Consistency regularization can also profoundly affect the geometry properties of the training
objective, and the trajectory of SGD, such that performance can particularly benefit from non￾standard training procedures. For example, the Euclidean distances between weights at different
training epochs is significantly larger for objectives that use consistency regularization. Athiwaratkun
et al. [Ath+19] show that a variant of stochastic weight averaging (SWA) [Izm+18] can achieve
state-of-the-art performance on semi-supervised learning tasks by exploiting the geometric properties
of consistency regularization.
A final consideration when using consistency regularization is the function used to measure the
difference between the network’s output with and without perturbations. Equation (19.27) uses the
squared L2 distance (also referred to as the Brier score), which is a common choice [SJT16; TV17;
LA16; Ber+19a]. It is also common to use the KL divergence DKL (pθ(y|x)kpθ(y|x
0
) in analogy with
the cross-entropy loss (i.e. KL divergence between ground-truth label and prediction) used for labeled
examples [Miy+18; Ber+19b; Xie+19]. The gradient of the squared-error loss approaches zero as the
model’s predictions on the perturbed and unperturbed input differ more and more, assuming the
model uses a softmax nonlinearity on its output. Using the squared-error loss therefore has a possible
advantage that the model is not updated when its predictions are very unstable. However, the KL
divergence has the same scale as the cross-entropy loss used for labeled data, which makes for more
intuitive tuning of the unlabeled loss hyperparameter λ. A comparison of the two loss functions is
shown in Figure 19.11.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license640 Chapter 19. Learning with Fewer Labeled Examples
19.3.6 Deep generative models *
Generative models provide a natural way of making use of unlabeled data through learning a model of
the marginal distribution by minimizing LU = −
P
n
log pθ(xn). Various approaches have leveraged
generative models for semi-supervised by developing ways to use the model of pθ(xn) to help produce
a better supervised model.
19.3.6.1 Variational autoencoders
In Section 20.3.5, we describe the variational autoencoder (VAE), which defines a probabilistic model
of the joint distribution of data x and latent variables z. Data is assumed to be generated by first
sampling z ∼ p(z) and then sampling x ∼ p(x|z). For learning, the VAE uses an encoder qλ(z|x)
to approximate the posterior and a decoder pθ(x|z) to approximate the likelihood. The encoder
and decoder are typically deep neural networks. The parameters of the encoder and decoder can be
jointly trained by maximizing the evidence lower bound (ELBO) of data.
The marginal distribution of latent variables p(z) is often chosen to be a simple distribution like
a diagonal-covariance Gaussian. In practice, this can make the latent variables z more amenable
to downstream classification thanks to the facts that z is typically lower-dimensional than x, that
z is constructed via cascaded nonlinear transformations, and that the dimensions of the latent
variables are designed to be independent. In other words, the latent variables can provide a (learned)
representation where data may be more easily separable. In [Kin+14], this approach is called M1
and it is indeed shown that the latent variables can be used to train stronger models when labels
are scarce. (The general idea of unsupervised learning of representations to help with downstream
classification tasks is described further in Section 19.2.4.)
An alternative approach to leveraging VAEs, also proposed in [Kin+14] and called M2, has the
form
pθ(x, y) = pθ(y)pθ(x|y) = pθ(y)
Z
pθ(x|y, z)pθ(z)dz (19.30)
where z is a latent variable, pθ(z) = N (z|0, I) is the latent prior, pθ(y) = Cat(y|π) the label prior,
and pθ(x|y, z) = p(x|fθ(y, z)) is the likelihood, such as a Gaussian, with parameters computed by f
(a deep neural network). The main innovation of this approach is to assume that data is generated
according to both a latent class variable y as well as the continuous latent variable z. The class
variable y is observed for labeled data and unobserved for unlabled data.
To compute the likelihood for the labeled data, pθ(x, y), we need to marginalize over z, which we
can do by using an inference network of the form
qφ(z|y, x) = N (z|µφ(y, x), diag(σ
2
φ(x)) (19.31)
We then use the following variational lower bound
log pθ(x, y) ≥ Eqφ(z|x,y)
[log pθ(x|y, z) + log pθ(y) + log pθ(z) − log qφ(z|x, y)] = −L(x, y) (19.32)
as is standard for VAEs (see Section 20.3.5). The only difference is that we observe two kinds of
data: x and y.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202219.3. Semi-supervised learning 641
To compute the likelihood for the unlabeled data, pθ(x), we need to marginalize over z and y,
which we can do by using an inference network of the form
qφ(z, y|x) = qφ(z|x)qφ(y|x) (19.33)
qφ(z|x) = N (z|µφ(x), diag(σ
2
φ(x)) (19.34)
qφ(y|x) = Cat(y|πφ(x)) (19.35)
Note that qφ(y|x) acts like a discriminative classifier, that imputes the missing labels. We then use
the following variational lower bound:
log pθ(x) ≥ Eqφ(z,y|x)
[log pθ(x|y, z) + log pθ(y) + log pθ(z) − log qφ(z, y|x)] (19.36)
= −
X
y
qφ(y|x)L(x, y) + H (qφ(y|x)) = −U(x) (19.37)
Note that the discriminative classifier qφ(y|x) is only used to compute the log-likelihood of the
unlabeled data, which is undesirable. We can therefore add an extra classification loss on the
supervised data, to get the following overall objective function:
L(θ) = E(x,y)∼DL
[L(x, y)] + Ex∼DU
[U(x)] + αE(x,y)∼DL
[− log qφ(y|x)] (19.38)
where α is a hyperparameter that controls the relative weight of generative and discriminative
learning.
Of course, the probablistic model used in M2 is just one of many ways to decompose the dependencies
between the observed data, the class labels, and the continuous latent variables. There are also many
ways other than variational inference to perform approximate inference. The best technique will
be problem dependent, but overall the main advantage of the generative approach is that we can
incorporate domain knowledge. For example, we can model the missing data mechanism, since the
absence of a label may be informative about the underlying data (e.g., people may be reluctant to
answer a survey question about their health if they are unwell).
19.3.6.2 Generative adversarial networks
Generative adversarial networks (GANs) (described in more detail in the sequel to this book,
[Mur22]) are a popular class of generative models that learn an implicit model of the data distribution.
They consist of a generator network, which maps samples from a simple latent distribution to the
data space, and a critic network, which attempts to distinguish between the outputs of the generator
and samples from the true data distribution. The generator is trained to generate samples that the
critic classifies as “real”.
Since standard GANs do not produce a learned latent representation of a given datapoint and do
not learn an explicit model of the data distribution, we cannot use the same approaches as were used
for VAEs. Instead, semi-supervised learning with GANs is typically done by modifying the critic
so that it outputs either a class label or “fake” instead of simply classifying real vs. fake [Sal+16;
Ode16]. For labeled real data, the critic is trained to output the appropriate class label, and for
unlabeled real data, it is trained to raise the probability of any of the class labels. As with standard
GAN training, the critic is trained to classify outputs from the generator as fake and the generator is
trained to fool the critic.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license642 Chapter 19. Learning with Fewer Labeled Examples
Labeled image, class 2
Unlabeled image
•
•
•
Figure 19.12: Diagram of the semi-supervised GAN framework. The discriminator is trained to output the
class of labeled datapoints (red), a “fake” label for outputs from the generator (yellow), and any label for
unlabeled data (green).
In more detail, let pθ(y|x) denote the critic with C + 1 outputs corresponding to C classes plus a
“fake” class, and let G(z) denote the generator which takes as input samples from the prior distribution
p(z). Let us assume that we are using the standard cross-entropy GAN loss as originally proposed in
[Goo+14]. Then the critic’s loss is
−Ex,y∼p(x,y)
log pθ(y|x)−Ex∼p(x)
log[1−pθ(y = C +1|x)]−Ez∼p(z)
log pθ(y = C +1|G(z)) (19.39)
This tries to maximize the probability of the correct class for the labeled examples, to minimize the
probability of the fake class for real unlabeled examples, and to maximize the probability of the fake
class for generated examples. The generator’s loss is simpler, namely
Ez∼p(z)
log pθ(y = C + 1|G(z)) (19.40)
A diagram visualizing the semi-supervised GAN framework is shown in Figure 19.12.
19.3.6.3 Normalizing flows
Normalizing flows (described in more detail in the sequel to this book, [Mur22]) are a tractable
way to define deep generative models. More precisely, they define an invertible mapping fθ : X → Z,
with parameters θ, from the data space X to the latent space Z. The density in data space can be
written starting from the density in the latent space using the change of variables formula:
p(x) = p(f(x)) ·




det 
∂f
∂x



. (19.41)
We can extend this to semi-supervised learning, as proposed in [Izm+20]. For class labels
y ∈ {1 . . . C}, we can specify the latent distribution, conditioned on a label k, as Gaussian with mean
µk and covariance Σk: p(z|y = k) = N (z|µk, Σk). The marginal distribution of z is then a Gaussian
mixture. The likelihood for labeled data is then
pX (x|y = k) = N (f(x)|µk, Σk) ·




det 
∂f
∂x



, (19.42)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202219.3. Semi-supervised learning 643
Figure 19.13: Combining self-supervised learning on unlabeled data (left), supervised fine-tuning (middle),
and self-training on pseudo-labeled data (right). From Figure 3 of [Che+20c]. Used with kind permission of
Ting Chen.
and the likelihood for data with unknown label is p(x) = P
k
p(x|y = k)p(y = k).
For semi-supervised learning we can then maximize the joint likelihood of the labeled D` and
unlabeled data Du:
p(D`, Du|θ) = Y
(xi,yi)∈D`
p(xi
, yi)
Y
xj∈Du
p(xj ), (19.43)
over the parameters θ of the bijective function f, which learns a density model for a Bayes classifier.
Given a test point x, the model predictive distribution is given by
pX (y|x) = p(x|y)p(y)
p(x)
=
N (f(x)|µy, Σy)
PC
k=1 N (f(x)|µk, Σk)
, (19.44)
when the classes are balanced. We can make predictions for a test point x with the Bayes decision
rule y = arg maxc∈{1,...,C} p(y = c|x).
19.3.7 Combining self-supervised and semi-supervised learning
It is possible to combine self-supervised and semi-supervised learning. For example, [Che+20c]
using SimCLR (Section 19.2.4.4) to perform self-supervised representation learning on the unlabeled
data, they then fine-tune this representation on a small labeled dataset (as in transfer learning,
Section 19.2), and finally, they apply the trained model back to the original unlabeled dataset, and
distill the predictions from this teacher model T into a student model S. (Knowledge distillation
is the name given to the approach of training one model on the predictions of another, as originally
proposed in [HVD14].) That is, after fine-tuning T, they train S by minimizing
L(T) = −
X
xi∈D "X
y
p
T
(y|xi
; τ ) log p
S
(y|xi
; τ )
#
(19.45)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license644 Chapter 19. Learning with Fewer Labeled Examples
where τ > 0 is a temperature parameter applied to the softmax output, which is used to perform
label smoothing. If S has the same form as T, this is known as self-training, as discussed in
Section 19.3.1. However, normally the student S is smaller than the teacher T. (For example, T might
be a high capacity model, and S is a lightweight version that runs on a phone.) See Figure 19.13 for
an illustration of the overall approach.
19.4 Active learning
In active learning, the goal is to identify the true predictive mapping y = f(x) by querying as few
(x, y) points as possible. There are three main variants. In query synthesis, the algorithm gets
to choose any input x, and can ask for its corresponding output y = f(x). In pool-based active
learning, there is a large, but fixed, set of unlabeled data points, and the algorithm gets to ask for
a label for one or more of these points. Finally, in stream-based active learning, the incoming
data is arriving continuously, and the algorithm must choose whether it wants to request a label for
the current input or not.
There are various closely related problems. In Bayesian optimization the goal is to estimate
the location of the global optimum x
∗ = argminx f(x) in as few queries as possible; typically we fit
a surrogate (response surface) model to the intermediate (x, y) queries, to decide which question
to ask next. In experiment design, the goal is to infer a parameter vector of some model, using
carefully chosen data samples D = {x1, . . . , xN }, i.e. we want to estimate p(θ|D) using as little data
as possible. (This can be thought of as an unsupervised, or generalized, form of active learning.)
In this section, we give a brief review of the pool based approach to active learning. For more
details, see e.g., [Set12] for a review.
19.4.1 Decision-theoretic approach
In the decision theoretic approach to active learning, proposed in [KHB07; RM01], we define the
utility of querying x in terms of the value of information. In particular, we define the utility of
issuing query x as
U(x) , Ep(y|x,D)
h
min
a
(R(a|D) − R(a|D,(x, y)))i
(19.46)
where R(a|D) = Ep(θ|D)
[`(θ, a)] is the posterior expected loss of taking some future action a given
the data D observed so far. Unfortunately, evaluating U(x) for each x is quite expensive, since for
each possible response y we might observe, we have to update our beliefs given (x, y) to see what
effect it might have on our future decisions (similar to look ahead search technique applied to belief
states).
19.4.2 Information-theoretic approach
In the information theoretic approach to active supervised learning, we avoid using task-specific loss
functions, and instead focus on learning our model as well as we can. In particular, [Lin56] proposed
to define the utility of querying x in terms of information gain about the parameters θ, i.e., the
reduction in entropy:
U(x) , H (p(θ|D)) − Ep(y|x,D)
[H (p(θ|D, x, y))] (19.47)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202219.5. Meta-learning 645
(Note that the first term is a constant wrt x, but we include it for later convenience.) Exercise 19.1
asks you to show that this objective is identical to the expected change in the posterior over the
parameters which is given by
U
0
(x) , Ep(y|x,D)
[DKL (p(θ|D, x, y)kp(θ|D))] (19.48)
Using symmetry of the mutual information, we can rewrite Equation (19.47) as follows:
U(x) = H (p(θ|D)) − Ep(y|x,D)
[H (p(θ|D, x, y))] (19.49)
= I(θ, y|D, x) (19.50)
= H (p(y|x, D)) − Ep(θ|D)
[H (p(y|x, θ))] (19.51)
The advantage of this approach is that we now only have to reason about the uncertainty of the
predictive distribution over outputs y, not over the parameters θ.
Equation (19.51) has an interesting interpretation. The first term prefers examples x for which
there is uncertainty in the predicted label. Just using this as a selection criterion is called maximum
entropy sampling [SW87]. However, this can have problems with examples which are inherently
ambiguous or mislabeled. The second term in Equation (19.51) will discourage such behavior, since
it prefers examples x for which the predicted label is fairly certain once we know θ; this will avoid
picking inherently hard-to-predict examples. In other words, Equation (19.51) will select examples
x for which the model makes confident predictions which are highly diverse. This approach has
therefore been called Bayesian active learning by disagreement or BALD [Hou+12].
This method can be used to train classifiers for other domains where expert labels are hard to
acquire, such as medical images or astronomical images [Wal+20].
19.4.3 Batch active learning
So far, we have assumed a greedy or myopic strategy, in which we select a single example x,
as if it were the last datapoint to be selected. But sometimes we have a budget to collect a set
of B samples, call them (X, Y). In this case, the information gain criterion becomes U(X) =
H (p(θ|D)) − Ep(Y|X,D)
[H (p(θ|Y, X, D))]. Unfortunately, optimizing this is NP-hard in the horizon
length B [KLQ95; KG05].
Fortunately, under certain conditions, the greedy strategy is near-optimal, as we now explain. First
note that, for any given X, the information gain function f(Y) , H (p(θ|D)) − H (p(θ|Y, X, D))
maps a set of labels Y to a scalar. It is clear that f(∅) = 0, and that f is non-decreasing, meaning
f(Y
large) ≥ f(Y
small), due to the “more information never hurts” principle. Furthermore, [KG05]
proved that f is submodular. As a consequence, a sequential greedy approach is within a constant
factor of optimal. If we combine this greedy technique with the BALD objective, we get a method
called BatchBALD [KAG19].
19.5 Meta-learning
We can think of a learning algorithm as a function A that maps data to a parameter estimate,
θ = A(D). The function A usually has its own parameter — call them φ — such as the initial values
for θ, or the learning rate, etc. We denote this by θ = A(D; φ). We can imagine learning φ itself,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license646 Chapter 19. Learning with Fewer Labeled Examples
N1 M1 NJ MJ
Φ
Θ1 ΘJ
Yn
1
Train 1
Ym
1
Valid 1 ...
Yn
J
Train J
Ym
J
Valid J
Xn
1 Xm
1 Xn
J Xm
J
Figure 19.14: Illustration of a hierarchical Bayesian model for meta-learning. Generated by code at fig￾ures.probml.ai/book1/19.14.
given a collection of datasets D1:J and some meta-learning algorithm M, i.e., φ = M(D1:J ). We
can then apply A(·; φ) to learn the parameters θJ+1 on some new dataset DJ+1. There are many
techniques for meta-learning — see e.g., [Van18; HRP21] for recent reviews. Below we discuss one
particularly popular method. (Note that meta-learning is also called learning to learn [TP97].)
19.5.1 Model-agnostic meta-learning (MAML)
A natural approach to meta learning is to use a hierarchical Bayesian model, as illustrated in
Figure 19.14. The parameters for each task θj are assumed to come from a common prior, p(θj |φ),
which can be used to help pool statistical strength from multiple data-poor problems. Meta-learning
becomes equivalent to learning the prior φ. Rather than performing full Bayesian inference in
this model, a more efficient approach is to use the following empirical Bayes (Section 4.6.5.3)
approximation:
φ
∗ = argmax
φ
1
J
X
J
j=1
log p(D
j
valid|θˆ
j (φ, D
j
train)) (19.52)
where θˆ
j = θˆ(φ, D
j
train) is a point estimate of the parameters for task j based on D
j
train and prior φ,
and where we use a cross-validation approximation to the marginal likelihood (Section 5.2.4).
To compute the point estimate of the parameters for the target task θˆ
J+1, we use K steps of a
gradient ascent procedure starting at φ with a learning rate of η. This is known as model-agnostic
meta-learning or MAML [FAL17]. This can be shown to be equivalent to an approximate MAP
estimate using a Gaussian prior centered at φ, where the strength of the prior is controlled by the
number of gradient steps [San96; Gra+18]. (This is an example of fast adapation of the task
specific weights starting from the shared prior φ.)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202219.6. Few-shot learning 647
Training task 1
C=3
N=2
Support set Support set Support set
Query set Query set Query set
Training task 2 Test task 1 .
.
.
.
.
.
Figure 19.15: Illustration of meta-learning for few-shot learning. Here, each task is a 3-way-2-shot classification
problem because each training task contains a support set with three classes, each with two examples. From
https: // bit. ly/ 3rrvSjw . Copyright (2019) Borealis AI. Used with kind permission of Simon Prince and
April Cooper.
19.6 Few-shot learning
People can learn to predict from very few labeled examples. This is called few-shot learning. In
the extreme in which the person or system learns from a single example of each class, this is called
one-shot learning, and if no labeled examples are given, it is called zero-shot learning.
A common way to evaluate methods for FSL is to use C-way N-shot classification, in which
the system is expected to learn to classify C classes using just N training examples of each class.
Typically N and C are very small, e.g., Figure 19.15 illustrates the case where we have C = 3 classes,
each with N = 2 examples. Since the amount of data from the new domain (here, ducks, dolphins
and hens) is so small, we cannot expect to learn from scratch. Therefore we turn to meta-learning.
During training, the meta-algorithm M trains on a labeled support set from group j, returns a
predictor f
j
, which is then evaluated on a disjoint query set also from group j. We optimize M over
all J groups. Finally we can apply M to our new labeled support set to get f
test, which is applied
to the query set from the test domain. This is illustrated in Figure 19.15. We see that there is no
overlap between the classes in the two training tasks ({cat, lamb, pig} and {dog, shark, lion}) and
those in the test task ({duck, dolphin, hen}). Thus the algorithm M must learn to predict image
classes in general rather than any particular set of labels.
There are many approaches to few-shot learning. We discuss one such method in Section 19.6.1.
For more methods, see e.g., [Wan+20b].
19.6.1 Matching networks
One approach to few shot learning is to learn a distance metric on some other dataset, and then to
use dθ(x, x
0
) inside of a nearest neighbor classifier. Essentially this defines a semi-parametric model
of the form pθ(y|x, S), where S is the small labeled dataset (known as the support set), and θ are the
parameters of the distance function. This approach is widely used for fine-grained classification
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license648 Chapter 19. Learning with Fewer Labeled Examples
Figure 19.16: Illustration of a matching network for one-shot learning. From Figure 1 of [Vin+16]. Used
with kind permission of Oriol Vinyals.
tasks, where there are many different visually similar categories, such as face images from a gallery,
or product images from a catalog.
An extension of this approach is to learn a function of the form
pθ(y|x, S) = I
 
y =
X
n∈S
aθ(x, xn; S)yn
!
(19.53)
where aθ(x, xn; S) ∈ R
+ is some kind of adaptive similarity kernel. For example, we can use an
attention kernel of the form
a(x, xn; S) = exp(c(f(x), g(xn)))
PN
n0=1 exp(c(f(x), g(xn0 )))
(19.54)
where c(u, v) is the cosine distance. (We can make f and g be the same function if we want.)
Intuitively, the attention kernel will compare x to xn in the context of all the labeled examples,
which provides an implicit signal about which feature dimensions are relevant. (We discuss attention
mechanisms in more detail in Section 15.4.) This is called a matching network [Vin+16]. See
Figure 19.16 for an illustration.
We can train the f and g functions using multiple small datasets, as in meta-learning (Section 19.5).
More precisely, let D be a large labeled dataset (e.g., ImageNet), and let p(L) be a distribution over
its labels. We create a task by sampling a small set of labels (say 25), L ∼ p(L), and then sampling a
small support set of examples from D with those labels, S ∼ L, and finally sampling a small test set
with those same labels, T ∼ L. We then train the model to predict the test labels given the support
set, i.e., we optimize the following objective:
L(θ; D) = EL∼p(L)

ES∼L,T ∼L


X
(x,y)∈T
log pθ(y|x, S)



 (19.55)
After training, we freeze θ, and apply Equation (19.53) to a test support set S.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202219.7. Weakly supervised learning 649
19.7 Weakly supervised learning
The term weakly supervised learning refers to scenarios where we do not have an exact label
associated with every feature vector in the training set.
One scenario is when we have a distribution over labels for each case, rather than a single label.
Fortunately, we can still do maximum likelihood training: we just have to minimize the cross entropy,
L(θ) = −
X
n
X
y
p(y|xn) log qθ(y|xn) (19.56)
where p(y|xn) is the label distribution for case n, and qθ(y|xn) is the predicted distribution. Indeed,
it is often useful to artificially replace exact labels with a “soft” version, in which we replace the delta
function with a distribution that puts, say, 90% of its mass on the observed label, and spreads the
remaining mass uniformly over the other choices. This is called label smoothing, and is a useful
form of regularization (see e.g., [MKH19]).
Another scenario is when we have a set, or bag, of instances, xn = {xn,1, . . . , xn,B}, but we only
have a label for the entire bag, yn, not for the members of the bag, ynb. We often assume that if any
member of the bag is positive, the whole bag is labeled positive, so yn = ∨
B
b=1ynb, but we do not
know which member “caused” the positive outcome. However, if all the members are negative, the
entire bag is negative. This is known as multi-instance learning [DLLP97]. (For a recent example
of this in the context of COVID-19 risk score learning, see [MKS21].) Various algorthms can be used
to solve the MIL problem, depending on what assumptions we make about the correlation between
the labels in each bag, and the fraction of positive members we expect to see (see e.g., [KF05]).
Yet another scenario is known as distant supervision [Min+09], which is often used to train
information extraction systems. The idea is that we have some fact, such as “Married(B,M)”, that
we know to be true (since it is stored in a database). We use this to label every sentence (in our
unlabeled training corpus) in which the entities B and M are mentioned as being a positive example
of the “Married” relation. For example, the sentence “B and M invited 100 people to their wedding”
will be labeled positive. But this heuristic may include false positives, for example “B and M went
out to dinner” will also be labeled positive. Thus the resulting labels will be noisy. We discuss some
ways to handle label noise in Section 10.4.
19.8 Exercises
Exercise 19.1 [Information gain equations]
Consider the following two objectives for evaluating the utility of querying a datapoint x in an active learning
setting:
U(x) , H (p(θ|D)) − Ep(y|x,D) [H (p(θ|D, x, y))] (19.57)
U
0
(x) , Ep(y|x,D) [DKL (p(θ|D, x, y)kp(θ|D))] (19.58)
Prove that these are equal.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license20 Dimensionality Reduction
A common form of unsupervised learning is dimensionality reduction, in which we learn a mapping
from the high-dimensional visible space, x ∈ R
D, to a low-dimensional latent space, z ∈ R
L. This
mapping can either be a parametric model z = f(x; θ) which can be applied to any input, or it can
be a nonparametric mapping where we compute an embedding zn for each input xn in the data
set, but not for any other points. This latter approach is mostly used for data visualization, whereas
the former approach can also be used as a preprocessing step for other kinds of learning algorithms.
For example, we might first reduce the dimensionality by learning a mapping from x to z, and then
learn a simple linear classifier on this embedding, by mapping z to y.
20.1 Principal components analysis (PCA)
The simplest and most widely used form of dimensionality reduction is principal components
analysis or PCA. The basic idea is to find a linear and orthogonal projection of the high dimensional
data x ∈ R
D to a low dimensional subspace z ∈ R
L, such that the low dimensional representation is
a “good approximation” to the original data, in the following sense: if we project or encode x to get
z = WTx, and then unproject or decode z to get xˆ = Wz, then we want xˆ to be close to x in `2
distance. In particular, we can define the following reconstruction error or distortion:
L(W) ,
1
N
X
N
n=1
||xn − decode(encode(xn;W);W)||2
2
(20.1)
where the encode and decoding stages are both linear maps, as we explain below.
In Section 20.1.2, we show that we can minimize this objective by setting Wˆ = UL, where UL
contains the L eigenvectors with largest eigenvalues of the empirical covariance matrix
Σˆ =
1
N
X
N
n=1
(xn − x)(xn − x)
T =
1
N
XT
cXc (20.2)
where Xc is a centered version of the N × D design matrix. In Section 20.2.2, we show that this is
equivalent to maximizing the likelihood of a latent linear Gaussian model known as probabilistic
PCA.
20.1.1 Examples
Before giving the details, we start by showing some examples.652 Chapter 20. Dimensionality Reduction
4 2 0 2 4
4
2
0
2
4
Figure 20.1: An illustration of PCA where we project from 2d to 1d. Circles are the original data points, crosses
are the reconstructions. The red star is the data mean. Generated by code at figures.probml.ai/book1/20.1.
4 2 0 2 4
First Principal Component
4
2
0
2
4
Second Principal Component
Figure 20.2: An illustration of PCA applied to MNIST digits from class 9. Grid points are at the 5, 25,
50, 75, 95 % quantiles of the data distribution along each dimension. The circled points are the closest
projected images to the vertices of the grid. Adapted from Figure 14.23 of [HTF09]. Generated by code at
figures.probml.ai/book1/20.2.
Figure 20.1 shows a very simple example, where we project 2d data to a 1d line. This direction
captures most of the variation in the data.
In Figure 20.2, we show what happens when we project some MNIST images of the digit 9 down to
2d. Although the inputs are high dimensional (specifically 28 × 28 = 784 dimensional), the number
of “effective degrees of freedom” is much less, since the pixels are correlated, and many digits look
similar. Therefore we can represent each image as a point in a low dimensional linear space.
In general, it can be hard to interpet the latent dimensions to which the data is projected. However,
by looking at several projected points along a given direction, and the examples from which they
are derived, we see that the first principal component (horizontal direction) seems to capture the
orientation of the digit, and the second component (vertical direction) seems to capture line thickness.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.1. Principal components analysis (PCA) 653
(a)
mean principal basis 1
principal basis 2 principal basis 3
(b)
Figure 20.3: a) Some randomly chosen 64 × 64 pixel images from the Olivetti face database. (b) The mean
and the first three PCA components represented as images. Generated by code at figures.probml.ai/book1/20.3.
In Figure 20.3, we show PCA applied to another image dataset, known as the Olivetti face dataset,
which is a set of 64 × 64 grayscale images. We project these to a 3d subspace. The resulting basis
vectors (columns of the projection matrix W) are shown as images in in Figure 20.3b; these are
known as eigenfaces [Tur13], for reasons that will be explained in Section 20.1.2. We see that the
main modes of variation in the data are related to overall lighting, and then differences in the eyebrow
region of the face. If we use enough dimensions (but fewer than the 4096 we started with), we can
use the represenation z = WTx as input to a nearest-neighbor classifier to perform face recognition;
this is faster and more reliable than working in pixel space [MWP98].
20.1.2 Derivation of the algorithm
Suppose we have an (unlabeled) dataset D = {xn : n = 1 : N}, where xn ∈ R
D. We can represent
this as an N × D data matrix X. We will assume x =
1
N
PN
n=1 xn = 0, which we can ensure by
centering the data.
We would like to approximate each xn by a low dimensional representation, zn ∈ R
L. We assume
that each xn can be “explained” in terms of a weighted combination of basis functions w1, . . . , wL,
where each wk ∈ R
D, and where the weights are given by zn ∈ R
L, i.e., we assume xn ≈
PL
k=1 znkwk.
The vector zn is the low dimensional representation of xn, and is known as the latent vector, since
it consists of latent or “hidden” values that are not observed in the data. The collection of these
latent variables are called the latent factors.
We can measure the error produced by this approximation as follows:
L(W, Z) = 1
N
||X − ZWT
||2
F =
1
N
||XT − WZT
||2
F =
1
N
X
N
n=1
||xn − Wzn||2
(20.3)
where the rows of Z contain the low dimension versions of the rows of X. This is known as the
(average) reconstruction error, since we are approximating each xn by xˆn = Wzn.
We want to minimize this subject to the constraint that W is an orthogonal matrix. Below we
show that the optimal solution is obtained by setting Wˆ = UL, where UL contains the L eigenvectors
with largest eigenvalues of the empirical covariance matrix.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license654 Chapter 20. Dimensionality Reduction
20.1.2.1 Base case
Let us start by estimating the best 1d solution, w1 ∈ R
D. We will find the remaining basis vectors
w2, w3, etc. later.
Let the coefficients for each of the data points associated with the first basis vector be denoted by
˜z1 = [z11, . . . , zN1] ∈ R
N . The reconstruction error is given by
L(w1,˜z1) = 1
N
X
N
n=1
||xn − zn1w1||2 =
1
N
X
N
n=1
(xn − zn1w1)
T
(xn − zn1w1) (20.4)
=
1
N
X
N
n=1
[x
T
nxn − 2zn1wT
1xn + z
2
n1wT
1w1] (20.5)
=
1
N
X
N
n=1
[x
T
nxn − 2zn1wT
1xn + z
2
n1
] (20.6)
since wT
1w1 = 1 (by the orthonormality assumption). Taking derivatives wrt zn1 and equating to
zero gives
∂
∂zn1
L(w1,˜z1) = 1
N
[−2wT
1xn + 2zn1] = 0 ⇒ zn1 = wT
1xn (20.7)
So the optimal embedding is obtained by orthogonally projecting the data onto w1 (see Figure 20.1(a)).
Plugging this back in gives the loss for the weights:
L(w1) = L(w1,˜z∗
1
(w1)) = 1
N
X
N
n=1
[x
T
nxn − z
2
n1
] = const −
1
N
X
N
n=1
z
2
n1
(20.8)
To solve for w1, note that
L(w1) = −
1
N
X
N
n=1
z
2
n1 = −
1
N
X
N
n=1
wT
1xnx
T
nw1 = −wT
1Σˆ w1 (20.9)
where Σ is the empirical covariance matrix (since we assumed the data is centered). We can trivially
optimize this by letting ||w1|| → ∞, so we impose the constraint ||w1|| = 1 and instead optimize
L˜(w1) = wT
1Σˆ w1 − λ1(wT
1w1 − 1) (20.10)
where λ1 is a Lagrange multiplier (see Section 8.5.1). Taking derivatives and equating to zero we
have
∂
∂w1
L˜(w1) = 2Σˆ w1 − 2λ1w1 = 0 (20.11)
Σˆ w1 = λ1w1 (20.12)
Hence the optimal direction onto which we should project the data is an eigenvector of the covariance
matrix. Left multiplying by wT
1
(and using wT
1w1 = 1) we find
wT
1Σˆ w1 = λ1 (20.13)
Since we want to maximize this quantity (minimize the loss), we pick the eigenvector which corresponds
to the largest eigenvalue.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.1. Principal components analysis (PCA) 655
1.0 0.5 0.0 0.5 1.0
x1
1.0
0.5
0.0
0.5
1.0
x2
v1
v
0
v2
2 1 0 1 2
z1
Figure 20.4: Illustration of the variance of the points projected onto different 1d vectors. v1 is the first
principal component, which maximizes the variance of the projection. v2 is the second principal component
which is direction orthogonal to v1. Finally v
0
is some other vector in between v1 and v2. Adapted from
Figure 8.7 of [Gér19]. Generated by code at figures.probml.ai/book1/20.4
20.1.2.2 Optimal weight vector maximizes the variance of the projected data
Before continuing, we make an interesting observation. Since the data has been centered, we have
E [zn1] = E

x
T
nw1

= E [xn]
T
w1 = 0 (20.14)
Hence variance of the projected data is given by
V [˜z1] = E

˜z2
1

− (E [˜z1])2 =
1
N
X
N
n=1
z
2
n1 − 0 = −L(w1) + const (20.15)
From this, we see that minimizing the reconstruction error is equivalent to maximizing the variance
of the projected data:
arg min
w1
L(w1) = arg max
w1
V [˜z1(w1)] (20.16)
This is why it is often said that PCA finds the directions of maximal variance. (See Figure 20.4 for an
illustration.) However, the minimum error formulation is easier to understand and is more general.
20.1.2.3 Induction step
Now let us find another direction w2 to further minimize the reconstruction error, subject to
wT
1w2 = 0 and wT
2w2 = 1. The error is
L(w1,˜z1, w2,˜z2) = 1
N
X
N
n=1
||xn − zn1w1 − zn2w2||2
(20.17)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license656 Chapter 20. Dimensionality Reduction
height
55 60 65 70 75 80 85
weight
80
100
120
140
160
180
200
220
240
260
280 heightWeightPCA
(a)
height
-4 -3 -2 -1 0 1 2 3 4
weight
-4
-3
-2
-1
0
1
2
3
4
5 heightWeightPCAstnd
(b)
Figure 20.5: Effect of standardization on PCA applied to the height/weight dataset. (Red=female, blue=male.)
Left: PCA of raw data. Right: PCA of standardized data. Generated by code at figures.probml.ai/book1/20.5.
Optimizing wrt w1 and z1 gives the same solution as before. Exercise 20.3 asks you to show that
∂L
∂z2
= 0 yields zn2 = wT
2xn. Substituting in yields
L(w2) = 1
n
X
N
n=1
[x
T
nxn − wT
1xnx
T
nw1 − wT
2xnx
T
nw2] = const − wT
2Σˆ w2 (20.18)
Dropping the constant term, plugging in the optimal w1 and adding the constraints yields
L˜(w2) = wT
2Σˆ w2 + λ2(wT
2w2 − 1) + λ12(wT
2w1 − 0) (20.19)
Exercise 20.3 asks you to show that the solution is given by the eigenvector with the second largest
eigenvalue:
Σˆ w2 = λ2w2 (20.20)
The proof continues in this way to show that Wˆ = UL.
20.1.3 Computational issues
In this section, we discuss various practical issues related to using PCA.
20.1.3.1 Covariance matrix vs correlation matrix
We have been working with the eigendecomposition of the covariance matrix. However, it is better to
use the correlation matrix instead. The reason is that otherwise PCA can be “misled” by directions in
which the variance is high merely because of the measurement scale. Figure 20.5 shows an example
of this. On the left, we see that the vertical axis uses a larger range than the horizontal axis. This
results in a first principal component that looks somewhat “unnatural”. On the right, we show the
results of PCA after standardizing the data (which is equivalent to using the correlation matrix
instead of the covariance matrix); the results look much better.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.1. Principal components analysis (PCA) 657
20.1.3.2 Dealing with high-dimensional data
We have presented PCA as the problem of finding the eigenvectors of the D × D covariance matrix
XTX. If D > N, it is faster to work with the N × N Gram matrix XXT. We now show how to do
this.
First, let U be an orthogonal matrix containing the eigenvectors of XXT with corresponding
eigenvalues in Λ. By definition we have (XXT)U = UΛ. Pre-multiplying by XT gives
(XTX)(XTU) = (XTU)Λ (20.21)
from which we see that the eigenvectors of XTX are V = XTU, with eigenvalues given by Λ as
before. However, these eigenvectors are not normalized, since ||vj ||2 = u
T
j XXTuj = λju
T
juj = λj .
The normalized eigenvectors are given by
V = XTUΛ− 1
2 (20.22)
This provides an alternative way to compute the PCA basis. It also allows us to use the kernel trick,
as we discuss in Section 20.4.6.
20.1.3.3 Computing PCA using SVD
In this section, we show the equivalence between PCA as computed using eigenvector methods
(Section 20.1) and the truncated SVD.1
Let UΣΛΣUT
Σ be the top L eigendecomposition of the covariance matrix Σ ∝ XTX (we assume X
is centered). Recall from Section 20.1.2 that the optimal estimate of the projection weights W is
given by the top L eigenvalues, so W = UΣ.
Now let UXSXVT
X ≈ X be the L-truncated SVD approximation to the data matrix X. From
Equation (7.184), we know that the right singular vectors of X are the eigenvectors of XTX, so
VX = UΣ = W. (In addition, the eigenvalues of the covariance matrix are related to the singular
values of the data matrix via λk = s
2
k
/N.)
Now suppose we are interested in the projected points (also called the principal components or PC
scores), rather than the projection matrix. We have
Z = XW = UXSXVT
XVX = UXSX (20.23)
Finally, if we want to approximately reconstruct the data, we have
Xˆ = ZWT = UXSXVT
X (20.24)
This is precisely the same as a truncated SVD approximation (Section 7.5.5).
Thus we see that we can perform PCA either using an eigendecomposition of Σ or an SVD
decomposition of X. The latter is often preferable, for computational reasons. For very high
dimensional problems, we can use a randomized SVD algorithm, see e.g., [HMT11; SKT14; DM16].
For example, the randomized solver used by sklearn takes O(NL2
) + O(L
3
) time for N examples
and L principal components, whereas exact SVD takes O(ND2
) + O(D3
) time.
1. A more detailed explanation can be found at https://bit.ly/2I566OK.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license658 Chapter 20. Dimensionality Reduction
num PCs
0 50 100 150 200 250 300 350 400
rmse
0
10
20
30
40
50
60
train set reconstruction error
(a)
num PCs
0 50 100 150 200 250 300 350 400
rmse
0
10
20
30
40
50
60
test set reconstruction error
(b)
Figure 20.6: Reconstruction error on MNIST vs number of latent dimensions used by PCA. (a) Training set.
(b) Test set. Generated by code at figures.probml.ai/book1/20.6.
20.1.4 Choosing the number of latent dimensions
In this section, we discuss how to choose the number of latent dimensions L for PCA.
20.1.4.1 Reconstruction error
Let us define the reconstruction error on some dataset D incurred by the model when using L
dimensions:
LL =
1
|D|
X
n∈D
||xn − xˆn||2
(20.25)
where the reconstruction is given by by xˆn = Wzn + µ, where zn = WT(xn − µ) and µ is the
empirical mean, and W is estimated as above. Figure 20.6(a) plots LL vs L on the MNIST training
data. We see that it drops off quite quickly, indicating that we can capture most of the empirical
correlation of the pixels with a small number of factors.
Of course, if we use L = rank(X), we get zero reconstruction error on the training set. To avoid
overfitting, it is natural to plot reconstruction error on the test set. This is shown in Figure 20.6(b).
Here we see that the error continues to go down even as the model becomes more complex! Thus
we do not get the usual U-shaped curve that we typically expect to see in supervised learning.
The problem is that PCA is not a proper generative model of the data: If you give it more latent
dimensions, it will be able to approximate the test data more accurately. (A similar problem arises if
we plot reconstruction error on the test set using K-means clustering, as discussed in Section 21.3.7.)
We discuss some solutions to this below.
20.1.4.2 Scree plots
A common alternative to plotting reconstruction error vs L is to use something called a scree
plot, which is a plot of the eigenvalues λj vs j in order of decreasing magnitude. One can show
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.1. Principal components analysis (PCA) 659
num PCs
0 10 20 30 40 50
eigenvalue
#105
0
0.5
1
1.5
2
2.5
3
3.5
4 scree plot
(a)
num PCs
0 10 20 30 40 50
proportion of variance explained
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
(b)
Figure 20.7: (a) Scree plot for training set, corresponding to Figure 20.6(a). (b) Fraction of variance explained.
Generated by code at figures.probml.ai/book1/20.7.
(Exercise 20.4) that
LL =
X
D
j=L+1
λj (20.26)
Thus as the number of dimensions increases, the eigenvalues get smaller, and so does the reconstruction
error, as shown in Figure 20.7a).2 A related quantity is the fraction of variance explained, defined
as
FL =
PL
j=1 λj
PLmax
j
0=1 λj
0
(20.27)
This captures the same information as the scree plot, but goes up with L (see Figure 20.7b).
20.1.4.3 Profile likelihood
Although there is no U-shape in the reconstruction error plot, there is sometimes a “knee” or “elbow”
in the curve, where the error suddenly changes from relatively large errors to relatively small. The
idea is that for L < L∗
, where L
∗
is the “true” latent dimensionality (or number of clusters), the rate
of decrease in the error function will be high, whereas for L > L∗
, the gains will be smaller, since the
model is already sufficiently complex to capture the true distribution.
One way to automate the detection of this change in the gradient of the curve is to compute
the profile likelihood, as proposed in [ZG06]. The idea is this. Let λL be some measure of the
error incurred by a model of size L, such that λ1 ≥ λ2 ≥ · · · ≥ λLmax . In PCA, these are the
eigenvalues, but the method can also be applied to the reoconstruction error from K-means clustering
(see Section 21.3.7). Now consider partitioning these values into two groups, depending on whether
k < L or k > L, where L is some threshold which we will determine. To measure the quality of L,
2. The reason for the term “scree plot” is that “the plot looks like the side of a mountain, and ’scree’ refers to the
debris fallen from a mountain and lying at its base”. (Quotation from Kenneth Janda, https://bit.ly/2kqG1yW.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license660 Chapter 20. Dimensionality Reduction
num PCs
0 10 20 30 40 50
profile log likelihood
-5750
-5700
-5650
-5600
-5550
-5500
-5450
Figure 20.8: Profile likelihood corresponding to PCA model in Figure 20.6(a). Generated by code at fig￾ures.probml.ai/book1/20.8.
we will use a simple change-point model, where λk ∼ N (µ1, σ2
) if k ≤ L, and λk ∼ N (µ2, σ2
) if
k > L. (It is important that σ
2 be the same in both models, to prevent overfitting in the case where
one regime has less data than the other.) Within each of the two regimes, we assume the λk are
iid, which is obviously incorrect, but is adequate for our present purposes. We can fit this model for
each L = 1 : L
max by partitioning the data and computing the MLEs, using a pooled estimate of the
variance:
µ1(L) =
P
k≤L
λk
L
(20.28)
µ2(L) =
P
k>L λk
Lmax − L
(20.29)
σ
2
(L) =
P
k≤L
(λk − µ1(L))2 +
P
k>L(λk − µ2(L))2
Lmax
(20.30)
We can then evaluate the profile log likelihood
`(L) = X
L
k=1
log N (λk|µ1(L), σ2
(L)) +
L
Xmax
k=L+1
log N (λk|µ2(L), σ2
(L)) (20.31)
This is illustrated in Figure 20.8. We see that the peak L
∗ = argmax `(L) is well determined.
20.2 Factor analysis *
PCA is a simple method for computing a linear low-dimensional representation of data. In this section,
we present a generalization of PCA known as factor analysis. This is based on a probabilistic
model, which means we can treat it as a building block for more complex models, such as the mixture
of FA models in Section 20.2.6, or the nonlinear FA model in Section 20.3.5. We can recover PCA as
a special limiting case of FA, as we discuss in Section 20.2.2.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.2. Factor analysis * 661
20.2.1 Generative model
Factor analysis corresponds to the following linear-Gaussian latent variable generative model:
p(z) = N (z|µ0, Σ0) (20.32)
p(x|z, θ) = N (x|Wz + µ, Ψ) (20.33)
where W is a D × L matrix, known as the factor loading matrix, and Ψ is a diagonal D × D
covariance matrix.
FA can be thought of as a low-rank version of a Gaussian distribution. To see this, note that the
induced marginal distribution p(x|θ) is a Gaussian (see Equation (3.38) for the derivation):
p(x|θ) = Z
N (x|Wz + µ, Ψ)N (z|µ0, Σ0)dz (20.34)
= N (x|Wµ0 + µ, Ψ + WΣ0WT
) (20.35)
Hence E [x] = Wµ0 + µ and Cov [x] = WCov [z]WT + Ψ = WΣ0WT + Ψ. From this, we see that
we can set µ0 = 0 without loss of generality, since we can always absorb Wµ0 into µ. Similarly, we
can set Σ0 = I without loss of generality, since we can always absorb a correlated prior by using a
new weight matrix, W˜ = WΣ− 1
2
0
. After these simplifications we have
p(z) = N (z|0, I) (20.36)
p(x|z) = N (x|Wz + µ, Ψ) (20.37)
p(x) = N (x|µ,WWT + Ψ) (20.38)
For example, suppose where L = 1, D = 2 and Ψ = σ
2
I. We illustrate the generative process in
this case in Figure 20.9. We can think of this as taking an isotropic Gaussian “spray can”, representing
the likelihood p(x|z), and “sliding it along” the 1d line defined by wz + µ as we vary the 1d latent
prior z. This induces an elongated (and hence correlated) Gaussian in 2d. That is, the induced
distribution has the form p(x) = N (x|µ, wwT + σ
2
I).
In general, FA approximates the covariance matrix of the visible vector using a low-rank decompo￾sition:
C = Cov [x] = WWT + Ψ (20.39)
This only uses O(LD) parameters, which allows a flexible compromise between a full covariance
Gaussian, with O(D2
) parameters, and a diagonal covariance, with O(D) parameters.
From Equation (20.39), we see that we should restrict Ψ to be diagonal, otherwise we could set
W = 0, thus ignoring the latent factors, while still being able to model any covariance. The marginal
variance of each visible variable is given by V [xd] =
PL
k=1 w
2
dk + ψd, where the first term is the
variance due to the common factors, and the second ψd term is called the uniqueness, and is the
variance term that is specific to that dimension.
We can estimate the parameters of an FA model using EM (see Section 20.2.3). Once we have
fit the model, we can compute probabilistic latent embeddings using p(z|x). Using Bayes rule for
Gaussians we have
p(z|x) = N (z|WTC−1
(x − µ), I − WTC−1W) (20.40)
where C is defined in Equation (20.39).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license662 Chapter 20. Dimensionality Reduction
Figure 20.9: Illustration of the FA generative process, where we have L = 1 latent dimension generating
D = 2 observed dimensions; we assume Ψ = σ
2
I. The latent factor has value z ∈ R, sampled from
p(z); this gets mapped to a 2d offset δ = zw, where w ∈ R
2
, which gets added to µ to define a Gaussian
p(x|z) = N (x|µ + δ, σ2
I). By integrating over z, we “slide” this circular Gaussian “spray can” along the
principal component axis w, which induces elliptical Gaussian contours in x space centered on µ. Adapted
from Figure 12.9 of [Bis06].
20.2.2 Probabilistic PCA
In this section, we consider a special case of the factor analysis model in which W has orthonormal
columns, Ψ = σ
2
I and µ = 0. This model is called probabilistic principal components analysis
(PPCA) [TB99], or sensible PCA [Row97]. The marginal distribution on the visible variables has
the form
p(x|θ) = Z
N (x|Wz, σ2
I)N (z|0, I)dz = N (x|µ, C) (20.41)
where
C = WWT + σ
2
I (20.42)
The log likelihood for PPCA is given by
log p(X|µ,W, σ2
) = −
ND
2
log(2π) −
N
2
log |C| − 1
2
X
N
n=1
(xn − µ)
TC−1
(xn − µ) (20.43)
The MLE for µ is x. Plugging in gives
log p(X|µ,W, σ2
) = −
N
2

D log(2π) + log |C| + tr(C−1S)

(20.44)
where S =
1
N
PN
n=1(xn − x)(xn − x)
T is the empirical covariance matrix.
In [TB99; Row97] they show that the maximum of this objective must satisfy
W = UL(LL − σ
2
I)
1
2 R (20.45)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.2. Factor analysis * 663
where UL is a D × L matrix whose columns are given by the L eigenvectors of S with largest
eigenvalues, LL is the L × L diagonal matrix of eigenvalues, and R is an arbitrary L × L orthogonal
matrix, which (WLOG) we can take to be R = I. In the noise-free limit, where σ
2 = 0, we see that
Wmle = ULL
1
2
L
, which is proportional to the PCA solution.
The MLE for the observation variance is
σ
2 =
1
D − L
X
D
i=L+1
λi (20.46)
which is the average distortion associated with the discarded dimensions. If L = D, then the
estimated noise is 0, since the model collapses to z = x.
To compute the likelihood p(X|µ,W, σ2
), we need to evaluate C−1 and log |C|, where C is a
D × D matrix. To do this efficiently, we can use the matrix inversion lemma to write
C−1 = σ
−2

I − WM−1WT

(20.47)
where the L × L dimensional matrix M is given by
M = WTW + σ
2
I (20.48)
When we plug in the MLE for W from Equation (20.45) (using R = I) we find
M = UL(LL − σ
2
I)UT
L + σ
2
I (20.49)
and hence
C−1 = σ
−2

I − UL(LL − σ
2
I)Λ
−1
L UT
L

(20.50)
log |C| = (D − L) log σ
2 +
X
L
j=1
log λj (20.51)
Thus we can avoid all matrix inversions (since Λ
−1
L = diag(1/λj )).
To use PPCA as an alternative to PCA, we need to compute the posterior mean E [z|x], which is
the equivalent of the encoder model. Using Bayes rule for Gaussians we have
p(z|x) = N (z|M−1WT
(x − µ), σ2M−1
) (20.52)
where M is defined in Equation (20.48). In the σ
2 = 0 limit, the posterior mean using the MLE
parameters becomes
E [z|x] = (WTW)
−1WT
(x − x) (20.53)
which is the orthogonal projection of the data into the latent space, as in standard PCA.
20.2.3 EM algorithm for FA/PPCA
In this section, we describe one method for computing the MLE for the FA model using the EM
algorithm, based on [RT82; GH96].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license664 Chapter 20. Dimensionality Reduction
20.2.3.1 EM for FA
In the E step, we compute the posterior embeddings
p(zi
|xi
, θ) = N (zi
|mi
, Σi) (20.54)
Σi , (IL + WTΨ−1W)
−1
(20.55)
mi , Σi(WTΨ−1
(xi − µ)) (20.56)
In the M step, it is easiest to estimate µ and W at the same time, by defining W˜ = (W, µ),
z˜ = (z, 1), Also, define
bi , E [˜z|xi
] = [mi
; 1] (20.57)
Ci , E
h
˜z˜zT
|xi
,
i
=

E

zzT
|xi

E [z|xi
]
E [z|xi
]
T
1

(20.58)
Then the M step is as follows:
Wˆ˜ =
"X
i
xib
T
i
# "X
i
Ci
#−1
(20.59)
Ψˆ =
1
N
diag (X
i

xi − Wˆ˜ bi

x
T
i
)
(20.60)
Note that these updates are for “vanilla” EM. A much faster version of this algorithm, based on
ECM, is described in [ZY08].
20.2.3.2 EM for (P)PCA
We can also use EM to fit the PPCA model, which provides a useful alternative to eigenvector
methods. This relies on the probabilistic formulation of PCA. However the algorithm continues to
work in the zero noise limit, σ
2 = 0, as shown by [Row97].
In particular, let Z˜ = Z
T be a L × N matrix storing the posterior means (low-dimensional
representations) along its columns. Similarly, let X˜ = XT store the original data along its columns.
From Equation (20.52), when σ
2 = 0, we have
Z˜ = (WTW)
−1WT X˜ (20.61)
This constitutes the E step. Notice that this is just an orthogonal projection of the data.
From Equation 20.59, the M step is given by
Wˆ =
"X
i
xiE [zi
]
T
# "X
i
E [zi
] E [zi
]
T
#−1
(20.62)
where we exploited the fact that Σ = Cov [zi
|xi
, θ] = 0I when σ
2 = 0.
It is worth comparing this expression to the MLE for multi-output linear regression (Equation 11.2),
which has the form W = (P
i
yix
T
i
)(P
i xix
T
i
)
−1
. Thus we see that the M step is like linear regression
where we replace the observed inputs by the expected values of the latent variables.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.2. Factor analysis * 665
In summary, here is the entire algorithm:
Z˜ = (WTW)
−1WT X˜ (E step) (20.63)
W = X˜ Z˜
T
(Z˜Z˜
T
)
−1
(M step) (20.64)
[TB99] showed that the only stable fixed point of the EM algorithm is the globally optimal solution.
That is, the EM algorithm converges to a solution where W spans the same linear subspace as that
defined by the first L eigenvectors. However, if we want W to be orthogonal, and to contain the
eigenvectors in descending order of eigenvalue, we have to orthogonalize the resulting matrix (which
can be done quite cheaply). Alternatively, we can modify EM to give the principal basis directly
[AO03].
This algorithm has a simple physical analogy in the case D = 2 and L = 1 [Row97]. Consider
some points in R
2 attached by springs to a rigid rod, whose orientation is defined by a vector w. Let
zi be the location where the i’th spring attaches to the rod. In the E step, we hold the rod fixed, and
let the attachment points slide around so as to minimize the spring energy (which is proportional to
the sum of squared residuals). In the M step, we hold the attachment points fixed and let the rod
rotate so as to minimize the spring energy. See Figure 20.10 for an illustration.
20.2.3.3 Advantages
EM for PCA has the following advantages over eigenvector methods:
• EM can be faster. In particular, assuming N, D  L, the dominant cost of EM is the projection
operation in the E step, so the overall time is O(T LND), where T is the number of iterations.
[Row97] showed experimentally that the number of iterations is usually very small (the mean
was 3.6), regardless of N or D. (This result depends on the ratio of eigenvalues of the empirical
covariance matrix.) This is much faster than the O(min(ND2
, DN2
)) time required by straightfor￾ward eigenvector methods, although more sophisticated eigenvector methods, such as the Lanczos
algorithm, have running times comparable to EM.
• EM can be implemented in an online fashion, i.e., we can update our estimate of W as the data
streams in.
• EM can handle missing data in a simple way (see e.g., [IR10; DJ15]).
• EM can be extended to handle mixtures of PPCA/ FA models (see Section 20.2.6).
• EM can be modified to variational EM or to variational Bayes EM to fit more complex models
(see e.g., Section 20.2.7).
20.2.4 Unidentifiability of the parameters
The parameters of a FA model are unidentifiable. To see this, consider a model with weights W and
observation covariance Ψ. We have
Cov [x] = WE

zzT
WT + E

T

= WWT + Ψ (20.65)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license666 Chapter 20. Dimensionality Reduction
-3 -2 -1 0 1 2 3
-2.5
-2
-1.5
-1
-0.5
0
0.5
1
1.5
2
2.5 E step 1
(a)
-3 -2 -1 0 1 2 3
-2.5
-2
-1.5
-1
-0.5
0
0.5
1
1.5
2
2.5 M step 1
(b)
-3 -2 -1 0 1 2 3
-2.5
-2
-1.5
-1
-0.5
0
0.5
1
1.5
2
2.5 E step 2
(c)
-3 -2 -1 0 1 2 3
-4
-3
-2
-1
0
1
2
3
4 M step 2
(d)
Figure 20.10: Illustration of EM for PCA when D = 2 and L = 1. Green stars are the original data points,
black circles are their reconstructions. The weight vector w is represented by blue line. (a) We start with a
random initial guess of w. The E step is represented by the orthogonal projections. (b) We update the rod w
in the M step, keeping the projections onto the rod (black circles) fixed. (c) Another E step. The black circles
can ’slide’ along the rod, but the rod stays fixed. (d) Another M step. Adapted from Figure 12.12 of [Bis06].
Generated by code at figures.probml.ai/book1/20.10.
Now consider a different model with weights W˜ = WR, where R is an arbitrary orthogonal rotation
matrix, satisfying RRT = I. This has the same likelihood, since
Cov [x] = W˜ E

zzT
W˜ T + E

T

= WRRTWT + Ψ = WWT + Ψ (20.66)
Geometrically, multiplying W by an orthogonal matrix is like rotating z before generating x; but
since z is drawn from an isotropic Gaussian, this makes no difference to the likelihood. Consequently,
we cannot uniquely identify W, and therefore cannot uniquely identify the latent factors, either.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.2. Factor analysis * 667
To break this symmetry, several solutions can be used, as we discuss below.
• Forcing W to have orthonormal columns. Perhaps the simplest solution to the identifiability
problem is to force W to have orthonormal columns. This is the approach adopted by PCA.
The resulting posterior estimate will then be unique, up to permutation of the latent dimensions.
(In PCA, this ordering ambiguity is resolved by sorting the dimensions in order of decreasing
eigenvalues of W.)
• Forcing W to be lower triangular. One way to resolve permutation unidentifiability, which
is popular in the Bayesian community (e.g., [LW04c]), is to ensure that the first visible feature is
only generated by the first latent factor, the second visible feature is only generated by the first
two latent factors, and so on. For example, if L = 3 and D = 4, the corresponding factor loading
matrix is given by
W =


w11 0 0
w21 w22 0
w31 w32 w33
w41 w42 w43


(20.67)
We also require that wkk > 0 for k = 1 : L. The total number of parameters in this constrained
matrix is D +DL−L(L−1)/2, which is equal to the number of uniquely identifiable parameters in
FA.3 The disadvantage of this method is that the first L visible variables, known as the founder
variables, affect the interpretation of the latent factors, and so must be chosen carefully.
• Sparsity promoting priors on the weights. Instead of pre-specifying which entries in W are
zero, we can encourage the entries to be zero, using `1 regularization [ZHT06], ARD [Bis99; AB08],
or spike-and-slab priors [Rat+09]. This is called sparse factor analysis. This does not necessarily
ensure a unique MAP estimate, but it does encourage interpretable solutions.
• Choosing an informative rotation matrix. There are a variety of heuristic methods that try
to find rotation matrices R which can be used to modify W (and hence the latent factors) so as
to try to increase the interpretability, typically by encouraging them to be (approximately) sparse.
One popular method is known as varimax [Kai58].
• Use of non-Gaussian priors for the latent factors. If we replace the prior on the latent
variables, p(z), with a non-Gaussian distribution, we can sometimes uniquely identify W, as well
as the latent factors. See e.g., [KKH20] for details.
20.2.5 Nonlinear factor analysis
The FA model assumes the observed data can be modeled as arising from a linear mapping from a
low-dimensional set of Gaussian factors. One way to relax this assumption is to let the mapping
from z to x be a nonlinear model, such as a neural network. That is, the model becomes
p(x) = Z
dz N (x|f(w; θ), Ψ)N (z|0, I) (20.68)
3. We get D parameters for Ψ and DL for W, but we need to remove L(L − 1)/2 degrees of freedom coming from R,
since that is the dimensionality of the space of orthogonal matrices of size L × L. To see this, note that there are L − 1
free parameters in R in the first column (since the column vector must be normalized to unit length), there are L − 2
free parameters in the second column (which must be orthogonal to the first), and so on.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license668 Chapter 20. Dimensionality Reduction
Figure 20.11: Mixture of factor analyzers as a PGM.
This is called nonlinear factor analysis. Unfortunately we can no longer compute the posterior or
the MLE exactly, so we need to use approximate methods. In Section 20.3.5, we discuss variational
autoencoders, which is the most common way to approximate a nonlinear FA model.
20.2.6 Mixtures of factor analysers
The factor analysis model (Section 20.2) assumes the observed data can be modeled as arising from
a linear mapping from a low-dimensional set of Gaussian factors. One way to relax this assumption
is to assume the model is only locally linear, so the overall model becomes a (weighted) combination
of FA models; this is called a mixture of factor analysers. The overall model for the data is a
mixture of linear manifolds, which can be used to approximate an overall curved manifold.
More precisely, let latent indicator cn ∈ {1, . . . , K}, specifying which subspace (cluster) we should
use to generate the data. If cn = k, we sample zn from a Gaussian prior and pass it through the
Wk matrix and add noise, where Wk maps from the L-dimensional subspace to the D-dimensional
visible space.4 More precisely, the model is as follows:
p(xn|zn, cn = k, θ) = N (xn|µk + Wkzn, Ψk) (20.69)
p(zn|θ) = N (zn|0, I) (20.70)
p(cn|θ) = Cat(cn|π) (20.71)
This is called a mixture of factor analysers (MFA) [GH96]. The corresponding distribution in
the visible space is given by
p(x|θ) = X
k
p(c = k)
Z
dz p(z|c)p(x|z, c) = X
k
πk
Z
dz N (z|µk, I)N (x|Wz, σ2
I) (20.72)
In the special case that Ψk = σ
2
I, we get a mixture of PPCA models (although it is difficult to
ensure orthogonality of the Wk in this case). See Figure 20.12 for an example of the method applied
to some 2d data.
We can think of this as a low-rank version of a mixture of Gaussians. In particular, this model
needs O(KLD) parameters instead of the O(KD2
) parameters needed for a mixture of full covariance
Gaussians. This can reduce overfitting.
4. If we allow zn to depend on cn, we can let each subspace have a different dimensionality, as suggested in [KS15].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.2. Factor analysis * 669
−2 −1.5 −1 −0.5 0 0.5 1 1.5 2
−1.5
−1
−0.5
0
0.5
1
1.5
(a)
−2 −1.5 −1 −0.5 0 0.5 1 1.5 2
−1.5
−1
−0.5
0
0.5
1
1.5
(b)
Figure 20.12: Mixture of PPCA models fit to a 2d dataset, using L = 1 latent dimensions. (a) K = 1 mixture
components. (b) K = 10 mixture components. Generated by code at figures.probml.ai/book1/20.12.
20.2.7 Exponential family factor analysis
So far we have assumed the observed data is real-valued, so xn ∈ R
D. If we want to model other
kinds of data (e.g., binary or categorical), we can simply replace the Gaussian output distribution
with a suitable member of the exponential family, where the natural parameters are given by a linear
function of zn. That is, we use
p(xn|zn) = exp(T (x)
Tθ + h(x) − g(θ)) (20.73)
where the N × D matrix of natural parameters is assumed to be given by the low rank decomposition
Θ = ZW, where Z is N × L and W is L × D. The resulting model is called exponential family
factor analysis.
Unlike the linear-Gaussian FA, we cannot compute the exact posterior p(zn|xn,W) due to the
lack of conjugacy between the expfam likelihood and the Gaussian prior. Furthermore, we cannot
compute the exact marginal likelihood either, which prevents us from finding the optimal MLE.
[CDS02] proposed a coordinate ascent method for a deterministic variant of this model, known as
exponential family PCA. This alternates between computing a point estimate of zn and W. This
can be regarded as a degenerate version of variational EM, where the E step uses a delta function
posterior for zn. [GS08] present an improved algorithm that finds the global optimum, and [Ude+16]
presents an extension called generalized low rank models, that covers many different kinds of
loss function.
However, it is often preferable to use a probabilistic version of the model, rather than computing
point estimates of the latent factors. In this case, we must represent the posterior using a non￾degenerate distribution to avoid overfitting, since the number of latent variables is proportional to
the number of datacases [WCS08]. Fortunately, we can use a non-degenerate posterior, such as a
Gaussian, by optimizing the variational lower bound. We give some examples of this below.
20.2.7.1 Example: binary PCA
Consider a factored Bernoulli likelihood:
p(x|z) = Y
d
Ber(xd|σ(wT
dz)) (20.74)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license670 Chapter 20. Dimensionality Reduction
Suppose we observe N = 150 bit vectors of length D = 6. Each example is generated by choosing one
of three binary prototype vectors, and then by flipping bits at random. See Figure 20.13(a) for the
data. We can fit this using the variational EM algorithm (see [Tip98] for details). We use L = 2 latent
dimensions to allow us to visualize the latent space. In Figure 20.13(b), we plot E
h
zn|xn,Wˆ
i
. We see
that the projected points group into three distinct clusters, as is to be expected. In Figure 20.13(c),
we plot the reconstructed version of the data, which is computed as follows:
p(ˆxnd = 1|xn) = Z
dzn p(zn|xn)p(ˆxnd|zn) (20.75)
If we threshold these probabilities at 0.5 (corresponding to a MAP estimate), we get the “denoised”
version of the data in Figure 20.13(d).
20.2.7.2 Example: categorical PCA
We can generalize the model in Section 20.2.7.1 to handle categorical data by using the following
likelihood:
p(x|z) = Y
d
Cat(xd|S(Wdz)) (20.76)
We call this categorical PCA (CatPCA). A variational EM algorithm for fitting this is described
in [Kha+10].
20.2.8 Factor analysis models for paired data
In this section, we discuss linear-Gaussian factor analysis models when we have two kinds of observed
variables, x ∈ R
Dx and y ∈ R
Dy , which are paired. These often correspond to different sensors or
modalities (e.g., images and sound). We follow the presentation of [Vir10].
20.2.8.1 Supervised PCA
In supervised PCA [Yu+06], we model the joint p(x, y) using a shared low-dimensional represen￾tation using the following linear Gaussian model:
p(zn) = N (zn|0, IL) (20.77)
p(xn|zn, θ) = N (xn|Wxzn, σ2
x
IDx
) (20.78)
p(yn|zn, θ) = N (yn|Wyzn, σ2
y
IDy
) (20.79)
This is illustrated as a graphical model in Figure 20.14a. The intuition is that zn is a shared latent
subspace, that captures features that xn and yn have in common. The variance terms σx and σy
control how much emphasis the model puts on the two different signals. If we put a prior on the
parameters θ = (Wx,Wy, σx, σy), we recover the Bayesian factor regression model of [Wes03].
We can marginalize out zn to get p(yn|xn). If yn is a scalar, this becomes
p(yn|xn, θ) = N (yn|x
T
nv, wT
yCwy + σ
2
y
) (20.80)
C = (I + σ
−2
x WT
xWx)
−1
(20.81)
v = σ
−2
x WxCwy (20.82)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.2. Factor analysis * 671
noisy binary data
2 4 6 8 10 12 14 16
20
40
60
80
100
120
140
(a)
-1.5 -1 -0.5 0 0.5 1 1.5 2
-1.5
-1
-0.5
0
0.5
1
1.5
latent embedding
(b)
Posterior predictive
2 4 6 8 10 12 14 16
20
40
60
80
100
120
140
(c)
Reconstruction
2 4 6 8 10 12 14 16
20
40
60
80
100
120
140
(d)
Figure 20.13: (a) 150 synthetic 16 dimensional bit vectors. (b) The 2d embedding learned by binary
PCA, fit using variational EM. We have color coded points by the identity of the true “prototype” that
generated them. (c) Predicted probability of being on. (d) Thresholded predictions. Generated by code at
figures.probml.ai/book1/20.13.
xn yn
zn
wx
l w
y
l
N
L
(a)
xn yn
z
s z n
x
n
b
x
l
wx
l w
y
l
N
L
s
L
x
(b)
Figure 20.14: Gaussian latent factor models for paired data. (a) Supervised PCA. (b) Partial least squares.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license672 Chapter 20. Dimensionality Reduction
xn yn
z
s z n
x
n z
y
n
b
x
l b
y
l
wx
l w
y
l
N
L
s
L
x L
y
Figure 20.15: Canonical correlation analysis as a PGM.
To apply this to the classification setting, we can use supervised ePCA [Guo09], in which we
replace the Gaussian p(y|z) with a logistic regression model.
This model is completely symmetric in x and y. If our goal is to predict y from x via the latent
bottleneck z, then we might want to upweight the likelihood term for y, as proposed in [Ris+08].
This gives
p(X, Y, Z|θ) = p(Y|Z,Wy)p(X|Z,Wx)
α
p(Z) (20.83)
where α ≤ 1 controls the relative importance of modeling the two sources. The value of α can be
chosen by cross-validation.
20.2.8.2 Partial least squares
Another way to improve the predictive performance in supervised tasks is to allow the inputs x
to have their own “private” noise source that is independent on the target variable, since not all
variation in x is relevant for predictive purposes. We can do this by introducing an extra latent
variable z
x
n
just for the inputs, that is different from z
s
n
that is the shared bottleneck between xn
and yn. In the Gaussian case, the overall model has the form
p(zn) = N (z
s
n
|0, I)N (z
x
n
|0, I) (20.84)
p(xn|zn, θ) = N (xn|Wxz
s
n + Bxz
x
n
, σ2
x
I) (20.85)
p(yn|zn, θ) = N (yn|Wyz
s
n
, σ2
y
I) (20.86)
See Figure 20.14b. MLE for θ in this model is equivalent to the technique of partial least squares
(PLS) [Gus01; Nou+02; Sun+09].
20.2.8.3 Canonical correlation analysis
In some cases, we want to use a fully symmetric model, so we can capture the dependence between x
and y, while allowing for domain-specific or “private” noise sources We can do this by introducing a
latent variable z
x
n
just for xn, a latent variable z
y
n
just for yn, and a shared latent variable z
s
n
. In
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.3. Autoencoders 673
x1
xd
xD
z1
zh
zH
x1
xd
xD
.
.
.
.
.
.
w1dh w2hd
Figure 20.16: An autoencoder with one hidden layer.
the Gaussian case, the overall model has the form
p(zn) = N (z
s
n
|0, I)N (z
x
n
|0, I) (20.87)
p(xn|zn, θ) = N (xn|Wxz
s
n + Bxz
x
n
, σ2
x
I) (20.88)
p(yn|zn, θ) = N (yn|Wyz
s
n + Byz
y
n
, σ2
y
I) (20.89)
where Wx and Wy are L
s ×D dimensional, Vx is L
x ×D dimensional, and Vy is L
y ×D dimensional.
See Figure 20.15 for the PGM.
If we marginalize out all the latent variables, we get the following distribution on the visibles
(where we assume σx = σy = σ):
p(xn, yn) = Z
dznp(zn)p(xn, yn|zn) = N (xn, yn|µ,WWT + σ
2
I) (20.90)
where µ = (µx; µy), and W = [Wx;Wy]. Thus the induced covariance is the following low rank
matrix:
WWT =
WxWT
x WxWT
y
WyWT
y WyWT
y

(20.91)
[BJ05] showed that MLE for this model is equivalent to a classical statistical method known as
canonical correlation analysis or CCA [Hot36]. However, the PGM perspective allows us to
easily generalize to multiple kinds of observations (this is known as generalized CCA [Hor61]) or
to nonlinear models (this is known as deep CCA [WLL16; SNM16]), or exponential family CCA
[KVK10]. See [Uur+17] for further discussion of CCA and its extensions.
20.3 Autoencoders
We can think of PCA (Section 20.1) and factor analysis (Section 20.2) as learning a (linear) mapping
from x → z, called the encoder, fe, and learning another (linear) mapping z → x , called the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license674 Chapter 20. Dimensionality Reduction
(a) (b)
Figure 20.17: Results of applying an autoencoder to the Fashion MNIST data. Top row are first 5 images
from validation set. Bottom row are reconstructions. (a) MLP model (trained for 20 epochs). The encoder is
an MLP with architecture 784-100-30. The decoder is the mirror image of this. (b) CNN model (trained for
5 epochs). The encoder is a CNN model with architecture Conv2D(16, 3x3, same, selu), MaxPool2D(2x2),
Conv2D(32, 3x3, same, selu), MaxPool2D(2x2), Conv2D(64, 3x3, same, selu), MaxPool2D(2x2). The decoder
is the mirror image of this, using transposed convolution and without the max pooling layers. Adapted from
Figure 17.4 of [Gér19]. Generated by code at figures.probml.ai/book1/20.17.
decoder, fd. The overall reconstruction function has the form r(x) = fd(fe(x)). The model is
trained to minimize L(θ) = ||r(x) − x||2
2
. More generally, we can use L(θ) = − log p(x|r(x)).
In this section, we consider the case where the encoder and decoder are nonlinear mappings
implemented by neural networks. This is called an autoencoder. If we use an MLP with one hidden
layer, we get the model shown Figure 20.16. We can think of the hidden units in the middle as a
low-dimensional bottleneck between the input and its reconstruction.
Of course, if the hidden layer is wide enough, there is nothing to stop this model from learning the
identity function. To prevent this degenerate solution, we have to restrict the model in some way. The
simplest approach is to use a narrow bottleneck layer, with L  D; this is called an undercomplete
representation. The other approach is to use L  D, known as an overcomplete representation,
but to impose some other kind of regularization, such as adding noise to the inputs, forcing the
activations of the hidden units to be sparse, or imposing a penalty on the derivatives of the hidden
units. We discuss these options in more detail below.
20.3.1 Bottleneck autoencoders
We start by considering the special case of a linear autoencoder, in which there is one hidden layer,
the hidden units are computed using z = W1x, and the output is reconstructed using xˆ = W2z,
where W1 is a L × D matrix, W2 is a D × L matrix, and L < D. Hence xˆ = W2W1x = Wx
is the output of the model. If we train this model to minimize the squared reconstruction error,
L(W) = PN
n=1 ||xn − Wxn||2
2
, one can show [BH89; KJ95] that Wˆ is an orthogonal projection onto
the first L eigenvectors of the empirical covariance matrix of the data. This is therefore equivalent to
PCA.
If we introduce nonlinearities into the autoencoder, we get a model that is strictly more powerful
than PCA, as proved in [JHG00]. Such methods can learn very useful low dimensional representations
of data.
Consider fitting an autoencoder to the Fashion MNIST dataset. We consider both an MLP
architecture (with 2 layers and a bottleneck of size 30), and a CNN based architecture (with 3 layers
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.3. Autoencoders 675
(a) (b)
Figure 20.18: tSNE plot of the first 2 latent dimensions of the Fashion MNIST validation set using
an autoencoder. (a) MLP. (b) CNN. Adapted from Figure 17.5 of [Gér19]. Generated by code at fig￾ures.probml.ai/book1/20.18.
(a) (b)
Figure 20.19: Denoising autoencoder (MLP architecture) applied to some noisy Fashion MNIST images from
the validation set. (a) Gaussian noise. (b) Bernoulli dropout noise. Top row: input. Bottom row: output.
Adapted from Figure 17.9 of [Gér19]. Generated by code at figures.probml.ai/book1/20.19.
and a 3d bottleneck with 64 channels). We use a Bernoulli likelihood model and binary cross entropy
as the loss. Figure 20.17 shows some test images and their reconstructions. We see that the CNN
model reconstructs the images more accurately than the MLP model. However, both models are
small, and were only trained for 5 epochs; results can be improved by using larger models, and
training for longer.
Figure 20.18 visualizes the first 2 (of 30) latent dimensions produced by the MLP-AE. More
precisely, we plot the tSNE embeddings (see Section 20.4.10), color coded by class label. We also
show some corresponding images from the dataset, from which the embeddings were derived. We see
that the method has done a good job of separating the classes in a fully unsupervised way. We also
see that the latent space of the MLP and CNN models is very similar (at least when viewed through
this 2d projection).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license676 Chapter 20. Dimensionality Reduction
Figure 20.20: The residual error from a DAE, e(x) = r(x˜) − x, can learn a vector field corresponding to
the score function. Arrows point towards higher probability regions. The length of the arrow is proportional
to ||e(x)||, so points near the 1d data manifold (represented by the curved line) have smaller arrows. From
Figure 5 of [AB14]. Used with kind permission of Guillaume Alain.
20.3.2 Denoising autoencoders
One useful way to control the capacity of an autoencoder is to add noise to its input, and then
train the model to reconstruct a clean (uncorrupted) version of the original input. This is called a
denoising autoencoder [Vin+10a].
We can implement this by adding Gaussian noise, or using Bernoulli dropout. Figure 20.19 shows
some reconstructions of corrupted images computed using a DAE. We see that the model is able to
“hallucinate” details that are missing in the input, since it has seen similar images before, and can
store this information in the parameters of the model.
Suppose we train a DAE using Gaussian corruption and squared error reconstruction, i.e., we use
pc(x˜|x) = N (x˜|x, σ2
I) and `(x, r(x˜)) = ||e||2
2
, where e(x) = r(x˜)−x is the residual error for example
x. Then one can show [AB14] the remarkable result that, as σ → 0 (and with a sufficiently powerful
model and enough data), the residuals approximate the score function, which is the log probability
of the data, i.e., e(x) ≈ ∇x log p(x). That is, the DAE learns a vector field, corresponding to the
gradient of the log data density. Thus points that are close to the data manifold will be projected
onto it via the sampling process. See Figure 20.20 for an illustration.
20.3.3 Contractive autoencoders
A different way to regularize autoencoders is by adding the penalty term
Ω(z, x) = λ||∂fe(x)
∂x
||2
F = λ
X
k
||∇x hk(x)||2
2
(20.92)
to the reconstruction loss, where hk is the value of the k’th hidden embedding unit. That is, we
penalize the Frobenius norm of the encoder’s Jacobian. This is called a contractive autoencoder
[Rif+11]. (A linear operator with Jacobian J is called a contraction if ||Jx|| ≤ 1 for all unit-norm
inputs x.)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.3. Autoencoders 677
To understand why this is useful, consider Figure 20.20. We can approximate the curved low￾dimensional manifold by a series of locally linear manifolds. These linear approximations can be
computed using the Jacobian of the encoder at each point. By encouraging these to be contractive,
we ensure the model “pushes” inputs that are off the manifold to move back towards it.
Another way to think about CAEs is as follows. To minimize the penalty term, the model would
like to ensure the encoder is a constant function. However, if it was completely constant, it would
ignore its input, and hence incur high reconstruction cost. Thus the two terms together encourage
the model to learn a representation where only a few units change in response to the most significant
variations in the input.
One possible degenerate solution is that the encoder simply learns to multiply the input by a
small constant  (which scales down the Jacobian), followed by a decoder that divides by  (which
reconstructs perfectly). To avoid this, we can tie the weights of the encoder and decoder, by setting
the weight matrix for layer ` of fd to be the transpose of the weight matrix for layer ` of fe, but
using untied bias terms. Unfortunately CAEs are slow to train, because of the expense of computing
the Jacobian.
20.3.4 Sparse autoencoders
Yet another way to regularize autoencoders is to add a sparsity penalty to the latent activations of
the form Ω(z) = λ||z||1. (This is called activity regularization.)
An alternative way to implement sparsity, that often gives better results, is to use logistic units,
and then to compute the expected fraction of time each unit k is on within a minibatch (call this qk),
and ensure that this is close to a desired target value p, as proposed in [GBB11]. In particular, we use
the regularizer Ω(z1:L,1:N ) = λ
P
k DKL (pkqk) for latent dimensions 1 : L and examples 1 : N, where
p = (p, 1 − p) is the desired target distribution, and qk = (qk, 1 − qk) is the empirical distribution for
unit k, computed using qk =
1
N
PN
n=1 I(zn,k = 1).
Figure 20.21 shows the results when fitting an AE-MLP (with 300 hidden units) to Fashion MNIST.
If we set λ = 0 (i.e., if we don’t impose a sparsity penalty), we see that the average activation value
is about 0.4, with most neurons being partially activated most of the time. With the `1 penalty, we
see that most units are off all the time, which means they are not being used at all. With the KL
penalty, we see that about 70% of neurons are off on average, but unlike the `1 case, we don’t see
units being permanently turned off (the average activation level is 0.1). This latter kind of sparse
firing pattern is similar to that observed in biological brains (see e.g., [Bey+19]).
20.3.5 Variational autoencoders
In this section, we discuss the variational autoencoder or VAE [KW14; RMW14; KW19a], which
can be thought of as a probabilistic version of a deterministic autoencoder (Section 20.3) The principal
advantage is that a VAE is a generative model that can create new samples, whereas an autoencoder
just computes embeddings of input vectors.
We discuss VAEs in detail in the sequel to this book, [Mur22]. However, in brief, the VAE combines
two key ideas. First we create a non-linear extension of the factor analysis generative model, i.e., we
replace p(x|z) = N (x|Wz, σ2
I) with
pθ(x|z) = N (x|fd(z; θ), σ2
I) (20.93)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license678 Chapter 20. Dimensionality Reduction
0 50 100 150 200 250
0
20
40
60
80
0 50 100 150 200 250
0
20
40
60
80
0 50 100 150 200 250
0
20
40
60
80
0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
Activation
0%
5%
10%
15%
20%
25%
30%
35%
% Activations
Overall Mean = 0.39
0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
Activation
0%
20%
40%
60%
80%
100%
% Activations
Overall Mean = 0.02
0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
Activation
0%
20%
40%
60%
80%
100%
% Activations
Overall Mean = 0.11
0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
Neuron Mean Activation
0%
5%
10%
15%
20%
25%
30%
35%
% Neurons
0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
Neuron Mean Activation
0%
20%
40%
60%
80%
100%
% Neurons
0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
Neuron Mean Activation
0%
20%
40%
60%
80%
100%
% Neurons
Figure 20.21: Neuron activity (in the bottleneck layer) for an autoencoder applied to Fashion MNIST. We
show results for three models, with different kinds of sparsity penalty: no penalty (left column), `1 penalty
(middle column), KL penalty (right column). Top row: Heatmap of 300 neuron activations (columns) across
100 examples (rows). Middle row: Histogram of activation levels derived from this heatmap. Bottom row:
Histogram of the mean activation per neuron, averaged over all examples in the validation set. Adapted from
Figure 17.11 of [Gér19]. Generated by code at figures.probml.ai/book1/20.21.
where fd is the decoder. For binary observations we should use a Bernoulli likelihood:
p(x|z, θ) = Y
D
i=1
Ber(xi
|fd(z; θ), σ2
I) (20.94)
Second, we create another model, q(z|x), called the recognition network or inference network,
that is trained simultaneously with the generative model to do approximate posterior inference. If
we assume the posterior is Gaussian, with diagonal covariance, we get
qφ(z|x) = N (z|fe,µ(x; φ), diag(fe,σ(x; φ))) (20.95)
where fe is the encoder. See Figure 20.22 for a sketch.
The idea of training an inference network to “invert” a generative network, rather than running
an optimization algorithm to infer the latent code, is called amortized inference. This idea was
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.3. Autoencoders 679
Figure 20.22: Schematic illustration of a VAE. From a figure from http: // krasserm. github. io/ 2018/
07/ 27/ dfc-vae/ . Used with kind permission of Martin Krasser.
first proposed in the Helmholtz machine [Day+95]. However, that paper did not present a single
unified objective function for inference and generation, but instead used the wake sleep method for
training, which alternates between optimizing the generative model and inference model. By contrast,
the VAE optimizes a variational lower bound on the log-likelihood, which is more principled, since it
is a single unified objective.
20.3.5.1 Training VAEs
We cannot compute the exact marginal likelihood p(x|θ) needed for MLE training, because posterior
inference in a nonlinear FA model is intractable. However, we can use the inference network to
compute an approximate posterior, q(z|x). We can then use this to compute the evidence lower
bound or ELBO. For a single example x, this is given by
Ł(θ, φ|x) = Eqφ(z|x)
[log pθ(x, z) − log qφ(z|x)] (20.96)
= Eq(z|x,φ)
[log p(x|z, θ)] − DKL (q(z|x, φ)kp(z)) (20.97)
This can be interpreted as the expected log likelihood, plus a regularizer, that penalizes the posterior
from deviating too much from the prior. (This is different than the approach in Section 20.3.4, where
we applied the KL penalty to the aggregate posterior in each minibatch.)
The ELBO is a lower bound of the log marginal likelihood (aka evidence), as can be seen from
Jensen’s inequality:
Ł(θ, φ|x) = Z
qφ(z|x) log pθ(x, z)
qφ(z|x)
dz (20.98)
≤ log Z
qφ(z|x)
pθ(x, z)
qφ(z|x)
dz = log pθ(x) (20.99)
Thus for fixed inference network parameters φ, increasing the ELBO should increase the log likelihood
of the data, similar to EM Section 8.7.2.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license680 Chapter 20. Dimensionality Reduction
Encoder
( )
Decoder
( )
Sample from
Encoder
( )
Decoder
( )
Sample from
*
+
Figure 20.23: Computation graph for VAEs. where p(z) = N (z|0, I), p(x|z, θ) = N (x|f(z), σ2
I), and
q(z|x, φ) = N (z|µ(x), Σ(x)). Red boxes show sampling operations which are not differentiable. Blue boxes
show loss layers (we assume Gaussian likelihoods and priors). (a) Without the reparameterization trick. (b)
With the reparameterization trick. Gradients can flow from the output loss, back through the decoder and into
the encoder. From Figure 4 of [Doe16]. Used with kind permission of Carl Doersch.
20.3.5.2 The reparameterization trick
In this section, we discuss how to compute the ELBO and its gradient. For simplicity, let us suppose
that the inference network estimates the parameters of a Gaussian posterior. Since qφ(z|x) is
Gaussian, we can write
z = fe,µ(x; φ) + fe,σ(x; φ)   (20.100)
where  ∼ N (0, I). Hence
Ł(θ, φ|x) = E∼N(0,I)
[log pθ(x|z = µφ(x) + σφ(x)  )] − DKL (qφ(z|x)kp(z)) (20.101)
Now the expectation is independent of the parameters of the model, so we can safely push gradients
inside and use backpropagation for training in the usual way, by minimizing −Ex∼D [Ł(θ, φ|x)] wrt
θ and φ. This is known as the reparameterization trick. See Figure 20.23 for an illustration.
The first term in the ELBO can be approximated by sampling , scaling it by the output of the
inference network to get z, and then evaluating log p(x|z) using the decoder network.
The second term in the ELBO is the KL of two Gaussians, which has a closed form solution. In
particular, inserting p(z) = N (z|0, I) and q(z) = N (z|µ, diag(σ)) into Equation (6.33), we get
DKL (qkp) = X
K
k=1

log( 1
σk
) + σ
2
k + (µk − 0)2
2 · 1
−
1
2

= −
1
2
X
K
k=1

log σ
2
k − σ
2
k − µ
2
k + 1
(20.102)
20.3.5.3 Comparison of VAEs and autoencoders
VAEs are very similar to autoencoders. In particular, the generative model, pθ(x|z), acts like the
decoder, and the inference network, qφ(z|x), acts like the encoder. The reconstruction abilities of
both models are similar, as can be seen by comparing Figure 20.24a with Figure 20.24b.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.3. Autoencoders 681
0 50 100 150 200 250
0
20
40
60
0 50 100 150 200 250
0
20
40
60
(a)
0 50 100 150 200
0
20
40
60
0 50 100 150 200 250
0
20
40
60
(b)
Figure 20.24: Reconstructing MNIST digits using a 20 dimensional latent space. Top row: input images. Bot￾tom row: reconstructions. (a) VAE. (b) Deterministic AE. Generated by code at figures.probml.ai/book1/20.24.
0 50 100 150 200 250
0
20
40
60
(a)
0 50 100 150 200 250
0
20
40
60
(b)
Figure 20.25: Sampling MNIST digits using a 20 dimensional latent space. (a) VAE. (b) Deterministic AE.
Generated by code at figures.probml.ai/book1/20.25.
The primary advantage of the VAE is that it can be used to generate new data from random
noise. In particular, we sample z from the Gaussian prior N (z|0, I), and then pass this through the
decoder to get E [x|z] = fd(z; θ). The VAE’s decoder is trained to convert random points in the
embedding space (generated by perturbing the input encodings) to sensible outputs. By contrast,
the decoder for the deterministic autoencoder only ever gets as inputs the exact encodings of the
training set, so it does not know what to do with random inputs that are outside what it was trained
on. So a standard autoencoder cannot create new samples. This difference can be seen by comparing
Figure 20.25a with Figure 20.25b.
The reason the VAE is better at sample is that it it embeds images into Gaussians in latent space,
whereas the AE embeds images into points, which are like delta functions. The advantage of using a
latent distribution is that it encourages local smoothness, since a given image may map to multiple
nearby places, depending on the stochastic sampling. By contrast, in an AE, the latent space is
typically not smooth, so images from different classes often end up next to each other. This difference
can be seen by comparing Figure 20.26a with Figure 20.26b.
We can leverage the smoothness of the latent space to perform image interpolation. Rather than
working in pixel space, we can work in the latent space of the model. Specifically, let x1 and x2 be
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license682 Chapter 20. Dimensionality Reduction
80 60 40 20 0 20 40 60 80
75
50
25
0
25
50
75
VAE mnist embedding
0
1
2
3
4
5
6
7
8
9
(a)
60 40 20 0 20 40 60
80
60
40
20
0
20
40
60
VAE mnist embedding
0
1
2
3
4
5
6
7
8
9
(b)
Figure 20.26: tSNE projection of a 20 dimensional latent space. (a) VAE. (b) Deterministic AE. Generated
by code at figures.probml.ai/book1/20.26.
0 50 100 150 200 250
0
20
(a)
0 50 100 150 200 250
0
20
(b)
Figure 20.27: Linear interpolation between the left and right images in a 20 dimensional latent space. (a)
VAE. (b) Deterministic AE. Generated by code at figures.probml.ai/book1/20.27.
two images, and let z1 = Eq(z|x1)
[z] and z2 = Eq(z|x2)
[z] be their encodings. We can now generate
new images that interpolate between these two anchors by computing z = λz1 + (1 − λ)z2, where
0 ≤ λ ≤ 1, and then decoding by computing E [x|z]. This is called latent space interpolation.
(The justification for taking a linear interpolation is that the learned manifold has approximately
zero curvature, as shown in [SKTF18].) A VAE is more useful for latent space interpolation than an
AE because its latent space is smoother, and because the model can generate from almost any point
in latent space. This difference can be seen by comparing Figure 20.27a with Figure 20.27b.
20.4 Manifold learning *
In this section, we discuss the problem of recovering the underlying low-dimensional structure in
a high-dimensional dataset. This structure is often assumed to be a curved manifold (explained
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.4. Manifold learning * 683
Figure 20.28: Illustration of the tangent space and tangent vectors at two different points on a 2d curved
manifold. From Figure 1 of [Bro+17a]. Used with kind permission of Michael Bronstein.
in Section 20.4.1), so this problem is called manifold learning or nonlinear dimensionality
reduction. The key difference from methods such as autoencoders (Section 20.3) is that we will
focus on non-parametric methods, in which we compute an embedding for each point in the training
set, as opposed to learning a generic model that can embed any input vector. That is, the methods
we discuss do not (easily) support out-of-sample generalization. However, they can be easier
to fit, and are quite flexible. Such methods can be a useful for unsupervised learning (knowledge
discovery), data visualization, and as a preprocessing step for supervised learning. See [AAB21] for a
recent review of this field.
20.4.1 What are manifolds?
Roughly speaking, a manifold is a topological space which is locally Euclidean. One of the simplest
examples is the surface of the earth, which is a curved 2d surface embedded in a 3d space. At each
local point on the surface, the earth seems flat.
More formally, a d-dimensional manifold X is a space in which each point x ∈ X has a neighborhood
which is topologically equivalent to a d-dimensional Euclidean space, called the tangent space,
denoted Tx = TxX . This is illustrated in Figure 20.28.
A Riemannian manifold is a differentiable manifold that associates an inner product operator
at each point x in tangent space; this is assumed to depend smoothly on the position x. The inner
product induces a notion of distance, angles, and volume. The collection of these inner products is
called a Riemannian metric. It can be shown that any sufficiently smooth Riemannian manifold
can be embedded into a Euclidean space of potentially higher dimension; the Riemannian inner
product at a point then becomes Euclidean inner product in that tangent space.
20.4.2 The manifold hypothesis
Most “naturally occuring” high dimensional dataset lie a low dimensional manifold. This is called the
manifold hypothesis [FMN16]. For example, consider the case of an image. Figure 20.29a shows a
single image of size 64 × 57. This is a vector in a 3,648-dimensional space, where each dimension
corresponds to a pixel intensity. Suppose we try to generate an image by drawing a random point
in this space; it is unlikely to look like the image of a digit, as shown in Figure 20.29b. However,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license684 Chapter 20. Dimensionality Reduction
(a) (b)
−0.1 −0.05 0 0.05 0.1 −0.1
−0.05
0
0.05
0.1
PC no 1
PC no 2
(c)
Figure 20.29: Illustration of the image manifold. (a) An image of the digit 6 from the USPS dataset, of
size 64 × 57 = 3, 648. (b) A random sample from the space {0, 1}
3648 reshaped as an image. (c) A dataset
created by rotating the original image by one degree 360 times. We project this data onto its first two principal
components, to reveal the underlying 2d circular manifold. From Figure 1 of [Law12]. Used with kind
permission of Neil Lawrence.
Method Parametric Convex Section
PCA / classical MDS N Y (Dense) Section 20.1
Kernel PCA N Y (Dense) Section 20.4.6
Isomap N Y (Dense) Section 20.4.5
LLE N Y (Sparse) Section 20.4.8
Laplacian Eigenmaps N Y (Sparse) Section 20.4.9
tSNE N N Section 20.4.10
Autoencoder Y N Section 20.3
Table 20.1: A list of some approaches to dimensionality reduction. If a method is convex, we specify in
parentheses whether it requires solving a sparse or dense eigenvalue problem.
the pixels are not independent of each other, since they are generated by some lower dimensional
structure, namely the shape of the digit 6.
As we vary the shape, we will generate different images. We can often characterize the space of
shape variations using a low-dimensional manifold. This is illustrated in Figure 20.29c, where we
apply PCA (Section 20.1) to project a dataset of 360 images, each one a slightly rotated version
of the digit 6, into a 2d space. We see that most of the variation in the data is captured by an
underlying curved 2d manifold. We say that the intrinsic dimensionality d of the data is 2, even
though the ambient dimensionality D is 3,648.
20.4.3 Approaches to manifold learning
In the rest of this section, we discuss ways to learn manifolds from data. There are many different
algorithms that have been proposed, which make different assumptions about the nature of the
manifold, and which have different computational properties. We discuss a few of these methods in
the following sections. For more details, see e.g., [Bur10].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.4. Manifold learning * 685
(a) (b)
Figure 20.30: Illustration of some data generated from low-dimensional manifolds. (a) The 2d Swiss-roll
manifold embedded into 3d. Generated by code at figures.probml.ai/book1/20.30. (b) Sample of some UCI
digits, which have size 8 × 8 = 64. Generated by code at figures.probml.ai/book1/20.30.
The methods can be categorized as shown in Table 20.1. The term “nonparametric” refers to
methods that learn a low dimensional embedding zi for each datapoint xi
, but do not learn a mapping
function which can be applied to an out-of-sample datapoint. (However, [Ben+04b] discusses how to
extend many of these methods beyond the training set by learning a kernel.)
In the sections below, we compare some of these methods using 2 different datasets: a set of
1000 3d-points sampled from the 2d “Swiss roll” manifold, and a set of 1797 64-dimensional points
sampled from the UCI digits dataset. See Figure 20.30 for an illustration of the data. We will learn
a 2d manifold, so we can visualize the data.
20.4.4 Multi-dimensional scaling (MDS)
The simplest approach to manifold learning is multidimensional scaling (MDS). This tries to
find a set of low dimensional vectors {zi ∈ R
L : i = 1 : N} such that the pairwise distances between
these vectors is as similar as possible to a set of pairwise dissimilarities D = {dij} provided by the
user. There are several variants of MDS, one of which turns out to be equivalent to PCA, as we
discuss below.
20.4.4.1 Classical MDS
Suppose we start an N × D data matrix X with rows xi
. Let us define the centered Gram (similarity)
matrix as follows:
K˜
ij = hxi − x, xj − xi (20.103)
In matrix notation, we have K˜ = X˜ X˜ T, where X˜ = CN X and CN = IN −
1
N
1N 1
T
N is the centering
matrix.
Now define the strain of a set of embeddings as follows:
Lstrain(Z) = X
i,j
(K˜
ij − hz˜i
, z˜j i)
2 = ||K˜ − Z˜Z˜T
||2
F (20.104)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license686 Chapter 20. Dimensionality Reduction
where z˜i = zi − z is the centered embedding vector. Intuitively this measures how well similarities in
the high-dimensional data space, K˜
ij , are matched by similarities in the low-dimensional embedding
space, hz˜i
, z˜j i. Minimizing this loss is called classical MDS.
We know from Section 7.5 that the best rank L approximation to a matrix is its truncated SVD
representation, K˜ = USVT. Since K˜ is positive semi definite, we have that V = U. Hence the
optimal embedding satisfies
Z˜Z˜T = USUT = (US 1
2 )(S
1
2 UT
) (20.105)
Thus we can set the embedding vectors to be the rows of Z˜ = US 1
2 .
Now we describe how to apply classical MDS to a dataset where we just have Euclidean distances,
rather than raw features. First we compute a matrix of squared Euclidean distances, D(2) = D  D,
which has the following entries:
D
(2)
ij = ||xi − xj ||2 = ||xi − x||2 + ||xj − x||2 − 2hxi − x, xj − xi (20.106)
= ||xi − x||2 + ||xj − x||2 − 2K˜
ij (20.107)
We see that D(2) only differs from K˜ by some row and column constants (and a factor of -2). Hence
we can compute K˜ by double centering D(2) using Equation (7.89) to get K˜ = −
1
2CN D(2)CN . In
other words,
K˜
ij = −
1
2
 
d
2
ij −
1
N
X
N
l=1
d
2
il −
1
N
X
N
l=1
d
2
jl +
1
N2
X
N
l=1
X
N
m=1
d
2
lm!
(20.108)
We can then compute the embeddings as before.
It turns out that classical MDS is equivalent to PCA (Section 20.1). To see this, let K˜ = ULSLUT
L
be the rank L truncated SVD of the centered kernel matrix. The MDS embedding is given by
ZMDS = ULS
1
2
L
. Now consider the rank L SVD of the centered data matrix, X˜ = UXSXVT
X. The
PCA embedding is ZPCA = UXSX. Now
K˜ = X˜ X˜ T = UXSXVT
XVXSXUT
X = UXS
2
XUT
X = ULSLUT
L (20.109)
Hence UX = UL and SX = S
2
L
, and so ZPCA = ZMDS.
20.4.4.2 Metric MDS
Classical MDS assumes Euclidean distances. We can generalize it to allow for any dissimilarity
measure by defining the stress function
Lstress(Z) =
vuut
P
i<j (di,j − ˆdij )
2
P
ij d
2
ij
(20.110)
where ˆdij = ||zi − zj ||. This is called metric MDS. Note that this is a different objective than the
one used by classical MDS, so even if dij are Euclidean distances, the results will be different.
We can use gradient descent to solve the optimization problem. However, it is better to use an
bound optimization algorithm (Section 8.7) called SMACOF [Lee77], which stands for “Scaling
by MAjorizing a COmplication Function”. (This is the method implemented in scikit-learn.) See
Figure 20.31 for the results of applying this to our running example.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.4. Manifold learning * 687
manifold-swiss-noise-0-MDS
(a)
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7 7
3
5
1
00
2
2
7
8
2
0
1
2
6
3
3
7
3
3
4
6
6
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
4 6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8
8
4
9
0
8
9
8
0
1
2
3
4
5
6
7
9 8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0 9
8
9
8
4
1
7
7
3
5
1
0
0
2 2
7
8
2
0
1
6 2
3
3
7
3
3
4
6
6
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
3
1
3
9
1
7
6
8
4
3
4 1
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
5
4
8
8
4
9
0
8
9
8
0
1 2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
0 9
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0
0
2
2
7
8
2
0
1
2
6
3
3
7
3
3
4
6 6
6
4
9
1
5
0
5 9
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1 3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8
8
4
9
0
8
9
3
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9 0
1
2
3
4 5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0 0
2
2
7
8
2
0
1
2
6
3
3
3 7
3
4 6
6
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1 7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4 4
7
2
8
2
2
5
7
9
5
4
8 8
4
9
0
8
9
8 0
1
2
3
4
5
6
7
9 8
0
1
2
3
4
5
6
7
8
9 0
1
2
3
4
5
6
8 7
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0
0
2
2
7
8
2
0
1
2
6
3
3
7
3
3
4
6
6
6
4
9
1
5
0
9
5
8 2
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
4 1
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8
8
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7 7
3
5
1
0
0
2
2
7
8
2
0
1 2
6
3
3
7
3
3
4
6
6
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7 5
4
47
2
8
2
2
5
7
9
5
4
8
8
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
0 9
1
2
3
4
5
6
7
8
9
0
9 5
5
6
5
0
9
8
9
8
4 1
7
7
3
5
1
00
2
7 2
8
2
0
1
2
6
3
3
7
3
3
4
6 6
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6 8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8
8
4
9
0
8
9
8
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5 5
6
5
0 9
8 9 8
4
1
7
7
3
5
1
2
7
8
2
0
1
2
6
3
3
7
3 3
4
6
6
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9 8
9
8
4
1
7
7
3
5
1
0 0
7
8
2
0
1
2
6
3 3
7
3
3
4
6
6 6
4
9
1
5
0
9
5
2
8
2
0 0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8
8 4
9
0
8
9
8
0
1
2
3
4
5
6
7
9 8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0
0
2
2
8 7
2
0
1
2
6
3
3
7
3
3
4
6 6
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8
8
4
0 9
8
9
8
0
1
2
3
4
5
6
8 7
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
00
2
2
7
8
2
0
1
6 2
3
3
7
3
3
4
6
66
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7 4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4 8
8
4
9
0
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4 5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0
0
2
2
7
8
2
0
1
2
6 3 3
7
3
3
4
6
6
6
4
9
1
5
0
9
5
2
8
2
0 0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
4 8
3
1
4
0
5
3
6
9
6
1 7
5
4
4
7
2
8
2
2
5
7
9
5
4
8
8
4
9
0
8 9
0 8
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
9
0
1
2 3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0
0
2
2
7
8
2
0
1
2
6
3 3 7
3
3
4
6 6
6
4
9
1
5
0
9
5
2
8
0
1
7
6
3
2
1
7
4
6
3
1
93
1
7
6
8
4
3
1
4
0
5
3
6
9
6 1
7
5
4
4
7
2
2
5
7
9
5
4
4
9
0
8
8 9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4 5
6
7
8
9
0
9
5 5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0
0
2
2
7
8
2
0
1
2
6
3
3
7
3
3
4
6
6
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
3 1
9
1
7
6
8
4
3 1
4
0
5
3
6
9
6
1 7
5
4
4
7
2
8
2
2
5
7
9
5
4
8
8
4
9
0
8
9
8
MDS embedding
(b)
Figure 20.31: Metric MDS applied to (a) Swiss roll. Generated by code at figures.probml.ai/book1/20.31. (b)
UCI digits. Generated by code at figures.probml.ai/book1/20.31.
20.4.4.3 Non-metric MDS
Instead of trying to match the distance between points, we can instead just try to match the ranking
of how similar points are. To do this, let f(d) be a monotonic transformation from distances to ranks.
Now define the loss
LNM(Z) =
vuut
P
i<j (f(di,j ) − ˆdij )
2
P
ij
ˆd
2
ij
(20.111)
where ˆdij = ||zi − zj ||. Minimizing this is known as non-metric MDS.
This objective can be optimized iteratively. First the function f is optimized, for a given Z, using
isotonic regression; this finds the optimal monotonic transformation of the input distances to match
the current embedding distances. Then the embeddings Z are optimized, for a given f, using gradient
descent, and the process repeats.
20.4.4.4 Sammon mapping
Metric MDS tries to minimize the sum of squared distances, so it puts the most emphasis on large
distances. However, for many embedding methods, small distances matter more, since they capture
local structure. One way to capture this is to divide each term of the loss by dij , so small distances
get upweighted:
Lsammon(Z) = 
1
P
i<j dij !X
i6=j
(
ˆdij − dij )
2
dij
(20.112)
Minimizing this results in a Sammon mapping. (The coefficient in front of the sum is just to
simplify the gradient of the loss.) Unfortunately this is a non-convex objective, and it arguably puts
too much emphasis on getting very small distances exactly right. We will discuss better methods for
capturing local structure later on.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license688 Chapter 20. Dimensionality Reduction
(a) (b)
Figure 20.32: (a) If we measure distances along the manifold, we find d(1, 6) > d(1, 4), whereas if we measure
in ambient space, we find d(1, 6) < d(1, 4). The plot at the bottom shows the underlying 1d manifold. (b) The
K-nearest neighbors graph for some datapoints; the red path is the shortest distance between A and B on this
graph. From [Hin13]. Used with kind permission of Geoff Hinton.
manifold-swiss-noise-0-Isomap
(a)
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0
0
2
2
7
8
2
0
1
2
6
3 3
7
3
3
4
6
6 6
4
9
1
5
0
9
5
8 2
2
0
0
7 1
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8
8
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
7 6
8
9
0
1
2
3
4
5
7 6
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7 7
3
5
1
0
0
2
2
7
8
2
0
1
2
6
3
3
7
33
4
6
6 6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
7 1
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1 7 5
4
4
2
8
2
2
5 5
4
8
8
4
9
0
8
9
8
1 0
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9 0
1
2
3
4
5
6
7 8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0 0
2
2
7
2 8
0
1
2
6
3
3
7
3
3
4
6
6
6
4
9
1 5
0
9 5
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6 7 1
5
4
4
7
2
8
2
2
5
7 9
5
4
8
8
4
9
8 0
9
3
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
1 0
2
3
4
5
6 7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1 0
0
2 2
7
8
2
0
1
2
6
3 3
7
3
3
4
66 6
4
9
1
5
0
9
5
2
2 8
0
0
1 7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
5 0
3
6
9
6
1
7 5
4
4
7
2
8
2
2
5
7
9
5
4
8
8
4
9
0
8
9
8
0
1
2
3
4
5
6
7 8
9
0
1
2
3
4
5
6
7
8
9
1 0
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0
0
2
2
7
8
2
0
1
2
6
3
3
7
3
3
4
6
6 6
4
9
1
5
0
9
5
2
8
2
0
0
7 1
6
3
2
1
7
4
6
3
1
9
1
7 6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5 7
9
5
4
88
4
9
0
8
9
8
0
1
2
3
4
5 6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5 7 6
8
9 0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0
0
2
2
7
8
2
0
1
2
6
3
3
7
3
3
4
6
6
6
4
9
1 5
0
9
5
2
8
2
7 1 0 0
6
3
2
7 1
4
6
3
1
3
9
1 7 6
8
4
3
1
4
0
5
3
6
9
1 6
7 5
4
4
7
2
8
22
5
7
5 9
4
8
8
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
7 1
7
3
15
0
0
2 2
7
8
2
0
1 2
6
33
7
3
3
4
6
6
6
4
9
1
5
0
9
5
2
8 2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
5 0
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8 8
4
9
0
8
9
8
1
2
3
4
5
6
7
8
9
0
2 1
3
4
5
6
7
8
9
0 1
2 3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
2
7
8
2
0
1
2
6
3
3
7
33
4
6 6
6
4
9
1
5
0
9
5
2
8
2
0 0
1
7
6
3
2
1
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
7 6
8
9
0
1
2
3
4
5
6
7
8 9
0
9
5 5
6 5
0
9
8
8 9
4
1
7
7
3
5
1
0
0
7
8
2
0
1
2
6
3
3
7
3
3
4
6
6
6
4
9
1
5
0
9
5
2 8
2
0 0
7 1
6
3
2
1
7
4
6
3
1
3
9
7 1
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
7 5
9
5
4
8
8
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8 9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5 6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
7 1 7
3
1 5
0
0
2
2
7
8
2
0
1
2
6
3
3
7
3
3
4
6
6
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
7 1
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2 2
5
7
9
5
4
8
8
4
9
0
8
9
8
0
1
2
3
4
5
7 6
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5 6
7
8
9
0
9
5
5 6
5
0
9
8
9
8
4
1
7
7
3
5
1 00
2
2
7
8
2
1 0
2
6
3
3
7
33
4
66
6
4
9
1
5 0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3 9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
44
7
2
8
2
2
7 5
9
5
4
8
8
4
9
0
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5 0
9
8
9
8
4
7 1
7
3
5
1 0
0
2
2
7
8
2
0
1
2
6
3
3
7
3
3
4
6
6
4
9
1
5
0
9
5
2 8
2
0 0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1 0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8 8
4
9
8 0
9
8
0
1
2 3
4
5
6
7
8
9
0
1
2
3
4
5
6
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5 6
5
0
9
8
9 8
4
1
7
7
3
5
1
0
0
2
2
7 8
2
0
1
2
6
3
3
7
3
3
4
6
6
6
4 9
1
5
0
9
5
2
8
0
1
7 6
3
2
1
7 4 6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
2
5
7
9
5
4
4
9
9 8 0
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
7 5 6
8
9
0
1
2
3
4
5
6
7
8
9
0
9
55
6
5
0
9
8
9
8
4
1
7
7
3
1 5 0
0
2
2
7
8
0
1
2
6
3
3
7
3
3
4
6
6
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
7 1
5
4
4
7
2
8
2
5
7
9
5
4
8 8
4
9
0
8
9
8
Isomap
(b)
Figure 20.33: Isomap applied to (a) Swiss roll. Generated by code at figures.probml.ai/book1/20.33. (b) UCI
digits. Generated by code at figures.probml.ai/book1/20.33.
20.4.5 Isomap
If the high-dimensional data lies on or near a curved manifold, such as the Swiss roll example, then
MDS might consider two points to be close even if their distance along the manifold is large. This is
illustrated in Figure 20.32a.
One way to capture this is to create the K-nearest neighbor graph between datapoints5
, and then
approximate the manifold distance between a pair of points by the shortest distance along this graph;
this can be computed efficiently using Dijkstra’s shortest path algorithm. See Figure 20.32b for an
illustration. Once we have computed this new distance metric, we can apply classical MDS (i.e.,
PCA). This is a way to capture local structure while avoiding local optima. The overall method is
called isomap [TSL00].
See Figure 20.33 for the results of this method on our running example. We see that they are
quite reasonable. However, if the data is noisy, there can be “false” edges in the nearest neighbor
5. In scikit-learn, you can use the function sklearn.neighbors.kneighbors_graph.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.4. Manifold learning * 689
(a)
manifold-swiss-noise-50-Isomap
(b)
Figure 20.34: (a) Noisy version of Swiss roll data. We perturb each point by adding N (0, 0.5
2
) noise. (b)
Results of Isomap applied to this data. Generated by code at figures.probml.ai/book1/20.34.
graph, which can result in “short circuits” which significantly distort the embedding, as shown in
Figure 20.34. This problem is known as “topological instability” [BS02]. Choosing a very small
neighborhood does not solve this problem, since this can fragment the manifold into a large number
of disconnected regions. Various other solutions have been proposed, e.g., [CC07].
20.4.6 Kernel PCA
PCA (and classical MDS) finds the best linear projection of the data, so as to preserve pairwise
similarities between all the points. In this section, we consider nonlinear projections. The key idea
is to solve PCA by finding the eigenvectors of the inner product (Gram) matrix K = XXT, as in
Section 20.1.3.2, and then to use the kernel trick (Section 17.3.4), which lets us replace inner products
such as x
T
i xj with a kernel function, Kij = K(xi
, xk). This is known as kernel PCA [SSM98].
Recall from Mercer’s theorem that the use of a kernel implies some underlying feature space, so we
are implicitly replacing xi with φ(xi) = φi
. Let Φ be the corresponding (notional) design matrix,
and K = XXT be the Gram matrix. Finally, let Sφ =
1
N
P
i φiφ
T
i be the covariance matrix in feature
space. (We are assuming for now the features are centered.) From Equation (20.22), the normalized
eigenvectors of S are given by VkPCA = Φ
TUΛ− 1
2 , where U and Λ contain the eigenvectors and
eigenvalues of K. Of course, we can’t actually compute VkPCA, since φi
is potentially infinite
dimensional. However, we can compute the projection of a test vector x∗ onto the feature space as
follows:
φ
T
∗VkPCA = φ
T
∗Φ
TUΛ− 1
2 = k
T
∗UΛ− 1
2 (20.113)
where k∗ = [K(x∗, x1), . . . , K(x∗, xN )].
There is one final detail to worry about. The covariance matrix is only given by S = Φ
TΦ if the
features is zero-mean. Thus we can only use the Gram matrix K = ΦΦT
if E [φi
] = 0. Unfortunately,
we cannot simply subtract off the mean in feature space, since it may be infinite dimensional. However,
there is a trick we can use. Define the centered feature vector as φ˜
i = φ(xi) −
1
N
PN
j=1 φ(xj ). The
Gram matrix of the centered feature vectors is given by K˜
ij = φ˜T
i φ˜
j
. Using the double centering trick
from Equation (7.89), we can write this in matrix form as K˜ = CN KCN , where CN , IN −
1
N
1N 1
T
N
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license690 Chapter 20. Dimensionality Reduction
−1 0 1
−0.5
0
0.5
1
1.5
Eigenvalue=22.558
−1 0 1
−0.5
0
0.5
1
1.5
Eigenvalue=20.936
−1 0 1
−0.5
0
0.5
1
1.5
Eigenvalue=4.648
−1 0 1
−0.5
0
0.5
1
1.5
Eigenvalue=3.988
−1 0 1
−0.5
0
0.5
1
1.5
Eigenvalue=3.372
−1 0 1
−0.5
0
0.5
1
1.5
Eigenvalue=2.956
−1 0 1
−0.5
0
0.5
1
1.5
Eigenvalue=2.760
−1 0 1
−0.5
0
0.5
1
1.5
Eigenvalue=2.211
Figure 20.35: Visualization of the first 8 kernel principal component basis functions derived from some 2d
data. We use an RBF kernel with σ
2 = 0.1. Generated by code at figures.probml.ai/book1/20.35.
manifold-swiss-noise-0-kPCA
(a)
1 0
2
3
4
5
6
78 9
0
1
2 4 3
5
6
7
8
9
0
1
2
3 9 67 84 5
0
95
5
6 9
5 0 8
9
8
4
71
7
3
5
1
0
0 22
7
8 62 312 0
3
3 7
3
4 6
6 4
9
15
0
9 5 0
820 2
1
7
3 6 2
1
6 74 3
13 7
1896
4
13
4
0
53
6
9
16
7
5
4 4 7
2
8
22
5
9 7
5
4
8
8
4
9
0 8
9
8
0
1
2
3
5 4
6
8 97
0
2 1 3
4
5
6
7
8
9
0 21
3
4
56
7
8
0 9
9
55 6
5
9 80
9
48 1
7
7
3 5
1
00
2
2 7
82 0
1
2
6 3
3
7
3
64 3
6
6
4 9
1
5
0
9 5
2
8
2
0
0
7 1
6
3
2 17
3
9 13 687 3 1 4
04
65 9 3
6
1
7
5
4 4 7
2228
5
54
8
8 94 0 8
9
8
0
1
32
4
6 785 9
0 1
2
3
4 5
6
7
89 0
1
2 34
5
7 6
8
9
095
5
65
9 0
8
98
4
1
7 7
3
51
0
0
22
7
8
210
2
6 37 3
3
3 4
6
6
46
9
1
0 5
9
2 25 8
0
0 1
7
26 3
1
74
9
1 3
63 1
7 6
8
4
3
1 4
0
3 5 96 761 5
4 47
2
8
29 7 52 5
4
8 8
4 9
0
80 31 2 3 45
6 7
89 0
1
2
3
4
5
67
8
0 1 9
6 4523
7
80 9
9
5 5
6
5
90
8 8 9 4
17 7
3 5
1
0
0
2
2 7
0 82 162
3
3
37
3
6 4
664
5
91
0
95
2
178
02 0 6
3
721
4
613
3
9
1
7 6
8
43 1
4
30 5
6
9
6
1
474 5
7
8 2
2
25
7
9
4 584 9
08
9
8
0
1
2
3
54
6
7 8
9
5 104326
7
8 9
10
2
3 697458
0
5
5
6
5 0
9
8 9
8
7741
3
1 50
0
2
2
0 8 7 2 3
2163
7
33
4
66 6
4
9
1
5 0
9
5
20 28
0
7 1 6
3
21
4 7
6
3
8 73961
4
3
04 1
53
6
9
6 1
7
54 47
2
8 22 5 795
4
8 8
4 9
0 08821 9
3 5 4
7 8 690
1
5
6
104934
27862735 5 9958 0
6
5
0 9 4 88 9
1
7135 7
0
7202
8
2
2160 3
3 3 37
4
66
491650
9 8522
0 36170
2 1
7 4
6 3
1
391
67 4 83
1
4 0
5 6 3
9
6
1
7 2 4
8422575
7
54 9
8
1 2 9498038 8
4
76 5
8 9 0 1
2
3
4
5
6790 8
1 2
3
4
7568
0 9
9
5
8550996
8
743715
2 01 02
1287026373
3
5026418409026
13733766124
9
1 74
6831
4
0
3 5
6
5 7 169
4
8427 7 52
94588
9408 9
1
68 74325
9
0
21 5 84763
9
0
1
2 3 4
5
5 97008968695
9
8 741 7 3
581722 102
6
7 33
3 53661469 3627205809 10
2
51
83787211095334131664466497
5 2 5 7 9
4
0 9 49 8 827061543 8
9
2 4013 8502761493985706
9 55 065893517874 01
7 0
8
0162233
7
634909334512166285116103921448334705667 07
3
2 47695647281 2
57498045 9 8
21890
3
64 5
7
2 91083
007609862958355491971
7456895 0073
2157021323638 4
6
6
69 4 1 0559
2
8
400
1722396736 1
8 1673471156922403955772 8
5
4 8 40818043989 2
5 88924637165 70 607951739
9
48537891855020465
6 613082607341072233
64 6703495976511021202381
3 1 9687
4 5314 0
3
3 91 6846961253811958
9071090708382872842
42962700351624749958454725827078540
490724119452563808637651193950671432606497298476183890254136357670642
0
14378490611120370838389602112765461523476902531608945736489201763908122750683557645809216473260951386892557925841136750134985074309526751376432369688973075417329
kPCA
(b)
Figure 20.36: Kernel PCA applied to (a) Swiss roll. Generated by code at figures.probml.ai/book1/20.36. (b)
UCI digits. Generated by code at figures.probml.ai/book1/20.36.
is the centering matrix.
If we apply kPCA with a linear kernel, we recover regular PCA (classical MDS). This is limited
to using L ≤ D embedding dimensions. If we use a non-degenerate kernel, we can use up to N
components, since the size of Φ is N × D∗
, where D∗
is the (potentially infinite) dimensionality of
embedded feature vectors. Figure 20.35 gives an example of the method applied to some D = 2
dimensional data using an RBF kernel. We project points in the unit grid onto the first 8 components
and visualize the corresponding surfaces using a contour plot. We see that the first two components
separate the three clusters, and the following components split the clusters.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.4. Manifold learning * 691
See Figure 20.36 for some the results on kPCA (with an RBF kernel) on our running example. In
this case, the results are arguably not very useful. In fact, it can be shown that kPCA with an RBF
kernel expands the feature space instead of reducing it [WSS04], as we saw in Figure 20.35, which
makes it not very useful as a method for dimensionality reduction. We discuss a solution to this in
Section 20.4.7.
20.4.7 Maximum variance unfolding (MVU)
kPCA with certain kernels, such as RBF, might not result in a low dimensional embedding, as
discussed in Section 20.4.6. This observation led to the development of the semidefinite embedding
algorithm [WSS04], also called maximum variance unfolding, which tries to learn an embedding
{zi} such that
maxX
ij
||zi − zj ||2
2
s.t. ||zi − zj ||2
2 = ||xi − xj ||2
2
for all (i, j) ∈ G (20.114)
where G is the nearest neighbor graph (as in Isomap). This approach explicitly tries to ’unfold’ the
data manifold while respecting the nearest neighbor constraints.
This can be reformulated as a semidefinite programming (SDP) problem by defining the kernel
matrix K = ZZT and then optimizing
max tr(K) s.t. ||zi − zj ||2
2 = ||xi − xj ||2
2
,
X
ij
Kij = 0, K  0 (20.115)
The resulting kernel is then passed to kPCA, and the resulting eigenvectors give the low dimensional
embedding.
20.4.8 Local linear embedding (LLE)
The techniques we have discussed so far all rely on an eigendecomposition of a full matrix of pairwise
similarities, either in the ambient space (PCA), in feature space (kPCA), or along the KNN graph
(Isomap). In this section, we discuss local linear embedding (LLE) [RS00], a technique that solves
a sparse eigenproblem, thus focusing more on local structure in the data.
LLE assumes the data manifold around each point xi
is locally linear. The best linear approximation
can be found by predicting xi as a linear combination of its K nearest neighbors using reconstruction
weights wi
. This can be found by solving
Wˆ = min
W
X
N
i=1
(xi −
X
N
j=1
wijxj )
2
(20.116)
subject to (
wij = 0 if xj 6∈ nbr(xi
, K)
PN
j=1 wij = 1 for i = 1 : N
(20.117)
Note that we need the sum-to-one constraint on the weights to prevent the trivial solution W = 0.
The resulting vector of weights wi,: constitute the barycentric coordinates of xi
.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license692 Chapter 20. Dimensionality Reduction
manifold-swiss-noise-0-LLE
(a)
0 1
3 42
5
6
7
8
9
0
1 2
3 4
5
6
7
8
9
0
1 2
3
4
5 6
7
8
9
0
9
5
5
6
5
0
9
8 9
8
4
17
7
3
5
1
0
2
2
7
8
2
1 0
2
6
3
3 7
3
3 4
66 6
4
9
1
5
0
9
2 5
8
2
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1 4
0
5
3
6
9
6
1
7
5
4 4
7
2
82 2
5
7
9
5 4
8
8
4
9
0 8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1 2
3
4
5
6
7
8
0 9
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0
0
2 7 2
8
20
1
2
6
3
3
7
3
3
4
6
4 6 6
9
1
5
0
9
5
2
8
2
7 1
00
6
3 2
1
7
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
5 2 2
5
4
8
8
4
9 0
8
8 9
0
1
2
3
4
56
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
3 2
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1 7
7
3
5
1
0
7 2 2
8
2
1 0
2
6
3
3
7
3
3
4
6
6
4 9
1
5
0
9
5
2
8
2
00
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8
8
4
90
8
9
3
1
23
4
5
6
7
8
9
1 0
2
3
4
5
6
7
8
10 9
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0 9
8
9
8
4 1
7
7
3
5
1
0
2 2
7
8
2
0
1
2
6
3
3
7
3
3
4
6
6 6
49 1
5
0
9
5
2
8
2
00
1
7
6
3
2 1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4 4
7
2
8
2
2
5
7
9
5
4
8 8
4
9
0
8
9
8
1
2
4 3
5 6
7
8
9
0 1
2
3
4
5
6
7 8
9
0
1
2
3
4
5
6
7
8
9
0
9
5 5
5 6
0
9
8
9
8
4
1
7
7
3
5
1
00
22
7
82
0
1
2
6
3
3
7
3
3
4
66
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7 9
5
4
8
8
4
9
0
8
9
8
0
1
2
4 3
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9 0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
00
7 2 2
8
2
0
1
2
6
3 3
7
3
4 3
6
6
6
4
9
1
5
0
9
5
2
8
2
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8 48
9
0
8
9
8
0
1
2
3 4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
0 9
1
2
3
4
5
6
7
8
9
09
5
5
6
5
0 9
8
9
8
4
1
7
7
3
5
1
0
2
2
7
8 2
0
1 2
6
3
3
7 3 3
4
66
6
4
9
1
5
0
9
5
2
8
2 0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
8 6
4
3
1
4
0
5
3
6
9
6
1
7
5
4
7 4
2
8 2
2
5
7
9
5
4
8
8
4
9
0
8
9
8
1
2
3
4
5
6
7
8
9
0
2 1
3
4
65
7
8 9
0
1
2
3
4
5 6
7
8
0 9
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
2
7
8 2
0
1
2
6
3
3
7
3
4 3
666
4
9
1
5
0
9
5
2
28
00
1
7
3 6
2
1
4
6
3
1
3
9
1
7
8 6
4
3
1
4 0
5
3
6
9
6
1
7
5
4
4
7
2
82
2 5
7
9
5
4
4 9
0
8
9
8
0
1
2
3
4
5 6
87
9
0
1
3 2
4
5
6 7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
8 9
9
8
4
1
7
7
3
5
1
0
7
8
2
0 1
2
6
3
3
7
3
3
4
6 6
6
4
9
1
5
0
9
5 2
8
2
0
1
7
6
3
2
1
7
4
3 6
1
3
9
1
7
6
8
4
3
1
4 0
5
3
6
9
6
1
7
5
4 4
7
2
8
2
2
5
7
9
5
4
8
8
4
9
0
8
9
8
1 0
2
3
4
5
6
7
8
9 0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9 0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0
2 2
7
8
2
0
1
2
6
3
3
7
3
3
4
66
4
9
1
5
0
9
5
2
8
2
0
1
7
3 6
2
1
7
4
6
3
1
3
9
1
7
6
8
3 4
1
4 0
5
3 6
9 6
1
7
5
4
4
7
2 8 2
2
5
79
5
4
8 8
4 9
0
8
9
8
0
1
3 2
4
5
6
7
8
1 0 9
2
3
4
5
6
8 7
9
0
1 2
3
4
5 6
7
8
9
0
9
5
5
6
5
0 9
8
9
8
4
1
7
7
3
5
1
0
2
2
7
8
2
0
1 2
6
3 3 7
3
3
4
66
6
4
9
1
5
9 0
5
2
8
0 2
1 0 7
6
3
2
1
7 4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
44
7
2
8
2
2
5
7
9
5
4
8
8
4
9
0
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9 5
5
6
5
0
9
8
9 8
4
1
7
7
3
5
1
0
2
2
7
8
2
0
1
2
6
3 3
7
3
3
4
66
6
4
9
1
5
0
9
5
2
8
2
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
9 6 6
1
7
5
4
4
7 2
8
2 2
5
7
9
5
4
8 8
4
9
0
8
9
8
0
1
2 3 4
5
6
7
8
9
1 20
3
4
5
9 6
0
1 2
3
4
5
6
7
8 9
0
9
5
5
6
5
9 0
8
9
8
4
1
7
7
3 5
1
0
0
2
2
7
8
2
0
1
3 2 6
3
7
3
3
4
666
4
9
1
5
0
9
5
2
8
0
1
7
6
3
2
1
7
4
3 6
1
3
9
1
7
6
8
43
1
4 0
5
3
6
9
6
1
7
5
4
4
7
2
2
5
7
9
5
4 4
9
0
8
9
8
1
2
3
4
5
6
7
8
0 9 1
3 2
4
5
6
7
8
9
0
1
2
3
4
5 6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
00
2
2
7
8
0
1
2
6
3
3 7
3
3
4
6
6 6
4
9
1
5
0
9
5
2
8
2
00
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
5
7
9
5
4
8
8
4
9
0
8
8 9
Locally Linear Embedding
(b)
Figure 20.37: LLE applied to (a) Swiss roll. Generated by code at figures.probml.ai/book1/20.37. (b) UCI
digits. Generated by code at figures.probml.ai/book1/20.37.
Any linear mapping of this hyperplane to a lower dimensional space perserves the reconstruction
weights, and thus the local geometry. Thus we can solve for the low-dimensional embeddings for
each point by solving
Zˆ = argmin
Z
X
i
||zi −
X
N
j=1
wˆijzj ||2
2
(20.118)
where wˆij = 0 if j is not one of the K nearest neighbors of i. We can rewrite this loss as
L(Z) = ||Z − WZ||2 = Z
T
(I − W)
T
(I − W)Z (20.119)
Thus the solution is given by the eigenvectors of (I − W)
T(I − W) corresponding to the smallest
nonzero eigenvalues, as shown in Section 7.4.8.
See Figure 20.37 for some the results on LLE on our running example. In this case, the results do
not seem as good as those produced by Isomap. However, the method tends to be somewhat less
sensitive to short-circuiting (noise).
20.4.9 Laplacian eigenmaps
In this section, we describe Laplacian eigenmaps or spectral embedding [BN01]. The idea is
to compute a low-dimensional representation of the data in which the weighted distances between
a datapoint and its K nearest neighbors are minimized. We put more weight on the first nearest
neighbor than the second, etc. We give the details below.
20.4.9.1 Using eigenvectors of the graph Laplacian to compute embeddings
We want to find embeddings which minimize
L(Z) = X
(i,j)∈E
Wi,j ||zi − zj ||2
2
(20.120)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.4. Manifold learning * 693
manifold-swiss-noise-0-SE
(a)
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0 9
8
9
8
4
1
7 7
3
5
1
0
0
2
2
7
8
2
0
2 1
6
3
3
7
3
3
4
6 6
6
4
9
1
5
0
9
5
2
8
2
0 0
1
7
6
3
2
71
4
6
3
1
3
9
7 1
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
28
2
5
7
9
5
4
8
8
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
55
6
5
0
9
8
9
8
4
1
77
3
5
1
0
0
2
2
7
8
2
0
1
2
6
3
3
7
3
3
4
6 66
4
9
1
5
0
2 5
8
2
0 0
1
7
6
3
2
1
7
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
7
2
8
2
2
5
5
4
8
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7 7
3
5
1
0
0
2
2
7
8
2
0
1
6
3
3
7
3
3
4
6
6
6
4
9
1
5
0
9
5
22 8
0 0
7 1
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
22
5
7
9
5
4
8
8
4
9
0
8
9
3 0
2 1
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
9 0
8
9
8
4
1
7 7
3
5
1
0
0
22
7
8
2
0
1
2
6
3 3
7
33
4
6
6
6
4
9
1
5
9 0
5
22 8
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8
8
4
9 0
8
9
8
0
1
2
3
4
5
6
7
8
9 0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
9 0
8
9
8
4
1
7 7
3
5
1
0 0
2
2
7
8
2
0
1
2
6
3 3
7
3
3
4
6
6
6
4
9
1
5
0
9
5
2
8
2
0
0
7 1
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
3 5
6
9
6
1
7
5
4
4
7
2
8
2
2 5
7
9
5
4
8
8
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0
0
2
2
7
8
2
0
1
2
6
3
3
7
3
4
6 66
4
9
1
5
0
9
5
2
8
2
00
71
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4 7
2
8
2
2
5
7
9
5
4
8
8
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9 0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1 7
7
3
5
1
00
2
2
7
8
2
0
1
2
6
33
7
3
3
4
6
6
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
7 1
5
44
7
2
8
2
2
5
7
9
5
4
8
8
4
9
0
8
9
8
1
2
3
4
5
6
7
8
9
0
1 2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
0
9
8
9
8
4
1
7
7
3
5
1
2
7
8
2
0
1
2
6
33
7
3
3
4
66
6
4
9
1
5
0
9
5
2 8
2
0 0
1
7
6
3
2
1
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
22 8
2
5
7
9
5
4
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
7 1
7
3
5
1
0
0
7
8
2
0
1
2
6
3
3
7
3
4
6
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1 7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8 8
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
7 1
7
3
1 5
0
0
2
2
7
8
2
0
1
2
6
3
3
7
3
3
4
6
66
4
9
1
5
0
9
2 5
8
2
0
0
7 1
6
3
2
1
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
22
5
7
9
5
4
8
8
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
77
3
5
1
00
2
2
7
8
2
0
1
2
6
3
3
7
33
4 66
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
44
7
2
8
22
5
7
9
5
4
8
8
4
9
0
8
0
1
2
3
4
5
6
7
8
9
0
2 1
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0 0
2
2
7
8
2
0
1
6
3
3
7
33
4
6
6
6
4
9
1
5
0
9
2 5
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8 8
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
3 2
4
5
6
9
0
1
2
3
4
5
6
7
8
9
0
9
5
6
5
0
9
8
9
8
4
1
7
7
3 5
1
0
2 0
2
7
8
2
0
1
2
6
3
3
7
3
3
4
6
6 6
4
9
1
5
0
9
5
2
8
0
7 1
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
1
7
5
4
4
7
2
2
5
7
9
5
4
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5 5
6
5
0
9
8 8
4
1
77
3
5
1
0
0
2
2
7
8
2
0
1
2
6
3
3
7
3
3
4
6
6
6
4
9
1
5
0
9
5
2
8
2
00
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2 5
7
9
5
4
8
8
4
9
0
8
9
8
Spectral embedding
(b)
Figure 20.38: Laplacian eigenmaps applied to (a) Swiss roll. Generated by code at fig￾ures.probml.ai/book1/20.38. (b) UCI digits. Generated by code at figures.probml.ai/book1/20.38.
Figure 20.39: Illustration of the Laplacian matrix derived from an undirected graph. From https: // en.
wikipedia. org/ wiki/ Laplacian_ matrix . Used with kind permission of Wikipedia author AzaToth.
where Wij = exp(−
1
2σ2 ||xi − xj ||2
2
) if i − j are neighbors in the KNN graph and 0 otherwise. We
add the constraint Z
TDZ = I to avoid the degenerate solution where Z = 0, where D is the diagonal
weight matrix storing the degree of each node, Dii =
P
j Wi,j .
We can rewrite the above objective as follows:
L(Z) = X
ij
Wij (||zi
||2 + ||zj ||2 − 2z
T
i zj ) (20.121)
=
X
i
Dii||zi
||2 +
X
j
Djj ||zj ||2 − 2
X
ij
Wijziz
T
j
(20.122)
= 2tr(Z
TDZ) − 2tr(Z
TWZ) = 2tr(Z
TLZ) (20.123)
where L = D − W is the graph Laplacian (see Section 20.4.9.2). One can show that minimizing this
is equivalent to solving the eigenvalue problem Lzi = λDzi for the L smallest nonzero eigenvalues.
See Figure 20.38 for the results of applying this method (with an RBF kernel) to our running
example.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license694 Chapter 20. Dimensionality Reduction
Figure 20.40: Illustration of a (positive) function defined on a graph. From Figure 1 of [Shu+13]. Used with
kind permission of Pascal Frossard.
20.4.9.2 What is the graph Laplacian?
We saw above that we can compute the eigenvectors of the graph Laplacian in order to learn a good
embedding of the high dimensional points. In this section, we give some intuition as to why this
works.
Let W be a symmetric weight matrix for a graph, where Wij = Wji ≥ 0. Let D = diag(di) be a
diagonal matrix containing the weighted degree of each node, di =
P
j wij . We define the graph
Laplacian as follows:
L , D − W (20.124)
Thus the elements of L are given by
Lij =



di
if i = j
−wij if i 6= j and wij 6= 0
0 otherwise
(20.125)
See Figure 20.39 for an example of how to compute this.
Suppose we associate a value fi ∈ R with each node i in the graph (see Figure 20.40 for example).
Then we can use the graph Laplacian as a difference operator, to compute a discrete derivative of
the function at a point:
(Lf)(i) = X
j∈nbri
Wij [f(i) − f(j)] (20.126)
where nbri
is the set of neighbors of node i. We can also compute an overall measure of “smoothness”
of the function f by computing its Dirichlet energy as follows:
f
TLf = f
T Df − f
TWf =
X
i
dif
2
i −
X
i,j
fifjwij (20.127)
=
1
2


X
i
dif
2
i − 2
X
i,j
fifjwij +
X
j
djf
2
j

 =
1
2
X
i,j
wij (fi − fj )
2
(20.128)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.4. Manifold learning * 695
By studying the eigenvalues and eigenvectors of the Laplacian matrix, we can determine various
useful properties of the function. (Applying linear algebra to study the adjacency matrix of a
graph, or related matrices, is called spectral graph theory [Chu97].) For example, we see that
L is symmetric and positive semi-definite, since we have f
TLf ≥ 0 for all f ∈ R
N , which follows
from Equation (20.128) due to the assumption that wij ≥ 0. Consequently L has N non-negative,
real-valued eigenvalues, 0 ≤ λ1 ≤ λ2 ≤ . . . ≤ λN . The corresponding eigenvectors form an orthogonal
basis for the function f defined on the graph, in order of decreasing smoothness.
In Section 20.4.9.1, we discuss Laplacian eigenmaps, which is a way to learn low dimensional
embeddings for high dimensional data vectors. The approach is to let zid = f
d
i be the d’th embedding
dimension for input i, and then to find a basis for these functions (i.e., embedding of the points) that
varies smoothly over the graph, thus respecting distance of the points in ambient space.
There are many other applications of the graph Laplacian in ML. For example, in Section 21.5.1, we
discuss normalized cuts, which is a way to learn a clustering of high dimensional data vectors based
on pairwise similarity; and [WTN19] discusses how to use the eigenvectors of the state transition
matrix to learn representations for RL.
20.4.10 t-SNE
In this section, we describe a very popular nonconvex technique for learning low dimensional
embeddings called t-SNE [MH08]. This extends the earlier stochastic neighbor embedding
method of [HR03], so we first describe SNE, before describing the t-SNE extension.
20.4.10.1 Stochastic neighborhood embedding (SNE)
The basic idea in SNE is to convert high-dimensional Euclidean distances into conditional probabilities
that represent similarities. More precisely, we define pj|i to be the probability that point i would pick
point j as its neighbor if neighbors were picked in proportion to their probability under a Gaussian
centered at xi
:
pj|i =
exp(−
1
2σ
2
i
||xi − xj ||2
)
P
k6=i
exp(−
1
2σ
2
i
||xi − xk||2)
(20.129)
Here σ
2
i
is the variance for data point i, which can be used to “magnify” the scale of points in dense
regions of input space, and diminish the scale in sparser regions. (We discuss how to estimate the
length scales σ
2
i
shortly).
Let zi be the low dimensional embedding representing xi
. We define similarities in the low
dimensional space in an analogous way:
qj|i =
exp(−||zi − zj ||2
)
P
k6=i
exp(−||zi − zk||2)
(20.130)
In this case, the variance is fixed to a constant; changing it would just rescale the learned map, and
not change its topology.
If the embedding is a good one, then qj|i should match pj|i
. Therefore, SNE defines the objective
to be
L =
X
i
DKL (PikQi) = X
i
X
j
pj|i
log
pj|i
qj|i
(20.131)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license696 Chapter 20. Dimensionality Reduction
where Pi
is the conditional distribution over all other data points given xi
, Qi
is the conditional
distribution over all other latent points given zi
, and DKL (PikQi) is the KL divergence (Section 6.2)
between the distributions.
Note that this is an asymmetric objective. In particular, there is a large cost if a small qj|i
is used
to model a large pj|i
. This objective will prefer to pull distant points together rather than push
nearby points apart. We can get a better idea of the geometry by looking at the gradient for each
embedding vector, which is given by
∇ziL(Z) = 2X
j
(zj − zi)(pj|i − qj|i + pi|j − qi|j ) (20.132)
Thus points are pulled towards each other if the p’s are bigger than the q’s, and repelled if the q’s
are bigger than the p’s.
Although this is an intuitively sensible objective, it is not convex. Nevertheless it can be minimized
using SGD. In practice, it helps to add Gaussian noise to the embedding points, and to gradually
anneal the amount of noise. [Hin13] recommends to “spend a long time at the noise level at which
the global structure starts to form from the hot plasma of map points” before reducing it.6
20.4.10.2 Symmetric SNE
There is a slightly simpler version of SNE that minimizes a single KL between the joint distribution
P in high dimensional space and Q in low dimensional space:
L = DKL (PkQ) = X
i<j
pij log pij
qij
(20.133)
This is called symmetric SNE.
The obvious way to define pij is to use
pij =
exp(−
1
2σ2 ||xi − xj ||2
)
P
k<l exp(−
1
2σ2 ||xk − xl
||2)
(20.134)
We can define qij similarily. The corresponding gradient becomes
∇ziL(Z) = 2X
j
(zj − zi)(pij − qij ) (20.135)
As before, points are pulled towards each other if the p’s are bigger than the q’s, and repelled if the
q’s are bigger than the p’s.
Although symmetric SNE is slightly easier to implement, it loses the nice property of regular SNE
that the data is its own optimal embedding if the embedding dimension L is set equal to the ambient
dimension D. Nevertheless, the methods seems to give similar results in practice on real datasets
where L  D.
6. See [Ros98; WF20] for a discussion of annealing and phase transitions in unsupervised learning. See also [CP10]
for a discussion of the elastic embedding algorithm, which uses a homotopy method to more efficiently optimize a
model that is related to both SNE and Laplacian eigenmaps.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.4. Manifold learning * 697
manifold-swiss-noise-0-t-SNE
(a)
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
0
9
8
9
8
4
1
7 7
3
5
1
0
0
22
7
8
0
1
2
6
3 3
7
33 4
6
6 6
4
9
1
5
0
9
5
2
8
00
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
3 4
1
0
5
3
6
9
6
1
7
5 44
7
2
8
5 2
7
9
5
4
8
8
4
9
0
8
9
8
0
1
2
3 4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3 4
5
6
7
8
9
0
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0
0
22
7
8
2
0
1
2
6
33
7
3
4
6 6
6
4
9
5 1
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
1
3
9
1
7
6
8
3 4
1
0
5
3
6
9
6
1
7
5
44
7
2
8
2
55
4
88
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5 5
6
5
0
9
8
9
4
1
7
7
3 5
1
00
22
7
8
2
0
1
2
6
3 3
7
3
4
66
4
9
1
5
0
9
5
2
8
2
00
1
7
6
3
2
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5 4
4
7
2
8
2
2
5
7
9
5
8 8 4
4
9
0
8
9
3
0
1
2
3
5 4
6
7
8
9
0
1
2
3
5 4
6
7
8
9
0
1
2
3
5 4
6
7
8
9
0
9
5 5
6
5
0
9
8
9
8 4
1
7 7
3
5
1
00
22
7
8
2
0
1 2
6
33
7
3
4
66
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5 44
2
8
2
5 2
7
9
5
4
88
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
2 1
3
4
5
6
7
8
9
0
2 1
3
4
5
6
7
8
9
0
9
5
5
6
0
9
8
9
8 4
1
7 7
3 5
1
0
0
2
7
8
2
0
1
2
6
3
3
7
33
4
6
66
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
9
1
7
6
8
4
3
1
0
5
9 66
1
7
5
4 4
7
2
8
2
2
5
7
9
5
88 44
9
0
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
4
1
7
3
5
0 0
22
7
8
0
1
6
33
7
3 3
4
6 66
4
9
1
5
0
9
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3 3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
1
7
5
4
4
2
8
2
5
7
5 9
4 8
8
4
9
0
8
8 9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5 5
6
5
0
9
8
9
8 4
1
7
7
3
5
1
0
0
2
2
7
8
2
0
1
2
6
3
7
3
4
6
6 6
4
9
1
5
0
9
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8 4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2 2
5
7
9
5
8 4
8
4
9
0
9
8
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8 4
1
7
7
3 5
1
2
7
8
2
0
1
2
6
33
7
33
4
666
4
9
1
5
0
5
2
8
0
0
1
7
6
3
2
1
4
6
3
1
3
9
1
7
6
8 4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2 2
5
7
9
5
44
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
2 1
3
4
5
6
7
8
9
0
9
55
6
0
9
8
9
8
4
1
77
3
5
1
0
7
8
2
0
1
2
6
3
3
7
3
4
6
66
4
9
1
5
0
9
5
2
8
2
00
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
2
2
5
7
9
5
4
8 8
4
9
0
8
9
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
5 4
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
5
6
5
0
9
8
9
8
4
1
7
7
3
5
1
00
2
2
7
8
2
0
1
2
6
3
3
7
3
3 4
6
6
4
9
1
5
0
9
5
2
8
2
0
1
7
6
3
2
1
7
4
6
3
1
3
9
7
6
8
4
3
1
4
0
5
3
6
9
6
1
7
5
4
4
7
2
8
22
5
7
9
5
4
8
8
4
9
0
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3 4 5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
55
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0
22
7
8
2
0
1
2
6
3
3
7
3
4
666
4
9
1
5
0
9
5
2
8
2
0 0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
3
9 66
1
7
5
4
7
2
8
22
5
7
9
5 4
88
4
9
0
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
5
6
0
9
8
9
4
1
77
3
5
0
22
7
8
2
0
1
6
3 3
7
3 3
4
6
6
6
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
0
3 5
6
9 6
1
7
5
4
4
7
2
8
2 2
5
7
9
5
4
88 4
9
0
8
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
9
0
2 1
3
4
5
6
7
8
9
0
5
5
6
5
0
9
8
9 8
4
1
7
7
3
5
1
0
0
2
2
7
8
0
1
2
6
33
7
3
3
4
66
6
4
9
1
5
0
9
5
2
8
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
4
3
1
4
0
5
9 6
6
1
7
5
4 4
7
2
2
5
7
9
5
4
4
9
0
8
9
0
1
2
3 5 4
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
9
55
6
5
0
9
8
9
8
4
1
7
7
3
5
1
0 0
2 2
7
8
0
1
2
6
3
7
3
4
6 66
4
9
1
5
0
9
5
2
8
2
0
0
1
7
6
3
2
1
7
4
6
3
1
3
9
1
7
6
8
3 4
1
4
0
5
3
6
9 6
1
7
5 4 4
7
2
8
22
5
7
9
5
4
8 8
4
9
0
8
9
8
t-SNE embedding
(b)
Figure 20.41: tSNE applied to (a) Swiss roll. Generated by code at figures.probml.ai/book1/20.41. (b) UCI
digits. Generated by code at figures.probml.ai/book1/20.41.
20.4.10.3 t-distributed SNE
A fundamental problem with SNE and many other embedding techniques is that they tend to squeeze
points that are relatively far away in the high dimensional space close together in the low dimensional
(usually 2d) embedding space; this is called the crowding problem, and arises due to the use of
squared errors (or Gaussian probabilities).
One solution to this is to use a probability distribution in latent space that has heavier tails,
which eliminates the unwanted attractive forces between points that are relatively far in the high
dimensional space. An obvious choice is the Student-t distribution (Section 2.7.1). In t-SNE, they
set the degree of freedom parameter to ν = 1, so the distribution becomes equivalent to a Cauchy:
qij =
(1 + ||zi − zj ||2
)
−1
P
k<l(1 + ||zk − zl
||2)−1
(20.136)
We can use the same global KL objective as in Equation (20.133). For t-SNE, the gradient turns
out to be
∇ziL = 4X
j
(pij − qij )(zi − zj )(1 + ||zi − zj ||2
)
−1
(20.137)
The gradient for symmetric (Gaussian) SNE is the same, but lacks the (1 + ||zi − zj ||2
)
−1
term. This
term is useful because (1 + ||zi − zj ||2
)
−1 acts like an inverse square law. This means that points in
embedding space act like stars and galaxies, forming many well-separated clusters (galaxies) each of
which has many stars tightly packed inside. This can be useful for separating different classes of data
in an unsupervised way (see Figure 20.41 for an example).
20.4.10.4 Choosing the length scale
An important parameter in t-SNE is the local bandwidth σ
2
i
. This is usually chosen so that Pi has a
perplexity chosen by the user.7 This can be interpreted as a smooth measure of the effective number
7. The perplexity is defined to be 2
H(Pi)
, where H(Pi) = −
P
j
pj|i
log2 pj|i
is the entropy; see Section 6.1.5 for details.
A big radius around each point (large value of σi) will result in a high entropy, and thus high perplexity.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license698 Chapter 20. Dimensionality Reduction
Figure 20.42: Illustration of the effect of changing the perplexity parameter when t-SNE is applied to some
2d data. From [WVJ16]. See http: // distill. pub/ 2016/ misread-tsne for an animated version of these
figures. Used with kind permission of Martin Wattenberg.
of neighbors.
Unfortunately, the results of t-SNE can be quite sensitive to the perplexity parameter, so it is
wise to run the algorithm with many different values. This is illustrated in Figure 20.42. The input
data is 2d, so there is no distortion generating by mapping to a 2d latent space. If the perplexity
is too small, the method tends to find structure within each cluster which is not truly present. At
perplexity 30 (the default for scikit-learn), the clusters seem equi-distant in embedding space, even
though some are closer than others in the data space. Many other caveats in interpreting t-SNE
plots can be found in [WVJ16].
20.4.10.5 Computational issues
The naive implementation of t-SNE takes O(N2
) time, as can be seen from the gradient term in
Equation (20.137). A faster version can be created by leveraging an analogy to N-body simulation in
physics. In particular, the gradient requires computing the force of N points on each of N points.
However, points that are far away can be grouped into clusters (computationally speaking), and
their effective force can be approximated by a few representative points per cluster. We can then
approximate the forces using the Barnes-Hut algorithm [BH86], which takes O(N log N) time, as
proposed in [Maa14]. Unfortunately, this only works well for low dimensional embeddings, such as
L = 2.
20.4.10.6 UMAP
Various extensions of tSNE have been proposed, that try to improve its speed, the quality of the
embedding space, or the ability to embed into more than 2 dimensions.
One popular recent extension is called UMAP (which stands for “Uniform Manifold Approximation
and Projection”), was proposed in [MHM18]. At a high level, this is similar to tSNE, but it tends to
preserve global structure better, and it is much faster. This makes it easier to try multiple values of
the hyperparameters. For an interactive tutorial on UMAP, and a comparison to tSNE, see [CP19].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.5. Word embeddings 699
20.5 Word embeddings
Words are categorical random variables, so their corresponding one-hot vector representations are
sparse. The problem with this binary representation is that semantically similar words may have
very different vector representations. For example, the pair of related words “man” and “woman” will
be Hamming distance 1 apart, as will the pair of unrelated words “man” and “banana”.
The standard way to solve this problem is to use word embeddings, in which we map each sparse
one-hot vector, sn,t ∈ {0, 1}M, representing the t’th word in document n, to a lower-dimensional dense
vector, zn,t ∈ R
D, such that semantically similar words are placed close by. This can significantly
help with data sparsity. There are many ways to learn such embeddings, as we discuss below.
Before discussing methods, we have to define what we mean by “semantically similar” words. We
will assume that two words are semantically similar if they occur in similar contexts. This is known
as the distributional hypothesis [Har54], which is often summarized by the phase (originally from
[Fir57]) “a word is characterized by the company it keeps”. Thus the methods we discuss will all
learn a mapping from a word’s context to an embedding vector for that word.
20.5.1 Latent semantic analysis / indexing
In this section, we discuss a simple way to learn word embeddings based on singular value decompo￾sition (Section 7.5) of a term-frequency count matrix.
20.5.1.1 Latent semantic indexing (LSI)
Let Cij be the number of times “term” i occurs in “context” j. The definition of what we mean by
“term” is application-specific. In English, we often take it to be the set of unique tokens that are
separated by punctuation or whitespace; for simplicity, we will call these “words”. However, we may
preprocess the text data to remove very frequent or infrequent words, or perform other kinds of
preprocessing. as we discuss in Section 1.5.4.1.
The definition of what we mean by “context” is also application-specific. In this section, we
count how many times word i occurs in each document j ∈ {1, . . . , N} from a set or corpus of
documents; the resulting matrx C is called a term-document frequency matrix, as in Figure 1.15.
(Sometimes we apply the TF-IDF transformation to the counts, as discussed in Section 1.5.4.2.)
Let C ∈ RM×N be the count matrix, and let Cˆ be the rank K approximation that minimizes the
following loss:
L(Cˆ ) = ||C − Cˆ ||F =
X
ij
(Cij − Cˆ
ij )
2
(20.138)
One can show that the minimizer of this is given by the rank K truncated SVD approximation,
Cˆ = USV. This means we can represent each cij as a bilinear product:
cij ≈
X
K
k=1
uikskvjk (20.139)
We define ui to be the embedding for word i, and s  vj to be the embedding for context j.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license700 Chapter 20. Dimensionality Reduction
Figure 20.43: Illustration of the cosine similarity between a query vector q and two document vectors d1
and d2. Since angle α is less than angle θ, we see that the query is more similar to document 1. From
https: // en. wikipedia. org/ wiki/ Vector_ space_ model . Used with kind permission of Wikipedia author
Riclas.
We can use these embeddings for document retrieval. The idea is to compute an embedding for
the query words using ui
, and to compare this to the embedding of all the documents or contexts vj .
This is known as latent semantic indexing or LSI [Dee+90].
In more detail, suppose the query is a bag of words w1, . . . , wB; we represent this by the vector
q =
1
B
PB
b=1 uwb
, where uwb
is the embedding for word wb. Let document j be represented by vj .
We then rank documents by the cosine similarity between the query vector and document, defined
by
sim(q, d) = q
Td
||q|| ||d|| (20.140)
where ||q|| =
pP
i
q
2
i
is the `2-norm of q. This measures the angles between the two vectors, as
shown in Figure 20.43. Note that if the vectors are unit norm, cosine similarity is the same as inner
product; it is also equal to the squared Euclidean distance, up to a change of sign and an irrelevant
additive constant:
||q − d||2 = (q − d)
T
(q − d) = q
T
q + d
Td − 2q
Td = 2(1 − sim(q, d)) (20.141)
20.5.1.2 Latent semantic analysis (LSA)
Now suppose we define context more generally to be some local neighborhood of words j ∈ {1, . . . , Mh},
where h is the window size. Thus Cij is how many times word i occurs in a neighborhood of type j.
We can compute the SVD of this matrix as before, to get cij ≈
PK
k=1 uikskvjk. We define ui to be
the embedding for word i, and s  vj to be the embedding for context j. This is known as latent
semantic analysis or LSA [Dee+90].
For example, suppose we compute C on the British National Corpus.8 For each word, let us
retrieve the K nearest neighbors in embedding space ranked by cosine similarity (i.e., normalized
inner product). If the query word is “dog”, and we use h = 2 or h = 30, the nearest neighbors are as
follows:
8. This example is taken from [Eis19, p312].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.5. Word embeddings 701
input projection
sum
w(t-2)
w(t-1)
w(t+1)
w(t+2)
w(t)
output
(a)
input projection
w(t-2)
w(t-1)
w(t+1)
w(t+2)
w(t)
output
(b)
Figure 20.44: Illustration of word2vec model with window size of 2. (a) CBOW version. (b) Skip-gram
version.
h=2: cat, horse, fox, pet, rabbit, pig, animal, mongrel, sheep, pigeon
h=30: kennel, puppy, pet, bitch, terrier, rottweiler, canine, cat, to bark
The 2-word context window is more sensitive to syntax, while the 30-word window is more sensitive
to semantics. The “optimal” value of context size h depends on the application.
20.5.1.3 PMI
In practice LSA (and other similar methods) give much better results if we replace the raw counts
Cij with pointwise mutual information (PMI) [CH90], defined as
PMI(i, j) = log p(i, j)
p(i)p(j)
(20.142)
If word i is strongly associated with context j, we will have PMI(i, j) > 0. If the PMI is negative, it
means i and j co-occur less often that if they were independent; however, such negative correlations
can be unreliable, so it is common to use the positive PMI: PPMI(i, j) = max(PMI(i, j), 0). In
[BL07], they show that SVD applied to the PPMI matrix results in word embeddings that perform
well on a many tasks related to word meaning. See Section 20.5.5 for a theoretical model that explains
this empirical performance.
20.5.2 Word2vec
In this section, we discuss the popular word2vec model from [Mik+13a; Mik+13b], which are
“shallow” neural nets for predicting a word given its context. In Section 20.5.5, we will discuss the
connections with SVD of the PMI matrix.
There are two versions of the word2vec model. The first is called CBOW, which stands for
“continuous bag of words”. The second is called skipgram. We discuss both of these below.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license702 Chapter 20. Dimensionality Reduction
20.5.2.1 Word2vec CBOW model
In the continuous bag of words (CBOW) model (see Figure 20.44(a)), the log likelihood of a sequence
of words is computed using the following model:
log p(w) = X
T
t=1
log p(wt|wt−m:t+m) = X
T
t=1
log
exp(v
T
wt
vt)
P
w0 exp(v
T
w0vt)
(20.143)
=
X
T
t=1
v
T
wt
vt − logX
i∈V
exp(v
T
i vt) (20.144)
where vwt
is the vector for the word at location wt, V is the set of all words, m is the context size,
and
vt =
1
2m
Xm
h=1
(vwt+h + vwt−h
) (20.145)
is the average of the word vectors in the window around word wt. Thus we try to predict each word
given its context. The model is called CBOW because it uses a bag of words assumption for the
context, and represents each word by a continuous embedding.
20.5.2.2 Word2vec Skip-gram model
In CBOW, each word is predicted from its context. A variant of this is to predict the context
(surrounding words) given each word. This yields the following objective:
− log p(w) = −
X
T
t=1


Xm
j=1
log p(wt−j |wt) + log p(wt+j |wt)

 (20.146)
= −
X
T
t=1
X
−m≤j≤m,j6=0
log p(wt+j |wt) (20.147)
where m is the context window length. We define the log probability of some other context word wo
given the central word wc to be
log p(wo|wc) = u
T
ovc − log X
i∈V
exp(u
T
i vc)
!
(20.148)
where V is the vocabulary. Here ui
is the embedding of a word if used as context, and vi
is the
embedding of a word if used as a central (target) word to be predicted. This model is known as the
skipgram model. See Figure 20.44(b) for an illustration.
20.5.2.3 Negative sampling
Computing the conditional probability of each word using Equation (20.148) is expensive, due to the
need to normalize over all possible words in the vocabulary. This makes it slow to compute the log
likelihood and its gradient, for both the CBOW and skip-gram models.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.5. Word embeddings 703
In [Mik+13b], they propose a fast approximation, called skip-gram with negative sampling
(SGNS). The basic idea is to create a set of K + 1 context words for each central word wt, and
to label the one that actually occurs as positive, and the rest as negative. The negative words are
called noise words, and can be sampled from a reweighted unigram distribution, p(w) ∝ freq(w)
3/4
,
which has the effect of redistributing probability mass from common to rare words. The conditional
probability is now approximated by
p(wt+j |wt) = p(D = 1|wt, wt+j )
Y
K
k=1
p(D = 0|wt, wk) (20.149)
where wk ∼ p(w) are noise words, and D = 1 is the event that the word pair actually occurs in the
data, and D = 0 is the event that the word pair does not occur. The binary probabilities are given by
p(D = 1|wt, wt+j ) = σ(u
T
wt+j
vwt
) (20.150)
p(D = 0|wt, wk) = 1 − σ(u
T
wk
vwt
) (20.151)
To train this model, we just need to compute the contexts for each central word, and a set of
negative noise words. We associate a label of 1 with the context words, and a label of 0 with the
noise words. We can then compute the log probability of the data, and optimize the embedding
vectors ui and vi for each word using SGD. See code.probml.ai/book1/skipgram_torch for some
sample code.
20.5.3 GloVE
A popular alternative to Skipgram is the GloVe model of [PSM14a]. (GloVe stands for “global
vectors for word representation”.) This method uses a simpler objective, which is much faster to
optimize.
To explain the method, recall that in the skipgram model, the predicted conditional probability of
word j occuring in the context window of central word i as
qij =
exp(u
T
j vi)
P
k∈V exp(u
T
k
vi)
(20.152)
Let xij be the number of times word j occurs in any context window of i. (Note that if word i occurs
in the window of j, then j will occur in the window of i, so we have xij = xji.) Then we we can
rewrite Equation (20.147) as follows:
L = −
X
i∈V
X
j∈V
xij log qij (20.153)
If we define pij = xij/xi to be the empirical probability of word j occuring in the context window of
central word i, we can rewrite the skipgram loss as a cross entropy loss:
L = −
X
i∈V
xi
X
j∈V
pij log qij (20.154)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license704 Chapter 20. Dimensionality Reduction
Figure 20.45: Visualization of arithmetic operations in word2vec embedding space. From https: // www.
tensorflow. org/ tutorials/ representation/ word2vec .
The problem with this objective is that computing qij is expensive, due to the need to normalize over
all words. In GloVe, we work with unnormalized probabilities, p
0
ij = xij and q
0
ij = exp(u
T
j vi +bi +cj ),
where bi and cj are bias terms to capture marginal probabilities. In addition, we minimize the
squared loss, (log p
0
ij − log q
0
ij )
2
, which is more robust to errors in estimating small probablities than
log loss. Finally, we upweight rare words for which xij < c, where c = 100, by weighting the squared
errors by h(xij ), where h(x) = (x/c)
0.75 if x < c, and h(x) = 1 otherwise. This gives the final GloVe
objective:
L = −
X
i∈V
X
j∈V
h(xij )(u
T
j vi + bi + cj − log xij )
2
(20.155)
We can precompute xij offline, and then optimize the above objective using SGD. After training, we
define the embedding of word i to be the average of vi and ui
.
Empirically GloVe gives similar results to skigram, but it is faster to train. See Section 20.5.5 for a
theoretical model that explains why these methods work.
20.5.4 Word analogies
One of the most remarkable properties of word embeddings produced by word2vec, GloVe, and other
similar methods is that the learned vector space seems to capture relational semantics in terms
of simple vector addition. For example, consider the word analogy problem “man is to woman
as king is to queen”, often written as man:woman::king:queen. Suppose we are given the words
a=man, b=woman, c=king; how do we find d=queen? Let δ = vb − va be the vector representing the
concept of “converting the gender from male to female”. Intuitively we can find word d by computing
vd = c + δ, and then finding the closest word in the vocabulary to vd. See Figure 20.45 for an
illustration of this process, and code.probml.ai/book1/word_analogies_torch for some code.
In [PSM14a], they conjecture that a : b :: c : d holds iff for every word w in the vocabulary, we
have
p(w|a)
p(w|b)
≈
p(w|c)
p(w|d)
(20.156)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.5. Word embeddings 705
In [Aro+16], they show that this follows from the RAND-WALK modeling assumptions in Sec￾tion 20.5.5. See also [AH19; EDH19] for other explanations of why word analogies work, based on
different modeling assumptions.
20.5.5 RAND-WALK model of word embeddings
Word embeddings significantly improve the performance of various kinds of NLP models compared
to using one-hot encodings for words. It is natural to wonder why the above word embeddings work
so well. In this section, we give a simple generative model for text documents that explains this
phenomenon, based on [Aro+16].
Consider a sequence of words w1, . . . , wT . We assume each word is generated by a latent context
or discourse vector zt ∈ R
D using the following log bilinear language model, similar to [MH07]:
p(wt = w|zt) = exp(z
T
t vw)
P
w0 exp(z
T
t vw0 )
=
exp(z
T
t vw)
Z(zt)
(20.157)
where vw ∈ R
D is the embedding for word w, and Z(zt) is the partition function. We assume D < M,
the number of words in the vocabulary.
Let us further assume the prior for the word embeddings vw is an isotropic Gaussian, and that the
latent topic zt undergoes a slow Gaussian random walk. (This is therefore called the RAND-WALK
model.) Under this model, one can show that Z(zt) is approximately equal to a fixed constant,
Z, independent of the context. This is known as the self-normalization property of log-linear
models [AK15]. Furthermore, one can show that the pointwise mutual information of predictions
from the model is given by
PMI(w, w0
) = p(w, w0
)
p(w)p(w0)
≈
v
T
wvw0
D
(20.158)
We can therefore fit the RAND-WALK model by matching the model’s predicted values for PMI
with the empirical values, i.e., we minimize
L =
X
w,w0
Xw,w0 (PMI(w, w0
) − v
T
wvw0 )
2
(20.159)
where Xw,w0 is the number of times w and w
0 occur next to each other. This objective can be seen as
a frequency-weighted version of the SVD loss in Equation (20.138). (See [LG14] for more connections
between word embeddings and SVD.)
Furthermore, some additional approximations can be used to show that the NLL for the RAND￾WALK model is equivalent to the CBOW and SGNS word2vec objectives. We can also derive the
objective for GloVE from this approach.
20.5.6 Contextual word embeddings
Consider the sentences “I was eating an apple” and “I bought a new phone from Apple”. The
meaning of the word “apple” is different in both cases, but a fixed word embedding, of the type
discussed in Section 20.5, would not be able to capture this. In Section 15.7, we discuss contextual
word embeddings, where the embedding of a word is a function of all the words in its context
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license706 Chapter 20. Dimensionality Reduction
(usually a sentence). This can give much improved results, and is currently the standard approach
to representing natural language data, as a pre-processing step before doing transfer learning (see
Section 19.2).
20.6 Exercises
Exercise 20.1 [EM for FA]
Derive the EM updates for the factor analysis model. For simplicity, you can optionally assume µ = 0 is
fixed.
Exercise 20.2 [EM for mixFA *]
Derive the EM updates for a mixture of factor analysers.
Exercise 20.3 [Deriving the second principal component]
a. Let
J(v2, z2) = 1
n
Xn
i=1
(xi − zi1v1 − zi2v2)
T
(xi − zi1v1 − zi2v2) (20.160)
Show that ∂J
∂z2
= 0 yields zi2 = v
T
2 xi.
b. Show that the value of v2 that minimizes
J˜(v2) = −v
T
2 Cv2 + λ2(v
T
2 v2 − 1) + λ12(v
T
2 v1 − 0) (20.161)
is given by the eigenvector of C with the second largest eigenvalue. Hint: recall that Cv1 = λ1v1 and
∂x
T Ax
∂x = (A + AT
)x.
Exercise 20.4 [Deriving the residual error for PCA *]
a. Prove that
||xi −
XK
j=1
zijvj ||2 = x
T
i xi −
XK
j=1
v
T
j xix
T
i vj (20.162)
Hint: first consider the case K = 2. Use the fact that v
T
j vj = 1 and v
T
j vk = 0 for k =6 j. Also, recall
zij = x
T
i vj .
b. Now show that
JK ,
1
n
Xn
i=1 
x
T
i xi −
XK
j=1
v
T
j xix
T
i vj
!
=
1
n
Xn
i=1
x
T
i xi −
XK
j=1
λj (20.163)
Hint: recall v
T
j Cvj = λjv
T
j vj = λj .
c. If K = d there is no truncation, so Jd = 0. Use this to show that the error from only using K < d terms
is given by
JK =
Xd
j=K+1
λj (20.164)
Hint: partition the sum Pd
j=1 λj into PK
j=1 λj and Pd
j=K+1 λj .
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202220.6. Exercises 707
Exercise 20.5 [PCA via successive deflation]
Let v1, v2, . . . , vk be the first k eigenvectors with largest eigenvalues of C =
1
nXT X, i.e., the principal basis
vectors. These satisfy
v
T
j vk =

0 if j 6= k
1 if j = k
(20.165)
We will construct a method for finding the vj sequentially.
As we showed in class, v1 is the first principal eigenvector of C, and satisfies Cv1 = λ1v1. Now define x˜i as
the orthogonal projection of xi onto the space orthogonal to v1:
x˜i = P⊥v1 xi = (I − v1v
T
1 )xi (20.166)
Define X˜ = [x˜1; ...; x˜n] as the deflated matrix of rank d − 1, which is obtained by removing from the d
dimensional data the component that lies in the direction of the first principal direction:
X˜ = (I − v1v
T
1 )
T X = (I − v1v
T
1 )X (20.167)
a. Using the facts that XT Xv1 = nλ1v1 (and hence v
T
1 XT X = nλ1v
T
1 ) and v
T
1 v1 = 1, show that the
covariance of the deflated matrix is given by
C˜ ,
1
n
X˜ T X˜ =
1
n
X
T X − λ1v1v
T
1 (20.168)
b. Let u be the principal eigenvector of C˜ . Explain why u = v2. (You may assume u is unit norm.)
c. Suppose we have a simple method for finding the leading eigenvector and eigenvalue of a pd matrix,
denoted by [λ, u] = f(C). Write some pseudo code for finding the first K principal basis vectors of X
that only uses the special f function and simple vector arithmetic, i.e., your code should not use SVD or
the eig function. Hint: this should be a simple iterative routine that takes 2–3 lines to write. The input
is C, K and the function f, the output should be vj and λj for j = 1 : K.
Exercise 20.6 [PPCA variance terms]
Recall that in the PPCA model, C = WWT + σ
2
I. We will show that this model correctly captures the
variance of the data along the principal axes, and approximates the variance in all the remaining directions
with a single average value σ
2
.
Consider the variance of the predictive distribution p(x) along some direction specified by the unit vector v,
where v
T v = 1, which is given by v
T Cv.
a. First suppose v is orthogonal to the principal subspace. and hence v
T U = 0. Show that v
T Cv = σ
2
.
b. Now suppose v is parallel to the principal subspace. and hence v = ui for some eigenvector ui. Show
that v
T Cv = (λi − σ
2
) + σ
2 = λi.
Exercise 20.7 [Posterior inference in PPCA *]
Derive p(zn|xn) for the PPCA model.
Exercise 20.8 [Imputation in a FA model *]
Derive an expression for p(xh|xv, θ) for a FA model, where x = (xh, xv) is a partition of the data vector.
Exercise 20.9 [Efficiently evaluating the PPCA density]
Derive an expression for p(x|Wˆ , σˆ
2
) for the PPCA model based on plugging in the MLEs and using the
matrix inversion lemma.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license21 Clustering
21.1 Introduction
Clustering is a very common form of unsupervised learning. There are two main kinds of methods.
In the first approach, the input is a set of data samples D = {xn : n = 1 : N}, where xn ∈ X ,
where typically X = R
D. In the second approach, the input is an N × N pairwise disimilarity metric
Dij ≥ 0. In both cases, the goal is to assign similar data points to the same cluster.
As is often the case with unsupervised learning, it is hard to evaluate the quality of a clustering
algorithm. If we have labeled data for some of the data, we can use the similarity (or equality)
between the labels of two data points as a metric for determining if the two inputs “should” be
assigned to the same cluster or not. If we don’t have labels, but the method is based on a generative
model of the data, we can use log likelihood as a metric. We will see examples of both approaches
below.
21.1.1 Evaluating the output of clustering methods
The validation of clustering structures is the most difficult and frustrating part of cluster
analysis. Without a strong effort in this direction, cluster analysis will remain a black art
accessible only to those true believers who have experience and great courage. — Jain and
Dubes [JD88]
Clustering is an unsupervised learning technique, so it is hard to evaluate the quality of the output
of any given method [Kle02; LWG12]. If we use probabilistic models, we can always evaluate the
likelihood of the data, but this has two drawbacks: first, it does not directly assess any clustering
that is discovered by the model; and second, it does not apply to non-probabilistic methods. So now
we discuss some performance measures not based on likelihood.
Intuitively, the goal of clustering is to assign points that are similar to the same cluster, and to
ensure that points that are dissimilar are in different clusters. There are several ways of measuring
these quantities e.g., see [JD88; KR90]. However, these internal criteria may be of limited use. An
alternative is to rely on some external form of data with which to validate the method. For example,
if we have labels for each object, then we can assume that objects with the same label are similar.
We can then use the metrics we discuss below to quantify the quality of the clusters. (If we do not
have labels, but we have a reference clustering, we can derive labels from that clustering.)710 Chapter 21. Clustering
Figure 21.1: Three clusters with labeled objects inside.
21.1.1.1 Purity
Let Nij be the number of objects in cluster i that belong to class j, and let Ni =
PC
j=1 Nij be the
total number of objects in cluster i. Define pij = Nij/Ni
; this is the empirical distribution over class
labels for cluster i. We define the purity of a cluster as pi , maxj pij , and the overall purity of a
clustering as
purity ,
X
i
Ni
N
pi (21.1)
For example, in Figure 21.1, we have that the purity is
6
17
5
6
+
6
17
4
6
+
5
17
3
5
=
5 + 4 + 3
17
= 0.71 (21.2)
The purity ranges between 0 (bad) and 1 (good). However, we can trivially achieve a purity of 1 by
putting each object into its own cluster, so this measure does not penalize for the number of clusters.
21.1.1.2 Rand index
Let U = {u1, . . . , uR} and V = {v1, . . . , vC } be two different partitions of the N data points. For
example, U might be the estimated clustering and V is reference clustering derived from the class
labels. Now define a 2 × 2 contingency table, containing the following numbers: T P is the number of
pairs that are in the same cluster in both U and V (true positives); T N is the number of pairs that
are in the different clusters in both U and V (true negatives); F N is the number of pairs that are in
the different clusters in U but the same cluster in V (false negatives); and F P is the number of pairs
that are in the same cluster in U but different clusters in V (false positives). A common summary
statistic is the Rand index:
R ,
T P + T N
T P + F P + F N + T N
(21.3)
This can be interpreted as the fraction of clustering decisions that are correct. Clearly 0 ≤ R ≤ 1.
For example, consider Figure 21.1, The three clusters contain 6, 6 and 5 points, so the number of
“positives” (i.e., pairs of objects put in the same cluster, regardless of label) is
T P + F P =

6
2

+

6
2

+

5
2

= 40 (21.4)
Of these, the number of true positives is given by
T P =

5
2

+

4
2

+

3
2

+

2
2

= 20 (21.5)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202221.2. Hierarchical agglomerative clustering 711
where the last two terms come from cluster 3: there are 
3
2

pairs labeled C and 
2
2

pairs labeled
A. So F P = 40 − 20 = 20. Similarly, one can show F N = 24 and T N = 72. So the Rand index is
(20 + 72)/(20 + 20 + 24 + 72) = 0.68.
The Rand index only achieves its lower bound of 0 if T P = T N = 0, which is a rare event. One
can define an adjusted Rand index [HA85] as follows:
AR ,
index − expected index
max index − expected index (21.6)
Here the model of randomness is based on using the generalized hyper-geometric distribution, i.e.,
the two partitions are picked at random subject to having the original number of classes and objects
in each, and then the expected value of T P + T N is computed. This model can be used to compute
the statistical significance of the Rand index.
The Rand index weights false positives and false negatives equally. Various other summary statistics
for binary decision problems, such as the F-score (Section 5.1.4), can also be used.
21.1.1.3 Mutual information
Another way to measure cluster quality is to compute the mutual information between two candidate
partitions U and V , as proposed in [VD99]. To do this, let pUV (i, j) = |ui∩vj |
N
be the probability that
a randomly chosen object belongs to cluster ui
in U and vj in V . Also, let pU (i) = |ui
|/N be the
be the probability that a randomly chosen object belongs to cluster ui
in U; define pV (j) = |vj |/N
similarly. Then we have
I(U, V ) = X
R
i=1
X
C
j=1
pUV (i, j) log pUV (i, j)
pU (i)pV (j)
(21.7)
This lies between 0 and min{H (U), H (V )}. Unfortunately, the maximum value can be achieved
by using lots of small clusters, which have low entropy. To compensate for this, we can use the
normalized mutual information,
NMI(U, V ) ,
I(U, V )
(H (U) + H (V ))/2
(21.8)
This lies between 0 and 1. A version of this that is adjusted for chance (under a particular random
data model) is described in [VEB09]. Another variant, called variation of information, is described
in [Mei05].
21.2 Hierarchical agglomerative clustering
A common form of clustering is known as hierarchical agglomerative clustering or HAC. The
input to the algorithm is an N × N dissimilarity matrix Dij ≥ 0, and the output is a tree structure
in which groups i and j with small disimilarity are grouped together in a hierarchical fashion.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license712 Chapter 21. Clustering
1.0 1.5 2.0 2.5 3.0 3.5 4.0
0.0
0.5
1.0
1.5
2.0
2.5
3.0
3.5
4.0
4.5
5.0
1
2
3
4
5
(a)
5 4 3 1 2
0.0
0.5
1.0
1.5
2.0
2.5
(b)
Figure 21.2: (a) An example of single link clustering using city block distance. Pairs (1,3) and (4,5) are
both distance 1 apart, so get merged first. (b) The resulting dendrogram. Adapted from Figure 7.5 of [Alp04].
Generated by code at figures.probml.ai/book1/21.2.
(a) (b) (c)
Figure 21.3: Illustration of (a) Single linkage. (b) Complete linkage. (c) Average linkage.
For example, consider the set of 5 inputs points in Figure 21.2(a), xn ∈ R
2
. We will use city
block distance between the points to define the dissimilarity, i.e.,
dij =
X
2
k=1
|xik − xjk| (21.9)
We start with a tree with N leaves, each corresponding to a cluster with a single data point. Next
we compute the pair of points that are closest, and merge them. We see that (1,3) and (4,5) are
both distance 1 apart, so they get merged first. We then measure the dissimilarity between the sets
{1, 3}, {4, 5} and {2} using some measure (details below), and group them, and repeat. The result is
a binary tree known as a dendogram, as shown in Figure 21.2(b). By cutting this tree at different
heights, we can induce a different number of (nested) clusters. We give more details below.
21.2.1 The algorithm
Agglomerative clustering starts with N groups, each initially containing one object, and then at each
step it merges the two most similar groups until there is a single group, containing all the data. See
Algorithm 11 for the pseudocode. Since picking the two most similar clusters to merge takes O(N2
)
time, and there are O(N) steps in the algorithm, the total running time is O(N3
). However, by using
a priority queue, this can be reduced to O(N2
log N) (see e.g., [MRS08, ch. 17] for details).
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202221.2. Hierarchical agglomerative clustering 713
Algorithm 11: Agglomerative clustering
1 Initialize clusters as singletons: for i ← 1 to n do Ci ← {i};
2 ;
3 Initialize set of clusters available for merging: S ← {1, . . . , n}; repeat
4 Pick 2 most similar clusters to merge: (j, k) ← arg minj,k∈S dj,k;
5 Create new cluster C` ← Cj ∪ Ck;
6 Mark j and k as unavailable: S ← S \ {j, k};
7 if C` 6= {1, . . . , n} then
8 Mark ` as available, S ← S ∪ {`};
9 foreach i ∈ S do
10 Update dissimilarity matrix d(i, `);
11 until no more clusters are available for merging;
0.00
0.05
0.10
0.15
0.20
0.25
0.30
single link
(a)
0.00
0.25
0.50
0.75
1.00
1.25
1.50
1.75
2.00
complete link
(b)
0.00
0.25
0.50
0.75
1.00
1.25
1.50
1.75
average link
(c)
Figure 21.4: Hierarchical clustering of yeast gene expression data. (a) Single linkage. (b) Complete linkage.
(c) Average linkage. Generated by code at figures.probml.ai/book1/21.4.
There are actually three variants of agglomerative clustering, depending on how we define the
dissimilarity between groups of objects. We give the details below.
21.2.1.1 Single link
In single link clustering, also called nearest neighbor clustering, the distance between two
groups G and H is defined as the distance between the two closest members of each group:
dSL(G, H) = min
i∈G,i0∈H
di,i0 (21.10)
See Figure 21.3(a).
The tree built using single link clustering is a minimum spanning tree of the data, which is a tree
that connects all the objects in a way that minimizes the sum of the edge weights (distances). To
see this, note that when we merge two clusters, we connect together the two closest members of
the clusters; this adds an edge between the corresponding nodes, and this is guaranteed to be the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license714 Chapter 21. Clustering
“lightest weight” edge joining these two clusters. And once two clusters have been merged, they will
never be considered again, so we cannot create cycles. As a consequence of this, we can actually
implement single link clustering in O(N2
) time, whereas the other variants take O(N3
) time.
21.2.1.2 Complete link
In complete link clustering, also called furthest neighbor clustering, the distance between
two groups is defined as the distance between the two most distant pairs:
dCL(G, H) = max
i∈G,i0∈H
di,i0 (21.11)
See Figure 21.3(b).
Single linkage only requires that a single pair of objects be close for the two groups to be considered
close together, regardless of the similarity of the other members of the group. Thus clusters can be
formed that violate the compactness property, which says that all the observations within a group
should be similar to each other. In particular if we define the diameter of a group as the largest
dissimilarity of its members, dG = maxi∈G,i0∈G di,i0 , then we can see that single linkage can produce
clusters with large diameters. Complete linkage represents the opposite extreme: two groups are
considered close only if all of the observations in their union are relatively similar. This will tend
to produce clusterings with small diameter, i.e., compact clusters. (Compare Figure 21.4(a) with
Figure 21.4(b).)
21.2.1.3 Average link
In practice, the preferred method is average link clustering, which measures the average distance
between all pairs:
davg(G, H) = 1
nGnH
X
i∈G
X
i
0∈H
di,i0 (21.12)
where nG and nH are the number of elements in groups G and H. See Figure 21.3(c).
Average link clustering represents a compromise between single and complete link clustering. It
tends to produce relatively compact clusters that are relatively far apart. (See Figure 21.4(c).)
However, since it involves averaging of the di,i0 ’s, any change to the measurement scale can change the
result. In contrast, single linkage and complete linkage are invariant to monotonic transformations of
di,i0 , since they leave the relative ordering the same.
21.2.2 Example
Suppose we have a set of time series measurements of the expression levels for N = 300 genes at
T = 7 points. Thus each data sample is a vector xn ∈ R
7
. See Figure 21.5 for a visualization of the
data. We see that there are several kinds of genes, such as those whose expression level goes up
monotonically over time (in response to a given stimulus), those whose expression level goes down
monotonically, and those with more complex response patterns.
Suppose we use Euclidean distance to compute a pairwise dissimilarity matrix, D ∈ R
300×300, and
apply HAC using average linkage. We get the dendogram in Figure 21.6(a). If we cut the tree at
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202221.2. Hierarchical agglomerative clustering 715
0.0 9.5 11.5 13.5 15.5 18.5 20.5
time
0
50
100
150
200
250
300
genes
yeast microarray data
4
3
2
1
0
1
2
3
4
(a)
0.0 9.5 11.5 13.5 15.5 18.5 20.5
time
4
2
0
2
4
genes
yeast microarray data
(b)
Figure 21.5: (a) Some yeast gene expression data plotted as a heat map. (b) Same data plotted as a time
series. Generated by code at figures.probml.ai/book1/21.5.
4 5 2 3 0 1
305
59
17
281
192
13
127
205
250
181
136
74
164
36
139
4
258
68
122
259
276
232
161
210
235
263
309
2
41
167
132
165
266
85
226
102
32
65
116
4
2
0
2
4
(a)
0 20
2.5
0.0
0 20
2.5
0.0
0 20
0.0
2.5
0 20
2.5
0.0
0 20
2.5
0.0
0 20
0
2
0 20
2.5
0.0
0 20
2.5
0.0
2.5
0 20
2
0
0 20
0.0
2.5
0 20
0
2
0 20
0.0
2.5
0 20
0.0
2.5
0 20
0.0
2.5
0 20
0.0
2.5
0 20
2.5
0.0
Hierarchical Clustering of Profiles 
(b)
Figure 21.6: Hierarchical clustering applied to the yeast gene expression data. (a) The rows are permuted
according to a hierarchical clustering scheme (average link agglomerative clustering), in order to bring similar
rows close together. (b) 16 clusters induced by cutting the average linkage tree at a certain height. Generated
by code at figures.probml.ai/book1/21.6.
a certain height, we get the 16 clusters shown in Figure 21.6(b). The time series assigned to each
cluster do indeed “look like” each other.
21.2.3 Extensions
There are many extensions to the basic HAC algorithm. For example, [Mon+21] present a more
scalable version of the bottom up algorithm that builds sub-clusters in parallel. And g [Mon+19]
discusses an online version of the algorithm, that can cluster data as it arrives, while reconsidering
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license716 Chapter 21. Clustering
previous clustering decisions (as opposed to only making greedy decisions). Under certain assumptions,
this can provably recover the true underlying structure. This can be useful for clustering “mentions”
of “entities” (such as people or things) in streaming text data. (This problem is called entity
discovery.)
21.3 K means clustering
There are several problems with hierarchical agglomerative clustering (Section 21.2). First, it takes
O(N3
) time (for the average link method), making it hard to apply to big datasets. Second, it
assumes that a dissimilarity matrix has already been computed, whereas the notion of “similarity” is
often unclear and needs to be learned. Third, it is just an algorithm, not a model, and so it is hard
to evaluate how good it is. That is, there is no clear objective that it is optimizing.
In this section, we discuss the K-means algorithm [Mac67; Llo82], which addresses these issues.
First, it runs in O(NKT) time, where T is the number of iterations. Second, it computes similarity in
terms of Euclidean distance to learned cluster centers µk ∈ R
D, rather than requiring a dissimilarity
matrix. Third, it optimizes a well-defined cost function, as we will see.
21.3.1 The algorithm
We assume there are K cluster centers µk ∈ R
D, so we can cluster the data by assigning each data
point xn ∈ R
D to it closest center:
z
∗
n = arg min
k
||xn − µk||2
2
(21.13)
Of course, we don’t know the cluster centers, but we can estimate them by computing the average
value of all points assigned to them:
µk =
1
Nk
X
n:zn=k
xn (21.14)
We can then iterate these steps to convergence.
More formally, we can view this as finding a local minimum of the following cost function, known
as the distortion:
J(M, Z) = X
N
n=1
||xn − µzn
||2 = ||X − ZMT
||2
F (21.15)
where X ∈ R
N×D, Z ∈ [0, 1]N×K, and M ∈ R
D×K contains the cluster centers µk in its columns.
K-means optimizes this using alternating minimization. (This is closely related to the EM algorithm
for GMMs, as we discuss in Section 21.4.1.1.)
21.3.2 Examples
In this section, we give some examples of K-means clustering.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202221.3. K means clustering 717
5 4 3 2 1 0 1 2
3
2
1
0
1
2
3
4
5
distortion = 2800.54
(a)
5 4 3 2 1 0 1 2
3
2
1
0
1
2
3
4
5
distortion = 2978.45
(b)
Figure 21.7: Illustration of K-means clustering in 2d. We show the result of using two different random seeds.
Adapted from Figure 9.5 of [Gér19]. Generated by code at figures.probml.ai/book1/21.7.
0 20
0.0
2.5
0 20
2.5
0.0
0 20
0.0
2.5
0 20
0.0
2.5
0 20
2.5
0.0
0 20
0
2
0 20
0.0
2.5
0 20
2.5
0.0
2.5
0 20
0.0
2.5
0 20
2.5
0.0
0 20
0
2
0 20
0
2
0 20
0.0
2.5
0 20
2.5
0.0
2.5
0 20
2
0
0 20
2.5
0.0
K-Means Clustering of Profiles
(a)
K-Means centroids
(b)
Figure 21.8: Clustering the yeast data from Figure 21.5 using K-means clustering with K = 16. (a) Visualizing
all the time series assigned to each cluster. (b) Visualizing the 16 cluster centers as prototypical time series.
Generated by code at figures.probml.ai/book1/21.8.
21.3.2.1 Clustering points in the 2d plane
Figure 21.7 gives an illustration of K-means clustering applied to some points in the 2d plane. We see
that the method induces a Voronoi tessellation of the points. The resulting clustering is sensitive
to the initialization. Indeed, we see that the lower quality clustering on the right has higher distortion.
By default, sklearn uses 10 random restarts (combined with the K-means++ initialization described
in Section 21.3.4) and returns the clustering with lowest distortion. (In sklearn, the distortion is
called the “inertia”.)
21.3.2.2 Clustering gene expression time series data from yeast cells
In Figure 21.8, we show the result of applying K-means clustering with K = 16 to the 300 × 7 yeast
time series matrix shown in Figure 21.5. We see that time series that “look similar” to each other are
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license718 Chapter 21. Clustering
0 200 400 600 800 1000
0
100
200
300
400
500
600
700
K = 2
(a)
0 200 400 600 800 1000
0
100
200
300
400
500
600
700
K = 4
(b)
Figure 21.9: An image compressed using vector quantization with a codebook of size K. (a) K = 2. (b)
K = 4. Generated by code at figures.probml.ai/book1/21.9.
assigned to the same cluster. We also see that the centroid of each cluster is a reasonabe summary
all the data points assigned to that cluster. Finally we notice that group 6 was not used, since no
points were assigned to it. However, this is just an accident of the initialization process, and we are
not guaranteed to get the same clustering, or number of clusters, if we repeat the algorithm. (We
discuss good ways to initialize the method in Section 21.3.4, and ways to choose K in Section 21.3.7.)
21.3.3 Vector quantization
Suppose we want to perform lossy compression of some real-valued vectors, xn ∈ R
D. A very simple
approach to this is to use vector quantization or VQ. The basic idea is to replace each real-valued
vector xn ∈ R
D with a discrete symbol zn ∈ {1, . . . , K}, which is an index into a codebook of K
prototypes, µk ∈ R
D. Each data vector is encoded by using the index of the most similar prototype,
where similarity is measured in terms of Euclidean distance:
encode(xn) = arg min
k
||xn − µk||2
(21.16)
We can define a cost function that measures the quality of a codebook by computing the recon￾struction error or distortion it induces:
J ,
1
N
X
N
n=1
||xn − decode(encode(xn))||2 =
1
N
X
N
n=1
||xn − µzn
||2
(21.17)
where decode(k) = µk. This is exactly the cost function that is minimized by the K-means algorithm.
Of course, we can achieve zero distortion if we assign one prototype to every data vector, by using
K = N and assigning µn = xn. However, this does not compress the data at all. In particular, it
takes O(NDB) bits, where N is the number of real-valued data vectors, each of length D, and B is
the number of bits needed to represent a real-valued scalar (the quantization accuracy to represent
each xn).
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202221.3. K means clustering 719
We can do better by detecting similar vectors in the data, creating prototypes or centroids for
them, and then representing the data as deviations from these prototypes. This reduces the space
requirement to O(N log2 K + KDB) bits. The O(N log2 K) term arises because each of the N data
vectors needs to specify which of the K codewords it is using; and the O(KDB) term arises because
we have to store each codebook entry, each of which is a D-dimensional vector. When N is large, the
first term dominates the second, so we can approximate the rate of the encoding scheme (number of
bits needed per object) as O(log2 K), which is typically much less than O(DB).
One application of VQ is to image compression. Consider the 200 × 320 pixel image in Figure 21.9;
we will treat this as a set of N = 64, 000 scalars. If we use one byte to represent each pixel (a
gray-scale intensity of 0 to 255), then B = 8, so we need NB = 512, 000 bits to represent the image in
uncompressed form. For the compressed image, we need O(N log2 K) bits. For K = 4, this is about
128kb, a factor of 4 compression, yet it results in negligible perceptual loss (see Figure 21.9(b)).
Greater compression could be achieved if we modeled spatial correlation between the pixels, e.g., if
we encoded 5x5 blocks (as used by JPEG). This is because the residual errors (differences from the
model’s predictions) would be smaller, and would take fewer bits to encode. This shows the deep
connection between data compression and density estimation. See the sequel to this book, [Mur22],
for more information.
21.3.4 The K-means++ algorithm
K-means is optimizing a non-convex objective, and hence needs to be initialized carefully. A simple
approach is to pick K data points at random, and to use these as the initial values for µk. We can
improve on this by using multiple restarts, i.e., we run the algorithm multiple times from different
random starting points, and then pick the best solution. However, this can be slow.
A better approach is to pick the centers sequentially so as to try to “cover” the data. That is,
we pick the initial point uniformly at random, and then each subsequent point is picked from the
remaining points, with probability proportional to its squared distance to the point’s closest cluster
center. That is, at iteration t, we pick the next cluster center to be xn with probability
p(µt = xn) = Dt−1(xn)
PN
n0=1 Dt−1(xn0 )
(21.18)
where
Dt(x) =
t−1
min
k=1
||x − µk||2
2
(21.19)
is the squared distance of x to the closest existing centroid. Thus points that are far away from a
centroid are more likely to be picked, thus reducing the distortion. This is known as farthest point
clustering [Gon85], or K-means++ [AV07; Bah+12; Bac+16; BLK17; LS19a]. Surprisingly, this
simple trick can be shown to guarantee that the recontruction error is never more than O(log K)
worse than optimal [AV07].
21.3.5 The K-medoids algorithm
There is a variant of K-means called K-medoids algorithm, in which we estimate each cluster center
µk by choosing the data example xn ∈ X whose average dissimilarity to all other points in that
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license720 Chapter 21. Clustering
cluster is minimal; such a point is known as a medoid. By contrast, in K-means, we take averages
over points xn ∈ R
D assigned to the cluster to compute the center. K-medoids can be more robust to
outliers (although that issue can also be tackled by using mixtures of Student distributions, instead
of mixtures of Gaussians). More importantly, K-medoids can be applied to data that does not live in
R
D, where averaging may not be well defined. In K-medoids, the input to the algorithm is N × N
pairwise distance matrix, D(n, n0
), not an N × D feature matrix.
The classic algorithm for solving the K-medoids is the partitioning around medoids or PAM
method [KR87]. In this approach, at each iteration, we loop over all K medoids. For each medoid
m, we consider each non-medoid point o, swap m and o, and recompute the cost (sum of all the
distances of points to their medoid). If the cost has decreased, we keep this swap. The running time
of this algorithm is O(N2KT), where T is the number of iterations.
There is also a simpler and faster method, known as the Voronoi iteration method due to [PJ09].
In this approach, at each iteration, we have two steps, similar to K-means. First, for each cluster
k, look at all the points currently assigned to that cluster, Sk = {n : zn = k}, and then set mk to
be the index of the medoid of that set. (To find the medoid requires examining all |Sk| candidate
points, and choosing the one that has the smallest sum of distances to all the other points in Sk.)
Second, for each point n, assign it to its closest medoid, zn = argmink D(n, k). The pseudo-code is
given in Algorithm 12.
Algorithm 12: K-medoids algorithm
1 Initialize m1:K as a random subset of size K from {1, . . . , N};
2 repeat
3 zn = argmink d(n, mk) for n = 1 : N;
4 mk = argminn:zn=k
P
n0
:zn0=k
d(n, n0
) for k = 1 : K;
5 until converged;
21.3.6 Speedup tricks
K-means clustering takes O(NKI) time, where I is the number of iterations, but we can reduce the
constant factors using various tricks. For example, [Elk03] shows how to use the triangle inequality
to keep track of lower and upper bounds for the distances between inputs and the centroids; this
can be used to eliminate some redundant computations. Another approach is to use a minibatch
approximation, as proposed in [Scu10]. This can be significantly faster, although can result in slightly
worse loss (see Figure 21.10).
21.3.7 Choosing the number of clusters K
In this section, we discuss how to choose the number of clusters K in the K-means algorithm and
other related methods.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202221.3. K means clustering 721
0 10 20 30 40 50
k
0
500
1000
1500
2000
2500
3000
3500
Distortion
K-Means
Mini-batch K-Means
0 10 20 30 40 50
k
0.0
0.5
1.0
1.5
2.0
2.5
Training time (seconds)
Figure 21.10: Illustration of batch vs mini-batch K-means clustering on the 2d data from Figure 21.7. Left:
distortion vs K. Right: Training time vs K. Adapted from Figure 9.6 of [Gér19]. Generated by code at
figures.probml.ai/book1/21.10.
2 3 4 5 6 7 8
k
1000
2000
3000
4000
5000
6000
7000
Distortion
(a)
2 3 4 5 6 7 8
k
13400
13600
13800
14000
14200
14400
14600
14800
Information Criterion
BIC
(b)
2 3 4 5 6 7 8
k
0.44
0.46
0.48
0.50
0.52
Silhouette score
(c)
Figure 21.11: Performance of K-means and GMM vs K on the 2d dataset from Figure 21.7. (a) Distortion on
validation set vs K. Generated by code at figures.probml.ai/book1/21.11. (b) BIC vs K. Generated by code at
figures.probml.ai/book1/21.11. (c) Silhouette score vs K. Generated by code at figures.probml.ai/book1/21.11.
21.3.7.1 Minimizing the distortion
Based on our experience with supervised learning, a natural choice for picking K is to pick the value
that minimizes the reconstruction error on a validation set, defined as follows:
err(Dvalid, K) = 1
|Dvalid|
X
n∈Dvalid
||xn − xˆn||2
2
(21.20)
where xˆn = decode(encode(xn)) is the reconstruction of xn.
Unfortunately, this technique will not work. Indeed, as we see in Figure 21.11a, the distortion
monotonically decreases with K. To see why, note that the K-means model is a degenerate density
model which consists of K “spikes” at the µk centers. As we increase K, we “cover” more of the input
space. Hence any given input point is more likely to find a close prototype to accurately represent
it as K increases, thus decreasing reconstruction error. Thus unlike with supervised learning, we
cannot use reconstruction error on a validation set as a way to select the best unsupervised model.
(This comment also applies to picking the dimensionality for PCA, see Section 20.1.4.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license722 Chapter 21. Clustering
21.3.7.2 Maximizing the marginal likelihood
A method that does work is to use a proper probabilistic model, such as a GMM, as we describe in
Section 21.4.1. We can then use the log marginal likelihood (LML) of the data to perform model
selection.
We can approximate the LML using the BIC score as we discussed in Section 5.2.5.1. From
Equation (5.59), we have
BIC(K) = log p(D|θˆ
k) −
DK
2
log(N) (21.21)
where DK is the number of parameters in a model with K clusters, and θˆK is the MLE. We see from
Figure 21.11b that this exhibits the typical U-shaped curve, where the penalty decreases and then
increases.
The reason this works is that each cluster is associated with a Gaussian distribution that fills a
volume of the input space, rather than being a degenerate spike. Once we have enough clusters to
cover the true modes of the distribution, the Bayesian Occam’s razor (Section 5.2.3) kicks in, and
starts penalizing the model for being unncessarily complex.
See Section 21.4.1.3 for more discussion of Bayesian model selection for mixture models.
21.3.7.3 Silhouette coefficient
In this section, we describe a common heuristic method for picking the number of clusters in a
K-means clustering model. This is designed to work for spherical (not elongated) clusters. First we
define the silhouette coefficient of an instance i to be sc(i) = (bi −ai)/ max(ai
, bi), where ai
is the
mean distance to the other instances in cluster ki = argmink
||µk − xi
||, and bi
is the mean distance
to the other instances in the next closest cluster, k
0
i = argmink6=ki
||µk − xi
||. Thus ai
is a measure
of compactness of i’s cluster, and bi
is a measure of distance between the clusters. The silhouette
coefficient varies from -1 to +1. A value of +1 means the instance is close to all the members of its
cluster, and far from other clusters; a value of 0 means it is close to a cluster boundary; and a value
of -1 means it may be in the wrong cluster. We define the silhouette score of a clustering K to be
the mean silhouette coefficient over all instances.
In Figure 21.11a, we plot the distortion vs K for the data in Figure 21.7. As we explained above,
it goes down monotonically with K. There is a slight “kink” or “elbow” in the curve at K = 3,
but this is hard to detect. In Figure 21.11c, we plot the silhouette score vs K. Now we see a more
prominent peak at K = 3, although it seems K = 7 is almost as good. See Figure 21.12 for a
comparison of some of these clusterings.
It can be informative to look at the individual silhouette coefficients, and not just the mean score.
We can plot these in a silhouette diagram, as shown in Figure 21.13, where each colored region
corresponds to a different cluster. The dotted vertical line is the average coefficient. Clusters with
many points to the left of this line are likely to be of low quality. We can also use the silhouette
diagram to look at the size of each cluster, even if the data is not 2d.
21.3.7.4 Incrementally growing the number of mixture components
An alternative to searching for the best value of K is to incrementally “grow” GMMs. We can start
with a small value of K, and after each round of training, we consider splitting the cluster with the
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202221.4. Clustering using mixture models 723
5 4 3 2 1 0 1 2
3
2
1
0
1
2
3
4
5
K=3
(a)
5 4 3 2 1 0 1 2
3
2
1
0
1
2
3
4
5
K=4
(b)
5 4 3 2 1 0 1 2
3
2
1
0
1
2
3
4
5
K=5
(c)
5 4 3 2 1 0 1 2
3
2
1
0
1
2
3
4
5
K=6
(d)
Figure 21.12: Voronoi diagrams for K-means for different K on the 2d dataset from Figure 21.7. Generated
by code at figures.probml.ai/book1/21.12.
highest mixing weight into two, with the new centroids being random perturbations of the original
centroid, and the new scores being half of the old scores. If a new cluster has too small a score, or
too narrow a variance, it is removed. We continue in this way until the desired number of clusters is
reached. See [FJ02] for details.
21.3.7.5 Sparse estimation methods
Another approach is to pick a large value of K, and then to use some kind of sparsity-promoting
prior or inference method to “kill off” unneeded mixture components, such as variational Bayes. See
the sequel to this book, [Mur22], for details.
21.4 Clustering using mixture models
We have seen how the K-means algorithm can be used to cluster data vectors in R
D. However,
this method assumes that all clusters have the same spherical shape, which is a very restrictive
assumption. In addition, K-means assumes that all clusters can be described by Gaussians in the
input space, so it cannot be applied to discrete data. By using mixture models (Section 3.5), we can
overcome both of these problems, as we illustrate below.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license724 Chapter 21. Clustering
0.0 0.2 0.4 0.6 0.8
0
500
1000
1500
2000
k = 3, score = 0.52
(a)
0.0 0.2 0.4 0.6 0.8
0
500
1000
1500
2000
k = 4, score = 0.48
(b)
0.0 0.2 0.4 0.6 0.8
0
500
1000
1500
2000
k = 5, score = 0.47
(c)
0.2 0.0 0.2 0.4 0.6 0.8
0
500
1000
1500
2000
2500
k = 6, score = 0.50
(d)
Figure 21.13: Silhouette diagrams for K-means for different K on the 2d dataset from Figure 21.7. Generated
by code at figures.probml.ai/book1/21.13.
21.4.1 Mixtures of Gaussians
Recall from Section 3.5.1 that a Gaussian mixture model (GMM) is a model of the form
p(x|θ) = X
K
k=1
πkN (x|µk, Σk) (21.22)
If we know the model parameters θ = (π, {µk, Σk}), we can use Bayes rule to compute the
responsibility (posterior membership probability) of cluster k for data point xn:
rnk , p(zn = k|xn, θ) = p(zn = k|θ)p(xn|zn = k, θ)
PK
k0=1 p(zn = k
0
|θ)p(xn|zn = k
0
, θ)
(21.23)
Given the responsibilities, we can compute the most probable cluster assignment as follows:
zˆn = arg max
k
rnk = arg max
k
[log p(xn|zn = k, θ) + log p(zn = k|θ)] (21.24)
This is known as hard clustering.
21.4.1.1 K-means is a special case of EM
We can estimate the parameters of a GMM using the EM algorithm (Section 8.7.3). It turns out that
the K-means algorithm is a special case of this algorithm, in which we make two approximations:
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202221.4. Clustering using mixture models 725
8 6 4 2 0 2 4 6
x1
2
0
2
4
x2
full
(a)
8 6 4 2 0 2 4 6
2
0
2
4
full
(b)
8 6 4 2 0 2 4 6
x1
2
0
2
4
x2
tied
(c)
8 6 4 2 0 2 4 6
2
0
2
4
tied
(d)
8 6 4 2 0 2 4 6
x1
2
0
2
4
x2
diag
(e)
8 6 4 2 0 2 4 6
2
0
2
4
diag
(f)
8 6 4 2 0 2 4 6
x1
2
0
2
4
x2
spherical
(g)
8 6 4 2 0 2 4 6
2
0
2
4
spherical
(h)
Figure 21.14: Some data in 2d fit using a GMM with K = 5 components. Left column: marginal distribution
p(x). Right column: visualization of each mixture distribution, and the hard assignment of points to their most
likely cluster. (a-b) Full covariance. (c-d) Tied full covariance. (e-f) Diagonal covairance, (g-h) Spherical
covariance. Color coding is arbitrary. Generated by code at figures.probml.ai/book1/21.14.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license726 Chapter 21. Clustering
45 50 55 60 65 70
Figure 21.15: Some 1d data, with a kernel density estimate superimposed. Adapted from Figure 6.2 of [Mar18].
Generated by code at figures.probml.ai/book1/21.15.
46 48 50 52 54 56 58
means
0
0 100 200 300 400
45
50
55
means
0
46 48 50 52 54 56 58
means
1
0 100 200 300 400
45
50
55
means
1
0.2 0.4 0.6 0.8
p
0
0 100 200 300 400
0.25
0.50
0.75
p
0
0.2 0.4 0.6 0.8
p
1
0 100 200 300 400
0.25
0.50
0.75
p
1
(a)
45.5 46.0 46.5 47.0 47.5 48.0 48.5
means
0
0 200 400 600 800
46
47
48
means
0
57.1 57.2 57.3 57.4 57.5 57.6 57.7 57.8
means
1
0 200 400 600 800
57.25
57.50
57.75
means
1
0.07 0.08 0.09 0.10 0.11 0.12
p
0
0 200 400 600 800
0.08
0.10
0.12
p
0
0.88 0.89 0.90 0.91 0.92 0.93
p
1
0 200 400 600 800
0.88
0.90
0.92
p
1
(b)
Figure 21.16: Illustration of the label switching problem when performing posterior inference for the parameters
of a GMM. We show a KDE estimate of the posterior marginals derived from 1000 samples from 4 HMC
chains. (a) Unconstrained model. Posterior is symmetric. (b) Constrained model, where we add a penalty to
ensure µ0 < µ1. Adapted from Figure 6.6-6.7 of [Mar18]. Generated by code at figures.probml.ai/book1/21.16.
we fix Σk = I and πk = 1/K for all the clusters (so we just have to estimate the means µk), and
we approximate the E step, by replacing the soft responsibilities with hard cluster assignments, i.e.,
we compute z
∗
n = argmaxk
rnk, and set rnk ≈ I(k = z
∗
n
) instead of using the soft responsibilities,
rnk = p(zn = k|xn, θ). With this approximation, the weighted MLE problem in Equation (8.165) of
the M step reduces to Equation (21.14), so we recover K-means.
However, the assumption that all the clusters have the same spherical shape is very restrictive.
For example, Figure 21.14 shows the marginal density and clustering induced using different shaped
covariance matrices for some 2d data. We see that modeling this particular dataset needs the ability
to capture off-diagonal covariance for some clusters (top row).
21.4.1.2 Unidentifiability and label switching
Note that we are free to permute the labels in a mixture model without changing the likelihood. This
is called the label switching problem, and is an example of non-identifiability of the parameters.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202221.4. Clustering using mixture models 727
This can cause problems if we wish to perform posterior inference over the parameters (as opposed
to just computing the MLE or a MAP estimate). For example, suppose we fit a GMM with K = 2
components to the data in Figure 21.15 using HMC. The posterior over the means, p(µ1, µ2|D), is
shown in Figure 21.16a. We see that the marginal posterior for each component, p(µk|D), is bimodal.
This reflects the fact that there are two equally good explanations of the data: either µ1 ≈ 47 and
µ2 ≈ 57, or vice versa.
To break symmetry, we can add an ordering constraint on the centers, so that µ1 < µ2. We can
do this by adding a penalty or potential function to the objective if the penalty is violated. More
precisely, the penalized log joint becomes
`
0
(θ) = log p(D|θ) + log p(θ) + φ(µ) (21.25)
where
φ(µ) = (
−∞ if µ1 < µ0
0 otherwise
(21.26)
This has the desired effect, as shown in Figure 21.16b.
A more general approach is to apply a transformation to the parameters, to ensure identifiability.
That is, we sample the parameters θ from a proposal, and then apply an invertible transformation
θ
0 = f(θ) to them before computing the log joint, log p(D, θ
0
). To account for the change of
variables (Section 2.8.3), we add the log of the determinant of the Jacobian. In the case of a 1d
ordering transformation, which just sorts its inputs, the determinant of the Jacobian is 1, so the
log-det-Jacobian term vanishes.
Unfortunately, this approach does not scale to more than 1 dimensional problems, because there is
no obvious way to enforce an ordering constraint on the centers µk.
21.4.1.3 Bayesian model selection
Once we have a reliable way to ensure identifiability, we can use Bayesian model selection techniques
from Section 5.2.2 to select the number of clusters K. In Figure 21.17, we illustrate the results
of fitting a GMM with K = 3 − 6 components to the data in Figure 21.15. We use the ordering
transform on the means, and perform inference using HMC. We compare the resulting GMM model
fits to the fit of a kernel density estimate (Section 16.3), which often over-smooths the data. We see
fairly strong evidence for two bumps, corresponding to different subpopulations.
We can compare these models more quantitatively by computing their WAIC scores (widely
applicable information criterion) which is an approximation to the log marginal likelihood (see [Wat10;
Wat13; VGG17] for details). The results are shown in Figure 21.18. (This kind of visualization was
proposed in [McE20, p228].) We see that the model with K = 6 scores significantly higher than for
the other models, although K = 5 is a close second. This is consistent with the plot in Figure 21.17.
21.4.2 Mixtures of Bernoullis
As we discussed in Section 3.5.2, we can use a mixtures of Bernoullis to cluster binary data. The
model has the form
p(y|z = k, θ) = Y
D
d=1
Ber(yd|µdk) = Y
D
d=1
µ
yd
dk(1 − µdk)
1−yd
(21.27)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license728 Chapter 21. Clustering
50 60 70
x
K = 3
50 60 70
x
K = 4
50 60 70
x
K = 5
50 60 70
x
K = 6
Figure 21.17: Fitting GMMs with different numbers of clusters K to the data in Figure 21.15. Black solid
line is KDE fit. Solid blue line is posterior mean; feint blue lines are posterior samples. Dotted lines show the
individual Gaussian mixture components, evaluated by plugging in their posterior mean parameters. Adapted
from Figure 6.8 of [Mar18]. Generated by code at figures.probml.ai/book1/21.17.
Here µdk is the probability that bit d turns on in cluster k. We can fit this model with EM, SGD,
MCMC, etc. See Figure 3.13 for an example, where we cluster some binarized MNIST digits.
21.5 Spectral clustering *
In this section, we discuss an approach to clustering based on eigenvalue analysis of a pairwise
similarity matrix. It uses the eigenvectors to derive feature vectors for each datapoint, which are
then clustered using a feature-based clustering method, such as K-means (Section 21.3). This is
known as spectral clustering [SM00; Lux07].
21.5.1 Normalized cuts
We start by creating a weighted undirected graph W, where each data vector is a node, and the
strength of the i − j edge is a measure of similarity. Typically we only connected a node to its most
similar neighbors, to ensure the graph is sparse, which speeds computation.
Our goal is to find K clusters of similar points. That is, we want to find a graph partition into
S1, . . . , SK disjoint sets of nodes so as to minimize some kind of cost.
Our first attempt at a cost function is to compute the weight of connections between nodes in each
cluster to nodes outside each cluster:
cut(S1, . . . , SK) ,
1
2
X
K
k=1
W(Sk, Sk) (21.28)
where W(A, B) ,
P
i∈A,j∈B wij and Sk = V \ Sk is the complement of Sk, where V = {1, . . . , N}.
Unfortunately the optimal solution to this often just partitions off a single node from the rest,
since that minimizes the weight of the cut. To prevent this, we can divide by the size of each set, to
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202221.5. Spectral clustering * 729
5200 5180 5160 5140 5120 5100
Log
6
5
4
3
Figure 21.18: WAIC scores for the different GMMs. The empty circle is the posterior mean WAIC score for
each model, and the black lines represent the standard error of the mean. The solid circle is the in-sample
deviance of each model, i.e., the unpenalized log-likelihood. The dashed vertical line corresponds to the
maximum WAIC value. The gray triangle is the difference in WAIC score for that model compared to the best
model. Adapted from Figure 6.10 of [Mar18]. Generated by code at figures.probml.ai/book1/21.18.
get the following objective, known as the normalized cut:
Ncut(S1, . . . , SK) ,
1
2
X
K
k=1
cut(Sk, Sk)
vol(Sk)
(21.29)
where vol(A) ,
P
i∈A di
is the total weight of set A and di =
PN
j=1 wij is the weighted degree of
node i. This splits the graph into K clusters such that nodes within each cluster are similar to each
other, but are different to nodes in other clusters.
We can formulate the Ncut problem in terms of searching for binary vectors ci ∈ {0, 1}
N that
minimizes the above objective, where cik = 1 iff point i belongs to cluster k. Unfortunately this is
NP-hard [WW93]. Below we discuss a continuous relaxation of the problem based on eigenvector
methods that is easier to solve.
21.5.2 Eigenvectors of the graph Laplacian encode the clustering
In Section 20.4.9.2, we discussed the graph Laplacian, which is defined as L , D − W, where W
is a symmetric weight matrix for the graph, and D = diag(di) is a diagonal matrix containing the
weighted degree of each node, di =
P
j wij . To get some intuition as to why L might be useful for
graph-based clustering, we note the following result.
Theorem 21.5.1. The set of eigenvectors of L with eigenvalue 0 is spanned by the indicator vectors
1S1
, . . . , 1SK , where Sk are the K connected components of the graph.
P
Proof. Let us start with the case K = 1. If f is an eigenvector with eigenvalue 0, then 0 =
ij wij (fi − fj )
2
. If two nodes are connected, so wij > 0, we must have that fi = fj . Hence f is
constant for all vertices which are connected by a path in the graph. Now suppose K > 1. In this
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license730 Chapter 21. Clustering
−6 −4 −2 0 2 4 6
x
−6
−4
−2
0
2
4
6
y
k-means clustering
(a)
−6 −4 −2 0 2 4 6
x
−6
−4
−2
0
2
4
6
y
spectral clustering
(b)
Figure 21.19: Results of clustering some data. (a) K-means. (b) Spectral clustering. Generated by code at
figures.probml.ai/book1/21.19.
case, L will be block diagonal. A similar argument to the above shows that we will have K indicator
functions, which “select out” the connected components.
This suggests the following clustering algorithm. Compute the eigenvectors and values of L, and
let U be an N × K matrix with the K eigenvectors with smallest eigenvalue in its columns. (Fast
methods for computing such “bottom” eigenvectors are discussed in [YHJ09]). Let ui ∈ R
K be
the i’th row of U. Since these ui will be piecewise constant, we can apply K-means clustering
(Section 21.3) to them to recover the connected components. (Note that the vectors ui are the same
as those computed by Laplacian eigenmaps discussed in Section 20.4.9.)
Real data may not exhibit such clean block structure, but one can show, using results from
perturbation theory, that the eigenvectors of a “perturbed” Laplacian will be close to these ideal
indicator functions [NJW01].
In practice, it is important to normalize the graph Laplacian, to account for the fact that some
nodes are more highly connected than others. One way to do this (proposed in [NJW01]) is to create
a symmetric matrix
Lsym , D− 1
2LD− 1
2 = I − D− 1
2WD− 1
2 (21.30)
This time the eigenspace of 0 is spanned by D
1
2 1Sk
. This suggests the following algorithm: find the
smallest K eigenvectors of Lsym, stack them into the matrix U, normalize each row to unit norm
by creating tij = uij/
p
(
P
k
u
2
ik) to make the matrix T, cluster the rows of T using K-means, then
infer the partitioning of the original points.
21.5.3 Example
Figure 21.19 illustrates the method in action. In Figure 21.19(a), we see that K-means does a
poor job of clustering, since it implicitly assumes each cluster corresponds to a spherical Gaussian.
Next we try spectral clustering. We compute a dense similarity matrix W using a Gaussian kernel,
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202221.6. Biclustering * 731
Wij = exp(−
1
2σ2 ||xi −xj ||2
2
). We then compute the first two eigenvectors of the normalized Laplacian
Lsym. From this we infer the clustering using K-means, with K = 2; the results are shown in
Figure 21.19(b).
21.5.4 Connection with other methods
Spectral clustering is closely related to several other methods for unsupervised learning, some of
which we discuss below.
21.5.4.1 Connection with kPCA
Spectral clustering is closely related to kernel PCA (Section 20.4.6). In particular, kPCA uses the
largest eigenvectors of W; these are equivalent to the smallest eigenvectors of I − W. This is similar
to the above method, which computes the smallest eigenvectors of L = D − W. See [Ben+04a] for
details. In practice, spectral clustering tends to give better results than kPCA.
21.5.4.2 Connection with random walk analysis
In practice we get better results by computing the eigenvectors of the normalized graph Laplacian.
One way to normalize the graph Laplacian, which is used in [SM00; Mei01], is to define
Lrw , D−1L = I − D−1W (21.31)
One can show that for Lrw, the eigenspace of 0 is again spanned by the indicator vectors 1Sk
[Lux07],
so we can perform clustering directly on the K smallest eigenvectors U.
There is an interesting connection between this approach and random walks on a graph. First
note that P = D−1W = I − Lrw is a stochastic matrix, where pij = wij/di can be interpreted as the
probability of going from i to j. If the graph is connected and non-bipartite, it possesses a unique
stationary distribution π = (π1, . . . ,πN ), where πi = di/vol(V ), and vol(V ) = P
i
di
is the sum of
all the node degrees. Furthermore, one can show that for a partition of size 2,
Ncut(S, S) = p(S|S) + p(S|S) (21.32)
This means that we are looking for a cut such that a random walk spends more time transitioning to
similar points, and rarely makes transitions from S to S or vice versa. This analysis can be extended
to K > 2; for details, see [Mei01].
21.6 Biclustering *
In some cases, we have a data matrix X ∈ R
Nr×Nc and we want to cluster the rows and the columns;
this is known as biclustering or coclustering. This is widely used in bioinformatics, where the
rows often represent genes and the columns represent conditions. It can also be used for collaborative
filtering, where the rows represent users and the columns represent movies.
A variety of ad hoc methods for biclustering have been proposed; see [MO04] for a review. In
Section 21.6.1, we present a simple probabilistic generative model in which we assign a latent cluster
id to each row, and a differnet latent cluster id to each column. In Section 21.6.2, we extend this
to the case where each row can belong to multiple clusters, depending on which groups of features
(columns) we choose to use to define the different groups of objects (rows).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license732 Chapter 21. Clustering
O1 killer whale, blue whale, humpback, seal, walrus, dolphin
O2 antelope, horse, giraffe, zebra, deer
O3 monkey, gorilla, chimp
O4 hippo, elephant, rhino
O5 grizzly bear, polar bear
F1 flippers, strain teeth, swims, arctic, coastal, ocean, water
F2 hooves, long neck, horns
F3 hands, bipedal, jungle, tree
F4 bulbous body shape, slow, inactive
F5 meat teeth, eats meat, hunter, fierce
F6 walks, quadrapedal, ground
F1 2 4 3 5
O1
O2
O3
O4
O5
6
Figure 21.20: Illustration of biclustering. We show 5 of the 12 organism clusters, and 6 of the 33 feature
clusters. The original data matrix is shown, partitioned according to the discovered clusters. From Figure 3
of [Kem+06]. Used with kind permission of Charles Kemp.
21.6.1 Basic biclustering
Here we present a simple probabilistic generative model for biclustering based on [Kem+06] (see also
[SMM03] for a related approach). The idea is to associate each row and each column with a latent
indicator, ui ∈ {1, . . . , Nu}, vj ∈ {1, . . . , Nv}, where Nu is the number of row clusters, and Nv is the
number of column clusters. We then use the following generative model:
p(U) = Y
Nr
i=1
Unif(ui
|{1, . . . , Nu}) (21.33)
p(V) = Y
Nc
j=1
Cat(vj |{1, . . . , Nv}) (21.34)
p(X|U, V, θ) = Y
Nr
i=1
Y
Nc
j=1
p(Xij |θui,vj
) (21.35)
where θa,b are the parameters for row cluster a and column cluster b.
Figure 21.20 shows a simple example. The data has the form Xij = 1 iff animal i has feature
j, where i = 1 : 50 and j = 1 : 85. The animals represent whales, bears, horses, etc. The
features represent properties of the habitat (jungle, tree, coastal), or anatomical properties (has
teeth, quadripedal), or behavioral properties (swims, eats meat), etc. The method discovered 12
animal clusters and 33 feature clusters. ([Kem+06] use a Bayesian nonparametric method to infer
the number of clusters.) For example, the O2 cluster is { antelope, horse, giraffe, zebra, deer }, which
is characterized by feature clusters F2 = { hooves, long neck, horns} and F6 = { walks, quadripedal,
ground }, whereas the O4 cluster is { hippo, elephant, rhino }, which is characterized by feature
clusters F4 = { bulbous body shape, slow, inactive } and F6.
21.6.2 Nested partition models (Crosscat)
The problem with basic biclustering (Section 21.6.1) is that each object (row) can only belong to
one cluster. Intuitively, an object can have multiple roles, and can be assigned to different clusters
depending on which subset of features you use. For example, in the animal dataset, we may want to
group the animals on the basis of anatomical features (e.g., mammals are warm blooded, reptiles are
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202221.6. Biclustering * 733
1.1 1.1 1.2 1.3 1.3 1.3
1.1 1.1 1.2 1.3 1.3 1.3
1.1 1.1 1.2 1.3 1.3 1.3
2.1 2.1 2.2 2.3 2.3 2.3
2.1 2.1 3.2 2.3 2.3 2.3
2.1 2.1 3.2 2.3 2.3 2.3
(a)
1.1 1.1 1.2 1.3 1.3 1.3
1.1 1.1 1.2 1.3 1.3 1.3
1.1 1.1 2.2 1.3 1.3 1.3
2.1 2.1 2.2 1.3 1.3 1.3
2.1 2.1 3.2 1.3 1.3 1.3
2.1 2.1 3.2 2.3 2.3 2.3
(b)
Figure 21.21: (a) Example of biclustering. Each row is assigned to a unique cluster, and each column is
assigned to a unique cluster. (b) Example of multi-clustering using a nested partition model. The rows can
belong to different clusters depending on which subset of column features we are looking at.
not), or on the basis of behavioral features (e.g., predators vs prey).
We now present a model that can capture this phenomenon. We illustrate the method with an
example. Suppose we have a 6 × 6 matrix, with Nu = 2 row clusters and Nv = 3 column clusters.
Furthermore, suppose the latent column assignments are as follows: v = [1, 1, 2, 3, 3, 3]. This means
we put columns 1 and 2 into group 1, column 3 into group 2, and columns 4 to 6 into group 3. For
the columns that get clustered into group 1, we cluster the rows as follows: u:,1 = [1, 1, 1, 2, 2, 2]; For
the columns that get clustered into group 2, we cluster the rows as follows: u:,2 = [1, 1, 2, 2, 2, 2]; and
for the columns that get clustered into group 3, we cluster the rows as follows: u:,3 = [1, 1, 1, 1, 1, 2].
The resulting partition is shown in Figure 21.21(b). We see that the clustering of the rows depends
on which group of columns we choose to focus on.
Formally, we can define the model as follows:
p(U) = Y
Nr
i=1
Y
Nv
l=1
Unif(uil|{1, . . . , Nu}) (21.36)
p(V) = Y
Nc
j=1
Unif(vj |{1, . . . , Nv}) (21.37)
p(Z|U, V) = Y
Nr
i=1
Y
Nc
j=1
I
￾
Zij = (ui,vj
, vj )

(21.38)
p(X|Z, θ) = Y
Nr
i=1
Y
Nc
j=1
p(Xij |θzij ) (21.39)
where θk,l are the parameters for cocluster k ∈ {1, . . . , Nu} and l ∈ {1, . . . , Nv}.
This model was independently proposed in [Sha+06; Man+16] who call it crosscat (for cross￾categorization), in [Gua+10; CFD10], who call it multi-clust, and in [RG11], who call it nested
partitioning. In all of these papers, the authors propose to use Dirichlet processes, to avoid the
problem of estimating the number of clusters. Here we assume the number of clusters is known, and
show the parameters explicitly, for notational simplicity.
Figure 21.22 illustrates the model applied to some binary data containing 22 animals and 106
features. The figure shows the (approximate) MAP partition. The first partition of the columns
contains taxonomic features, such as “has bones”, “is warm-blooded”, “lays eggs”, etc. This divides the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens734 Chapter 21. Clustering lives in lakes is an amphibian is a rodent is tall is a fish is slimy has horns has hooves is a feline roars has fins has webbed feet eats nuts is smooth lives in trees is large lives in cold climates is ferocious is dangerous is a carnivore is a predator lives in water flies is long eats leaves eats animals lives in grass eats fish lives in hot climates
Leopard
Alligator
Python
Seal
Dolphin
Frog
Jellyfish
Octopus
Penguin
Finch
Seagull
Owl
Eagle
Dragonfly
Bat
Grasshopper
Ant
Bee
Sheep
Monkey
Iguana
Ostrich
has bones
lays eggs is warm−blooded
is a mammal
squawks has a beak
has a tongue is green has a spinal cord is a lizard
has antennae
has flippers has paws has a large brain has a tail
is furry eats mice
eats rodents
has a snout
is brown
makes loud noises
has teeth
has feet
is smart
travels in groups
Leopard
Sheep Seal
Dolphin
Monkey Bat
Alligator
Iguana Frog Python
Finch
Ostrich
Seagull Owl
Penguin Eagle Grasshopper Ant
Bee
Jellyfish
Octopus
Dragonfly
A B C
Frog
Figure 21.22: MAP estimate produced by the crosscat system when applied to a binary data matrix of animals
(rows) by features (columns). See text for details. From Figure 7 of [Sha+06]. Used with kind permission of
Vikash Mansingkha.
animals into birds, reptiles/ amphibians, mammals, and invertebrates. The second partition of the
columns contains features that are treated as noise, with no apparent structure (except for the single
row labeled “frog”). The third partition of the columns contains ecological features like “dangerous”,
“carnivorous”, “lives in water”, etc. This divides the animals into prey, land predators, sea predators
and air predators. Thus each animal (row) can belong to a different cluster depending on what set of
features are considered.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202222 Recommender Systems
Recommender systems are systems which recommend items (such as movies, books, ads) to
users based on various information, such as their past viewing/ purchasing behavior (e.g., which
movies they rated high or low, which ads they clicked on), as well as optional “side information” such
as demographics about the user, or information about the content of the item (e.g., its title, genre
or price). Such systems are widely used by various internet companies, such as Facebook, Amazon,
Netflix, Google, etc. In this chapter, we give a brief introduction to the topic. More details can be
found in e.g., [DKK12; Pat12; Yan+14; AC16; Agg16; Zha+19b]..
22.1 Explicit feedback
In this section, we consider the simplest setting in which the user gives explicit feedback to the
system in terms of a rating, such as +1 or -1 (for like/dislike) or a score from 1 to 5. Let Yui ∈ R
be the rating that user u gives to item i. We can represent this as an M × N matrix, where M is
the number of users, and N is the number of items. Typically this matrix will be very large but
very sparse, since most users will not provide any feedback on most items. See Figure 22.1(a) for an
example. We can also view this sparse matrix as a bipartite graph, where the weight of the u − i
edge is Yui. This reflects the fact that we are dealing with relational data, i.e., the values of u and
i have no intrinsic meaning (they are just arbitrary indices), it is the fact that u and i are connected
that matters.
If Yui is missing, it could be because user u has not interacted with item i, or it could be that they
knew they wouldn’t like it and so they chose not to engage with it. In the former case, some of the
data is missing at random; in the latter case, the missingness is informative about the true value
of Yui. (See e.g., [Mar+11] for further discussion of this point.) We will assume the data is missing
at random, for simplicity.
22.1.1 Datasets
A famous example of an explicit ratings matrix was made available by the movie streaming company
Netflix. In 2006, they released a large dataset of 100,480,507 movie ratings (on a scale of 1 to 5)
from 480,189 users of 17,770 movies. Despite the large size of the training set, the ratings matrix is
still 99% sparse (unknown). Along with the data, they offered a prize of $100,000, known as the
Netflix Prize, to any team that could predict the true ratings of a set of test (user, item) pairs
more accurately than their incumbent system. The prize was claimed on September 21, 2009 by a
team known as “Pragmatic Chaos”. They used an ensemble of different methods, as described in736 Chapter 22. Recommender Systems
Figure 22.1: Example of a relational dataset represented as a sparse matrix (left) or a sparse bipartite graph
(right). Values corresponding to empty cells (missing edges) are unknown. Rows 3 and 4 are similar to each
other, indicating that users 3 and 4 might have similar preferences, so we can use the data from user 3 to
predict user 4’s preferences. However, user 1 seems quite different in their preferences, and seems to give low
ratings to all items. For user 2, we have very little observed data, so it is hard to make reliable predictions.
[Kor09; BK07; FHK12]. However, a key component in their ensemble was the method described in
Section 22.1.3.
Unfortunately the Netflix data is no longer available due to privacy concerns. Fortunately the
MovieLens group at the University of Minnesota have released an anonymized public dataset of
movie ratings, on a scale of 1-5, that can be used for research [HK15]. There are also various
other public explicit ratings datasets, such as the Jester jokes dataset from [Gol+01] and the
BookCrossing dataset from [Zie+05].
22.1.2 Collaborative filtering
The original approach to the recommendation problem is called collaborative filtering [Gol+92].
The idea is that users collaborate on recommending items by sharing their ratings with other users;
then if u wants to know if they interact with i, they can see what ratings other users u
0 have given
to i, and take a weighted average:
Yˆ
ui =
X
u0
:Yu0,i6=?
sim(u, u0
) Yu0
,i (22.1)
where we assume Yu0
,i =? if the entry is unknown. The traditional approach measured the similarity
of two users by comparing the sets Su = {Yu,i 6=? : i ∈ I} and Su0 = {Yu0
,i =? : 6 i ∈ I}, where I
is the set of items. However, this can suffer from data sparsity. In Section 22.1.3 we discuss an
approach based on learning dense embedding vectors for each item and each user, so we can compute
similarity in a low dimensional feature space.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202222.1. Explicit feedback 737
22.1.3 Matrix factorization
We can view the recommender problem as one of matrix completion, in which we wish to predict
all the missing entries of Y. We can formulate this as the following optimization problem:
L(Z) = X
ij:Yij 6=?
(Zij − Yij )
2 = ||Z − Y||2
F (22.2)
However, this is an under-specified problem, since there are an infinite number of ways of filling in
the missing entries of Z.
We need to add some constraints. Suppose we assume that Y is low rank. Then we can write it in
the form Z = UVT ≈ Y, where U is an M × K matrix, V is a N × K matrix, K is the rank of the
matrix, M is the number of users, and N is the number of items. This corresponds to a prediction of
the form by writing
yˆui = u
T
uvi (22.3)
This is called matrix factorization.
If we observe all the Yij entries, we can find the optimal Z using SVD (Section 7.5). However,
when Y has missing entries, the corresponding objective is no longer convex, and does not have a
unique optimum [SJ03]. We can fit this uisng alternating least squares (ALS), where we estimate
U given V and then estimate V given U (for details, see e.g., [KBV09]). Alternatively we can just
use SGD.
In practice, it is important to also allow for user-specific and item-specific baselines, by writing
yˆui = µ + bu + ci + u
T
uvi (22.4)
This can capture the fact that some users might always tend to give low ratings and others may give
high ratings; in addition, some items (e.g., very popular movies) might have unusually high ratings.
In addition, we can add some `2 regularization to the parameters to get the objective
L(θ) = X
ij:Yij 6=?
(yij − yˆij )
2 + λ(b
2
u + c
2
i + ||uu||2 + ||vi
||2
) (22.5)
We can optimize this using SGD by sampling a random (u, i) entry from the set of observed values,
and performing the following updates:
bu = bu + η(eui − λbu) (22.6)
ci = ci + η(eui − λbi) (22.7)
uu = uu + η(euiuu − λuu) (22.8)
vi = vi + η(euivi − λvi) (22.9)
where eui = yui − yˆui is the error term, and η ≥ 0 is the learning rate. This approach was first
proposed by Simon Funk, who was one of the first to do well in the early days of the Netflix
competition.1
1. https://sifter.org/~simon/journal/20061211.html.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license738 Chapter 22. Recommender Systems
Figure 22.2: Visualization of the first two latent movie factors estimated from the Netflix challenge data.
Each movie j is plotted at the location specified by vj . See text for details. From Figure 3 of [KBV09]. Used
with kind permission of Yehuda Koren.
22.1.3.1 Probabilistic matrix factorization (PMF)
We can convert matrix factorization into a probabilistic model by defining
p(yui = y) = N (y|µ + bu + ci + u
T
uvi
, σ2
) (22.10)
This is known as probabilistic matrix factorization (PMF) [SM08]. The NLL of this model
is equivalent to the matrix factorization objective in Equation (22.2). However, the probabilistic
perspective allows us to generalize the model more easily. For example, we can capture the fact
that the ratings are integers (often mostly 0s), and not reals, using a Poisson or negative Binomial
likelihood (see e.g., [GOF18]). This is similar to exponential family PCA (Section 20.2.7), except
that we view rows and columns symmetrically.
22.1.3.2 Example: Netflix
Suppose we apply PMF to the Netflix dataset using K = 2 latent factors. Figure 22.2 visualizes the
learned embedding vectors ui for a few movies. On the left of the plot we have low-brow humor and
horror movies (Half Baked, Freddy vs Jason), and on the right we have more serious dramas (Sophie’s
Choice, Moonstruck). On the top we have critically acclaimed independent movies (Punch-Drunk Love,
I Heart Huckabees), and on the bottom we have mainstream Hollywood blockbusters (Armageddon,
Runway Bride). The Wizard of Oz is right in the middle of these axes, since it is in some senses an
“average movie”.
Users are embedded into the same spaces as movies. We can then predict the rating for any
user-video pair using proximity in the latent embedding space.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202222.1. Explicit feedback 739
(a) (b)
Figure 22.3: (a) A fragment of the observed ratings matrix from the MovieLens-1M dataset. (b) Predictions
using SVD with 50 latent components. Generated by code at figures.probml.ai/book1/22.3.
22.1.3.3 Example: MovieLens
Now suppose we apply PMF to the MovieLens-1M dataset with 6040 users, 3706 movies, and 1,000,209
ratings. We will use K = 50 factors. For simplicity, we fit this using SVD applied to the dense
ratings matrix, where we replace missing values with 0. (This is just a simple approximation to keep
the demo code simple.) In Figure 22.3 we show a snippet of the true and predicted ratings matrix.
(We truncate the predictions to lie in the range [1,5].) We see that the model is not particularly
accurate, but does capture some structure in the data.
Furthermore, it seems to behave in a qualitatively sensible way. For example, in Figure 22.4 we
show the top 10 movies rated by a given user as well as the top 10 predictions for movies they had not
seen. The model seems to have “picked up” on the underlying preferences of the user. For example,
we see that many of the predicted movies are action or film-noir, and both of these genres feature in
the user’s own top-10 list, even though explicit genre information is not used during model training.
22.1.4 Autoencoders
Matrix factorization is a (bi)linear model. We can make a nonlinear version using autoencoders. Let
y:,i ∈ RM be the i’th column of the ratings matrix, where unknown ratings are set to 0. We can
predict this ratings vector using an autoencoder of the form
f(y:,i; θ) = WTϕ(Vy:,i + µ) + b (22.11)
where V ∈ R
KM maps the ratings to an embedding space, W ∈ R
KM maps the embedding space to
a distribution over ratings, µ ∈ R
K are the biases of the hidden units, and b ∈ RM are the biases
of the output units. This is called the (item-based) version of the AutoRec model [Sed+15]. This
has 2MK + M + K parameters. There is also a user-based version, that can be derived in a similar
manner, which has 2NK + N + K parameters. (On MovieLens and Netflix, the authors find that
the item-based method works better.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license740 Chapter 22. Recommender Systems
(a)
(b)
Figure 22.4: (a) Top 10 movies (from a list of 69) that user “837” has already highly rated. (b) Top 10
predictions (from a list of 3637) from the algorithm. Generated by code at figures.probml.ai/book1/22.4.
We can fit this by only updating parameters that are associated with the observed entries of y:,i.
Furthermore, we can add an `2 regularizer to the weight matrices to get the objective
L(θ) = X
N
i=1
X
u:yui6=?
(yu,i − f(y:,i; θ)u)
2 +
λ
2
(||W||2
F + ||V||2
F ) (22.12)
Despite the simplicity of this method, the authors find that this does better than more complex
methods such as restricted Boltzmann machines (RBMs, [SMH07]) and local low-rank matrix
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202222.2. Implicit feedback 741
approximation (LLORMA, [Lee+13]).
22.2 Implicit feedback
So far, we have assumed that the user gives explicit ratings for each item that they interact with.
This is a very restrictive assumption. More generally, we would like to learn from the implicit
feedback that users give just by interacting with a system. For example, we can treat the list of
movies that user u watches as positives, and regard all the other movies as negatives. Thus we get a
sparse, positive-only ratings matrix.
Alternatively, we can view the fact that they watched movie i but did not watch movie j as an
implicit signal that they prefer i to j. The resulting data can be represented as a set of tuples of the
form yn = (u, i, j), where (u, i) is a positive pair, and (u, j) is a negative (or unlabeled) pair.
22.2.1 Bayesian personalized ranking
To fit a model to data of the form (u, i, j), we need to use a ranking loss, so that the model ranks i
ahead of j for user u. A simple way to do this is to use a Bernoulli model of the form
p(yn = (u, i, j)|θ) = σ(f(u, i; θ) − f(u, j; θ)) (22.13)
If we combine this with a Gaussian prior for θ, we get the following MAP estimation problem:
L(θ) = X
(u,i,j)∈D
log σ(f(u, i; θ) − f(u, j; θ)) − λ||θ||2
(22.14)
where D = {(u, i, j) : i ∈ I+
u
, j ∈ I \ I+
u }, where I
+
u are the set of all items that user u selected, and
I \ I+
u are all the other items (which they may dislike, or simply may not have seen). This is known
as Bayesian personalized ranking or BPR [Ren+09].
Let us consider this example from [Zha+20, Sec 16.5]. There are 4 items in total, I = {i1, i2, i3, i4},
and user u chose to interact with I
+
u = {i2, i3}. In this case, the implicit item-item preference matrix
for user u has the form
Yu =


. + + ?
− . ? −
− ? . −
? + + .


(22.15)
where Yu,i,i0 = + means user u prefers i
0
to i, Yu,i,i0 = − means user u prefers i to i
0
, and Yu,i,i0 =?
means we cannot tell what the user’s preference is. For example, focusing on the second column, we
see that this user rates i2 higher than i1 and i4, since they selected i2 but not i1 or i4; however, we
cannot tell if they prefer i2 over i3 or vice versa.
When the set of posssible items is large, the number of negatives in I \ I+
u
can be very large.
Fortunately we can approximate the loss by subsampling negatives.
Note that an alternative to the log-loss above is to use a hinge loss, similar to the approach used
in SVMs (Section 17.3). This has the form
L(yn = (u, i, j), f) = max (m − (f(u, i) − f(u, j)), 0) = max (m − f(u, i) + f(u, j), 0) (22.16)
where m ≥ 0 is the safety margin. This tries to ensure the negative items j never score more than m
higher than the positive items i.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license742 Chapter 22. Recommender Systems
22.2.2 Factorization machines
The AutoRec approach of Section 22.1.4 is nonlinear, but treats users and items asymmetrically.
In this section, we discuss a more symmetric discriminative modeling approach. We start with a
linear version. The basic idea is to predict the output (such as a rating) for any given user-item pair,
x = [one-hot(u), one-hot(i)], using
f(x) = µ +
X
D
i=1
wixi +
X
D
i=1
X
D
j=i+1
(v
T
i vj )xixj (22.17)
where x ∈ R
D where D = (M + N) is the number of inputs, V ∈ R
D×K is a weight matrix, w ∈ R
D
is a weight vector, and µ ∈ R is a global offset. This is known as a factorization machine (FM)
[Ren12].
The term (v
T
i vj )xixj measures the interaction between feature i and j in the input. This generalizes
the matrix factorization model of Equation (22.4), since it can handle other kinds of information in
the input x, beyond just user and item, as we discuss in Section 22.3.
Computing Equation (22.17) takes O(KD2
) time, since it considers all possible pairwise interactions
between every user and every item. Fortunately we can rewrite this so that we can compute it in
O(KD) time as follows:
X
D
i=1
X
D
j=i+1
(v
T
i vj )xixj =
1
2
X
D
i=1
X
D
j=1
(v
T
i vj )xixj −
1
2
X
D
i=1
(v
T
i vi)xixi (22.18)
= −
1
2


X
D
i=1
X
D
j=1
X
K
k=1
vikvjkxixj −
X
D
i=1
X
K
k=1
vikvikxixi

 (22.19)
= −
1
2
X
K
k=1 
(
X
D
i=1
vikxi)
2 −
X
D
i=1
v
2
ikx
2
i
!
(22.20)
For sparse vectors, the overall complexity is linear in the number of non-zero components. So if we
use one-hot encodings of the user and item id, the complexity is just O(K), analogous to the original
matrix factorization objective of Equation (22.4).
We can fit this model to minimize any loss we want. For example, if we have explicit feedback, we
may choose MSE loss, and if we have implicit feedback, we may choosing ranking loss.
In [Guo+17], they propose a model called deep factorization machines, which combines the
above method with an MLP applied to a concatenation of the embedding vectors, instead of the
inner product. More precisely, it is a model of the form
f(x; θ) = σ(FM(x) + MLP(x)) (22.21)
This is closely related to the wide and deep model proposed in [Che+16]. The idea is that
the bilinear FM model captures explicit interactions between specific users and items (a form of
memorization), whereas the MLP captures implicit interactions between user features and item
features, which allows the model to generalize.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202222.3. Leveraging side information 743
Input Layer (Sparse)
Embedding Layer
Neural CF Layers
Output Layer
0 0 0 1 0 0 ……
User (u)
0 0 0 0 1 0 ……
Item (i)
User Latent Vector Item Latent Vector
Layer 1
Layer 2
Layer X ……
Score Target Training ŷui yui
PM×K = {puk} QN×K = {qik}
Figure 22.5: Illustration of the neural matrix factorization model. From Figure 2 of [He+17]. Used with kind
permission of Xiangnan He.
22.2.3 Neural matrix factorization
In this section, we describe the neural matrix factorization model of [He+17]. This is another
way to combine bilinear models with deep neural networks. The bilinear part is used to define the
following generalized matrix factorization (GMF) pathway, which computes the following feature
vector for user u and item i:
z
1
ui = Pu,:  Qi,: (22.22)
where P ∈ RMK is a user embedding matrix, and Q ∈ R
NK is an item embedding matrix. The DNN
part is just an MLP applied to a concatenation of the embedding vectors (using different embedding
matrices):
z
2
ui = MLP([U˜
u,:
, V˜
i,:
]) (22.23)
Finally, the model combines these to get
f(u, i; θ) = σ(wT
[z
1
ui, z
2
ui]) (22.24)
See Figure 22.5 for an illustration.
In [He+17], the model is trained on implicit feedback, where yui = 1 if the interaction of user u
with item i is observed, and yui = 0 otherwise. However, it could be trained to minimize BPR loss.
22.3 Leveraging side information
So far, we have assumed that the only information available to the predictor are the integer id of the
user and the integer id of the item. This is an extremely impoverished representation, and will fail to
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license744 Chapter 22. Recommender Systems
Figure 22.6: Illustration of a design matrix for a movie recommender system, where we show the id of the
user and movie, as well as other side information. From Figure 1 of [Ren12]. Used with kind permission of
Stefen Rendle.
work if we encounter a new user or new item (the so-called cold start problem). To overcome this,
we need to leverage “side information”, beyond just the id of the user/item.
There are many forms of side information we can use. For items, we often have rich meta-data,
such text (e.g., title), images (e.g., cover), high-dimensional categorical variables (e.g., location), or
just scalars (eg., price). For users, the side information available depends on the specific form of the
interactive system. For search engines, it is the list of queries the user has issued, and (if they are
logged in), information derived from websites they have visited (which is tracked via cookies). For
online shopping sites, it is the list of searches plus past viewing and purchasing behavior. For social
networking sites, there is information about the friendship graph of each user.
It is very easy to capture this side information in the factorization machines framework, by
expanding our definition of x beyond the two one-hot vectors, as illustrated in Figure 22.6. The
same input encoding can of course be fed into other kinds of models, such as deepFM or neuralMF.
In addition to features about the user and item, there may be other contextual features, such as
the time of the interaction (e.g., the day or evening). The order (sequence) of the most recently
viewed items is often also a useful signal. The “Convolutional Sequence Embedding Recommendation”
or Caser model proposed in [TW18] captures this by embedding the last M items, and then treating
the M × K input as an image, by using a convolutional layer as part of the model.
Many other kinds of neural models can be designed for the recommender task. See e.g., [Zha+19b]
for a review.
22.4 Exploration-exploitation tradeoff
An interesting “twist” to recommender systems that does not arise in other kinds of prediction
problems is the fact that the data that the system is trained on is a consequence of recommendations
made by earlier versions of the system. Thus there is a feedback loop [Bot+13]. For example, consider
the YouTube video recommendation system [CAS16]. There are millions of videos on the site, so the
system must come up with a shortlist, or “slate”, of videos to show the user, to help them find what
they want (see e.g., [Ie+19]). If the user watches one of these videos, the system can consider this
positive feedback that it made a good recommendation, and it can update the model parameters
accordingly. However, maybe there was some other video that the user would have liked even more?
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202222.4. Exploration-exploitation tradeoff 745
It is impossible to answer this counterfactual unless the system takes a chance and shows some
items for which the user response is uncertain. This is an example of the exploration-exploitation
tradeoff.
In addition to needing to explore, the system may have to wait for a long time until it can detect
if a change it made its recommendation policies was beneficial. It is common to use reinforcement
learning to learn policies which optimize long-term reward. See the sequel to this book, [Mur22],
for details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license23 Graph Embeddings *
This chapter is coauthored with Bryan Perozzi, Sami Abu-El-Haija and Ines Chami, and is based on
[Cha+21].
23.1 Introduction
We now turn our focus to data which has semantic relationships between training samples {xn}
N
n=1.
The relationships (known as edges) connect training samples (nodes) with an application specific
meaning (commonly similarity). Graphs provide the mathematical foundations for reasoning about
these kind of relationships
Graphs are universal data structures that can represent complex relational data (composed of
nodes and edges), and appear in multiple domains such as social networks, computational chemistry
[Gil+17], biology [Sta+06], recommendation systems [KSJ09], semi-supervised learning [GB18], and
others.
Let A ∈ {0, 1}
N×N be the adjacency matrix, where N is the number of nodes, and let W ∈ R
N×N
be a weighted version. In the methods we discuss below, some set W = A while others set W to a
transformation of A, such as row-wise normalization. Finally, let X ∈ R
N×D be a matrix of node
features.
When designing and training a neural network model over graph data, we desire the designed
method be applicable to nodes which participate in different graph settings (e.g. have differing
connections and community structure). Contrast this with a neural network model designed for images,
where each pixel (node) has the same neighborhood structure. By contrast, an arbitrary graph has no
specified alignment of nodes, and further, each node might have a different neighborhood structure.
See Figure 23.1 for a comparison. Consequently, operations like Euclidean spatial convolution cannot
be directly applied on irregular graphs: Euclidean convolutions strongly rely on geometric priors
(such as shift invariance), which don’t generalize to non-Euclidean domains.
These challenges led to the development of Geometric Deep Learning (GDL) research [Bro+17b],
which aims at applying deep learning techniques to non-Euclidean data. In particular, given the
widespread prevalence of graphs in real-world applications, there has been a surge of interest in
applying machine learning methods to graph-structured data. Among these, Graph Represen￾tation Learning (GRL) [Cha+21] methods aim at learning low-dimensional continuous vector
representations for graph-structured data, also called embeddings.
We divide GRL here into two classes of problems: unsupervised and supervised (or semi￾supervised) GRL. The first class aims at learning low-dimensional Euclidean representations optimizing748 Chapter 23. Graph Embeddings *
(a) Grid (Euclidean). (b) Arbitrary graph (Non-Euclidean).
Figure 23.1: An illustration of Euclidean vs. non-Euclidean graphs. Used with permission from [Cha+21].
an objective, e.g. one that preserve the structure of an input graph. The second class also learns
low-dimensional Euclidean representations but for a specific downstream prediction task such as
node or graph classification. Further, the graph structure can be fixed throughout training and
testing, which is known as the transductive learning setting (e.g. predicting user properties in a
large social network), or alternatively the model is expected to answer questions about graphs not
seen during training, known as the inductive learning setting (e.g. classifying molecular structures).
Finally, while most supervised and unsupervised methods learn representations in Euclidean vector
spaces, there recently has been interest for non-Euclidean representation learning, which aims
at learning non-Euclidean embedding spaces such as hyperbolic or spherical spaces. The main
motivations for this body of work is to use a continuous embedding space that resembles the
underlying discrete structure of the input data it tries to embed (e.g. the hyperbolic space is a
continuous version of trees [Sar11]).
23.2 Graph Embedding as an Encoder/Decoder Problem
While there are many approaches to GRL, many methods follow a similar pattern. First, the network
input (node features X ∈ R
N×D and graph edges in A or W ∈ R
N×N ) is encoded from the discrete
domain of the graph into a continuous representation (embedding), Z ∈ R
N×L. Next, the learned
representation Z is used to optimize a particular objective (such as reconstructing the links of the
graph). In this section we will use the graph encoder-decoder model (GraphEDM) proposed by
Chami et al. [Cha+21] to analyze popular families of GRL methods.
The GraphEDM framework (Figure 23.2, [Cha+21]) provides a general framework that encap￾sulates a wide variety of supervised and unsupervised graph embedding methods: including ones
utilizing the graph as a regularizer (e.g. [ZG02]), positional embeddings(e.g. [PARS14]), and graph
neural networks such as ones based on message passing [Gil+17; Sca+09] or graph convolutions
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202223.2. Graph Embedding as an Encoder/Decoder Problem 749
Figure 23.2: Illustration of the GraphEDM framework from Chami et al. [Cha+21]. Based on the supervision
available, methods will use some or all of the branches. In particular, unsupervised methods do not leverage
label decoding for training and only optimize the similarity decoder (lower branch). On the other hand,
semi-supervised and supervised methods leverage the additional supervision to learn models’ parameters (upper
branch). Reprinted with permission from [Cha+21].
[Bru+14; KW16a]).
The GraphEDM framework takes as input a weighted graph W ∈ R
N×N , and optional node
features X ∈ R
N×D. In (semi-)supervised settings, we assume that we are given training target labels
for nodes (denoted N), edges (denoted E), and/or for the entire graph (denoted G). We denote the
supervision signal as S ∈ {N, E, G}, as presented below.
The GraphEDM model itself can be decomposed into the following components:
• Graph encoder network ENCΘE : R
N×N × R
N×D → R
N×L, parameterized by ΘE, which
combines the graph structure with optional node features to produce a node embedding matrix
Z ∈ R
N×L as follows:
Z = ENC(W, X; ΘE). (23.1)
As we shall see next, this node embedding matrix might capture different graph properties
depending on the supervision used for training.
• Graph decoder network DECΘD : R
N×L → R
N×N , parameterized by ΘD, which uses the
node embeddings Z to compute similarity scores for all node pairs in matrix Wc ∈ R
N×N as
follows:
Wc = DEC(Z; ΘD). (23.2)
• Classification network DECΘS : R
N×L → R
N×|Y|, where Y is the label space. This network is
used in (semi-)supervised settings and parameterized by ΘS. The output is a distribution over
the labels yˆ
S, using node embeddings, as follows:
yb
S = DEC(Z; ΘS
). (23.3)
Specific choices of the aforementioned (encoder and decoder) networks allows GraphEDM to realize
specific graph embedding methods, as we explain in the next subsections.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license750 Chapter 23. Graph Embeddings *
Figure 23.3: Shallow embedding methods. The encoder is a simple embedding look-up and the graph structure
is only used in the loss function. Reprinted with permission from [Cha+21].
The output of a model, as described by GraphEDM framework, is a reconstructed graph similarity
matrix Wc (often used to train unsupervised embedding algorithms), and/or labels yb
S for supervised
applications. The label output space Y is application dependent. For instance, in node-level
classification, yb
N ∈ YN , with Y representing the node label space. Alternately, for edge-level labeling,
yb
E ∈ YN×N , with Y representing the edge label space. Finally, we note that other kinds of labeling
are possible, such as graph-level labeling (where we would say yb
G ∈ Y, with Y representing the graph
label space).
Finally, a loss must be specified. This can be used to optimize the parameters Θ = {ΘE, ΘD, ΘS}.
GraphEDM models can be optimized using a combination of three different terms. First, a supervised
loss term, L
S
SUP, compares the predicted labels yˆ
S to the ground truth labels y
S. Next, a graph
reconstruction loss term, LG,RECON, may leverage the graph structure to impose regularization
constraints on the model parameters. Finally, a weight regularization loss term, LREG, allows
representing priors on trainable model parameters for reducing overfitting. Models realizable by
GraphEDM framework are trained by minimizing the total loss L defined as:
L = αL
S
SUP(y
S
, yˆ
S
; Θ) + βLG,RECON(W,Wc; Θ) + γLREG(Θ), (23.4)
where α, β and γ are hyper-parameters, that can be tuned or set to zero. Note that graph embedding
methods can be trained in a supervised (α 6= 0) or unsupervised (α = 0) fashion. Supervised graph
embedding approaches leverage an additional source of information to learn embeddings such as node
or graph labels. On the other hand, unsupervised network embedding approaches rely on the graph
structure only to learn node embeddings.
23.3 Shallow graph embeddings
Shallow embedding methods are transductive graph embedding methods, where the encoder function
maps categorical node IDs onto a Euclidean space through an embedding matrix. Each node vi ∈ V
has a corresponding low-dimensional learnable embedding vector Zi ∈ R
L and the shallow encoder
function is
Z = ENC(ΘE) , Θ
E where Θ
E ∈ R
N×L
. (23.5)
Crucially, the embedding dictionary Z is directly learned as model parameters. In the unsupervised
case, embeddings Z are optimized to recover some information about the input graph (e.g., the
adjacency matrix W, or some transformation of it). This is somewhat similar to dimensionality
reduction methods, such as PCA (Section 20.1), but for graph data structures. In the supervised
case, the embeddings are optimized to predict some labels, for nodes, edges and/or the whole graph.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202223.3. Shallow graph embeddings 751
23.3.1 Unsupervised embeddings
In the unsupervised case, we will consider two main types of shallow graph embedding methods:
distance-based and outer product-based. Distance-based methods optimize the embedding dictionary
Z = ΘE ∈ R
N×L such that nodes i and j which are close in the graph (as measured by some
graph distance function) are embedded in Z such that d2(Zi
, Zj ) is small, where d2(., .) is a pairwise
distance function between embedding vectors. The distance function d2(·, ·) can be customized, which
can lead to Euclidean (Section 23.3.2) or non-Euclidean (Section 23.3.3) embeddings. The decoder
outputs a node-to-node matrix Wc = DEC(Z; ΘD), with Wcij = d2(Zi
, Zj ).
Alternatively, some methods rely on pairwise dot-products to compute node similarities. The
decoder network can be written as: Wc = DEC(Z; ΘD) = ZZ>.
In both cases, unsupervised embeddings for distance- and product-based methods are learned by
minimizing the graph regularization loss:
LG,RECON(W,Wc; Θ) = d1(s(W),Wc), (23.6)
where s(W) is an optional transformation of the adjacency matrix W, and d1 is pairwise distance
function between matrices, which does not need to be of the same form as d2. As we shall see, there
are many plausible choices for s, d1, d2. For instance, we can let s be the adjacency matrix itself,
s(W) = W or a power of it e.g. s(W) = W2
. If the input is an weighted binary matrix W = A, we
can set s(W) = 1 − W, so that connected nodes with Aij = 1 get a weight (distance) of 0.
23.3.2 Distance-based: Euclidean methods
Distance-based methods minimize Euclidean distances between similar (connected) nodes. We give
some examples below.
Multi-dimensional scaling (MDS, Section 20.4.4) is equivalent to setting s(W) to some distance
matrix measuring the dissimilarity between nodes (e.g. proportional to pairwise shortest distance)
and then defining
d1(s(W), Wc) = X
i,j
(s(W)ij − Wcij )
2 = ||s(W) − Wc||2
F (23.7)
where Wcij = d2(Zi
, Zj ) = ||Zi − Zj || (although other distance metrics are plausible).
Laplacian eigenmaps (Section 20.4.9) learn embeddings by solving the generalized eigenvector
problem
min
Z∈R|V |×d
Z
TL Zs.t. Z
TDZ = I and Z
TD1 = 0 (23.8)
where L = D − W is the graph Laplacian (Section 20.4.9.2), and D is a diagonal matrix containing
the sum across columns for each row. The first constraint removes an arbitrary scaling factor in the
embedding and the second one removes trivial solutions corresponding to the constant eigenvector
(with eigenvalue zero for connected graphs). Further, note that Z
TL Z =
1
2
P
i,j Wij ||Zi − Zj ||2
2 and
therefore the minimization objective can be equivalently written as a graph reconstruction term, as
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license752 Chapter 23. Graph Embeddings *
follows:
d1(s(W),Wc) = X
i,j
Wij × Wcij (23.9)
Wcij = d2(Zi
, Zj ) = ||Zi − Zj ||2
2
(23.10)
where s(W) = W.
23.3.3 Distance-based: non-Euclidean methods
So far, we have discussed methods which assume that embeddings lie in an Euclidean Space. However,
recent work has considered hyperbolic geometry for graph embedding. In particular, hyperbolic
embeddings are ideal for embedding trees and offer an exciting alternative to Euclidean geometry for
graphs that exhibit hierarchical structures. We give some examples below.
Nickel and Kiela [NK17] learn embeddings of hierarchical graphs using the Poincaré model of
hyperbolic space. This is simple to represent in our notation as we only need to change d2(Zi
, Zj ) to
the Poincaré distance function:
d2(Zi
, Zj ) = dPoincar´e(Zi
, Zj ) = arcosh
1 + 2
||Zi − Zj ||2
2
(1 − ||Zi
||2
2
)(1 − ||Zj ||2
2
)

. (23.11)
The optimization then learns embeddings which minimize distances between connected nodes while
maximizing distances between disconnected nodes:
d1(W,Wc) = X
i,j
Wij log e
−Wcij
P
k|Wik=0 e−Wcik
(23.12)
where the denominator is approximated using negative sampling. Note that since the hyperbolic
space has a manifold structure, care needs to be taken to ensure that the embeddings remain on the
manifold (using Riemannian optimization techniques [Bon13]).
Other variants of these methods have been proposed. Nickel and Kiela [NK18] explore the Lorentz
model of hyperbolic space , and show that it provides better numerical stability than the Poincaré
model. Another line of work extends non-Euclidean embeddings to mixed-curvature product spaces
[Gu+18], which provide more flexibility for other types of graphs (e.g. ring of trees). Finally, work
by Chamberlain, Clough, and Deisenroth [CCD17] extends Poincaré embeddings using skip-gram
losses with hyperbolic inner products.
23.3.4 Outer product-based: Matrix factorization methods
Matrix factorization approaches learn embeddings that lead to a low rank representation of some
similarity matrix s(W), with s : R
N×N → R
N×N . The following are frequent choices: s(W) = W,
s(W) = L (Graph Laplacian), or other proximity measure such as the Katz centrality index, Common
Neighbors or Adamic/Adar index. The decoder function in matrix factorization methods is just a
dot product:
Wc = DEC(Z; ΘD) = ZZT
(23.13)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202223.3. Shallow graph embeddings 753
Figure 23.4: An overview of the pipeline for random-walk graph embedding methods. Reprinted with permission
from [God18].
Matrix factorization methods learn Z by minimizing a regularization loss LG,RECON(W,Wc; Θ) =
||s(W) − Wc||2
F
.
The graph factorization method of [Ahm+13] learns a low-rank factorization of a graph by
minimizing the graph regularization loss LG,RECON(W,Wc; Θ) = P
(vi,vj )∈E
(Wij − Wcij )
2
.
Note that if A is the binary adjacency matrix, (Aij = 1 iff (vi
, vj ) ∈ E and Aij = 0 otherwise),
the graph regularization loss can be expressed in terms of the Frobenius norm:
LG,RECON(W,Wc; Θ) = ||A  (W − Wc)||2
F , (23.14)
where  is the element-wise matrix multiplication operator. Therefore, GF also learns a low-rank
factorization of the adjacency matrix W measured in Frobenuis norm. We note that this is a sparse
operation (summing only over edges which exist in the graph), and so the method has computational
complexity O(M).
The methods described so far are all symmetric, that is, they assume that Wij = Wji. This is
a limiting assumption when working with directed graphs as some relationships are not reciprocal.
The GraRep method of [CLX15] overcomes this limitation by learning two embeddings per node, a
source embedding Z
s and a target embedding Z
t
, which capture asymmetric proximity in directed
networks. In addition to asymmetry, GraRep learns embeddings that preserve k-hop neighborhoods
via powers of the adjacency matrix and minimizes a graph reconstruction loss with:
Wc(k) = Z
(k),sZ
(k),tT
(23.15)
LG,RECON(W,Wc(k)
; Θ) = ||D−kWk − Wc(k)
||2
F , (23.16)
for each 1 ≤ k ≤ K. GraRep concatenates all representations to get source embeddings Z
s =
[Z
(1),s| . . . |Z
(K),s] and target embeddings Z
t = [Z
(1),t| . . . |Z
(K),t]. Unfortunately, GraRep is not very
scalable, since it uses a matrix power, D−1W, making it increasingly more dense. This limitation
can be circumvented by using implicit matrix factorization [Per+17] as discussed below.
23.3.5 Outer product-based: Skip-gram methods
Skip-gram graph embedding models were inspired by research in natural language processing to model
the distributional behavior of words [Mik+13c; PSM14b]. Skip-gram word embeddings are optimized
to predict words in their context (the surrounding words) for each target word in a sentence. Given
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license754 Chapter 23. Graph Embeddings *
a sequence of words (w1, . . . , wT ), skip-gram will minimize the objective:
L = −
X
−K≤i≤K,i6=0
log P(wk−i
|wk),
for each target words wk. These conditional probabilities can be efficiently estimated using neural
networks. See Section 20.5.2.2 for details.
This idea has been leveraged for graph embeddings in the DeepWalk framework of [PARS14].
They justified this by showing empirically how the frequency statistics induced by random walks
in real graphs follow a distribution similar that of words used in natural language. In terms of
GraphEDM, skip-gram graph embedding methods use an outer product (Equation 23.13) as their
decoder function and a graph reconstruction term computed over random walks on the graph.
In more detail, DeepWalk trains node embeddings to maximize the probability of predicting context
nodes for each center node. The context nodes are nodes appearing adjacent to the center node, in
simulated random walks on A. To train embeddings, DeepWalk generates sequences of nodes using
truncated unbiased random walks on the graph—which can be compared to sentences in natural
language models—and then maximize their log-likelihood. Each random walk starts with a node
vi1 ∈ V and repeatedly samples the next node uniformly at random: vij+1 ∈ {v ∈ V | (vij
, v) ∈ E}.
The walk length is a hyperparameter. All generated random-walks can then be encoded by a sequence
model. This two-step paradigm introduced by [PARS14] has been followed by many subsequent
works, such as node2vec [GL16].
We note that it is common for underlying implementations to use two distinct representations for
each node, one for when a node is center of a truncated random walk, and one when it is in the
context. The implications of this modeling choice is studied further in [AEHPAR17].
To present DeepWalk in the GraphEDM framework, we can set:
s(W) = Eq
h￾
D−1W
q
i
with q ∼ P(Q) = Categorical([1, 2, . . . , Tmax]) (23.17)
where P(Q = q) = Tmax−1+q
Tmax
(see [AEH+18] for the derivation).
Training DeepWalk is equivalent to minimizing:
LG,RECON(W, Wc; Θ) = log Z(Z) −
X
vi∈V,vj∈V
s(W)ijWcij , (23.18)
where Wc = ZZT, and the partition function is given by Z(Z) = Q
i
P
j
exp(Wcij ) can be approximated
in O(N) time via hierarchical softmax (see Section 20.5.2). (It is also common to model Wc = ZoutZin
T
for directed graphs using embedding dictionaries Zout, Zin ∈ R
N×L.)
As noted by [LG14], Skip-gram methods can be viewed as implicit matrix factorization, and
the methods discussed here are related to those of Matrix Factorization (see Section 23.3.4). This
relationship is discussed in depth by [Qiu+18], who propose a general matrix factorization framework,
NetMF, which uses the same underlying graph proximity information as DeepWalk, LINE [Tan+15],
and node2vec [GL16]. Casting the node embedding problem as matrix factorization can inherit
benefits of efficient sparse matrix operations [Qiu+19b].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20223.3. Shallow graph embeddings 755
23.3.6 Supervised embeddings
In many applications, we have labeled data in addition to node features and graph structure. While
it is possible to tackle a supervised task by first learning unsupervised representations and then using
them as features in a secondary model, this is not the ideal workflow. Unsupervised node embeddings
might not preserve important properties of graphs (e.g., node neighborhoods or attributes), that are
most useful for a downstream supervised task.
In light of this limitation, a number of methods combining these two steps, namely learning
embeddings and predicting node or graph labels, have been proposed. Here, we focus on simple
shallow methods. We discuss deep, nonlinear embeddings later on.
23.3.6.1 Label propagation
Label propagation (LP) [ZG02] is a very popular algorithm for graph-based semi-supervised node
classification. The encoder is a shallow model represented by a lookup table Z. LP uses the label
space to represent the node embeddings directly (i.e. the decoder in LP is simply the identity
function):
yˆ
N = DEC(Z; ΘC ) = Z.
In particular, LP uses the graph structure to smooth the label distribution over the graph by
adding a regularization term to the loss function, using the underlying assumption is that neighbor
nodes should have similar labels (i.e. there exist some label consistency between connected nodes).
Laplacian eigenmaps are utilized in the regularization to enforce this smoothness:
LG,RECON(W,Wc; Θ) = X
i,j
Wij ||y
N
i − yˆ
N
j
||2
2
(23.19)
LP minimizes this energy function over the space of functions that take fixed values on labeled
nodes (i.e. yˆ
N
i = y
N
i ∀i|vi ∈ VL) using an iterative algorithm that updates an unlabeled node’s label
distribution via the weighted average of its neighbors’ labels.
Label spreading (LS) [Zho+04] is a variant of label propagation which minimizes the following
energy function:
LG,RECON(W,Wc; Θ) = X
i,j
Wij








yˆ
N
√
i
Di
−
yˆ
N
p
j
Dj








2
2
, (23.20)
where Di =
P
j Wij is the degree of node vi
.
In both methods, the supervised loss is simply the sum of distances between predicted labels and
ground truth labels (one-hot vectors):
L
N
SUP(y
N , yˆ
N ; Θ) = X
i|vi∈VL
||y
N
i − yˆ
N
i
||2
2
. (23.21)
Note that while the regularization term is computed over all nodes in the graph, the supervised loss is
computed over labeled nodes only. These methods are expected to work well with consistent graphs,
that is graphs where node proximity in the graph is positively correlated with label similarity.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license756 Chapter 23. Graph Embeddings *
23.4 Graph Neural Networks
An extensive area of research focuses on defining convolutions over graph data. In the notation of
Chami et al. [Cha+21], these (semi-)supervised neighborhood aggregation methods can be represented
by an encoder of the form Z = ENC(X,W; ΘE), and decoders of the form Wc = DEC(Z; ΘD) and/or
yb
S = DEC(Z; ΘS). There are many models in this family; we review some of them below.
23.4.1 Message passing GNNs
The original graph neural network (GNN) model of [GMS05; Sca+09] was the first formulation of
deep learning methods for graph-structured data. It views the supervised graph embedding problem
as an information diffusion mechanism, where nodes send information to their neighbors until some
stable equilibrium state is reached. More concretely, given randomly initialized node embeddings Z
0
,
it applies the following recursion:
Z
t+1 = ENC(X,W, Z
t
; ΘE), (23.22)
where parameters ΘE are reused at every iteration. After convergence (t = T), the node embeddings
Z
T are used to predict the final output such as node or graph labels:
yˆ
S = DEC(X, Z
T
; ΘS
). (23.23)
This process is repeated several times and the GNN parameters ΘE and ΘD are learned with
backpropagation via the Almeda-Pineda algorithm [Alm87; Pin88]. By Banach’s fixed point theorem,
this process is guaranteed to converge to a unique solution when the recursion provides a contraction
mapping. In light of this, Scarselli et al. [Sca+09] explore maps that can be expressed using message
passing networks:
Z
t+1
i =
X
j|(vi,vj )∈E
f(Xi
, Xj , Z
t
j
; ΘE), (23.24)
where f(·) is a multi-layer perception (MLP) constrained to be a contraction mapping. The decoder
function, however, has no constraints and can be any MLP.
Li et al. [Li+15] propose Gated Graph Sequence Neural Networks (GGSNNs), which remove
the contraction mapping requirement from GNNs. In GGSNNs, the recursive algorithm in Equation
23.22 is relaxed by applying mapping functions for a fixed number of steps, where each mapping
function is a gated recurrent unit [Cho+14a] with parameters shared for every iteration. The GGSNN
model outputs predictions at every step, and so is particularly useful for tasks which have sequential
structure (such as temporal graphs).
Gilmer et al. [Gil+17] provide a framework for graph neural networks called message passing
neural networks (MPNNs), which encapsulates many recent models. In contrast with the GNN
model which runs for an indefinite number of iterations, MPNNs provide an abstraction for modern
approaches, which consist of multi-layer neural networks with a fixed number of layers. At every
layer `, message functions f
`
(.) receive messages from neighbors (based on neighbor’s hidden state),
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202223.4. Graph Neural Networks 757
which are then passed to aggregation functions h
`
(.):
m`+1
i =
X
j|(vi,vj )∈E
f
`
(H`
i
, H`
j
) (23.25)
H`+1
i = h
`
(H`
i
, m`+1
i
), (23.26)
where H0 = X. After ` layers of message passing, nodes’ hidden representations encode information
within `-hop neighborhoods.
Battaglia et al. [Bat+18] propose GraphNet, which further extends the MPNN framework to
learn representations for edges, nodes and the entire graph using message passing functions. The
explicit addition of edge and graph representations adds additional expressivity to the MPNN model,
and allows the application of graph models to additional domains.
23.4.2 Spectral Graph Convolutions
Spectral methods define graph convolutions using the spectral domain of the graph Laplacian matrix.
These methods broadly fall into two categories: spectrum-based methods, which explicitly compute an
eigendecomposition of the Laplacian (e.g., spectral CNNs [Bru+14]) and spectrum-free methods,
which are motivated by spectral graph theory but do not actually perform a spectral decomposition
(e.g., Graph convolutional networks or GCN [KW16a]).
A major disadvantage of spectrum-based methods is that they rely on the spectrum of the graph
Laplacian and are therefore domain-dependent (i.e. cannot generalize to new graphs). Moreover,
computing the Laplacian’s spectral decomposition is computationally expensive. Spectrum-free
methods overcome these limitations by utilizing approximations of these spectral filters. However,
spectrum-free methods require using the whole graph W, and so do not scale well.
For more details on spectral approaches, see e.g., [Bro+17b; Cha+21].
23.4.3 Spatial Graph Convolutions
Spectrum-based methods have an inherent domain dependency which limits the application of a model
trained on one graph to a new dataset. Additionally, spectrum-free methods (e.g. GCNs) require
using the entire graph A, which can quickly become unfeasible as the size of the graph grows.
To overcome these limitations, another branch of graph convolutions (spatial methods) borrow
ideas from standard CNNs – applying convolutions in the spatial domain as defined by the graph
topology. For instance, in computer vision, convolutional filters are spatially localized by using fixed
rectangular patches around each pixel. Combined with the natural ordering of pixels in images (top,
left, bottom, right), it is possible to reuse filters’ weights at every location. This process significantly
reduces the total number of parameters needed for a model. While such spatial convolutions cannot
directly be applied in graph domains, spatial graph convolutions take inspiration from them. The core
idea is to use neighborhood sampling and attention mechanisms to create fixed-size graph patches,
overcoming the irregularity of graphs.
23.4.3.1 Sampling-based spatial methods
To overcome the domain dependency and storage limitations of GCNs, Hamilton, Ying, and Leskovec
[HYL17] propose GraphSAGE, a framework to learn inductive node embeddings. Instead of
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license758 Chapter 23. Graph Embeddings *
Figure 23.5: Illustration of the GraphSAGE model. Reprinted with permission from [HYL17].
averaging signals from all one-hop neighbors (via multiplications with the Laplacian matrix), SAGE
samples fixed neighborhoods (of size q) for each node. This removes the strong dependency on fixed
graph structure and allows generalization to new graphs. At every SAGE layer, nodes aggregate
information from nodes sampled from their neighborhood (see Figure 23.5). In the GraphEDM
notation, the propagation rule can be written as:
H`+1
:,i = σ(Θ`
1H`
:,i + Θ`
2AGG({H`
:,j | vj ∈ Sample(nbr(vi), q)})), (23.27)
where AGG(·) is an aggregation function. This aggregation function can be any permutation invariant
operator such as averaging (SAGE-mean) or max-pooling (SAGE-pool). As SAGE works with fixed
size neighborhoods (and not the entire adjacency matrix), it also reduces the computational complexity
of training GCNs.
23.4.3.2 Attention-based spatial methods
Attention mechanisms (Section 15.4) have been successfully used in language models where they, for
example, allow models to identify relevant parts of long sequence inputs. Inspired by their success
in language, similar ideas have been proposed for graph convolution networks. Such graph-based
attention models learn to focus their attention on important neighbors during the message passing
step via parametric patches which are learned on top of node features. This provides more flexibility
in inductive settings, compared to methods that rely on fixed weights such as GCNs.
The Graph attention network (GAT) model of [Vel+18] is an attention-based version of GCNs.
At every GAT layer, it attends over the neighborhood of each node and learns to selectively pick
nodes which lead to the best performance for some downstream task. The intuition behind this is
similar to SAGE [HYL17] and makes GAT suitable for inductive and transductive problems. However
unlike SAGE, which limits the convolution step to fixed size-neighborhoods, GAT allows each node
to attend over the entirety of its neighbors – assigning each of them different weights. The attention
parameters are trained through backpropagation, and the attention scores are then row-normalized
with a softmax activation.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202223.5. Deep graph embeddings 759
23.4.3.3 Geometric spatial methods
Monti et al. [Mon+17] propose MoNet, a general framework that works particularly well when the
node features lie in a geometric space, such as 3D point clouds or meshes. MoNet learns attention
patches using parametric functions in a pre-defined spatial domain (e.g. spatial coordinates), and
then applies convolution filters in the resulting graph domain.
MoNet generalizes spatial approaches which introduce constructions for convolutions on manifolds,
such as the Geodesic CNN (GCNN) [Mas+15] and the Anisotropic CNN (ACNN) [Bos+16]. Both
GCNN and ACNN use fixed patches that are defined on a specific coordinate system and therefore
cannot generalize to graph-structured data. However, the MoNet framework is more general; any
pseudo-coordinates (i.e. node features) can be used to induce the patches. More formally, if Us are
pseudo-coordinates and H`
are features from another domain, the MoNet layer can be expressed in
our notation as:
H`+1 = σ
X
K
k=1
(W  gk(Us
))H`Θ
`
k

, (23.28)
where gk(U
s
) are the learned parametric patches, which are N × N matrices. In practice, MoNet
uses Gaussian kernels to learn patches, such that:
gk(Us
) = exp
−
1
2
(Us − µk)
TΣ
−1
k
(Us − µk)

, (23.29)
where µk and Σk are learned parameters, and Σk is restricted to be diagonal.
23.4.4 Non-Euclidean Graph Convolutions
As we discussed in Section 23.3.3, hyperbolic geometry enables learning of shallow embeddings of
hierarchical graphs which have smaller distortion than Euclidean embeddings. However, one major
downside of shallow embeddings is that they do not generalize well (if at all) across graphs. On the
other hand, Graph Neural Networks, which leverage node features, have achieved good results on
many inductive graph embedding tasks.
It is natural then, that there has been recent interest in extending Graph Neural Networks to learn
non-Euclidean embeddings. One major challenge in doing so again revolves around the nature of
convolution itself. How should we perform convolutions in a non-Euclidean space, where standard
operations such as inner products and matrix multiplications are not defined?
Hyperbolic Graph Convolution Networks (HGCN) [Cha+19a] and Hyperbolic Graph Neural
Networks (HGNN) [LNK19] apply graph convolutions in hyperbolic space by leveraging the Euclidean
tangent space, which provides a first-order approximation of the hyperbolic manifold at a point.
For every graph convolution step, node embeddings are mapped to the Euclidean tangent space at
the origin, where convolutions are applied, and then mapped back to the hyperbolic space. These
approaches yield significant improvements on graphs that exhibit hierarchical structure (Figure 23.6).
23.5 Deep graph embeddings
In this section, we use graph neural networks to devise graph embeddings in the unsupervised and
semi-supervised cases.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license760 Chapter 23. Graph Embeddings *
(a) GCN layers. (b) HGCN layers.
Figure 23.6: Euclidean (left) and hyperbolic (right) embeddings of a tree graph. Hyperbolic embeddings
learn natural hierarchies in the embedding space (depth indicated by color). Reprinted with permission from
[Cha+19a].
Figure 23.7: Unsupervised graph neural networks. Graph structure and input features are mapped to low￾dimensional embeddings using a graph neural network encoder. Embeddings are then decoded to compute a
graph regularization loss (unsupervised). Reprinted with permission from [Cha+21].
23.5.1 Unsupervised embeddings
In this section, we discuss unsupervised losses for GNNs, as illustrated in Figure 23.7.
23.5.1.1 Structural deep network embedding
The structural deep network embedding (SDNE) method of [WCZ16] uses auto-encoders which
preserve first and second-order node proximity. The SDNE encoder takes a row of the adjacency
matrix as input (setting s(W) = W) and produces node embeddings Z = ENC(W; θ
E). (Note that
this ignores any node features.) The SDNE decoder returns Wc = DEC(Z; ΘD), a reconstruction
trained to recover the original graph adjacency matrix. SDNE preserves second order node proximity
by minimizing the following loss:
||(s(W) − Wc) · I(s(W) > 0)||2
F + αSDNEX
ij
s(W)ij ||Zi − Zj ||2
2
(23.30)
The first term is similar to the matrix factorization regularization objective, except that Wc is not
computed using outer products. The second term is the used by distance-based shallow embedding
methods.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202223.5. Deep graph embeddings 761
23.5.1.2 (Variational) graph auto-encoders
Kipf and Welling [KW16b] use graph convolutions (Section 23.4.2) to learn node embeddings Z =
GCN(W, X; ΘE). The decoder is an outer product: DEC(Z; ΘD) = ZZT. The graph reconstruction
term is the sigmoid cross entropy between the true adjacency and the predicted edge similarity scores:
LG,RECON(W,Wc; Θ) = −
X
i,j
(1 − Wij )log(1 − σ(Wcij )) + Wij logσ(Wcij )

. (23.31)
Computing the regularization term over all possible nodes pairs is computationally challenging
in practice, so the Graph Auto Encoders (GAE) model uses negative sampling to overcome this
challenge.
Whereas GAE is a deterministic model, the authors also introduce variational graph auto-encoders
(VGAE), which relies on variational auto-encoders (as in Section 20.3.5) to encode and decode
the graph structure. In VGAE, the embedding Z is modeled as a latent variable with a standard
multivariate normal prior p(Z) = N (Z|0, I) and a graph convolution is used as the amortized inference
network, qΦ(Z|W, X). The model is trained by minimizing the corresponding negative evidence
lower bound:
NELBO(W, X; Θ) = −EqΦ(Z|W,X)
[log p(W|Z)] + KL(qΦ(Z|W, X)||p(Z)) (23.32)
= LG,RECON(W,Wc; Θ) + KL(qΦ(Z|W, X)||p(Z)). (23.33)
23.5.1.3 Iterative generative modelling of graphs (Graphite)
The graphite model of [GZE19] extends GAE and VGAE by introducing a more complex decoder.
This decoder iterates between pairwise decoding functions and graph convolutions, as follows:
Wc(k) =
Z
(k)Z
(k)
T
||Z(k)
||2
2
+
11T
N
Z
(k+1) = GCN(Wc(k)
, Z
(k)
)
where Z
(0) is initialized using the output of the encoder network. This process allows Graphite to
learn more expressive decoders. Finally, similar to GAE, Graphite can be deterministic or variational.
23.5.1.4 Methods based on contrastive losses
The deep graph infomax method of [Vel+19] is a GAN-like method for creating graph-level
embeddings. Given one or more real (positive) graphs, each with its adjacency matrix W ∈ R
N×N
and node features X ∈ R
N×D, this method creates fake (negative) adjacency matrices W− ∈ R
N−×N−
and their features X− ∈ R
N−×D. It trains (i) an encoder that processes both real and fake samples,
respectively giving Z = ENC(X,W; ΘE) ∈ R
N×L and Z
− = ENC(X−,W−; ΘE) ∈ R
N−×L, (ii) a
(readout) graph pooling function R : R
N×L → R
L, and (iii) a descriminator function D : R
L × R
L →
[0, 1] which is trained to output D(Zi
, R(Z)) ≈ 1 and D(Z
−
j
, R(Z
−)) ≈ 0, respectively, for nodes
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license762 Chapter 23. Graph Embeddings *
corresponding to given graph i ∈ V and fake graph j ∈ V
−. Specifically, DGI optimizes:
min
Θ
− E
X,W
X
N
i=1
log D(Zi
, R(Z)) − E
X−,W−
X
N−
j=1
log ￾
1 − D(Z
−
j
, R(Z
−))
, (23.34)
where Θ contains ΘE and the parameters of R, D. In the first expectation, DGI samples from
the real (positive) graphs. If only one graph is given, it could sample some subgraphs from it
(e.g. connected components). The second expectation samples fake (negative) graphs. In DGI, fake
samples use the real adjacency W− := W but fake features X− are a row-wise random permutation of
real X. The ENC used in DGI is a graph convolutional network, though any GNN can be used. The
readout R summarizes an entire (variable-size) graph to a single (fixed-dimension) vector. Veličković
et al. [Vel+19] use R as a row-wise mean, though other graph pooling might be used e.g. ones aware
of the adjacency.
The optimization of Equation (23.34) is shown by [Vel+19] to maximize a lower-bound on the
mutual information between the outputs of the encoder and the graph pooling function, i.e., between
individual node representations and the graph representation.
In [Pen+20] they present a variant called Graphical Mutual Information. Rather than
maximizing MI of node information and an entire graph, GMI maximizes the MI between the
representation of a node and its neighbors.
23.5.2 Semi-supervised embeddings
In this section, we discuss semi-supervised losses for GNNs. We consider the simple special case in
which we use a nonlinear encoder of the node features, but ignore the graph structure, i.e., we use
Z = ENC(X; ΘE).
23.5.2.1 SemiEmb
[WRC08] propose an approach called semi-supervised embeddings (SemiEmb) They use an
MLP for the encoder of X. For the decoder, we can use a distance-based graph decoder: Wcij =
DEC(Z; ΘD)ij = ||Zi − Zj ||2
, where || · || can be the L2 or L1 norm.
SemiEmb regularizes intermediate or auxiliary layers in the network using the same regularizer
as the label propagation loss in Equation (23.19). SemiEmb uses a feed forward network to predict
labels from intermediate embeddings, which are then compared to ground truth labels using the
Hinge loss.
23.5.2.2 Planetoid
Unsupervised skip-gram methods like DeepWalk and node2vec learn embeddings in a multi-step
pipeline, where random walks are first generated from the graph and then used to learn embeddings.
These embeddings are likely not optimal for downstream classification tasks. The Planetoid method
of [YCS16] extends such random walk methods to leverage node label information during the
embedding algorithm.
Planetoid first maps nodes to embeddings Z = [Z
c
||Z
F ] = ENC(X; ΘE) using a neural network
(again ignoring graph structure). The node embeddings Z
c
capture structural information while the
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 20223.6. Applications 763
node embeddings Z
F capture feature information. There are two variants, a transductive version
that directly learns Z
c
(as an embedding lookup), and an inductive model where Z
c
is computed
with parametric mappings that act on input features X. The Planetoid objective contains both a
supervised loss and a graph regularization loss. The graph regularization loss measures the ability to
predict context using nodes embeddings:
LG,RECON(W,Wc; Θ) = −E(i,j,γ)
log σ

γWcij
, (23.35)
with Wcij = Z
T
i Zj and γ ∈ {−1, 1} with γ = 1 if (vi
, vj ) ∈ E is a positive pair and γ = −1 if (vi
, vj )
is a negative pair. The distribution under the expectation is directly defined through a sampling
process
The supervised loss in Planetoid is the negative log-likelihood of predicting the correct labels:
L
N
SUP(y
N , yb
N ; Θ) = −
1
|VL|
X
i|vi∈VL
X
1≤k≤C
y
N
iklog yb
N
ik, (23.36)
where i is a node’s index while k indicates label classes, and yb
N
i
are computed using a neural network
followed by a softmax activation, mapping Zi to predicted labels.
23.6 Applications
There are many applications of graph embeddings, both unsupervised and supervised. We give some
examples in the sections below.
23.6.1 Unsupervised applications
In this section, we discuss common unsupervised applications.
23.6.1.1 Graph reconstruction
A popular unsupervised graph application is graph reconstruction. In this setting, the goal is to
learn mapping functions (which can be parametric or not) that map nodes onto a manifold which
can reconstruct the graph. This is regarded as unsupervised in the sense that there is no supervision
beyond the graph structure. Models can be trained by minimizing a reconstruction error, which is
the error in recovering the original graph from learned embeddings. Several algorithms were designed
specifically for this task, and we refer to Section 23.3.1 and Section 23.5.1 for some examples of
reconstruction objectives. At a high level, graph reconstruction is similar to dimensionality reduction
in the sense that the main goal is summarize some input data into a low-dimensional embedding.
Instead of compressing high dimensional vectors into low-dimensional ones as standard dimensionality
reduction methods (e.g. PCA) do, the goal of graph reconstruction models is to compress data
defined on graphs into low-dimensional vectors.
23.6.1.2 Link prediction
The goal in link prediction is to predict missing or unobserved links (e.g., links that may appear
in the future for dynamic and temporal networks). Link prediction can also help identify spurious
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license764 Chapter 23. Graph Embeddings *
number: 10039 number: 2090
transaction
amount: $9900.00
transaction
amount: $9999.50
name:
Camille
name:
Oracle
transaction
amount: $1000.00
name:
Nikita
transaction
amount: $1500.30
transaction
amount: $3000.70
number: 8021 number: 1001
name:
Liam
Work for
Owner of
Owner of
Owner of
Owner of
Account Account
Company
Person
Person Account Account
Person
Figure 23.8: A graph representation of some financial transactions. Adapted from http: // pgql-lang. org/
spec/ 1. 2/ .
links and remove them. It is a major application of graph learning models in industry, and common
example of applications include predicting friendships in social networks predicting user-product
interactions in recommendation systems, predicting suspicious links in a fraud detection
system (see Figure 23.8), or predicting missing relationships between entities in a knowledge
graph (see e.g., [Nic+15]).
A common approach for training link prediction models is to mask some edges in the graph
(positive and negative edges), train a model with the remaining edges and then test it on the masked
set of edges. Note that link prediction is different from graph reconstruction. In link prediction, we
aim at predicting links that are not observed in the original graph while in graph reconstruction, we
only want to compute embeddings that preserve the graph structure through reconstruction error
minimization.
Finally, while link prediction has similarities with supervised tasks in the sense that we have labels
for edges (positive, negative, unobserved), we group it under the unsupervised class of applications
since edge labels are usually not used during training, but only used to measure the predictive quality
of embeddings.
23.6.1.3 Clustering
Clustering is particularly useful for discovering communities and has many real-world applications.
For instance, clusters exist in biological networks (e.g. as groups of proteins with similar properties),
or in social networks (e.g. as groups of people with similar interests).
The unsupervised methods introduced in this chapter can be used to solve clustering problems
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202223.6. Applications 765
by applying the clustering algorithm (e.g. k-means) to embeddings that are output by an encoder.
Further, clustering can be joined with the learning algorithm while learning a shallow [Roz+19] or
Graph Convolution [Chi+19a; CEL19] embedding model.
23.6.1.4 Visualization
There are many off-the-shelf tools for mapping graph nodes onto two-dimensional manifolds for the
purpose of visualization. Visualizations allow network scientists to qualitatively understand graph
properties, understand relationships between nodes or visualize node clusters. Among the popular
tools are methods based on Force-Directed Layouts, with various web-app Javascript implementations.
Unsupervised graph embedding methods are also used for visualization purposes: by first training
an encoder-decoder model (corresponding to a shallow embedding or graph convolution network), and
then mapping every node representation onto a two-dimensional space using t-SNE (Section 20.4.10)
or PCA (Section 20.1). Such a process (embedding → dimensionality reduction) is commonly used to
qualitatively evaluate the performance of graph learning algorithms. If nodes have attributes, one can
use these attributes to color the nodes on 2D visualization plots. Good embedding algorithms embed
nodes that have similar attributes nearby in the embedding space, as demonstrated in visualizations
of various methods [PARS14; KW16a; AEH+18]. Finally, beyond mapping every node to a 2D
coordinate, methods which map every graph to a representation [ARZP19] can similarly be projected
into two dimensions to visualize and qualitatively analyze graph-level properties.
23.6.2 Supervised applications
In this section, we discuss common supervised applications.
23.6.2.1 Node classification
Node classification is an important supervised graph application, where the goal is to learn node
representations that can accurately predict node labels. (This is sometimes called statistical
relational learning [GT07].) For instance, node labels could be scientific topics in citation networks,
or gender and other attributes in social networks.
Since labeling large graphs can be time-consuming and expensive, semi-supervised node classification
is a particularly common application. In semi-supervised settings, only a fraction of nodes are labeled
and the goal is to leverage links between nodes to predict attributes of unlabeled nodes. This setting
is transductive since there is only one partially labeled fixed graph. It is also possible to do inductive
node classification, which corresponds to the task of classifying nodes in multiple graphs.
Note that node features can significantly boost the performance on node classification tasks if
these are descriptive for the target label. Indeed, recent methods such as GCN (Section 23.4.2)
GraphSAGE (Section 23.4.3.1) have achieved state-of-the-art performance on multiple node classifi￾cation benchmarks due to their ability to combine structural information and semantics coming from
features. On the other hand, other methods such as random walks on graphs fail to leverage feature
information and therefore achieve lower performance on these tasks.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license766 Chapter 23. Graph Embeddings *
Figure 23.9: Structurally similar molecules do not necessarily have similar odor descriptors. (A) Lyral, the
reference molecule. (B) Molecules with similar structure can share similar odor descriptors. (C) However, a
small structural change can render the molecule odorless. (D) Further, large structural changes can leave the
odor of the molecule largely unchanged. From Figure 1 of [SL+19], originally from [OPK12]. Used with kind
permission of Benjamin Sanchez-Lengeling.
23.6.2.2 Graph classification
Graph classification is a supervised application where the goal is to predict graph labels. Graph
classification problems are inductive and a common example is classifying chemical compounds (e.g.
predicting toxicity or odor from a molecule, as shown in Figure 23.9).
Graph classification requires some notion of pooling, in order to aggregate node-level information
into graph-level information. As discussed earlier, generalizing this notion of pooling to arbitrary
graphs is non trivial because of the lack of regularity in the graph structure making graph pooling an
active research area. In addition to the supervised methods discussed above, a number of unsupervised
methods for learning graph-level representations have been proposed [Tsi+18; ARZP19; TMP20].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022A Notation
A.1 Introduction
It is very difficult to come up with a single, consistent notation to cover the wide variety of data,
models and algorithms that we discuss in this book. Furthermore, conventions differ between different
fields (such as machine learning, statistics and optimization), and between different books and papers
within the same field. Nevertheless, we have tried to be as consistent as possible. Below we summarize
most of the notation used in this book, although individual sections may introduce new notation.
Note also that the same symbol may have different meanings depending on the context, although we
try to avoid this where possible.
A.2 Common mathematical symbols
We list some common symbols below.
Symbol Meaning
∞ Infinity
→ Tends towards, e.g., n → ∞
∝ Proportional to, so y = ax can be written as y ∝ x
, Defined as
O(·) Big-O: roughly means order of magnitude
Z+ The positive integers
R The real numbers
R+ The positive reals
SK The K-dimensional probability simplex
S
D
++ Cone of positive definite D × D matrices
≈ Approximately equal to
{1, . . . , N} The finite set {1, 2, . . . , N}
1 : N The finite set {1, 2, . . . , N}
[`, u] The continuous interval {` ≤ x ≤ u}.768 Appendix A. Notation
A.3 Functions
Generic functions will be denoted by f (and sometimes g or h). We will encounter many named
functions, such as tanh(x) or σ(x). A scalar function applied to a vector is assumed to be applied ele￾mentwise, e.g., x
2 = [x
2
1
, . . . , x2
D]. Functionals (functions of a function) are written using “blackboard”
font, e.g., H(p) for the entropy of a distribution p. A function parameterized by fixed parameters
θ will be denoted by f(x; θ) or sometimes fθ(x). We list some common functions (with no free
parameters) below.
A.3.1 Common functions of one argument
Symbol Meaning
bxc Floor of x, i.e., round down to nearest integer
dxe Ceiling of x, i.e., round up to nearest integer
¬a logical NOT
I(x) Indicator function, I(x) = 1 if x is true, else I(x) = 0
δ(x) Dirac delta function, δ(x) = ∞ if x = 0, else δ(x) = 0
|x| Absolute value
|S| Size (cardinality) of a set
n! Factorial function
log(x) Natural logarithm of x
exp(x) Exponential function e
x
Γ(x) Gamma function, Γ(x) = R ∞
0
u
x−1
e
−udu
Ψ(x) Digamma function, Ψ(x) = d
dx log Γ(x)
σ(x) Sigmoid (logistic) function, 1
1+e−x
A.3.2 Common functions of two arguments
Symbol Meaning
a ∧ b logical AND
a ∨ b logical OR
B(a, b) Beta function, B(a, b) = Γ(a)Γ(b)
￾
Γ(a+b)
n
k

n choose k, equal to n!/(k!(n − k)!)
δij Kronecker delta, equals I(i = j)
u  v Elementwise product of two vectors
u ~ v Convolution of two vectors
A.3.3 Common functions of > 2 arguments
Symbol Meaning
B(x) Multivariate beta function,
Q
k Γ(xk)
Γ(P
k xk)
Γ(x) Multi. gamma function, π
D(D−1)/4 QD
d=1 Γ (x + (1 − d)/2)
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 202A.4. Linear algebra 769
S(x) Softmax function, [
e
xc PC
c0=1 e
xc0
]
C
c=1
A.4 Linear algebra
In this section, we summarize the notation we use for linear algebra (see Chapter 7 for details).
A.4.1 General notation
Vectors are bold lower case letters such as x, w. Matrices are bold upper case letters, such as X,
W. Scalars are non-bold lower case. When creating a vector from a list of N scalars, we write
x = [x1, . . . , xN ]; this may be a column vector or a row vector, depending on the context. (Vectors
are assumed to be column vectors, unless noted otherwise.) When creating an M × N matrix from a
list of vectors, we write X = [x1, . . . , xN ] if we stack along the columns, or X = [x1; . . . ; xM] if we
stack along the rows.
A.4.2 Vectors
Here is some standard notation for vectors. (We assume u and v are both N-dimensional vectors.)
Symbol Meaning
u
Tv Inner (scalar) product, PN
i=1 uivi
uvT Outer product (N × N matrix)
u  v Elementwise product, [u1v1, . . . , uN vN ]
v
T Transpose of v
dim(v) Dimensionality of v (namely N)
diag(v) Diagonal N × N matrix made from vector v
1 or 1N Vector of ones (of length N)
0 or 0N Vector of zeros (of length N)
||v|| = ||v||2 Euclidean or `2 norm qPN
i=1 v
2
i
||v||1 `1 norm PN
i=1 |vi
|
A.4.3 Matrices
Here is some standard notation for matrices. (We assume S is a square N × N matrix, X and Y are
of size M × N, and Z is of size M0 × N0
.)
Symbol Meaning
X:,j j’th column of matrix
Xi,: i’th row of matrix (treated as a column vector)
Xij Element (i, j) of matrix
S  0 True iff S is a positive definite matrix
tr(S) Trace of a square matrix
det(S) Determinant of a square matrix
|S| Determinant of a square matrix
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license770 Appendix A. Notation
S
−1
Inverse of a square matrix
X† Pseudo-inverse of a matrix
XT Transpose of a matrix
diag(S) Diagonal vector extracted from square matrix
I or IN Identity matrix of size N × N
X  Y Elementwise product
X ⊗ Z Kronecker product (see Section 7.2.5)
A.4.4 Matrix calculus
In this section, we summarize the notation we use for matrix calculus (see Section 7.8 for details).
Let θ ∈ R
N be a vector and f : R
N → R be a scalar valued function. The derivative of f wrt its
argument is denoted by the following:
∇θf(θ) , ∇f(θ) , ∇f ,

∂f
∂θ1
· · ·
∂f
∂θN

(A.1)
The gradient is a vector that must be evaluated at a point in space. To emphasize this, we will
sometimes write
gt , g(θt) , ∇f(θ)




θt
(A.2)
We can also compute the (symmetric) N × N matrix of second partial derivatives, known as the
Hessian:
∇2
f ,


∂
2
f
∂θ2
1
· · ·
∂
2
f
∂θ1∂θN
.
.
.
∂
2
f
∂θN θ1
· · ·
∂
2
f
∂θ2
N


(A.3)
The Hessian is a matrix that must be evaluated at a point in space. To emphasize this, we will
sometimes write
Ht , H(θt) , ∇2
f(θ)




θt
(A.4)
A.5 Optimization
In this section, we summarize the notation we use for optimization (see Chapter 8 for details).
We will often write an objective or cost function that we wish to minimize as L(θ), where θ are
the variables to be optimized (often thought of as parameters of a statistical model). We denote
the parameter value that achieves the minimum as θ∗ = argminθ∈Θ L(θ), where Θ is the set we are
optimizing over. (Note that there may be more than one such optimal value, so we should really
write θ∗ ∈ argminθ∈Θ L(θ).)
When performing iterative optimization, we use t to index the iteration number. We use η as a
step size (learning rate) parameter. Thus we can write the gradient descent algorithm (explained in
Section 8.4) as follows: θt+1 = θt − ηtgt.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022A.6. Probability 771
We often use a hat symbol to denote an estimate or prediction (e.g., θˆ, yˆ), a star subscript or
superscript to denote a true (but usually unknown) value (e.g., θ∗ or θ
∗
), an overline to denote a
mean value (e.g., θ).
A.6 Probability
In this section, we summarize the notation we use for probability theory (see Chapter 2 for details).
We denote a probability density function (pdf) or probability mass function (pmf) by p, a cumulative
distribution function (cdf) by P, and the probability of a binary event by Pr. We write p(X) for the
distribution for random variable X, and p(Y ) for the distribution for random variable Y — these
refer to different distributions, even though we use the same p symbol in both cases. (In cases where
confusion may arise, we write pX(·) and pY (·).) Approximations to a distribution p will often be
represented by q, or sometimes pˆ.
In some cases, we distinguish between a random variable (rv) and the values it can take on. In this
case, we denote the variable in upper case (e.g., X), and its value in lower case (e.g., x). However,
we often ignore this distinction between variables and values. For example, we sometimes write p(x)
to denote either the scalar value (the distribution evaluated at a point) or the distribution itself,
depending on whether X is observed or not.
We write X ∼ p to denote that X is distributed according to distribution p. We write X ⊥ Y | Z
to denote that X is conditionally independent of Y given Z. If X ∼ p, we denote the expected value
of f(X) using
E [f(X)] = Ep(X)
[f(X)] = EX [f(X)] = Z
x
f(x)p(x)dx (A.5)
If f is the identity function, we write X , E [X]. Similarly, the variance is denoted by
V [f(X)] = Vp(X)
[f(X)] = VX [f(X)] = Z
x
(f(x) − E [f(X)])2
p(x)dx (A.6)
If x is a random vector, the covariance matrix is denoted
Cov [x] = E

(x − x)(x − x)
T

(A.7)
If X ∼ p, the mode of a distribution is denoted by
xˆ = mode [p] = argmax
x
p(x) (A.8)
We denote parametric distributions using p(x|θ), where x are the random variables, θ are the
parameters and p is a pdf or pmf. For example, N (x|µ, σ2
) is a Gaussian (normal) distribution with
mean µ and standard deviation σ.
A.7 Information theory
In this section, we summarize the notation we use for information theory (see Chapter 6 for details).
If X ∼ p, we denote the (differential) entropy of the distribution by H (X) or H (p). If Y ∼ q,
we denote the KL divergence from distribution p to q by DKL (pkq). If (X, Y ) ∼ p, we denote the
mutual information between X and Y by I(X; Y ).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license772 Appendix A. Notation
A.8 Statistics and machine learning
We briefly summarize the notation we use for statistical learning.
A.8.1 Supervised learning
For supervised learning, we denote the observed features (also called inputs or covariates) by
x ∈ X . Often X = R
D, meaning the features are real-valued. (Note that this includes the case
of discrete-valued inputs, which can be represented as one-hot vectors.) Sometimes we compute
manually-specified features of the input; we denote these by φ(x). We also have outputs (also called
targets or response variables) y ∈ Y that we wish to predict. Our task is to learn a conditional
probability distribution p(y|x, θ), where θ are the parameters of the model. If Y = {1, . . . , C}, we
call this classification. If Y = R
C , we call this regression (often C = 1, so we are just predicting
a scalar response).
The parameters θ are estimated from training data, denoted by D = {(xn, yn) : n ∈ {1, . . . , N}}
(so N is the number of training cases). If X = R
D, we can store the training inputs in an N × D
design matrix denoted by X. If Y = R
C , we can store the training outputs in an N × C matrix Y.
If Y = {1, . . . , C}, we can represent each class label as a C-dimensional bit vector, with one element
turned on (this is known as a one-hot encoding), so we can store the training outputs in an N × C
binary matrix Y.
A.8.2 Unsupervised learning and generative models
Unsupervised learning is usually formalized as the task of unconditional density estimation, namely
modeling p(x|θ). In some cases, we want to perform conditional density estimation; we denote the
values we are conditioning on by u, so the model becomes p(x|u, θ). This is similar to supervised
learning, except that x is usually high dimensional (e.g., an image) and u is usually low dimensional
(e.g., a class label or a text description).
In some models, we have latent variables, also called hidden variables, which are never observed
in the training data. We call such models latent variable models (LVM). We denote the latent
variables for data case n by zn ∈ Z. Sometimes latent variables are known as hidden variables,
and are denoted by hn. By contrast, the visible variables will be denoted by vn. Typically the
latent variables are continuous or discrete, i.e., Z = R
L or Z = {1, . . . , K}.
Most LVMs have the form p(xn, zn|θ); such models can be used for unsupervised learning. However,
LVMs can also be used for supervised learning. In particular, we can either create a generative
(unconditional) model of the form p(xn, yn, zn|θ), or a discriminative (conditional) model of the
form p(yn, zn|xn, θ).
A.8.3 Bayesian inference
When working with Bayesian inference, we write the prior over the parameters as p(θ|φ), where φ
are the hyperparameters. For conjugate models, the posterior has the same form as the prior (by
definition). We can therefore just update the hyperparameters from their prior value, `
φ, to their
posterior value, a
φ.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022A.9. Abbreviations 773
In variational inference (Section 4.6.8.3), we use ψ to represent the parameters of the variational
posterior, i.e., p(θ|D) ≈ q(θ|ψ). We optimize the ELBO wrt ψ to make this a good approximation.
When performing Monte Carlo sampling, we use a s subscript or superscript to denote a sample
(e.g., θs or θ
s
).
A.9 Abbreviations
Here are some of the abbreviations used in the book.
Abbreviation Meaning
cdf Cumulative distribution function
CNN Convolutional neural network
DAG Directed acyclic graph
DML Deep metric learning
DNN Deep neural network
d.o.f. Degrees of freedom
EB Empirical Bayes
EM Expectation maximization algorithm
GLM Generalized linear model
GMM Gaussian mixture model
HMC Hamiltonian Monte Carlo
HMM Hidden Markov model
i.i.d. Independent and identically distributed
iff If and only if
KDE Kernel density estimation
KL Kullback Leibler divergence
KNN K nearest neighbor
LHS Left hand side (of an equation)
LSTM Long short term memory (a kind of RNN)
LVM Latent variable model
MAP Maximum A Posterior estimate
MCMC Markov chain Monte Carlo
MLE Maximum likelihood estimate
MLP Multilayer perceptron
MSE Mean squared error
NLL Negative log likelihood
OLS Ordinary least squares
psd Positive definite (matrix)
pdf Probability density function
pmf Probability mass function
PNLL Penalized NLL
PGM Probabilistic graphical model
RNN Recurrent neural network
RHS Right hand side (of an equation)
RSS Residual sum of squares
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license774 Appendix A. Notation
rv Random variable
RVM Relevance vector machine
SGD Stochastic gradient descent
SSE Sum of squared errors
SVI Stochastic variational inference
SVM Support vector machine
VB Variational Bayes
w.r.t. With respect to
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022Index
à trous algorithm, 480
AMSGrad, 295
AdaDelta, 294
AdaGrad, 293
Adam, 294
Padam, 295
RMSProp, 293
RPROP, 293
Yogi, 295
1x1 convolution, 468
abstractive summarization, 536
action potential, 430
actions, 163
activation function, 422
activation maximization, 489
active, 299
active learning, 401, 644
active set, 393
activity regularization, 677
Adaboost.M1, 609
AdaBoostClassifier, 609
Adam, 440
Adamic/Adar, 752
adapters, 625
adaptive basis functions, 605
adaptive instance normalization, 495
adaptive learning rate, 293, 295
add-one smoothing, 118, 128, 329
additive attention, 515
additive model, 605
adjoint, 439
adjusted Rand index, 711
admissible, 187
affine function, 8, 8
agent, 17, 163
aggregated gradient, 292
AI, 27
AI ethics, 28
AI safety, 28
Akaike information criterion, 181
aleatoric uncertainty, 7, 32
AlexNet, 475
alignment, 516
alignment problem, 28
all pairs, 587
all-reduce, 448
ALS, 737
alternating least squares, 737
alternative hypothesis, 175, 193
ambient dimensionality, 684
amortized inference, 678
anchor, 549
anchor boxes, 483
ANN, 429
Anscombe’s quartet, 41, 41
approximate posterior inference, 147
approximation error, 189
ARD, 405, 564, 592
ARD kernel, 564
area under the curve, 169
Armijo backtracking method, 280
Armijo-Goldstein, 280
artificial general intelligence, 28
artificial intelligence, 27
artificial neural networks, 429
associative, 236
asymptotic normality, 151
asynchronous training, 448
atomic bomb, 71
attention, 516
attention kernel, 648
attention mechanisms, 512
attention score, 513
attention weight, 513
AUC, 169
augmented intelligence, 28
auto-covariance matrix, 77
Auto-ML, 479
AutoAugment, 621
autocorrelation matrix, 77
autodiff, 432
autoencoder, 674
automatic differentiation, 432
automatic relevancy determination, 405, 564, 592
AutoRec, 739
autoregressive model, 99
average link clustering, 714
average pooling, 469
average precision, 171
axis aligned, 80
axis parallel splits, 597
axon, 430
B-splines, 393
backbone, 426
775776 INDEX
backfitting, 396
backpropagation, 422
backpropagation algorithm, 432
backpropagation through time, 504
backslash operator, 261
backsubstitution, 261, 369
bag, 649
bag of word embeddings, 26
bag of words, 24, 425
bagging, 603
BALD, 645
balloon kernel density estimator, 557
band-diagonal matrix, 233
bandwidth, 453, 554, 562
Barnes-Hut algorithm, 698
barycentric coordinates, 691
base measure, 90
basis, 227
basis function expansion, 419
basis vectors, 237
batch learning, 115
batch normalization, 471, 472
batch renormalization, 472
BatchBALD, 645
Bayes error, 123, 541
Bayes estimator, 164, 186
Bayes factor, 175, 193
Bayes model averaging, 125
Bayes risk, 186
Bayes’ rule, 43, 43
Bayes’ rule for Gaussians, 85
Bayes’s rule, 43
Bayesian, 31
Bayesian χ
2
-test, 183
Bayesian active learning by disagreement, 645
Bayesian decision theory, 163
Bayesian deep learning, 451
Bayesian factor regression, 670
Bayesian inference, 43, 44
Bayesian information criterion, 181
Bayesian machine learning, 143
Bayesian model selection, 181
Bayesian network, 97
Bayesian neural network, 451
Bayesian Occam’s razor, 179
Bayesian optimization, 644
Bayesian personalized ranking, 741
Bayesian statistics, 125, 150
Bayesian t-test, 183
BBO, 313
Beam search, 509
belief state, 44
Berkson’s paradox, 99
Bernoulli distribution, 47
Bernoulli mixture model, 95
BERT, 532
Bessel function, 564
beta distribution, 61, 117, 127
beta function, 61
beta-binomial, 131
BFGS, 284
bi-tempered logistic regression, 356
bias, 8, 155, 365
bias-variance tradeoff, 157
BIC, 181
BIC loss, 181
BIC score, 181, 722
biclustering, 731
bidirectional RNN, 501
big data, 3
bigram model, 99, 206
bijector, 65
bilevel optimization, 190
binary classification, 2, 44
binary connect, 305
binary cross entropy, 336
binary entropy function, 202
binary logistic regression, 333
binomial coefficient, 48
binomial distribution, 48, 48
binomial regression, 410
BinomialBoost, 612
BIO, 534
BiT, 526
bits, 201
bivariate Gaussian, 80
black swan paradox, 118
blackbox, 313
blackbox optimization, 313
block diagonal, 233
block structured matrices, 244
Blue Brain Project, 431
BMA, 125
BMM, 95
BN, 471
BNN, 451
Boltzmann distribution, 53
BookCrossing, 736
Boolean logic, 32
Boosting, 605
bootstrap, 152
bottleneck, 674
bound optimization, 306, 347
bounding boxes, 483
bowl shape, 338
box constraints, 302
box plots, 43
boxcar kernel, 554, 556
branching factor, 206
Brier score, 175, 639
Brownian motion, 565
byte-pair encoding, 26
C-way N-shot classification, 647
C4, 536
C4.5, 599
calculus, 263
calculus of variations, 93
calibration plot, 414
canonical correlation analysis, 673
canonical form, 91
canonical link function, 411
canonical parameters, 90
CART, 597, 599
Cartesian, 66
Caser, 744
CatBoost, 613
categorical, 51
categorical PCA, 670
CatPCA, 670
Cauchy, 60
causal, 78
causal CNN, 511
causal convolution, 512
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022INDEX 777
CBOW, 701, 702, 702
CCA, 673
cdf, 35, 55
center, 402
centering matrix, 109, 241, 690
central interval, 142
central limit theorem, 58, 70
centroids, 453
chain rule for entropy, 205
chain rule for mutual information, 213
chain rule of calculus, 267
chain rule of probability, 37
change of variables, 65
channels, 461, 467
characteristic equation, 248
characteristic length scale, 564
characteristic matrix, 216
Chi-squared distribution, 63
Cholesky decomposition, 376
Cholesky factorization, 260
CIFAR, 20
city block distance, 712
class conditional density, 317
class confusion matrix, 168
class imbalance, 169, 352, 587
class-balanced sampling, 353
classes, 2
classical MDS, 686
classical statistics, 150
classification, 2, 772
Classification and regression trees, 597
CLIP, 629
closed world assumption, 544
cloze, 532
cloze task, 626
cluster assumption, 634
Clustering, 709
clustering, 95
clusters, 14
CNN, 3, 420, 461
co-adaptation, 450
Co-training, 636
coclustering, 731
codebook, 718
coefficient of determination, 375
CoLA, 537
cold start, 744
collaborative filtering, 731, 736
column rank, 231
column space, 227
column vector, 223
column-major order, 225
committee method, 602
commutative, 236
compactness, 714
complementary log-log, 412
complementary slackness, 298
complete link clustering, 714
complexity penalty, 117
composite objective, 276
compositional, 429
compound hypothesis, 194
computation graph, 438
computer graphics, 487
concave, 272
condition number, 119, 232, 280
conditional computation, 455
conditional distribution, 36
conditional entropy, 204
conditional instance normalization, 494
conditional mixture model, 455
conditional mutual information, 213
conditional probability, 33
conditional probability distribution, 7, 48, 98
conditional probability table, 98
conditional variance formula, 40
conditionally independent, 33, 33, 37, 96
confidence interval, 142, 153, 154
confirmation bias, 633
conformer, 527
conjugate function, 273
conjugate gradient, 280, 369
conjugate prior, 85, 125, 126, 127
consensus sequence, 203
conservation of probability mass, 179
Consistency regularization, 638
consistent estimator, 187, 400
constrained optimization, 271
constrained optimization problem, 295
constrained optimization problems, 397
constraints, 271
contextual word embeddings, 26, 531, 705
contingency table, 184
continual learning, 545
continuation method, 392
continuous optimization, 269
continuous random variable, 34
contraction, 676
contractive autoencoder, 676
contradicts, 518
contrastive loss, 549
contrastive tasks, 627
control variate, 291
convex, 338
convex combination, 129
convex function, 272
convex optimization, 271
convex relaxation, 380
convex set, 272
convolution, 68, 462
convolution theorem, 68
convolution with holes, 480
convolutional Markov model, 511
convolutional neural network, 3, 21
convolutional neural networks, 12, 420, 461
coordinate descent, 391
coordinate vectors, 227
coreference resolution, 521
coreset, 553
corpus, 699
correlation coefficient, 76, 80
correlation does not imply causation, 77
correlation matrix, 76, 110
cosine kernel, 565
cosine similarity, 700
cost function, 269
covariance, 75
covariance matrix, 75, 79
covariates, 2, 365, 772
COVID-19, 44
CPD, 98
CPT, 98
credible interval, 139, 142, 142, 154
critical point, 297
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license778 INDEX
cross correlation, 463
cross entropy, 203, 208, 210
cross validation, 121, 191
cross-covariance, 75
cross-entropy, 174
cross-over rate, 169
cross-validated risk, 122, 191
crosscat, 733
crowding problem, 697
cubic splines, 393
cumulants, 92
cumulative distribution function, 35, 55
curse of dimensionality, 542
curve fitting, 14
curved exponential family, 91
CV, 121, 191
cyclic permutation property, 230
cyclical learning rate, 290
DAG, 97, 439
data augmentation, 210, 621
data compression, 16, 719
data fragmentation, 599
Data mining, 27
data parallelism, 447
data processing inequality, 217
Data science, 27
data uncertainty, 7, 32
Datasaurus Dozen, 41, 42
dead ReLU, 443
debiasing, 383
decision boundary, 5, 51, 145, 334
decision making under uncertainty, 1
decision rule, 5
decision surface, 6
decision tree, 6
decision trees, 597
decode, 651
decoder, 674, 680
deconvolution, 481
deduction, 195
deep CCA, 673
deep factorization machines, 742
deep graph infomax, 761
deep metric learning, 546, 548
deep mixture of experts, 457
deep neural networks, 12, 419
DeepDream, 491
DeepWalk, 754
default prior, 141
defender’s fallacy, 73
deflated matrix, 707
deflation, 253
degree of normality, 59
degrees of freedom, 13, 59, 377
delta rule, 288
demonstrations, 18
dendogram, 712
dendrites, 430
denoising autoencoder, 676
dense prediction, 486
dense sequence labeling, 501
DenseNets, 478
density estimation, 16
density kernel, 514, 554
dependent variable, 365
depth prediction, 486
depthwise separable convolution, 482
derivative, 263
derivative free optimization, 313
descent direction, 277, 278
design matrix, 3, 239, 420, 772
determinant, 231
development set, 120
deviance, 414, 600
DFO, 313
diagonal covariance matrix, 81
diagonal matrix, 233
diagonalizable, 249
diagonally dominant, 234
diameter, 714
differentiable programming, 439
differential entropy, 206
differentiating under the integral sign, 68
differentiation, 264
diffuse prior, 141
dilated convolution, 480, 485
dilation factor, 480
dimensionality reduction, 4, 651
Dirac delta function, 58, 144
directed acyclic graph, 97
directed ayclic graph, 439
directional derivative, 264
Dirichlet distribution, 134, 328
Dirichlet energy, 694
discrete AdaBoost, 608
discrete optimization, 269
discrete random variable, 33
discretize, 207, 214
discriminant function, 318
discriminative classifier, 317, 330
dispersion parameter, 409
distance metric, 207
distant supervision, 649
distortion, 651, 716, 718
distributional hypothesis, 699
distributive, 236
divergence measure, 207
diverse beam search, 510
DNA sequence motifs, 202
DNN, 12, 419
document retrieval, 700
document summarization, 22
domain adaptation, 624, 631
domain adversarial learning, 631
dominates, 187, 194
dot product, 236
double centering trick, 241
double sided exponential, 61
dropout, 449
dual feasibility, 298
dual form, 582
dual problem, 581
dual variables, 588
dummy encoding, 23, 51
Dutch book theorem, 197
dynamic graph, 439
dynamic programming, 509
E step, 306, 308
early stopping, 122, 448
EB, 141
echo state network, 505
ECM, 664
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022INDEX 779
economy sized QR, 259
economy sized SVD, 254
edge devices, 304, 482
EER, 169
effect size, 182
EfficientNetv2, 479
eigenfaces, 653
eigenvalue, 247
eigenvalue decomposition, 247
eigenvalue spectrum, 119
eigenvector, 247
Einstein summation, 242
einsum, 242
elastic embedding, 696
elastic net, 384, 390
ELBO, 149, 308, 679
elbow, 722
electronic health records, 518
ell-2 loss, 9
ELM, 579
ELMo, 531
ELU, 444
EM, 83, 306
EMA, 115
email spam classification, 22
embarassingly parallel, 447
embedding, 651
EMNIST, 20
empirical Bayes, 141, 178, 405
empirical distribution, 63, 70, 105, 188, 209
empirical risk, 6, 188
empirical risk minimization, 7, 111, 189, 287
encode, 651
encoder, 673, 680
encoder-decoder, 485
encoder-decoder architecture, 503
endogenous variables, 2
energy based model, 629
energy function, 148
ensemble, 290, 450
ensemble learning, 602
entails, 518
entity discovery, 716
entity linking, 545
entity resolution, 535, 545
entropy, 174, 201, 308, 600
entropy minimization, 633
entropy SGD, 451
Epanechnikov kernel, 555
epigraph, 272
epistemic uncertainty, 7, 32
epistemology, 32
epoch, 287
epsilon insensitive loss function, 589
equal error rate, 169
equality constraints, 271, 296
equitability, 216
equivalent sample size, 127
equivariance, 469
ERM, 111, 189
error function, 55
estimation error, 189
estimator, 150
EVD, 247
event, 32, 32, 33, 33
events, 31
evidence, 131, 177
evidence lower bound, 149, 308, 679
EWMA, 115, 293
exact line search, 280
exchangeable, 100
exclusive KL, 210
exclusive or, 454
exemplar-based models, 541
exemplars, 453
exogenous variables, 2
expectation maximization, 306
expected complete data log likelihood, 309
expected sufficient statistics, 309
expected value, 38, 56
experiment design, 644
explaining away, 99
explanatory variables, 365
explicit feedback, 735
exploding gradient problem, 441
exploration-exploitation tradeoff, 745
exploratory data analysis, 4
exponential dispersion family, 409
Exponential distribution, 63
exponential family, 90, 93, 140
exponential family factor analysis, 669
exponential family PCA, 669
Exponential linear unit, 442
exponential loss, 608
exponential moving average, 115
exponentially weighted moving average, 115
exponentiated cross entropy, 205
exponentiated quadratic, 562
extractive summarization, 536
extreme learning machine, 579
F score, 171
face detection, 483
face recognition, 483
face verification, 545
FaceNet, 551
factor analysis, 16, 660
factor loading matrix, 661
factorization machine, 742
FAISS, 544
false alarm rate, 168
false negative rate, 44
false positive rate, 44, 168
fan-in, 446
fan-out, 446
Fano’s inequality, 219
farthest point clustering, 719
Fashion-MNIST, 20
fast adapation, 646
fast Hadamard transform, 578
fastfood, 578
feasibility, 298
feasibility problem, 271
feasible set, 271
feature crosses, 24
feature detection, 465
feature engineering, 11
feature extraction, 11
feature extractor, 366
feature importance, 615, 615
feature map, 465
feature preprocessing, 11
feature selection, 219, 303, 379
features, 1
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license780 INDEX
featurization, 4
feedforward neural network, 419
few-shot classification, 545
few-shot learning, 647
FFNN, 419
fill in, 27
fill-in-the-blank, 532, 626
filter, 463
filter response normalization, 473
filters, 461
FIM, 151
fine-grained classification, 21, 647
fine-grained visual classification, 623
fine-tune, 531
fine-tuning phase, 623
finite difference, 264
finite sum problem, 287
first order, 276, 340
first order Markov condition, 99
first-order, 283
Fisher information matrix, 151, 341
Fisher scoring, 341
Fisher’s linear discriminant analysis, 322
FISTA, 392
flat local minimum, 270
flat minima, 451
flat prior, 140
flatten, 425
FLDA, 322
folds, 121, 191
forget gate, 507
forward mode differentiation, 433
forward stagewise additive modeling, 606
forwards KL, 210
forwards model, 47
founder variables, 667
fraction of variance explained, 659
fraud detection system, 764
frequentist, 31
frequentist decision theory, 184
frequentist statistics, 150
Frobenius norm, 230
frozen parameters, 624
full covariance matrix, 81
full rank, 231
full-matrix Adagrad, 295
function space, 571
furthest neighbor clustering, 714
fused batchnorm, 471
gallery, 483, 544
GAM, 395
gamma distribution, 62
GANs, 631
Gated Graph Sequence Neural Networks, 756
gated recurrent units, 506
gating function, 455
Gaussian, 9
Gaussian discriminant analysis, 317
Gaussian distribution, 55
Gaussian kernel, 453, 529, 554, 562
Gaussian mixture model, 94
Gaussian process, 453
Gaussian process regression, 395
Gaussian processes, 568
Gaussian scale mixture, 102
GCN, 757
GDA, 317
GELU, 442, 444
generalization error, 189, 191
generalization gap, 13, 189
generalize, 7, 117
generalized additive model, 395
generalized CCA, 673
generalized eigenvalue, 324
generalized Lagrangian, 298, 581
generalized linear models, 409
generalized low rank models, 669
generalized probit approximation, 361
Generative adversarial networks, 641
generative classifier, 317, 330
generative image model, 487
Geometric Deep Learning, 747
geometric series, 116, 281
Gini index, 599
glmnet, 391
GLMs, 409
global average pooling, 426, 470
global optimization, 269
global optimum, 269, 338
globally convergent, 270
Glorot initialization, 447
GloVe, 703
GMM, 94
GMRES, 370
GNN, 420, 756
goodness of fit, 374
GoogLeNet, 476
GPT, 536
GPT-2, 536
GPT-3, 536
GPUs, 429, 447
GPyTorch, 577
gradient, 264, 277
gradient boosted regression trees, 612
gradient boosting, 610
gradient clipping, 441
gradient sign reversal, 631
gradient tree boosting, 612
Gram matrix, 235, 241, 494, 562
Gram Schmidt, 236
Graph attention network, 758
Graph convolutional networks, 757
graph factorization, 753
graph Laplacian, 694, 729
graph neural network, 756
graph neural networks, 420
graph partition, 728
Graph Representation Learning, 747
graphical models, 37
Graphical Mutual Information, 762
graphics processing units, 447
graphite, 761
GraphNet, 757
GraphSAGE, 757
GraRep, 753
greedy decoding, 509
greedy forward selection, 393
grid approximation, 148
grid search, 120, 314
group lasso, 388
group normalization, 473
group sparsity, 387
grouping effect, 390
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022INDEX 781
GRU, 506
Gshard, 526
Gumbel noise, 510
HAC, 711
half Cauchy, 61
half spaces, 334
Hamiltonian Monte Carlo, 150
hard attention, 519
hard clustering, 95, 724
hard negatives, 551
hard thresholding, 382, 385
hardware accelerators, 431
harmonic mean, 171
hat matrix, 369
HDI, 143
He initialization, 447
heads, 426
heat map, 465
Heaviside, 340
Heaviside step function, 437
heaviside step function, 50, 420
heavy ball, 281
heavy tails, 60, 396
Helmholtz machine, 679
Hessian, 338, 770
Hessian matrix, 266
heteroskedastic regression, 57, 370
heuristics, 432
hidden, 43
hidden common cause, 77
hidden units, 421
hidden variables, 100, 306, 772
hierarchical, 429
hierarchical agglomerative clustering, 711
hierarchical Bayesian model, 141
hierarchical mixture of experts, 457
hierarchical softmax, 352
hierarchy, 351
highest density interval, 143
highest posterior density, 143
hinge loss, 112, 314, 585, 741
Hinton diagram, 84
hit rate, 168
HMC, 150
Hoeffding’s inequality, 192
hogwild training, 448
holdout set, 190
homogeneous, 99
homoscedastic regression, 57
homotopy, 392
HPD, 143
Huber loss, 173, 398, 611
Huffman encoding, 352
human pose estimation, 486
Hutchinson trace estimator, 230, 231
hyper-parameters, 127, 313
hypercolumn, 468
hypernyms, 351
hyperparameter, 190
hyperparameters, 141
hyperplane, 334
hypothesis, 518
hypothesis space, 189
hypothesis testing, 175
I-projection, 210
IA, 28
ID3, 599
identifiability, 349
identifiable, 187, 349
identity matrix, 233
iid, 69, 104, 126
ill-conditioned, 110, 232
ill-posed, 47
ILP, 301
ILSVRC, 21
image captioning, 499
image classification, 3
image compression, 719
image interpolation, 681
image patches, 461
image tagging, 344, 483
image-to-image, 486
ImageNet, 21, 429, 475
ImageNet-21k, 526
IMDB, 124
IMDB movie review dataset, 22
implicit feedback, 741
implicit regularization, 451
impostors, 546
imputation tasks, 626
inception block, 476
Inceptionism, 491
inclusive KL, 210
incremental learning, 545
indefinite, 234
independent, 37
independent and identically distributed, 69, 126
independent variables, 365
indicator function, 6, 34
induced norm, 229
inducing points, 577
induction, 118, 195
inductive bias, 13, 421, 526
inductive learning, 637
inequality constraints, 271, 296
infeasible, 299
inference, 103, 125
inference network, 678
infinitely wide, 576
InfoNCE, 550
information, 31
information content, 201
information criteria, 181
information diagram, 212
information diagrams, 213
information extraction, 534
information gain, 207, 644
information gathering action, 7
information projection, 210
information retrieval, 169
information theory, 174, 201
inner product, 236
input gate, 507
Instagram, 483
instance normalization, 472
instance segmentation, 484
instance-balanced sampling, 353
instance-based learning, 541
Integer linear programming, 301
integrated risk, 186
integrating out, 125
intelligence augmentation, 28
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license782 INDEX
inter-quartile range, 43
interaction effects, 23
intercept, 8
interior point method, 300
internal covariate shift, 471
interpolate, 11
interpolated precision, 171
interpolator, 568
interpretable, 17
intrinsic dimensionality, 684
inverse, 243
inverse cdf, 36
inverse document frequency, 25
inverse Gamma distribution, 63
inverse probability, 47
inverse problems, 47
inverse reinforcement learning, 28
inverse Wishart, 118
Iris, 2
Iris dataset, 3
IRLS, 341
isomap, 688
isotropic covariance matrix, 81
ISTA, 392
items, 735
iterate averaging, 291
iterative soft thresholding algorithm, 392
iteratively reweighted least squares, 341
Jacobian, 65, 346
Jacobian formulation, 265
Jacobian matrix, 265
Jacobian vector product, 265
Jensen’s inequality, 208, 308
Jeopardy, 166
Jester, 736
JFT, 526
jittered, 454
joint distribution, 36
joint probability, 32
JPEG, 719
just in time, 439
JVP, 265
K nearest neighbor, 541
k-d tree, 544
K-means algorithm, 716
K-means clustering, 95
K-means++, 719
K-medoids, 719
Kalman filter, 89
Karl Popper, 118
Karush-Kuhn-Tucker, 299
Katz centrality index, 752
KDE, 554, 556
kernel, 463, 554
kernel density estimation, 554
kernel density estimator, 556
kernel function, 453, 561, 561
kernel PCA, 689, 731
kernel regression, 514, 558, 570
kernel ridge regression, 570, 589
kernel smoothing, 558
kernel trick, 584
keys, 512
keywords, 255
kink, 722
KKT, 299
KL divergence, 105, 174, 207, 308
KNN, 541
knots, 393
Knowledge distillation, 643
knowledge graph, 764
Kronecker product, 242
Krylov subspace methods, 577
KSG estimator, 214
Kullback Leibler divergence, 105, 174
Kullback-Leibler divergence, 207, 308
L-BFGS, 285
L0-norm, 379, 380
L1 loss, 173
L1 regularization, 379
L1VM, 592
L2 loss, 172
L2 regularization, 119, 342, 375
L2VM, 591
label, 2
label noise, 353, 649
Label propagation, 637, 755
label smearing, 351
label smoothing, 644, 649
Label spreading, 755
label switching problem, 313, 726
Lagrange multiplier, 297
Lagrange multipliers, 93, 107
Lagrange notation, 264
Lagrangian, 93, 253, 271, 297, 380
Lanczos algorithm, 665
language model, 98
language modeling, 22, 499
language models, 205, 531
Laplace, 379
Laplace approximation, 148, 357
Laplace distribution, 61
Laplace smoothing, 329
Laplace vector machine, 592
Laplace’s rule of succession, 130
Laplacian eigenmaps, 692, 730, 751
LAR, 393
large margin classifier, 580
large margin nearest neighbor, 546
LARS, 392
lasso, 301, 379
latent coincidence analysis, 547
latent factors, 16, 653
latent semantic analysis, 700
latent semantic indexing, 700
latent space interpolation, 682
latent variable, 93
latent variable models, 772
latent variables, 772
latent vector, 653
law of iterated expectations, 39
law of total expectation, 39
law of total variance, 40
layer normalization, 472
layer-sequential unit-variance, 447
LCA, 547
LDA, 317, 319
Leaky ReLU, 442
leaky ReLU, 444
learning curve, 123
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022INDEX 783
learning rate, 277
learning rate schedule, 278, 288, 289
learning rate warmup, 290
learning to learn, 646
learning with a critic, 18
learning with a teacher, 18
least angle regression, 393
least favorable prior, 187
least mean squares, 288, 372
least squares boosting, 393, 606
least squares objective, 262
least squares solution, 10
leave-one-out cross-validation, 122, 191
LeCun initialization, 447
left pseudo inverse, 263
Leibniz notation, 264
LeNet, 470, 473
level sets, 80, 81
life-long learning, 545
LightGBM, 613
likelihood, 43
likelihood function, 125
likelihood principle, 197
likelihood ratio, 175, 196
likelihood ratio test, 193
limited memory BFGS, 285, 347
line search, 279
Linear algebra, 223
linear autoencoder, 674
linear combination, 237
linear discriminant analysis, 317, 319
linear function, 8
linear Gaussian system, 84
linear kernel, 576
linear map, 227
linear operator, 370
linear programming, 397
linear rate, 280
linear regression, 57, 365, 409, 419
linear subspace, 237
linear threshold function, 420
linear transformation, 227
linearity of expectation, 38
linearly dependent, 226
linearly independent, 226
linearly separable, 334
Linformer, 529
link function, 409, 411
link prediction, 763
Lipschitz constant, 275
liquid state machine, 505
LMNN, 546
LMS, 288
local linear embedding, 691
local maximum, 270
local minimum, 269
local optimum, 269, 338
locality sensitive hashing, 544
locally linear regression, 559
locally-weighted scatterplot smoothing, 559
LOESS, 559
log bilinear language model, 705
log likelihood, 104
log loss, 175, 586
log odds, 50
log partition function, 90
log-sum-exp trick, 54
logistic, 49
logistic function, 50, 144
Logistic regression, 333
logistic regression, 8, 51, 144, 409
logit, 49, 333, 336
logit function, 50
logitBoost, 610
logits, 7, 53, 344
long short term memory, 507
long tail, 147, 352
Lorentz, 60
Lorentz model, 752
loss function, 6, 9, 163, 269
lossy compression, 718
lower triangular matrix, 234
LOWESS, 559
LSA, 700
lse, 54
LSH, 544
LSI, 700
LSTM, 507
M step, 306
M’th order Markov model, 99
M-projection, 210
M1, 640
M2, 640
machine learning, 1
machine translation, 22, 503
Mahalanobis distance, 81, 541
Mahalanobis whitening, 251
main effects, 23
majorize-minimize, 306
MALA, 487
MAML, 646
manifold, 682, 683
manifold assumption, 637
manifold hypothesis, 683
manifold learning, 683
mAP, 171
MAP estimate, 165
MAP estimation, 117, 190
MAR, 27
margin, 112, 579, 608
margin errors, 584
marginal distribution, 36
marginal likelihood, 43, 125, 131, 133, 141, 177
marginalizing out, 125, 144
marginalizing over, 125
marginally independent, 37
Markov chain, 99
Markov chain Monte Carlo, 149
Markov kernel, 99
Markov model, 99
MART, 612
masked attention, 513
masked language model, 533
matched filter, 462
matching network, 648
Matern kernel, 564
matrix, 223
matrix completion, 737
matrix determinant lemma, 246
matrix factorization, 737
matrix inversion lemma, 245, 588
matrix square root, 229, 239, 260
matrix vector multiplication, 577
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license784 INDEX
max pooling, 469
maxent classifier, 350
maximal information coefficient, 215
maximum a posterior estimation, 117
maximum a posteriori, 165
maximum entropy, 58, 201
maximum entropy classifer, 350
maximum entropy model, 92
maximum entropy sampling, 645
maximum expected utility principle, 164
maximum likelihood estimate, 8
maximum likelihood estimation, 103
maximum risk, 186
maximum variance unfolding, 691
MCAR, 27
McCulloch-Pitts model, 430
McKernel, 578
MCMC, 149
MDL, 182
MDN, 457
MDS, 685
mean, 38, 56
mean average precision, 171
mean function, 409
mean squared error, 9, 111
mean value imputation, 27
median, 36, 55
median absolute deviation, 557
medoid, 720
memory cell, 507
memory-based learning, 541
Mercer kernel, 561
Mercer’s theorem, 562
message passing neural networks, 756
meta-learning, 646, 648
method of moments, 113
metric MDS, 686
Metropolis-adjusted Langevin algorithm, 487
MICe, 216
min-max scaling, 344
minibatch, 287
minimal, 91
minimal representation, 91
minimal sufficient statistic, 218
minimally informative prior, 141
minimax estimator, 186
minimum description length, 182
minimum mean squared error, 172
minimum spanning tree, 713
minorize-maximize, 306
MIP, 301
misclassification rate, 6, 112
missing at random, 27, 735
missing completely at random, 27
missing data, 26, 306
missing data mechanism, 27, 641
missing value imputation, 83
mixed ILP, 301
mixing weights, 133
mixmatch, 634
mixture density network, 457
mixture model, 93
mixture of Bernoullis, 95
mixture of beta distributions, 132
mixture of experts, 455, 527
mixture of factor analysers, 668
mixture of Gaussians, 94
ML, 1
MLE, 8, 103
MLP, 419, 421
MLP-mixer, 421
MM, 306
MMSE, 172
MNIST, 19, 473
MobileNet, 482
MoCo, 629
mode, 39, 165
mode-covering, 210
mode-seeking, 211
model compression, 449
model fitting, 7, 103
model parallelism, 447
model selection, 176
model selection consistent, 386
model uncertainty, 7, 32
model-agnostic meta-learning, 646
modus tollens, 195
MoE, 455
MoG, 94
moment projection, 210
momentum, 281
momentum contrastive learning, 629
MoNet, 759
Monte Carlo approximation, 70, 149, 360
Monte Carlo dropout, 450
Monty Hall problem, 45
Moore-Penrose pseudo-inverse, 255
most powerful test, 194
motes, 11
motif, 203
MovieLens, 736
moving average, 115
MSE, 9, 111
multi-class classification, 344
multi-clust, 733
Multi-dimensional scaling, 751
multi-headed attention, 521
multi-instance learning, 649
multi-label classification, 344
multi-label classifier, 351
multi-level model, 141
multi-object tracking, 545
multiclass logistic regression, 333
multidimensional scaling, 685
multilayer perceptron, 419, 421
multimodal, 39
multinomial coefficient, 52
multinomial distribution, 51, 52
Multinomial logistic regression, 344
multinomial logistic regression, 53, 333
multinomial logit, 52
multiple imputation, 84
multiple linear regression, 10, 365
multiple restarts, 719
multivariate Bernoulli naive Bayes, 326
multivariate Gaussian, 79
multivariate linear regression, 366
multivariate normal, 79
mutual information, 77, 211
mutually independent, 72
MVM, 577
MVN, 79
myopic, 645
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022INDEX 785
N-pairs loss, 550
Nadaraya-Watson, 558
naive Bayes assumption, 321, 326
naive Bayes classifier, 326
named entity recognition, 534
NAS, 479
nats, 201
natural exponential family, 91
natural language inference, 518
natural language processing, 21, 350
natural language understanding, 47
natural parameters, 90
NBC, 326
NCA, 546
NCM, 322
nearest centroid classifier, 322
nearest class mean classifier, 322, 353
nearest class mean metric learning, 322
nearest neighbor clustering, 713
NEF, 91
negative definite, 234
negative log likelihood, 8, 104
negative semidefinite, 234
neighborhood components analysis, 546
neocognitron, 470
nested optimization, 190
nested partitioning, 733
Nesterov accelerated gradient, 282
Netflix Prize, 735
NetMF, 754
neural architecture search, 479
neural language model, 99
neural machine translation, 503
neural matrix factorization, 743
neural style transfer, 491
neural tangent kernel, 576
NeurIPS, 18
neutral, 518
Newton’s method, 283, 340
next sentence prediction, 533
Neyman-Pearson lemma, 194
NHST, 194
NHWC, 468
NIPS, 18
NLL, 104
NLP, 21
NMAR, 27
no free lunch theorem, 13
node2vec, 754
noise floor, 123
non-identifiability, 726
non-identifiable, 404
non-metric MDS, 687
non-parametric bootstrap, 153
non-parametric methods, 683
non-parametric model, 453
non-saturating activation functions, 423, 443
noninformative, 140
nonlinear dimensionality reduction, 683
nonlinear factor analysis, 668
nonparametric methods, 561
nonparametric models, 541
nonsmooth optimization, 275
norm, 228, 232
normal, 9
normal distribution, 55
normal equations, 263, 367
Normal-Inverse-Wishart distribution, 312
normalization layers, 470
normalized, 235
normalized cut, 729
normalized mutual information, 215, 711
normalizer-free networks, 473
Normalizing flows, 642
not missing at random, 27
noun phrase chunking, 534
novelty detection, 545
NT-Xent, 550
nu-SVM classifier, 584
nuclear norm, 229
nucleotide, 202
null hypothesis, 175, 182, 193
null hypothesis significance testing, 194
nullspace, 227
numerator layout, 265
object detection, 483
objective, 140
objective function, 104, 269
observation distribution, 43
Occam factor, 181
Occam’s razor, 178
offset, 10, 365
Old Faithful, 310
Olivetti face dataset, 653
OLS, 111, 263, 367
one-cycle learning rate schedule, 290
one-hot, 174
one-hot encoding, 23, 345, 772
one-hot vector, 51, 223
one-shot learning, 322, 647
one-sided test, 182
one-standard error rule, 122
one-to-many functions, 454
one-versus-one, 587
one-versus-the-rest, 587
one-vs-all, 587
online learning, 115, 305, 545
OOD, 545
OOV, 24, 26
open class, 26
open set recognition, 544
open world, 483
open world assumption, 545
OpenPose, 486
opt-einsum, 243
optimal policy, 164
optimism of the training error, 190
optimization problem, 269
order, 225
order statistics, 114
ordered Markov property, 97
ordering constraint, 727
ordinary least squares, 111, 263, 367
Ornstein-Uhlenbeck process, 565
orthodox statistics, 150
orthogonal, 235, 249
orthogonal projection, 369
orthogonal random features, 578
orthonormal, 235, 249
out of vocabulary, 26
out-of-bag instances, 603
out-of-distribution, 545
out-of-sample generalization, 683
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license786 INDEX
out-of-vocabulary, 24
outer product, 237
outliers, 59, 173, 353, 396
output gate, 507
over-complete representation, 91
over-parameterized, 53
overcomplete representation, 674
overdetermined, 260
overdetermined system, 368
overfitting, 13, 116, 129
p-value, 176, 195
PAC learnable, 191
PageRank, 252
pair plot, 4
paired test, 182
pairwise independent, 71
PAM, 720
panoptic segmentation, 485
parameter space, 269
parameter tying, 99
parameters, 6
parametric bootstrap, 152
parametric models, 541
parametric ReLU, 444
part of speech tagging, 534
part-of-speech, 532
partial dependency plot, 617
partial derivative, 264
partial least squares, 672
partial pivoting, 258
partial regression coefficient, 371
partially observed, 163
partition function, 54, 90, 629
partitioned inverse formulae, 244
partitioning around medoids, 720
Parzen window density estimator, 556
pathologies, 197
pattern recognition, 2
PCA, 16, 651, 652
PCA whitening, 251
pdf, 35, 56
peephole connections, 508
penalty term, 302
percent point function, 36
perceptron, 340, 420
perceptron learning algorithm, 340
Performer, 529
periodic kernel, 565
perplexity, 205, 499
person re-identification, 545
PersonLab, 486
perturbation theory, 730
PGM, 97
Planetoid, 762
plates, 100
Platt scaling, 585
PLS, 672
plug-in approximation, 129, 144
plugin approximation, 359
PMF, 738
pmf, 34
PMI, 701
Poincaré model, 752
point estimate, 103
point null hypothesis, 182
pointwise convolution, 468
pointwise mutual information, 701
Poisson regression, 411
polar, 66
policy, 17
Polyak-Ruppert averaging, 291
polynomial expansion, 366
polynomial regression, 10, 119, 366
polytope, 299
pool-based active learning, 644
population risk, 13, 121, 188
POS, 532
position weight matrix, 202
positional embedding, 522
positive definite, 234
positive definite kernel, 561
positive PMI, 701
positive semidefinite, 234
posterior, 125
posterior distribution, 44, 125
posterior expected loss, 163
posterior inference, 44
posterior mean, 172
posterior median, 173
posterior predictive distribution, 125, 130, 144, 359, 400
power, 194
power method, 252
PPCA, 662
ppf, 36
pre-activation, 333
pre-activations, 422
pre-train, 531
pre-trained word embedding, 26
pre-training phase, 623
preactivation resnet, 478
precision, 55, 137, 170, 170
precision at K, 170
precision matrix, 82, 108
precision-recall curve, 170
preconditioned SGD, 292
preconditioner, 292
preconditioning matrix, 292
predictive analytics, 27
predictors, 2
preferences, 163
premise, 518
PreResnet, 478
pretext tasks, 627
prevalence, 44, 171
primal problem, 581
primal variables, 589
principal components analysis, 16, 651
principal components regression, 378
prior, 117, 125
prior distribution, 43
probabilistic forecasting, 173
probabilistic graphical model, 97
probabilistic inference, 44
probabilistic matrix factorization, 738
probabilistic PCA, 651
probabilistic perspective, 1
probabilistic prediction, 173
probabilistic principal components analysis, 662
probability density function, 35, 56
probability distribution, 173
probability distributions, 1
probability mass function, 34
probability simplex, 134
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022INDEX 787
probability theory, 43
probably approximately correct, 191
probit approximation, 360
probit function, 55, 360
probit link function, 412
product rule, 37
product rule of probability, 43
profile likelihood, 659
profile log likelihood, 660
projected gradient descent, 303, 392
projection, 228
projection matrix, 369
prompt, 536
prompt engineering, 631
proper scoring rule, 175
prosecutor’s fallacy, 73
proxies, 551
proximal gradient descent, 392
proximal gradient method, 302
proximal operator, 302
ProxQuant, 305
proxy tasks, 627
prune, 600
psd, 234
pseudo counts, 127, 328
pseudo inputs, 577
pseudo inverse, 367
pseudo norm, 229
pseudo-labeling, 633
pseudo-likelihood, 532
pure, 600
purity, 710
Pythagoras’s theorem, 262
QALY, 163
QP, 300
quadratic approximation, 148
quadratic discriminant analysis, 318
quadratic form, 234, 250
quadratic kernel, 562
quadratic loss, 9, 172
quadratic program, 300, 380, 590
quality-adjusted life years, 163
quantile, 36, 55
quantile function, 36
quantization, 206
quantize, 207, 214
quantized, 304
quartiles, 36, 55
Quasi-Newton, 284
quasi-Newton, 347
query, 512
query synthesis, 644
question answering, 22, 535
radial basis function, 554
radial basis function kernel, 453, 529
Rand index, 710
RAND-WALK, 705
random finite sets, 545
random forests, 604
random Fourier features, 578
random number generator, 70
random shuffling, 287
random variable, 33
random variables, 1
random walk kernel, 567
range, 227
rank, 225, 231
rank deficient, 231
rank one update, 245
rank-nullity theorem, 256
ranking loss, 549, 741
RANSAC, 398
rate, 480, 719
rate of convergence, 280
rating, 735
Rayleigh quotient, 252
RBF, 554
RBF kernel, 453, 562
RBF network, 453
real AdaBoost, 608
recall, 168, 170
receiver operating characteristic, 169
receptive field, 467, 480
recognition network, 678
recommendation systems, 764
Recommender systems, 735
reconstruction error, 651, 653, 718
Rectified linear unit, 442
rectified linear unit, 423, 443
recurrent neural network, 497
recurrent neural networks, 12, 420
recursive update, 115
recursively, 371
reduce-on-plateau, 290
reduced QR, 259
Reformer, 528
region of practical equivalence, 182
regression, 8, 772
regression coefficient, 371
regression coefficients, 8, 365
regularization, 117
regularization parameter, 117
regularization path, 378, 383, 392
regularized discriminant analysis, 321
regularized empirical risk, 189
reinforcement learning, 17, 745
reject option, 166
relational data, 735
relative entropy, 207
relevance vector machine, 592
ReLU, 423, 443
reparameterization trick, 680
representation learning, 627
reservoir computing, 506
reset gate, 507
reshape, 225
residual block, 445, 476
residual error, 111
residual network, 445
residual plot, 374
residual sum of squares, 111, 367
residuals, 9, 374
ResNet, 445, 476
ResNet-18, 478
response, 2
response variables, 772
responsibility, 95, 309, 456
reverse KL, 210
reverse mode differentiation, 434
reward, 18
reward function, 269
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license788 INDEX
reward hacking, 28
RFF, 578
ridge regression, 119, 158, 375, 449
Riemannian manifold, 683
Riemannian metric, 683
right pseudo inverse, 262
risk, 163, 184
risk averse, 165, 166
risk neutral, 165
risk sensitive, 165
RL, 17
RMSE, 111, 375
RNN, 420, 497
Robbins-Monro conditions, 289
robust, 9, 59, 173
robust linear regression, 300
robust logistic regression, 353
robustness, 396
ROC, 169
root mean squared error, 111, 375
ROPE, 182
rotation matrix, 235
row rank, 231
row-major order, 225
RSS, 111
rule of iterated expectation, 102
rule of total probability, 36
running sum, 115
rv, 33
RVM, 592
saddle point, 271, 274
SAGA, 292, 339
same convolution, 465
SAMME, 609
Sammon mapping, 687
sample efficiency, 17
sample mean, 156
sample size, 2, 106, 126
sample space, 33
sample variance, 139
sampling distribution, 150
SARS-CoV-2, 44
saturated model, 414
saturates, 423
scalar field, 264
scalar product, 236
scalars, 226
scale of evidence, 176
scaled dot-product attention, 515
scatter matrix, 109, 240
Schatten p-norm, 229
scheduled sampling, 504
Schur complement, 82, 244
score function, 151, 269, 676
scree plot, 658
second order, 340
Second-order, 283
self attention, 520
self-normalization property, 705
self-supervised, 626
self-supervised learning, 16
self-training, 632, 644
SELU, 444
semantic role labeling, 350
semantic segmentation, 485
semantic textual similarity, 519
semi-hard negatives, 551
semi-supervised embeddings, 762
Semi-supervised learning, 632
semi-supervised learning, 331
semidefinite embedding, 691
semidefinite programming, 546, 691
sensible PCA, 662
sensitivity, 44, 168
sensor fusion, 89
sentiment analysis, 22
seq2seq, 501
seq2seq model, 22
seq2vec, 500
sequence logo, 203
sequential minimal optimization, 582
SGD, 286
SGNS, 703
shaded nodes, 100
shallow parsing, 534
Shampoo, 295
Shannon’s source coding theorem, 203
shared, 319
sharp minima, 451
sharpness aware minimization, 451
Sherman-Morrison formula, 245
Sherman-Morrison-Woodbury formula, 245
shooting, 391
short and fat, 3
shrinkage, 88, 139, 378
shrinkage estimation, 118
shrinkage factor, 384, 611
Siamese network, 549, 627
side information, 744
sifting property, 59, 144
sigmoid, 49, 50, 144, 320
signal-to-noise ratio, 88
significance, 194
silhouette coefficient, 722, 722
silhouette diagram, 722
silhouette score, 722
SiLU, 444
SimCLR, 627
similarity, 541
simple hypothesis, 194
simple linear regression, 9, 365
simplex algorithm, 299
Simpson’s paradox, 78
simulated annealing, 41
single link clustering, 713
single shot detector, 484
singular, 243
singular value decomposition, 254
singular values, 232, 254
singular vectors, 254
skip connections, 478
skip-gram with negative sampling, 703
skipgram, 701
skipgram model, 702
slack variables, 583, 590
slate, 744
slope, 10
SMACOF, 686
SMO, 582
smooth optimization, 275
Smoothing splines, 395
SNLI, 518
Sobel edge detector, 488
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022INDEX 789
social networks, 764
soft clustering, 95
soft margin constraints, 583
soft thresholding, 382, 385
soft thresholding operator, 304
soft triple, 551
softmax, 52
softmax function, 7
Softplus, 442
softplus, 57
solver, 269
source dataset, 623
source domain, 631
span, 226
sparse, 134, 379
sparse Bayesian learning, 405
sparse factor analysis, 667
sparse GP, 577
sparse kernel machine, 453, 544
sparse linear regression, 301
sparse vector machines, 591
sparsity inducing regularizer, 304
specificity, 44
spectral clustering, 728
spectral CNNs, 757
spectral embedding, 692
spectral graph theory, 695
spectral radius, 441
spherical covariance matrix, 81
spherical embedding constraint, 553
split variable trick, 391
spurious correlation, 77
spurious correlations, 78
spurious features, 331
square, 224
square-root sampling, 353
square-root schedule, 290
squared error, 172
squared exponential kernel, 562
stacking, 603
standard basis, 227
standard deviation, 39, 56
standard error, 129
standard error of the mean, 122, 139
standard form, 299
standard normal, 55
standardization operation, 240
standardize, 343, 370
standardized, 310
standardizing, 250
Stanford Natural Language Inference, 518
state of nature, 163
state space, 33
state transition matrix, 99
static graph, 439
stationary, 99
stationary kernels, 563
stationary point, 270
statistical learning theory, 191
statistical machine translation, 503
statistical relational learning, 765
statistically significant, 194
statistics, 27
steepest descent, 278
Stein’s paradox, 188
step decay, 290
step function, 63
step size, 277
stochastic averaged gradient accelerated, 292
stochastic beam search, 510
stochastic gradient boosting, 612
stochastic gradient descent, 286, 339
stochastic gradient descent with warm restarts, 290
stochastic matrix, 99
stochastic neighbor embedding, 695
stochastic optimization, 286
stochastic variance reduced gradient, 291
stochastic volatility model, 427
Stochastic Weight Averaging, 291
stochastic weight averaging, 451, 639
stop word removal, 24
storks, 78
straight-through estimator, 305
strain, 685
stream-based active learning, 644
stress function, 686
strict, 187
strict local minimum, 270
strictly concave, 272
strictly convex, 272
strided convolution, 467
string kernel, 567
strong learner, 606
strongly convex, 274
structural deep network embedding, 760
structural risk minimization, 190
structured data, 419
STS Benchmark, 519
STSB, 537
Student distribution, 59
Student t distribution, 59
subderivative, 437
subdifferentiable, 276
subdifferential, 276
subgradient, 276
submodular, 645
subword units, 26
sufficient statistic, 218
sufficient statistics, 90, 106, 108, 126
sum of squares matrix, 240
sum rule, 36
supervised learning, 1
supervised PCA, 670
support vector machine, 579
support vector machine regression, 591
support vectors, 579, 583, 591
surface normal prediction, 486
surrogate function, 306
surrogate loss function, 112
surrogate splits, 600
suspicious coincidence, 176
SVD, 254, 377
SVM, 301, 579
SVM regression, 591
SVRG, 291
Swish, 442
swish, 444
Swiss roll, 685
symmetric, 224
symmetric SNE, 696
synaptic connection, 430
synchronous training, 448
syntactic sugar, 100
systems of linear equations, 260
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license790 INDEX
t-SNE, 695
T5, 536
tabular data, 3, 419
tall and skinny, 3
tangent space, 683
target, 2, 365
target dataset, 623
target domain, 631
target neighbors, 546
targets, 772
taxonomy, 351
Taylor series, 148
Taylor series expansion, 220
teacher forcing, 503
temperature, 53
tempered cross entropy, 354
tempered softmax, 355
template matching, 461, 465
tensor, 224, 467
tensor processing units, 431
term frequency matrix, 25
term-document frequency matrix, 699
test risk, 13
test set, 13
test statistic, 193
text to speech, 512
textual entailment, 518
TF-IDF, 25
The Pile, 536
thin SVD, 254
thresholded linear unit, 473
TICe, 216
tied, 319
Tikhonov damping, 286
Tikhonov regularization, 286
time series forecasting, 499
time-invariant, 99
TinyImages, 20
TL;DR, 536
token, 24
topological instability, 689
topological order, 97
total derivative, 265
total differential, 265
total variation, 488
TPUs, 431
trace, 230
trace norm, 229
trace trick, 230
tracing, 439
training, 7, 103
training data, 772
training set, 2
transductive learning, 637
transfer learning, 531, 553, 623
transformer, 520
transformers, 420
transition function, 99
transition kernel, 99
translation invariance, 461
transpose, 224
transposed convolution, 481, 485
treewidth, 243
Tri-cube kernel, 555
Tri-Training, 636
triangle inequality, 207
tridiagonal, 233
trigram model, 99
triplet loss, 549
true negative rate, 44
true positive rate, 44, 168
truncate, 505
truncated SVD, 258
trust-region optimization, 286
tube, 590
Turing machine, 498
TV, 488
two-sided test, 182
type I error rate, 168, 194
type II maximum likelihood, 141
typical patterns, 16
U-net, 485, 486
U-shaped curve, 13
UMAP, 698
unadjusted Langevin algorithm, 487
unbiased, 155
uncertainty, 31
unconditionally independent, 37
unconstrained optimization, 271
undercomplete representation, 674
underdetermined, 260
underfitting, 13, 120, 123
unidentifiable, 349
uninformative, 128, 140
uninformative prior, 139
union bound, 192
uniqueness, 661
unit vector, 223
unit vectors, 51
unitary, 235
universal function approximator, 428
UNK, 26
unrolled, 100
unstable, 602
unstructured data, 420
unsupervised learning, 14
unsupervised pre-training, 626
update gate, 507
upper triangular matrix, 234
users, 735
utility function, 164
VAE, 677
valid convolution, 465
validation risk, 121, 191
validation set, 13, 120, 190
value of information, 644
values, 512
vanishing gradient problem, 423, 441
variable metric, 284
variable selection, 386
variance, 38, 56
variation of information, 711
variational autoencoder, 16, 640, 677
variational autoencoders, 668
variational EM, 309
variational inference, 149
variational RNN, 499
varimax, 667
VC dimension, 192
vec2seq, 497
vector, 223
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022INDEX 791
vector addition, 704
vector field, 264, 676
vector Jacobian product, 266
vector quantization, 718
vector space, 226
vector space model, 24
VI, 149
vicinal risk minimization, 622
violin plot, 43
virtual adversarial training, 638
visible variables, 772
visual n-grams, 631
visual scene understanding, 47
ViT, 526
Viterbi decoding, 509
VJP, 266
Voronoi iteration, 720
Voronoi tessellation, 542, 717
VQ, 718
WAIC, 727
wake sleep, 679
Wald interval, 155
warm start, 378
warm starting, 392
Watson, 166
wavenet, 512
weak learner, 606
weakly supervised learning, 649
WebText, 536
weight decay, 119, 342, 375, 449
weight space, 571
weighted least squares, 370
weighted least squares problem, 341
weighted linear regression, 370
weights, 8, 365
well-conditioned, 232
whiten, 250
wide and deep, 742
wide data, 3
wide format, 24
wide resnet, 478
Widrow-Hoff rule, 288
winner takes all, 53
WMT dataset, 22
Wolfe conditions, 285
word analogy problem, 704
word embeddings, 26, 699, 699
word sense disambiguation, 532
word stemming, 24
word2vec, 701
wordpieces, 26
working response, 341
World Health Organization, 216
WSD, 532
Xavier initialization, 447
XGBoost, 613
XOR problem, 421
YOLO, 484
ZCA, 251
zero count, 118
zero-avoiding, 210
zero-forcing, 211
zero-one loss, 6, 165
zero-padding, 465
zero-shot classification, 631
zero-shot learning, 647
zero-shot task transfer, 536
zig-zag, 280
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licenseBibliography
[AAB21] A. Agrawal, A. Ali, and S. Boyd. “Minimum￾distortion embedding”. en. In: Foundations
and Trends in Machine Learning 14.3 (2021),
pp. 211–378.
[AB08] C. Archambeau and F. Bach. “Sparse proba￾bilistic projections”. In: NIPS. 2008.
[AB14] G. Alain and Y. Bengio. “What Regular￾ized Auto-Encoders Learn from the Data￾Generating Distribution”. In: JMLR (2014).
[AC16] D. K. Agarwal and B.-C. Chen. Statisti￾cal Methods for Recommender Systems. en.
1st edition. Cambridge University Press, Feb.
2016.
[Ace] “The Turing Test is Bad for Business”. In:
(2021).
[AEH+18] S. Abu-El-Haija, B. Perozzi, R. Al-Rfou,
and A. A. Alemi. “Watch your step: Learn￾ing node embeddings via graph attention”. In:
Advances in Neural Information Processing
Systems. 2018, pp. 9180–9190.
[AEHPAR17] S. Abu-El-Haija, B. Perozzi, and R. Al￾Rfou. “Learning Edge Representations via
Low-Rank Asymmetric Projections”. In: Pro￾ceedings of the 2017 ACM on Conference on
Information and Knowledge Management.
CIKM ’17. 2017, 1787–1796.
[AEM18] Ö. D. Akyildiz, V. Elvira, and J. Miguez.
“The Incremental Proximal Method: A Prob￾abilistic Perspective”. In: ICASSP. 2018.
[AFF19] C. Aicher, N. J. Foti, and E. B. Fox. “Adap￾tively Truncating Backpropagation Through
Time to Control Gradient Bias”. In: (May
2019). arXiv: 1905.07473 [cs.LG].
[Agg16] C. C. Aggarwal. Recommender Systems: The
Textbook. en. 1st ed. 2016 edition. Springer,
Mar. 2016.
[Agg20] C. C. Aggarwal. Linear Algebra and Opti￾mization for Machine Learning: A Textbook.
en. 1st ed. 2020 edition. Springer, May 2020.
[AGM19] V. Amrhein, S. Greenland, and B. McShane.
“Scientists rise up against statistical signif￾icance”. In: Nature 567.7748 (Mar. 2019),
p. 305.
[Agr70] A. Agrawala. “Learning with a probabilistic
teacher”. In: IEEE Transactions on Informa￾tion Theory 16.4 (1970), pp. 373–379.
[AH19] C. Allen and T. Hospedales. “Analogies Ex￾plained: Towards Understanding Word Em￾beddings”. In: ICML. 2019.
[AHK12] A. Anandkumar, D. Hsu, and S. M. Kakade.
“A Method of Moments for Mixture Mod￾els and Hidden Markov Models”. In: COLT.
Vol. 23. Proceedings of Machine Learning Re￾search. Edinburgh, Scotland: PMLR, 2012,
pp. 33.1–33.34.
[Ahm+13] A. Ahmed, N. Shervashidze, S. Narayana￾murthy, V. Josifovski, and A. J. Smola. “Dis￾tributed large-scale natural graph factoriza￾tion”. In: Proceedings of the 22nd interna￾tional conference on World Wide Web. ACM.
2013, pp. 37–48.
[AK15] J. Andreas and D. Klein. “When and why are
log-linear models self-normalizing?” In: Proc.
ACL. Denver, Colorado: Association for Com￾putational Linguistics, 2015, pp. 244–249.
[Aka74] H. Akaike. “A new look at the statistical
model identification”. In: IEEE Trans. on
Automatic Control 19.6 (1974).
[AKA91] D. W. Aha, D. Kibler, and M. K. Al￾bert. “Instance-based learning algorithms”.
In: Mach. Learn. 6.1 (Jan. 1991), pp. 37–66.
[Aky+19] Ö. D. Akyildiz, É. Chouzenoux, V. Elvira,
and J. Míguez. “A probabilistic incremental
proximal gradient method”. In: IEEE Signal
Process. Lett. 26.8 (2019).
[AL13] N. Ailon and E. Liberty. “An Almost Opti￾mal Unrestricted Fast Johnson-Lindenstrauss
Transform”. In: ACM Trans. Algorithms 9.3
(2013), 21:1–21:12.
[Ala18] J. Alammar. Illustrated Transformer. Tech.
rep. 2018.
[Alb+17] M. Alber, P.-J. Kindermans, K. Schütt, K.-R.
Müller, and F. Sha. “An Empirical Study on
The Properties of Random Bases for Kernel
Methods”. In: NIPS. Curran Associates, Inc.,
2017, pp. 2763–2774.
[Alb+18] D. Albanese, S. Riccadonna, C. Donati, and
P. Franceschi. “A practical tool for maximal
information coefficient analysis”. en. In: Gi￾gascience 7.4 (Apr. 2018), pp. 1–8.
[ALL18] S. Arora, Z. Li, and K. Lyu. “Theoretical
Analysis of Auto Rate-Tuning by Batch Nor￾malization”. In: (Dec. 2018). arXiv: 1812 .
03981 [cs.LG].
[Alm87] L. B. Almeida. “A learning rule for asyn￾chronous perceptrons with feedback in a com￾binatorial environment.” In: Proceedings, 1st
First International Conference on Neural
Networks. Vol. 2. IEEE. 1987, pp. 609–618.
[Alo+09] D. Aloise, A. Deshpande, P. Hansen, and
P. Popat. “NP-hardness of Euclidean sum-of￾squares clustering”. In: Machine Learning 75
(2009), pp. 245–249.
[Alp04] E. Alpaydin. Introduction to machine learn￾ing. MIT Press, 2004.794 BIBLIOGRAPHY
[Ami+19] E. Amid, M. K. Warmuth, R. Anil, and T.
Koren. “Robust Bi-Tempered Logistic Loss
Based on Bregman Divergences”. In: NIPS.
2019.
[Amo+16] D. Amodei, C. Olah, J. Steinhardt, P. Chris￾tiano, J. Schulman, and D. Mané. “Con￾crete Problems in AI Safety”. In: (June 2016).
arXiv: 1606.06565 [cs.AI].
[Amo17] Amoeba. What is the difference between
ZCA whitening and PCA whitening. Stack￾exchange. 2017.
[And01] C. A. Anderson. “Heat and Violence”. In:
Current Directions in Psychological Science
10.1 (2001), pp. 33–38.
[And+18] R. Anderson, J. Huchette, C. Tjandraat￾madja, and J. P. Vielma. “Strong convex re￾laxations and mixed-integer programming for￾mulations for trained neural networks”. In:
(Nov. 2018). arXiv: 1811.01988 [math.OC].
[Ani+20] R. Anil, V. Gupta, T. Koren, K. Regan,
and Y. Singer. “Scalable Second Order Opti￾mization for Deep Learning”. In: (Feb. 2020).
arXiv: 2002.09018 [cs.LG].
[Ans73] F. J. Anscombe. “Graphs in Statistical Anal￾ysis”. In: Am. Stat. 27.1 (1973), pp. 17–21.
[AO03] J.-H. Ahn and J.-H. Oh. “A Constrained
EM Algorithm for Principal Component Anal￾ysis”. In: Neural Computation 15 (2003),
pp. 57–65.
[Arc+19] F. Arcadu, F. Benmansour, A. Maunz, J.
Willis, Z. Haskova, and M. Prunotto. “Deep
learning algorithm predicts diabetic retinopa￾thy progression in individual patients”. en. In:
NPJ Digit Med 2 (Sept. 2019), p. 92.
[Ard+20] R. Ardila et al. “Common Voice: A Massively￾Multilingual Speech Corpus”. In: Proceedings
of The 12th Language Resources and Evalu￾ation Conference. 2020, pp. 4218–4222.
[Arj21] M. Arjovsky. “Out of Distribution Generaliza￾tion in Machine Learning”. In: (Mar. 2021).
arXiv: 2103.02667 [stat.ML].
[Arn+19] S. M. R. Arnold, P.-A. Manzagol, R. Ba￾banezhad, I. Mitliagkas, and N. Le Roux. “Re￾ducing the variance in online optimization by
transporting past gradients”. In: NIPS. 2019.
[Aro+16] S. Arora, Y. Li, Y. Liang, T. Ma, and A. Ris￾teski. “A Latent Variable Model Approach to
PMI-based Word Embeddings”. In: TACL 4
(Dec. 2016), pp. 385–399.
[Aro+19] L. Aroyo, A. Dumitrache, O. Inel, Z. Szlávik,
B. Timmermans, and C. Welty. “Crowdsourc￾ing Inclusivity: Dealing with Diversity of
Opinions, Perspectives and Ambiguity in An￾notated Data”. In: WWW. WWW ’19. San
Francisco, USA: Association for Computing
Machinery, May 2019, pp. 1294–1295.
[Aro+21] R. Arora et al. Theory of deep learning.
2021.
[ARZP19] R. Al-Rfou, D. Zelle, and B. Perozzi.
“DDGK: Learning Graph Representations for
Deep Divergence Graph Kernels”. In: Proceed￾ings of the 2019 World Wide Web Confer￾ence on World Wide Web (2019).
[AS17] A. Achille and S. Soatto. “On the Emergence
of Invariance and Disentangling in Deep Rep￾resentations”. In: (June 2017). arXiv: 1706 .
01350 [cs.LG].
[AS19] A. Achille and S. Soatto. “Where is the Infor￾mation in a Deep Neural Network?” In: (May
2019). arXiv: 1905.12213 [cs.LG].
[Ash18] J. Asher. “A Rise in Murder? Let’s Talk
About the Weather”. In: The New York
Times (Sept. 2018).
[ASR15] A. Ali, S. M. Shamsuddin, and A. L. Ralescu.
“Classification with class imbalance problem:
A Review”. In: Int. J. Advance Soft Compu.
Appl 7.3 (2015).
[Ath+19] B. Athiwaratkun, M. Finzi, P. Izmailov, and
A. G. Wilson. “There Are Many Consistent
Explanations of Unlabeled Data: Why You
Should Average”. In: ICLR. 2019.
[AV07] D. Arthur and S. Vassilvitskii. “k-means++:
the advantages of careful seeding”. In: Proc.
18th ACM-SIAM symp. on Discrete algo￾rithms. 2007, 1027–1035.
[AWS19] E. Amid, M. K. Warmuth, and S. Srini￾vasan. “Two-temperature logistic regression
based on the Tsallis divergence”. In: AIS￾TATS. 2019.
[Axl15] S. Axler. Linear algebra done right. 2015.
[BA10] R. Bailey and J. Addison. A Smoothed￾Distribution Form of Nadaraya-Watson Es￾timation. Tech. rep. 10-30. Univ. Birming￾ham, 2010.
[BA97a] A. Bowman and A. Azzalini. Applied Smooth￾ing Techniques for Data Analysis. Oxford,
1997.
[BA97b] L. A. Breslow and D. W. Aha. “Simplifying
decision trees: A survey”. In: Knowl. Eng.
Rev. 12.1 (Jan. 1997), pp. 1–40.
[Bab19] S. Babu. A 2019 guide to Human Pose Esti￾mation with Deep Learning. 2019.
[Bac+16] O. Bachem, M. Lucic, H. Hassani, and A.
Krause. “Fast and Provably Good Seedings
for k-Means”. In: NIPS. 2016, pp. 55–63.
[Bah+12] B. Bahmani, B. Moseley, A. Vattani, R.
Kumar, and S. Vassilvitskii. “Scalable k￾Means++”. In: VLDB. 2012.
[Bah+20] Y. Bahri, J. Kadmon, J. Pennington, S.
Schoenholz, J. Sohl-Dickstein, and S. Gan￾guli. “Statistical Mechanics of Deep Learn￾ing”. In: Annu. Rev. Condens. Matter Phys.
(Mar. 2020).
[BAP14] P. Bachman, O. Alsharif, and D. Precup.
“Learning with pseudo-ensembles”. In: Ad￾vances in neural information processing sys￾tems. 2014, pp. 3365–3373.
[Bar09] M. Bar. “The proactive brain: memory for pre￾dictions”. en. In: Philos. Trans. R. Soc. Lond.
B Biol. Sci. 364.1521 (May 2009), pp. 1235–
1243.
[Bar19] J. T. Barron. “A General and Adaptive Ro￾bust Loss Function”. In: CVPR. 2019.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 795
[Bat+18] P. W. Battaglia et al. “Relational inductive
biases, deep learning, and graph networks”.
In: arXiv preprint arXiv:1806.01261 (2018).
[BB08] O. Bousquet and L. Bottou. “The Tradeoffs
of Large Scale Learning”. In: NIPS. 2008,
pp. 161–168.
[BB11] L. Bottou and O. Bousquet. “The Tradeoffs of
Large Scale Learning”. In: Optimization for
Machine Learning. Ed. by S. Sra, S. Nowozin,
and S. J. Wright. MIT Press, 2011, pp. 351–
368.
[BBV11] R. Benassi, J. Bect, and E. Vazquez.
“Bayesian optimization using sequential
Monte Carlo”. In: (Nov. 2011). arXiv: 1111 .
4802 [math.OC].
[BC17] D. Beck and T. Cohn. “Learning Kernels over
Strings using Gaussian Processes”. In: Pro￾ceedings of the Eighth International Joint
Conference on Natural Language Process￾ing (Volume 2: Short Papers). Vol. 2. 2017,
pp. 67–73.
[BCB15] D. Bahdanau, K. Cho, and Y. Bengio. “Neu￾ral Machine Translation by Jointly Learning
to Align and Translate”. In: ICLR. 2015.
[BCD01] L. Brown, T. Cai, and A. DasGupta. “Inter￾val Estimation for a Binomial Proportion”. In:
Statistical Science 16.2 (2001), pp. 101–133.
[BCN18] L. Bottou, F. E. Curtis, and J. Nocedal.
“Optimization Methods for Large-Scale Ma￾chine Learning”. In: SIAM Rev. 60.2 (2018),
pp. 223–311.
[BCV13] Y. Bengio, A. Courville, and P. Vincent.
“Representation learning: a review and new
perspectives”. en. In: IEEE PAMI 35.8 (Aug.
2013), pp. 1798–1828.
[BD21] D. G. T. Barrett and B. Dherin. “Implicit
Gradient Regularization”. In: ICLR. 2021.
[BD87] G. Box and N. Draper. Empirical Model￾Building and Response Surfaces. Wiley,
1987.
[BDEL03] S. Ben-David, N. Eiron, and P. M. Long.
“On the difficulty of approximately maximiz￾ing agreements”. In: J. Comput. System Sci.
66.3 (May 2003), pp. 496–514.
[Ben+04a] Y. Bengio, O. Delalleau, N. Roux, J.
Paiement, P. Vincent, and M. Ouimet.
“Learning eigenfunctions links spectral em￾bedding and kernel PCA”. In: Neural Com￾putation 16 (2004), pp. 2197–2219.
[Ben+04b] Y. Bengio, J.-F. Paiement, P. Vincent,
O. Delalleau, N. L. Roux, and M. Ouimet.
“Out-of-Sample Extensions for LLE, Isomap,
MDS, Eigenmaps, and Spectral Clustering”.
In: NIPS. MIT Press, 2004, pp. 177–184.
[Ben+15a] S. Bengio, O. Vinyals, N. Jaitly, and N.
Shazeer. “Scheduled Sampling for Sequence
Prediction with Recurrent Neural Networks”.
In: NIPS. 2015.
[Ben+15b] Y. Bengio, D.-H. Lee, J. Bornschein, T.
Mesnard, and Z. Lin. “Towards Biologically
Plausible Deep Learning”. In: (2015). arXiv:
1502.04156 [cs.LG].
[Ben+17] A. Benavoli, G. Corani, J. Demsar, and
M. Zaffalon. “Time for a change: a tuto￾rial for comparing multiple classifiers through
Bayesian analysis”. In: JMLR (2017).
[Ber15] D. Bertsekas. Convex Optimization Algo￾rithms. Athena Scientific, 2015.
[Ber16] D. Bertsekas. Nonlinear Programming.
Third. Athena Scientific, 2016.
[Ber+19a] D. Berthelot, N. Carlini, I. Goodfellow,
N. Papernot, A. Oliver, and C. Raffel.
“Mixmatch: A holistic approach to semi￾supervised learning”. In: Advances in Neu￾ral Information Processing Systems. 2019,
pp. 5049–5059.
[Ber+19b] D. Berthelot et al. “Remixmatch: Semi￾supervised learning with distribution align￾ment and augmentation anchoring”. In: arXiv
preprint arXiv:1911.09785 (2019).
[Ber+21] J. Berner, P. Grohs, G. Kutyniok, and P. Pe￾tersen. “The Modern Mathematics of Deep
Learning”. In: (May 2021). arXiv: 2105.04026
[cs.LG].
[Ber85] J. Berger. “Bayesian Salesmanship”. In:
Bayesian Inference and Decision Tech￾niques with Applications: Essays in Honor
of Bruno deFinetti. Ed. by P. K. Goel and A.
Zellner. North-Holland, 1985.
[Ber99] D. Bertsekas. Nonlinear Programming. Sec￾ond. Athena Scientific, 1999.
[Bey+19] M. Beyeler, E. L. Rounds, K. D. Carlson, N.
Dutt, and J. L. Krichmar. “Neural correlates
of sparse coding and dimensionality reduc￾tion”. en. In: PLoS Comput. Biol. 15.6 (June
2019), e1006908.
[Bey+20] L. Beyer, O. J. Hénaff, A. Kolesnikov, X.
Zhai, and A. van den Oord. “Are we done
with ImageNet?” In: (June 2020). arXiv: 2006.
07159 [cs.CV].
[BFO84] L. Breiman, J. Friedman, and R. Ol￾shen. Classification and regression trees.
Wadsworth, 1984.
[BG11] P. Buhlmann and S. van de Geer. Statistics
for High-Dimensional Data: Methodology,
Theory and Applications. Springer, 2011.
[BH07] P. Buhlmann and T. Hothorn. “Boosting
Algorithms: Regularization, Prediction and
Model Fitting”. In: Statistical Science 22.4
(2007), pp. 477–505.
[BH69] A. Bryson and Y.-C. Ho. Applied optimal
control: optimization, estimation, and con￾trol. Blaisdell Publishing Company, 1969.
[BH86] J. Barnes and P. Hut. “A hierarchical O(N
log N) force-calculation algorithm”. In: Na￾ture 324.6096 (Dec. 1986), pp. 446–449.
[BH89] P. Baldi and K. Hornik. “Neural networks and
principal components analysis: Learning from
examples without local minima”. In: Neural
Networks 2 (1989), pp. 53–58.
[Bha+19] A. Bhadra, J. Datta, N. G. Polson, and B. T.
Willard. “Lasso Meets Horseshoe: a survey”.
In: Bayesian Anal. 34.3 (2019), pp. 405–427.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license796 BIBLIOGRAPHY
[Bha+20] A. Bhadra, J. Datta, Y. Li, and N. Polson.
“Horseshoe regularisation for machine learn￾ing in complex and deep models”. en. In: Int.
Stat. Rev. 88.2 (Aug. 2020), pp. 302–320.
[BHM92] J. S. Bridle, A. J. Heading, and D. J. MacKay.
“Unsupervised Classifiers, Mutual Informa￾tion and’Phantom Targets”. In: Advances in
neural information processing systems. 1992,
pp. 1096–1101.
[BI19] P. Barham and M. Isard. “Machine Learning
Systems are Stuck in a Rut”. In: Proceedings
of the Workshop on Hot Topics in Operating
Systems. HotOS ’19. Bertinoro, Italy: Asso￾ciation for Computing Machinery, May 2019,
pp. 177–183.
[Bis06] C. Bishop. Pattern recognition and machine
learning. Springer, 2006.
[Bis94] C. M. Bishop. Mixture Density Networks.
Tech. rep. NCRG 4288. Neural Computing
Research Group, Department of Computer
Science, Aston University, 1994.
[Bis99] C. Bishop. “Bayesian PCA”. In: NIPS. 1999.
[BJ05] F. Bach and M. Jordan. A probabilistic inter￾pretation of canonical correlation analysis.
Tech. rep. 688. U. C. Berkeley, 2005.
[BJM06] P. Bartlett, M. Jordan, and J. McAuliffe.
“Convexity, Classification, and Risk Bounds”.
In: JASA 101.473 (2006), pp. 138–156.
[BK07] R. M. Bell and Y. Koren. “Lessons from the
Netflix Prize Challenge”. In: SIGKDD Ex￾plor. Newsl. 9.2 (Dec. 2007), pp. 75–79.
[BK20] E. M. Bender and A. Koller. “Climbing to￾wards NLU: On Meaning, Form, and Under￾standing in the Age of Data”. In: Proc. ACL.
Online, July 2020, pp. 5185–5198.
[BKC17] V. Badrinarayanan, A. Kendall, and R.
Cipolla. “SegNet: A Deep Convolutional
Encoder-Decoder Architecture for Image Seg￾mentation”. In: IEEE PAMI 39.12 (2017).
[BKH16] J. L. Ba, J. R. Kiros, and G. E. Hinton. “Layer
Normalization”. In: (2016). arXiv: 1607.06450
[stat.ML].
[BKL10] S. Bird, E. Klein, and E. Loper. Natural
Language Processing with Python: Analyz￾ing Text with the Natural Language Toolkit.
2010.
[BL04] P. Bickel and E. Levina. “Some theory for
Fisher’s linear discriminant function, "Naive
Bayes", and some alternatives when there are
many more variables than observations”. In:
Bernoulli 10 (2004), pp. 989–1010.
[BL07] J. A. Bullinaria and J. P. Levy. “Extract￾ing semantic representations from word co￾occurrence statistics: a computational study”.
en. In: Behav. Res. Methods 39.3 (Aug.
2007), pp. 510–526.
[BL12] J. A. Bullinaria and J. P. Levy. “Extract￾ing semantic representations from word co￾occurrence statistics: stop-lists, stemming,
and SVD”. en. In: Behav. Res. Methods 44.3
(Sept. 2012), pp. 890–907.
[BL88] D. S. Broomhead and D Lowe. “Multivariable
Functional Interpolation and Adaptive Net￾works”. In: Complex Systems (1988).
[BLK17] O. Bachem, M. Lucic, and A. Krause. “Dis￾tributed and provably good seedings for k￾means in constant rounds”. In: ICML. 2017,
pp. 292–300.
[Blo20] M. Blondel. Automatic differentiation. 2020.
[BLV19] X. Bouthillier, C. Laurent, and P. Vincent.
“Unreproducible Research is Reproducible”.
In: ICML. Vol. 97. Proceedings of Machine
Learning Research. Long Beach, California,
USA: PMLR, 2019, pp. 725–734.
[BM98] A. Blum and T. Mitchell. “Combining la￾beled and unlabeled data with co-training”.
In: Proceedings of the eleventh annual con￾ference on Computational learning theory.
1998, pp. 92–100.
[BN01] M. Belkin and P. Niyogi. “Laplacian Eigen￾maps and Spectral Techniques for Embedding
and Clustering”. In: NIPS. 2001, pp. 585–591.
[BNJ03] D. Blei, A. Ng, and M. Jordan. “Latent Dirich￾let allocation”. In: JMLR 3 (2003), pp. 993–
1022.
[Bo+08] L. Bo, C. Sminchisescu, A. Kanaujia, and D.
Metaxas. “Fast Algorithms for Large Scale
Conditional 3D Prediction”. In: CVPR. 2008.
[Boh92] D. Bohning. “Multinomial logistic regression
algorithm”. In: Annals of the Inst. of Statis￾tical Math. 44 (1992), pp. 197–200.
[Bon13] S. Bonnabel. “Stochastic gradient descent
on Riemannian manifolds”. In: IEEE Trans￾actions on Automatic Control 58.9 (2013),
pp. 2217–2229.
[Bos+16] D. Boscaini, J. Masci, E. Rodolà, and M.
Bronstein. “Learning shape correspondence
with anisotropic convolutional neural net￾works”. In: Advances in Neural Information
Processing Systems. 2016, pp. 3189–3197.
[Bot+13] L. Bottou et al. “Counterfactual Reasoning
and Learning Systems: The Example of Com￾putational Advertising”. In: JMLR 14 (2013),
pp. 3207–3260.
[Bow+15] S. R. Bowman, G. Angeli, C. Potts, and C. D.
Manning. “A large annotated corpus for learn￾ing natural language inference”. In: EMNLP.
Lisbon, Portugal: Association for Computa￾tional Linguistics, Sept. 2015, pp. 632–642.
[BPC20] I. Beltagy, M. E. Peters, and A. Cohan.
“Longformer: The Long-Document Trans￾former”. In: CoRR abs/2004.05150 (2020).
arXiv: 2004.05150.
[Bre01] L. Breiman. “Random Forests”. In: Machine
Learning 45.1 (2001), pp. 5–32.
[Bre96] L. Breiman. “Bagging predictors”. In: Ma￾chine Learning 24 (1996), pp. 123–140.
[Bri50] G. W. Brier. “Verification of forecasts ex￾pressed in terms of probability”. In: Monthly
Weather Review 78.1 (Jan. 1950), pp. 1–3.
[Bri90] J. Bridle. “Probabilistic Interpretation of
Feedforward Classification Network Outputs,
with Relationships to Statistical Pattern
Recognition”. In: Neurocomputing: Algo￾Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 797
rithms, Architectures and Applications. Ed.
by F. F. Soulie and J. Herault. Springer Ver￾lag, 1990, pp. 227–236.
[Bro+17a] M. M. Bronstein, J Bruna, Y LeCun,
A Szlam, and P Vandergheynst. “Geomet￾ric Deep Learning: Going beyond Euclidean
data”. In: IEEE Signal Process. Mag. 34.4
(July 2017), pp. 18–42.
[Bro+17b] M. M. Bronstein, J. Bruna, Y. LeCun, A.
Szlam, and P. Vandergheynst. “Geometric
deep learning: going beyond euclidean data”.
In: IEEE Signal Processing Magazine 34.4
(2017), pp. 18–42.
[Bro19] J. Brownlee. Deep Learning for Computer
Vision - Machine Learning Mastery. Ac￾cessed: 2020-6-30. Machine Learning Mastery,
Feb. 2019.
[Bro+20] T. B. Brown et al. “Language Models are
Few-Shot Learners”. In: (May 2020). arXiv:
2005.14165 [cs.CL].
[Bro+21] A. Brock, S. De, S. L. Smith, and K. Si￾monyan. “High-Performance Large-Scale Im￾age Recognition Without Normalization”. In:
(Feb. 2021). arXiv: 2102.06171 [cs.CV].
[BRR18] T. D. Bui, S. Ravi, and V. Ramavajjala. “Neu￾ral Graph Machines: Learning Neural Net￾works Using Graphs”. In: WSDM. 2018.
[Bru+14] J. Bruna, W. Zaremba, A. Szlam, and Y. Le￾cun. “Spectral networks and locally connected
networks on graphs International Conference
on Learning Representations (ICLR2014)”. In:
CBLS, April (2014).
[Bru+19] G. Brunner, Y. Liu, D. Pascual, O. Richter,
and R. Wattenhofer. “On the Validity of
Self-Attention as Explanation in Transformer
Models”. In: (Aug. 2019). arXiv: 1908.04211
[cs.CL].
[BS02] M. Balasubramanian and E. L. Schwartz.
“The isomap algorithm and topological sta￾bility”. en. In: Science 295.5552 (Jan. 2002),
p. 7.
[BS16] P. Baldi and P. Sadowski. “A Theory of Lo￾cal Learning, the Learning Channel, and the
Optimality of Backpropagation”. In: Neural
Netw. 83 (2016), pp. 51–74.
[BS17] D. M. Blei and P. Smyth. “Science and data
science”. en. In: Proc. Natl. Acad. Sci. U. S.
A. (Aug. 2017).
[BS94] J. Bernardo and A. Smith. Bayesian Theory.
John Wiley, 1994.
[BS97] A. J. Bell and T. J. Sejnowski. “The “indepen￾dent components” of natural scenes are edge
filters”. en. In: Vision Res. 37.23 (Dec. 1997),
pp. 3327–3338.
[BT08] D. Bertsekas and J. Tsitsiklis. Introduction
to Probability. 2nd Edition. Athena Scientific,
2008.
[BT09] A Beck and M Teboulle. “A Fast Iterative
Shrinkage-Thresholding Algorithm for Linear
Inverse Problems”. In: SIAM J. Imaging Sci.
2.1 (Jan. 2009), pp. 183–202.
[BT73] G. Box and G. Tiao. Bayesian inference in
statistical analysis. Addison-Wesley, 1973.
[Bul11] A. D. Bull. “Convergence rates of efficient
global optimization algorithms”. In: JMLR 12
(2011), 2879–2904.
[Bur10] C. J. C. Burges. “Dimension Reduction:
A Guided Tour”. en. In: Foundations and
Trends in Machine Learning (July 2010).
[BV04] S. Boyd and L. Vandenberghe. Convex opti￾mization. Cambridge, 2004.
[BW08] P. L. Bartlett and M. H. Wegkamp. “Classifi￾cation with a Reject Option using a Hinge
Loss”. In: JMLR 9.Aug (2008), pp. 1823–
1840.
[BW88] J. Berger and R. Wolpert. The Likelihood
Principle. 2nd edition. The Institute of Math￾ematical Statistics, 1988.
[BWL19] Y. Bai, Y.-X. Wang, and E. Liberty. “Prox￾Quant: Quantized Neural Networks via Prox￾imal Operators”. In: ICLR. 2019.
[BY03] P. Buhlmann and B. Yu. “Boosting with the
L2 loss: Regression and classification”. In:
JASA 98.462 (2003), pp. 324–339.
[Byr+16] R Byrd, S Hansen, J Nocedal, and Y
Singer. “A Stochastic Quasi-Newton Method
for Large-Scale Optimization”. In: SIAM J.
Optim. 26.2 (Jan. 2016), pp. 1008–1031.
[BZ20] A. Barbu and S.-C. Zhu. Monte Carlo Meth￾ods. en. Springer, 2020.
[Cal20] O. Calin. Deep Learning Architectures: A
Mathematical Approach. en. 1st ed. Springer,
Feb. 2020.
[Cao+18] Z. Cao, G. Hidalgo, T. Simon, S.-E. Wei,
and Y. Sheikh. “OpenPose: Realtime Multi￾Person 2D Pose Estimation using Part Affin￾ity Fields”. In: (Dec. 2018). arXiv: 1812.08008
[cs.CV].
[CAS16] P. Covington, J. Adams, and E. Sargin. “Deep
Neural Networks for YouTube Recommenda￾tions”. In: Proceedings of the 10th ACM
Conference on Recommender Systems. Rec￾Sys ’16. Boston, Massachusetts, USA: Associ￾ation for Computing Machinery, Sept. 2016,
pp. 191–198.
[CB02] G. Casella and R. Berger. Statistical infer￾ence. 2nd edition. Duxbury, 2002.
[CBD15] M. Courbariaux, Y. Bengio, and J.-P. David.
“BinaryConnect: Training Deep Neural Net￾works with binary weights during propaga￾tions”. In: NIPS. 2015.
[CC07] H. Choi and S. Choi. “Robust kernel Isomap”.
In: Pattern Recognit. 40.3 (Mar. 2007),
pp. 853–862.
[CCD17] B. P. Chamberlain, J. Clough, and M. P.
Deisenroth. “Neural embeddings of graphs
in hyperbolic space”. In: arXiv preprint
arXiv:1705.10359 (2017).
[CD14] K. Chaudhuri and S. Dasgupta. “Rates of
Convergence for Nearest Neighbor Classifica￾tion”. In: NIPS. 2014.
[CD88] W. Cleveland and S. Devlin. “Locally￾Weighted Regression: An Approach to Regres￾sion Analysis by Local Fitting”. In: JASA
83.403 (1988), pp. 596–610.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license798 BIBLIOGRAPHY
[CDL16] J. Cheng, L. Dong, and M. Lapata. “Long
Short-Term Memory-Networks for Machine
Reading”. In: EMNLP. Association for Com￾putational Linguistics, Nov. 2016, pp. 551–
561.
[CDL19] S. Chen, E. Dobriban, and J. H. Lee. “Invari￾ance reduces Variance: Understanding Data
Augmentation in Deep Learning and Beyond”.
In: (July 2019). arXiv: 1907.10905 [stat.ML].
[CDS02] M. Collins, S. Dasgupta, and R. E. Schapire.
“A Generalization of Principal Components
Analysis to the Exponential Family”. In:
NIPS-14. 2002.
[CEL19] Z. Chen, J. B. Estrach, and L. Li. “Super￾vised community detection with line graph
neural networks”. In: 7th International Con￾ference on Learning Representations, ICLR
2019. 2019.
[Cer+17] D. Cer, M. Diab, E. Agirre, I. Lopez-Gazpio,
and L. Specia. “SemEval-2017 Task 1: Se￾mantic Textual Similarity Multilingual and
Crosslingual Focused Evaluation”. In: Proc.
11th Intl. Workshop on Semantic Evaluation
(SemEval-2017). Vancouver, Canada: Asso￾ciation for Computational Linguistics, Aug.
2017, pp. 1–14.
[CFD10] Y. Cui, X. Z. Fern, and J. G. Dy. “Learn￾ing Multiple Nonredundant Clusterings”. In:
ACM Transactions on Knowledge Discovery
from Data 4.3 (2010).
[CG16] T. Chen and C. Guestrin. “XGBoost: A Scal￾able Tree Boosting System”. In: KDD. ACM,
2016, pp. 785–794.
[CG18] J. Chen and Q. Gu. “Closing the Generaliza￾tion Gap of Adaptive Gradient Methods in
Training Deep Neural Networks”. In: (June
2018). arXiv: 1806.06763 [cs.LG].
[CGG17] S. E. Chazan, J. Goldberger, and S. Gannot.
“Speech Enhancement using a Deep Mixture
of Experts”. In: (2017). arXiv: 1703 . 09302
[cs.SD].
[CGW21] W. Chen, X. Gong, and Z. Wang. “Neural Ar￾chitecture Search on ImageNet in Four GPU
Hours: A Theoretically Inspired Perspective”.
In: ICLR. Feb. 2021.
[CH67] T. Cover and P. Hart. “ Nearest neighbor pat￾tern classification”. In: IEEE Trans. Inform.
Theory 13.1 (1967), pp. 21–27.
[CH90] K. W. Church and P. Hanks. “Word Associ￾ation Norms, Mutual Information, and Lex￾icography”. In: Computational Linguistics
(1990).
[Cha+01] O. Chapelle, J. Weston, L. Bottou, and
V. Vapnik. “Vicinal Risk Minimization”. In:
NIPS. MIT Press, 2001, pp. 416–422.
[Cha+17] P. Chaudhari et al. “Entropy-SGD: Bias￾ing Gradient Descent Into Wide Valleys”. In:
ICLR. 2017.
[Cha+19a] I. Chami, Z. Ying, C. Ré, and J. Leskovec.
“Hyperbolic graph convolutional neural net￾works”. In: Advances in Neural Information
Processing Systems. 2019, pp. 4869–4880.
[Cha+19b] J. J. Chandler, I. Martinez, M. M. Finu￾cane, J. G. Terziev, and A. M. Resch. “Speak￾ing on Data’s Behalf: What Researchers Say
and How Audiences Choose”. en. In: Eval.
Rev. (Mar. 2019), p. 193841X19834968.
[Cha+21] I. Chami, S. Abu-El-Haija, B. Perozzi, C.
Ré, and K. Murphy. “Machine Learning on
Graphs: A Model and Comprehensive Taxon￾omy”. In: JMLR (2021).
[Che+16] H.-T. Cheng et al. “Wide & Deep Learning
for Recommender Systems”. In: (June 2016).
arXiv: 1606.07792 [cs.LG].
[Che+20a] T. Chen, S. Kornblith, M. Norouzi, and
G. Hinton. “A Simple Framework for Con￾trastive Learning of Visual Representations”.
In: ICML. 2020.
[Che+20b] T. Chen, S. Kornblith, M. Norouzi, and G.
Hinton. “A simple framework for contrastive
learning of visual representations”. In: ICML.
2020.
[Che+20c] T. Chen, S. Kornblith, K. Swersky, M.
Norouzi, and G. Hinton. “Big Self-Supervised
Models are Strong Semi-Supervised Learners”.
In: NIPS. 2020.
[Chi+19a] W.-L. Chiang, X. Liu, S. Si, Y. Li, S. Ben￾gio, and C.-J. Hsieh. “Cluster-GCN: An Effi￾cient Algorithm for Training Deep and Large
Graph Convolutional Networks”. In: ACM
SIGKDD Conference on Knowledge Discov￾ery and Data Mining (KDD). 2019.
[Chi+19b] R. Child, S. Gray, A. Radford, and I.
Sutskever. “Generating Long Sequences
with Sparse Transformers”. In: CoRR
abs/1904.10509 (2019). arXiv: 1904.10509.
[CHL05] S. Chopra, R. Hadsell, and Y. LeCun. “Learn￾ing a Similarity Metric Discriminatively, with
Application to Face Verification”. en. In:
CVPR. 2005.
[Cho+14a] K. Cho, B. Van Merriënboer, D. Bah￾danau, and Y. Bengio. “On the proper￾ties of neural machine translation: Encoder￾decoder approaches”. In: arXiv preprint
arXiv:1409.1259 (2014).
[Cho+14b] K. Cho et al. “Learning Phrase Represen￾tations using RNN Encoder-Decoder for Sta￾tistical Machine Translation”. In: EMNLP.
2014.
[Cho+15] Y. Chow, A. Tamar, S. Mannor, and M.
Pavone. “Risk-Sensitive and Robust Decision￾Making: a CVaR Optimization Approach”. In:
NIPS. 2015, pp. 1522–1530.
[Cho17] F. Chollet. Deep learning with Python. Man￾ning, 2017.
[Cho+19] K. Choromanski, M. Rowland, W. Chen, and
A. Weller. “Unifying Orthogonal Monte Carlo
Methods”. In: Proceedings of the 36th In￾ternational Conference on Machine Learn￾ing, ICML 2019, 9-15 June 2019, Long
Beach, California, USA. Ed. by K. Chaud￾huri and R. Salakhutdinov. Vol. 97. Proceed￾ings of Machine Learning Research. PMLR,
2019, pp. 1203–1212.
[Cho+20a] K. Choromanski et al. “Masked Language
Modeling for Proteins via Linearly Scalable
Long-Context Transformers”. In: (June 2020).
arXiv: 2006.03555 [cs.LG].
[Cho+20b] K. Choromanski et al. “Rethinking
Attention with Performers”. In: CoRR
abs/2009.14794 (2020). arXiv: 2009.14794.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 799
[Cho21] F. Chollet. Deep learning with Python (sec￾ond edition). Manning, 2021.
[Chr20] B. Christian. The Alignment Problem: Ma￾chine Learning and Human Values. en.
1st ed. W. W. Norton & Company, Oct. 2020.
[Chu+15] J. Chung, K. Kastner, L. Dinh, K. Goel, A.
Courville, and Y. Bengio. “A Recurrent La￾tent Variable Model for Sequential Data”. In:
NIPS. 2015.
[Chu97] F. Chung. Spectral Graph Theory. AMS,
1997.
[Cir+10] D. C. Ciresan, U. Meier, L. M. Gambardella,
and J. Schmidhuber. “Deep Big Simple Neu￾ral Nets For Handwritten Digit Recogni￾tion”. In: Neural Computation 22.12 (2010),
pp. 3207–3220.
[Cir+11] D. C. Ciresan, U. Meier, J. Masci, L. M. Gam￾bardella, and J. Schmidhuber. “Flexible, High
Performance Convolutional Neural Networks
for Image Classification”. In: IJCAI. 2011.
[CL96] B. P. Carlin and T. A. Louis. Bayes and
Empirical Bayes Methods for Data Analysis.
Chapman and Hall, 1996.
[Cla21] A. Clayton. Bernoulli’s Fallacy: Statistical
Illogic and the Crisis of Modern Science. en.
Columbia University Press, Aug. 2021.
[CLX15] S. Cao, W. Lu, and Q. Xu. “Grarep: Learning
graph representations with global structural
information”. In: Proceedings of the 24th
ACM International on Conference on Infor￾mation and Knowledge Management. ACM.
2015, pp. 891–900.
[CNB17] C. Chelba, M. Norouzi, and S. Bengio. “N￾gram Language Modeling using Recurrent
Neural Network Estimation”. In: (Mar. 2017).
arXiv: 1703.10724 [cs.CL].
[Coh+17] G. Cohen, S. Afshar, J. Tapson, and A. van
Schaik. “EMNIST: an extension of MNIST to
handwritten letters”. In: (Feb. 2017). arXiv:
1702.05373 [cs.CV].
[Coh94] J. Cohen. “The earth is round (p < .05)”. In:
American Psychologist 49.12 (1994), pp. 997–
1003.
[Con+17] A. Conneau, D. Kiela, H. Schwenk, L. Bar￾rault, and A. Bordes. “Supervised learning
of universal sentence representations from
natural language inference data”. In: arXiv
preprint arXiv:1705.02364 (2017).
[Coo05] J. Cook. Exact Calculation of Beta Inequal￾ities. Tech. rep. M. D. Anderson Cancer Cen￾ter, Dept. Biostatistics, 2005.
[Cor+16] C. Cortes, X. Gonzalvo, V. Kuznetsov, M.
Mohri, and S. Yang. “AdaNet: Adaptive
Structural Learning of Artificial Neural Net￾works”. In: (July 2016). arXiv: 1607 . 01097
[cs.LG].
[CP10] M. A. Carreira-Perpinan. “The Elastic Em￾bedding Algorithm for Dimensionality Reduc￾tion”. In: ICML. 2010.
[CP19] A. Coenen and A. Pearce. Understanding
UMAP. 2019.
[CPS06] K. Chellapilla, S. Puri, and P. Simard.
“High Performance Convolutional Neural Net￾works for Document Processing”. In: 10th
Intl. Workshop on Frontiers in Handwriting
Recognition. 2006.
[CRW17] K. Choromanski, M. Rowland, and A. Weller.
“The Unreasonable Effectiveness of Struc￾tured Random Orthogonal Embeddings”. In:
NIPS. Mar. 2017.
[CS20] F. E. Curtis and K Scheinberg. “Adap￾tive Stochastic Optimization: A Framework
for Analyzing Stochastic Optimization Algo￾rithms”. In: IEEE Signal Process. Mag. 37.5
(Sept. 2020), pp. 32–42.
[Csu17] G. Csurka. “Domain Adaptation for Visual
Applications: A Comprehensive Survey”. In:
Domain Adaptation in Computer Vision
Applications. Ed. by G. Csurka. 2017.
[CT06] T. M. Cover and J. A. Thomas. Elements of
Information Theory. 2nd edition. John Wiley,
2006.
[CT91] T. M. Cover and J. A. Thomas. Elements of
Information Theory. John Wiley, 1991.
[Cub+19] E. D. Cubuk, B. Zoph, D. Mane, V. Vasude￾van, and Q. V. Le. “AutoAugment: Learning
Augmentation Policies from Data”. In: CVPR.
2019.
[CUH16] D.-A. Clevert, T. Unterthiner, and S. Hochre￾iter. “Fast and Accurate Deep Network Learn￾ing by Exponential Linear Units (ELUs)”. In:
ICLR. 2016.
[Cui+19] X. Cui, K. Zheng, L. Gao, B. Zhang, D. Yang,
and J. Ren. “Multiscale Spatial-Spectral Con￾volutional Network with Image-Based Frame￾work for Hyperspectral Imagery Classifica￾tion”. en. In: Remote Sensing 11.19 (Sept.
2019), p. 2220.
[Cur+17] J. D. Curtó et al. “McKernel: A Library for
Approximate Kernel Expansions in Log-linear
Time”. In: (Feb. 2017). arXiv: 1702.08159v14
[cs.LG].
[Cyb89] G. Cybenko. “Approximation by superposi￾tions of a sigmoidal function”. In: Mathe￾matics of Control, Signals, and Systems 2
(1989), 303–331.
[D’A+20] A. D’Amour et al. “Underspecification
Presents Challenges for Credibility in Modern
Machine Learning”. In: (Nov. 2020). arXiv:
2011.03395 [cs.LG].
[Dah+11] G. E. Dahl, D. Yu, L. Deng, and A. Acero.
“Large vocabulary continuous speech recog￾nition with context-dependent DBN-HMMS”.
In: ICASSP. IEEE, 2011, pp. 4688–4691.
[Dai+19] Z. Dai, Z. Yang, Y. Yang, J. G. Car￾bonell, Q. V. Le, and R. Salakhutdinov.
“Transformer-XL: Attentive Language Mod￾els beyond a Fixed-Length Context”. In: Proc.
ACL. 2019, pp. 2978–2988.
[Dao+19] T. Dao, A. Gu, A. J. Ratner, V. Smith, C. De
Sa, and C. Re. “A Kernel Theory of Modern
Data Augmentation”. In: ICML. 2019.
[Dau17] J. Daunizeau. “Semi-analytical approxima￾tions to statistical moments of sigmoid and
softmax mappings of normal variables”. In:
(Mar. 2017). arXiv: 1703.00091 [stat.ML].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license800 BIBLIOGRAPHY
[Day+95] P. Dayan, G. Hinton, R. Neal, and R. Zemel.
“The Helmholtz machine”. In: Neural Net￾works 9.8 (1995).
[DB18] A. Defazio and L. Bottou. “On the Ineffec￾tiveness of Variance Reduced Optimization
for Deep Learning”. In: (Dec. 2018). arXiv:
1812.04529 [cs.LG].
[DBLJ14] A. Defazio, F. Bach, and S. Lacoste-Julien.
“SAGA: A Fast Incremental Gradient Method
With Support for Non-Strongly Convex Com￾posite Objectives”. In: NIPS. Curran Asso￾ciates, Inc., 2014, pp. 1646–1654.
[DDDM04] I Daubechies, M Defrise, and C De Mol.
“An iterative thresholding algorithm for lin￾ear inverse problems with a sparsity con￾straint”. In: Commun. Pure Appl. Math. Ad￾vances in E 57.11 (Nov. 2004), pp. 1413–1457.
[Dee+90] S. Deerwester, S. Dumais, G. Furnas, T. Lan￾dauer, and R. Harshman. “Indexing by Latent
Semantic Analysis”. In: J. of the American
Society for Information Science 41.6 (1990),
pp. 391–407.
[DeG70] M. DeGroot. Optimal Statistical Decisions.
McGraw-Hill, 1970.
[Den+12] J. Deng, J Krause, A. C. Berg, and L. Fei￾Fei. “Hedging your bets: Optimizing accuracy￾specificity trade-offs in large scale visual
recognition”. In: CVPR. June 2012, pp. 3450–
3457.
[Den+14] J. Deng et al. “Large-Scale Object Classifica￾tion using Label Relation Graphs”. In: ECCV.
2014.
[Dev+19] J. Devlin, M.-W. Chang, K. Lee, and K.
Toutanova. “BERT: Pre-training of Deep
Bidirectional Transformers for Language Un￾derstanding”. In: NAACL. 2019.
[DG06] J. Davis and M. Goadrich. “The Relationship
Between Precision-Recall and ROC Curves”.
In: ICML. 2006, pp. 233–240.
[DHM07] P. Diaconis, S. Holmes, and R. Montgomery.
“Dynamical Bias in the Coin Toss”. In: SIAM
Review 49.2 (2007), pp. 211–235.
[DHS01] R. O. Duda, P. E. Hart, and D. G. Stork. Pat￾tern Classification. 2nd edition. Wiley Inter￾science, 2001.
[DHS11] J. Duchi, E. Hazan, and Y. Singer. “Adap￾tive Subgradient Methods for Online Learn￾ing and Stochastic Optimization”. In: JMLR
12 (2011), pp. 2121–2159.
[Die98] T. G. Dietterich. “Approximate Statistical
Tests for Comparing Supervised Classifica￾tion Learning Algorithms”. In: Neural Com￾putation. 10.7 (1998), pp. 1895–1923.
[Din+15] N. Ding, J. Deng, K. Murphy, and H. Neven.
“Probabilistic Label Relation Graphs with
Ising Models”. In: ICCV. 2015.
[DJ15] S. Dray and J. Josse. “Principal component
analysis with missing values: a comparative
survey of methods”. In: Plant Ecol. 216.5
(May 2015), pp. 657–667.
[DKK12] G Dror, N Koenigstein, and Y Koren. “Web￾Scale Media Recommendation Systems”. In:
Proc. IEEE 100.9 (2012), pp. 2722–2736.
[DKS95] J. Dougherty, R. Kohavi, and M. Sahami. “Su￾pervised and Unsupervised Discretization of
Continuous Features”. In: ICML. 1995.
[DLLP97] T. Dietterich, R. Lathrop, and T. Lozano￾Perez. “Solving the multiple instance prob￾lem with axis-parallel rectangles”. In: Artifi￾cial Intelligence 89 (1997), pp. 31–71.
[DLR77] A. P. Dempster, N. M. Laird, and D. B. Ru￾bin. “Maximum likelihood from incomplete
data via the EM algorithm”. In: J. of the
Royal Statistical Society, Series B 34 (1977),
pp. 1–38.
[DM01] D. van Dyk and X.-L. Meng. “The Art of
Data Augmentation”. In: J. Computational
and Graphical Statistics 10.1 (2001), pp. 1–
50.
[DM16] P. Drineas and M. W. Mahoney. “RandNLA:
Randomized Numerical Linear Algebra”. In:
CACM (June 2016).
[Do+19] T.-T. Do, T. Tran, I. Reid, V. Kumar, T.
Hoang, and G. Carneiro. “A Theoretically
Sound Upper Bound on the Triplet Loss for
Improving the Efficiency of Deep Distance
Metric Learning”. In: CVPR. 2019, pp. 10404–
10413.
[Doe16] C. Doersch. “Tutorial on Variational Au￾toencoders”. In: (2016). arXiv: 1606 . 05908
[stat.ML].
[Don95] D. L. Donoho. “De-noising by soft￾thresholding”. In: IEEE Trans. Inf. Theory
41.3 (May 1995), pp. 613–627.
[Dos+21] A. Dosovitskiy et al. “An Image is Worth
16x16 Words: Transformers for Image Recog￾nition at Scale”. In: ICLR. 2021.
[Doy+07] K. Doya, S. Ishii, A. Pouget, and R. P. N.
Rao, eds. Bayesian Brain: Probabilistic Ap￾proaches to Neural Coding. MIT Press, 2007.
[DP97] P. Domingos and M. Pazzani. “On the Op￾timality of the Simple Bayesian Classifier un￾der Zero-One Loss”. In: Machine Learning 29
(1997), pp. 103–130.
[DR21] H. Duanmu and D. M. Roy. “On extended ad￾missibale procedures and their nonstandard
Bayes risk”. In: Annals of Statistics (2021).
[Dri+04] P. Drineas, A. Frieze, R. Kannan, S. Vempala,
and V. Vinay. “Clustering Large Graphs via
the Singular Value Decomposition”. In: Ma￾chine Learning 56 (2004), pp. 9–33.
[DS12] M. Der and L. K. Saul. “Latent Coincidence
Analysis: A Hidden Variable Model for Dis￾tance Metric Learning”. In: NIPS. Curran As￾sociates, Inc., 2012, pp. 3230–3238.
[DSK16] V. Dumoulin, J. Shlens, and M. Kudlur. “A
Learned Representation For Artistic Style”.
In: (2016). arXiv: 1610.07629 [cs.CV].
[Dum+18] A. Dumitrache et al. “Empirical Methodol￾ogy for Crowdsourcing Ground Truth”. In: Se￾mantic Web Journal (Sept. 2018).
[Duv14] D. Duvenaud. “Automatic Model Construc￾tion with Gaussian Processes”. PhD thesis.
Computational and Biological Learning Lab￾oratory, University of Cambridge, 2014.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 801
[DV16] V. Dumoulin and F. Visin. “A guide to con￾volution arithmetic for deep learning”. In:
(2016). arXiv: 1603.07285 [stat.ML].
[EDH19] K. Ethayarajh, D. Duvenaud, and G. Hirst.
“Towards Understanding Linear Word Analo￾gies”. In: Proc. ACL. Association for Com￾putational Linguistics, July 2019, pp. 3253–
3262.
[EF15] D. Eigen and R. Fergus. “Predicting Depth,
Surface Normals and Semantic Labels with a
Common Multi-Scale Convolutional Architec￾ture”. In: ICCV. 2015.
[Efr+04] B. Efron, I. Johnstone, T. Hastie, and R. Tib￾shirani. “Least angle regression”. In: Annals
of Statistics 32.2 (2004), pp. 407–499.
[Efr86] B. Efron. “Why Isn’t Everyone a Bayesian?”
In: The American Statistician 40.1 (1986).
[Ein16] A Einstein. “Die Grundlage der allgemeinen
Relativitätstheorie”. In: Ann. Phys. 354.7
(1916), pp. 769–822.
[Eis19] J. Eisenstein. Introduction to Natural Lan￾guage Processing. 2019.
[Elk03] C. Elkan. “Using the triangle inequality to ac￾celerate k-means”. In: ICML. 2003.
[EMH19] T. Elsken, J. H. Metzen, and F. Hutter. “Neu￾ral Architecture Search: A Survey”. In: JMLR
20 (2019), pp. 1–21.
[Erh+10] D. Erhan, Y. Bengio, A. Courville, P.-A.
Manzagol, P. Vincent, and S. Bengio. “Why
Does Unsupervised Pre-training Help Deep
Learning?” In: JMLR 11 (2010), pp. 625–660.
[FAL17] C. Finn, P. Abbeel, and S. Levine. “Model￾Agnostic Meta-Learning for Fast Adaptation
of Deep Networks”. In: ICML. 2017.
[FB81] M. A. Fischler and R. Bolles. “Random sam￾ple concensus: A paradigm for model fitting
with applications to image analysis and auto￾mated cartography”. In: Comm. ACM 24.6
(1981), pp. 381–395.
[Fen+21] S. Y. Feng et al. “A Survey of Data Augmen￾tation Approaches for NLP”. In: (May 2021).
arXiv: 2105.03075 [cs.CL].
[Fer+10] D. Ferrucci et al. “Building Watson: An
Overview of the DeepQA Project”. In: AI
Magazine (2010), pp. 59–79.
[FH20] E. Fong and C. Holmes. “On the marginal like￾lihood and cross-validation”. In: Biometrika
107.2 (May 2020).
[FHK12] A. Feuerverger, Y. He, and S. Khatri. “Sta￾tistical Significance of the Netflix Challenge”.
In: Stat. Sci. 27.2 (May 2012), pp. 202–231.
[FHT00] J. Friedman, T. Hastie, and R. Tibshirani.
“Additive logistic regression: a statistical view
of boosting”. In: Annals of statistics 28.2
(2000), pp. 337–374.
[FHT10] J. Friedman, T. Hastie, and R. Tibshirani.
“Regularization Paths for Generalized Linear
Models via Coordinate Descent”. In: J. of Sta￾tistical Software 33.1 (2010).
[Fir57] J. Firth. “A synopsis of linguistic theory 1930-
1955”. In: Studies in Linguistic Analysis. Ed.
by F. Palmer. 1957.
[FJ02] M. A. T. Figueiredo and A. K. Jain. “Unsu￾pervised Learning of Finite Mixture Models”.
In: IEEE PAMI 24.3 (2002), pp. 381–396.
[FM03] J. H. Friedman and J. J. Meulman. “Multiple
additive regression trees with application in
epidemiology”. en. In: Stat. Med. 22.9 (May
2003), pp. 1365–1381.
[FMN16] C. Fefferman, S. Mitter, and H. Narayanan.
“Testing the manifold hypothesis”. In: J.
Amer. Math. Soc. 29.4 (Feb. 2016), pp. 983–
1049.
[FNW07] M. Figueiredo, R. Nowak, and S. Wright.
“Gradient projection for sparse reconstruc￾tion: application to compressed sensing and
other inverse problems”. In: IEEE. J. on Se￾lected Topics in Signal Processing (2007).
[For+21] P. Foret, A. Kleiner, H. Mobahi, and B.
Neyshabur. “Sharpness-aware Minimization
for Efficiently Improving Generalization”. In:
ICLR. 2021.
[Fos19] D. Foster. Generative Deep Learning: Teach￾ing Machines to Paint, Write, Compose,
and Play. 1 edition. O’Reilly Media, July
2019.
[FR07] C. Fraley and A. Raftery. “Bayesian Regular￾ization for Normal Mixture Estimation and
Model-Based Clustering”. In: J. of Classifi￾cation 24 (2007), pp. 155–181.
[Fra+17] L. Franceschi, M. Donini, P. Frasconi, and M.
Pontil. “Forward and Reverse Gradient-Based
Hyperparameter Optimization”. In: ICML.
2017.
[Fre98] B. Frey. Graphical Models for Machine
Learning and Digital Communication. MIT
Press, 1998.
[Fri01] J. Friedman. “Greedy Function Approxima￾tion: a Gradient Boosting Machine”. In: An￾nals of Statistics 29 (2001), pp. 1189–1232.
[Fri97a] J. Friedman. “On bias, variance, 0-1 loss
and the curse of dimensionality”. In: J. Data
Mining and Knowledge Discovery 1 (1997),
pp. 55–77.
[Fri97b] J. H. Friedman. “Data mining and statis￾tics: What’s the connection”. In: Proceed￾ings of the 29th Symposium on the Inter￾face Between Computer Science and Statis￾tics. 1997.
[Fri99] J. Friedman. Stochastic Gradient Boosting.
Tech. rep. 1999.
[FS96] Y. Freund and R. R. Schapire. “Experiments
with a new boosting algorithm”. In: ICML.
1996.
[FT05] M. Fashing and C. Tomasi. “Mean shift is
a bound optimization”. en. In: IEEE Trans.
Pattern Anal. Mach. Intell. 27.3 (Mar. 2005),
pp. 471–474.
[Fu98] W. Fu. “Penalized regressions: the bridge ver￾sus the lasso”. In: J. Computational and
graphical statistics 7 (1998), 397– 416.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license802 BIBLIOGRAPHY
[Fuk75] K. Fukushima. “Cognitron: a self-organizing
multilayered neural network”. In: Biological
Cybernetics 20.6 (1975), pp. 121–136.
[Fuk80] K Fukushima. “Neocognitron: a self organiz￾ing neural network model for a mechanism
of pattern recognition unaffected by shift in
position”. en. In: Biol. Cybern. 36.4 (1980),
pp. 193–202.
[Fuk90] K. Fukunaga. Introduction to Statistical
Pattern Recognition. 2nd edition. Academic
Press, 1990.
[Gag94] P. Gage. “A New Algorithm for Data Com￾pression”. In: Dr Dobbs Journal (1994).
[Gan+16] Y Ganin, E Ustinova, H Ajakan, P Germain,
and others. “Domain-adversarial training of
neural networks”. In: JMLR (2016).
[Gao+20] L. Gao et al. “The Pile: An 800GB Dataset
of Diverse Text for Language Modeling”. In:
(Dec. 2020). arXiv: 2101.00027 [cs.CL].
[Gär03] T. Gärtner. “A Survey of Kernels for Struc￾tured Data”. In: SIGKDD Explor. Newsl. 5.1
(July 2003), pp. 49–58.
[Gar+18] J. Gardner, G. Pleiss, K. Q. Weinberger, D.
Bindel, and A. G. Wilson. “GPyTorch: Black￾box Matrix-Matrix Gaussian Process Infer￾ence with GPU Acceleration”. In: NIPS. Ed.
by S Bengio, H Wallach, H Larochelle, K
Grauman, N Cesa-Bianchi, and R Garnett.
Curran Associates, Inc., 2018, pp. 7576–7586.
[GASG18] D. G. A. Smith and J. Gray. “opt-einsum -
A Python package for optimizing contraction
order for einsum-like expressions”. In: JOSS
3.26 (June 2018), p. 753.
[GB05] Y. Grandvalet and Y. Bengio. “Semi￾supervised learning by entropy minimization”.
In: Advances in neural information process￾ing systems. 2005, pp. 529–536.
[GB10] X. Glorot and Y. Bengio. “Understanding the
difficulty of training deep feedforward neural
networks”. In: AISTATS. 2010, pp. 249–256.
[GB18] V. Garcia and J. Bruna. “Few-shot Learning
with Graph Neural Networks”. In: Interna￾tional Conference on Learning Representa￾tions (ICLR). 2018.
[GBB11] X. Glorot, A. Bordes, and Y. Bengio. “Deep
Sparse Rectifer Neural Networks”. In: AIS￾TATS. 2011.
[GBC16] I. Goodfellow, Y. Bengio, and A. Courville.
Deep Learning. http://www.deeplearningbook.
org. MIT Press, 2016.
[GBD92] S. Geman, E. Bienenstock, and R. Dour￾sat. “Neural networks and the bias-variance
dilemma”. In: Neural Computing 4 (1992),
pp. 1–58.
[GC20] A. Gelman and B. Carpenter. “Bayesian anal￾ysis of tests with unknown specificity and sen￾sitivity”. In: J. of Royal Stat. Soc. Series C
medrxiv;2020.05.22.20108944v2 (2020).
[GEB16] L. A. Gatys, A. S. Ecker, and M. Bethge. “Im￾age style transfer using convolutional neural
networks”. In: CVPR. 2016, pp. 2414–2423.
[GEH19] T. Gale, E. Elsen, and S. Hooker. “The State
of Sparsity in Deep Neural Networks”. In:
(Feb. 2019). arXiv: 1902.09574 [cs.LG].
[Gel+04] A. Gelman, J. Carlin, H. Stern, and D. Rubin.
Bayesian data analysis. 2nd edition. Chap￾man and Hall, 2004.
[Gel+14] A. Gelman, J. B. Carlin, H. S. Stern,
D. B. Dunson, A. Vehtari, and D. B. Ru￾bin. Bayesian Data Analysis, Third Edi￾tion. Third edition. Chapman and Hall/CRC,
2014.
[Gel16] A. Gelman. “The problems with p-values are
not just with p-values”. In: American Statis￾tician (2016).
[Gér17] A. Géron. Hands-On Machine Learning
with Scikit-Learn and TensorFlow: Con￾cepts, Tools, and Techniques for Building In￾telligent Systems. en. O’Reilly Media, Incor￾porated, Apr. 2017.
[Gér19] A. Géron. Hands-On Machine Learning
with Scikit-Learn and TensorFlow: Con￾cepts, Tools, and Techniques for Building In￾telligent Systems (2nd edition). en. O’Reilly
Media, Incorporated, 2019.
[GEY19] Y. Geifman and R. El-Yaniv. “SelectiveNet:
A Deep Neural Network with an Integrated
Reject Option”. In: ICML. 2019.
[GG16] Y. Gal and Z. Ghahramani. “Dropout as
a Bayesian Approximation: Representing
Model Uncertainty in Deep Learning”. In:
ICML. 2016.
[GH96] Z. Ghahramani and G. Hinton. The EM Al￾gorithm for Mixtures of Factor Analyzers.
Tech. rep. Dept. of Comp. Sci., Uni. Toronto,
1996.
[GHK17] Y. Gal, J. Hron, and A. Kendall. “Concrete
Dropout”. In: (May 2017). arXiv: 1705.07832
[stat.ML].
[GHV14] A. Gelman, J. Hwang, and A. Vehtari. “Un￾derstanding predictive information criteria
for Bayesian models”. In: Statistics and Com￾puting 24.6 (Nov. 2014), pp. 997–1016.
[Gib97] M. Gibbs. “Bayesian Gaussian Processes for
Regression and Classification”. PhD thesis. U.
Cambridge, 1997.
[Gil+17] J. Gilmer, S. S. Schoenholz, P. F. Riley, O.
Vinyals, and G. E. Dahl. “Neural message
passing for quantum chemistry”. In: ICML.
2017, pp. 1263–1272.
[GIM99] A. Gionis, P. Indyk, and R. Motwani. “Sim￾ilarity Search in High Dimensions via Hash￾ing”. In: Proc. 25th Intl. Conf. on Very Large
Data Bases. VLDB ’99. 1999, pp. 518–529.
[GKS18] V. Gupta, T. Koren, and Y. Singer. “Sham￾poo: Preconditioned Stochastic Tensor Opti￾mization”. In: ICML. 2018.
[GL15] B. Gu and C. Ling. “A New Generalized Er￾ror Path Algorithm for Model Selection”. In:
ICML. 2015.
[GL16] A. Grover and J. Leskovec. “node2vec: Scal￾able feature learning for networks”. In: Pro￾ceedings of the 22nd ACM SIGKDD inter￾national conference on Knowledge discovery
and data mining. ACM. 2016, pp. 855–864.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 803
[GMS05] M. Gori, G. Monfardini, and F. Scarselli. “A
new model for learning in graph domains”.
In: Proceedings. 2005 IEEE International
Joint Conference on Neural Networks, 2005.
Vol. 2. IEEE. 2005, pp. 729–734.
[GNK18] R. A. Güler, N. Neverova, and I. Kokkinos.
“Densepose: Dense human pose estimation in
the wild”. In: CVPR. 2018, pp. 7297–7306.
[God18] P. Godec. Graph Embeddings; The Summary.
https : / / towardsdatascience . com / graph -
embeddings-the-summary-cc6075aba007. 2018.
[GOF18] O. Gouvert, T. Oberlin, and C. Févotte. “Neg￾ative Binomial Matrix Factorization for Rec￾ommender Systems”. In: (Jan. 2018). arXiv:
1801.01708 [cs.LG].
[Gol+01] K. Goldberg, T. Roeder, D. Gupta, and C.
Perkins. “Eigentaste: A Constant Time Col￾laborative Filtering Algorithm”. In: Informa￾tion Retrieval 4.2 (2001), pp. 133–151.
[Gol+05] J. Goldberger, S. Roweis, G. Hinton, and R.
Salakhutdinov. “Neighbourhood Components
Analysis”. In: NIPS. 2005.
[Gol+92] D. Goldberg, D. Nichols, B. M. Oki, and D.
Terry. “Using collaborative filtering to weave
an information tapestry”. In: Commun. ACM
35.12 (Dec. 1992), pp. 61–70.
[Gon85] T. Gonzales. “Clustering to minimize the
maximum intercluster distance”. In: Theor.
Comp. Sci. 38 (1985), pp. 293–306.
[Goo01] N. Goodman. “Classes for fast maximum en￾tropy training”. In: ICASSP. 2001.
[Goo+14] I. J. Goodfellow et al. “Generative Adversar￾ial Networks”. In: NIPS. 2014.
[Gor06] P. F. Gorder. “Neural Networks Show New
Promise for Machine Vision”. In: Computing
in science & engineering 8.6 (2006), pp. 4–8.
[Got+19] A. Gotmare, N. S. Keskar, C. Xiong, and
R. Socher. “A Closer Look at Deep Learning
Heuristics: Learning rate restarts, Warmup
and Distillation”. In: ICLR. 2019.
[GOV18] W Gao, S Oh, and P Viswanath. “Demysti￾fying Fixed k -Nearest Neighbor Information
Estimators”. In: IEEE Trans. Inf. Theory
64.8 (Aug. 2018), pp. 5629–5661.
[GR07] T. Gneiting and A. E. Raftery. “Strictly
Proper Scoring Rules, Prediction, and Esti￾mation”. In: JASA 102.477 (2007), pp. 359–
378.
[GR18] A. Graves and M.-A. Ranzato. “Tutorial on
unsupervised deep learning: part 2”. In: NIPS.
2018.
[Gra04] Y. Grandvalet. “Bagging Equalizes Influence”.
In: Mach. Learn. 55 (2004), pp. 251–270.
[Gra11] A. Graves. “Practical variational inference
for neural networks”. In: Advances in neu￾ral information processing systems. 2011,
pp. 2348–2356.
[Gra13] A. Graves. “Generating Sequences With Re￾current Neural Networks”. In: (Aug. 2013).
arXiv: 1308.0850 [cs.NE].
[Gra+17] E. Grave, A. Joulin, M. Cissé, D. Grangier,
and H. Jégou. “Efficient softmax approxima￾tion for GPUs”. In: ICML. 2017.
[Gra+18] E. Grant, C. Finn, S. Levine, T. Darrell,
and T. Griffiths. “Recasting Gradient-Based
Meta-Learning as Hierarchical Bayes”. In:
ICLR. 2018.
[Gra+20] W. Grathwohl, K.-C. Wang, J.-H. Jacobsen,
D. Duvenaud, M. Norouzi, and K. Swersky.
“Your classifier is secretly an energy based
model and you should treat it like one”. In:
ICLR. 2020.
[Gre+17] K. Greff, R. K. Srivastava, J. Koutník, B. R.
Steunebrink, and J. Schmidhuber. “LSTM: A
Search Space Odyssey”. In: IEEE Transac￾tions on Neural Networks and Learning Sys￾tems 28.10 (2017).
[Gri20] T. L. Griffiths. “Understanding Human Intel￾ligence through Human Limitations”. en. In:
Trends Cogn. Sci. 24.11 (Nov. 2020), pp. 873–
883.
[GS08] Y Guo and D Schuurmans. “Efficient global
optimization for exponential family PCA and
low-rank matrix factorization”. In: 2008 46th
Annual Allerton Conference on Communi￾cation, Control, and Computing. Sept. 2008,
pp. 1100–1107.
[GS97] C. M. Grinstead and J. L. Snell. Introduction
to probability (2nd edition). American Math￾ematical Society, 1997.
[GSK18] S. Gidaris, P. Singh, and N. Komodakis. “Un￾supervised Representation Learning by Pre￾dicting Image Rotations”. In: ICLR. 2018.
[GT07] L. Getoor and B. Taskar, eds. Introduction to
Relational Statistical Learning. MIT Press,
2007.
[GTA00] G. Gigerenzer, P. M. Todd, and ABC Re￾search Group. Simple Heuristics That Make
Us Smart. en. Illustrated edition. Oxford Uni￾versity Press, Sept. 2000.
[Gu+18] A. Gu, F. Sala, B. Gunel, and C. Ré.
“Learning Mixed-Curvature Representations
in Product Spaces”. In: International Confer￾ence on Learning Representations (2018).
[Gua+10] Y. Guan, J. Dy, D. Niu, and Z. Ghahra￾mani. “Variational Inference for Nonparamet￾ric Multiple Clustering”. In: 1st Intl. Work￾shop on Discovering, Summarizing and Us￾ing Multiple Clustering (MultiClust). 2010.
[Gua+17] S. Guadarrama, R. Dahl, D. Bieber, M.
Norouzi, J. Shlens, and K. Murphy. “Pix￾Color: Pixel Recursive Colorization”. In:
BMVC. 2017.
[Gul+20] A. Gulati et al. “Conformer: Convolution￾augmented Transformer for Speech Recogni￾tion”. In: (May 2020). arXiv: 2005 . 08100
[eess.AS].
[Guo09] Y. Guo. “Supervised exponential family prin￾cipal component analysis via convex optimiza￾tion”. In: NIPS. 2009.
[Guo+17] H. Guo, R. Tang, Y. Ye, Z. Li, and X. He.
“DeepFM: a factorization-machine based neu￾ral network for CTR prediction”. In: IJCAI.
IJCAI’17. Melbourne, Australia: AAAI Press,
Aug. 2017, pp. 1725–1731.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license804 BIBLIOGRAPHY
[Gus01] M. Gustafsson. “A probabilistic derivation of
the partial least-squares algorithm”. In: Jour￾nal of Chemical Information and Modeling
41 (2001), pp. 288–294.
[GVZ16] A. Gupta, A. Vedaldi, and A. Zisserman.
“Synthetic Data for Text Localisation in Nat￾ural Images”. In: CVPR. 2016.
[GZE19] A. Grover, A. Zweig, and S. Ermon.
“Graphite: Iterative Generative Modeling of
Graphs”. In: International Conference on
Machine Learning. 2019, pp. 2434–2444.
[HA85] L. Hubert and P. Arabie. “Comparing Par￾titions”. In: J. of Classification 2 (1985),
pp. 193–218.
[HAB19] M. Hein, M. Andriushchenko, and J. Bit￾terwolf. “Why ReLU networks yield high￾confidence predictions far away from the
training data and how to mitigate the prob￾lem”. In: CVPR. 2019.
[Hac75] I. Hacking. The Emergence of Probability:
A Philosophical Study of Early Ideas about
Probability, Induction and Statistical Infer￾ence. Cambridge University Press, 1975.
[Háj08] A. Hájek. “Dutch Book Arguments”. In: The
Oxford Handbook of Rational and Social
Choice. Ed. by P. Anand, P. Pattanaik, and
C. Puppe. Oxford University Press, 2008.
[Han+20] B. Han et al. “A Survey of Label-noise Rep￾resentation Learning: Past, Present and Fu￾ture”. In: (Nov. 2020). arXiv: 2011 . 04406
[cs.LG].
[Har54] Z. Harris. “Distributional structure”. In:
Word 10.23 (1954), pp. 146–162.
[Has+04] T. Hastie, S. Rosset, R. Tibshirani, and J.
Zhu. “The entire regularization path for the
support vector machine”. In: JMLR 5 (2004),
pp. 1391–1415.
[Has+09] T. Hastie, S. Rosset, J. Zhu, and H. Zou.
“Multi-class AdaBoost”. In: Statistics and tis
Interface 2.3 (2009), pp. 349–360.
[Has+17] D. Hassabis, D. Kumaran, C. Summerfield,
and M. Botvinick. “Neuroscience-Inspired Ar￾tificial Intelligence”. en. In: Neuron 95.2
(2017), pp. 245–258.
[Has87] J. Hastad. Computational limits of small￾depth circuits. MIT Press, 1987.
[HB17] X. Huang and S. Belongie. “Arbitrary style
transfer in real-time with adaptive instance
normalization”. In: ICCV. 2017.
[HCD12] D. Hoiem, Y. Chodpathumwan, and Q. Dai.
“Diagnosing Error in Object Detectors”. In:
ECCV. 2012.
[HCL09] C.-W. Hsu, C.-C. Chang, and C.-J. Lin. A
Practical Guide to Support Vector Classifi￾cation. Tech. rep. Dept. Comp. Sci., National
Taiwan University, 2009.
[HDR19] S. Hayou, A. Doucet, and J. Rousseau. “On
the Impact of the Activation Function on
Deep Neural Networks Training”. In: (Feb.
2019). arXiv: 1902.06853 [stat.ML].
[He+15] K. He, X. Zhang, S. Ren, and J. Sun. “Delv￾ing Deep into Rectifiers: Surpassing Human￾Level Performance on ImageNet Classifica￾tion”. In: ICCV. 2015.
[He+16a] K. He, X. Zhang, S. Ren, and J. Sun. “Deep
Residual Learning for Image Recognition”. In:
CVPR. 2016.
[He+16b] K. He, X. Zhang, S. Ren, and J. Sun. “Iden￾tity Mappings in Deep Residual Networks”.
In: ECCV. 2016.
[He+17] X. He, L. Liao, H. Zhang, L. Nie, X. Hu, and
T.-S. Chua. “Neural Collaborative Filtering”.
In: WWW. 2017.
[HE18] D. Ha and D. Eck. “A Neural Representation
of Sketch Drawings”. In: ICLR. 2018.
[He+20] K. He, H. Fan, Y. Wu, S. Xie, and R. Gir￾shick. “Momentum contrast for unsupervised
visual representation learning”. In: CVPR.
2020, pp. 9729–9738.
[Hen+15] J. Hensman, A. Matthews, M. Filippone, and
Z. Ghahramani. “MCMC for Variationally
Sparse Gaussian Processes”. In: NIPS. 2015,
pp. 1648–1656.
[HG16] D. Hendrycks and K. Gimpel. “Gaussian Er￾ror Linear Units (GELUs)”. In: arXiv [cs.LG]
(June 2016).
[HG20] J. Howard and S. Gugger. Deep Learning for
Coders with Fastai and PyTorch: AI Appli￾cations Without a PhD. en. 1st ed. O’Reilly
Media, Aug. 2020.
[HG21] M. K. Ho and T. L. Griffiths. “Cognitive sci￾ence as a source of forward and inverse models
of human decisions for robotics and control”.
In: Annual Review of Control, Robotics, and
Autonomous Systems. Sept. 2021.
[HGD19] K. He, R. Girshick, and P. Dollár. “Rethink￾ing ImageNet Pre-training”. In: CVPR. 2019.
[Hin+12] G. E. Hinton et al. “Deep Neural Networks
for Acoustic Modeling in Speech Recognition:
The Shared Views of Four Research Groups”.
In: IEEE Signal Process. Mag. 29.6 (2012),
pp. 82–97.
[Hin13] G. Hinton. CSC 2535 Lecture 11: Non-linear
dimensionality reduction. 2013.
[Hin14] G. Hinton. Lecture 6e on neural networks
(RMSprop: Divide the gradient by a running
average of its recent magnitude). 2014.
[HK15] F. M. Harper and J. A. Konstan. “The Movie￾Lens Datasets: History and Context”. In:
ACM Trans. Interact. Intell. Syst. 5.4 (Dec.
2015), pp. 1–19.
[HL04] D. R. Hunter and K. Lange. “A Tutorial on
MM Algorithms”. In: The American Statisti￾cian 58 (2004), pp. 30–37.
[HMT11] N. Halko, P.-G. Martinsson, and J. A. Tropp.
“Finding structure with randomness: Proba￾bilistic algorithms for constructing approx￾imate matrix decompositions”. In: SIAM
Rev., Survey and Review section 53.2 (2011),
pp. 217–288.
[HN19] C. M. Holmes and I. Nemenman. “Estimation
of mutual information for real-valued data
with error bars and controlled bias”. en. In:
Phys Rev E 100.2-1 (Aug. 2019), p. 022404.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 805
[Hoc+01] S. Hochreiter, Y. Bengio, P. Frasconi, and
J. Schmidhuber. “Gradient flow in recurrent
nets: the difficulty of learning long-term de￾pendencies”. In: A Field Guide to Dynami￾cal Recurrent Neural Networks. Ed. by S. C.
Kremer and J. F. Kolen. 2001.
[Hoe+14] R. Hoekstra, R. D. Morey, J. N. Rouder,
and E.-J. Wagenmakers. “Robust misinterpre￾tation of confidence intervals”. en. In: Psy￾chon. Bull. Rev. 21.5 (Oct. 2014), pp. 1157–
1164.
[Hoe+21] T. Hoefler, D. Alistarh, T. Ben-Nun, N. Dry￾den, and A. Peste. “Sparsity in Deep Learn￾ing: Pruning and growth for efficient inference
and training in neural networks”. In: (Jan.
2021). arXiv: 2102.00554 [cs.LG].
[Hof09] P. D. Hoff. A First Course in Bayesian Sta￾tistical Methods. Springer, 2009.
[Hor61] P Horst. “Generalized canonical correlations
and their applications to experimental data”.
en. In: J. Clin. Psychol. 17 (Oct. 1961),
pp. 331–347.
[Hor91] K. Hornik. “Approximation Capabilities of
Multilayer Feedforward Networks”. In: Neu￾ral Networks 4.2 (1991), pp. 251–257.
[Hos+19] M. Z. Hossain, F. Sohel, M. F. Shiratud￾din, and H. Laga. “A Comprehensive Survey
of Deep Learning for Image Captioning”. In:
ACM Computing Surveys (2019).
[HOT06] G. Hinton, S. Osindero, and Y. Teh. “A fast
learning algorithm for deep belief nets”. In:
Neural Computation 18 (2006), pp. 1527–
1554.
[Hot36] H. Hotelling. “Relations Between Two Sets
of Variates”. In: Biometrika 28.3/4 (1936),
pp. 321–377.
[Hou+12] N. Houlsby, F. Huszar, Z. Ghahramani, and
J. M. Hernández-lobato. “Collaborative Gaus￾sian Processes for Preference Learning”. In:
NIPS. 2012, pp. 2096–2104.
[Hou+19] N. Houlsby et al. “Parameter-Efficient Trans￾fer Learning for NLP”. In: ICML. 2019.
[How+17] A. G. Howard et al. “MobileNets: Efficient
Convolutional Neural Networks for Mobile Vi￾sion Applications”. In: CVPR. 2017.
[HR03] G. E. Hinton and S. T. Roweis. “Stochas￾tic Neighbor Embedding”. In: NIPS. 2003,
pp. 857–864.
[HR76] L. Hyafil and R. Rivest. “Constructing Opti￾mal Binary Decision Trees is NP-complete”.
In: Information Processing Letters 5.1
(1976), pp. 15–17.
[HRP21] M. Huisman, J. N. van Rijn, and A. Plaat. “A
Survey of Deep Meta-Learning”. In: AI Re￾view (2021).
[HS19] J. Haochen and S. Sra. “Random Shuffling
Beats SGD after Finite Epochs”. In: ICML.
Vol. 97. Proceedings of Machine Learning Re￾search. Long Beach, California, USA: PMLR,
2019, pp. 2624–2633.
[HS97a] S Hochreiter and J Schmidhuber. “Flat min￾ima”. en. In: Neural Comput. 9.1 (1997),
pp. 1–42.
[HS97b] S. Hochreiter and J. Schmidhuber. “Long
short-term memory”. In: Neural Computa￾tion 9.8 (1997), 1735–1780.
[HSW89] K. Hornik, M. Stinchcombe, and H. White.
“Multilayer feedforward networks are univer￾sal approximators”. In: Neural Networks 2.5
(1989), pp. 359–366.
[HT90] T. Hastie and R. Tibshirani. Generalized ad￾ditive models. Chapman and Hall, 1990.
[HTF01] T. Hastie, R. Tibshirani, and J. Fried￾man. The Elements of Statistical Learning.
Springer, 2001.
[HTF09] T. Hastie, R. Tibshirani, and J. Friedman.
The Elements of Statistical Learning. 2nd
edition. Springer, 2009.
[HTW15] T. Hastie, R. Tibshirani, and M. Wain￾wright. Statistical Learning with Sparsity:
The Lasso and Generalizations. CRC Press,
2015.
[Hua14] G.-B. Huang. “An Insight into Extreme
Learning Machines: Random Neurons, Ran￾dom Features and Kernels”. In: Cognit. Com￾put. 6.3 (Sept. 2014), pp. 376–390.
[Hua+17a] G. Huang, Z. Liu, K. Q. Weinberger, and
L. van der Maaten. “Densely Connected Con￾volutional Networks”. In: CVPR. 2017.
[Hua+17b] J. Huang et al. “Speed/accuracy trade-offs
for modern convolutional object detectors”.
In: CVPR. 2017.
[Hua+18] C.-Z. A. Huang et al. “Music Transformer”.
In: (Sept. 2018). arXiv: 1809.04281 [cs.LG].
[Hub+08] M. F. Huber, T Bailey, H Durrant-Whyte,
and U. D. Hanebeck. “On entropy approxi￾mation for Gaussian mixture random vectors”.
In: 2008 IEEE International Conference on
Multisensor Fusion and Integration for In￾telligent Systems. Aug. 2008, pp. 181–188.
[Hub64] P. Huber. “Robust Estimation of a Loca￾tion Parameter”. In: Annals of Statistics 53
(1964), 73–101.
[Hut90] M. F. Hutchinson. “A stochastic estimator of
the trace of the influence matrix for lapla￾cian smoothing splines”. In: Communications
in Statistics - Simulation and Computation
19.2 (Jan. 1990), pp. 433–450.
[HVD14] G. Hinton, O. Vinyals, and J. Dean. “Distill￾ing the Knowledge in a Neural Network”. In:
NIPS Deep Learning Workshop. 2014.
[HW62] D. Hubel and T. Wiesel. “Receptive fields,
binocular interaction, and functional architec￾ture in the cat’s visual cortex”. In: J. Physi￾ology 160 (1962), pp. 106–154.
[HY01] M. Hansen and B. Yu. “Model selection and
the principle of minimum description length”.
In: JASA (2001).
[HYL17] W. Hamilton, Z. Ying, and J. Leskovec.
“Inductive representation learning on large
graphs”. In: Advances in Neural Information
Processing Systems. 2017, pp. 1024–1034.
[Idr+17] H. Idrees et al. “The THUMOS challenge on
action recognition for videos “in the wild””.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license806 BIBLIOGRAPHY
In: Comput. Vis. Image Underst. 155 (Feb.
2017), pp. 1–23.
[Ie+19] E. Ie et al. “SlateQ: A tractable decomposi￾tion for reinforcement learning with recom￾mendation sets”. In: IJCAI. Macao, China:
International Joint Conferences on Artificial
Intelligence Organization, Aug. 2019.
[Iof17] S. Ioffe. “Batch Renormalization: Towards
Reducing Minibatch Dependence in Batch￾Normalized Models”. In: (2017). arXiv: 1702.
03275 [cs.LG].
[IR10] A. Ilin and T. Raiko. “Practical Approaches
to Principal Component Analysis in the Pres￾ence of Missing Values”. In: JMLR 11 (2010),
pp. 1957–2000.
[IS15] S. Ioffe and C. Szegedy. “Batch Normaliza￾tion: Accelerating Deep Network Training by
Reducing Internal Covariate Shift”. In: ICML.
2015, pp. 448–456.
[Isc+19] A. Iscen, G. Tolias, Y. Avrithis, and O. Chum.
“Label Propagation for Deep Semi-supervised
Learning”. In: CVPR. 2019.
[Izm+18] P. Izmailov, D. Podoprikhin, T. Garipov,
D. Vetrov, and A. G. Wilson. “Averaging
Weights Leads to Wider Optima and Better
Generalization”. In: UAI. 2018.
[Izm+20] P. Izmailov, P. Kirichenko, M. Finzi, and
A. G. Wilson. “Semi-supervised learning with
normalizing flows”. In: ICML. 2020, pp. 4615–
4630.
[Jac+91] R. Jacobs, M. Jordan, S. Nowlan, and G. Hin￾ton. “Adaptive mixtures of local experts”. In:
Neural Computation (1991).
[JAFF16] J. Johnson, A. Alahi, and L. Fei-Fei. “Per￾ceptual Losses for Real-Time Style Transfer
and Super-Resolution”. In: ECCV. 2016.
[Jan18] E. Jang. Normalizing Flows Tutorial. 2018.
[Jay03] E. T. Jaynes. Probability theory: the logic of
science. Cambridge university press, 2003.
[Jay76] E. T. Jaynes. “Confidence intervals vs
Bayesian intervals”. In: Foundations of Prob￾ability Theory, Statistical Inference, and
Statistical Theories of Science, vol II. Ed.
by W. L. Harper and C. A. Hooker. Reidel
Publishing Co., 1976.
[JD88] A. Jain and R. Dubes. Algorithms for Clus￾tering Data. Prentice Hall, 1988.
[JDJ17] J. Johnson, M. Douze, and H. Jégou. “Billion￾scale similarity search with GPUs”. In: (Feb.
2017). arXiv: 1702.08734 [cs.CV].
[Jef61] H. Jeffreys. Theory of Probability. Oxford,
1961.
[Jef73] H. Jeffreys. Scientific Inference. Third edi￾tion. Cambridge, 1973.
[JGH18] A. Jacot, F. Gabriel, and C. Hongler. “Neural
Tangent Kernel: Convergence and Generaliza￾tion in Neural Networks”. In: NIPS. 2018.
[JH04] H. Jaeger and H. Haas. “Harnessing Nonlin￾earity: Predicting Chaotic Systems and Sav￾ing Energy in Wireless Communication”. In:
Science 304.5667 (2004).
[JHG00] N. Japkowicz, S. Hanson, and M. Gluck.
“Nonlinear autoassociation is not equivalent
to PCA”. In: Neural Computation 12 (2000),
pp. 531–545.
[Jia+20] Y. Jiang, B. Neyshabur, H. Mobahi, D. Kr￾ishnan, and S. Bengio. “Fantastic Generaliza￾tion Measures and Where to Find Them”. In:
ICLR. 2020.
[Jin+17] Y. Jing, Y. Yang, Z. Feng, J. Ye, Y. Yu, and
M. Song. “Neural Style Transfer: A Review”.
In: arXiv [cs.CV] (May 2017).
[JJ94] M. I. Jordan and R. A. Jacobs. “Hierarchical
mixtures of experts and the EM algorithm”.
In: Neural Computation 6 (1994), pp. 181–
214.
[JK13] A. Jern and C. Kemp. “A probabilistic ac￾count of exemplar and category generation”.
en. In: Cogn. Psychol. 66.1 (Feb. 2013),
pp. 85–125.
[JM08] D. Jurafsky and J. H. Martin. Speech and lan￾guage processing: An Introduction to Nat￾ural Language Processing, Computational
Linguistics, and Speech Recognition. 2nd edi￾tion. Prentice-Hall, 2008.
[JM20] D. Jurafsky and J. H. Martin. Speech and lan￾guage processing: An Introduction to Nat￾ural Language Processing, Computational
Linguistics, and Speech Recognition (Third
Edition). Draft of 3rd edition. 2020.
[Jor19] M. Jordan. “Artificial Intelligence — The
Revolution Hasn’t Happened Yet”. In: Har￾vard Data Science Review 1.1 (July 2019).
[JT19] L. Jing and Y. Tian. “Self-supervised Visual
Feature Learning with Deep Neural Networks:
A Survey”. In: (Feb. 2019). arXiv: 1902.06162
[cs.CV].
[Jun+19] W. Jung, D. Jung, B. Kim, S. Lee, W. Rhee,
and J. Anh. “Restructuring Batch Normaliza￾tion to Accelerate CNN Training”. In: SysML.
2019.
[JW19] S. Jain and B. C. Wallace. “Attention is not
Explanation”. In: NAACL. 2019.
[JZ13] R. Johnson and T. Zhang. “Accelerating
Stochastic Gradient Descent using Predictive
Variance Reduction”. In: NIPS. Curran Asso￾ciates, Inc., 2013, pp. 315–323.
[JZS15] R. Jozefowicz, W. Zaremba, and I. Sutskever.
“An Empirical Exploration of Recurrent
Network Architectures”. In: ICML. 2015,
pp. 2342–2350.
[KAG19] A. Kirsch, J. van Amersfoort, and Y. Gal.
“BatchBALD: Efficient and Diverse Batch Ac￾quisition for Deep Bayesian Active Learning”.
In: NIPS. 2019.
[Kai58] H. Kaiser. “The varimax criterion for analytic
rotation in factor analysis”. In: Psychome￾trika 23.3 (1958).
[Kan+12] E. Kandel, J. Schwartz, T. Jessell, S. Siegel￾baum, and A. Hudspeth, eds. Principles of
Neural Science. Fifth Edition. 2012.
[Kan+20] B. Kang et al. “Decoupling Representation
and Classifier for Long-Tailed Recognition”.
In: ICLR. 2020.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 807
[Kap16] J. Kaplan. Artificial Intelligence: What Ev￾eryone Needs to Know. en. 1st ed. Oxford
University Press, Oct. 2016.
[Kat+20] A. Katharopoulos, A. Vyas, N. Pappas, and
F. Fleuret. “Transformers are RNNs: Fast Au￾toregressive Transformers with Linear Atten￾tion”. In: ICML. 2020.
[KB15] D. Kingma and J. Ba. “Adam: A Method for
Stochastic Optimization”. In: ICLR. 2015.
[KB19] M. Kaya and H. S. Bilge. “Deep Metric Learn￾ing: A Survey”. en. In: Symmetry 11.9 (Aug.
2019), p. 1066.
[KBV09] Y. Koren, R. Bell, and C. Volinsky. “Ma￾trix factorization techniques for recommender
systems”. In: IEEE Computer 42.8 (2009),
pp. 30–37.
[KD09] A. D. Kiureghian and O. Ditlevsen. “Aleatory
or epistemic? Does it matter?” In: Structural
Safety 31.2 (Mar. 2009), pp. 105–112.
[Kem+06] C. Kemp, J. Tenenbaum, T. Y. T. Griffiths
and, and N. Ueda. “Learning systems of con￾cepts with an infinite relational model”. In:
AAAI. 2006.
[KF05] H. Kuck and N. de Freitas. “Learning about
individuals from group statistics”. In: UAI.
2005.
[KG05] A. Krause and C. Guestrin. “Near-optimal
value of information in graphical models”. In:
UAI. 2005.
[KG17] A. Kendall and Y. Gal. “What Uncertainties
Do We Need in Bayesian Deep Learning for
Computer Vision?” In: NIPS. Curran Asso￾ciates, Inc., 2017, pp. 5574–5584.
[KGS20] J. von Kügelgen, L. Gresele, and B. Schölkopf.
“Simpson’s paradox in Covid-19 case fatal￾ity rates: a mediation analysis of age-related
causal effects”. In: (May 2020). arXiv: 2005 .
07180 [stat.AP].
[KH09] A Krizhevsky and G Hinton. Learning multi￾ple layers of features from tiny images. Tech.
rep. U. Toronto, 2009.
[KH19] D. Krotov and J. J. Hopfield. “Unsupervised
learning by competing hidden units”. en. In:
PNAS 116.16 (Apr. 2019), pp. 7723–7731.
[Kha+10] M. E. Khan, B. Marlin, G. Bouchard, and
K. P. Murphy. “Variational bounds for mixed￾data factor analysis”. In: NIPS. 2010.
[Kha+20] A. Khan, A. Sohail, U. Zahoora, and A. S.
Qureshi. “A Survey of the Recent Archi￾tectures of Deep Convolutional Neural Net￾works”. In: AI Review (Jan. 2020).
[KHB07] A. Kapoor, E. Horvitz, and S. Basu. “Selec￾tive Supervision: Guiding Supervised Learn￾ing with Decision-Theoretic Active Learning”.
In: IJCAI. 2007.
[KHW19] W. Kool, H. van Hoof, and M. Welling.
“Stochastic Beams and Where to Find Them:
The Gumbel-Top-k Trick for Sampling Se￾quences Without Replacement”. In: ICML.
Mar. 2019.
[Kim14] Y. Kim. “Convolutional Neural Networks for
Sentence Classification”. In: EMNLP. 2014.
[Kim19] D. H. Kim. Survey of Deep Metric Learning.
2019.
[Kin+14] D. P. Kingma, D. J. Rezende, S. Mohamed,
and M. Welling. “Semi-Supervised Learning
with Deep Generative Models”. In: NIPS.
2014.
[Kir+19] A. Kirillov, K. He, R. Girshick, C. Rother,
and P. Dollár. “Panoptic Segmentation”. In:
CVPR. 2019.
[KJ16] L Kang and V Joseph. “Kernel Approxima￾tion: From Regression to Interpolation”. In:
SIAM/ASA J. Uncertainty Quantification
4.1 (Jan. 2016), pp. 112–129.
[KJ95] J. Karhunen and J. Joutsensalo. “Generaliza￾tions of principal component analysis, opti￾mization problems, and neural networks”. In:
Neural Networks 8.4 (1995), pp. 549–562.
[KJM19] N. M. Kriege, F. D. Johansson, and C. Mor￾ris. “A Survey on Graph Kernels”. In: (Mar.
2019). arXiv: 1903.11835 [cs.LG].
[KK06] S. Kotsiantis and D. Kanellopoulos. “Dis￾cretization Techniques: A recent survey”. In:
GESTS Intl. Trans. on Computer Science
and Engineering 31.1 (2006), pp. 47–58.
[KKH20] I. Khemakhem, D. P. Kingma, and A. Hyväri￾nen. “Variational Autoencoders and Nonlin￾ear ICA: A Unifying Framework”. In: AIS￾TATS. 2020.
[KKL20] N. Kitaev, L. Kaiser, and A. Levskaya.
“Reformer: The Efficient Transformer”. In:
8th International Conference on Learn￾ing Representations, ICLR 2020, Addis
Ababa, Ethiopia, April 26-30, 2020. Open￾Review.net, 2020.
[KKS20] F. Kunstner, R. Kumar, and M. Schmidt.
“Homeomorphic-Invariance of EM: Non￾Asymptotic Convergence in KL Divergence
for Exponential Families via Mirror Descent”.
In: (Nov. 2020). arXiv: 2011.01170 [cs.LG].
[KL17] J. K. Kruschke and T. M. Liddell. “The
Bayesian New Statistics: Hypothesis testing,
estimation, meta-analysis, and power analy￾sis from a Bayesian perspective”. In: Psychon.
Bull. Rev. (2017).
[KL21] W. M. Kouw and M. Loog. “A review of do￾main adaptation without target labels”. en.
In: IEEE PAMI (Oct. 2021).
[Kla+17] G. Klambauer, T. Unterthiner, A. Mayr, and
S. Hochreiter. “Self-Normalizing Neural Net￾works”. In: NIPS. 2017.
[Kle02] J. Kleinberg. “An Impossibility Theorem for
Clustering”. In: NIPS. 2002.
[Kle+11] A. Kleiner, A. Talwalkar, P. Sarkar, and
M. I. Jordan. A scalable bootstrap for mas￾sive data. Tech. rep. UC Berkeley, 2011.
[Kle13] P. N. Klein. Coding the Matrix: Linear Alge￾bra through Applications to Computer Sci￾ence. en. 1 edition. Newtonian Press, Sept.
2013.
[KLQ95] C. Ko, J. Lee, and M. Queyranne. “An exact
algorithm for maximum entropy sampling”.
In: Operations Research 43 (1995), 684–691.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license808 BIBLIOGRAPHY
[Kok17] I. Kokkinos. “UberNet: Training a Univer￾sal Convolutional Neural Network for Low-,
Mid-, and High-Level Vision Using Diverse
Datasets and Limited Memory”. In: CVPR.
Vol. 2. 2017, p. 8.
[Kol+19] A. Kolesnikov et al. “Large Scale Learning of
General Visual Representations for Transfer”.
In: (Dec. 2019). arXiv: 1912.11370 [cs.CV].
[Kol+20] A. Kolesnikov et al. “Large Scale Learning of
General Visual Representations for Transfer”.
In: ECCV. 2020.
[Kon20] M. Konnikova. The Biggest Bluff: How I
Learned to Pay Attention, Master Myself,
and Win. en. Penguin Press, June 2020.
[Kor09] Y. Koren. The BellKor Solution to the Net￾flix Grand Prize. Tech. rep. Yahoo! Research,
2009.
[KR19] M. Kearns and A. Roth. The Ethical Algo￾rithm: The Science of Socially Aware Algo￾rithm Design. en. Oxford University Press,
Nov. 2019.
[KR87] L. Kaufman and P. Rousseeuw. “Clustering
by means of Medoids”. In: Statistical Data
Analysis Based on the L1-norm and Related
Methods. Ed. by Y. Dodge. North-Holland,
1987, 405–416.
[KR90] L. Kaufman and P. Rousseeuw. Finding
Groups in Data: An Introduction to Cluster
Analysis. Wiley, 1990.
[Kri+05] B. Krishnapuram, L. Carin, M. Figueiredo,
and A. Hartemink. “Learning sparse Bayesian
classifiers: multi-class formulation, fast algo￾rithms, and generalization bounds”. In: IEEE
Transaction on Pattern Analysis and Ma￾chine Intelligence (2005).
[Kru13] J. K. Kruschke. “Bayesian estimation super￾sedes the t test”. In: J. Experimental Psy￾chology: General 142.2 (2013), pp. 573–603.
[Kru15] J. Kruschke. Doing Bayesian Data Analysis:
A Tutorial with R, JAGS and STAN. Second
edition. Academic Press, 2015.
[KS15] H. Kaya and A. A. Salah. “Adaptive Mixtures
of Factor Analyzers”. In: (July 2015). arXiv:
1507.02801 [stat.ML].
[KSG04] A. Kraskov, H. Stögbauer, and P. Grass￾berger. “Estimating mutual information”. en.
In: Phys. Rev. E Stat. Nonlin. Soft Matter
Phys. 69.6 Pt 2 (June 2004), p. 066138.
[KSH12] A. Krizhevsky, I. Sutskever, and G. Hinton.
“Imagenet classification with deep convolu￾tional neural networks”. In: NIPS. 2012.
[KSJ09] I. Konstas, V. Stathopoulos, and J. M. Jose.
“On social networks and collaborative recom￾mendation”. In: Proceedings of the 32nd in￾ternational ACM SIGIR conference on Re￾search and development in information re￾trieval. 2009, pp. 195–202.
[KST82] D. Kahneman, P. Slovic, and A. Tversky, eds.
Judgment under uncertainty: Heuristics and
biases. Cambridge, 1982.
[KTB11] D. P. Kroese, T. Taimre, and Z. I. Botev.
Handbook of Monte Carlo Methods. en. 1 edi￾tion. Wiley, Mar. 2011.
[Kua+09] P. Kuan, G. Pan, J. A. Thomson, R. Stewart,
and S. Keles. A hierarchical semi-Markov
model for detecting enrichment with appli￾cation to ChIP-Seq experiments. Tech. rep.
U. Wisconsin, 2009.
[Kul13] B. Kulis. “Metric Learning: A Survey”. In:
Foundations and Trends in Machine Learn￾ing 5.4 (2013), pp. 287–364.
[KV94] M. J. Kearns and U. V. Vazirani. An Intro￾duction to Computational Learning Theory.
MIT Press, 1994.
[KVK10] A. Klami, S. Virtanen, and S. Kaski.
“Bayesian exponential family projections for
coupled data sources”. In: UAI. 2010.
[KW14] D. P. Kingma and M. Welling. “Auto￾encoding variational Bayes”. In: ICLR. 2014.
[KW16a] T. N. Kipf and M. Welling. “Semi-supervised
classification with graph convolutional net￾works”. In: arXiv preprint arXiv:1609.02907
(2016).
[KW16b] T. N. Kipf and M. Welling. “Variational
graph auto-encoders”. In: arXiv preprint
arXiv:1611.07308 (2016).
[KW19a] D. P. Kingma and M. Welling. “An Introduc￾tion to Variational Autoencoders”. In: Foun￾dations and Trends in Machine Learning
12.4 (2019), pp. 307–392.
[KW19b] M. J. Kochenderfer and T. A. Wheeler. Algo￾rithms for Optimization. en. The MIT Press,
Mar. 2019.
[KWW22] M. J. Kochenderfer, T. A. Wheeler, and K.
Wray. Algorithms for Decision Making. The
MIT Press, 2022.
[Kyu+10] M. Kyung, J. Gill, M. Ghosh, and G. Casella.
“Penalized Regression, Standard Errors and
Bayesian Lassos”. In: Bayesian Analysis 5.2
(2010), pp. 369–412.
[LA16] S. Laine and T. Aila. “Temporal ensem￾bling for semi-supervised learning”. In: arXiv
preprint arXiv:1610.02242 (2016).
[Lak+17] B. M. Lake, T. D. Ullman, J. B. Tenen￾baum, and S. J. Gershman. “Building Ma￾chines That Learn and Think Like People”.
en. In: Behav. Brain Sci. (2017), pp. 1–101.
[Law12] N. D. Lawrence. “A Unifying Probabilistic
Perspective for Spectral Dimensionality Re￾duction: Insights and New Models”. In: JMLR
13.May (2012), pp. 1609–1638.
[LBS19] Y. Li, J. Bradshaw, and Y. Sharma. “Are Gen￾erative Classifiers More Robust to Adversar￾ial Attacks?” In: ICML. Ed. by K. Chaudhuri
and R. Salakhutdinov. Vol. 97. Proceedings
of Machine Learning Research. PMLR, 2019,
pp. 3804–3814.
[LeC18] Y. LeCun. Self-supervised learning: could
machines learn like humans? 2018.
[LeC+98] Y. LeCun, L. Bottou, Y. Bengio, and P.
Haffner. “Gradient-Based Learning Applied
to Document Recognition”. In: Proceedings
of the IEEE 86.11 (1998), pp. 2278–2324.
[Lee13] D.-H. Lee. “Pseudo-label: The simple and ef￾ficient semi-supervised learning method for
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 809
deep neural networks”. In: ICML Workshop
on Challenges in Representation Learning.
2013.
[Lee+13] J. Lee, S. Kim, G. Lebanon, and Y. Singer.
“Local Low-Rank Matrix Approximation”. In:
ICML. Vol. 28. Proceedings of Machine
Learning Research. Atlanta, Georgia, USA:
PMLR, 2013, pp. 82–90.
[Lee+19] J. Lee, Y. Lee, J. Kim, A. R. Kosiorek, S.
Choi, and Y. W. Teh. “Set Transformer: A
Framework for Attention-based Permutation￾Invariant Neural Networks”. In: ICML. 2019.
[Lee77] J. de Leeuw. “Applications of Convex Anal￾ysis to Multidimensional Scaling”. In: Re￾cent Developments in Statistics. Ed. by J. R.
Barra, F Brodeau, G Romier, and B Van Cut￾sem. 1977.
[Lep+21] D. Lepikhin et al. “GShard: Scaling Giant
Models with Conditional Computation and
Automatic Sharding”. In: ICLR. 2021.
[LG14] O. Levy and Y. Goldberg. “Neural Word Em￾bedding as Implicit Matrix Factorization”. In:
NIPS. 2014.
[LH17] I. Loshchilov and F. Hutter. “SGDR: Stochas￾tic Gradient Descent with Warm Restarts”.
In: ICLR. 2017.
[Li+15] Y. Li, D. Tarlow, M. Brockschmidt, and R.
Zemel. “Gated graph sequence neural net￾works”. In: arXiv preprint arXiv:1511.05493
(2015).
[Li+17] A. Li, A. Jabri, A. Joulin, and L. van
der Maaten. “Learning Visual N-Grams from
Web Data”. In: ICCV. 2017.
[Lia20] S. M. Liao, ed. Ethics of Artificial Intelli￾gence. en. 1st ed. Oxford University Press,
Sept. 2020.
[Lim+19] S. Lim, I. Kim, T. Kim, C. Kim, and S. Kim.
“Fast AutoAugment”. In: (May 2019). arXiv:
1905.00397 [cs.LG].
[Lin06] D. Lindley. Understanding Uncertainty. Wi￾ley, 2006.
[Lin+21] T. Lin, Y. Wang, X. Liu, and X. Qiu. “A Sur￾vey of Transformers”. In: (June 2021). arXiv:
2106.04554 [cs.LG].
[Lin56] D. Lindley. “On a measure of the information
provided by an experiment”. In: The Annals
of Math. Stat. (1956), 986–1005.
[Liu01] J. Liu. Monte Carlo Strategies in Scientific
Computation. Springer, 2001.
[Liu+16] W. Liu, D. Anguelov, D. Erhan, C. Szegedy,
and S. Reed. “SSD: Single Shot MultiBox De￾tector”. In: ECCV. 2016.
[Liu+18a] H. Liu, Y.-S. Ong, X. Shen, and J. Cai.
“When Gaussian Process Meets Big Data: A
Review of Scalable GPs”. In: (July 2018).
arXiv: 1807.01065 [stat.ML].
[Liu+18b] L. Liu, X. Liu, C.-J. Hsieh, and D. Tao.
“Stochastic Second-order Methods for Non￾convex Optimization with Inexact Hessian
and Gradient”. In: (Sept. 2018). arXiv: 1809.
09853 [math.OC].
[Liu+20] F. Liu, X. Huang, Y. Chen, and J. A. K.
Suykens. “Random Features for Kernel Ap￾proximation: A Survey on Algorithms, The￾ory, and Beyond”. In: (Apr. 2020). arXiv:
2004.11154 [stat.ML].
[LJ09] H. Lukosevicius and H. Jaeger. “Reservoir
computing approaches to recurrent neural
network training”. In: Computer Science Re￾view 3.3 (2009), 127–149.
[LKB20] Q. Liu, M. J. Kusner, and P. Blunsom. “A
Survey on Contextual Embeddings”. In: (Mar.
2020). arXiv: 2003.07278 [cs.CL].
[Llo82] S Lloyd. “Least squares quantization in
PCM”. In: IEEE Trans. Inf. Theory 28.2
(Mar. 1982), pp. 129–137.
[LLT89] K. Lange, R. Little, and J. Taylor. “Robust
Statistical Modeling Using the T Disribution”.
In: JASA 84.408 (1989), pp. 881–896.
[LM04] E. Learned-Miller. Hyperspacings and the es￾timation of information theoretic quantities.
Tech. rep. 04-104. U. Mass. Amherst Comp.
Sci. Dept, 2004.
[LM86] R. Larsen and M. Marx. An introduction to
mathematical statistics and its applications.
Prentice Hall, 1986.
[LN81] D. V. Lindley and M. R. Novick. “The Role of
Exchangeability in Inference”. en. In: Annals
of Statistics 9.1 (Jan. 1981), pp. 45–58.
[LNK19] Q. Liu, M. Nickel, and D. Kiela. “Hyperbolic
graph neural networks”. In: Advances in Neu￾ral Information Processing Systems. 2019,
pp. 8228–8239.
[Loa00] C. F. V. Loan. “The ubiquitous Kronecker
product”. In: J. Comput. Appl. Math. 123.1
(Nov. 2000), pp. 85–100.
[Lod+02] H. Lodhi, C. Saunders, J. Shawe-Taylor, N.
Cristianini, and C. Watkins. “Text classifica￾tion using string kernels”. en. In: J. Mach.
Learn. Res. (Mar. 2002).
[LPM15] M.-T. Luong, H. Pham, and C. D. Manning.
“Effective Approaches to Attention-based
Neural Machine Translation”. In: EMNLP.
2015.
[LR87] R. J. Little and D. B. Rubin. Statistical Anal￾ysis with Missing Data. New York: Wiley and
Son, 1987.
[LRU14] J. Leskovec, A. Rajaraman, and J. Ull￾man. Mining of massive datasets. Cam￾bridge, 2014.
[LS10] P. Long and R. Servedio. “Random classifica￾tion noise beats all convex potential boosters”.
In: JMLR 78.3 (2010), pp. 287–304.
[LS19a] S. Lattanzi and C. Sohler. “A Better k￾means++ Algorithm via Local Search”. In:
ICML. Vol. 97. Proceedings of Machine
Learning Research. Long Beach, California,
USA: PMLR, 2019, pp. 3662–3671.
[LS19b] Z. C. Lipton and J. Steinhardt. “Trou￾bling Trends in Machine Learning Scholar￾ship: Some ML papers suffer from flaws that
could mislead the public and stymie future
research”. In: The Queue 17.1 (Feb. 2019),
pp. 45–77.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license810 BIBLIOGRAPHY
[LSS13] Q. Le, T. Sarlos, and A. Smola. “Fastfood -
Computing Hilbert Space Expansions in log￾linear time”. In: ICML. Vol. 28. Proceedings
of Machine Learning Research. Atlanta, Geor￾gia, USA: PMLR, 2013, pp. 244–252.
[LSY19] H. Liu, K. Simonyan, and Y. Yang. “DARTS:
Differentiable Architecture Search”. In: ICLR.
2019.
[Lu+19] L. Lu, Y. Shin, Y. Su, and G. E. Karniadakis.
“Dying ReLU and Initialization: Theory and
Numerical Examples”. In: (Mar. 2019). arXiv:
1903.06733 [stat.ML].
[Luo16] M.-T. Luong. “Neural machine translation”.
PhD thesis. Stanford Dept. Comp. Sci., 2016.
[Luo+19] P. Luo, X. Wang, W. Shao, and Z. Peng. “To￾wards Understanding Regularization in Batch
Normalization”. In: ICLR. 2019.
[LUW17] C. Louizos, K. Ullrich, and M. Welling.
“Bayesian Compression for Deep Learning”.
In: NIPS. 2017.
[Lux07] U. von Luxburg. “A tutorial on spectral clus￾tering”. In: Statistics and Computing 17.4
(2007), pp. 395–416.
[LW04a] O. Ledoit and M. Wolf. “A Well-Conditioned
Estimator for Large-Dimensional Covariance
Matrices”. In: J. of Multivariate Analysis
88.2 (2004), pp. 365–411.
[LW04b] O. Ledoit and M. Wolf. “Honey, I Shrunk the
Sample Covariance Matrix”. In: J. of Portfo￾lio Management 31.1 (2004).
[LW04c] H. Lopes and M. West. “Bayesian model
assessment in factor analysis”. In: Statisica
Sinica 14 (2004), pp. 41–67.
[LW16] C. Li and M. Wand. “Precomputed Real-Time
Texture Synthesis with Markovian Generative
Adversarial Networks”. In: ECCV. 2016.
[LWG12] U. von Luxburg, R. Williamson, and I.
Guyon. “Clustering: science or art?” In:
Workshop on Unsupervised and Transfer
Learning. 2012.
[LXW19] X. Liu, Q. Xu, and N. Wang. “A survey on
deep neural network-based image captioning”.
In: The Visual Computer 35.3 (Mar. 2019),
pp. 445–470.
[Lyu+20] X.-K. Lyu, Y. Xu, X.-F. Zhao, X.-N. Zuo,
and C.-P. Hu. “Beyond psychology: preva￾lence of p value and confidence interval misin￾terpretation across different fields”. In: Jour￾nal of Pacific Rim Psychology 14 (2020).
[MA10] I. Murray and R. P. Adams. “Slice sampling
covariance hyperparameters of latent Gaus￾sian models”. In: NIPS. 2010, pp. 1732–1740.
[MA+17] Y. Movshovitz-Attias, A. Toshev, T. K. Le￾ung, S. Ioffe, and S. Singh. “No Fuss Distance
Metric Learning using Proxies”. In: ICCV.
2017.
[Maa+11] A. L. Maas, R. E. Daly, P. T. Pham, D.
Huang, A. Y. Ng, and C. Potts. “Learning
Word Vectors for Sentiment Analysis”. In:
Proc. ACL. 2011, pp. 142–150.
[Maa14] L. van der Maaten. “Accelerating t-SNE using
Tree-Based Algorithms”. In: JMLR (2014).
[Mac03] D. MacKay. Information Theory, Inference,
and Learning Algorithms. Cambridge Univer￾sity Press, 2003.
[Mac09] L. W. Mackey. “Deflation Methods for Sparse
PCA”. In: NIPS. 2009.
[Mac67] J MacQueen. “Some methods for classifica￾tion and analysis of multivariate observa￾tions”. en. In: Proceedings of the Fifth Berke￾ley Symposium on Mathematical Statistics
and Probability, Volume 1: Statistics. The
Regents of the University of California, 1967.
[Mac95] D. MacKay. “Probable networks and plau￾sible predictions — a review of practical
Bayesian methods for supervised neural net￾works”. In: Network: Computation in Neural
Systems 6.3 (1995), pp. 469–505.
[Mad+20] A. Madani et al. “ProGen: Language Model￾ing for Protein Generation”. en. Mar. 2020.
[Mah07] R. P. S. Mahler. Statistical Multisource￾Multitarget Information Fusion. Norwood,
MA, USA: Artech House, Inc., 2007.
[Mah13] R Mahler. “Statistics 102 for Multisource￾Multitarget Detection and Tracking”. In:
IEEE J. Sel. Top. Signal Process. 7.3 (June
2013), pp. 376–389.
[Mah+18] D. Mahajan et al. “Exploring the Limits
of Weakly Supervised Pretraining”. In: (May
2018). arXiv: 1805.00932 [cs.CV].
[Mai15] J Mairal. “Incremental Majorization￾Minimization Optimization with Application
to Large-Scale Machine Learning”. In: SIAM
J. Optim. 25.2 (Jan. 2015), pp. 829–855.
[Mal99] S. Mallat. A Wavelet Tour of Signal Process￾ing. Academic Press, 1999.
[Man+16] V. Mansinghka, P. Shafto, E. Jonas, C.
Petschulat, M. Gasner, and J. Tenenbaum.
“Crosscat: A Fully Bayesian, Nonparametric
Method For Analyzing Heterogeneous, High￾dimensional Data.” In: JMLR 17 (2016).
[Mar06] H. Markram. “The blue brain project”. en. In:
Nat. Rev. Neurosci. 7.2 (Feb. 2006), pp. 153–
160.
[Mar08] B. Marlin. “Missing Data Problems in Ma￾chine Learning”. PhD thesis. U. Toronto,
2008.
[Mar+11] B. M. Marlin, R. S. Zemel, S. T. Roweis, and
M. Slaney. “Recommender Systems, Missing
Data and Statistical Model Estimation”. In:
IJCAI. 2011.
[Mar18] O. Martin. Bayesian analysis with Python.
Packt, 2018.
[Mar20] G. Marcus. “The Next Decade in AI: Four
Steps Towards Robust Artificial Intelligence”.
In: (Feb. 2020). arXiv: 2002.06177 [cs.AI].
[Mar72] G. Marsaglia. “Choosing a Point from the Sur￾face of a Sphere”. en. In: Ann. Math. Stat.
43.2 (Apr. 1972), pp. 645–646.
[Mas+00] L. Mason, J. Baxter, P. L. Bartlett, and
M. R. Frean. “Boosting Algorithms as Gra￾dient Descent”. In: NIPS. 2000, pp. 512–518.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 811
[Mas+15] J. Masci, D. Boscaini, M. Bronstein, and P.
Vandergheynst. “Geodesic convolutional neu￾ral networks on riemannian manifolds”. In:
Proceedings of the IEEE international con￾ference on computer vision workshops. 2015,
pp. 37–45.
[Mat00] R. Matthews. “Storks Deliver Babies ( p =
0.008)”. In: Teach. Stat. 22.2 (June 2000),
pp. 36–38.
[Mat98] R. Matthews. Bayesian Critique of Statistics
in Health: The Great Health Hoax. 1998.
[MAV17] D. Molchanov, A. Ashukha, and D. Vetrov.
“Variational Dropout Sparsifies Deep Neural
Networks”. In: ICML. 2017.
[MB05] F. Morin and Y. Bengio. “Hierarchical Proba￾bilistic Neural Network Language Model”. In:
AISTATS. 2005.
[MB06] N. Meinshausen and P. Buhlmann. “High di￾mensional graphs and variable selection with
the lasso”. In: The Annals of Statistics 34
(2006), pp. 1436–1462.
[MBL20] K. Musgrave, S. Belongie, and S.-N. Lim. “A
Metric Learning Reality Check”. In: ECCV.
Mar. 2020.
[McE20] R. McElreath. Statistical Rethinking: A
Bayesian Course with Examples in R
and Stan (2nd edition). en. Chapman and
Hall/CRC, 2020.
[McL75] G. J. McLachlan. “Iterative reclassification
procedure for constructing an asymptotically
optimal rule of allocation in discriminant
analysis”. In: Journal of the American Sta￾tistical Association 70.350 (1975), pp. 365–
369.
[MD97] X. L. Meng and D. van Dyk. “The EM algo￾rithm — an old folk song sung to a fast new
tune (with Discussion)”. In: J. Royal Stat.
Soc. B 59 (1997), pp. 511–567.
[ME14] S. Masoudnia and R. Ebrahimpour. “Mixture
of experts: a literature survey”. In: Artifi￾cial Intelligence Review 42.2 (Aug. 2014),
pp. 275–293.
[Mei01] M. Meila. “A random walks view of spectral
segmentation”. In: AISTATS. 2001.
[Mei05] M. Meila. “Comparing clusterings: an ax￾iomatic view”. In: ICML. 2005.
[Men+12] T. Mensink, J. Verbeek, F. Perronnin,
and G. Csurka. “Metric Learning for Large
Scale Image Classification: Generalizing to
New Classes at Near-Zero Cost”. In: ECCV.
Springer Berlin Heidelberg, 2012, pp. 488–
501.
[Met21] C. Metz. Genius Makers: The Mavericks
Who Brought AI to Google, Facebook, and
the World. en. Dutton, 2021.
[MF17] J. Matejka and G. Fitzmaurice. “Same Stats,
Different Graphs: Generating Datasets with
Varied Appearance and Identical Statistics
through Simulated Annealing”. In: Proceed￾ings of the 2017 CHI Conference on Hu￾man Factors in Computing Systems. New
York, NY, USA: Association for Computing
Machinery, May 2017, pp. 1290–1294.
[MFR20] G. M. Martin, D. T. Frazier, and C. P.
Robert. “Computing Bayes: Bayesian Com￾putation from 1763 to the 21st Century”. In:
(Apr. 2020). arXiv: 2004.06425 [stat.CO].
[MG05] I. Murray and Z. Ghahramani. A note on the
evidence and Bayesian Occam’s razor. Tech.
rep. Gatsby, 2005.
[MH07] A. Mnih and G. Hinton. “Three new graphi￾cal models for statistical language modelling”.
en. In: ICML. 2007.
[MH08] L. v. d. Maaten and G. Hinton. “Visualizing
Data using t-SNE”. In: JMLR 9.Nov (2008),
pp. 2579–2605.
[MHM18] L. McInnes, J. Healy, and J. Melville.
“UMAP: Uniform Manifold Approximation
and Projection for Dimension Reduction”. In:
(Feb. 2018). arXiv: 1802.03426 [stat.ML].
[MHN13] A. L. Maas, A. Y. Hannun, and A. Y. Ng.
“Rectifier Nonlinearities Improve Neural Net￾work Acoustic Models”. In: ICML. Vol. 28.
2013.
[Mik+13a] T. Mikolov, K. Chen, G. Corrado, and J.
Dean. “Efficient Estimation of Word Repre￾sentations in Vector Space”. In: ICLR. 2013.
[Mik+13b] T. Mikolov, I. Sutskever, K. Chen, G. Cor￾rado, and J. Dean. “Distributed Representa￾tions of Words and Phrases and their Compo￾sitionality”. In: NIPS. 2013.
[Mik+13c] T. Mikolov, I. Sutskever, K. Chen, G. S.
Corrado, and J. Dean. “Distributed represen￾tations of words and phrases and their compo￾sitionality”. In: NIPS. 2013, pp. 3111–3119.
[Min00] T. Minka. Bayesian model averaging is not
model combination. Tech. rep. MIT Media
Lab, 2000.
[Min+09] M. Mintz, S. Bills, R. Snow, and D. Jurafksy.
“Distant supervision for relation extraction
without labeled data”. In: Prof. Conf. Recent
Advances in NLP. 2009.
[Mit97] T. Mitchell. Machine Learning. McGraw Hill,
1997.
[Miy+18] T. Miyato, S.-I. Maeda, M. Koyama, and
S. Ishii. “Virtual Adversarial Training: A
Regularization Method for Supervised and
Semi-Supervised Learning”. In: IEEE PAMI
(2018).
[MK97] G. J. McLachlan and T. Krishnan. The EM
Algorithm and Extensions. Wiley, 1997.
[MKH19] R. Müller, S. Kornblith, and G. E. Hinton.
“When does label smoothing help?” In: NIPS.
2019, pp. 4694–4703.
[MKL11] O. Martin, R. Kumar, and J. Lao. Bayesian
Modeling and Computation in Python. CRC
Press, 2011.
[MKS21] K. Murphy, A. Kumar, and S. Serghiou. “Risk
score learning for COVID-19 contact tracing
apps”. In: Machine Learning for Healthcare.
Apr. 2021.
[MM16] D. Mishkin and J. Matas. “All you need is a
good init”. In: ICLR. 2016.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license812 BIBLIOGRAPHY
[MN89] P. McCullagh and J. Nelder. Generalized lin￾ear models. 2nd edition. Chapman and Hall,
1989.
[MNM02] W. Maass, T. Natschlaeger, and H. Markram.
“Real-time computing without stable states:
A new framework for neural computation
based on perturbations”. In: Neural Compu￾tation 14.11 (2002), 2531––2560.
[MO04] S. C. Madeira and A. L. Oliveira. “Bicluster￾ing Algorithms for Biological Data Analysis:
A Survey”. In: IEEE/ACM Transactions on
Computational Biology and Bioinformatics
1.1 (2004), pp. 24–45.
[Mol04] C. Moler. Numerical Computing with MAT￾LAB. SIAM, 2004.
[Mon+14] G. F. Montufar, R. Pascanu, K. Cho, and Y.
Bengio. “On the Number of Linear Regions of
Deep Neural Networks”. In: NIPS. 2014.
[Mon+17] F. Monti, D. Boscaini, J. Masci, E. Rodola,
J. Svoboda, and M. M. Bronstein. “Geometric
deep learning on graphs and manifolds using
mixture model cnns”. In: Proceedings of the
IEEE Conference on Computer Vision and
Pattern Recognition. 2017, pp. 5115–5124.
[Mon+19] N. Monath, A. Kobren, A. Krishnamurthy,
M. R. Glass, and A. McCallum. “Scalable Hi￾erarchical Clustering with Tree Grafting”. In:
KDD. KDD ’19. Anchorage, AK, USA: Asso￾ciation for Computing Machinery, July 2019,
pp. 1438–1448.
[Mon+21] N. Monath et al. “Scalable Bottom-Up Hier￾archical Clustering”. In: KDD. 2021.
[Mor+16] R. D. Morey, R. Hoekstra, J. N. Rouder,
M. D. Lee, and E.-J. Wagenmakers. “The fal￾lacy of placing confidence in confidence inter￾vals”. en. In: Psychon. Bull. Rev. 23.1 (Feb.
2016), pp. 103–123.
[MOT15] A. Mordvintsev, C. Olah, and M. Tyka. In￾ceptionism: Going Deeper into Neural Net￾works. https : / / ai . googleblog . com / 2015 /
06/inceptionism- going- deeper- into- neural.
html. Accessed: NA-NA-NA. 2015.
[MP43] W. McCulloch and W. Pitts. “A logical cal￾culus of the ideas immanent in nervous activ￾ity”. In: Bulletin of Mathematical Biophysics
5 (1943), pp. 115–137.
[MP69] M. Minsky and S. Papert. Perceptrons. MIT
Press, 1969.
[MRS08] C. Manning, P. Raghavan, and H. Schuetze.
Introduction to Information Retrieval. Cam￾bridge University Press, 2008.
[MS11] D. Mayo and A. Spanos. “Error Statistics”.
In: Handbook of Philosophy of Science. Ed.
by P. S. Bandyopadhyay and M. R. Forster.
2011.
[Muk+19] B. Mukhoty, G. Gopakumar, P. Jain,
and P. Kar. “Globally-convergent Iteratively
Reweighted Least Squares for Robust Regres￾sion Problems”. In: AISTATS. 2019, pp. 313–
322.
[Mur22] K. P. Murphy. Probabilistic Machine Learn￾ing: Advanced Topics. MIT Press, 2022.
[MV15] A Mahendran and A Vedaldi. “Understand￾ing deep image representations by inverting
them”. In: CVPR. June 2015, pp. 5188–5196.
[MV16] A. Mahendran and A. Vedaldi. “Visualizing
Deep Convolutional Neural Networks Using
Natural Pre-images”. In: Intl. J. Computer
Vision (2016), pp. 1–23.
[MWK16] A. H. Marblestone, G. Wayne, and K. P. Ko￾rding. “Toward an Integration of Deep Learn￾ing and Neuroscience”. en. In: Front. Comput.
Neurosci. 10 (2016), p. 94.
[MWP98] B Moghaddam, W Wahid, and A Pentland.
“Beyond eigenfaces: probabilistic matching
for face recognition”. In: Proceedings Third
IEEE International Conference on Auto￾matic Face and Gesture Recognition. Apr.
1998, pp. 30–35.
[Nad+19] S. Naderi, K. He, R. Aghajani, S.
Sclaroff, and P. Felzenszwalb. “Generalized
Majorization-Minimization”. In: ICML. 2019.
[Nea96] R. Neal. Bayesian learning for neural net￾works. Springer, 1996.
[Nes04] Y. Nesterov. Introductory Lectures on Con￾vex Optimization. A basic course. Kluwer,
2004.
[Neu04] A. Neumaier. “Complete search in continu￾ous global optimization and constraint sat￾isfaction”. In: Acta Numer. 13 (May 2004),
pp. 271–369.
[Neu17] G. Neubig. “Neural Machine Translation and
Sequence-to-sequence Models: A Tutorial”. In:
(Mar. 2017). arXiv: 1703.01619 [cs.CL].
[Ngu+17] A. Nguyen, J. Yosinski, Y. Bengio, A. Doso￾vitskiy, and J. Clune. “Plug & Play Genera￾tive Networks: Conditional Iterative Genera￾tion of Images in Latent Space”. In: CVPR.
2017.
[NH98] R. M. Neal and G. E. Hinton. “A View of
the EM Algorithm that Justifies Incremental,
Sparse, and other Variants”. In: Learning in
Graphical Models. Ed. by M. I. Jordan. Dor￾drecht: Springer Netherlands, 1998, pp. 355–
368.
[NHLS19] E. Nalisnick, J. M. Hernández-Lobato, and
P. Smyth. “Dropout as a Structured Shrink￾age Prior”. In: ICML. 2019.
[Nic+15] M. Nickel, K. Murphy, V. Tresp, and E.
Gabrilovich. “A Review of Relational Ma￾chine Learning for Knowledge Graphs”. In:
Proc. IEEE (2015).
[Niu+11] F. Niu, B. Recht, C. Re, and S. J. Wright.
“HOGWILD!: A Lock-Free Approach to Par￾allelizing Stochastic Gradient Descent”. In:
NIPS. 2011.
[NJ02] A. Y. Ng and M. I. Jordan. “On Discrimi￾native vs. Generative Classifiers: A compar￾ison of logistic regression and Naive Bayes”.
In: NIPS-14. 2002.
[NJW01] A. Ng, M. Jordan, and Y. Weiss. “On Spec￾tral Clustering: Analysis and an algorithm”.
In: NIPS. 2001.
[NK17] M. Nickel and D. Kiela. “Poincaré embed￾dings for learning hierarchical representa￾Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 813
tions”. In: Advances in neural information
processing systems. 2017, pp. 6338–6347.
[NK18] M. Nickel and D. Kiela. “Learning Continuous
Hierarchies in the Lorentz Model of Hyper￾bolic Geometry”. In: International Confer￾ence on Machine Learning. 2018, pp. 3779–
3788.
[NK19] T. Niven and H.-Y. Kao. “Probing Neural
Network Comprehension of Natural Language
Arguments”. In: Proc. ACL. 2019.
[NMC05] A. Niculescu-Mizil and R. Caruana. “Pre￾dicting Good Probabilities with Supervised
Learning”. In: ICML. 2005.
[Nou+02] M. N. Nounou, B. R. Bakshi, P. K. Goel, and
X. Shen. “Process modeling by Bayesian la￾tent variable regression”. In: Am. Inst. Chem￾ical Engineers Journal 48.8 (Aug. 2002),
pp. 1775–1793.
[Nov62] A. Novikoff. “On convergence proofs on per￾ceptrons”. In: Symp. on the Mathematical
Theory of Automata 12 (1962), pp. 615–622.
[NR18] G. Neu and L. Rosasco. “Iterate Averaging
as Regularization for Stochastic Gradient De￾scent”. In: COLT. 2018.
[NTL20] J. Nixon, D. Tran, and B. Lakshminarayanan.
“Why aren’t bootstrapped neural networks
better?” In: NIPS Workshop on “I can’t be￾lieve it’s not better”. 2020.
[NW06] J. Nocedal and S. Wright. Numerical Opti￾mization. Springer, 2006.
[Ode16] A. Odena. “Semi-supervised learning with
generative adversarial networks”. In: arXiv
preprint arXiv:1606.01583 (2016).
[OLV18] A. van den Oord, Y. Li, and O. Vinyals. “Rep￾resentation Learning with Contrastive Predic￾tive Coding”. In: (July 2018). arXiv: 1807 .
03748 [cs.LG].
[OMS17] C. Olah, A. Mordvintsev, and L. Schubert.
“Feature Visualization”. In: Distill (2017).
[oor+16] A. Van den oord et al. “WaveNet: A Gener￾ative Model for Raw Audio”. In: (Dec. 2016).
arXiv: 1609.03499 [cs.SD].
[Oor+18] A. van den Oord et al. “Parallel WaveNet:
Fast High-Fidelity Speech Synthesis”. In:
ICML. Ed. by J. Dy and A. Krause.
Vol. 80. Proceedings of Machine Learning Re￾search. Stockholmsmässan, Stockholm Swe￾den: PMLR, 2018, pp. 3918–3926.
[OPK12] G. Ohloff, W. Pickenhagen, and P. Kraft.
Scent and Chemistry. en. Wiley, Jan. 2012.
[OPT00a] M. R. Osborne, B. Presnell, and B. A.
Turlach. “A new approach to variable se￾lection in least squares problems”. In: IMA
Journal of Numerical Analysis 20.3 (2000),
pp. 389–403.
[OPT00b] M. R. Osborne, B. Presnell, and B. A.
Turlach. “On the lasso and its dual”. In:
J. Computational and graphical statistics 9
(2000), pp. 319–337.
[Ort+19] P. A. Ortega et al. “Meta-learning of Sequen￾tial Strategies”. In: (May 2019). arXiv: 1905.
03030 [cs.LG].
[Osb16] I. Osband. “Risk versus Uncertainty in Deep
Learning: Bayes, Bootstrap and the Dangers
of Dropout”. In: NIPS workshop on Bayesian
deep learning. 2016.
[OTJ07] G. Obozinski, B. Taskar, and M. I. Jordan.
Joint covariate selection for grouped classi￾fication. Tech. rep. UC Berkeley, 2007.
[Pai05] A. Pais. Subtle Is the Lord: The Science and
the Life of Albert Einstein. en. Oxford Uni￾versity Press, Nov. 2005.
[Pan+15] V. Panayotov, G. Chen, D. Povey, and
S. Khudanpur. “Librispeech: an asr corpus
based on public domain audio books”. In:
ICASSP. IEEE. 2015, pp. 5206–5210.
[Pap+18] G. Papandreou, T. Zhu, L.-C. Chen, S. Gi￾daris, J. Tompson, and K. Murphy. “Person￾Lab: Person Pose Estimation and Instance
Segmentation with a Bottom-Up, Part-Based,
Geometric Embedding Model”. In: ECCV.
2018, pp. 269–286.
[Par+16a] A. Parikh, O. Täckström, D. Das, and J.
Uszkoreit. “A Decomposable Attention Model
for Natural Language Inference”. In: EMNLP.
Austin, Texas: Association for Computational
Linguistics, Nov. 2016, pp. 2249–2255.
[Par+16b] A. Parikh, O. Täckström, D. Das, and J.
Uszkoreit. “A Decomposable Attention Model
for Natural Language Inference”. In: EMNLP.
Association for Computational Linguistics,
Nov. 2016, pp. 2249–2255.
[Par+18] N. Parmar et al. “Image Transformer”. In:
ICLR. 2018.
[PARS14] B. Perozzi, R. Al-Rfou, and S. Skiena.
“Deepwalk: Online learning of social rep￾resentations”. In: Proceedings of the 20th
ACM SIGKDD international conference on
Knowledge discovery and data mining. ACM.
2014, pp. 701–710.
[Pas14] R. Pascanu. “On Recurrent and Deep Neural
Networks”. PhD thesis. U. Montreal, 2014.
[Pat12] A. Paterek. Predicting movie ratings and
recommender systems. 2012.
[Pat+16] D. Pathak, P. Krahenbuhl, J. Donahue, T.
Darrell, and A. A. Efros. “Context Encoders:
Feature Learning by Inpainting”. In: CVPR.
2016.
[Pau+20] A. Paullada, I. D. Raji, E. M. Bender,
E. Denton, and A. Hanna. “Data and its
(dis)contents: A survey of dataset develop￾ment and use in machine learning research”.
In: NeurIPS 2020 Workshop: ML Retrospec￾tives, Surveys & Meta-analyses (ML-RSA).
Dec. 2020.
[PB+14] N. Parikh, S. Boyd, et al. “Proximal algo￾rithms”. In: Foundations and Trends in Op￾timization 1.3 (2014), pp. 127–239.
[Pea18] J. Pearl. Theoretical Impediments to Ma￾chine Learning With Seven Sparks from the
Causal Revolution. Tech. rep. UCLA, 2018.
[Pen+20] Z. Peng et al. “Graph Representation Learn￾ing via Graphical Mutual Information Maxi￾mization”. In: Proceedings of The Web Con￾ference. 2020.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license814 BIBLIOGRAPHY
[Per+17] B. Perozzi, V. Kulkarni, H. Chen, and S.
Skiena. “Don’t Walk, Skip! Online Learn￾ing of Multi-Scale Network Embeddings”. In:
Proceedings of the 2017 IEEE/ACM Inter￾national Conference on Advances in So￾cial Networks Analysis and Mining 2017.
ASONAM ’17. Sydney, Australia: Association
for Computing Machinery, 2017, 258–265.
[Pet13] J. Peters. When Ice Cream Sales Rise, So
Do Homicides. Coincidence, or Will Your
Next Cone Murder You? https://slate.com/
news - and - politics / 2013 / 07 / warm - weather -
homicide-rates-when-ice-cream-sales-rise￾homicides- rise- coincidence.html. Accessed:
2020-5-20. July 2013.
[Pet+18] M. E. Peters et al. “Deep contextualized word
representations”. In: NAACL. 2018.
[Pey20] G. Peyre. “Course notes on Optimization for
Machine Learning”. 2020.
[PH18] T. Parr and J. Howard. “The Matrix Calcu￾lus You Need For Deep Learning”. In: (Feb.
2018). arXiv: 1802.01528 [cs.LG].
[Pin88] F. J. Pineda. “Generalization of back prop￾agation to recurrent and higher order neural
networks”. In: Neural information processing
systems. 1988, pp. 602–611.
[Piz01] Z Pizlo. “Perception viewed as an inverse
problem”. en. In: Vision Res. 41.24 (Nov.
2001), pp. 3145–3161.
[PJ09] H.-S. Park and C.-H. Jun. “A simple and fast
algorithm for K-medoids clustering”. In: Ex￾pert Systems with Applciations 36.2, Part 2
(2009), pp. 3336–3341.
[PJ92] B Polyak and A Juditsky. “Acceleration of
Stochastic Approximation by Averaging”. In:
SIAM J. Control Optim. 30.4 (July 1992),
pp. 838–855.
[Pla00] J. Platt. “Probabilities for SV machines”. In:
Advances in Large Margin Classifiers. Ed.
by A. Smola, P. Bartlett, B. Schoelkopf, and
D. Schuurmans. MIT Press, 2000.
[Pla98] J. Platt. “Using analytic QP and sparseness
to speed training of support vector machines”.
In: NIPS. 1998.
[PM17] D. L. Poole and A. K. Mackworth. Ar￾tificial intelligenceL foundations computa￾tional agents 2nd edition. Cambridge Univer￾sity Press, Nov. 2017.
[PM18] J. Pearl and D. Mackenzie. The book of why:
the new science of cause and effect. 2018.
[PMB19] J. Pérez, J. Marinkovic, and P. Barcelo. “On
the Turing Completeness of Modern Neural
Network Architectures”. In: ICLR. 2019.
[Pog+17] T. Poggio, H. Mhaskar, L. Rosasco, B. Mi￾randa, and Q. Liao. “Why and when can deep￾but not shallow-networks avoid the curse of
dimensionality: A review”. en. In: Int. J. Au￾tom. Comput. (2017), pp. 1–17.
[PP+20] M. Papadatou-Pastou et al. “Human handed￾ness: A meta-analysis”. en. In: Psychol. Bull.
146.6 (June 2020), pp. 481–524.
[PPS18] T. Pierrot, N. Perrin, and O. Sigaud. “First￾order and second-order variants of the gradi￾ent descent in a unified framework”. In: (Oct.
2018). arXiv: 1810.08102 [cs.LG].
[Pre21] K. Pretz. “Stop Calling Everything AI,
Machine-Learning Pioneer Says”. In: IEEE
Spectrum (2021).
[PSM14a] J. Pennington, R. Socher, and C. Manning.
“GloVe: Global vectors for word representa￾tion”. In: EMNLP. 2014, pp. 1532–1543.
[PSM14b] J. Pennington, R. Socher, and C. Manning.
“Glove: Global vectors for word representa￾tion”. In: Proceedings of the 2014 conference
on empirical methods in natural language
processing (EMNLP). 2014, pp. 1532–1543.
[PSW15] N. G. Polson, J. G. Scott, and B. T. Willard.
“Proximal Algorithms in Statistics and Ma￾chine Learning”. en. In: Stat. Sci. 30.4 (Nov.
2015), pp. 559–581.
[QC+06] J. Quiñonero-Candela, C. E. Rasmussen, F.
Sinz, O. Bousquet, and B. Schölkopf. “Evalu￾ating Predictive Uncertainty Challenge”. In:
Machine Learning Challenges. Evaluating
Predictive Uncertainty, Visual Object Clas￾sification, and Recognising Tectual Entail￾ment. Lecture Notes in Computer Science.
Springer Berlin Heidelberg, 2006, pp. 1–27.
[Qia+19] Q. Qian, L. Shang, B. Sun, J. Hu, H. Li, and
R. Jin. “SoftTriple Loss: Deep Metric Learn￾ing Without Triplet Sampling”. In: ICCV.
2019.
[Qiu+18] J. Qiu, Y. Dong, H. Ma, J. Li, K. Wang,
and J. Tang. “Network embedding as ma￾trix factorization: Unifying deepwalk, line,
pte, and node2vec”. In: Proceedings of the
Eleventh ACM International Conference on
Web Search and Data Mining. 2018, pp. 459–
467.
[Qiu+19a] J. Qiu, H. Ma, O. Levy, S. W. Yih, S. Wang,
and J. Tang. “Blockwise Self-Attention for
Long Document Understanding”. In: CoRR
abs/1911.02972 (2019). arXiv: 1911.02972.
[Qiu+19b] J. Qiu et al. “NetSMF: Large-Scale Net￾work Embedding as Sparse Matrix Factor￾ization”. In: The World Wide Web Confer￾ence. WWW ’19. San Francisco, CA, USA:
Association for Computing Machinery, 2019,
1509–1520.
[Qui86] J. R. Quinlan. “Induction of decision trees”.
In: Machine Learning 1 (1986), pp. 81–106.
[Qui93] J. R. Quinlan. C4.5 Programs for Machine
Learning. Morgan Kauffman, 1993.
[Rad+] A. Radford et al. Learning transferable vi￾sual models from natural language supervi￾sion. Tech. rep. OpenAI.
[Rad+18] A. Radford, K. Narasimhan, T. Salimans,
and I. Sutskever. Improving Language Un￾derstanding by Generative Pre-Training.
Tech. rep. OpenAI, 2018.
[Rad+19] A. Radford, J. Wu, R. Child, D. Luan, D.
Amodei, and I. Sutskever. Language Models
are Unsupervised Multitask Learners. Tech.
rep. OpenAI, 2019.
[Raf+19] C. Raffel et al. “Exploring the Limits of
Transfer Learning with a Unified Text-to￾Text Transformer”. In: (Oct. 2019). arXiv:
1910.10683 [cs.LG].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 815
[Rag+17] M. Raghu, B. Poole, J. Kleinberg, S. Ganguli,
and J. Sohl-Dickstein. “On the Expressive
Power of Deep Neural Networks”. In: ICML.
2017.
[Rag+19] M. Raghu, C. Zhang, J. Kleinberg, and S.
Bengio. “Transfusion: Understanding transfer
learning for medical imaging”. In: NIPS. 2019,
pp. 3347–3357.
[Raj+16] P. Rajpurkar, J. Zhang, K. Lopyrev, and P.
Liang. “SQuAD: 100,000+ Questions for Ma￾chine Comprehension of Text”. In: EMNLP.
2016.
[Raj+18] A. Rajkomar et al. “Scalable and accurate
deep learning with electronic health records”.
en. In: NPJ Digit Med 1 (May 2018), p. 18.
[Rat+09] M. Rattray, O. Stegle, K. Sharp, and J. Winn.
“Inference algorithms and learning theory for
Bayesian sparse factor analysis”. In: Proc.
Intl. Workshop on Statistical-Mechanical In￾formatics. 2009.
[RB93] M. Riedmiller and H. Braun. “A direct
adaptive method for faster backpropagation
learning: The RPROP algorithm”. In: ICNN.
IEEE. 1993, pp. 586–591.
[RBV17] S.-A. Rebuffi, H. Bilen, and A. Vedaldi.
“Learning multiple visual domains with resid￾ual adapters”. In: NIPS. 2017.
[RBV18] S.-A. Rebuffi, H. Bilen, and A. Vedaldi. “Ef￾ficient parametrization of multi-domain deep
neural networks”. In: CVPR. 2018.
[RC04] C. Robert and G. Casella. Monte Carlo
Statisical Methods. 2nd edition. Springer,
2004.
[Rec+19] B. Recht, R. Roelofs, L. Schmidt, and V.
Shankar. “Do Image Net Classifiers General￾ize to Image Net?” In: ICML. 2019.
[Red+16] J Redmon, S Divvala, R Girshick, and A
Farhadi. “You Only Look Once: Unified, Real￾Time Object Detection”. In: CVPR. 2016,
pp. 779–788.
[Ren+09] S. Rendle, C. Freudenthaler, Z. Gantner, and
L. Schmidt-Thieme. “BPR: Bayesian Person￾alized Ranking from Implicit Feedback”. In:
UAI. 2009.
[Ren12] S. Rendle. “Factorization Machines with
libFM”. In: ACM Trans. Intell. Syst. Tech￾nol. 3.3 (May 2012), pp. 1–22.
[Ren19] Z. Ren. List of papers on self-supervised
learning. 2019.
[Res+11] D. Reshef et al. “Detecting Novel Associa￾tions in Large Data Sets”. In: Science 334
(2011), pp. 1518–1524.
[Res+16] Y. A. Reshef, D. N. Reshef, H. K. Finu￾cane, P. C. Sabeti, and M. Mitzenmacher.
“Measuring Dependence Powerfully and Eq￾uitably”. In: J. Mach. Learn. Res. 17.211
(2016), pp. 1–63.
[RF17] J. Redmon and A. Farhadi. “YOLO9000: Bet￾ter, Faster, Stronger”. In: CVPR. 2017.
[RFB15] O. Ronneberger, P. Fischer, and T. Brox.
“U-Net: Convolutional Networks for Biomedi￾cal Image Segmentation”. In: MICCAI (Intl.
Conf. on Medical Image Computing and
Computer Assisted Interventions). 2015.
[RG11] A. Rodriguez and K. Ghosh. Modeling rela￾tional data through nested partition models.
Tech. rep. UC Santa Cruz, 2011.
[RHS05] C. Rosenberg, M. Hebert, and H. Schneider￾man. “Semi-Supervised Self-Training of Ob￾ject Detection Models”. In: Proceedings of the
Seventh IEEE Workshops on Application
of Computer Vision (WACV/MOTION’05)-
Volume 1-Volume 01. 2005, pp. 29–36.
[RHW86] D. Rumelhart, G. Hinton, and R. Williams.
“Learning internal representations by error
propagation”. In: Parallel Distributed Pro￾cessing: Explorations in the Microstructure
of Cognition. Ed. by D. Rumelhart, J. Mc￾Clelland, and the PDD Research Group. MIT
Press, 1986.
[Ric95] J. Rice. Mathematical statistics and data
analysis. 2nd edition. Duxbury, 1995.
[Rif+11] S. Rifai, P. Vincent, X. Muller, X. Glorot, and
Y. Bengio. “Contractive Auto-Encoders: Ex￾plicit Invariance During Feature Extraction”.
In: ICML. 2011.
[Ris+08] I. Rish, G. Grabarnik, G. Cecchi, F. Pereira,
and G. Gordon. “Closed-form supervised di￾mensionality reduction with generalized lin￾ear models”. In: ICML. 2008.
[RKK18] S. J. Reddi, S. Kale, and S. Kumar. “On the
Convergence of Adam and Beyond”. In: ICLR.
2018.
[RM01] N. Roy and A. McCallum. “Toward optimal
active learning through Monte Carlo estima￾tion of error reduction”. In: ICML. 2001.
[RMC09] H. Rue, S. Martino, and N. Chopin. “Approx￾imate Bayesian Inference for Latent Gaussian
Models Using Integrated Nested Laplace Ap￾proximations”. In: J. of Royal Stat. Soc. Se￾ries B 71 (2009), pp. 319–392.
[RMW14] D. J. Rezende, S. Mohamed, and D. Wier￾stra. “Stochastic Backpropagation and Ap￾proximate Inference in Deep Generative Mod￾els”. In: ICML. Ed. by E. P. Xing and T. Je￾bara. Vol. 32. Proceedings of Machine Learn￾ing Research. Bejing, China: PMLR, 2014,
pp. 1278–1286.
[RN10] S. Russell and P. Norvig. Artificial Intel￾ligence: A Modern Approach. 3rd edition.
Prentice Hall, 2010.
[Roo+21] F. de Roos, C. Jidling, A. Wills, T. Schön,
and P. Hennig. “A Probabilistically Moti￾vated Learning Rate Adaptation for Stochas￾tic Optimization”. In: (Feb. 2021). arXiv:
2102.10880 [cs.LG].
[Ros58] F. Rosenblatt. “The Perceptron: A Probabilis￾tic Model for Information Storage and Orga￾nization in the Brain”. In: Psychological Re￾view 65.6 (1958), pp. 386–408.
[Ros98] K. Rose. “Deterministic Annealing for Clus￾tering, Compression, Classification, Regres￾sion, and Related Optimization Problems”. In:
Proc. IEEE 80 (1998), pp. 2210–2239.
[Rot+20] K. Roth, T. Milbich, S. Sinha, P. Gupta, B.
Ommer, and J. P. Cohen. “Revisiting Train￾ing Strategies and Generalization Perfor￾Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license816 BIBLIOGRAPHY
mance in Deep Metric Learning”. In: ICML.
2020.
[Rou+09] J. Rouder, P. Speckman, D. Sun, and R.
Morey. “Bayesian t tests for accepting and re￾jecting the null hypothesis”. In: Psychonomic
Bulletin & Review 16.2 (2009), pp. 225–237.
[Row97] S. Roweis. “EM algorithms for PCA and
SPCA”. In: NIPS. 1997.
[Roy+20] A. Roy, M. Saffar, A. Vaswani, and D. Grang￾ier. “Efficient Content-Based Sparse Atten￾tion with Routing Transformers”. In: CoRR
abs/2003.05997 (2020). arXiv: 2003.05997.
[Roz+19] B. Rozemberczki, R. Davies, R. Sarkar, and
C. Sutton. “GEMSEC: Graph Embedding
with Self Clustering”. In: Proceedings of
the 2019 IEEE/ACM International Confer￾ence on Advances in Social Networks Anal￾ysis and Mining. ASONAM ’19. Vancouver,
British Columbia, Canada: Association for
Computing Machinery, 2019, 65–72.
[RP99] M. Riesenhuber and T. Poggio. “Hierarchi￾cal Models of Object Recognition in Cortex”.
In: Nature Neuroscience 2 (1999), pp. 1019–
1025.
[RR08] A. Rahimi and B. Recht. “Random Features
for Large-Scale Kernel Machines”. In: NIPS.
Curran Associates, Inc., 2008, pp. 1177–1184.
[RR09] A. Rahimi and B. Recht. “Weighted Sums
of Random Kitchen Sinks: Replacing min￾imization with randomization in learning”.
In: NIPS. Curran Associates, Inc., 2009,
pp. 1313–1320.
[RS00] S. T. Roweis and L. K. Saul. “Nonlinear
dimensionality reduction by locally linear
embedding”. en. In: Science 290.5500 (Dec.
2000), pp. 2323–2326.
[RT82] D. B. Rubin and D. T. Thayer. “EM algo￾rithms for ML factor analysis”. In: Psychome￾trika 47.1 (Mar. 1982), pp. 69–76.
[Rub84] D. B. Rubin. “Bayesianly Justifiable and Rel￾evant Frequency Calculations for the Ap￾plied Statistician”. In: Ann. Stat. 12.4 (1984),
pp. 1151–1172.
[Rup88] D Ruppert. Efficient Estimations from a
Slowly Convergent Robbins-Monro Process.
Tech. rep. 1988.
[Rus+15] O. Russakovsky et al. “ImageNet Large Scale
Visual Recognition Challenge”. In: Intl. J.
Computer Vision (2015), pp. 1–42.
[Rus15] S. Russell. “Unifying Logic and Probability”.
In: Commun. ACM 58.7 (June 2015), pp. 88–
97.
[Rus18] A. M. Rush. “The Annotated Transformer”.
In: Proceedings of ACL Workshop on Open
Source Software for NLP. 2018.
[Rus19] S. Russell. Human Compatible: Artificial In￾telligence and the Problem of Control. en.
Kindle. Viking, Oct. 2019.
[RW06] C. E. Rasmussen and C. K. I. Williams. Gaus￾sian Processes for Machine Learning. MIT
Press, 2006.
[RY21] D. Roberts and S. Yaida. The Principles of
Deep Learning Theory: An Effective Theory
Approach to Understanding Neural Network.
2021.
[RZL17] P. Ramachandran, B. Zoph, and Q. V. Le.
“Searching for Activation Functions”. In: (Oct.
2017). arXiv: 1710.05941 [cs.NE].
[SA93] P Sinha and E Adelson. “Recovering re￾flectance and illumination in a world of
painted polyhedra”. In: ICCV. May 1993,
pp. 156–163.
[Sab21] W. Saba. “Machine Learning Won’t Solve
Natural Language Understanding”. In: (Aug.
2021).
[Sal+16] T. Salimans, I. Goodfellow, W. Zaremba, V.
Cheung, A. Radford, and X. Chen. “Improved
Techniques for Training GANs”. In: (2016).
arXiv: 1606.03498 [cs.LG].
[SAM04] D. J. Spiegelhalter, K. R. Abrams, and J. P.
Myles. Bayesian Approaches to Clinical Tri￾als and Health-Care Evaluation. Wiley, 2004.
[San+18a] M. Sandler, A. Howard, M. Zhu, A. Zhmogi￾nov, and L.-C. Chen. “Inverted Residuals and
Linear Bottlenecks: Mobile Networks for Clas￾sification, Detection and Segmentation”. In:
(Jan. 2018). arXiv: 1801.04381 [cs.CV].
[San+18b] S. Santurkar, D. Tsipras, A. Ilyas, and A.
Madry. “How Does Batch Normalization Help
Optimization? (No, It Is Not About Internal
Covariate Shift)”. In: NIPS. 2018.
[San96] R. Santos. “Equivalence of regularization and
truncated iteration for general ill-posed prob￾lems”. In: Linear Algebra and its Applica￾tions 236.15 (1996), pp. 25–33.
[Sar11] R. Sarkar. “Low distortion delaunay embed￾ding of trees in hyperbolic plane”. In: In￾ternational Symposium on Graph Drawing.
Springer. 2011, pp. 355–366.
[SAV20] E. Stevens, L. Antiga, and T. Viehmann.
Deep Learning with PyTorch. Manning,
2020.
[SBB01] T. Sellke, M. J. Bayarri, and J. Berger. “Cal￾ibration of p Values for Testing Precise Null
Hypotheses”. In: The American Statistician
55.1 (2001), pp. 62–71.
[SBP17] Y Sun, P Babu, and D. P. Palomar.
“Majorization-Minimization Algorithms in
Signal Processing, Communications, and Ma￾chine Learning”. In: IEEE Trans. Signal Pro￾cess. 65.3 (Feb. 2017), pp. 794–816.
[SBS20] K. Shi, D. Bieber, and C. Sutton. “Incre￾mental sampling without replacement for se￾quence models”. In: ICML. Feb. 2020.
[Sca+09] F. Scarselli, M. Gori, A. C. Tsoi, M. Hagen￾buchner, and G. Monfardini. “The graph neu￾ral network model”. In: IEEE Transactions
on Neural Networks 20.1 (2009), pp. 61–80.
[Sca+17] S. Scardapane, D. Comminiello, A. Hussain,
and A. Uncini. “Group Sparse Regularization
for Deep Neural Networks”. In: Neurocomput￾ing 241 (2017).
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 817
[Sch+00] B Scholkopf, A. J. Smola, R. C. Williamson,
and P. L. Bartlett. “New support vector al￾gorithms”. en. In: Neural Comput. 12.5 (May
2000), pp. 1207–1245.
[Sch19] B. Schölkopf. “Causality for Machine Learn￾ing”. In: (Nov. 2019). arXiv: 1911 . 10500
[cs.LG].
[Sch78] G. Schwarz. “Estimating the dimension of a
model”. In: Annals of Statistics 6.2 (1978),
pp. 461–464.
[Sch90] R. E. Schapire. “The strength of weak learn￾ability”. In: Mach. Learn. 5.2 (June 1990),
pp. 197–227.
[Sco79] D. Scott. “On optimal and data-based
histograms”. In: Biometrika 66.3 (1979),
pp. 605–610.
[Scu10] D Sculley. “Web-scale k-means clustering”. In:
WWW. WWW ’10. Raleigh, North Carolina,
USA: Association for Computing Machinery,
Apr. 2010, pp. 1177–1178.
[Scu65] H. Scudder. “Probability of error of some
adaptive pattern-recognition machines”. In:
IEEE Transactions on Information Theory
11.3 (1965), pp. 363–371.
[Sed+15] S. Sedhain, A. K. Menon, S. Sanner, and L.
Xie. “AutoRec: Autoencoders Meet Collabo￾rative Filtering”. In: WWW. WWW ’15 Com￾panion. Florence, Italy: Association for Com￾puting Machinery, May 2015, pp. 111–112.
[Sej18] T. J. Sejnowski. The Deep Learning Revolu￾tion. en. Kindle. The MIT Press, Sept. 2018.
[Set12] B. Settles. “Active learning”. In: Synthesis
Lectures on Artificial Intelligence and Ma￾chine Learning 6 (2012), 1–114.
[SF12] R. Schapire and Y. Freund. Boosting: Foun￾dations and Algorithms. MIT Press, 2012.
[SGJ11] D. Sontag, A. Globerson, and T. Jaakkola.
“Introduction to Dual Decomposition for
Inference”. In: Optimization for Machine
Learning. Ed. by S. Sra, S. Nowozin, and S. J.
Wright. MIT Press, 2011.
[Sha+06] P. Shafto, C. Kemp, V. Mansinghka, M. Gor￾don, and J. B. Tenenbaum. “Learning cross￾cutting systems of categories”. In: Cognitive
Science Conference. 2006.
[Sha+17] N. Shazeer et al. “Outrageously Large Neu￾ral Networks: The Sparsely-Gated Mixture-of￾Experts Layer”. In: ICLR. 2017.
[Sha88] T. Shallice. From Neuropsychology to Men￾tal Structure. 1988.
[SHB16] R. Sennrich, B. Haddow, and A. Birch. “Neu￾ral Machine Translation of Rare Words with
Subword Units”. In: Proc. ACL. 2016.
[She+18] Z. Shen, M. Zhang, S. Yi, J. Yan,
and H. Zhao. “Factorized Attention: Self￾Attention with Linear Complexities”. In:
CoRR abs/1812.01243 (2018). arXiv: 1812 .
01243.
[She94] J. R. Shewchuk. An introduction to the con￾jugate gradient method without the agoniz￾ing pain. Tech. rep. CMU, 1994.
[SHF15] R. Steorts, R. Hall, and S. Fienberg. “A
Bayesian Approach to Graphical Record Link￾age and De-duplication”. In: JASA (2015).
[Shu+13] D. I. Shuman, S. K. Narang, P Frossard, A
Ortega, and P Vandergheynst. “The emerging
field of signal processing on graphs: Extend￾ing high-dimensional data analysis to net￾works and other irregular domains”. In: IEEE
Signal Process. Mag. 30.3 (2013), pp. 83–98.
[Sin+20] S. Sinha, H. Zhang, A. Goyal, Y. Bengio,
H. Larochelle, and A. Odena. “Small-GAN:
Speeding up GAN Training using Core-Sets”.
In: ICML. Vol. 119. Proceedings of Machine
Learning Research. Virtual: PMLR, 2020,
pp. 9005–9015.
[SIV17] C. Szegedy, S. Ioffe, and V. Vanhoucke.
“Inception-v4, Inception-ResNet and the Im￾pact of Residual Connections on Learning”.
In: AAAI. 2017.
[SJ03] N. Srebro and T. Jaakkola. “Weighted low￾rank approximations”. In: ICML. 2003.
[SJT16] M. Sajjadi, M. Javanmardi, and T. Tas￾dizen. “Regularization with stochastic trans￾formations and perturbations for deep semi￾supervised learning”. In: Advances in neu￾ral information processing systems. 2016,
pp. 1163–1171.
[SK20] S. Singh and S. Krishnan. “Filter Response
Normalization Layer: Eliminating Batch De￾pendence in the Training of Deep Neural Net￾works”. In: CVPR. 2020.
[SKP15] F. Schroff, D. Kalenichenko, and J. Philbin.
“FaceNet: A Unified Embedding for Face
Recognition and Clustering”. In: CVPR.
2015.
[SKT14] A. Szlam, Y. Kluger, and M. Tygert. “An
implementation of a randomized algorithm
for principal component analysis”. In: (2014).
arXiv: 1412.3510 [stat.CO].
[SKTF18] H. Shao, A. Kumar, and P Thomas Fletcher.
“The Riemannian Geometry of Deep Genera￾tive Models”. In: CVPR. 2018, pp. 315–323.
[SL18] S. L. Smith and Q. V. Le. “A Bayesian
Perspective on Generalization and Stochastic
Gradient Descent”. In: ICLR. 2018.
[SL+19] B. Sanchez-Lengeling, J. N. Wei, B. K.
Lee, R. C. Gerkin, A. Aspuru-Guzik, and
A. B. Wiltschko. “Machine Learning for Scent:
Learning Generalizable Perceptual Represen￾tations of Small Molecules”. In: (Oct. 2019).
arXiv: 1910.10685 [stat.ML].
[SL90] D. J. Spiegelhalter and S. L. Lauritzen. “Se￾quential updating of conditional probabilities
on directed graphical structures”. In: Net￾works 20 (1990).
[SLRB17] M. Schmidt, N. Le Roux, and F. Bach. “Min￾imizing finite sums with the stochastic av￾erage gradient”. In: Mathematical Program￾ming 162.1-2 (2017), pp. 83–112.
[SM00] J. Shi and J. Malik. “Normalized Cuts and Im￾age Segmentation”. In: IEEE PAMI (2000).
[SM08] R. Salakhutdinov and A. Mnih. “Probabilis￾tic Matrix Factorization”. In: NIPS. Vol. 20.
2008.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license818 BIBLIOGRAPHY
[SMG14] A. M. Saxe, J. L. McClelland, and S. Ganguli.
“Exact solutions to the nonlinear dynamics of
learning in deep linear neural networks”. In:
ICLR. 2014.
[SMH07] R. Salakhutdinov, A. Mnih, and G. Hinton.
“Restricted Boltzmann machines for collabo￾rative filtering”. In: ICML. ICML ’07. Cor￾valis, Oregon, USA: Association for Comput￾ing Machinery, June 2007, pp. 791–798.
[Smi18] L. Smith. “A disciplined approach to neural
network hyper-parameters: Part 1 – learning
rate, batch size, momentum, and weight de￾cay”. In: (2018).
[Smi+21] S. L. Smith, B. Dherin, D. Barrett, and S.
De. “On the Origin of Implicit Regularization
in Stochastic Gradient Descent”. In: ICLR.
2021.
[SMM03] Q. Sheng, Y. Moreau, and B. D. Moor.
“Biclustering Microarray data by Gibbs
sampling”. In: Bioinformatics 19 (2003),
pp. ii196–ii205.
[SNM16] M. Suzuki, K. Nakayama, and Y. Matsuo.
“Joint Multimodal Learning with Deep Gen￾erative Models”. In: (2016). arXiv: 1611.01891
[stat.ML].
[Soh16] K. Sohn. “Improved Deep Metric Learn￾ing with Multi-class N-pair Loss Objective”.
In: NIPS. Curran Associates, Inc., 2016,
pp. 1857–1865.
[Soh+20] K. Sohn et al. “Fixmatch: Simplify￾ing semi-supervised learning with consis￾tency and confidence”. In: arXiv preprint
arXiv:2001.07685 (2020).
[SP97] M Schuster and K. K. Paliwal. “Bidirectional
recurrent neural networks”. In: IEEE. Trans
on Signal Processing 45.11 (Nov. 1997),
pp. 2673–2681.
[Spe11] T. Speed. “A correlation for the 21st century”.
In: Science 334 (2011), pp. 152–1503.
[SR15] T. Saito and M. Rehmsmeier. “The precision￾recall plot is more informative than the ROC
plot when evaluating binary classifiers on im￾balanced datasets”. en. In: PLoS One 10.3
(Mar. 2015), e0118432.
[SRG03] R. Salakhutdinov, S. T. Roweis, and Z.
Ghahramani. “Optimization with EM and
Expectation-Conjugate-Gradient”. In: ICML.
2003.
[Sri+14] N. Srivastava, G. Hinton, A. Krizhevsky, I.
Sutskever, and R. Salakhutdinov. “Dropout:
A Simple Way to Prevent Neural Networks
from Over tting”. In: JMLR (2014).
[SS01] B. Schlkopf and A. J. Smola. Learning with
Kernels: Support Vector Machines, Regular￾ization, Optimization, and Beyond (Adap￾tive Computation and Machine Learning).
en. 1st edition. The MIT Press, Dec. 2001.
[SS02] B. Schoelkopf and A. Smola. Learning with
Kernels: Support Vector Machines, Regu￾larization, Optimization, and Beyond. MIT
Press, 2002.
[SS05] J. Schaefer and K. Strimmer. “A shrinkage
approach to large-scale covariance matrix es￾timation and implications for functional ge￾nomics”. In: Statist. Appl. Genet. Mol. Biol
4.32 (2005).
[SS19] S. Serrano and N. A. Smith. “Is Attention In￾terpretable?” In: Proc. ACL. 2019.
[SS95] H. T. Siegelmann and E. D. Sontag. “On
the Computational Power of Neural Nets”. In:
J. Comput. System Sci. 50.1 (Feb. 1995),
pp. 132–150.
[SSM98] B. Schoelkopf, A. Smola, and K.-R. Mueller.
“Nonlinear component analysis as a kernel
Eigenvalue problem”. In: Neural Computa￾tion 10 (5 1998), pp. 1299 –1319.
[Sta+06] C. Stark, B.-J. Breitkreutz, T. Reguly, L.
Boucher, A. Breitkreutz, and M. Tyers. “Bi￾oGRID: a general repository for interac￾tion datasets”. In: Nucleic acids research
34.suppl_1 (2006), pp. D535–D539.
[Ste56] C. Stein. “Inadmissibility of the usual esti￾mator for the mean of a multivariate distri￾bution”. In: Proc. 3rd Berkeley Symposium
on Mathematical Statistics and Probability
(1956), 197–206.
[Str09] G. Strang. Introduction to linear algebra. 4th
edition. SIAM Press, 2009.
[Sug+19] A. S. Suggala, K. Bhatia, P. Ravikumar,
and P. Jain. “Adaptive Hard Thresholding
for Near-optimal Consistent Robust Regres￾sion”. In: Proceedings of the Annual Con￾ference On Learning Theory (COLT). 2019,
pp. 2892–2897.
[Sun+09] L. Sun, S. Ji, S. Yu, and J. Ye. “On the
Equivalence Between Canonical Correlation
Analysis and Orthonormalized Partial Least
Squares”. In: IJCAI. 2009.
[Sun+19a] C. Sun, A. Myers, C. Vondrick, K. Mur￾phy, and C. Schmid. “VideoBERT: A Joint
Model for Video and Language Representa￾tion Learning”. In: ICCV. 2019.
[Sun+19b] S. Sun, Z. Cao, H. Zhu, and J. Zhao. “A
Survey of Optimization Methods from a Ma￾chine Learning Perspective”. In: (June 2019).
arXiv: 1906.06821 [cs.LG].
[SVL14] I. Sutskever, O. Vinyals, and Q. V. V. Le.
“Sequence to Sequence Learning with Neural
Networks”. In: NIPS. 2014.
[SVZ14] K. Simonyan, A. Vedaldi, and A. Zisser￾man. “Deep Inside Convolutional Networks:
Visualising Image Classification Models and
Saliency Maps”. In: ICLR. 2014.
[SW87] M. Shewry and H. Wynn. “Maximum entropy
sampling”. In: J. Applied Statistics 14 (1987),
165–170.
[SWY75] G Salton, A Wong, and C. S. Yang. “A vec￾tor space model for automatic indexing”. In:
Commun. ACM 18.11 (Nov. 1975), pp. 613–
620.
[Sze+15a] C. Szegedy, V. Vanhoucke, S. Ioffe, J. Shlens,
and Z. Wojna. “Rethinking the Inception Ar￾chitecture for Computer Vision”. In: (2015).
arXiv: 1512.00567 [cs.CV].
[Sze+15b] C. Szegedy et al. “Going Deeper with Con￾volutions”. In: CVPR. 2015.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 819
[Tal07] N. Taleb. The Black Swan: The Impact of
the Highly Improbable. Random House, 2007.
[Tan+15] J. Tang, M. Qu, M. Wang, M. Zhang, J.
Yan, and Q. Mei. “Line: Large-scale infor￾mation network embedding”. In: Proceedings
of the 24th International Conference on
World Wide Web. International World Wide
Web Conferences Steering Committee. 2015,
pp. 1067–1077.
[Tan+18] C. Tan, F. Sun, T. Kong, W. Zhang, C.
Yang, and C. Liu. “A Survey on Deep Trans￾fer Learning”. In: ICANN. 2018.
[TAS18] M. Teye, H. Azizpour, and K. Smith.
“Bayesian Uncertainty Estimation for Batch
Normalized Deep Networks”. In: ICML. 2018.
[Tay+20a] Y. Tay, M. Dehghani, D. Bahri, and D. Met￾zler. “Efficient Transformers: A Survey”. In:
(Sept. 2020). arXiv: 2009.06732 [cs.LG].
[Tay+20b] Y. Tay et al. “Long Range Arena: A Bench￾mark for efficient Transformers”. In: CoRR
(2020).
[TB97] L. Trefethen and D. Bau. Numerical Linear
Algebra. SIAM, 1997.
[TB99] M. Tipping and C. Bishop. “Probabilistic
principal component analysis”. In: J. of Royal
Stat. Soc. Series B 21.3 (1999), pp. 611–622.
[TDP19] I. Tenney, D. Das, and E. Pavlick. “BERT
Rediscovers the Classical NLP Pipeline”. In:
Proc. ACL. 2019.
[TF03] M. Tipping and A. Faul. “Fast marginal likeli￾hood maximisation for sparse Bayesian mod￾els”. In: AI/Stats. 2003.
[Tho16] M. Thoma. “Creativity in Machine Learning”.
In: (Jan. 2016). arXiv: 1601.03642 [cs.CV].
[Tho17] R. Thomas. Computational Linear Algebra
for Coders. 2017.
[Tib96] R. Tibshirani. “Regression shrinkage and se￾lection via the lasso”. In: J. Royal. Statist.
Soc B 58.1 (1996), pp. 267–288.
[Tip01] M. Tipping. “Sparse Bayesian learning and
the relevance vector machine”. In: JMLR 1
(2001), pp. 211–244.
[Tip98] M. Tipping. “Probabilistic visualization of
high-dimensional binary data”. In: NIPS.
1998.
[Tit16] M. Titsias. “One-vs-Each Approximation to
Softmax for Scalable Estimation of Probabil￾ities”. In: NIPS. 2016, pp. 4161–4169.
[TK86] L. Tierney and J. Kadane. “Accurate approx￾imations for posterior moments and marginal
densities”. In: JASA 81.393 (1986).
[TL21] M. Tan and Q. V. Le. “EfficientNetV2:
Smaller Models and Faster Training”. In:
(Apr. 2021). arXiv: 2104.00298 [cs.CV].
[TM15] D. Trafimow and M. Marks. “Editorial”. In:
Basic Appl. Soc. Psych. 37.1 (Jan. 2015),
pp. 1–2.
[TMP20] A. Tsitsulin, M. Munkhoeva, and B. Per￾ozzi. “Just SLaQ When You Approximate:
Accurate Spectral Distances for Web-Scale
Graphs”. In: Proceedings of The Web Con￾ference 2020. WWW ’20. 2020, 2697–2703.
[TOB16] L. Theis, A. van den Oord, and M. Bethge. “A
note on the evaluation of generative models”.
In: ICLR. 2016.
[Tol+21] I. Tolstikhin et al. “MLP-Mixer: An all￾MLP Architecture for Vision”. In: (May 2021).
arXiv: 2105.01601 [cs.CV].
[TP10] P. D. Turney and P. Pantel. “From Frequency
to Meaning: Vector Space Models of Seman￾tics”. In: JAIR 37 (2010), pp. 141–188.
[TP97] S. Thrun and L. Pratt, eds. Learning to learn.
Kluwer, 1997.
[TS92] D. G. Terrell and D. W. Scott. “Variable ker￾nel density estimation”. In: Annals of Statis￾tics 20.3 (1992), 1236–1265.
[Tsi+18] A. Tsitsulin, D. Mottin, P. Karras, A. Bron￾stein, and E. Müller. “NetLSD: Hearing the
Shape of a Graph”. In: Proceedings of the
24th ACM SIGKDD International Confer￾ence on Knowledge Discovery & Data Min￾ing. KDD ’18. 2018, 2347–2356.
[TSL00] J. Tenenbaum, V. de Silva, and J. Lang￾ford. “A global geometric framework for non￾linear dimensionality reduction”. In: Science
290.550 (2000), pp. 2319–2323.
[Tur13] M. Turk. “Over Twenty Years of Eigenfaces”.
In: ACM Trans. Multimedia Comput. Com￾mun. Appl. 9.1s (Oct. 2013), 45:1–45:5.
[TV17] A. Tarvainen and H. Valpola. “Mean teach￾ers are better role models: Weight-averaged
consistency targets improve semi-supervised
deep learning results”. In: Advances in neu￾ral information processing systems. 2017,
pp. 1195–1204.
[TVW05] B. Turlach, W. Venables, and S. Wright. “Si￾multaneous Variable Selection”. In: Techno￾metrics 47.3 (2005), pp. 349–363.
[TW18] J. Tang and K. Wang. “Personalized Top￾N Sequential Recommendation via Convo￾lutional Sequence Embedding”. In: WSDM.
WSDM ’18. Marina Del Rey, CA, USA: Asso￾ciation for Computing Machinery, Feb. 2018,
pp. 565–573.
[TXT19] V. Tjeng, K. Xiao, and R. Tedrake. “Eval￾uating Robustness of Neural Networks with
Mixed Integer Programming”. In: ICLR.
2019.
[Ude+16] M. Udell, C. Horn, R. Zadeh, and S. Boyd.
“Generalized Low Rank Models”. In: Founda￾tions and Trends in Machine Learning 9.1
(2016), pp. 1–118.
[Uly+16] D. Ulyanov, V. Lebedev, Andrea, and V.
Lempitsky. “Texture Networks: Feed-forward
Synthesis of Textures and Stylized Images”.
In: ICML. 2016, pp. 1349–1357.
[Uur+17] V. Uurtio, J. M. Monteiro, J. Kandola, J.
Shawe-Taylor, D. Fernandez-Reyes, and J.
Rousu. “A Tutorial on Canonical Correla￾tion Methods”. In: ACM Computing Surveys
(2017).
[UVL16] D. Ulyanov, A. Vedaldi, and V. Lempitsky.
“Instance Normalization: The Missing Ingre￾Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license820 BIBLIOGRAPHY
dient for Fast Stylization”. In: (2016). arXiv:
1607.08022 [cs.CV].
[Van06] L. Vandenberghe. Applied Numerical Com￾puting: Lecture notes. 2006.
[Van14] J. VanderPlas. Frequentism and Bayesian￾ism III: Confidence, Credibility, and why
Frequentism and Science do not Mix. Blog
post. 2014.
[Van18] J. Vanschoren. “Meta-Learning: A Survey”.
In: (Oct. 2018). arXiv: 1810.03548 [cs.LG].
[Vap98] V. Vapnik. Statistical Learning Theory. Wi￾ley, 1998.
[Vas+17] A. Vaswani et al. “Attention Is All You Need”.
In: NIPS. 2017.
[Vas+19] S. Vaswani, A. Mishkin, I. Laradji, M.
Schmidt, G. Gidel, and S. Lacoste-Julien.
“Painless Stochastic Gradient: Interpola￾tion, Line-Search, and Convergence Rates”.
In: NIPS. Curran Associates, Inc., 2019,
pp. 3727–3740.
[VD99] S. Vaithyanathan and B. Dom. “Model Selec￾tion in Unsupervised Learning With Appli￾cations To Document Clustering”. In: ICML.
1999.
[VEB09] N. Vinh, J. Epps, and J. Bailey. “Information
Theoretic Measures for Clusterings Compar￾ison: Is a Correction for Chance Necessary?”
In: ICML. 2009.
[Vel+18] P. Veličković, G. Cucurull, A. Casanova, A.
Romero, P. Lio, and Y. Bengio. “Graph at￾tention networks”. In: ICLR. 2018.
[Vel+19] P. Veličković, W. Fedus, W. L. Hamilton,
P. Liò, Y. Bengio, and R. D. Hjelm. “Deep
Graph Infomax”. In: International Confer￾ence on Learning Representations. 2019.
[VGG17] A. Vehtari, A. Gelman, and J. Gabry. “Prac￾tical Bayesian model evaluation using leave￾one-out cross-validation and WAIC”. In: Stat.
Comput. 27.5 (Sept. 2017), pp. 1413–1432.
[VGS97] V. Vapnik, S. Golowich, and A. Smola. “Sup￾port vector method for function approxima￾tion, regression estimation, and signal pro￾cessing”. In: NIPS. 1997.
[Vig15] T. Vigen. Spurious Correlations. en. Gift edi￾tion. Hachette Books, May 2015.
[Vij+18] A. K. Vijayakumar et al. “Diverse Beam
Search: Decoding Diverse Solutions from Neu￾ral Sequence Models”. In: IJCAI. 2018.
[Vin+10a] P. Vincent, H. Larochelle, I. Lajoie, Y. Ben￾gio, and P.-A. Manzagol. “Stacked Denoising
Autoencoders: Learning Useful Representa￾tions in a Deep Network with a Local Denois￾ing Criterion”. In: JMLR 11 (2010), pp. 3371–
3408.
[Vin+10b] P. Vincent, H. Larochelle, I. Lajoie, Y. Ben￾gio, and P.-A. Manzagol. “Stacked denois￾ing autoencoders: Learning useful representa￾tions in a deep network with a local denoising
criterion”. In: Journal of machine learning
research 11.Dec (2010), pp. 3371–3408.
[Vin+16] O. Vinyals, C. Blundell, T. Lillicrap, K.
Kavukcuoglu, and D. Wierstra. “Matching
Networks for One Shot Learning”. In: NIPS.
2016.
[Vir10] S. Virtanen. “Bayesian exponential family
projections”. MA thesis. Aalto University,
2010.
[Vis+10] S. V. N. Vishwanathan, N. N. Schraudolph,
R. Kondor, and K. M. Borgward. “Graph Ker￾nels”. In: JMLR 11 (2010), pp. 1201–1242.
[Vo+15] B.-N. Vo et al. Multitarget tracking. John Wi￾ley and Sons, 2015.
[Vor+17] E. Vorontsov, C. Trabelsi, S. Kadoury, and
C. Pal. “On orthogonality and learning recur￾rent networks with long term dependencies”.
In: ICML. 2017.
[VT17] C. Vondrick and A. Torralba. “Generating
the Future with Adversarial Transformers”.
In: CVPR. 2017.
[VV13] G. Valiant and P. Valiant. “Estimating the
unseen: improved estimators for entropy and
other properties”. In: NIPS. 2013.
[Wah+21] O. Wahltinez et al. “COVID-19 Open￾Data: a global-scale, spatially granular meta￾dataset for SARS-CoV-2”. In: (2021). Submit￾ted.
[Wal+20] M. Walmsley et al. “Galaxy Zoo: proba￾bilistic morphology through Bayesian CNNs
and active learning”. In: Monthly Notices
Royal Astronomial Society 491.2 (Jan. 2020),
pp. 1554–1574.
[Wal47] A. Wald. “An Essentially Complete Class of
Admissible Decision Functions”. en. In: Ann.
Math. Stat. 18.4 (Dec. 1947), pp. 549–555.
[Wan+15] J. Wang, W. Liu, S. Kumar, and S.-F.
Chang. “Learning to Hash for Indexing Big
Data - A Survey”. In: Proc. IEEE (2015).
[Wan+17] Y. Wang et al. “Tacotron: Towards End-to￾End Speech Synthesis”. In: Interspeech. 2017.
[Wan+20a] S. Wang, B. Z. Li, M. Khabsa, H. Fang, and
H. Ma. “Linformer: Self-Attention with Lin￾ear Complexity”. In: CoRR abs/2006.04768
(2020). arXiv: 2006.04768.
[Wan+20b] Y. Wang, Q. Yao, J. Kwok, and L. M. Ni.
“Generalizing from a Few Examples: A Survey
on Few-Shot Learning”. In: ACM Computing
Surveys 1.1 (2020).
[Wan+21] R. Wang, M. Cheng, X. Chen, X. Tang, and
C.-J. Hsieh. “Rethinking Architecture Selec￾tion in Differentiable NAS”. In: ICLR. 2021.
[Wat10] S. Watanabe. “Asymptotic Equivalence of
Bayes Cross Validation and Widely Applica￾ble Information Criterion in Singular Learn￾ing Theory”. In: JMLR 11 (Dec. 2010),
pp. 3571–3594.
[Wat13] S. Watanabe. “A Widely Applicable Bayesian
Information Criterion”. In: JMLR 14 (2013),
pp. 867–897.
[WCS08] M. Welling, C. Chemudugunta, and N. Sut￾ter. “Deterministic Latent Variable Models
and their Pitfalls”. In: ICDM. 2008.
[WCZ16] D. Wang, P. Cui, and W. Zhu. “Structural
deep network embedding”. In: Proceedings of
the 22nd ACM SIGKDD international con￾ference on Knowledge discovery and data
mining. ACM. 2016, pp. 1225–1234.
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 821
[Wei76] J. Weizenbaum. Computer Power and Hu￾man Reason: From Judgment to Calculation.
en. 1st ed. W H Freeman & Co, Mar. 1976.
[Wen+16] W. Wen, C. Wu, Y. Wang, Y. Chen, and
H. Li. “Learning Structured Sparsity in Deep
Neural Networks”. In: (2016). arXiv: 1608 .
03665 [cs.NE].
[Wen18] L. Weng. “Attention? Attention!” In:
lilianweng.github.io/lil-log (2018).
[Wen19] L. Weng. “Generalized Language Models”. In:
lilianweng.github.io/lil-log (2019).
[Wer74] P. Werbos. “Beyond regression: New Tools for
Prediction and Analysis in the Behavioral Sci￾ences”. PhD thesis. Harvard, 1974.
[Wer90] P. J. Werbos. “Backpropagation Through
Time: What It Does and How to Do It”. In:
Proc. IEEE 78.10 (1990), pp. 1550–1560.
[Wes03] M. West. “Bayesian Factor Regression Mod￾els in the "Large p, Small n" Paradigm”. In:
Bayesian Statistics 7 (2003).
[WF14] Z. Wang and N. de Freitas. “Theoretical
Analysis of Bayesian Optimisation with Un￾known Gaussian Process Hyper-Parameters”.
In: (June 2014). arXiv: 1406.7758 [stat.ML].
[WF20] T. Wu and I. Fischer. “Phase Transitions for
the Information Bottleneck in Representation
Learning”. In: ICLR. 2020.
[WH18] Y. Wu and K. He. “Group Normalization”. In:
ECCV. 2018.
[WH60] B. Widrow and M. E. Hoff. “Adaptive Switch￾ing Circuits”. In: 1960 IRE WESCON Con￾vention Record, Part 4. IRE, 1960, pp. 96–
104.
[WI20] A. G. Wilson and P. Izmailov. “Bayesian Deep
Learning and a Probabilistic Perspective of
Generalization”. In: NIPS. Feb. 2020.
[Wil14] A. G. Wilson. “Covariance kernels for fast au￾tomatic pattern discovery and extrapolation
with Gaussian processes”. PhD thesis. Univer￾sity of Cambridge, 2014.
[Wil20] C. K. I. Williams. “The Effect of Class Imbal￾ance on Precision-Recall Curves”. In: Neural
Comput. (July 2020).
[WL08] T. T. Wu and K. Lange. “Coordinate descent
algorithms for lasso penalized regression”. In:
Ann. Appl. Stat 2.1 (2008), pp. 224–244.
[WLL16] W. Wang, H. Lee, and K. Livescu. “Deep Vari￾ational Canonical Correlation Analysis”. In:
arXiv (Nov. 2016).
[WM00] D. R. Wilson and T. R. Martinez. “Reduction
Techniques for Instance-Based Learning Algo￾rithms”. In: Mach. Learn. 38.3 (Mar. 2000),
pp. 257–286.
[WNF09] S. Wright, R. Nowak, and M. Figueiredo.
“Sparse reconstruction by separable approxi￾mation”. In: IEEE Trans. on Signal Process￾ing 57.7 (2009), pp. 2479–2493.
[WNS19] C. White, W. Neiswanger, and Y. Savani.
“BANANAS: Bayesian Optimization with
Neural Architectures for Neural Architecture
Search”. In: (Oct. 2019). arXiv: 1910 . 11858
[cs.LG].
[Wol92] D. Wolpert. “Stacked Generalization”. In:
Neural Networks 5.2 (1992), pp. 241–259.
[Wol96] D. Wolpert. “The lack of a priori distinc￾tions between learning algorithms”. In: Neu￾ral Computation 8.7 (1996), pp. 1341–1390.
[WP19] S. Wiegreffe and Y. Pinter. “Attention is not
not Explanation”. In: EMNLP. 2019.
[WRC08] J. Weston, F. Ratle, and R. Collobert. “Deep
learning via semi-supervised embedding”. In:
Proceedings of the 25th international con￾ference on Machine learning. ACM. 2008,
pp. 1168–1175.
[WS09] K. Weinberger and L. Saul. “Distance Metric
Learning for Large Margin Classification”. In:
JMLR 10 (2009), pp. 207–244.
[WSH16] L. Wu, C. Shen, and A. van den Hengel. “Per￾sonNet: Person Re-identification with Deep
Convolutional Neural Networks”. In: (2016).
arXiv: 1601.07255 [cs.CV].
[WSL19] R. L. Wasserstein, A. L. Schirm, and N. A.
Lazar. “Moving to a World Beyond “p
< 0.05””. In: The American Statistician
73.sup1 (Mar. 2019), pp. 1–19.
[WSS04] K. Q. Weinberger, F. Sha, and L. K. Saul.
“Learning a kernel matrix for nonlinear di￾mensionality reduction”. In: ICML. 2004.
[WTN19] Y. Wu, G. Tucker, and O. Nachum. “The
Laplacian in RL: Learning Representations
with Efficient Approximations”. In: ICLR.
2019.
[Wu+16] Y. Wu et al. “Google’s Neural Machine Trans￾lation System: Bridging the Gap between
Human and Machine Translation”. In: (Sept.
2016). arXiv: 1609.08144 [cs.CL].
[Wu+19] Y. Wu, E. Winston, D. Kaushik, and
Z. Lipton. “Domain Adaptation with
Asymmetrically-Relaxed Distribution Align￾ment”. In: ICML. 2019.
[WVJ16] M. Wattenberg, F. Viégas, and I. Johnson.
“How to Use t-SNE Effectively”. In: Distill
1.10 (Oct. 2016).
[WW93] D. Wagner and F. Wagner. “Between min
cut and graph bisection”. In: Proc. 18th Intl.
Symp. on Math. Found. of Comp. Sci. 1993,
pp. 744–750.
[Xie+19] Q. Xie, Z. Dai, E. Hovy, M.-T. Luong, and
Q. V. Le. “Unsupervised data augmentation
for consistency training”. In: arXiv preprint
arXiv:1904.12848 (2019).
[Xie+20] Q. Xie, M.-T. Luong, E. Hovy, and Q. V.
Le. “Self-training with noisy student im￾proves imagenet classification”. In: Proceed￾ings of the IEEE/CVF Conference on Com￾puter Vision and Pattern Recognition. 2020,
pp. 10687–10698.
[XJ96] L. Xu and M. I. Jordan. “On Convergence
Properties of the EM Algorithm for Gaussian
Mixtures”. In: Neural Computation 8 (1996),
pp. 129–151.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license822 BIBLIOGRAPHY
[XRV17] H. Xiao, K. Rasul, and R. Vollgraf. “Fashion￾MNIST: a Novel Image Dataset for Bench￾marking Machine Learning Algorithms”. In:
(2017). arXiv: 1708.07747 [stat.ML].
[Xu+15] K. Xu et al. “Show, Attend and Tell: Neural
Image Caption Generation with Visual Atten￾tion”. In: ICML. 2015.
[Yal+19] I. Z. Yalniz, H. Jégou, K. Chen, M.
Paluri, and D. Mahajan. “Billion-scale semi￾supervised learning for image classification”.
In: arXiv preprint arXiv:1905.00546 (2019).
[Yan+14] X. Yang, Y. Guo, Y. Liu, and H. Steck.
“A Survey of Collaborative Filtering Based
Social Recommender Systems”. In: Comput.
Commun. 41 (Mar. 2014), pp. 1–10.
[Yar95] D. Yarowsky. “Unsupervised word sense dis￾ambiguation rivaling supervised methods”. In:
33rd annual meeting of the association for
computational linguistics. 1995, pp. 189–196.
[YB19] C. Yadav and L. Bottou. “Cold Case: The
Lost MNIST Digits”. In: arXiv (May 2019).
[YCS16] Z. Yang, W. W. Cohen, and R. Salakhut￾dinov. “Revisiting semi-supervised learning
with graph embeddings”. In: Proceedings of
the 33rd International Conference on Inter￾national Conference on Machine Learning￾Volume 48. JMLR. org. 2016, pp. 40–48.
[Yeu91] R. W. Yeung. “A new outlook on Shannon’s
information measures”. In: IEEE Trans. Inf.
Theory 37.3 (May 1991), pp. 466–474.
[YHJ09] D. Yan, L. Huang, and M. I. Jordan. “Fast ap￾proximate spectral clustering”. In: 15th ACM
Conf. on Knowledge Discovery and Data
Mining. 2009.
[Yin+19] P. Yin, J. Lyu, S. Zhang, S. Osher, Y. Qi, and
J. Xin. “Understanding Straight-Through Es￾timator in Training Activation Quantized
Neural Nets”. In: ICLR. 2019.
[YK16] F. Yu and V. Koltun. “Multi-Scale Context
Aggregation by Dilated Convolutions”. In:
ICLR. 2016.
[YL06] M. Yuan and Y. Lin. “Model Selection and
Estimation in Regression with Grouped Vari￾ables”. In: J. Royal Statistical Society, Series
B 68.1 (2006), pp. 49–67.
[YL21] A. L. Yuille and C. Liu. “Deep Nets: What
have they ever done for Vision?” In: Intl. J.
Computer Vision 129 (2021), pp. 781–802.
[Yon19] E. Yong. “The Human Brain Project Hasn’t
Lived Up to Its Promise”. In: The Atlantic
(July 2019).
[Yos+15] J. Yosinski, J. Clune, A. Nguyen, T. Fuchs,
and H. Lipson. “Understanding Neural Net￾works Through Deep Visualization”. In:
ICML Workshop on Deep Learning. 2015.
[Yu+06] S. Yu, K. Yu, V. Tresp, K. H-P., and M.
Wu. “Supervised probabilistic principal com￾ponent analysis”. In: KDD. 2006.
[Yu+16] F. X. X. Yu, A. T. Suresh, K. M. Choroman￾ski, D. N. Holtmann-Rice, and S. Kumar. “Or￾thogonal Random Features”. In: NIPS. Cur￾ran Associates, Inc., 2016, pp. 1975–1983.
[YWG12] S. E. Yuksel, J. N. Wilson, and P. D. Gader.
“Twenty Years of Mixture of Experts”. In:
IEEE Trans. on neural networks and learn￾ing systems (2012).
[Zah+18] M. Zaheer, S. Reddi, D. Sachan, S. Kale, and
S. Kumar. “Adaptive Methods for Nonconvex
Optimization”. In: NIPS. Curran Associates,
Inc., 2018, pp. 9815–9825.
[Zah+20] M. Zaheer et al. “Big Bird: Transformers for
Longer Sequences”. In: CoRR abs/2007.14062
(2020). arXiv: 2007.14062.
[Zei12] M. D. Zeiler. “ADADELTA: An Adaptive
Learning Rate Method”. In: (Dec. 2012).
arXiv: 1212.5701 [cs.LG].
[Zel76] A. Zellner. “Bayesian and non-Bayesian anal￾ysis of the regression model with multivari￾ate Student-t error terms”. In: JASA 71.354
(1976), pp. 400–405.
[ZG02] X. Zhu and Z. Ghahramani. Learning from
labeled and unlabeled data with label propa￾gation. Tech. rep. CALD tech report CMU￾CALD-02-107. CMU, 2002.
[ZG06] M. Zhu and A. Ghodsi. “Automatic dimen￾sionality selection from the scree plot via
the use of profile likelihood”. In: Computa￾tional Statistics & Data Analysis 51 (2006),
pp. 918–930.
[ZH05] H. Zou and T. Hastie. “Regularization and
Variable Selection via the Elastic Net”. In:
J. of Royal Stat. Soc. Series B 67.2 (2005),
pp. 301–320.
[Zha+17a] C. Zhang, S. Bengio, M. Hardt, B. Recht,
and O. Vinyals. “Understanding deep learn￾ing requires rethinking generalization”. In:
ICLR. 2017.
[Zha+17b] H. Zhang, M. Cisse, Y. N. Dauphin, and D.
Lopez-Paz. “mixup: Beyond Empirical Risk
Minimization”. In: ICLR. 2017.
[Zha+18] Z.-Q. Zhao, P. Zheng, S.-T. Xu, and X. Wu.
“Object Detection with Deep Learning: A Re￾view”. In: (July 2018). arXiv: 1807 . 05511
[cs.CV].
[Zha+19a] J. Zhang, Y. Zhao, M. Saleh, and P. J.
Liu. “PEGASUS: Pre-training with Extracted
Gap-sentences for Abstractive Summariza￾tion”. In: (Dec. 2019). arXiv: 1912 . 08777
[cs.CL].
[Zha+19b] S. Zhang, L. Yao, A. Sun, and Y. Tay.
“Deep Learning Based Recommender System:
A Survey and New Perspectives”. In: ACM
Comput. Surv. 52.1 (Feb. 2019), pp. 1–38.
[Zha+20] A. Zhang, Z. Lipton, M. Li, and A. Smola.
Dive into deep learning. 2020.
[Zho+04] D. Zhou, O. Bousquet, T. N. Lal, J. We￾ston, and B. Schölkopf. “Learning with lo￾cal and global consistency”. In: Advances in
neural information processing systems. 2004,
pp. 321–328.
[Zho+18] D. Zhou, Y. Tang, Z. Yang, Y. Cao, and Q.
Gu. “On the Convergence of Adaptive Gra￾dient Methods for Nonconvex Optimization”.
In: (Aug. 2018). arXiv: 1808.05671 [cs.LG].
Draft of “Probabilistic Machine Learning: An Introduction”. February 8, 2022BIBLIOGRAPHY 823
[Zho+21] C. Zhou, X. Ma, P. Michel, and G. Neu￾big. “Examining and Combating Spurious
Features under Distribution Shift”. In: ICML.
June 2021.
[ZHT06] H. Zou, T. Hastie, and R. Tibshirani. “Sparse
principal component analysis”. In: JCGS 15.2
(2006), pp. 262–286.
[Zhu05] X. Zhu. “Semi-supervised learning with
graphs”. PhD thesis. Carnegie Mellon Univer￾sity, 2005.
[Zhu+21] F. Zhuang et al. “A Comprehensive Survey
on Transfer Learning”. In: Proc. IEEE 109.1
(2021).
[Zie+05] C.-N. Ziegler, S. M. McNee, J. A. Konstan,
and G. Lausen. “Improving recommendation
lists through topic diversification”. In: WWW.
WWW ’05. Chiba, Japan: Association for
Computing Machinery, May 2005, pp. 22–32.
[ZK16] S. Zagoruyko and N. Komodakis. “Wide
Residual Networks”. In: BMVC. 2016.
[ZL05] Z.-H. Zhou and M. Li. “Tri-training: Exploit￾ing unlabeled data using three classifiers”. In:
IEEE Transactions on knowledge and Data
Engineering 17.11 (2005), pp. 1529–1541.
[ZL17] B. Zoph and Q. V. Le. “Neural Architec￾ture Search with Reinforcement Learning”. In:
ICLR. 2017.
[ZLZ20] D. Zhang, Y. Li, and Z. Zhang. “Deep metric
learning with spherical embedding”. In: NIPS.
2020.
[ZMY19] D. Zabihzadeh, R. Monsefi, and H. S. Yazdi.
“Sparse Bayesian approach for metric learning
in latent space”. In: Knowledge-Based Sys￾tems 178 (Aug. 2019), pp. 11–24.
[ZRY05] P. Zhao, G. Rocha, and B. Yu. Grouped and
Hierarchical Model Selection through Com￾posite Absolute Penalties. Tech. rep. UC
Berkeley, 2005.
[ZS14] H. Zen and A Senior. “Deep mixture den￾sity networks for acoustic modeling in statisti￾cal parametric speech synthesis”. In: ICASSP.
May 2014, pp. 3844–3848.
[ZY08] J.-H. Zhao and P. L. H. Yu. “Fast ML Es￾timation for the Mixture of Factor Analyzers
via an ECM Algorithm”. In: IEEE. Trans. on
Neural Networks 19.11 (2008).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license

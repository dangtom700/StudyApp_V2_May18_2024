Advances in Industrial Control
Thivaharan Albin Rajasingham
Nonlinear Model 
Predictive 
Control 
of Combustion 
Engines
From Fundamentals to ApplicationsAdvances in Industrial Control
Series Editors
Michael J. Grimble, Industrial Control Centre, University of Strathclyde, Glasgow,
UK
Antonella Ferrara, Department of Electrical, Computer and Biomedical
Engineering, University of Pavia, Pavia, Italy
Editorial Board
Graham Goodwin, School of Electrical Engineering and Computing, University of
Newcastle, Callaghan, NSW, Australia
Thomas J. Harris, Department of Chemical Engineering, Queen’s University,
Kingston, ON, Canada
Tong Heng Lee , Department of Electrical and Computer Engineering, National
University of Singapore, Singapore, Singapore
Om P. Malik, Schulich School of Engineering, University of Calgary, Calgary, AB,
Canada
Kim-Fung Man, City University Hong Kong, Kowloon, Hong Kong
Gustaf Olsson, Department of Industrial Electrical Engineering and Automation,
Lund Institute of Technology, Lund, Sweden
Asok Ray, Department of Mechanical Engineering, Pennsylvania State University,
University Park, PA, USA
Sebastian Engell, Lehrstuhl für Systemdynamik und Prozessführung, Technische
Universität Dortmund, Dortmund, Germany
Ikuo Yamamoto, Graduate School of Engineering, University of Nagasaki,
Nagasaki, JapanAdvances in Industrial Control is a series of monographs and contributed titles focusing on
the applications of advanced and novel control methods within applied settings. This series
has worldwide distribution to engineers, researchers and libraries.
The series promotes the exchange of information between academia and industry, to
which end the books all demonstrate some theoretical aspect of an advanced or new control
method and show how it can be applied either in a pilot plant or in some real industrial
situation. The books are distinguished by the combination of the type of theory used and the
type of application exemplified. Note that “industrial” here has a very broad interpretation; it
applies not merely to the processes employed in industrial plants but to systems such as
avionics and automotive brakes and drivetrain. This series complements the theoretical and
more mathematical approach of Communications and Control Engineering.
Indexed by SCOPUS and Engineering Index.
Proposals for this series, composed of a proposal form downloaded from this page, a draft
Contents, at least two sample chapters and an author cv (with a synopsis of the whole project,
if possible) can be submitted to either of the:
Series Editors
Professor Michael J. Grimble
Department of Electronic and Electrical Engineering, Royal College Building, 204
George Street, Glasgow G1 1XW, United Kingdom
e-mail: m.j.grimble@strath.ac.uk
Professor Antonella Ferrara
Department of Electrical, Computer and Biomedical Engineering, University of
Pavia, Via Ferrata 1, 27100 Pavia, Italy
e-mail: antonella.ferrara@unipv.it
or the
In-house Editor
Mr. Oliver Jackson
Springer London, 4 Crinan Street, London, N1 9XW, United Kingdom
e-mail: oliver.jackson@springer.com
Proposals are peer-reviewed.
Publishing Ethics
Researchers should conduct their research from research proposal to publication in line with
best practices and codes of conduct of relevant professional bodies and/or national and
international regulatory bodies. For more details on individual ethics matters please see:
https://www.springer.com/gp/authors-editors/journal-author/journal-author-helpdesk/
publishing-ethics/14214
More information about this series at http://www.springer.com/series/1412Thivaharan Albin Rajasingham
Nonlinear Model Predictive
Control of Combustion
Engines
From Fundamentals to ApplicationsThivaharan Albin Rajasingham
Institute for Dynamic Systems and Control
ETH Zurich
Zurich, Switzerland
ISSN 1430-9491 ISSN 2193-1577 (electronic)
Advances in Industrial Control
ISBN 978-3-030-68009-1 ISBN 978-3-030-68010-7 (eBook)
https://doi.org/10.1007/978-3-030-68010-7
MATLAB and Simulink are registered trademarks of The MathWorks, Inc. See https://www.mathworks.
com/trademarks for a list of additional trademarks.
Mathematics Subject Classification: 49, 93, 80
© Springer Nature Switzerland AG 2021
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of
the material is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation,
broadcasting, reproduction on microfilms or in any other physical way, and transmission or information
storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology
now known or hereafter developed.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication
does not imply, even in the absence of a specific statement, that such names are exempt from the relevant
protective laws and regulations and therefore free for general use.
The publisher, the authors and the editors are safe to assume that the advice and information in this book
are believed to be true and accurate at the date of publication. Neither the publisher nor the authors or
the editors give a warranty, expressed or implied, with respect to the material contained herein or for any
errors or omissions that may have been made. The publisher remains neutral with regard to jurisdictional
claims in published maps and institutional affiliations.
This Springer imprint is published by the registered company Springer Nature Switzerland AG
The registered company address is: Gewerbestrasse 11, 6330 Cham, SwitzerlandTo Julin, Amma, Appa, and ElliAIC Series Editors’ Foreword
Control engineering is viewed rather differently by researchers and those that must
implement and maintain control systems. Researchers develop general algorithms
with a strong mathematical basis, while practitioners have more local concerns
over the capabilities of equipment, quality of control, and plant downtime. The
series Advances in Industrial Control attempts to bridge this divide and hopes to
encourage the adoption of more advanced control techniques when they are likely to
be beneficial.
The rapid development of new control theory and technology has an impact on
all areas of control engineering and applications. This monograph series encourages
the development of a more targeted control theory that is driven by the needs and
challenges of applications. A focus on applications is essential if the different aspects
of the control design problem are to be explored with the same dedication that control
synthesis problems have received in the past. The series provides an opportunity
for researchers to present an extended exposition of their new work on industrial
control, raising awareness of the substantial benefits that can accrue, and exploring
the challenges that can arise.
The author has made a number of contributions to the control of combustion
engines using Model Predictive Control (MPC) methods and has also been involved
in teaching the subject at various prestigious institutions. The text reflects this current
research and the valuable practical experience gained. It begins by explaining the
classical approaches to engine control and the major problem of engine calibration.
When the number of calibration parameters was small, this was a practical process
but for modern engines, the number of inputs and outputs and the number of calibra￾tion parameters have increased significantly and continue to do so. This and tighter
emissions and fuel-consumption requirements led to substantial interest in model￾based predictive control methods that are particularly suitable for complex nonlinear
multivariable systems.
After the introductory chapter, the traditional decentralized PID control solution
is discussed using look-up tables, and the problems of calibration are described. The
problems encountered motivate the introduction of more systematic design proce￾dures. These normally stem from optimal control or optimization-based methods
viiviii AIC Series Editors’ Foreword
covered in the following chapter. There is a very useful introduction to optimiza￾tion techniques that are essential for predictive control where its constraint-handling
capabilities are often the main feature.
The predictive control algorithms are based on optimization, which is a topic
introduced from the first principles in Part I of the text. First, the linear MPC algo￾rithms are introduced and then the use of hard constraints in a section on Constrained
MPC. This is a relatively simple introduction, which is also valuable for the subse￾quent introduction to nonlinear MPC. This approach is a good candidate for engine
control since engines are very nonlinear, and to improve performance some form of
nonlinear control or compensation is essential.
Nonlinear optimization and numerical methods are introduced for the solution of
the nonlinear predictive control problem that results. This is a topic that can often
be hard to follow because of the mathematical tools required and the very large
number of options available in modeling and optimization. This text provides a very
straightforward approach of great practical use to the application. The feasibility
of implementing the computational algorithm in real time is considered. This is a
challenging and very practical problem in engine control, which seldom receives the
attention it deserves in published work. It is also valuable that theoretical issues like
stability questions are considered in this first part of the text.
The introduction to engine control problems including air path control, fuel and
combustion control, and exhaust gas path control is followed by introductions to
spark ignition and then compression-ignition engines in Part II. A good understanding
of engines is needed before models can be produced and model-based techniques
can be applied. The very clear introductions to the complicated control problems
involved are therefore important. The final parts of the text are concerned with in￾depth case studies that will probably be the most valuable chapters for engineers
actually working in the automotive industry. These sections include useful practical
details emphasizing the real engineering aspects of the problem not often available
in research, rather than development-oriented texts.
This text concerns an area of advanced control where there is both a need and a
desire for a practical solution. Senior management in the automotive industry has
been very receptive to the use of models for the design of controllers that can provide
higher performance and can cope with the complexity of the engine control problem.
There is also a desire for systematic or formalized design procedures to be produced.
This faith in model-based control has been justified recently in the first application
of MPC to GM production engines. This text is therefore a very timely and a very
welcome addition to the series on Advances in Industrial Control.
Glasgow, UK
Pavia, Italy
October 2020
Michael J. Grimble
Antonella FerraraPreface
Scope of the Book
The requirements on combustion engines used for transportation, i.e. automotive
vehicles, ships, and airplanes, as well as for stationary energy supply, are constantly
increasing. This concerns, for instance, the reduction of fuel consumption and pollu￾tant emissions. An increasing number of sensors and actuators are implemented in
combustion engines to improve their performance. To fully exploit the potentials of
the system capabilities, complex control algorithms are required which allow for suit￾able process handling. The book describes the use of an advanced control algorithm,
namely, the Model Predictive Control (MPC) method. The book aims to provide a
comprehensive overview of the topics related to MPC for its application to engine
systems.
Readers targeted are engineers and researchers in academia and industry working
in the field of engine system control. The text is also suited for graduate students
interested in this topic and who want to deepen their expertise. Readers should have
a solid knowledge of control systems and the working principle of an engine system.
Additional prerequisites are the fundamentals of mechanical engineering, such as
mechanics and calculus.
Several good textbooks discuss the various topics that are needed for model predic￾tive engine control. Textbooks exist that specifically detail the fundamentals of MPC,
the fundamentals of numerical optimization, or the fundamentals of engine control
and modeling. These textbooks treat the full scope of the specific topic in detail
including their theoretical background. Rather than looking into any one topic in
detail, the focus of this book is placed on the intersection of all the necessary topics.
The algorithms and methods that are scattered over the various disciplines are brought
together from a practical perspective. This allows the reader to become familiar
with all the relevant aspects and to see how the various topics are interconnected.
Instead of showing all available algorithms, particularly those are presented that have
shown to work well in real vehicles and on real engine test benches. This concerns
the characteristics of engine control, such as the necessity to consider nonlineari￾ties and the small timescales of control that make the real-time feasibility a very
ixx Preface
demanding aspect. These algorithms are not only explained, but their application to
engine control problems is detailed as well. After reading the book, readers have all
the necessary fundamentals to implement their own MPC algorithms on real-world
combustion engine control problems and advance the field of combustion engine
control on their own.
Origin of the Book
The book originated from a graduate course that has been taught at various
institutions. The courses are as follows:
• lecture series at ETH Zurich, Switzerland,
• lecture series at RWTH Aachen University, Germany,
• lecture at Peter the Great St. Petersburg Polytechnic University, Russia,
• summer school at Jilin University, Changchun, China and
• summer school at Sophia University, Tokyo, Japan.
Several Ph.D. students have been involved in the preparation of the lectures and the
associated lab exercises, namely Martin Keller and Dennis Ritter at RWTH Aachen
University as well as Richard Hutter, Severin Hänggi, Johannes Ritzmann, and Stijn
van Dooren at ETH Zurich. I am thankful for all their support.
The content for the lectures and the book resulted from several research projects on
the topic of MPC for engine system control. As a senior researcher and a group leader,
I had the opportunity to work together with numerous Ph.D. students on this topic. I
would like to especially mention the research unit FOR2401 as one project for which
I had the honor to act as a spokesman. Numerous fruitful academic collaborations
have resulted from the research unit, for instance, with Prof. Moritz Diehl on the
topic of numerical optimization, with Prof. Heinz Pitsch on combustion modeling,
with Prof. Katharina Kohse-Höinghaus on combustion chemistry, as well as with
Prof. Stefan Pischinger and Prof. Jakob Andert on combustion engines. The book
also benefited from publicly funded research projects with industrial collaborators
such as General Electric and Ford AG.
The research work entered and shaped the book. Results from joint work with
collaborators are properly cited in the various chapters. The focus is placed on appli￾cation examples, where active research has been carried out—the application exam￾ples investigated all stem from research projects conducted. Within the research
projects, the application examples described have been implemented by the author
in real-world combustion engine test benches and in real-world vehicles which have
been tested on public roads. Clearly, not all relevant and interesting application exam￾ples are treated. For instance, the energy management for hybrid drivetrains or the
topic of exhaust gas aftertreatment is not treated within this book.Preface xi
Acknowledgments
The financial support received from several funding agencies is acknowledged,
which has made the research covered in this book possible. Part of the research
was performed within the Research Unit (Forschungsgruppe) FOR2401 “Optimiza￾tion based Multiscale Control for Low-Temperature Combustion Engines”, which
has been funded by the German Research Association (Deutsche Forschungsgemein￾schaft, DFG).
Part of the research results presented was realized within the IGF research project
17733 N/1 “Prädiktive Steuerung für hochaufgeladene Ottomotoren” of the FVV. The
IGF project 17733 N/1 of the research association Forschungskuratorium Maschi￾nenbau e.V.—FKM, Lyoner Strasse 18, 60528 Frankfurt am Main, was financially
supported by the AiF within the framework of the development program for Indus￾trial Community Research (IGF) of the Federal Ministry of Economic Affairs and
Energy based on a decision of the German Bundestag. The author thanks the AiF,
the FVV, and the corresponding committee of the FVV for their financial support,
expertise, and discussions during the working group meetings.
Part of the work presented was conducted within the research project “JB-X
Clean—Model based Control of Dual-Fuel Combustion Engines”. The project was
funded by the Federal Ministry of Economic Affairs and Energy (BMWi) under the
number BMBF 03SX375C. The author thanks the BMWi for its financial support
and all project partners for the good cooperation.
In addition to the several funding agencies, several people have to be mentioned
as well who have been essential in realizing the book. I would like to acknowledge
Dennis Ritter with whom I worked together on many of the results presented. This
concerns especially the topic of two-stage turbocharging and of combustion-rate
shaping. Additionally, I would like to thank Severin Hänggi for his support on the
EGR VTG case study and Jan Schilliger and Nils Keller who helped to streamline the
book, for instance, with the implementations of several numerical examples. Brigitte
Rohrbach helped to improve the quality of the book by very carefully proofreading
the manuscript. I am very grateful to Prof. Chris Onder for hosting me for the last 2.5
years. He was very supportive in every regard and provided a research environment
amenable to high-quality research. Finally, I would like to acknowledge Prof. Dirk
Abel who has been a mentor for more than 10 years. It is a great honor to work with
him and to learn from him.
Zurich, Switzerland
September 2020
Thivaharan Albin RajasinghamContents
1 Introduction .................................................. 1
1.1 Motivation to Improve Engine Performance . . . . . . . . . . . . . . . . . . 1
1.2 Improving the Engine Performance by Advanced Control . . . . . . 4
1.3 Control Algorithms for Engine Control . . . . . . . . . . . . . . . . . . . . . . 6
1.4 Introduction to Model Predictive Control . . . . . . . . . . . . . . . . . . . . 8
1.4.1 Formulation of the Optimization Problem . . . . . . . . . . . . 11
1.4.2 Control-Oriented Modeling . . . . . . . . . . . . . . . . . . . . . . . . 12
1.4.3 Numerical Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
1.5 Aims and Outline of the Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
2 Model-Based Approach with PID Controllers . . . . . . . . . . . . . . . . . . . . 17
2.1 Multiple-Input Multiple-Output Systems . . . . . . . . . . . . . . . . . . . . . 17
2.1.1 Introduction to MIMO Systems . . . . . . . . . . . . . . . . . . . . . 18
2.1.2 Relative Gain Array . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
2.1.3 System Decoupling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.2 Actuator Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
2.2.1 Integrator Windup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.2.2 Directionality in Constrained MIMO Systems . . . . . . . . . 30
2.3 Control Approach Based on Look-Up Tables . . . . . . . . . . . . . . . . . 32
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
3 Mathematical Fundamentals of Optimization . . . . . . . . . . . . . . . . . . . . 37
3.1 Introduction to Optimization Problems . . . . . . . . . . . . . . . . . . . . . . 37
3.2 Convex Optimization Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
3.3 Classes of Optimization Problems . . . . . . . . . . . . . . . . . . . . . . . . . . 45
3.3.1 Dynamic Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
3.3.2 Static Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
3.4 Optimality Conditions for NLPs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
3.4.1 Unconstrained Optimization Problems . . . . . . . . . . . . . . . 48
3.4.2 Constrained Case: Equality Constraints . . . . . . . . . . . . . . 50
3.4.3 Constrained Case: Inequality and Equality
Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
xiiixiv Contents
3.4.4 Graphical Interpretation . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
Part I Model Predictive Control
4 Linear Model Predictive Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
4.1 Linear Model Representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
4.1.1 Discrete-Time State-Space Model for Linear
Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
4.1.2 Discretization of Linear Continuous-Time
State-Space Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
4.2 Cost Function for Linear MPC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
4.3 Unconstrained Linear MPC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
4.3.1 Analytic Solution of the Optimization Problem . . . . . . . . 69
4.3.2 Resulting Control Law . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
4.4 Constrained Linear MPC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
4.4.1 Dense Formulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
4.4.2 Sparse Formulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
4.4.3 Comparison of Dense and Sparse Formulations . . . . . . . 82
4.4.4 Control Structure of Constrained Linear MPC . . . . . . . . . 83
4.4.5 Numerical Solution of the Resulting Quadratic
Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
4.5 Linear Time-Variant (LTV) Model Predictive Control . . . . . . . . . . 87
4.6 Numerical Examples for Linear MPC . . . . . . . . . . . . . . . . . . . . . . . 90
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
5 Nonlinear Model Predictive Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
5.1 Introduction to Nonlinear MPC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
5.2 Numerical Solution of the Resulting Nonlinear Program . . . . . . . 104
5.2.1 Solving the Unconstrained NLP . . . . . . . . . . . . . . . . . . . . . 104
5.2.2 Solving the Constrained NLP via Sequential
Quadratic Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
5.2.3 Approximation of Hessian Matrix . . . . . . . . . . . . . . . . . . . 116
5.3 Discretization of the OCP via Shooting Methods . . . . . . . . . . . . . . 119
5.3.1 Numerical Methods for Simulation . . . . . . . . . . . . . . . . . . 119
5.3.2 Discretization of Actuated Values, Cost Function,
and Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
5.3.3 Discretization via Single Shooting . . . . . . . . . . . . . . . . . . . 126
5.3.4 Discretization via Multiple Shooting . . . . . . . . . . . . . . . . . 128
5.3.5 Real-Time NMPC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
6 Formulation of the Optimization Problem . . . . . . . . . . . . . . . . . . . . . . . 139
6.1 Soft Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
6.2 Offset-Free Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
6.2.1 Observer-Based Offset-Free Control . . . . . . . . . . . . . . . . . 148Contents xv
6.2.2 Offset-Free Control Using a Deadbeat Observer . . . . . . . 150
6.3 Reference Tracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
6.3.1 Delta Formulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
6.3.2 Two-Layered Control Structure . . . . . . . . . . . . . . . . . . . . . 155
6.4 Stability Mechanisms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
6.4.1 Stability of the Infinite-Horizon MPC . . . . . . . . . . . . . . . . 163
6.4.2 Stability of Finite-Horizon MPC . . . . . . . . . . . . . . . . . . . . 164
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
Part II Introduction to Combustion Engine Control
7 SI and CI Engine Control Architectures . . . . . . . . . . . . . . . . . . . . . . . . . 175
7.1 Overview of Engine Control Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . 175
7.2 SI Engine Control Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
7.2.1 Air Path Controller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
7.2.2 Fuel Path Controller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
7.2.3 Ignition Path Controller . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
7.2.4 Control Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
7.3 CI Engine Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
7.3.1 Fuel Path Controller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
7.3.2 Air Path Controller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
7.3.3 Aftertreatment Path Controller . . . . . . . . . . . . . . . . . . . . . . 190
7.3.4 Control Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
8 Low-Temperature Combustion Engine Control . . . . . . . . . . . . . . . . . . 195
8.1 Introduction to LTC Engines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
8.2 Gasoline-Based LTC: Gasoline Controlled Autoignition . . . . . . . 198
8.2.1 Cycle-to-Cycle-Based Control Strategies . . . . . . . . . . . . . 200
8.2.2 Multi-scale Control Strategies . . . . . . . . . . . . . . . . . . . . . . 202
8.3 Diesel-Based LTC: Premixed Charge Compression Ignition . . . . 203
8.4 Dual-Fuel-Based LTC: Reactivity Controlled Compression
Ignition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
Part III In-Depth Case Studies: Air Path Control
9 Fundamentals of Control-Oriented Air Path Modeling . . . . . . . . . . . . 215
9.1 Introduction to Control-Oriented Air Path Modeling . . . . . . . . . . . 215
9.1.1 Requirements on Control-Oriented Air Path
Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
9.1.2 Continuous Differentiability . . . . . . . . . . . . . . . . . . . . . . . . 217
9.2 Volume . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
9.3 Engine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
9.4 Flow Restriction Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
9.4.1 Incompressible Flow Restriction Model . . . . . . . . . . . . . . 226xvi Contents
9.4.2 Compressible Flow Restriction Model . . . . . . . . . . . . . . . 227
9.5 Turbocharger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
9.5.1 Compressor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
9.5.2 Turbine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
9.5.3 Turbocharger Dynamics . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
10 Combined Exhaust Gas Recirculation and VTG: Modeling
and Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
10.1 System Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
10.2 Control-Oriented Process Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
10.3 Validation of the Process Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244
10.4 Analysis of the System Dynamics . . . . . . . . . . . . . . . . . . . . . . . . . . 248
10.4.1 Nonlinearity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
10.4.2 Pole-Zero Locations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
10.4.3 Relative Gain Array . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 251
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
11 Combined Exhaust Gas Recirculation and VTG: Control . . . . . . . . . 253
11.1 Nonlinear MPC Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
11.1.1 Controller-Internal Model . . . . . . . . . . . . . . . . . . . . . . . . . . 253
11.1.2 Formulation of the Optimization Problem . . . . . . . . . . . . 254
11.1.3 Parametrization of the Numerical Solver . . . . . . . . . . . . . 255
11.1.4 Parametrization of the Cost Function . . . . . . . . . . . . . . . . 257
11.2 Model-Based Synthesis of PI Controllers . . . . . . . . . . . . . . . . . . . . 260
11.2.1 Decentralized Synthesis of PI Controllers . . . . . . . . . . . . 260
11.2.2 Decoupling Control Approach . . . . . . . . . . . . . . . . . . . . . . 261
11.2.3 Anti-windup and Dead-Time . . . . . . . . . . . . . . . . . . . . . . . 262
11.3 Simulative Comparison of the Controllers . . . . . . . . . . . . . . . . . . . . 263
11.4 Experimental Validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
12 Two-Stage Turbocharging: Modeling and Analysis . . . . . . . . . . . . . . . 267
12.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
12.2 System Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
12.2.1 Sensors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
12.2.2 Actuators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
12.2.3 Engine Control Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . 271
12.3 Nonlinear Process Model for Two-Stage Turbocharging . . . . . . . . 271
12.3.1 Fundamental Equations of Two-Stage
Turbocharging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
12.3.2 Overall State-Space Model . . . . . . . . . . . . . . . . . . . . . . . . . 274
12.4 Analysis of the System Dynamics . . . . . . . . . . . . . . . . . . . . . . . . . . 275
12.4.1 Stationary System Behavior . . . . . . . . . . . . . . . . . . . . . . . . 275
12.4.2 Transient System Behavior . . . . . . . . . . . . . . . . . . . . . . . . . 276
12.5 Validation of Reduced-Order Model . . . . . . . . . . . . . . . . . . . . . . . . 278
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281Contents xvii
13 Two-Stage Turbocharging: Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
13.1 Nonlinear MPC Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
13.1.1 Controller-Internal Model . . . . . . . . . . . . . . . . . . . . . . . . . . 283
13.1.2 Formulation of the Optimization Problem . . . . . . . . . . . . 284
13.1.3 Numerical Solution of the Optimization Problem . . . . . . 287
13.2 Validation of the NMPC Algorithm by Simulations . . . . . . . . . . . . 287
13.3 Experimental In-Vehicle Validation of the NMPC
Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292
Part IV In-Depth Case Studies: Combustion Control
14 Fundamentals of CI Engine Combustion Control
and Modeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295
14.1 Introduction to Combustion Control . . . . . . . . . . . . . . . . . . . . . . . . . 295
14.2 Control-Oriented Process Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
14.2.1 Mass Balance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
14.2.2 Energy Balance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
14.2.3 Applications of the Single-Zone Model . . . . . . . . . . . . . . 303
14.2.4 Combustion Chamber Volume . . . . . . . . . . . . . . . . . . . . . . 303
14.2.5 Heat Transfer Through Combustion Chamber
Walls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305
14.3 Control of Cycle-Integral Combustion Parameters . . . . . . . . . . . . . 306
14.4 Combustion Rate Shaping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310
15 Combustion Rate Shaping Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
15.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
15.2 Combustion Modeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315
15.2.1 Overview on Combustion Modeling Approaches . . . . . . 315
15.2.2 Data-Based Combustion Models . . . . . . . . . . . . . . . . . . . . 316
15.3 Optimization-Based Fuel Injection Rate Digitalization . . . . . . . . . 321
15.3.1 Data-Based Fuel Injection Model . . . . . . . . . . . . . . . . . . . 321
15.3.2 Formulation of the Optimization Problem . . . . . . . . . . . . 322
15.3.3 Validation of the Fuel Injection Rate Digitalization
Concept . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 326
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329Chapter 1
Introduction
Abstract There exists a high demand to improve combustion engines. The main
focus is the reduction of carbon dioxide (CO2) and pollutant emissions while sus￾taining the same performance, e.g. in terms of driveability, comfort, and durability.
In this chapter, it is detailed that a lot of the improvements of the engine investigated
come along with increased complexity of the process control. The state-of-the-art
control algorithms are reaching the limits of their capabilities. To satisfy the rising
requirements on the process control, a lot of calibration parameters are needed. The
tuning of these parameters is very time consuming and cost-intensive, yet results in a
suboptimal control behavior. Model predictive control (MPC) poses a very attractive
alternative. It is suited to handle the complex system dynamic behavior of the engine
in a systematic manner. This allows achieving better performance while reducing the
time needed for the calibration of the controller.
1.1 Motivation to Improve Engine Performance
One of the central challenges in today’s society is the ecological and economic energy
supply for both mobile and stationary applications. In the upcoming decades, this
topic will become even more important. Due to a significant increase in the pop￾ulation and prosperity worldwide, an over-proportional increase in primary energy
consumption is predicted [4]. At present, a large portion of this energy is supplied by
the combustion of hydrocarbon-based fuels [13]. Approximately 70% of the crude
oil consumed, which amounts to 86 million barrels per day, is used in internal com￾bustion engines (ICEs) [21]. They are used not only within a broad range of different
applications such as passenger vehicles, heavy-duty trucks, and ships, but also for
stationary energy supply, in order to drive electric generators.
The combustion of fossil fuels is associated with the emission of pollutants, e.g.
particulate matter (PM), consisting mainly of soot, nitrogen oxides (NOx), carbon
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_1
12 1 Introduction
monoxide (CO), and unburned hydrocarbons (HC). These emissions contribute sig￾nificantly to urban and rural air pollution. In addition, the greenhouse gas CO2 is
produced, which leads to a change in the global climate [12]. In the foreseeable
future, ICEs will still continue to play a major role, although the relative contribu￾tion of ICEs to the global energy supply will decrease [22]. In the case of passenger
cars, the partial or full electrification of the propulsion system is accelerated, which
allows a significant reduction of CO2 and pollutant emissions. The transformations
will be an ongoing process over the next decades; see, for example, [4] where differ￾ent outlooks for the share of electric vehicles by 2040 are highlighted. Besides their
drawbacks, HC-based fuels still also have advantages compared to recently applied
state-of-the-art batteries in electric vehicles. The fuels have a very high energy den￾sity, are easily storable, ubiquitously available, and are well-standardized. Especially
for applications which require a high energy density such as ships, no technically
reasonable alternatives are available at present. In the case of stationary applications,
increasing shares of renewable energy will be deployed [4]. Still, also ICE-driven
electric generators will be used in the future, as they allow for a load-flexible power
supply which can stabilize the electrical grid by counter-balancing the varying levels
of coverage given by renewable energies.
In the context of the depletion of resources and the increasing impact on the envi￾ronment, the development of improved technologies for clean combustion in ICEs is
extremely important. The requirements for more efficient and ecological combustion
engines are enforced by both customer demands and political governments posing
emission standards by law. In the future, emission regulations for various applica￾tions of ICEs will become even tighter. To illustrate exemplarily the tightening of
requirements, the emission limits for automotive diesel engines and ship engines are
shown in the following. For the automotive area, the development of emission reg￾ulations in the European Union (EU) is depicted in Fig. 1.1. It shows the constantly
decreasing limits on PM, HC, and NOx emissions for passenger cars with diesel
engines [10]. For automotive engines, the so-called Real Driving Emissions (RDE)
legislation is introduced, where a tougher determination of emissions is enforced.
The vehicle’s emissions are measured on the road using portable emission measuring
systems (PEMS).
The same trends for emission legislation can be observed for maritime propulsion
systems. The International Maritime Organization (IMO) sets emission standards
for diesel and heavy-fuel engines depending on the maximum operating speed of the
engine. Figure 1.2 depicts the NOx limits subject to engine speed for engines with a
displacement volume of 30l per cylinder or more [14]. Tier I and II limits are glob￾ally applied, while Tier III standards apply only in Emission Control Areas (ECA),
including the North Sea, Baltic Sea, and most of the US and Canadian coasts.
All in all, ICEs will still play a central role in the energy supply for mobile and
stationary applications in the upcoming decades. To reduce the negative impact of
ICEs, their development is inevitable. The main drivers are the reduction of CO2 and
pollutant emissions. These reductions have to be achieved while customers simul￾taneously demand unchanged characteristics, e.g. concerning driveability, comfort,
noise, vibration and harshness, and durability.1.1 Motivation to Improve Engine Performance 3
Fig. 1.1 EU emissions
limits for HC+NOx and PM
in diesel vehicles
Fig. 1.2 IMO Tier
emissions limits of NOx for
diesel and heavy-fuel
maritime engines
0 1000 2000
0
5
10
15
204 1 Introduction
1.2 Improving the Engine Performance by Advanced
Control
In order to improve the performance of ICEs, e.g. in terms of fuel consumption
or emission reduction, each component itself is revisited and improved. Examples
include the combustion process, the air path, the exhaust gas aftertreatment, waste
heat recovery, and auxiliary devices [18]. Many of the improvements investigated
are accompanied by increased complexity of the process control which is detailed in
the following.
A general development within the automotive area over the last decades has been
the increase in electric/electronic parts, which often replace mechanical parts [5].
Within the engine area, a classic example is the throttle which used to be a purely
mechanical element. With the mechanical throttle, no electronically implemented
control algorithm is necessary. Today’s standard is the use of electronic throttles
which include a DC motor and a position sensor to actively control the throttle
position. For the electronic throttle, one controller is needed to set the appropriate
position of the throttle in dependence on parameters such as the required load and
the ambient temperature. Additionally, at low level a controller is necessary to set
the DC motor such that the desired throttle position results. The general trend of
electrification of the components leads to increased degrees of freedom to control
the entire process.
Additionally, more and more components are added to the engine system. One
example is the introduction of turbocharging units for gasoline engines. The integra￾tion of the turbocharger unit allows for a downsizing of the ICE, thus increasing the
efficiency in part-load operations. Often, turbochargers are equipped with a waste￾gate or a variable geometry turbine which allows for flexible use, but it adds a degree
of freedom which has to be handled by the control unit.
The increased flexibility for operating the engine results in more possibilities
to influence the processes involved. In order to fully exploit these capabilities, the
number of sensors is increasing, which leads to better knowledge about the current
system states. With these possibilities, the process can be adapted to handle varying
conditions optimally, e.g. in terms of requested load, engine speed, and ambient
conditions. Today’s engines in automotive vehicles contain about 15 to 25 sensors
and five to nine actuated variables that are considered in the process control [15].
In order to cope with these developments, improved electronic control units (ECU)
are necessary. This concerns the hardware of the ECUs which are based on micro￾controllers and also the software running on the ECUs. A crucial part of the software
is the control algorithm which generates the appropriate actuator signals. Only if the
control algorithm is able to fully exploit the given degrees of freedom, significant
benefits in terms of fuel consumption and pollutant emissions can result.
For future engine systems, the requirements on the closed-loop system and the
control algorithm itself will become increasingly complex. The engine controller has
to handle the interaction between actuators and the engine process. For an appropriate
control of the engine, several requirements have to be addressed. From a control1.2 Improving the Engine Performance by Advanced Control 5
equirements
R
Functional Non-functional
Challenges
Fig. 1.3 Requirements and challenges on engine control algorithms
point of view, one can distinguish between the two categories, functional and non￾functional requirements, as shown in Fig. 1.3. These requirements have to be fulfilled,
while there are challenges arising from the open-loop dynamics of the system.
Functional Requirements
The control algorithm has to ensure that the engine provides the requested torque
while satisfying numerous requirements such as emission legislation (NOx, CO, HC,
and PM), comfort demands, safety requirements, and reduction of CO2 emissions.
The control performance has a direct correlation to these engine characteristics.
Relevant control specifications are the achieved closed-loop dynamics and the control
accuracy, i.e. no steady-state error. The closed-loop dynamic of the intake manifold
pressure in a gasoline engine, for instance, directly influences the performance for
the acceleration of a vehicle. Additionally, the engine control should be able to reject
disturbances. The engine is operated at various ambient conditions which concern
the temperature, pressure, and humidity while not all of these influencing factors are
measured or modeled. Disturbances to the nominal system also arise due to the aging
of components over their lifetime. The engine control should be robust enough to cope
with these (unmodeled) disturbances. Depending on the control task investigated,
additional requirements occur, such as the prohibition of any considerable overshoot.
On the other side, the control has to take into account the constraints of the system.
They can be due to physical limitations, e.g. the throttle cannot be more than fully
open. They can also occur due to safety requirements, i.e. the process control has to
ensure that the engine (or its sub-components) is not operated in a safety-critical state.
An example is the operation of components such as the exhaust gas aftertreatment
at too high temperatures. Additionally, the control should reduce tear and wear. For
example, high wear might appear when the actuator is used extensively.6 1 Introduction
Non-functional Requirements
The second category is given by the non-functional requirements. These arise espe￾cially in an industrial context, where the cost and development time are important
factors. The control algorithm should have a low impact on the memory usage and
a low computational burden to the control hardware. Concerning the software, the
development costs and time are important. The development time is given by the
time for coding and calibration of the software. To reduce the calibration effort, it
is advantageous if the algorithm is as modular as possible. In such a case, a lot of
software and calibration development can be reused for another control project, e.g.
a slightly modified engine.
Due to the highly dynamic system, the sampling times of the control loops are
chosen to be very short. Additionally, for realizing the requirements named, chal￾lenges arise from the (open-loop) system dynamics of the process to be controlled.
Challenging system properties are present, such as
• nonlinearities,
• multiple-input multiple-output (MIMO) system dynamics,
• dead-time,
• stiffness of describing ordinary differential equations (ODE),
• highly dynamical systems, and
• noise on the measured signals.
1.3 Control Algorithms for Engine Control
In order to operate the engine, many diverse control tasks have to be tackled with var￾ious levels of complexity. Consequently, the most suitable control algorithm depends
on the specific control task. In the following, the suitability of different control algo￾rithms for use within engine control systems is examined. A very rough classification
of control algorithms can be conducted as follows:
1. controller design and synthesis without any use of a process model,
2. controller design and synthesis (offline) by use of a process model, and
3. the process model is an integral part of the controller implemented.
For simple control tasks, the synthesis of the controller can often be conducted
without the use of any process model, i.e. by heuristic tuning. In these cases, the use of
a simple controller such as feedforward or a linear feedback controller is sufficient for
the desired control quality. An application example for engines is the low-level control
of actuators, e.g. the throttle position, which are often single-input single-output
(SISO) control problems without strong impact of disturbance variables. In this
simple setting, the heuristic tuning will even be quicker than a systematic approach.
No in-depth system knowledge is necessary and also no process model has to be
developed. Also, the computational demands for processing the algorithm are low.1.3 Control Algorithms for Engine Control 7
In the case of more complex control tasks, heuristic tuning does not lead to sat￾isfactory results, such that the use of a process model is necessary. This kind of
control algorithm is referred to as model-based control. In general, there are two
possibilities to use the process model for control synthesis. Either the process model
is used to design a controller (offline) or the process model itself is an integral part
of the controller implemented. The state of the art in terms of engine control is the
use of a process model in order to calibrate the controller offline. The control algo￾rithm typically consists of a combination of feedforward and PID-based feedback
controllers. Look-up tables are applied to parametrize the various factors within the
controller. Compared to heuristic tuning, a higher control quality can be achieved.
Additionally, the control structure has low computational demands. For the system￾atic controller design, a model of the process is necessary, which can also be used for
other purposes, such as state estimation. This approach comes along with drawbacks
in terms of time effort for calibration, especially in the case of complex control tasks
with high demands. The main reason lies in the inability to systematically consider
various properties such as the handling of constraints. Due to this disadvantage, a
lot of calibration parameters have to be included in order to still fulfill requirements
such as constraint handling. As a result, the control algorithm is prone to the curse
of dimensionality. An increase in degrees of freedom will lead to an exponential
increase in the number of parameters which have to be calibrated, as discussed in
Sect. 2.3 in more detail. In the context of engine control, these parameters are called
calibration labels.
With the increase of actuators and sensors in modern engine systems, a controller
based on look-up tables is reaching the limits of capability. Figure 1.4 shows the
increase in the number of calibration labels over the number of degrees of freedom
for different years [9].
In the case of complex control tasks with high demands, such as those given in
modern engine systems, control algorithms are better suited where the controller
itself contains a process model. Compared to the model-based control synthesis
(offline), an even higher control performance can be achieved and more system
properties can be handled in a systematic manner. Many different control algorithms
exist where the model is contained in the controller itself, such as the Smith pre￾dictor [1], flatness-based control [16], and MPC. The Smith predictor is especially
suitable for the dead-time compensation of SISO systems and of MIMO systems
with dead-time directly associated with the outputs. The application of the Smith
predictor for MIMO systems with arbitrary dead-times is far more complex [24].
Flatness-based control allows dealing with non-minimum phase systems. However,
the flatness-based control approach can only be applied if the system fulfills the
property of being flat. As MPC does not suffer from these limitations, it can be
used for a wide range of system properties. On top of that, among all these control
algorithms, MPC has an outstanding role as it is the only one that can inherently
take into account constraints on actuated values, system states, and outputs. This is
an important requirement in engine control, e.g. due to the given safety limitations.
In the following, the fundamental concept of MPC will be explained along with
advantages and disadvantages.8 1 Introduction
Fig. 1.4 Increase of engine
management complexity
based on data from [9]
5 10 15
0
10000
20000
30000
1.4 Introduction to Model Predictive Control
MPC relates to a class of control strategies which uses optimization to calculate the
actuated values. Figure 1.5 depicts the control structure using MPC. Compared to
classical control structures, the feedforward and feedback action are combined in a
single controller. Typically, MPC is used as a state-feedback controller, which means
that the control action is based on the recent states of the system. These states are
necessary, as they are used for the prediction of the output values in the process model.
Either the system states are all measurable or, more commonly, a state observer has
to be applied to estimate the system states.
Figure 1.6 depicts the working principle of MPC. The MPC algorithm solves an
optimization problem in each sampling step, consisting of a cost function and con￾straints. In the optimization, a mathematical process model of the controlled appli￾cation is explicitly utilized in order to predict the system behavior. Due to limitations
on the maximum calculation time, the outputs of the model are predicted over a finite
horizon. The result of the optimization algorithm is the optimal open-loop sequence
of actuated values. The first values of the sequence are directly taken as actuated
values that are applied to the system. In the next sampling step, the optimization
problem is solved again and a new sequence of actuated values is calculated over a
shifted horizon. This procedure is called the receding-horizon principle. Due to this
principle, a feedback control algorithm is realized, as the most recent measurement
is used as the basis for the new prediction.
The use of optimization along with a process model for predicting the system
behavior has many benefits in terms of control performance and systematic design,1.4 Introduction to Model Predictive Control 9
which makes it attractive for engine control. A high control performance can be
achieved, as the complex system dynamics are directly accounted for. Exemplary
characteristics that can be handled in a systematic manner are nonlinearity, dead￾time, non-minimum phase, and MIMO systems with strong couplings between the
different inputs and outputs. The improvements in performance for engine control
are reflected in better fuel economy or better vehicle acceleration performance, thus
generating direct customer value. Its applicability to a wide range of system properties
makes it possible to have a uniform approach for different control tasks instead
of having individual solutions. This property is important for engine control. For
instance, during the development process, the engine setup is changed from time to
time. The change of the physical location of an actuator, for example, might result
in a change of the system dynamics, going from no dead-time to a considerable
dead-time. In the worst case, a control algorithm which was appropriate beforehand
is no longer usable. For a systematic design, it is preferable if the control algorithm is
employable as generically as possible – ideally independent of the system properties.
As the control behavior is directly determined by the optimization problem, fur￾ther control requirements can be included. This concerns especially the inclusion of
constraints which cannot be handled systematically by any other control algorithm.
Additionally, the optimization allows considering preview information in the control
concept. The preview can consider, for instance, the knowledge of future reference
values or future disturbance variables. This becomes important for engine control as
due to increased connectivity, e.g. by vehicle-to-vehicle information, preview infor￾mation becomes more and more available [25]. The MPC algorithm can take the
future information into account, in order to act in an anticipatory and thus acausal
manner.
Fig. 1.5 Structure of a control loop with MPC10 1 Introduction
Fig. 1.6 Working principle of MPC
In addition to the advantage of better performance, the calibration time can be
decreased. Some of the requirements, such as the consideration of constraints, are
hard to tackle with conventional controllers that are based on look-up tables. A lot of
heuristic tuning of calibration parameters has to be conducted and protection logics
have to be included [8].
The MPC algorithm is able to consider the arising properties and requirements
systematically. As a consequence, the process model has a crucial role. It is ideally
built up in a very modular way, i.e. for each physical component of the system,
there exists a separate submodel. For a change of a component, e.g. the injector, it
is possible to only modify the submodel responsible for the injection system while
all other submodels are reusable. If a new engine system is built, the controller can
be designed via the use of submodels of each component, which might have already
been developed in prior projects. This systematic design enables a fast adaptation
to different engine hardware architectures – even for a mass production setting [3].
Consequently, the calibration procedure is shifted toward the use of measurement
data to develop and validate the process model. As a result, the development and
calibration time of the controller can be drastically reduced. A study conducted by
a car manufacturer shows the reduction of calibration time from 4 months with
an approach based on look-up tables to 15 d with an MPC-based approach for a
turbocharging control problem [23]. Additionally, the mathematical models of the
process are a good way to build up and save knowledge in a large organization. In
the case of the calibration process based on look-up tables, the knowledge is directly1.4 Introduction to Model Predictive Control 11
linked to the experience of the people involved and thus is not easily accessible to
all.
The main disadvantage of the MPC algorithm is the increased requirement for
the hardware of the ECU. The memory storage and also the processor have to cope
with the increased impact of the MPC algorithm. However, the hardware of ECUs is
becoming more and more powerful, while the price for the hardware decreases [7].
Simultaneously, the algorithms and methods needed for MPC are improving such
that the computational burden is reduced and its real-time feasibility is getting less
critical. These improvements concern the numerical real-time optimization algo￾rithms and also the reduced-order modeling of the components. Along with that, the
MPC algorithm in general is much more complex than conventional controllers such
as the PID-based controllers. Within MPC, a complex numerical algorithm is used,
which usually relies on an iterative solution. The algorithm has to be designed very
carefully, such that, for instance, a suitable solution is found always. In contrast, the
PID-based control algorithm only calculates a few simple expressions. Besides these
points, it has to be considered that the control engineers involved have to have a higher
qualification level for the development of MPC-based algorithms. They need to be
trained in the modeling of dynamic systems and in the topic of optimization-based
control.
A successful implementation of MPC consists of three ingredients [6]. These are
1. a suitable formulation of the optimization problem,
2. a (reduced-order) process model, and
3. a real-time-feasible optimization algorithm.
In order for real-time-feasible control to be achieved and all the requirements on
the closed-loop system to be fulfilled, the three parts have to match.
1.4.1 Formulation of the Optimization Problem
For a successful MPC-based control algorithm, a suitable optimization problem has
to be formulated that allows fulfilling all requirements of the specific control task.
The main advantage of MPC is that a large variety of control requirements can
be covered by the possibilities given by the real-time optimization. In particular,
the cost function can handle requirements on the time trajectory of the closed-loop
system. One example is the performance requirement that the system states should
follow the reference value as fast as possible, e.g. in order to allow a fast vehicle
acceleration. However, the cost function can also consider other variables which
have an impact on the process, e.g. the absolute value of the actuated values, the
rate of change of actuated values, and economic considerations of the closed-loop
system. The various elements can be included in the cost function and prioritized by
weighting factors. The optimization is performed subject to constraints, which allows
considering constraints on physics, performance, and safety. Physical constraints are
given by the process setup, such as limits on the actuators, e.g. a valve has a minimum12 1 Introduction
and maximum opening position. The performance constraints come into play if, for
example, no overshoot is allowed, which can be formulated as a constraint on the
output signal. Another important issue are the safety constraints, which have to be
considered if system states or output values have to be kept in a certain operating
region for safe operation.
Compared to classical controllers, the design is not conducted in the frequency
domain but in the time domain which is more intuitive for the practitioner. However,
a good physical understanding of the process and a systematic analysis of the process
are still necessary for the formulation of a suitable optimization problem. Overall, the
optimization problem allows sufficient freedom to account for all the requirements
arising in engine control.
1.4.2 Control-Oriented Modeling
For MPC, control-oriented models have to be developed which capture the relevant
system dynamics. The process model has a significant impact on the control per￾formance, as the prediction capability of the model directly influences the quality
of the control behavior. At the same time, the models have to be sufficiently simple
such that they are suited for real-time optimization. Therefore, a trade-off has to be
found between model accuracy and simplicity. This trade-off plays a fundamental
role especially in engine control as on the one hand the sampling times are in the
range of milliseconds and on the other hand, complex multi-physics processes have
to be modeled.
For modeling the engine system, physics-based white-box models are available.
These models allow for a detailed simulation of the processes involved, such as
aerodynamics and chemical reaction kinetics. However, many of the physics-based
models are far too complex to be used in a real-time optimization setting. An alterna￾tive approach uses data-based black-box models. The basis for these models consists
of input/output data derived from measurements. With these experimental data, a
candidate model is chosen that is usually given in a parametrized form. Through the
use of the measured data set, the parameters are estimated. Black-box models allow
reproducing the system dynamics with a model of low complexity. The drawback is
that a large amount of measurement data is needed for the calibration of the black￾box process model and that only a very limited extrapolation capability is given. In
addition, no state estimation of physically meaningful quantities is possible. For this
reason, the book will detail gray-box models [17]. In the approach taken, simplified,
low-complexity physics-based models are used in addition to sub-components that
are modeled using black-box models. One of the goals of model-based control is the
reduction of measurements necessary or time at the test bench, respectively. Conse￾quently, the advantages of model-based control are especially given if the portion of
physics-based models is as high as possible in the gray-box approach.1.4 Introduction to Model Predictive Control 13
1.4.3 Numerical Optimization
For systems with large sampling times, the real-time feasibility is not an issue, as
the available time for solving the optimization problem is long enough. For sys￾tems with faster dynamics, the computational demand is the major bottleneck when
applying MPC algorithms. This is the reason why the MPC algorithm was originally
limited to relatively slowly varying applications as those present in the process and
chemical industries [19]. The continuous improvement of methods and algorithms
related to MPC allows the application of MPC to systems with ever-faster system
dynamics [20].
Typical sampling times in combustion engines are in the order of milliseconds,
which makes real-time feasibility a major challenge. As a consequence, the optimiza￾tion methods applied play a major role. In general, several methods are available for
solving the optimization problem. Depending on the class of system model, the type
of cost function, and the constraints, different kinds of optimization problems result.
In the case of a linear model, a quadratic cost function, and linear constraints, a Linear
MPC (LMPC)1 algorithm results. As the chapters below show, a quadratic program
(QP) has to be solved in each sampling step. The algorithm is called Nonlinear MPC
(NMPC), if, for example, the system model is nonlinear. In this case, a nonlinear
program (NLP) results, which generally is harder to solve than the QP.
For linear and piecewise affine models, it is possible to calculate the control law
resulting from the optimization-based controller already in advance offline. This
approach is called explicit MPC [2]. In this case, the control laws are stored in
maps and only the evaluation of the control law is conducted online. This approach
is only feasible for systems with small dimensions. For this reason, it is usually
not applicable to engine control tasks. Therefore, online methods are of interest for
engine control, where the optimization problem is solved numerically during the
runtime of the process. The numerical algorithm has to be fast in order to fulfill
real-time feasibility and it has to be reliable such that a feasible solution is always
available. The numerical methods applicable to these requirements are also called
“embedded” optimization methods [11]. It is important to specifically design the
optimization routine according to the given optimization problem. By proper choice
of the optimization algorithm, a solution can be developed which can handle the
given characteristics.
1.5 Aims and Outline of the Book
The present book provides a comprehensive overview of the application of MPC to
complex control tasks arising in engine systems. The methods detailed in the book
are presented from the algorithms to various in-depth application examples. The
1In the present book, the term MPC refers to the general case (Linear or Nonlinear MPC), whereas
LMPC/NMPC refers specifically to the linear/nonlinear case.14 1 Introduction
application examples described have been implemented in real-world combustion
engine test benches and in real-world vehicles which have been tested on public roads.
Readers should have a solid knowledge of control systems and the working principle
of an engine system. Additional prerequisites are the fundamentals of mechanical
engineering, such as mechanics and calculus. Overall, the monograph consists of
introductory chapters and four main parts.
Chapter 2 details the limitations of the current state-of-the-art control approach for
ICEs. Current control approaches are often based on PID controllers which handle
SISO control tasks in a decentralized manner. To take into account the nonlinearity
of the plant, the parameters of the PID controller are adjusted via look-up tables.
For complex control tasks, as present in engine systems, the control concept applied
has some severe disadvantages. The chapter details for which circumstances the
drawbacks arise. The last introductory chapter, Chap. 3, provides an overview of
the fundamentals of optimization. The notations used in the book are introduced and
classification of optimization problems is conducted. A special emphasis is placed on
the optimality conditions for the typical optimization problems arising within engine
MPC. These optimality conditions serve as fundamentals for numerical algorithms
to solve the optimization problems.
Part I provides an overview of MPC methods that can be applied to achieve
real-time-feasible engine control. First, the LMPC algorithm is introduced. It allows
considering linear system models and linear constraints. The resulting optimization
problem and its solution are presented. For the LMPC problem, a QP results which
can be solved very reliably and very fast. Within engine control, the consideration
of nonlinear system models and thus NMPC is often necessary. The fundamentals
of NMPC are presented within the part. A focus is set on methods that allow for the
real-time-feasible computation of the solution for the optimization problem formu￾lated. This concerns discretization methods and also numerical solution algorithms.
As one suitable solution algorithm, the so-called sequential quadratic programming
(SQP) is introduced. Finally, suitable formulations of the optimization problem are
discussed. This is a very crucial task as the optimization problem determines the con￾trol behavior. The formulation should allow to fully exploit the system capabilities
and to fulfill the requirements on the engine controller. This concerns, for instance,
the requirement to achieve offset-free control.
Part II provides an overview of the control tasks of an engine system. First, the
general control structure is presented, along with an introduction of the control tasks
within the fuel path, the air path, and the exhaust gas path. Based on this general
overview, the specific requirements of a spark ignition (SI), a compression ignition
(CI), and a low-temperature combustion (LTC) engines are explained. The control￾relevant differences in the combustion concepts are detailed. For the SI and the CI
engines, one typical setup is presented, along with its sensor and actuator architec￾ture. For this setup, the various control loops are explained and typical sensitivities
from actuated value to controlled value are demonstrated. For the LTC concept, three
different possibilities for realizing LTC are revisited. Specifically the Gasoline Con￾trolled Autoignition (GCAI), the diesel-based Premixed Charge Compression Igni￾tion (PCCI), and the dual-fuel-based Reactivity Controlled Compression Ignition1.5 Aims and Outline of the Book 15
(RCCI) are introduced. The control challenges that arise for the various realizations
are described as well.
The purpose of Part III is to show in detail the application of MPC to air path
control tasks, which is a very common and complex engine control problem. As a
basis, the reduced-order modeling of the air path system is investigated. All common
components of the air path, such as throttles, volumes, and turbochargers, thus are
revisited to derive reduced-order models. A special focus is set on the suitability
for the use within optimization-based control algorithms. The application of MPC is
demonstrated by investigating a CI and an SI air path control problem. The CI engine
air path consists of a combined exhaust gas recirculation and turbocharging with
variable turbine geometry. The MPC approach is used to control the intake manifold
pressure and the burnt gas ratio. For the SI engine, a two-stage turbocharging concept
is investigated, where two wastegate-equipped turbochargers are placed in series to
control the charging pressure. For both systems, the reduced-order modeling as well
as a suitable MPC algorithm are detailed. The requirements and the setup of both
systems are different. Nevertheless, a quite similar systematic procedure based on
MPC can be used to develop appropriate control algorithms. This is possible due
to the fact that MPC is inherently able to handle a broad range of requirements and
system dynamic properties.
Part IV details the fundamentals of combustion control and modeling along with a
case study. An overview of the in-cycle-resolved modeling of the CI engine process
is presented first. The fundamental equations for the calculation of the cylinder
pressure are detailed. Necessary submodels such as the ones for the determination
of the cylinder volume and the heat transfer through cylinder walls are presented.
The part details as well the state-of-the-art combustion control algorithms which
rely on the use of cycle-integral parameters. Additionally, combustion rate shaping
is introduced which is investigated in research for improved combustion control.
The goal of combustion rate shaping is to shape the heat release highly resolved
by the use of multiple-pulse fuel injections. Two aspects of the combustion rate
shaping are investigated in the case study: the modeling of the combustion process
and the so-called fuel injection rate digitalization. Algorithms are detailed that can
be applied for both, conventional CI engines and PCCI engines. The combustion
process is a complex multi-physics process, which is usually represented by very
detailed models that are not suited for control purposes. Hence, data-based models
of the process are investigated instead. Optimization-based methods can be used to
determine the parameters of the model. As the second aspect, real-time optimization
is used to realize the discretization of the continuous fuel injection rate. As a result,
the discrete startpoints and durations of the various injection events can be determined
that resemble the continuous reference fuel-rate flow as close as possible.16 1 Introduction
References
1. N. Abe and K. Yamanaka, Smith predictor control and internal model control – a tutorial, in
SICE Conference (2003), pp. 1383–1387
2. A. Alessio, A. Bemporad, A survey on explicit model predictive control, in Nonlinear Model
Predictive Control (Springer, 2009), pp. 345–369
3. A. Bemporad, D. Bernardini, R. Long, J. Verdejo, Model predictive control of turbocharged
gasoline engines for mass production, in SAE Technical Paper, vol. 2018-01-0875 (2018)
4. BP p.l.c., Energy Outlook (2018). Accessed 2019-05-08. https://www.bp.com/content/dam/
bp/en/corporate/pdf/energy-economics/energy-outlook/bp-energy-outlook-2018.pdf
5. M. Broy, I.H. Krüger, A. Pretschner, C. Salzmann, Engineering automotive software. Proc.
IEEE 95(2), 356–373 (2007)
6. L. Del Re, P. Ortner, D. Alberer, Chances and challenges in automotive predictive control, in
Automotive Model Predictive Control (Springer, 2010), pp. 1–22
7. S. Di Cairano, An industry perspective on MPC in large volumes applications: potential benefits
and open challenges. IFAC Proc. Vol. 45(17), 52–59 (2012)
8. S. Di Cairano, I.V. Kolmanovsky, Automotive applications of model predictive control, in
Handbook of Model Predictive Control (Springer, 2019), pp. 493–527
9. ETAS GmbH, ETAS calibration consulting flyer (2018). Accessed 2018-06-17. https://www.
etas.com/download-center-files/company/Calibration_Consulting_Flyer_EN.pdf
10. European Union, Regulation (EC) No 715/2007 of the European Parliament and of the Council
of 20 June 2007 on type approval of motor vehicles with respect to emissions from light
passenger and commercial vehicles (Euro 5 and Euro 6) and on access to vehicle repair and
maintenance information. Off. J. Eur. Union (2007)
11. H.J. Ferreau, S. Almér, R. Verschueren, M. Diehl, D. Frick, A. Domahidi, J.L. Jerez,
G. Stathopoulos, C. Jones, Embedded optimization methods for industrial automatic control.
IFAC-PapersOnLine 50(1), 13 194–13 209 (2017)
12. J. Gregory, R.J. Stouffer, M. Molina et al., Climate change 2007: the physical science basis.
Intergovernmental Panel on Climate Change (2007)
13. International Energy Agency, World Energy Outlook (2016). Accessed 2018-06-20. https://
www.iea.org/publications/freepublications/
14. International Maritime Organization, MARPOL Annex VI and NTC 2008: With Guidelines for
Implementation (IMO Publishing, 2013)
15. R. Isermann, Engine Modeling and Control (Springer, 2014)
16. J. Levine, Analysis and Control of Nonlinear Systems: a Flatness-Based Approach (Springer,
2009)
17. L. Ljung, Perspectives on system identification. Ann. Rev. Control 34(1), 1–12 (2010)
18. F. Payri, J. Luján, C. Guardiola, B. Pla, A challenging future for the IC engine: new technologies
and the control role. Oil Gas Sci. Technol. 70(1), 15–30 (2014)
19. S.J. Qin, T.A. Badgwell, A survey of industrial model predictive control technology. Control
Eng. Pract. 11(7), 733–764 (2003)
20. S.V. Rakovi´c, W.S. Levine, Handbook of Model Predictive Control (Springer, 2018)
21. R.D. Reitz, Directions in internal combustion engine research. Combust. Flame 160(1), 1–8
(2013)
22. U.S. Energy Information Administration, International Energy Outlook (2017). Accessed 2019-
05-08. https://www.eia.gov/outlooks/ieo/pdf/0484(2017).pdf
23. D. von Wissel, A. Husson, V. Talon, L. Lansky, D. Pachner, M. Uchanski, Reducing engine
calibration time and cost with model predictive control, in IAV Automotive Powertrain Control
Systems Conference (2014)
24. Q.-G. Wang, Decoupling ontrol (Springer, 2002)
25. F. Willems, P. van Gompel, X. Seykens, S. Wilkins, Robust real-world emissions by integrated
ADF and powertrain control development, inControl Strategies for Advanced Driver Assistance
Systems and Autonomous Driving Functions (Springer), pp. 29–45 (2019)Chapter 2
Model-Based Approach with PID
Controllers
Abstract The state of the art in engine control is the use of decentralized PID con￾trollers based on look-up tables. For complex engine tasks, the requirements on the
controller can only be fulfilled by using a high number of calibration parameters. The
tuning of the calibration parameters is very time-consuming and is associated with
high costs as well as suboptimality. In this chapter, it will be shown why so many cal￾ibration parameters result. It will be exemplified by investigating two typical system
dynamical properties which arise in combustion engines. In particular, multiple-input
multiple-output (MIMO) system dynamics and actuator constraints are examined.
The conventional control algorithms are not able to handle these system properties
in a systematic manner. Instead, additional measures, such as decoupling terms or
anti-windup mechanisms, have to be implemented to handle the system properties.
2.1 Multiple-Input Multiple-Output Systems
MIMO systems are characterized by several inputs and outputs, as opposed to single￾input single-output (SISO). In the case of MIMO systems, the inputs and outputs may
have cross-couplings, e.g. both inputs u(t) affect both outputs y(t) simultaneously;
see Fig. 2.1. As the input and also the output are given as vectors rather than being
scalar, additional properties are present, such as the concept of directionality. Thus,
the gain of the system will not only depend on the frequency of the input but also
on the direction of the input. The direction of the input can be expressed by singular
value decomposition [11].
Within the present book, various examples will be investigated in detail where
this MIMO characteristic is present. A common engine-related example is the air
path control with exhaust gas recirculation (EGR) and turbocharging combined, as
detailed in Chap. 10. The task is to control the intake manifold pressure and the
burnt gas ratio with the actuated values being the guide vane position of the variable
turbine geometry and the EGR valve position. However, changing the EGR valve
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_2
1718 2 Model-Based Approach with PID Controllers
Fig. 2.1 Cross-couplings in a 2×2 MIMO system
position changes not only the burnt gas ratio but also the intake manifold pressure.
As a consequence, the variable turbine geometry has to be adjusted simultaneously
for appropriate closed-loop control.
In order to close-loop-control a MIMO system, two different approaches are
possible: centralized and decentralized control; see Fig. 2.2. In the case of centralized
control, one MIMO controller is used to control the entire system. Suitable control
methods are H∞, linear quadratic regulator (LQR), and model predictive control
(MPC) [1, 11]. The main objective of decentralized control is to control the outputs
of a MIMO system with distinct SISO controllers. In this case, standard SISO control
concepts such as PID can be used. The applicability of the widespread PID controller
makes the decentralized control the state of the art for engine control problems. In
the case of weakly coupled systems, their treatment as several single-loop control
problems might be sufficient. However, if the couplings are strong, the treatment
of the MIMO system as several uncoupled SISO systems for control design can
lead to unsatisfactory control performance. In the worst case, the negligence of the
cross-couplings can lead to controllers which “work against each other”. In this case,
a suitable controller can be obtained only if the cross-couplings are considered. In
general, the design of a decentralized controller is simpler. However, it is suboptimal
as it does not take the cross-couplings into account. In the following, an overview
will be given on decentralized control for MIMO systems. The fundamentals are
outlined along with some of the challenges arising for the design of decentralized
control.
2.1.1 Introduction to MIMO Systems
A common way to describe linear MIMO systems is the use of the transfer function
matrix G(s). For a system with k inputs and l outputs, the transfer function matrix
consists of the transfer functions Gi j , where i = 1,...,l and j = 1,..., k. Each
transfer function Gi j describes the relation between the input Uj(s) and the output
Yi(s). The inputs Uj(s) and outputs Yi(s) define the Laplace transform of the corre￾sponding scalar input u j(t) and scalar output yi(t) (for simplicity, vanishing initial
conditions are assumed).2.1 Multiple-Input Multiple-Output Systems 19
Fig. 2.2 Decentralized (upper plot) versus centralized (bottom plot) control for a 2×2 example
⎡
⎢
⎣
Y1(s)
.
.
.
Yl(s)
⎤
⎥
⎦ =
⎡
⎢
⎣
G11(s)... G1k (s)
.
.
. ... .
.
.
Gl1(s) ... Glk (s)
⎤
⎥
⎦
⎡
⎢
⎣
U1(s)
.
.
.
Uk (s)
⎤
⎥
⎦ (2.1)
Y(s) = G(s)U(s) (2.2)
In the example of a linear system with two inputs and two outputs, four transfer
functions result, as shown in Fig. 2.3.

Y1(s)
Y2(s)
	
=

G11(s) G12(s)
G21(s) G22(s)
	 U1(s)
U2(s)
	
(2.3)
The use of transfer function matrices allows to compute the input–output behavior
of a complex system, for instance, when the system consists of several subsystems,
each of which is described by a transfer function matrix. This is the case, for example,
when the behavior of a MIMO closed-loop system is to be determined. For the
calculation with transfer function matrices, the fact has to be considered that in
general no commutativity is given. Thus, in contrast to SISO systems, the order of
the transfer function matrices in the system does matter. Obviously, by changing
the order of the transfer function matrices, the sizes of the matrices and thus their
physical counterparts, i.e. the number of inputs, might no longer be applicable. In20 2 Model-Based Approach with PID Controllers
Fig. 2.3 Transfer functions from each input to each output for a linear 2 × 2 system
Fig. 2.4, the parallel, serial, and feedback connection of transfer function matrices is
depicted. The general calculation rules for these fundamental operations are given
in the following:
• Parallel connection
G = G1 + G2 (2.4)
• Series connection
G = G2G1 = G1G2 (2.5)
• Feedback
G = G1(I + G2G1)
−1 = (I + G1G2)
−1G1 (2.6)
The transfer function matrix of the input–output behavior can be used to analyze
the characteristics of the system investigated. The most important properties are the
pole-zero locations, controllability, observability, and stability. Standard textbooks
dealing with MIMO control, such as [10, 11], give an overview of these topics. They
also describe in detail the differences between these concepts for the SISO and the
MIMO case. Although the fundamental concepts are the same, differences result in
calculation and interpretation, such as the directionality of zeros. Additionally, there
are characteristics which are specific to MIMO systems and are directly related to
the concept of directionality. Examples are the singular value decomposition and
the relative gain array (RGA) matrix [1]. As an example, the RGA methodology is
detailed in the following.2.1 Multiple-Input Multiple-Output Systems 21
Fig. 2.4 Connections of subsystems: serial (upper left), parallel (upper right), and feedback (below)
2.1.2 Relative Gain Array
An example of a closed-loop system with a decentralized controller and a 2×2 plant is
depicted in Fig. 2.5. In this case, the decentralized controller consists of the transfer
functions C1(s) and C2(s). The first step to design decentralized controllers is to
determine which combination of input and output is the best choice for the feedback
loops. This question is sometimes called the pairing problem. For this purpose, the
RGA can be used [1]. It allows quantifying the effectiveness of a certain input to
influence a certain output in a closed-loop control setting. This influence consists of
two portions: One is the direct influence occurring when the entire system is operated
in an open-loop fashion (u1(t) → y1(t) via P11 in Fig. 2.5), and the other one is given
by the influence through the cross-couplings when the process is operated in a closed￾loop system (u1(t) → y1(t) via P21 and subsequent subsystems in Fig. 2.5).
First, with all other inputs being constant, the open-loop gain from Uj(s) to Yi(s)
can be determined.
∂Yi(s)
∂Uj(s)








Uk= j=const.
= Gi j(s) (2.7)
Next, the gain is quantified from Uj to Yi when all other loops are closed. The ideal
actuated values for perfect closed-loop tracking are given by
U(s) = G−1
(s)Y(s) (2.8)
When all other outputs Yk=i are perfectly closed-loop tracked, the sensitivities can
be calculated.22 2 Model-Based Approach with PID Controllers
Fig. 2.5 Decentralized control for a 2×2 system
∂Uj(s)
∂Yi(s)








Yk=i=const.
= [G−1
(s)]ji ⇒
∂Yi(s)
∂Uj(s)








Yk=i=const.
= 1
[G−1
(s)]ji
(2.9)
The RGA element i j(s) is given by the ratio of these two gains:
i j(s) =
∂Yi
∂Uj




Uk= j=const.
∂Yi
∂Uj




Yk=i=const.
= Gi j(s)[G−1
(s)]ji (2.10)
Alternatively, a matrix representation can be used for (s).
(s) = G(s) × (G−1
(s))T (2.11)
Here, the × operator represents an element-wise multiplication, also called a Schur
product. The matrix (s) is a transfer function matrix with some specific properties:
It is symmetric, and all rows and columns add up to one. As ratios are calculated,
the RGA matrix (s) is independent of scaling and thus also independent of the
physical units used.
Example 2.1 (Calculation of the RGA matrix) The RGA matrix (s) shall be cal￾culated for a system with two inputs and two outputs (the dependence on s is omitted
for readability).
G(s) =

G11 G12
G21 G22	
, (s) = 1
G11G22 − G12G21  G11G22 −G12G21
−G12G21 G11G22	
(2.12)2.1 Multiple-Input Multiple-Output Systems 23
The RGA matrix (s) can be evaluated to determine suitable parings of inputs and
outputs. As (s) is a transfer function matrix, the evaluation has to be conducted
at a certain frequency. Typically, the steady-state properties s = 0 and the crossover
frequency region s ∈ [jωc,low, jωc,up] are of interest. In the case of i j(s) = 1, the
input–output combination is only affected by the open-loop gain and is not affected
by any cross-couplings. Consequently, this would be a perfect choice for pairing.
In general, it is advisable to pair inputs and outputs where the RGA elements are
close to one. The more closely the RGA matrix is to the identity matrix I, the better
the system is suited for decentralized control. For the quantification of “closeness”,
any distance norm can be used. Pairings with very high or very low values in the
RGA matrix should be avoided, as this indicates a very strong interaction with other
variables than the paired variables. For i j(s) = 0, there is no open-loop effect of
the input on the output, thus it is a bad choice for pairing. Pairings with i j(s) < 0
should also be avoided, as these can lead to problems with closed-loop stability [11].
Example 2.2 (Design of a decentralized controller) In the following, an example
for decentralized control design is investigated. The system to be controlled is given
by the transfer function matrix P(s):
Y(s) = P(s)U(s) (2.13)

Y1
Y2
	
=
 1
s+1
4
s+8
0.5
s+1
1
s+1
 
U1
U2
	
(2.14)
The considered system has similarities with the Rosenbrock system which is clas￾sically used as an example for a system that looks simple to control, but has some
fundamental limitations [3]. In order to choose the pairing of inputs and outputs, the
RGA matrix is calculated. With the equations given in (2.12), the RGA matrix can
be calculated exemplarily for s = 0.
(0) =
 1.33 −0.33
−0.33 1.33	
(2.15)
The resulting  matrix suggests to pair input y1 with u1 and, for the second control
loop, to pair y2 with u2. For an initial control synthesis, the cross-couplings are
ignored, i.e. P12 = P21 = 0. The effects of cross-couplings are considered as external
disturbances d1 and d2, which can ideally be rejected by the closed-loop controller.
As a consequence, two SISO control loops remain, which can easily be designed; see
Fig. 2.6. Ignoring the cross-couplings, results in the system P˜(s) with two first-order
elements on the diagonal.
Y(s) = P˜(s)U(s) (2.16)

Y1
Y2
	
=
 1
s+1 0
0 1
s+1
	 U1
U2
	
(2.17)24 2 Model-Based Approach with PID Controllers
Fig. 2.6 The decentralized controller for the system investigated
Simple proportional controllers with C1 = 18, C2 = 20 result in suitable closed￾loop control for the two SISO loops.

U1
U2
	
=

18 0
0 20	 R1 − Y1
R2 − Y2
	
(2.18)
To determine the closed-loop dynamics of the entire system, the complementary
sensitivity functions can be calculated.
T1(s) = Y1(s)
R1(s) = C1(s)P11(s)
1 + C1(s)P11(s) = 18
s + 19
T2(s) = Y2(s)
R2(s) = C2(s)P22(s)
1 + C2(s)P22(s) = 20
s + 21
(2.19)
The left-hand side plot in Fig. 2.7 shows the step response of the two single closed
loops without any further cross-couplings considered, i.e. P˜(s) is used as a plant. A
suitable closed-loop control performance is achieved. However, the picture changes
as the full system, i.e. P(s) as a plant, is investigated. The step response of the
closed-loop system is shown in the right-hand plot of Fig. 2.7. Including the cross￾couplings, the system turns out to be unstable. Figure 2.8 shows the pole-zero map
of the open-loop system P(s). The difficulty in controlling the system arises due to
the existence of a right half-plane transmission zero. Consequently, cross-coupling
can lead to instability, even if all SISO closed loops are stable. In order to achieve
suitable control performance, the closed-loop couplings have to be considered in the
design. One possibility to still rely on a SISO control synthesis while considering the2.1 Multiple-Input Multiple-Output Systems 25
0123
-0.5
0
0.5
1
1.5
2
0123
Fig. 2.7 Step response of the closed-loop system with P˜(s) as a plant (left) versus P(s) as a plant
(right)
-8 -6 -4 -2 0 2 4 6 8
-1
0
1
Fig. 2.8 Pole-zero map of the open-loop system P(s)
couplings in the design process can be achieved by using system decoupling, which
is explained in the following.
2.1.3 System Decoupling
If the controller design with separate SISO controllers for the decentralized system
is insufficient, the cross-couplings have to be considered in the design. One approach
for dealing with the cross-couplings while still using SISO control synthesis is the
application of decoupling in addition to the decentralized controller. The idea is to
introduce a decoupling matrix D(s) to achieve a sufficient decoupling of the system
to allow for decentralized control synthesis. Ideally, after the introduction of D(s),
no cross-coupling effects are present anymore.
The diagonal controller matrix C(s)is designed in a separate step once the system
is decoupled. The structure of the closed-loop system including the decoupling matrix
is given in Fig. 2.9. The dynamics of the closed-loop system can be calculated by the26 2 Model-Based Approach with PID Controllers
Fig. 2.9 Principle of decoupling for a 2×2 plant
transfer function matrix T(s). For readability, the dependency on s is omitted when
appropriate.
T = P DC
I + P DC−1
(2.20)
The closed-loop system is perfectly decoupled if T(s) is diagonal and nonsingu￾lar [12]. The matrix C(s) is diagonal, as a decentralized controller is investigated. If
T(s) is diagonal, the inverse T −1(s) has to be diagonal as well. The inverse is given
by
T −1 = 
I + P DC
P DC−1
=

P DC−1
+ I
(2.21)
As a consequence, the closed-loop system T(s) is diagonal (and thus decoupled), if
and only if the open-loop system P(s)D(s) is decoupled. The matrix D(s) has to
be designed such that P(s)D(s) is diagonal. In this case, the following open-loop
behavior is achieved.
P(s)D(s) = diag
Q11(s), Q22(s), . . .  (2.22)
In a perfectly decoupled system, all off-diagonal terms are zero. The diagonal
entries of the new decoupled system matrix are represented by Q11(s), Q22(s), and
so on. For a 2×2 plant, the following equations result with the structure corresponding
to Fig. 2.9.
D(s) =
 D11 D22D12
D11D21 D22 	
(2.23)
Using det(P(s)) for the determinant of P(s), the elements of the decoupling matrix
D(s) are given by2.1 Multiple-Input Multiple-Output Systems 27
D11 = P22
det(P)
Q11 = P22
P11P22 − P12P21
Q11, D12 = − P12
P11
,
D22 = P11
det(P)
Q22 = P11
P11P22 − P12P21
Q22, D21 = − P21
P22
(2.24)
The control engineer designs the transfer functions Qii(s) on the diagonal of the
resulting decoupled MIMO system. The appropriate choice of the transfer functions
for Qii(s) depends strongly on the original system. One possibility is to use the
diagonal elements of the original system, i.e. Qii(s) = Pii(s).
This general decoupling approach relies on inverting the transfer functions of the
original system. The inversion-based design has limitations for many cases, such as
the presence of model uncertainty, dead-times, right half-plane zeroes, and poles.
These properties can have a major (negative) impact on the performance of the
decoupled system. Furthermore, an exact decoupling may be rendered impossible
by the fact that all terms in the decoupling matrix have to be proper to be applicable
in an online control system. For more information on how the decoupling matrix
is calculated, as well as which constraint exists on the performance achievable, the
reader is referred to [12].
For certain systems, a transfer function matrix D(s) exists for perfect decou￾pling. However, this approach often fails. In general, perfect decoupling is difficult
or impossible to achieve for a given system. In practice, perfect decoupling is often
not even necessary, because an approximate decoupling is sufficient. Depending
on the system characteristics present, various approaches for approximate decou￾pling exist [12]. For instance, the issue of improper terms in D(s) can be solved by
introducing additional poles until the terms are proper. Doing so, the original decou￾pling terms are recovered for low frequencies. Another alternative for approximate
decoupling is to use decoupling at one specific frequency, i.e. at s = jωdes. If the
determinant det(D(jωdes)) = 0, then D(jωdes) can be chosen as a constant, i.e. a
frequency-independent decoupling matrix. A common choice is ωdes = 0 rad
s such
that the system is statically decoupled, i.e. at steady state. Another alternative is a
decoupling at the desired bandwidth. The use of static decoupling is often better
than no decoupling. If approximate decoupling is applied, it is important to check
if the closed-loop system fulfills the desired properties, of which at least stability is
critical. There are no theoretical guarantees on performance. However, quite good
results are usually observed in practice.
Example 2.3 (Closed-loop control with decoupling) The closed-loop control system
from Example 2.2 is to be extended by a decoupling term. Figure 2.8 showed that
the system has a non-minimum phase zero at a frequency of 6rad
s , which limits the
feasible choices for the diagonal terms of the decoupled system. The zero has to
occur in the chosen transfer functions Qii . Additional poles are introduced for Qii ,
such that the resulting decoupling terms are strictly proper. One feasible choice is
given by
Q11 = Q22 = − 0.1(s − 6)
s2 + 9s + 8 (2.25)28 2 Model-Based Approach with PID Controllers
Fig. 2.10 Closed-loop
control including decoupling
matrix with simple feedback
controller
0123
-0.5
0
0.5
1
1.5
2
With (2.24), the decoupling matrix can be calculated as
D11 = D22 = 0.1
D12 = −4(s + 1)
s + 8 , D21 = −1
2
(2.26)
Example 2.2 showed that the controllers C1 = 18 and C2 = 20 lead to unstable
closed-loop system behavior when no decoupling is used. When the decoupling
term is added, the closed-loop system becomes stable. Figure 2.10 shows the step
response for the resulting system with the calculated decoupling matrix and the same
controllers C1 = 18 and C2 = 20. The closed-loop system is stable, and even perfect
decoupling can be achieved. For a step response on y1, there is no impact on y2. For the
given system, the MIMO non-minimum phase transmission zero cannot be canceled:
It is still present in the decoupled system. By using this decoupling approach, any
SISO control design can be applied to shape the closed-loop control response. With
the simple proportional controller, for instance, a significant steady-state error results.
This can be eliminated by more advanced controllers.
2.2 Actuator Constraints
There is extensive theory available about linear controllers. The closed-loop control
performance remains good as long as the plant dynamics remain close to the linear
system dynamics that was used for synthesizing the controller. In reality, in all plants
nonlinear effects are present. Constraints are one example of a nonlinear effect that2.2 Actuator Constraints 29
Fig. 2.11 System becomes open-loop if saturation is active
is always present. The constraints concern, for instance, the actuator: Due to limited
energy, the actuators do have an upper and a lower limit on the absolute value of the
actuated value or on the rate of change. Often, these constraints limit the closed-loop
control performance. Usually, the actuator cannot be changed for economic, size, or
weight reasons.
In Fig. 2.11, the closed-loop system is shown including actuator constraints. The
presence of these actuator saturations can give rise to undesired behavior in the
closed-loop system. The saturation can lead to closed-loop instability or a sluggish
response with temporary large control errors. As soon as the saturation is active,
the closed-loop system is not present anymore. Instead, an open-loop behavior is
present. For an unstable plant, this inevitably leads to an unstable closed-loop system.
Additionally, problems result with integrator windup and MIMO systems, as detailed
in the following.
2.2.1 Integrator Windup
If an integrator is present within the controller or the plant, the problem of integrator
windup can occur. A typical example is the combination of a controller with integral
action and an actuator that has saturations. When the actuated value is saturated, the
integral part will continue to integrate the error, as the error is typically not zero. Due
to the constrained actuated value, the integration is decoupled from the actual system
behavior, i.e. the increasing integral part does not have an influence on the actuated
value. The calculated actuated value of the controller can become very large due to
the term of the integrator. Even when the error changes, e.g. due to a change of the
reference value, it takes a long time until the non-saturated region is reached again.
Consequently, a sluggish behavior results in transients.
One possibility to counteract this undesired behavior is the use of an anti-windup
mechanism. A well-known example is the so-called back-calculation scheme [4].
Figure 2.12 shows the functional diagram of the back-calculation scheme. The
anti-windup scheme has no effect when the actuator is not saturating, i.e. when
et(t) = 0. The time constant Tt determines how quickly the integrator of the PID
controller is reset. Thus, Tt serves as a tuning parameter. For calculating the differ￾ence et(t) = v(t) − u(t), the actual (saturated) output u(t) of the actuator has to be30 2 Model-Based Approach with PID Controllers
Fig. 2.12 Anti-windup with back calculation
either measured or determined by a mathematical model. A typical example for such
a mathematical model is given in (2.27).
u(t) = sat(v) =
⎧
⎪⎨
⎪⎩
umax , for v > umax
u, for umin ≤ v ≤ umax
umin, for v < umin
(2.27)
2.2.2 Directionality in Constrained MIMO Systems
Not only the magnitude and frequency of the input are important in MIMO systems,
but also their direction due to cross-couplings. Active input constraints may change
the direction of the input and a nonlinear system behavior of the plant results. In a
closed-loop system, the active input constraints can lead to an undesirable system
response. This problem is independent of the integrator windup discussed previously.
The problem with directionality can also occur when no integrators are involved, e.g.
when a simple proportional feedback controller is used.
To further illustrate this problem, a closed-loop system with a decentralized con￾troller is to be treated. In Sect. 2.1.3, the usefulness of decoupling was introduced. A
system is considered that is in nominal operation, i.e. without any active saturations,
perfectly decoupled. As soon as input saturations are active, the directionality of the
inputs is changed, such that for saturated inputs the decoupling is lost. Example 2.3
showed that the decoupling has a significant effect on the closed-loop stability. As a
result, the closed-loop system can become unstable as soon as the input constraints
are active, and thus decoupling is no longer given. Additional measures have to be2.2 Actuator Constraints 31
introduced to counteract this behavior. One example is the introduction of a reference
shaping filter [8].
Example 2.4 (Actuator constraints for a MIMO system) Suppose a 2×2 MIMO
system is given. The transfer function matrix of the system is given by P(s).
P(s) = Y(s)
V(s) =
 2
s+4
4
s2+3s+4
0 1
s+2

(2.28)
The input to the system is denoted by v. It is saturated at v1,max = 0.8 and v2,max = 1.
In order to decouple the system, the following decoupling matrix D(s) is introduced.
D(s) = V(s)
U(s) =

−1 2(s+4)
s2+3s+4
0 1 
(2.29)
The open-loop transfer function without considering the input saturations is given
by P(s)D(s).
P(s)D(s) =
 2
s+4 0
0 1
s+2

(2.30)
The left-hand side of Fig. 2.13 shows the response to a step in u2 for the system
P(s)D(s) without considering the input constraints. The system is perfectly decou￾pled, i.e. the input u2 only affects y2 but not y1. However, if the step response
is simulated for the system including the input constraints, the decoupling is not
effective any more; see the right-hand side plot of Fig. 2.13. Due to saturation, the
0 5 10
0
0.2
0.4
0.6
0.8
1
0 5 10
Fig. 2.13 Step response of the MIMO system without input saturations (left) and with input satu￾rations (right)32 2 Model-Based Approach with PID Controllers
directionality changes and the nonlinear system behavior no longer lead to a decou￾pling. In the case of a closed-loop control system, this can affect the stability of the
system.
2.3 Control Approach Based on Look-Up Tables
Since the engine is characterized by nonlinear behavior, a linear controller is often not
sufficient for appropriate control performance. In practice, the nonlinearity is tackled
by the use of look-up tables. In a control approach based on look-up tables, depending
on the control task, either feedforward control, feedback control, or a combination of
both is applied. Figure 2.14 shows the resulting closed-loop control structure when
feedforward and feedback control are used simultaneously. The feedforward control
action is directly calculated with the use of a look-up table. For this case, at least
one signal is present which serves as an input to the look-up table. This signal might
either be the reference value or a disturbance variable which is measured or estimated.
Based on this input signal, the look-up table calculates the output signal. For this
reason, the look-up table is segmented into different regions, depending on the input
value(s). For each cell, a feedforward control value is assigned. In between these
values, a linear interpolation is conducted [6]. In the case of multiple input variables,
a bilinear area interpolation is performed [9].
Fig. 2.14 Controller based on look-up tables2.3 Control Approach Based on Look-Up Tables 33
As a feedback control algorithm, most commonly SISO control loops with PID
controllers are used, resulting in decentralized controllers. A standard PID controller
is designed with three parameters, KP , KI , and K D [2]. However, if a nonlinear
process is controlled, where the system behavior depends strongly on the operating
point, a standard PID controller is insufficient to achieve a highly dynamic reference
tracking. Consequently, the parameters KP , KI , and K D are parametrized depend￾ing on the operating point based on look-up tables. A possible approach is to use
linearization of the nonlinear model to design the values KP , KI , and K D for the
different operating points. The look-up tables work equivalently to the description
given in the case of the feedforward part. The main advantage of the approach based
on look-up tables is the fast processing of the algorithm due to its simplicity. Thus,
only low requirements for the control hardware in terms of memory storage and pro￾cessor result. The simple structure of the controller also allows for easy recalibration.
If the control behavior is to be adapted only at a certain operating point, this can be
done in a straightforward manner.
Drawbacks arise especially in the case of a high number of inputs and outputs
as a high amount of calibration work results. Figure 2.15 shows an example of a
feedforward control calibration based on look-up tables. In this example, the fuel
mass injected per cylinder is plotted on the left in terms of engine speed and torque.
On the right-hand side, in addition to the engine speed and torque, the ambient
temperature is used as an input for the look-up table. Changing from two inputs
to three inputs, each input considered with four segments, leads to an increase in
number of calibration parameter from 42 = 16 to 43 = 64 values. Clearly, the curse
of dimensionality is coming into full play. For a small number of inputs, a relatively
small number of calibration parameters is needed. However, already for a system that
Fig. 2.15 Structure of 2D and 3D look-up tables34 2 Model-Based Approach with PID Controllers
is just slightly more complex, large numbers of calibration parameters are required.
At the same time, the decentralized PID controllers are unable to account for the
MIMO nonlinear dynamics in a systematic way. As shown in the previous sections,
additional measures are needed. Constraints on the actuators pose problems as well,
e.g. additional anti-windup schemes have to be implemented. The constraints can
also exist on the system states. This might be due to safety limitations, e.g. because
the temperature has to stay within a certain region for a safe operation. The PID-based
controllers handle constraints on system states by choosing setpoints sufficiently far
from constraints and by adding protection logics [5]. Therefore, suboptimal plant
operation results.
As several system dynamic characteristics cannot be handled in a systematic way,
the calibration process can be very time-consuming. For proof of validity, a lot of
tests, e.g. at the test bench or in the vehicle have to be conducted. This results in
high costs for the control development. Further restrictions of the approach based
on look-up tables arise due to its structure, which does not allow high reusability of
parts of the controller. Consequently, a new setup, e.g. due to a change of individual
components, often leads to a new determination of the calibration labels.
In conclusion, the control approach based on look-up tables is well suited for
control tasks that are characterized by a low number of inputs and outputs, no strong
nonlinearity, and no strong interconnections with other components such that they
can be treated as SISO systems. However, in the case of modern engines, the number
of inputs and outputs is increasing, causing the number of calibration parameters
to be drastically increasing as well. This makes the calibration of controllers with
look-up tables very tedious. In Fig. 1.4, the development of the number of calibration
labels from 1997 to 2017 was already shown [7]. The calibration labels increase by
a factor of more than six for an increase in the number of degrees of freedom by
approximately 2.5. Future engines will likely have even a higher number of degrees of
freedom. Consequently, increasingly more calibration labels have to be determined
by heavy use of measurements at a test bench or in the vehicle. In [7], the work share
during the calibration process of current engine controllers is detailed as follows:
1. 5% calibration time in a virtual environment,
2. 25% calibration time at the test bench, and
3. 70% calibration time in the vehicle.
Due to the strong use of late development stages (such as vehicle testings) in the
calibration procedure, the calibration procedure is not only very time-consuming but
also very expensive. A possible alternative to overcome these drawbacks is given by
a switch to new advanced control algorithms, such as MPC.
References
1. P. Albertos, S. Antonio, Multivariable Control Systems: An Engineering Approach (Springer,
2006)
2. K.J. Aström, T. Hägglund, Advanced PID control, in ISA – The Instrumentation, Systems, and
Automation Society, vol. 461 (2006)References 35
3. K.J. Aström, K.H. Johansson, Q.-G. Wang, Design of decoupled PID controllers for MIMO
systems, in American Control Conference (2001), pp. 2015–2020
4. K.J. Aström, R.M. Murray, Feedback Systems: An Introduction for Scientists and Engineers
(Princeton University Press, 2010)
5. S. Di Cairano, I.V. Kolmanovsky, Automotive applications of model predictive control, in
Handbook of Model Predictive Control (Springer, 2019), pp. 493–527
6. L. Eriksson, L. Nielsen, Modeling and Control of Engines and Drivelines (Wiley, 2014)
7. ETAS GmbH, ETAS calibration consulting flyer (2018). Accessed 2018-06-17. https://www.
etas.com/download-center-files/company/Calibration_Consulting_Flyer_EN.pdf
8. P. Hippe, Windup in Control: Its Effects and Their Prevention (Springer, 2006)
9. R. Isermann, Engine Modeling and Control (Springer, 2014)
10. J.M. Maciejowski, Multivariable Feedback Design (Addison-Wesley, 1989)
11. S. Skogestad, I. Postlethwaite, Multivariable Feedback Control: Analysis and Design (Wiley,
2007)
12. Q.-G. Wang, Decoupling Control (Springer, 2002)Chapter 3
Mathematical Fundamentals
of Optimization
Abstract The fundamental principle of model predictive control (MPC) is the solu￾tion of an optimization problem in real time. The optimization problem is designed
in such a way that it reflects the goals of the control algorithm. For the development
of MPC controllers for complex engine tasks, a solid knowledge of optimization is
required. This chapter provides a brief overview of the fundamentals of optimiza￾tion. Rather than an overview of the entire field, the optimization fundamentals are
described that are particularly needed for the application of MPC in the field of com￾bustion engines. The reader also is familiarized with the notation used. The chapter
is to discuss various classifications of optimization problems. Furthermore, the con￾cept of convexity is introduced. Additionally, the optimality conditions for nonlinear
programs (NLP) are examined.
3.1 Introduction to Optimization Problems
The optimization tasks that are to be treated within this book can be seen as the math￾ematical search for the best solution. Within MPC, optimization is used to find the
most suitable actuated values to control the process. For this purpose, various criteria
are taken into account, such as deviations from the predicted output to the reference
value. Optimization tasks obviously are not only found in the context of closed-loop
control but also in many other applications. Examples are portfolio management,
where the investment in different assets is optimized [4], routing for autonomous￾mobility-on-demand, where the traffic throughput through a city is investigated [9],
or system identification, where the model parameters are explored for the best fit to
measurement data [7]. This chapter provides a brief overview of the fundamentals of
optimization that are necessary for the MPC of combustion engines and introduces
the notation used. Readers who are interested in further details, such as mathematical
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_3
3738 3 Mathematical Fundamentals of Optimization
Fig. 3.1 Equivalence of maximization and minimization problems
proofs of the presented statements, are referred to the many good textbooks which
suit this purpose [2, 3, 8].
To find the best solution of an optimization problem, there has to be a quantification
of the objective. This is done by the so-called cost function J (z) (sometimes also
called objective function) where z represents the optimization variables. The output
of the cost function is a scalar value which enables a comparison of different costs.
Depending on the application, the goal is to minimize or maximize this cost function
under certain constraints. A minimization is desired to reduce the material usage
for the production of a certain product, for instance, whereas the maximization is
requested for the throughput of a product in a plant. However, they are equivalent:
the minimization of J (z) corresponds to the maximization of −J (z), as illustrated
in Fig. 3.1. From now on, the focus will be on the minimization of the cost function.
One specific class of optimization problems is investigated first in order to famil￾iarize the reader with the notation used. It is the so-called NLP, which is an important
class of optimization problems for engine MPC. For an NLP, the cost function is
defined by J (z) : Rn → R, where J (z) is a general nonlinear function. The cost
function is optimized for the optimization variables z ∈ Rn, which are given as
column vector z = [z1,...,zn]
T. The minimal cost is called optimum or alterna￾tively minimum and is denoted as J ∗ = J (z∗). To denote the optimizer, also called
minimizer, of the optimization problem, z∗ is used. In the case of an unconstrained
optimization problem, the cost function is minimized without taking into account any
additional constraints. The unconstrained optimization problem for an NLP reads as
follows:
min
z ∈ Rn J (z) (3.1)3.1 Introduction to Optimization Problems 39
Besides the cost function, additional constraints can be added, such that a constrained
optimization problem results. The constraints can be divided into equality constraints,
which have to be fulfilled exactly, and inequality constraints, where the inequality has
to be fulfilled. The general constrained NLP is denoted by the following equations:
min
z ∈ Rn J (z) (3.2a)
s.t. h(z) = 0, h : Rn → Rp, (3.2b)
g(z) ≤ 0, g : Rn → Rq (3.2c)
In (3.2b), the equality constraints are given, whereas (3.2c) shows the inequality
constraints. Both, the equality and the inequality constraints have to be fulfilled,
which is why they are also called hard constraints. The constraints of the optimization
problem define the feasible set Ω, i.e. the set of all points which satisfy the constraints.
Ω = {z ∈ Rn|g(z) ≤ 0, h(z) = 0} (3.3)
With Ω, the NLP can be rewritten in an equivalent form.
min
z ∈ Ω
J (z) (3.4)
For the solution of the optimization problem, various types of minimizers z∗ can be
distinguished. Examples of the various types of solutions are depicted in Fig. 3.2.
• The minimizer z∗ is a local minimizer if z∗ ∈ Ω and if there is a neighborhood
N(z∗) of z∗, such that
(a) (b) (c)
Fig. 3.2 Illustrations of the various types of solutions: a z∗
1 is a strict local solution, z∗
2 is a unique
global solution, and each z∗ ∈ [a, b] is a non-strict local solution; b z∗
1 and z∗
2 are strict local
solutions, there exists no global solution; c there exists no solution40 3 Mathematical Fundamentals of Optimization
J (z∗) ≤ J (z) ∀z ∈ N(z∗) ⊂ Ω (3.5)
• The minimizer z∗ is a strict local minimizer if z∗ ∈ Ω and if there is a neighborhood
N(z∗) of z∗, such that
J (z∗) < J (z) ∀z ∈ N(z∗) ⊂ Ω, z = z∗ (3.6)
• The minimizer z∗ is a global minimizer if z∗ ∈ Ω and
J (z∗) ≤ J (z) ∀z ∈ Ω (3.7)
• The minimizer z∗ is an unique global minimizer if z∗ ∈ Ω and
J (z∗) < J (z) ∀z ∈ Ω (3.8)
The influence of the constraints on the location of the minimizer is visualized
in Fig. 3.3, which shows one cost function with iso-contour lines for the same cost
and where the arrow indicates an increasing cost. If the unconstrained minimizer
is within the feasible set of the constrained optimization problem, the minimizer
does not change. An inequality constraint i is called active if gi(z∗) = 0 and inactive
in the case of gi(z∗) < 0. Disregarding the inactive inequality constraints in the
optimization problem does not change the minimizer. However, usually it is not
known in advance as to which constraints are inactive. In contrast to the inequality
constraints, all equality constraints are active, as they always have to be fulfilled.
Within the numerical optimization algorithms, derivatives of functions play an
important role. These are especially the gradient, Jacobian, and the Hessian of a
function, which are introduced in the following.
Gradient
For a continuously differentiable function f (z) : Rn → R, the gradient is given by
the column vector ∇ f .
∇ f =
⎡
⎢
⎢
⎣
∂ f
∂z1
.
.
.
∂ f
∂zn
⎤
⎥
⎥
⎦
(3.9)
Jacobian
The Jacobian matrix of a (vector-valued) continuously differentiable function
f(z) : Rn → Rm is given by ∂ f
∂z .
∂ f
∂z =
⎡
⎢
⎢
⎣
∂ f1
∂z1 ··· ∂ f1
∂zn
.
.
. ... .
.
. ∂ fm
∂z1 ··· ∂ fm
∂zn
⎤
⎥
⎥
⎦
(3.10)3.1 Introduction to Optimization Problems 41
Fig. 3.3 Visualizations of the influence of constraints on the location of the minimizer
As commonly done in optimization literature, the nabla operator will also be used
for vector-valued functions. The matrix ∇ f(z) defines the transpose of the Jacobian
matrix
∇ f =
⎡
⎢
⎢
⎣
∂ f1
∂z1 ··· ∂ fm
∂z1
.
.
. ... .
.
. ∂ f1
∂zn ··· ∂ fm
∂zn
⎤
⎥
⎥
⎦
(3.11)
which can also be denoted by
∇ f(z) = [∇ f1(z), ∇ f2(z), . . . , ∇ fm(z)] (3.12)
Hessian
For a twice continuously differentiable function f (z) : Rn → R, the Hessian defines
a matrix-valued function. The Hessian will be denoted by ∇2 f . Due to the commu-42 3 Mathematical Fundamentals of Optimization
tative property of the differentiation, the Hessian matrix is symmetric.
∇2 f =
⎡
⎢
⎢
⎣
∂2 f
∂z2
1
··· ∂2 f
∂z1 zn
.
.
. ... .
.
. ∂2 f
∂zn z1 ··· ∂2 f
∂z2
n
⎤
⎥
⎥
⎦
(3.13)
Within optimization algorithms, the definiteness of the Hessian is an important char￾acteristic. A symmetric n×n matrix Ais called positive (semi)definite if the following
condition holds:
sT As > (≥) 0, ∀s ∈ Rn, s = 0 (3.14)
A practical way to determine whether a matrix is positive (semi)definite is the eval￾uation of the eigenvalues. The eigenvalues σi,i = 1, ..., n can be calculated by the
solution of
det(A − σI) = 0 (3.15)
Here, I is the n×n identity matrix. The matrix A is positive (semi)definite, if it holds
σi > (≥) 0, ∀i ∈ {1,..., n} (3.16)
If (−A) is positive (semi)definite, then A is called negative (semi)definite. The nota￾tion A  0, A  0, A ≺ 0, A  0 denotes a positive-definite, positive-semidefinite,
negative-definite, and a negative-semidefinite matrix A.
3.2 Convex Optimization Problems
Convexity is an important characteristic for the distinction of optimization problems.
When the optimization problem is convex, a lot of beneficial properties are present,
such that it becomes easier to find the solution numerically. In order to classify
optimization problems as convex, the notions of a convex set and a convex function
have to be known.
Convex Sets
A set Z ⊆ Rn is convex if the following condition is fulfilled:
z = kx + (1 − k) y ∈ Z, ∀x, y ∈ Z, k ∈ [0, 1] (3.17)
The geometric interpretation is that the set Z is convex if the straight line connect￾ing any pair of points from within the set lies completely inside the set, as shown in
Fig. 3.4. One property that can be utilized for MPC is the property that the intersection
set of convex sets is a convex set again. This property holds true for an infinite number
of sets. Scaling does not influence the convexity properties, i.e. αZ, where α ∈ R is3.2 Convex Optimization Problems 43
x
y
x
y y
x
y
x
(a) convex (b) convex (c) non-convex (d) non-convex
Fig. 3.4 Examples for convex and non-convex sets
a convex set if Z is convex. There are also many other properties that are associated
with convex sets and operations that preserve convexity [3].
Convex Function
A function f (z) : Z → R is convex if Z ⊆ Rn is a convex set and the function
satisfies the following condition for all points x, y ∈ Z, x = y:
f (z) ≤ k f (x) + (1 − k) f ( y) ∀z = kx + (1 − k) y, k ∈ [0, 1] (3.18)
This condition can be interpreted in a geometrical sense that the line segment con￾necting any two points on the graph of the function lies above (or on) the graph.
Furthermore, the function f is called strictly convex if the following inequality
holds:
f (z) < k f (x) + (1 − k) f ( y) ∀z = kx + (1 − k) y, k ∈ (0, 1) (3.19)
The function f is called (strictly) concave if − f is (strictly) convex.
If the function f (z) : Z → R is twice continuously differentiable, the convexity
can be examined in the following practical way:
• f (z) is convex if the Hessian ∇2 f (z) is positive semidefinite ∀z ∈ Z.
• f (z) is strictly convex if the Hessian ∇2 f (z) is positive definite ∀z ∈ Z.
• f (z) is concave if the Hessian ∇2 f (z) is negative semidefinite ∀z ∈ Z.
• f (z) is strictly concave if the Hessian ∇2 f (z) is negative definite ∀z ∈ Z.
Exemplary convex and non-convex functions are demonstrated in Fig. 3.5. For convex
functions, there are also operations that preserve convexity [3]. For instance, the sum
of two convex functions is a convex function again f3(z) = f1(z) + f2(z).
Convex Optimization Problem
Assume that the following NLP is given:44 3 Mathematical Fundamentals of Optimization
(a) (b) (c)
Fig. 3.5 a Convex function, b concave function, and c function is neither convex nor concave
min
z ∈ Rn J (z)
s.t. hi(z) = 0, i = 1, ..., p,
gi(z) ≤ 0, i = 1, ..., q
(3.20)
The individual constraint functions are given by hi(z) : Rn → R and gi(z) :
Rn → R and define the feasible set z ∈ Ω. An optimization problem is (strictly)
convex if the cost function J is a (strictly) convex function and the feasible set Ω is
a convex set.
Convexity of the feasible set is achieved, for instance, when each single constraint
defines a convex set, as the intersection of convex sets becomes a convex set again. In
this case, each equality constraint function hi(z),i = 1,..., p has to be a linear or an
affine function. For a nonlinear function, the equality constraint directly translates to a
non-convex set. Additionally, for each inequality constraint gi(z)≤ 0,i = 1,..., q ,
the functions gi have to be convex functions, as these define convex sets [3].
Extensive theory exists on the subject of convex optimization [3]. Convex opti￾mization problems have properties that make them attractive for numerical solutions.
In general, they can be solved more easily and faster than non-convex optimization
problems. Additionally, conclusions can be drawn about global optimality which is
generally not possible for non-convex optimization problems. For convex optimiza￾tion problems, every local minimum is also a global minimum. As a consequence, if
there exists an isolated local minimum, it is also the unique global minimum. Opti￾mization problems with a strictly convex cost function and a convex feasible set have
either one or no minimum. If there exists a minimum, it is directly the unique global
minimum.
Example 3.1 (Convex functions) In the following, the connection between the defi￾niteness of the Hessian and the convexity of the function is demonstrated. Figure 3.6
shows plots of functions with f (z) : R2 → R as well as their projection of the sur￾face onto the plane z1z2 (R2). The left plot shows a strictly convex function. The
positive definiteness of ∇2 f (z) ∀z ∈ Z renders it strictly convex. If this function3.2 Convex Optimization Problems 45
1 , 2>0 1>0, 2=0 1>0, 2<0
Fig. 3.6 Function: a strictly convex, b convex, and c neither convex nor concave
was a cost function to be minimized, one unique global minimum of the function
would result. In the case of positive semidefinite Hessian matrices ∇2 f (z) ∀z ∈ Z
with one eigenvalue equal to zero, a convex but not strictly convex function would
result. The corresponding function is shown in the middle. The function is constant
in the direction of the eigenvector associated with σ2 = 0. If this function was a
cost function to be minimized, no unique minimum would be present anymore. In
the case where ∇2 f (z) ∀z ∈ Z has one positive and one negative eigenvalue, the
function is neither convex nor concave. The function is shown on the right plot. It is
characterized by a saddle point.
3.3 Classes of Optimization Problems
There are many possibilities to classify optimization problems. Depending on the
class of optimization problem, the representable challenges vary, the characteristics
change, and, accordingly, different suitable solution methods are available. In the
following, some important optimization classes for engine MPC are introduced. First,
the difference between static and dynamic optimization problems will be outlined.
Based on that outline, various examples of static optimization problems, specifically
linear, quadratic, nonlinear, integer, and mixed-integer programs are described.
3.3.1 Dynamic Optimization
The goal of dynamic optimization is to determine the function of an independent
variable (often time t) that solves the optimization problem given. For that reason,
the optimization is conducted over a function space and can thus be interpreted as an
optimization problem with infinite number of optimization variables. One specific
class within dynamic optimization is the class of optimal control problems (OCP)
which will be relevant for the engine MPC. For an OCP problem, a possibly nonlinear46 3 Mathematical Fundamentals of Optimization
dynamic system is given with an input u ∈ Rm and the system states x ∈ Rn. The
dynamic system is described by an ordinary differential equation (ODE) and its initial
value.
x˙(t) = f(x(t), u(t), t)
x(t0) = x0
(3.21)
The task within the OCP is to find a trajectory u(t) ∈ Rm, t ∈ [t0, t f ], such
that the resulting state trajectory x(t) ∈ Rn, t ∈ [t0, t f ] minimizes the cost func￾tion J (x(t), u(t)) while satisfying the constraints. The cost function is defined as
Jocp.
Jocp(x(t), u(t)) = l f (x(t f )) +
 t f
t0
ls(x(t), u(t))dt (3.22)
The cost function Jocp is often divided in two parts, the stage cost resulting from
the integration of ls called Lagrange term and the final cost l f called Mayer term. A
typical example of an OCP then reads as follows:
min
x(t), u(t)
Jocp(x(t), u(t)) (3.23a)
s.t. x˙(t) = f(x(t), u(t), t), ∀t ∈ [t0, t f ], (3.23b)
x(t0) = x0, (3.23c)
h(x(t f )) = 0, (3.23d)
g(x(t), u(t)) ≤ 0, ∀t ∈ [t0, t f ] (3.23e)
In this optimization problem, the system dynamics are considered in (3.23b),
while (3.23c) considers the initial state of the system at t = t0. The function
h(x(t f )) ∈ Rn represents the equality constraints defining the final state, i.e. the
states where the system is steered to. The path constraints are defined by the inequal￾ity constraints with g(x(t), u(t)) ∈ Rq .
3.3.2 Static Optimization
In static optimization, the optimization variables are characterized by a finite number
of optimization variables. Within static optimization, numerous classifications exist.
They depend, for example, on the type of cost function and constraints (e.g. convex
vs. non-convex) and the domain of the optimization variables (e.g. discrete vs. con￾tinuous variables). In the following, an overview is presented on NLPs, Quadratic
Programs (QP), Linear Programs (LP), Integer Programs (IP), and Mixed-Integer
Programs (MIP).
Nonlinear Program (NLP)
For the NLP, the cost function, or at least one constraint, is nonlinear. In general, it can
be a non-convex optimization problem. NLPs occur in many practical applications,3.3 Classes of Optimization Problems 47
for example, in the production planning [11]. An NLP is defined by the following
optimization problem:
min
z ∈ Rn J (z)
s.t. h(z) = 0,
g(z) ≤ 0
(3.24)
Quadratic Program (QP)
For a QP, the cost function is quadratic and the constraint functions are affine. The
optimization problem is (strictly) convex if the Hessian H is positive semidefinite
(positive definite). A typical example for QPs is the parameter fitting via a least￾squares approach [5]. The QP is defined by
min
z ∈ Rn
1
2
zTH z + xTq
s.t. Az − b = 0,
C z − d ≤ 0
(3.25)
Linear Program (LP)
For a LP, the cost function and the constraint functions are both affine. The optimiza￾tion problem is always convex; as a consequence, every local solution is a global
solution. An example where LPs are used is the balancing of supply and demand
points, for instance, in transportation problems [10]. The LP is given in standard
form as
min
z ∈ Rn cT z
s.t. Az − b = 0,
z ≥ 0
(3.26)
Integer Program (IP)
Within an IP, the optimization variables are integer variables. The traveling salesman
problem, for instance, can be formulated as an IP [6]. An example for this class of
optimization problems is the Integer Nonlinear Program which can be formulated
as
min
za
J (za)
s.t. h(za) = 0,
g(za) ≤ 0,
za ∈ Zn
(3.27)
Mixed-Integer Program (MIP)
Within an MIP, some optimization variables are integer variables and others are
continuous. For instance, the energy management of hybrid vehicles can be posed as48 3 Mathematical Fundamentals of Optimization
a MIP, as it involves the discrete decision to turn on or off the combustion engine [1].
One example for this class of optimization problems is the Mixed-Integer Nonlinear
Program which is given as
min
za, zb
J (za, zb)
s.t. h(za, zb) = 0,
g(za, zb) ≤ 0,
za ∈ Zna ,
zb ∈ Rnb
(3.28)
3.4 Optimality Conditions for NLPs
In the following, an overview of optimality conditions for NLPs is provided. As
QPs and LPs can be seen as a subset of NLPs, the optimality conditions also hold
for these classes. These conditions offer the possibility to find the minimizers z∗ of
an optimization problem, and they allow to check if a certain candidate is indeed
a minimizer. In general, the conditions provide information about local optimality.
Conclusions about global optimality can only be drawn for special cases, such as
convex optimization problems. The functions involved, i.e. the cost function, the
equality constraints, and inequality constraints, are assumed to be twice continu￾ously differentiable functions. First, the unconstrained case is considered. It is then
extended by equality and inequality constraints.
3.4.1 Unconstrained Optimization Problems
For the unconstrained case, optimization problems are considered that can be put in
the following form:
min
z ∈ Rn J (z) (3.29)
The cost function J can either be a linear, a quadratic, or a general nonlinear function.
There exists a necessary condition for optimality which is also called the first-order
necessary condition (FONC). The FONC is given by the following equation:
∇ J (z∗) = 0 (3.30)
All points that satisfy this equation are called stationary points. Every local minimizer
fulfills the FONC. However, the reverse is not true: Not every stationary point is a
local minimizer. A stationary point can also be a maximum or a saddle point. Thus, the3.4 Optimality Conditions for NLPs 49
FONC can be used to determine all stationary points which are possible candidates
for minimizers.
For determining whether a candidate is indeed a local minimizer, the sufficient
condition can be checked. This is the so-called second-order sufficient condition
(SOSC) for optimality. The criteria are based on evaluation of the positive definiteness
of the Hessian of the cost function at the candidate point. The SOSC is fulfilled when
the Hessian matrix of the cost function is positive definite:
∇2 J (z∗)  0 (3.31)
If the candidate is a stationary point and the SOSC holds, the point z∗ is a strict local
minimizer. If the SOSC is not fulfilled, the stationary point could be a saddle point,
a maximum, or still a minimum, e.g. J (z) = z4,z ∈ R.
For a convex cost function J , the SOSC does not need to be checked: All stationary
points are local minima. Additionally, every local minimizer is directly also a global
minimizer. For strictly convex optimization problems, there exists either no stationary
point or exactly one, which is simultaneously the unique global minimizer.
Example 3.2 (Unconstrained NLP) A simple example for minimizing an uncon￾strained NLP by application of the optimality conditions is demonstrated. The cost
function J1 investigated is the well-known Rosenbrock function [8]. Figure 3.7 shows
a plot of the function J1.
J1(z1,z2) = (1 − z1)
2 + 100(z2 − z2
1)
2 (3.32)
The following unconstrained NLP defines the optimization task:
min
z ∈ R2
J1(z) (3.33)
Fig. 3.7 Visualizing the Rosenbrock function from Example 3.250 3 Mathematical Fundamentals of Optimization
The FONC can be set up for this optimization problem.
∇ J1(z1,z2) =
	
2z1 − 400z1(−z2
1 + z2) − 2
−200z2
1 + 200z2


= 0 (3.34)
The stationary point is given by z∗
1 = 1, z∗
2 = 1. The SOSC is evaluated to determine
if the point is indeed a local minimizer:
∇2 J1(z1,z2) =
	 1200z2
1 − 400z2 + 2 −400z1
−400z1 200 

∇2 J1(z∗
1,z∗
2) =
	 802 −400
−400 200
 (3.35)
The matrix ∇2 J1(z∗
1,z∗
2) has eigenvalues σ1 = 1002 and σ2 = 0.4, which shows that
it is positive definite and that therefore SOSC is fulfilled. Consequently, the stationary
point z∗ = [1, 1]
T calculated by the FONC is indeed a strict local minimizer.
3.4.2 Constrained Case: Equality Constraints
The optimality conditions for an equality-constrained problem is to be summarized
next. The optimization problem investigated is defined by the following equations:
min
z ∈ Rn J (z)
s.t. hi(z) = 0, i = 1,..., p
(3.36)
The cost function is defined by J (z) : Rn → R and the p equality constraints
are given by hi(z) : Rn → R. For setting up the optimality conditions, the so-called
Lagrange function (also known as Lagrangian) is introduced. The Lagrange function
for an equality-constrained problem is defined by L(z,λ) : Rn × Rp → R.
L(z,λ) = J (z) +p
i=1
λihi(z) (3.37)
= J (z) + λTh(z) (3.38)
The variables λ = [λ1, .., λp]
T are called Lagrange multipliers or dual variables.
To obtain a more compact form, the equality constraints are summarized to h(z) =
[h1(z), .., h p(z)]
T, with h(z) ∈ Rp. To each constraint hi(z), there exists an associ￾ated scalar value λi .3.4 Optimality Conditions for NLPs 51
First-Order Necessary Conditions
The FONC can be defined using the Lagrange function. For an equality-constrained
problem, the FONC are defined by the following equations:
∇L(z∗,λ∗
) =
	
∇zL(z∗,λ∗
)
∇λL(z∗,λ∗
)


=
⎡
⎣
∇ J (z∗) + p
i=1
λ∗
i ∇hi(z∗)
h(z∗)
⎤
⎦
=
	
∇ J (z∗) + ∇h(z∗)λ∗
h(z∗)


= 0
(3.39)
In these equations, ∇h(z) is defined to be ∇h(z) = 
∇h1(z), ∇h2(z), . . . , ∇h p(z)

,
the transpose of the Jacobian matrix of the equality-constrained function h(z). If the
point(z∗,λ∗
)fulfills ∇λL(z∗,λ∗
) = 0, it is said to be primal feasible. The FONC for
equality-constrained problems are defined by n + p equations for n + p unknown
variables.
Constraint Qualification
For constrained optimization problems, there might exist a minimum even though
the FONC conditions are not fulfilled. To ensure that the FONC conditions hold at a
local minimizer z∗, the problem has to fulfill some regularity conditions, the so-called
constraint qualifications. There exist several constraint qualifications, which differ
in their ease of application and also in how restrictive they are [8]. A commonly used
constraint qualification is the linear independence constraint qualification (LICQ).
This constraint qualification holds if ∇h(z∗) has full column rank, i.e. rank p. If
LICQ is fulfilled, each local minimizer (z∗,λ∗
) fulfills the FONC, i.e. it solves
∇L(z,λ) = 0. Additionally, there exist a unique set of Lagrange multipliers to ful￾fill ∇L(z,λ) = 0. If the constraints are not qualified at z∗, then ∇L(z∗,λ∗
) = 0 is
not a necessary condition for local optimality, which means that local minima might
exist which do not fulfill the FONC. An example is shown in Sect. 3.4.4 below.
Second-Order Sufficient Optimality Conditions
Let z∗ ∈ Rn be a point at which LICQ holds, together with the Lagrange multipliers
λ∗
, such that the FONC conditions are satisfied. In this case, z∗ ∈ Rn is a candidate
for a local minimizer. However, it can still be a point which is no local minimizer. The
SOSC can be applied to check if it is indeed a minimizer. For equality-constrained
problems, the SOSC are given by the following equations:
sT∇2
zzL(z∗,λ∗
)s > 0, ∀s = 0 (3.40)
∇hT(z∗) · s = 0 (3.41)
If the LICQ is fulfilled along with the FONC and the SOSC, the candidate z∗ is
a strict local minimizer. The variables s represent the constraint tangent space and
are defined by the dot product in (3.41) [8]. The constraint tangent space yields the
feasible directions of the optimization problem at the point (z∗,λ∗
). Thus, the SOSC52 3 Mathematical Fundamentals of Optimization
checks whether in all the feasible directions, a positive curvature is present. For the
unconstrained case, a positive curvature is demanded for all directions. If the SOSC
is not fulfilled, no conclusion about optimality can be drawn.
Note that for the constrained optimization problem, the Hessian matrix with
respect to z of the Lagrange function – and not of the cost function – is checked
for the SOSC. If the Hessian of the Lagrange function with respect to z at the can￾didate point is positive definite, i.e. ∇2
zzL(z∗,λ∗
)  0, the SOSC is automatically
fulfilled. For a convex optimization problem, the Hessian matrix ∇2
zzL(z∗,λ∗
)  0 is
inherently positive definite. Consequently, for a convex optimization problem, SOSC
does not need to be checked as the FONC is a necessary and sufficient condition.
Example 3.3 (Equality-constrained QP) The optimality conditions shall be applied
for an equality-constrained QP. The QP considers n optimization variables z ∈ Rn
and p equality constraints defined by the matrices A ∈ Rp×n, b ∈ Rp. The optimiza￾tion problem is defined by
min
z ∈ Rn
1
2
zTH z + zTq
s.t. Az − b = 0
(3.42)
First, the Lagrange function of the optimization problem is formulated as
L(z,λ) = 1
2
zTH z + zTq + λT(Az − b) (3.43)
The constraints have to fulfill the LICQ, in order for the FONC to be a necessary
condition for the local minimizers. For the given optimization problem, the matrix
A has to have full row rank, i.e. rank p, to fulfill the LICQ. The FONC are given by
the following equation:
∇L(z∗,λ∗
) = 0 (3.44)
The application of this condition to a QP results in a square system of linear equations.
This system is called the Karush–Kuhn–Tucker (KKT) system, with the KKT matrix
on the left-hand side. It consists of n + p linear equations with n + p unknown
variables, which even allows for an analytic solution.
	
H AT
A 0

 	 z∗
λ∗


=
	
−q
b


(3.45)
For finding the possible candidates, this system of linear equations has to be solved.
In order for a unique solution to exist, the KKT matrix has to be nonsingular. One
prerequisite for the existence of a unique solution is that LICQ is fulfilled. If LICQ
does not hold (because A does not have full row rank), the KKT matrix becomes
singular. If the Hessian matrix is positive definite, i.e. H  0, and LICQ holds, the
optimization problem is strictly convex, the KKT matrix becomes nonsingular, and3.4 Optimality Conditions for NLPs 53
a unique solution exists [8]. Actually, even in the case that a positive curvature exists
in the constraint tangent space and LICQ is fulfilled, a unique solution exists.
Example 3.4 (Constrained optimization of a QP by substitution) A numerical exam￾ple for the application of optimality conditions on an optimization problem including
equality constraints is investigated. The cost function is given by J2.
J2(z) = z2
1 + z2
2 + z2
3 + z1z3 − 4z2 (3.46)
For the optimization task, one equality constraint is considered.
min
z ∈ R3
J2(z)
s.t. z3 − 2 = 0
(3.47)
Obviously, this implies that z∗
3 = 2. This can be substituted into the cost function
J2 which yields another unconstrained minimization problem named J˜
2, with z˜ =
[z1,z2]
T.
J˜
2(z˜) = z2
1 + z2
2 + 2z1 − 4z2 + 4 (3.48)
The FONC yields the candidate z˜
∗ for the cost function J˜
2.
z˜
∗ = 
−1 2T (3.49)
For checking the SOSC, the Hessian of J˜
2(z˜) can be calculated as
∇2 J˜
2(z˜) =
	
2 0
0 2

(3.50)
The Hessian of J˜
2(z˜) is a positive definite and constant matrix. Therefore, the opti￾mization problem is strictly convex and the candidate is a unique global minimizer.
Together with z3 = 2, the result is z∗ = 
−122T
.
Example 3.5 (Constrained optimization of a QP using the Lagrange function) The
problem of minimizing J2 as shown in Example 3.4 can also be solved by means of
the Lagrange function. The Lagrange function for this problem is defined by L(z, λ):
L(z, λ) = J2(z) + λ(z3 − 2) (3.51)
For the simple equality constraint, the LICQ is fulfilled. To obtain possible candidates,
the FONC is evaluated.54 3 Mathematical Fundamentals of Optimization
∇L(z, λ) =
	
∇zL(z, λ)
∇λL(z, λ)


=
⎡
⎢
⎢
⎣
2z1 + z3
2z2 − 4
2z3 + z1 + λ
z3 − 2
⎤
⎥
⎥
⎦ = 0 (3.52)
⇒ z∗ = 
−122T , λ∗ = −3 (3.53)
By evaluation of the FONC, the candidate z∗ = [−122]
T can be found. For checking
if the candidate is indeed a local minimizer, the Hessian matrix of the cost function
is evaluated.
∇2 J2(z) =
⎡
⎣
201
0 20
1 02
⎤
⎦  0 (3.54)
The cost function J2 is a strictly convex function and the equality constraint defines
a convex feasible set, such that the optimization problem is actually a convex opti￾mization problem. As a result, the FONC is also a sufficient condition. Consequently,
z∗ = [−122]
T is the unique global minimizer.
3.4.3 Constrained Case: Inequality and Equality Constraints
In the following, optimization problems with equality and inequality constraints are
treated. The optimization problem is defined by the cost function J (z) : Rn → R, the
p equality constraints are given by hi(z) : Rn → R, and the q inequality constraints
by gi(z) : Rn → R.
min
z ∈ Rn J (z)
s.t. hi(z) = 0, i = 1,..., p,
gi(z) ≤ 0, i = 1,..., q
(3.55)
First-Order Necessary Condition
The FONC can be set up using the Lagrange function. When equality and inequality
constraints are present, it is given by L(z,λ, μ) : Rn × Rp × Rq → R.
L(z,λ, μ) = J (z) +p
i=1
λihi(z) +
q
i=1
μigi(z) (3.56)
= J (z) + λTh(z) + μTg(z) (3.57)
The Lagrange multipliers are given by the vectors [λ1,..., λp]
T = λ ∈ Rp and by
[μ1,..., μq ]
T = μ ∈ Rq . The equality constraints are summarized to be
h(z) = 
h1(z), h2(z), . . . , h p(z)
T and the inequality constraints to be g(z) =3.4 Optimality Conditions for NLPs 55

g1(z), g2(z), . . . , gq (z)
T
. Each scalar value λi is associated with the equality con￾straint hi(z) and each scalar value μi is associated with the inequality constraint
gi(z).
For constrained optimization problems, the FONC are named after their inventors,
KKT conditions. A point (z∗,λ∗
, μ∗) that satisfies the KKT conditions and LICQ is
also called a KKT point. The KKT conditions for a constrained problem are given
by the following equations:
∇zL (z∗,λ∗
, μ∗) = 0 Stationarity (3.58)

hi(z∗) = 0, ∀i = 1,..., p
gi(z∗) ≤ 0, ∀i = 1,..., q
Primal Feasibility (3.59)
μ∗
i ≥ 0, ∀i = 1,..., q Dual Feasibility (3.60)
μ∗
i gi(z∗) = 0, ∀i = 1,..., q Complementary Slackness (3.61)
The expression ∇zL(z∗,λ∗
, μ∗) can be calculated by
∇zL(z∗,λ∗
, μ∗) = ∇ J (z∗) +p
i=1
λ∗
i ∇hi(z∗) +
q
i=1
μ∗
i ∇gi(z∗) (3.62)
= ∇ J (z∗) + ∇h(z∗)λ∗ + ∇g(z∗)μ∗ (3.63)
By inclusion of the inequality constraints in the optimization problem, additional
conditions have to be fulfilled. The condition μ∗ ≥ 0 prohibits a reduction of the cost
function toward the infeasible directions of the inequality constraints. A graphical
example will be shown in Sect. 3.4.4 below. The gradients of the equality constraints
∇hi(z∗) can point in any direction, which is why λ∗ can be negative as well.
The condition (3.61) is called the complementary slackness condition. It is an
elegant way to formulate that one of three scenarios is present:
1. The inequality constraint i is strictly active with gi(z∗) = 0 and μ∗
i > 0.
2. The inequality constraint i is inactive with gi(z∗) < 0 and the associated Lagrange
multiplier has to be μ∗
i = 0.
3. The inequality constraint i is weakly active with gi(z∗) = 0 and μ∗
i = 0.
In the case of an optimization problem with solely equality constraints, the FONC
leads to a system of n + p equations with n + p unknowns. Usually, this system
of equations can be solved very effectively. Sometimes, it is even possible to find
an analytic solution for this system of equations, as shown in Example 3.3 for the
equality-constrained QP. The KKT conditions for inequality-constrained optimiza￾tion problems generate a system of equations and inequalities. As a consequence, an
analytic solution is even for simple systems not possible. Instead, numerical solution
techniques are necessary. The solution manifold resulting from the KKT conditions
is non-smooth which renders the problem challenging even for numerical solution
techniques. Consequently, in general, optimization problems with inequality con￾straints are harder to solve than purely equality-constrained optimization problems.56 3 Mathematical Fundamentals of Optimization
Constraint Qualification
Analogous to the equality constrained case, a regularity condition has to be fulfilled
to ensure that a local minimizer z∗ fulfills the KKT conditions. The LICQ for an
optimization problem with equality and inequality constraints requires that the gra￾dients of both the strictly and weakly active inequality constraints and of all equality
constraints are linearly independent. This is done by stacking all equality and active
inequality constraints together. For this purpose, the active set A(z) of the optimiza￾tion problem is defined as the sum of the indices of the inequality constraints i for
which gi(z) = 0 holds.
A(z) = {i ∈ {1,..., q} | gi(z) = 0} (3.64)
The stacked active inequality constraints are denoted by gA(z). Now, the gradient of
all active constraints can be computed. To fulfill LICQ, this matrix has to have full
column rank.
rank 
∇h(z), ∇gA(z))
= p + |A| (3.65)
Suppose that z∗ is a local minimizer of the constrained optimization problem and
LICQ is satisfied. Then there is a unique Lagrange multiplier vector 
λ∗
, μ∗
T such
that the KKT conditions hold at (z∗,λ∗
, μ∗). A graphical interpretation of LICQ
will be shown in Sect. 3.4.4 below.
Second-Order Sufficient Optimality Conditions
If LICQ holds and the KKT conditions are fulfilled at a point z∗, the point z∗ can still
be a point which is not a local minimizer. For checking if the candidate z∗ is indeed
a local minimizer, the SOSC can be examined which, together with LICQ and the
KKT conditions, is a sufficient condition for optimality. Let z∗ ∈ Rn be a point at
which LICQ holds, together with the Lagrange multipliers λ∗
, μ∗ such that the KKT
conditions are satisfied. The additional fulfillment of SOSC ensures that z∗ is a local
minimizer. The SOSC checks if the curvature is positive in all feasible directions:
sT∇2
zzL(z∗,λ∗
, μ∗)s > 0, ∀s = 0 (3.66)
∇hT
i (z∗) · s = 0, ∀i = 1,..., p (3.67)
∇gT
i (z∗) · s = 0, ∀i ∈ A(z∗),for μ∗
i > 0 (3.68)
∇gT
i (z∗) · s ≤ 0, ∀i ∈ A(z∗),for μ∗
i = 0 (3.69)
The feasible directions s are given by the dot products in (3.67)–(3.69). For the
inequality constraints, a distinction of cases has to be made. If the inequality con￾straint is strictly active, i.e. μ∗
i > 0, the feasible direction is given by the constraint
tangent space as in the case of equality constraints. However, if the inequality con￾straint is weakly active μ∗
i = 0, the entire half-space, defined by (3.69), is a feasible
direction.3.4 Optimality Conditions for NLPs 57
If the Hessian of the Lagrange function with respect to zz is positive definite at
the point z∗,λ∗
, μ∗, the SOSC is automatically fulfilled. If a convex optimization
problem is given, the FONC and the fulfillment of LICQ are necessary and sufficient
conditions, such that SOSC does not need to be checked.
3.4.4 Graphical Interpretation
In the following, the KKT conditions and the LICQ condition are interpreted in a
graphical way.
Graphical Interpretation of KKT Conditions for Equality Constraints
Both plots in Fig. 3.8 show the iso-contour lines of a cost function with two
optimization variables z1,z2, along with an affine equality constraint of the form
h(z) = Az − b = 0. According to the FONC, ∇ J and ∇h are parallel at the mini￾mizer z∗. If these are parallel, there is no feasible direction in which a decrease in
the cost function is possible while satisfying the constraints. The left-hand plot of
Fig. 3.8 shows additionally a point zα as a counterexample where the FONC is not
fulfilled. At the point zα, the two gradients ∇ J and ∇h are not parallel. Consequently,
there is a direction pα in which it is possible to decrease the cost function while the
constraint is still fulfilled. For an equality constraint, the Lagrange multiplier λ∗ can
have a positive or a negative sign. The sign is always such that the weighted sum
of the gradients of the cost function and of the constraints equal to 0; see (3.39). In
the left-hand plot, the Lagrange multiplier λ∗ has a positive sign. As an alternative
example, the right-hand plot shows a case where the Lagrange multiplier λ∗ has a
negative sign.
Fig. 3.8 Graphical interpretation of KKT conditions for equality constraints58 3 Mathematical Fundamentals of Optimization
In general, the single Lagrange multipliers λ∗
i can be interpreted as a sensitivity.
High absolute values of λ∗
i mean that if the constraint is relaxed by a small amount,
the cost can be decreased by a high value [3].
Graphical Interpretation of KKT Conditions for Inequality Constraints
Figure 3.9 shows the iso-contour lines of a cost function with the two optimization
variables z1,z2. One affine inequality constraint of the form g(z) = Az − b ≤ 0 is
considered. In the left graph, the unconstrained minimizer lies within the feasible set,
such that it is also the constrained minimizer. In this case, the inequality constraint
is inactive. At the point zα, the gradients of the cost function ∇ J (z∗) and of the
constraint ∇g(z∗) point in the same direction. According to (3.58), the sum of the
two gradients would result in 0 for μα ≤ 0. For inequality constraints, the feasible
region is restricted to only one direction. For negative values of μ, there exists a
direction where the inequality constraints are fulfilled and the cost can be decreased.
This is the reason why zα is no local minimizer. For an actual minimizer, the inequality
μ∗ ≥ 0 has to hold. The right-hand graph of Fig. 3.9 shows an example of an active
inequality constraint. In this case, the inequality μ∗ > 0 holds, such that the KKT
conditions are fulfilled.
Linear Independence Constraint Qualification
The LICQ poses a regularity condition for the optimization problem. For LICQ to
hold, all active constraints need to be linearly independent. In this case, the KKT
conditions as given in (3.58)–(3.61) are necessary conditions for the minimizer. If
they are not fulfilled, there might exist a minimizer where the FONC is not satis￾fied. Figure 3.10 shows an example of the LICQ not being fulfilled. A cost function
with the two optimization variables z1,z2 is present, along with one inequality con￾straint g(z) ≤ 0 and one equality constraint h(z) = 0. There exists a minimum of this
optimization problem at z∗. Although it is a minimizer, the KKT conditions are not
Fig. 3.9 Graphical interpretation of KKT conditions for inequality constraints3.4 Optimality Conditions for NLPs 59
Fig. 3.10 Graphical interpretation of the LICQ
fulfilled at this point z∗. The LICQ is not fulfilled as the gradients of h(z) and g(z) are
parallel. As a consequence, they do not span a basis to represent the gradient ∇ J (z∗).
Consequently, the stationarity condition −∇ J (z∗) = λ∗∇h(z∗) + μ∗∇g(z∗) cannot
be fulfilled for any choice of λ∗, μ∗. As the LICQ is not fulfilled, the KKT conditions
do not pose a necessary condition for the minimizer.
References
1. R. Beck, A. Bollig, D. Abel, Comparison of two real-time predictive strategies for the optimal
energy management of a hybrid electric vehicle. Oil & Gas Science and Technology-Revue de
l’IFP 62(4), 635–643 (2007)
2. J.T. Betts, Practical methods for optimal control and estimation using nonlinear programming
(SIAM, 2010)
3. S. Boyd, L. Vandenberghe, Convex optimization (Cambridge University Press, 2004)
4. P.N. Kolm, R. Tütüncü, F.J. Fabozzi, 60 years of portfolio optimization: practical challenges
and current trends. European Journal of Operational Research 234(2), 356–371 (2014)
5. L. Ljung, System identification (Wiley, 1999)
6. R. Matai, S. Singh, and M. L. Mittal, “Traveling salesman problem: an overview of applica￾tions, formulations, and solution approaches,” in: Traveling Salesman Problem, Theory and
Applications, IntechOpen, 2010
7. O. Nelles, Nonlinear system identification: from classical approaches to neural networks and
fuzzy models (Springer, 2013)
8. J. Nocedal, S.J. Wright, Numerical optimization (Springer, 2006)
9. M. Salazar, M. Tsao, I. Aguiar, M. Schiffer, and M. Pavone, “A congestion-aware routing
scheme for autonomous mobility-on-demand systems,” European Control Conference, 2019
10. D. Solow, “Linear and nonlinear programming,” in: Encyclopedia of Computer Science and
Engineering, Wiley, 2007
11. W. L. Winston, “Operations research: applications and algorithms,” Thomson/Brooks/Cole,
2004Part I
Model Predictive ControlChapter 4
Linear Model Predictive Control
Abstract In the most basic and common linear model predictive control (LMPC)
formulation, a deterministic linear model is used for a prediction of the system states
along with a quadratic cost function and linear constraints. This chapter presents
an overview of various aspects of LMPC. First, the unconstrained LMPC will be
explained, including the solution of the optimization problem and the resulting con￾trol structure. Based on these results, the extension of the optimization problem by
constraints is investigated. The constraints can apply for the actuated values or the
system states, for instance. Two different ways to formulate the optimization problem
are shown, namely the sparse and the dense formulations. It is shown that a quadratic
program (QP) results for a constrained LMPC, which can be solved very efficiently.
Additionally, the MPC scheme for linear time-variant (LTV) systems, called LTV
MPC, is investigated. For the LTV MPC, a QP has to be solved in each time step.
This is of particular interest, because with LTV MPC already appropriate control
results can be achieved for slightly nonlinear systems. To show applications of the
methods presented, the chapter concludes with numerical examples.
4.1 Linear Model Representation
A linear model is used for the prediction of the system states within LMPC. There
are various possibilities to represent a linear model. The most common approach in
LMPC is the use of a discrete-time state-space model.
The use of the state-space representation in LMPC offers several advantages
compared to the other linear model representations. Multiple-input multiple-output
(MIMO) systems can very naturally be handled and calculated. As the system states
are explicitly given, the consideration of system states, e.g. for constraint handling
is straightforward. Additionally, the use of a state observer provides the possibility
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_4
6364 4 Linear Model Predictive Control
to incorporate additional information for the calculation of the system states, e.g. the
covariance of the noise or the structure of the disturbance [16].
Besides the use of the state-space representation, the LMPC can also be based on
other model representations [12]. Alternatives are the Generalized Predictive Control
(GPC) which is an LMPC using discrete-time transfer functions. Another concept is
the Dynamic Matrix Control (DMC) which is based on a discrete-time pulse-sequence
model. Usually, limitations have to be considered for these alternative concepts, such
as the restriction of DMC to stable plants.
In the following, the state-space model representation is introduced. First, an
overview of the discrete-time state-space representation is given in Sect. 4.1.1. The
discrete-time state-space representation can directly be used within the LMPC. Some￾times, instead of a discrete-time model, a continuous-time model is present. This is
especially the case when the system model is governed by first principles. As dis￾cussed in Sect. 3.3 above, the consideration of a continuous-time model leads to an
optimal control problem with an infinite number of optimization variables. Unfortu￾nately, such a program cannot be solved easily, especially when additional constraints
are considered. There are two possibilities to deal with a continuous-time model. The
most common approach is to discretize the continuous-time linear model and then
use the discretized model within the LMPC implementation. An overview of the
discretization of continuous-time models is given in Sect. 4.1.2. An alternative way
to deal with a continuous-time model within LMPC is the approximation of the tra￾jectory of actuated values by a parametrized function. One exemplary approach is
described in [13].
4.1.1 Discrete-Time State-Space Model for Linear Systems
A discrete-time state-space model is represented by the following equations.
x(k + 1) = Ax(k) + Bu(k)
y(k) = C x(k) + Du(k) (4.1)
The system states are represented by x ∈ Rn, the actuated values by u ∈ Rl
, and the
output values by y ∈ Rm. Thus, the matrices have the dimensions A ∈ Rn×n, B ∈
Rn×l
, C ∈ Rm×n, and D ∈ Rm×l
. Without loss of generality, this book considers
systems without feedthrough, i.e. D = 0. This is reasonable for technical systems as
they do not contain feedthrough. The state-space representation can also be visualized
with the so-called functional diagram; see Fig. 4.1.4.1 Linear Model Representation 65
Fig. 4.1 Visualization of the state-space model by its functional diagram
4.1.2 Discretization of Linear Continuous-Time State-Space
Models
A continuous-time representation with state-space models is given by (4.2).
x˙(t) = Ax(t) + Bu(t)
y(t) = C x(t) + Du(t) (4.2)
In the following, the discretization of the continuous-time model is revisited. The
discretized representation of the continuous-time model is denoted as
x(k + 1) = AD x(k) + BD u(k)
y(k) = C D x(k) + DD u(k) (4.3)
The values k, k + 1,... denote the discrete-time grid at the time instances t, t +
Ts, t + 2Ts,... with Ts being the sampling time. When it is clear from the context
that the system under consideration is a discrete-time system, the subscript D will
usually be omitted. One way to discretize the continuous-time model is the use of
the Euler discretization. The Euler approximation uses a constant derivative during
the sampling time Ts:
x˙(t) = x(t + Ts) − x(t)
Ts
(4.4)
As a consequence, the discrete-time model is represented by
x(k + 1) = x(k) + Ts x˙(k) (4.5)
The following system matrices result for the state-space representation:66 4 Linear Model Predictive Control
AD = I + Ts A
BD = Ts B
C D = C
DD = D
(4.6)
An alternative way to discretize the continuous-time model is the exact discretization.
The discrete-time model calculates the same values for the states and outputs at the
discrete-time grid as the continuous-time model as long as the actuated values u
are constant during each sampling interval, i.e. zero-order hold. The discretization
results from an analytic solution with the transition matrix [2].
x(t) = eA(t−t0)
x(t0) +
 t
t0
eA(t−τ )Bu(τ )dτ (4.7)
With
t0 = kTs,
t = (k + 1)Ts,
u(τ ) = u(k) = const. ∀ kTs ≤ τ<(k + 1)Ts
the equation can be transformed to
x(k + 1) = eATs

AD
x(k) +
 (k+1)Ts
kTs
eA(Ts−τ 
)
Bdτ 
   BD
u(k) (4.8)
The corresponding system matrix AD can be expressed as a series:
AD = eATs = I +
ATs
1!    Euler disc.
+
A2T 2
s
2! +··· (4.9)
If A is invertible, BD can be calculated by the following series expansion:
BD = A−1 
eATs − I

B = ITs
1!
B
   Euler disc.
+
AT 2
s
2!
B +··· (4.10)
The matrices C D and DD remain unchanged, similar to the Euler approximation.
C D = C
DD = D. (4.11)4.2 Cost Function for Linear MPC 67
4.2 Cost Function for Linear MPC
For MPC, the goals of the control task are mapped into a suitable optimization
problem consisting of a cost function and constraints. In the following, the most
conventional and basic structure of a cost function is discussed. For the standard
reference tracking problem, two different goals have to be considered. The primary
goal is that the controlled values should track the reference trajectory over the course
of the prediction horizon as accurately as possible. At the same time, any change of
actuated values should be penalized for several reasons. The change of actuated values
is denoted by Δu(k) = u(k) − u(k − 1). The penalization is needed for appropriate
disturbance rejection. If a change of actuation was not penalized, there would be a
strong change of actuated values for every arising disturbance. Based on classical
control theory, an inspection of the sensitivity function reveals that there is a trade-off
between the disturbance rejection and the reference tracking properties. The actuated
values should also not be used with high dynamics for reasons of protection of the
actuator. For instance, applying high dynamics to a valve reduces its lifetime. The
penalization of a change of actuated values will help to ensure that the optimization
problem is strictly convex as is to be shown below in Sect. 4.3.1. In order to set up the
cost function, some notations are introduced in Fig. 4.2 and are listed in Table 4.1.
The cost function penalizes the deviation between the reference values during the
prediction horizon r(·|k) and the predicted values of the output y(·|k). The current
measurement data is represented by y(k) and x(k), while the first predicted state
and output are denoted by y(k + 1|k) and x(k + 1|k). To account for the dead-time
Fig. 4.2 Notation used for LMPC68 4 Linear Model Predictive Control
Table 4.1 Nomenclature of LMPC
a(k + i|k) Prediction of values a at time instance k + i at the current
time step k
a(·|k) Total trajectory of predicted values a in the horizon
considered based on the current time step k
N1 Lower prediction horizon
N2 Upper prediction horizon
Nu Control horizon
TD, the lower prediction horizon N1 is introduced. As the actuated values do not
have an influence on the output before the time point k + TD + 1, it is advantageous
to not consider these time points in the optimization in order to reduce the size of
the problem and thus also the computation time required. For a system without any
dead-time, N1 = 1 is chosen, else N1 = 1 + TD. The prediction is computed over a
restricted prediction horizon from N1,..., N2. When linear systems are considered,
it is very often sufficient to account for a control horizon Nu that is smaller than the
prediction horizon. The horizon Nu directly determines the number of optimization
variables. As a consequence, the horizon is very critical for calculation times, and
engineers are advised to choose it as low as possible. The actuated values u are held
constant beyond the control horizon Nu for the prediction of the system states and
outputs.
For the penalization of the two terms, namely the predicted change of the actu￾ated values Δu(·|k) and the predicted control error y(·|k) − r(·|k), a suitable norm
is needed. The most common choice is to quantify the penalization by a squared
weighted 2-norm. The general squared weighted 2-norm of the vector s ∈ Rn with
the weighting matrix A ∈ Rn×n is given by (4.12).
||s||2
A := sT As, s ∈ Rn, A ∈ Rn×n (4.12)
The main reason for this choice is that the optimization problem results in a QP, as is
to be shown below, which can be solved efficiently. Moreover, for small changes in
the optimization problem, e.g. due to disturbances, the minimizer, i.e. the actuated
values, also change in a smooth manner. Additionally, large deviations lead to higher
costs. An alternative is the use of the 1-norm in the cost function, which leads to a
linear program (LP). The general 1-norm of the vector s ∈ Rn is given by (4.13).
||s||1 := 	n
i=1
|si| (4.13)
In a few specific applications, the LP is a more “natural” way to describe the control
goals; see [11] for an example. In general, the drawback is that for an LP, the mini￾mizer always lies on an intersection of the linear constraints. As a consequence, for4.2 Cost Function for Linear MPC 69
small changes, e.g. due to a disturbance, the minimizer and thus the actuated values
change in a non-smooth manner which is often not desired in practical applications.
Using the squared weighted 2-norm, the entire cost function can be set up in a
matrix representation:
J =




























⎡
⎢
⎣
y(k + N1|k)
.
.
.
y(k + N2|k)
⎤
⎥
⎦ −
⎡
⎢
⎣
r(k + N1|k)
.
.
.
r(k + N2|k)
⎤
⎥
⎦




























2
Q
+




























⎡
⎢
⎣
Δu(k|k)
.
.
.
Δu(k + Nu − 1|k)
⎤
⎥
⎦




























2
R
(4.14)
The weighting factors are given by Q and R.
Q =
⎡
⎢
⎢
⎢
⎣
QN1 0 ··· 0
0 QN1+1 ··· 0
.
.
. .
.
. ...
.
.
.
0 0 ··· QN2
⎤
⎥
⎥
⎥
⎦
R =
⎡
⎢
⎢
⎢
⎣
R0 0 ··· 0
0 R1 ··· 0
.
.
. .
.
. ...
.
.
.
0 0 ··· RNu−1
⎤
⎥
⎥
⎥
⎦ .
(4.15)
4.3 Unconstrained Linear MPC
The cost function resulting for the unconstrained LMPC investigated can be summa￾rized in a compact form:
J = 	
N2
i=N1
|| y(k + i|k) − r(k + i|k)||2
Qi +
N
	u−1
i=0
||Δu(k + i|k)||2
Ri (4.16)
In the following, the solution of this optimization problem is described. It is detailed
that the resulting optimization problem can actually be solved analytically. Based on
the solution, it can even be shown that a linear state-feedback controller results for
an unconstrained LMPC.
4.3.1 Analytic Solution of the Optimization Problem
In order to derive the solution of the optimization problem, the linear model is incor￾porated into the optimization problem. Within the optimization problem, the change
of actuated values over the horizon Δu(·|k) are chosen as optimization variables.70 4 Linear Model Predictive Control
Thus, the sequence of actuated values is reformulated to
u(k|k) = u(k − 1) + Δu(k|k)
u(k + 1|k) = u(k|k) + Δu(k + 1|k)
= u(k − 1) + Δu(k|k) + Δu(k + 1|k)
.
.
.
u(k + Nu − 1|k) = u(k + Nu − 2|k) + Δu(k + Nu − 1|k)
u(k + Nu|k) = u(k + Nu − 1|k)
u(k + Nu + 1|k) = u(k + Nu − 1|k)
.
.
.
u(k + N2 − 1|k) = u(k + Nu − 1|k)
(4.17)
The control sequence takes into account that the actuated values are set constant after
the control horizon which corresponds to Δu(k + i|k) = 0,i = Nu,..., N2 − 1.
This definition of the sequence of actuated values allows to reformulate the general
system equations:
x(k + 1|k) = Ax(k) + Bu(k − 1) + BΔu(k|k)
y(k + 1|k) = C(Ax(k) + Bu(k − 1) + BΔu(k|k)) (4.18)
The initial system states, obtained by measurement or estimation, are denoted by
x(k). The last actuated values applied are given by u(k − 1). Both x(k) and u(k − 1)
cannot be adjusted. The variables Δu(·|k) are adjustable and serve as degrees of
freedom for the optimization. From here on and for the duration of this derivation, the
optimization variables are underlined as a visual aid where necessary. The prediction
of the system states x(·|k) can be calculated in dependence of the optimization
variables:
x(k + 1|k) = Ax(k) + Bu(k − 1) + BΔu(k|k)
x(k + 2|k) = Ax(k + 1|k) + Bu(k|k) + BΔu(k + 1|k)
x(k + 3|k) = Ax(k + 2|k) + Bu(k + 1|k) + BΔu(k + 2|k)
.
.
.
x(k + Nu |k) = Ax(k + Nu − 1|k) + Bu(k + Nu − 2|k) + BΔu(k + Nu − 1|k)
⇒ x(k + j|k) = Aj
x(k) +	
j
i=1

Ai−1Bu(k − 1)

+ 	
j−1
m=0
⎛
⎝	
j−m
i=1

Ai−1B

Δu(k + m|k)
⎞
⎠
(4.19)4.3 Unconstrained Linear MPC 71
After the control horizon,
x(k + Nu + 1|k) = Ax(k + Nu|k) + Bu(k + Nu − 1|k) +
=0 as u is const. after Nu steps   
BΔu(k + Nu|k)
.
.
.
x(k + N2|k) = Ax(k + N2 − 1|k) + Bu(k + Nu − 1|k) + BΔu(k + Nu|k)    =0 as u is const. after Nu steps
(4.20)
All equations are substituted such that only the initial values x(k), u(k − 1), and the
optimization variables Δu(·|k) remain.
x(·|k) =
⎡
⎢
⎢
⎢
⎣
x(k + N1|k)
x(k + N1 + 1|k)
.
.
.
x(k + N2|k)
⎤
⎥
⎥
⎥
⎦ =
⎡
⎢
⎢
⎢
⎣
AN1
AN1+1
.
.
.
AN2
⎤
⎥
⎥
⎥
⎦
  
=: Θ ∈
Rn·(N2−N1+1)×n
x(k) +
⎡
⎢
⎢
⎢
⎢
⎣
N1
i=1 Ai−1B
N1+1
i=1 Ai−1B
.
.
. N2
i=1 Ai−1B
⎤
⎥
⎥
⎥
⎥
⎦
  
=: Π ∈
Rn·(N2−N1+1)×l
u(k − 1)
+
⎡
⎢
⎢
⎢
⎣
Λ(N1) Λ(N1 − 1) ··· Λ(N1 − Nu + 1)
Λ(N1 + 1) Λ(N1) ··· Λ(N1 − Nu + 2)
.
.
. .
.
. ... .
.
.
Λ(N2) Λ(N2 − 1) ··· Λ(N2 − Nu + 1)
⎤
⎥
⎥
⎥
⎦
  
=: Υ ∈
Rn·(N2−N1+1)×l·Nu
⎡
⎢
⎢
⎢
⎣
Δu(k|k)
Δu(k + 1|k)
.
.
.
Δu(k + Nu − 1|k)
⎤
⎥
⎥
⎥
⎦
  
= Δu(·|k)
(4.21)
with Rn×l  Λ(i) =
i
j=1 Aj−1B, i ≥ 1
0, i < 1 (4.22)
The prediction of the system outputs is given by the simple relation:
y(k + i|k) = C x(k + i|k) (4.23)
The prediction of the system states and outputs over the entire horizon can be
rewritten in a compact matrix representation:
x(·|k) = Θx(k) + Πu(k − 1) + Υ Δu(·|k)
y(·|k) = Γ x(·|k)
with Γ = diag(C,..., C) ∈ Rm·(N2−N1+1)×n·(N2−N1+1)
(4.24)
Some new variables are introduced that are helpful for interpretation. The free
response f is the vector of the output prediction for the case that the actuated values
are kept constant over the entire prediction horizon, i.e. Δu(·|k) = 0.
f(·|k) = Γ

Θx(k) + Πu(k − 1)
 (4.25)72 4 Linear Model Predictive Control
The free error e(·|k) is the resulting predicted error for the constant actuated values
Δu(·|k) = 0, with r(·|k) being the reference.
e(·|k) = r(·|k) − f(·|k) (4.26)
Hence, the controller has to compensate for the free error by an adjustment of the
optimization variables Δu(·|k). As a linear system model is considered, the overall
predicted output y(·|k) results from a superposition:
y(·|k) = f(·|k) + Γ Υ Δu(·|k) (4.27)
The cost function can be reformulated using the defined variables:
J = || y(·|k) − r(·|k)||2
Q + ||Δu(·|k)||2
R
= ||Γ Υ Δu(·|k) − e(·|k)||2
Q + ||Δu(·|k)||2
R (4.28)
=

Δu(·|k)
TΥ TΓ T − eT(·|k)

Q

Γ Υ Δu(·|k) − e(·|k)

+ Δu(·|k)
TRΔu(·|k)
= Δu(·|k)
T 
Υ TΓ T QΓ Υ + R

Δu(·|k) − 2Δu(·|k)
TΥ TΓ T Qe(·|k) + e(·|k)
T Qe(·|k)
The cost function can be rearranged to show the quadratic function in the optimization
variables Δu(·|k).
J =2
1
2
Δu(·|k)
T

Υ TΓ T QΓ Υ + R

Δu(·|k) Quadratic term
+ Δu(·|k)
T

−Υ TΓ T Qe(·|k)

Linear term
+
1
2
e(·|k)
T Qe(·|k)

Constant term
The constant term is invariant with respect to Δu(·|k). As it has no influence on
the minimizer, i.e. the actuated values, it thus can be neglected for the purpose of
optimization. Only the non-constant terms have to be considered for the optimization.
The same holds for the constant factor two, it can also be neglected.
min
Δu(·|k)
1
2
Δu(·|k)
T

Υ TΓ T QΓ Υ + R

   =:H
Δu(·|k) + Δu(·|k)
T

−Υ TΓ T Qe(·|k)

   =:q
(4.29)
This optimization problem can be solved by the means discussed in Sect. 3.4.1 above.
The first-order necessary condition (FONC) for the minimizer Δu∗(·|k) can be set
up as
∇Δu(·|k) J (Δu∗(·|k)) = 0 (4.30)4.3 Unconstrained Linear MPC 73
The calculation of the gradient yields
∇Δu(·|k) J (Δu∗(·|k)) = HΔu∗(·|k) + q (4.31)
Thus, the FONC can be reformulated as in the following equation:
HΔu∗(·|k) + q = 0 (4.32)
One way to solve this equation forΔu∗(·|k)is given by the use of the matrix inversion.
For real-time implementations, it is computationally more efficient and robust to solve
this equation as a least-squares problem. Still, the matrix inversion is denoted for
ease of notation:
Δu∗(·|k) = H−1q
=

Υ TΓ T QΓ Υ + R
−1
   Matrix Inversion
Υ TΓ T Qe(·|k) (4.33)
In order to check if the candidate Δu∗(·|k) is a minimum, the second-order sufficient
condition (SOSC) can be used, as follows:
∇2
Δu(·|k) J (Δu∗(·|k))  0 (4.34)
The Hessian of J needs to be positive definite. The SOSC can be denoted by the
following condition for the minimizer:
Υ TΓ T QΓ Υ + R  0 (4.35)
The positive definiteness of the Hessian can be ensured by an appropriate choice of
the weighting matrices Q and R. The conditions on Q and R are as follows:
R  0 and Q  0 (4.36)
With a positive-definite Hessian, the QP also becomes strictly convex. As a conse￾quence, if there exists a minimizer it is the unique global minimizer.
4.3.2 Resulting Control Law
Thus far, the text showed that there exists an analytic solution for the optimiza￾tion problem arising in an unconstrained LMPC. The optimal trajectory over the
entire control horizon can be calculated with (4.33). According to the receding￾horizon principle, only the first values of Δu∗(·|k), i.e. Δu∗(k|k) are applied to the
plant, while the remaining values are discarded. The current actuated values u(k) are74 4 Linear Model Predictive Control
given by
Δu∗(k|k) = K mpc e(·|k)
K mpc = 
I 0 ··· 0


Υ TΓ T QΓ Υ + R
−1
Υ TΓ T Q

u(k) = u(k − 1) + Δu∗(k|k)
(4.37)
The matrix K mpc is linear time-invariant. It depends solely on the linear system model
and the weighting matrices. The free error e(·|k) depends linearly on the current state
measurement x(k) and the reference values r(·|k). Thus, the error typically changes
at every time step. As a consequence, the unconstrained LMPC is actually a linear
state-feedback controller.
As a linear controller results for an LMPC, classical properties such as pole-zero
locations of the closed-loop system can be calculated. It is expectable that a linear
state-feedback controller results when the concept of an unconstrained LMPC is
compared to the linear quadratic regulator (LQR). The concepts are very similar, with
the only difference being that the LQR conducts an infinite-horizon prediction rather
than a finite-time prediction for an unconstrained LMPC. With the LQR concept, a
linear time-invariant state-feedback controller results, as well [5].
4.4 Constrained Linear MPC
One of the major advantages of MPC is the ability it offers to systematically consider
constraints. The constraints can arise on the actuated values u(·|k), the change of
the actuated values Δu(·|k), on the system states x(·|k), and on the system output
y(·|k). Examples are the maximum opening position of a valve, the maximum rate
of change of an electric motor, the maximum allowed temperature for safety reasons,
and the prevention of overshoots on an output due to performance demands. In the
following, two approaches are demonstrated to set up the optimization problem for
a constrained LMPC. The first approach is the so-called dense formulation where
the model equations are substituted into the cost function as done already in the
unconstrained case. The second approach is the so-called sparse formulation where
the model equations are added to the optimization problem as equality constraints.
4.4.1 Dense Formulation
The goal is to formulate the constrained LMPC problem in such a way that it results
in the typical constrained QP formulation. The general structure of a constrained QP
with optimization variables z ∈ Rl is given by (4.38). To define p equality constraints,
the matrices Aeq ∈ Rp×l
, beq ∈ Rp are used. Additionally, q inequality constraints
are defined by Ain ∈ Rq×l
, bin ∈ Rq .4.4 Constrained Linear MPC 75
min
z ∈ Rl
1
2
zTH z + zTq
s.t. Aeq z − beq = 0, Aeq ∈ Rp×l
, beq ∈ Rp,
Ain z − bin ≤ 0, Ain ∈ Rq×l
, bin ∈ Rq
(4.38)
For a constrained, LMPC the same cost function (4.28) is considered as in the case
of an unconstrained LMPC. Within the dense formulation, the model equations for
the system dynamics are substituted into the cost function. The entire cost function is
formulated in terms of the optimization variables, i.e. Δu(·|k). In the case of a con￾strained LMPC, the constraints on the system output y(·|k), the system states x(·|k),
the change of the actuated values Δu(·|k), and the absolute actuated values u(·|k)
are added. The transformation to the standard QP formulation, as shown in (4.38), is
conducted exemplarily for box constraints, i.e. inequality-constrained variables with
upper and lower bounds.
min
Δu(·|k)
1
2
Δu(·|k)
T
=:H    
Υ TΓ T QΓ Υ + R

Δu(·|k) + Δu(·|k)
T
=:q    
−Υ TΓ T Qe(·|k)

s.t. Δumin ≤ Δu(·|k) ≤ Δumax ,
umin ≤ u(·|k) ≤ umax ,
xmin ≤ x(·|k) ≤ xmax ,
ymin ≤ y(·|k) ≤ ymax
(4.39)
In order to formulate the LMPC optimization problem in a QP setting, all constraints
have to be expressed in dependence of the optimization variables Δu(·|k). Using the
prediction matrices derived above, the lower and upper bounds have to be reformu￾lated to match the standard form given by AinΔu(·|k) ≤ bin.
First, the transformation of the bounds on Δu(·|k) is discussed.
Δumin ≤ Δu(·|k) ≤ Δumax (4.40)
Expressing lower and upper bounds as less than or equal to inequalities yields
Δu(k|k) ≤ Δumax
.
.
.
Δu(k + Nu − 1|k) ≤ Δumax
−Δu(k|k) ≤ −Δumin
.
.
.
−Δu(k + Nu − 1|k) ≤ −Δumin
(4.41)76 4 Linear Model Predictive Control
The changes on the actuated values have to be considered until the time point Nu − 1,
as once the control horizon is reached, the actuated values are fixed. This can be
rewritten in a matrix-vector representation:
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
I 0 ... 0
0 I ... 0
.
.
. .
.
. ... .
.
.
0 0 ... I
−I 0 ... 0
0 −I ... 0
.
.
. .
.
. ... .
.
.
0 0 ... −I
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
  
=: Ain, Δu ∈ R2l Nu×l Nu
⎡
⎢
⎣
Δu(k|k)
.
.
.
Δu(k + Nu − 1|k)
⎤
⎥
⎦
  
= Δu(·|k)
≤
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
Δumax
.
.
.
Δumax
−Δumin
.
.
.
−Δumin
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
  
=: bin, Δu ∈ R2l Nu
(4.42)
Analogously, the bounds on u(·|k) are attained by the following less than or equal
to inequalities.
u(k|k) ≤ umax
.
.
.
u(k + Nu − 1|k) ≤ umax
−u(k|k) ≤ −umin
.
.
.
−u(k + Nu − 1|k) ≤ −umin
(4.43)
Expressed in terms of the optimization variables Δu(·|k), these bounds may be
rewritten as the following inequalities:
u(k − 1) + Δu(k|k) ≤ umax
u(k − 1) + Δu(k|k) + Δu(k + 1|k) ≤ umax
.
.
.
u(k − 1) + Δu(k|k) +···+ Δu(k + Nu − 1|k) ≤ umax
−u(k − 1) − Δu(k|k) ≤ −umin
−u(k + 1) − Δu(k|k) − Δu(k + 1|k) ≤ −umin
.
.
.
−u(k − 1) − Δu(k|k) −···− Δu(k + Nu − 1|k) ≤ −umin
(4.44)
The corresponding matrix-vector notation reads as follows:4.4 Constrained Linear MPC 77
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
I 0 ... 0
.
.
. .
.
. ... .
.
.
I I ... I
−I 0 ... 0
.
.
. .
.
. ... .
.
.
−I −I ... −I
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
  
=: Ain, u ∈ R2l Nu×l Nu
Δu(·|k) ≤
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
umax
.
.
.
umax
−umin
.
.
.
−umin
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
−
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
u(k − 1)
.
.
.
u(k − 1)
−u(k − 1)
.
.
.
−u(k − 1)
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
  
=: bin, u ∈ R2l Nu
(4.45)
The bounds on the system states x(·|k) are defined by the following equations:
x(k + N1|k) ≤ xmax
.
.
.
x(k + N2|k) ≤ xmax
−x(k + N1|k) ≤ −xmin
.
.
.
−x(k + N2|k) ≤ −xmin
(4.46)
As shown in Sect. 4.3.1, the system states predicted can be expressed by Θ, Π,Υ in
accordance to the definitions in (4.21).
x(·|k) = Θx(k) + Πu(k − 1) + Υ Δu(·|k) (4.47)
As a consequence, the inequalities can be expressed by the following matrix-vector
notation:
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
x(k + N1|k)
.
.
.
x(k + N2|k)
−x(k + N1|k)
.
.
.
−x(k + N2|k)
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
=
 Θ
−Θ

x(k) +
 Π
−Π

u(k − 1) +
 Υ
−Υ

⎡
⎢
⎢
⎣
Δu(k|k)
.
.
.
Δu(k + Nu − 1|k)
⎤
⎥
⎥
⎦
≤
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
xmax
.
.
.
xmax
−xmin
.
.
.
−xmin
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
(4.48)
The transformation into standard form yields
 Υ
−Υ

  
=: Ain, x
∈ R2n(N2−N1+1)×l Nu
Δu(·|k) ≤
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
xmax
.
.
.
xmax
−xmin
.
.
.
−xmin
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
−
 Θ
−Θ

x(k) −
 Π
−Π

u(k − 1)
  
=: bin,x ∈ R2n(N2−N1+1)
(4.49)78 4 Linear Model Predictive Control
In a similar fashion, the constraints on the outputs y(·|k) can be defined as
 Γ Υ
−Γ Υ 
  
=: Ain,y ∈
R2 m(N2−N1+1)×l Nu
Δu(·|k) ≤
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
ymax
.
.
.
ymax
−ymin
.
.
.
−ymin
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
−
 Γ Θ
−Γ Θ
x(k) −
 Γ Π
−Γ Π
u(k − 1)
  
=: bin,y ∈ R2 m(N2−N1+1)
(4.50)
By these transformations, the constrained LMPC can be brought into the standard
QP formulation. The transformations were presented here for inequalities which are
given as box constraints. However, the general framework allows more flexibility.
For instance, the linear combination of various variables or equality constraints can
be considered as well. The transformations have to be conducted in a similar way. A
more general formulation of a constrained LMPC with a dense formulation is given
by the following optimization problem, where the system dynamics are incorporated
into the cost function via the prediction matrices:
min
Δu(·|k)
1
2
Δu(·|k)
THΔu(·|k) + Δu(·|k)
Tq
s.t. AeqΔu(·|k) − beq = 0, Aeq ∈ Rp×l Nu , beq ∈ Rp,
AinΔu(·|k) − bin ≤ 0, Ain ∈ Rq×l Nu , bin ∈ Rq
(4.51)
with Δu(·|k) =
⎡
⎢
⎣
Δu(k|k)
.
.
.
Δu(k + Nu − 1|k)
⎤
⎥
⎦
∈ Rl Nu .
4.4.2 Sparse Formulation
An alternative approach for setting up the QP problem for the constrained LMPC
is given by the sparse problem formulation. In this approach, the state equations of
the linear model are directly incorporated as equality constraints in the optimiza￾tion problem. As optimization variables, the system states x(·|k) and the actuated
values u(·|k) are used additionally to the changes of the actuated values Δu(·|k).
Compared to the dense formulation, the sparse problem formulation changes the
size of the optimization problem as well as the sparsity pattern of the resulting4.4 Constrained Linear MPC 79
matrices of the QP problem. The sparsity pattern shows where non-zero entries are
structurally possible in the matrix. The resulting sparsity pattern allows to apply
computationally efficient methods. As a result, the sparse formulation is compu￾tationally faster than the dense formulation in specific cases, as detailed below in
Sect. 4.4.3. The optimization problem can be formulated as follows:
min x(·|k), u(·|k), Δu(·|k)







 Γ x(·|k)    =y(·|k)
−r(·|k)








2
Q + ||Δu(·|k)||2
R
s.t.
x(k + i + 1|k) = Ax(k + i|k) + Bu(k + i|k) i = 0,..., N2 − 1
x(k|k) = x(k)
u(k + i|k) = u(k − 1 + i|k) + Δu(k + i|k) i = 1,..., Nu − 1
u(k + i|k) = u(k + Nu − 1) i = Nu,..., N2 − 1
u(k|k) = u(k − 1) + Δu(k|k)
⎫
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎬
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎭
system dynamics,
Δumin ≤ Δu(·|k) ≤ Δumax
umin ≤ u(·|k) ≤ umax
xmin ≤ x(·|k) ≤ xmax
ymin ≤ Γ x(·|k) ≤ ymax
⎫
⎪⎪⎪⎪⎪⎪⎬
⎪⎪⎪⎪⎪⎪⎭
constraints
(4.52)
For simplicity, the resulting matrices will be derived for the confined case of Nu =
N2 = N and N1 = 1. Additionally, inequalities on u(·|k), Δu(·|k), x(·|k), and y(·|k)
are considered, which are given as box constraints. Other cases can be handled
analogously. All optimization variables are merged in the vector ξ (·|k).
ξ (·|k) :=
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
Δu(k|k)
u(k|k)
x(k + 1|k)
.
.
.
Δu(k + N − 1|k)
u(k + N − 1|k)
x(k + N|k)
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
∈ R(2l+n)N (4.53)
The linear system model has to be considered in the optimization problem as a linear
equality constraint in dependence of ξ (·|k) by the form Aeq,sξ (·|k) = beq,s. This
results in a banded sparse structure.80 4 Linear Model Predictive Control
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
I −I 0 0
0 B −I 0
0 I 0 I −I 0
0 A 0 B −I 0
0 I 0 I −I 0
0 A 0 B −I 0
... ... ... ... ... ...
0 I 0 I −I 0
0 0 A 0 B −I
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
  
=: Aeq,s ∈ R(l+n)N×(2l+n)N
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
Δu(k|k)
u(k|k)
x(k + 1|k)
Δu(k + 1|k)
u(k + 1|k)
x(k + 2|k)
.
.
.
Δu(k + N − 1|k)
u(k + N − 1|k)
x(k + N|k)
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
=
⎡
⎢
⎢
⎢
⎢
⎢
⎣
0
−A
0
.
.
.
0
⎤
⎥
⎥
⎥
⎥
⎥
⎦
x(k) +
⎡
⎢
⎢
⎢
⎢
⎢
⎣
−I
0
0
.
.
.
0
⎤
⎥
⎥
⎥
⎥
⎥
⎦
u(k − 1)
  
=: beq,s ∈ R(l+n)N
(4.54)
The cost function and the box constraints on the system states, outputs, and actuated
values have to be formulated in dependence of ξ (·|k) as well. This can be done by
appropriate linear mappings, as denoted for the example of x(·|k).
x(·|k) =
⎡
⎢
⎣
x(k + 1|k)
.
.
.
x(k + N|k)
⎤
⎥
⎦ =
⎡
⎢
⎢
⎢
⎣
0 0 I 0 ··· 0
0 ··· 0 0 I 0 ··· 0
.
.
. ... ... ... .
.
.
0 ··· 0 0 I
⎤
⎥
⎥
⎥
⎦
  
=: I x
ξ (·|k)
(4.55)
With linear mappings such as I x , the cost function can be expressed in terms of
ξ (·|k). The Hessian matrix Hs again has a sparse structure. Additionally, qs does
not depend any more on the initial states, instead it only depends on the reference
trajectory r(·|k).
J = (Γ x(·|k) − r(·|k))
T Q (Γ x(·|k) − r(·|k)) + Δu(·|k)
TRΔu(·|k)
= (Γ I x ξ (·|k) − r(·|k))
T Q (Γ I x ξ (·|k) − r(·|k)) + (IΔuξ (·|k))
T R (IΔuξ (·|k))
= ξ (·|k)
T(IT
x Γ T QΓ I x + IT
Δu R IΔu)   
=: Hs ∈ R(2l+n)N×(2l+n)N
ξ (·|k) − 2ξ (·|k)
T (IT
x Γ T Qr(·|k))   
=: −qs ∈ R(2l+n)N
+ const.
(4.56)4.4 Constrained Linear MPC 81
The inequality constraints are similarly expressed by these linear mappings. All
matrices generated for the handling of the constraints have sparse structures and
reordering the rows results in sparse banded structures. The constraints on the state
equations, for example, can be formulated by the following matrix-vector notation.
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
0 0 I 0 ··· 0
0 ··· 0 0 I 0 ··· 0
.
.
. ... ... ... .
.
.
0 ··· 0 0 I
0 0 −I 0 ··· 0
0 ··· 0 0 −I 0 ··· 0
.
.
. ... ... ... .
.
.
0 ··· 0 0 −I
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
  
=: Ain,s,x ∈ R2nN×(2l+n)N
ξ (·|k) ≤
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
xmax
.
.
.
xmax
−xmin
.
.
.
−xmin
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
  
=: bin,s,x
∈ R2nN
(4.57)
The transformations mentioned above allow the constrained LMPC to be brought
into the standard QP formulation. To sum up, the constrained LMPC results overall
in the following QP. Other cases, such as Nu < N2 or the constraint of a linear com￾bination of various variables, can be handled analogously.
min
ξ (·|k)
1
2
ξ (·|k)
THsξ (·|k) + ξ (·|k)
Tqs + const.
s.t. Aeq,sξ (·|k) = beq,s, ⎡
⎢
⎢
⎣
Ain,s,Δu
Ain,s,u
Ain,s,x
Ain,s,y
⎤
⎥
⎥
⎦
  
=: Ain,s
ξ (·|k) ≤
⎡
⎢
⎢
⎣
bin,s,Δu
bin,s,u
bin,s,x
bin,s,y
⎤
⎥
⎥
⎦
  
=: bin
(4.58)
with ξ (·|k) =
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
Δu(k|k)
u(k|k)
x(k + 1|k)
.
.
.
Δu(k + N − 1|k)
u(k + N − 1|k)
x(k + N|k)
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎥
⎦
(4.59)82 4 Linear Model Predictive Control
The matrices have the following dimensions:
Aeq,s ∈ R(l+n)N×(2l+n)N
beq,s ∈ R(l+n)N
Ain,s ∈ R(m+n+2l)2N×(2l+n)N
bin,s ∈ R(m+n+2l)2N
ξ (·|k) ∈ R(2l+n)N .
(4.60)
4.4.3 Comparison of Dense and Sparse Formulations
The resulting structures of the dense and the sparse formulations are summarized in
Fig. 4.3. As the dense formulation has fewer optimization variables, fewer constraints,
and as the resulting matrices are much smaller, one would expect the computation
time to be lower than that of the sparse formulation. However, due to its dense struc￾ture, the decomposition of the matrices is numerically expensive. As a consequence,
solving the QP in the sparse formulation might still be faster. The sparse banded
structure of the Hessian, the equality, and the inequality constraint matrices result in
an overall sparse structure of the resulting QP. This can be exploited by using tailored
numerics of the QP solver, e.g. for an efficient lower–upper (LU) decomposition [15].
Additionally, the sparse formulation results in a better conditioning for unstable sys￾tems, as the matrix potentiation is avoided. In the case of a linear time-variant MPC,
see Sect. 4.5, the constraints and system matrices change at each time step. With the
sparse structure, less time is needed for constructing the necessary matrices.
Fig. 4.3 Comparison of the sparse and dense formulations for LMPC4.4 Constrained Linear MPC 83
In general, the dense formulation is especially advantageous for smaller problem
sizes and for cases in which Nu << N2. For the sparse formulation, drawbacks arise
for the case where Nu << N2 as many additional optimization variables have to
be added that are not adjustable. The sparse formulation is better suited for larger
problems and in the case of Nu ≈ N2.
4.4.4 Control Structure of Constrained Linear MPC
From the discussions thus far, it is possible to conclude that a linear control law
results if only equality constraints are considered within the constrained LMPC.
The equality constraints can be substituted in the cost function, such that a new
unconstrained optimization problem with reduced degrees of freedom results. A
linear controller also results if there is one fixed active set that is not changing,
containing equality constraints and some active inequalities. As soon as inequality
constraints are present that are both active and inactive such that the active set is
changing, a nonlinear control behavior results. Thus, although the control concept
is called “Linear MPC”, it is actually a nonlinear controller. In the following, some
remarks are added concerning the structure of the resulting nonlinear controller.
The constrained LMPC is represented by the following QP. For the sake of simplic￾ity, no equality constraints are considered and the dense formulation is investigated.
Additionally, a positive-definite Hessian matrix is assumed.
min
Δu
1
2
ΔuTHΔu+ΔuTq with H  0
s.t. Ain,dΔu − bin,d ≤ 0
(4.61)
To detail the structure of the resulting controller, it is assumed for now that a certain set
of inequalities are active. The active set is given by A. As soon as the inequalities are
known, the optimization problem turns into one with only equality constraints. The
inactive inequalities can be neglected for the calculation of the minimizer. The active
inequality constraints are represented by AAΔu − bA = 0. The new optimization
problem can be presented as follows:
min
Δu
1
2
ΔuTHΔu+ΔuTq with H  0
s.t. AAΔu − bA = 0
(4.62)
If the Hessian is positive definite, i.e. H  0 and linear independence constraint
qualification (LICQ) holds, there exists a unique minimizer Δu∗ that can be directly
calculated by the optimality conditions. The corresponding FONC are given by a
system of linear equations with ∇L = 0.84 4 Linear Model Predictive Control
∇L(Δu∗, λ∗) =
 H AA
T
AA 0
 Δu∗
λ∗

−

−q
bA

= 0 (4.63)
The minimizer Δu∗ can be calculated as follows:

Δu∗
λ∗

=
 H AA
T
AA 0
−1 
−q
bA

(4.64)
Based on the definitions of the various matrices, the matrix H turns out to be constant,
i.e. H = const., as it depends solely on the weighting matrices and on the system
matrices. For a fixed active set, the matrix AA = const. is constant. However, with
a different active set, the matrix changes. For a fixed active set, the following holds:
 H AA
T
AA 0
−1
= const. (4.65)
The vector q is a linear function of x(k), u(k − 1), and the reference values r(·|k).
If state or output constraints are considered, the vector bA is an affine function of
x(k) and u(k − 1). The structure of the resulting optimal actuated values u∗(·|k)
thus becomes
u∗(·|k) = Kx x(k) + Kuu(k − 1) + Kr r(k) + Kc (4.66)
The matrices Kx , Ku, Kr, and Kc are all constant. Hence, for a fixed active set, an
affine control law in the feedback variable x(k) results. When the active set changes,
the parameters of Kx , Ku, Kr, and Kc change. Thus, for each possible set of active
constraints, a corresponding affine control law can be computed. Overall, a piecewise
affine (PWA) control law results. The authors of [3] demonstrate that the resulting
PWA control law is continuous in the output u∗(·|k). All in all, the control structure
for a constrained LMPC results to be nonlinear and more specifically, a PWA control
law results.
The fact that a PWA control law results is exploited for the use within explicit
MPC [1]. For explicit MPC, this control law is precomputed offline using multi￾parametric programming. Subsequently, by evaluation of the function, the PWA
control law can be used online to calculate the optimal actuated values. However, it
is only feasible for small systems and low amounts of possible active set changes.
In the worst case, for an amount of q constraints, 2q different active sets can result.
Most engine MPC applications are too large for the use of explicit MPC. Instead,
the solution of the optimization problem is found by the use of numerical solution
methods. These allow the solution of the optimization problem to be found in an
iterative manner during the runtime of the process. An example of such a method is
described in the next section.4.4 Constrained Linear MPC 85
4.4.5 Numerical Solution of the Resulting Quadratic
Program
The above sections have shown that the LMPC with constraints leads to a QP that
is typically convex. A variety of approaches exist to solve a convex QP in a fast and
reliable manner [14]. A number of powerful numerical tools can be used to solve QPs,
even for demanding problems in real time. The possibility to efficiently solve QPs is
one of the reasons why LMPC is in widespread use, even in industrial applications.
Prominent approaches are the active set method, which is implemented, for exam￾ple, in qpOASES [8], the interior point (IP) method implemented, for example, in
FORCESPRO [7], and the gradient method implemented, for example, in FiOr￾dOs [10]. Some of the software tools originate from academic research, such as
qpOASES [8], and others are commercially available and professionally maintained,
such as FORCESPRO [7]. The algorithms differ in terms of properties such as their
convergence rate, numerical robustness, and capability to include an initial guess,
which is also called warm-starting. To show the fundamental idea behind one of these
techniques, the basic idea behind the IP method is briefly introduced.
For constrained LMPC in every time step, related QP problems are solved, i.e. they
have the same number of constraints and optimization variables. The instances differ,
as for example the initial state or the reference is changing. For such kinds of related
problems, IP methods show relatively constant computation times. Additionally, IP
methods are well suited for exploiting the sparsity pattern. Thus, it is advantageous
to use IP methods along with a sparse formulation for large problems. The dense
formulation is often used in combination with active set methods for small problems.
The convex QP investigated has the following form. For simplicity, a problem
with q inequality constraints is investigated. The additional handling of equality
constraints does not pose a challenge.
min
z
1
2
zTH z + zTq, with H  0
s.t. Ain z − bin ≤ 0
(4.67)
The Lagrange function of the convex QP is defined by L(z,μ).
L(z,μ) = 1
2
zTH z + zTq + μT(Ain z − bin) (4.68)
If z∗ is a minimizer of the constrained optimization problem and LICQ holds, then
the following conditions are satisfied:
∇z L(z∗,μ∗) = H z∗ + q + Ai n
Tμ∗ = 0
Ain z∗ − bin ≤ 0
μ∗ ≥ 0
μ∗T(Ain z∗ − bin) = 0
(4.69)86 4 Linear Model Predictive Control
As discussed in Sect. 3.4.3, the inequality constraints make the optimization task
demanding. They lead to the complementary slackness conditions which are non￾smooth. The idea behind the IP methods is to reformulate the optimization prob￾lem such that the inequality constraints are avoided. The inequality constraints are
replaced by an additional term in the cost function which penalizes any constraint
violation. For the penalty term, various functions can be used; a common choice is the
application of logarithmic functions. The addition of logarithmic barrier functions
yields a new unconstrained NLP. For unconstrained NLPs, many solution techniques
exist, such as the Newton’s method, which is to be described in Sect. 5.2. The aug￾mented cost function, with γ being a scalar positive value, is represented by the
following equations:
Jaug(z,γ) = J (z) +
1
γ
Jlog(z)
Jlog(z) = −	
q
i=1
log 
− (Ain,iz − bin,i)
 (4.70)
As the Hessian is supposed to be positive-definite H  0, the original cost function
J (z)is convex. The sum of two convex functions is a convex function again [6]. Thus,
the augmented cost function is a convex function also. Additionally, the augmented
cost function is smooth in its domain. The function Jlog yields costs of infinity as the
argument goes to zero. This occurs when the original limits described by the inequal￾ity constraints are approached. Therefore, the penalty term forces the optimization
variables to lie inside the feasible set. Indeed, every minimizer z∗
γ of the augmented
cost function z∗
γ = arg min Jaug(z,γ) satisfies all constraints. As the original cost
function is augmented by additional terms, the minimizer of the augmented cost
function z∗
γ differs from the minimizer of the original cost function z∗. However, in
the case of γ → ∞, the minimizer of the augmented cost function converges to the
solution of the original problem z∗
γ → z∗. The point z∗
0 = arg min Jlog(z) is called
the analytic center of constraints. The central path is defined as the trajectory given
by z∗
γ = arg min Jaug(z,γ) from the analytic center z∗
0 to the original minimizer z∗
with positive values of γ .
The numerical solution of the original problem can be calculated by following
the central path. First, an initial point inside the feasible set is needed. This point
serves as an initial guess for the unconstrained optimization of the augmented cost
function Jaug(z,γ) with a small value of γ . In every iteration, a different instance
of the augmented unconstrained optimization problem is then solved. The value of
γ is continuously increased in every iteration. The initial guess of every iteration is
the solution of the previous iterate. This procedure allows finding very efficiently
a minimizer of the augmented cost function, as a good initial guess is present. The
solutions of the iterations lie on the central path and the algorithm converges to
the original minimizer z∗. Among the various versions of IP methods that exist,
especially the primal-dual method is used for online solutions within MPC [17].4.5 Linear Time-Variant (LTV) Model Predictive Control 87
4.5 Linear Time-Variant (LTV) Model Predictive Control
In the following, LTV problems are investigated. A plant with LTV system dynamics
can be denoted by the following discrete-time representation:
x(k + 1) =Ak x(k) + Bku(k)
y(k) =Ck x(k) (4.71)
The time-variant system matrices Ak , Bk , Ck are valid for the sampling instant k.
For an analysis of MPC based on an LTV system, the prediction of the system is
considered. The optimization variables Δu are underlined.
x(k + 1|k) = Ak x(k) + Bku(k|k)
= Ak x(k) + Bku(k − 1) + BkΔu(k|k)
x(k + 2|k) = Ak+1 x(k + 1|k) + Bk+1u(k + 1|k)
= Ak+1

Ak x(k) + Bku(k − 1) + BkΔu(k|k)

+ (4.72)
Bk+1

u(k − 1) + Δu(k|k) + Δu(k + 1|k)

= Ak+1Ak x(k) +

Ak+1Bk + Bk+1

u(k − 1)+

Ak+1Bk + Bk+1

Δu(k|k) + Bk+1Δu(k + 1|k)
.
.
.
These equations can be summarized in matrix form as functions of the initial values
(x(k), u(k − 1)) and the optimization variables (Δu(·|k)):
x(·|k) =
⎡
⎢
⎢
⎢
⎣
x(k + N1|k)
x(k + N1 + 1|k)
.
.
.
x(k + N2|k)
⎤
⎥
⎥
⎥
⎦ =
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎣
#N1
p=1 Ak+N1−p
#N1+1
p=1 Ak+N1+1−p
.
.
.
#N2
p=1 Ak+N2−p
⎤
⎥
⎥
⎥
⎥
⎥
⎥
⎦
  
Θ ∈ Rn(N2−N1+1)×n
x(k) +
⎡
⎢
⎢
⎢
⎣
Λ(N1, 1)
Λ(N1 + 1, 1)
.
.
.
Λ(N2, 1)
⎤
⎥
⎥
⎥
⎦
  
Π ∈ Rn(N2−N1+1)×l
u(k − 1)
+
⎡
⎢
⎣
Λ(N1, 1) ... Λ(N1, Nu )
.
.
. ... .
.
.
Λ(N2, 1) ... Λ(N2, Nu )
⎤
⎥
⎦
  
Υ ∈ Rn(N2−N1+1)×l Nu
⎡
⎢
⎢
⎣
Δu(k|k)
Δu(k + 1|k)
...
Δu(k + Nu − 1|k)
⎤
⎥
⎥
⎦
  
Δu(·|k)
(4.73)
with Λ(i,r) being defined recursively as88 4 Linear Model Predictive Control
Rn×l  Λ(i,r) =
⎧
⎪⎨
⎪⎩
Ak+i−1Λ(i − 1,r) + Bk+i−1, i > r
Bk+i−1, i = r
0, i < r
(4.74)
The output equation is defined by
y(·|k) = Γ x(·|k) with Γ = diag(CN1 ,..., CN2 ) ∈ Rm(N2−N1+1)×n(N2−N1+1)
(4.75)
The findings from (4.73) to (4.75) show that the prediction still depends linearly on
x(k), u(k − 1) and Δu(·|k). Therefore, the same solution procedure as for the linear
time-invariant (LTI) case is applicable. The LTV MPC formulation thus results in a
QP of the same form as that of the LTI case. For the dense formulation, the QP is
defined by the following optimization problem:
min
Δu(·|k)
1
2
Δu(·|k)
THΔu(·|k) + Δu(·|k)
Tq + const.
s.t. Ain,dΔu(·|k) − bin,d ≤ 0, Ain,d ∈ Rq×l Nu , bin ∈ Rq
(4.76)
However, there exists one difference between the LTI and the LTV cases. The matrices
describing the system dynamics are changing in every time step for the LTV case.
As a result, the matrices H and q have to be recalculated in every time step, while
for the LTI case H and q are constant. Hence, even for the unconstrained LTV case,
a nonlinear control law results, since the matrix K mpc has to be recalculated in every
time step.
Why is the LTV MPC interesting at all? First of all, the original system model
might be described by an LTV system. Secondly, the LTV MPC can be used to
approximately take into account the nonlinear system behavior. The linearization of a
nonlinear system model x˙ = f(x, u) can be calculated by the Taylor series expansion
around the operating point (OP) given by xop, uop. The linearized continuous-time
state-space model at the current operating point has the following form:
x˙ = f(x, u) ≈ f(xop, uop) +
∂ f
∂ x








xop ,uop
  
=: A
(x − xop) +
∂ f
∂u








xop ,uop
  
=: B
(u − uop)
(4.77)
For a stationary operating point, the expression f(xop, uop) = 0 holds. Otherwise,
the non-stationary term has to be considered in the state prediction. The overall
approach is depicted in Fig. 4.4. The following steps are conducted:
1. Obtain a new measurement or estimation for x(k).
2. Build one linear model around the measured or estimated value x(k).
3. Use this model for an LTI prediction over the entire prediction horizon.
4. Repeat this procedure in every sampling step.4.5 Linear Time-Variant (LTV) Model Predictive Control 89
Fig. 4.4 LTV MPC by linearizations of current measured or estimated states
In each time step, one new linearized LTI state-space model results, which is used
within MPC for a prediction.
x(k + i|k) = Ak x(k + i − 1|k) + Bku(k + i − 1|k), ∀i = 1,..., N2 (4.78)
The LTV approach presented so far uses the linearized information around the current
measured or estimated system state x(k)for handling a nonlinear system. This results
in one QP which has to be solved in each time step. Compared to the LTI MPC
approach, the computational load is increased as the linearization has to be calculated
as well.
An alternative approach to handle a nonlinear system is to incorporate additionally
the information of the system around future states in the LTV model. For instance,
the optimal actuated values from the last time step u∗(·|k − 1) could be used along
with the recent measured or estimated state x(k) for a nonlinear simulation of the
system states xu∗ (·|k). Subsequently, linear system models can be derived around the
measured or estimated value x(k) and the predicted states xu∗ (·|k). A new state-space
model with time-varying matrices is governed in each time step for the prediction
within MPC. The approach is depicted in Fig. 4.5. The computational load for one
time step results from the nonlinear simulation for calculating the future states, the
determination of the linearized models for the various states and solving one QP.
However, there exist also other possibilities for incorporating the nonlinear infor￾mation of the system while having comparable computational loads. One example
is the so-called real-time iteration (RTI) scheme, where similarly one QP is solved
in each time step. It is introduced in Chap. 5. The RTI scheme offers various algo￾rithmic choices. For specific choices, the RTI scheme is the same as the LTV with
time-varying matrices. In general, due to the algorithmic flexibility, the RTI scheme
is usually superior to the LTV approach.90 4 Linear Model Predictive Control
Fig. 4.5 LTV MPC by linearization along current measured or estimated states and the predicted
states’ trajectory
The LTV MPC approach can also be used to handle time-variant constraints.
For example, non-convex feasible sets can be approximated by time-variant linear
constraints that define time-varying convex sets. An application example is described
in [4].
4.6 Numerical Examples for Linear MPC
In the following, some numerical examples are given to demonstrate the capabilities
of LMPC.
Example 4.1 (Unconstrained LMPC for unstable non-minimum phase system) This
example demonstrates that LMPC is able to handle complex system dynamics.
A plant model is used that is unstable and is a non-minimum phase system. The
continuous-time transfer function is given by G(s):
G(s) = s − 1.3
s2 + 1.1s − 2 (4.79)
The poles are located at π1 ≈ 0.97 and π2 ≈ −2.1, while the zero is set at ζ1 =
1.3. Due to the system characteristics present, the control with conventional linear4.6 Numerical Examples for Linear MPC 91
Fig. 4.6 Closed-loop control
result for an unconstrained
LMPC with sparse problem
formulation for Example 4.1
controllers is quite complex. With the use of an LMPC approach, it turns out to be
quite straightforward. A conventional cost function J is used.
J = 	
N2
i=N1
|| y(k + i|k) − r||2
Q +
N
	u−1
i=0
||Δu(k + i|k)||2
R (4.80)
The parameters used for the MPC are N1 = 1, N2 = Nu = 45, R = 10I, Q = I,
and the sampling time is chosen to be Ts = 1 s. A constant reference signal ofr = 1 is
used. As the system is unstable, the sparse formulation is used for the implementation
of the LMPC. Figure 4.6 shows that with this conventional cost function and without
detailed tuning of the weighting matrices, already very good closed-loop control
results can be achieved.
Example 4.2 (Comparing the dense and the sparse formulations) In this exam￾ple, the differences between the dense formulation as introduced in Sect. 4.4.1 and
the sparse formulation as introduced in Sect. 4.4.2 are demonstrated. For this pur￾pose, the system described in Example 4.1 is investigated again. In Example 4.1, the
closed-loop control was achieved by the use of the sparse formulation. It might seem
counter-intuitive to use the sparse formulation instead of the dense formulation, as
the optimization problem is blown up. This example demonstrates that there exist
certain settings where the sparse formulation is advantageous due to the numerical
differences arising. As mentioned in Sect. 4.4.2, the performance of the sparse for￾mulation is superior to that of the dense formulation for large problems and settings92 4 Linear Model Predictive Control
Fig. 4.7 Sparsity pattern of
the Hessian of the dense
MPC formulation
0 20 40
0
10
20
30
40
with Nu ≈ N2. The parameters chosen in the example are N1 = 1, N2 = Nu = 45
such that both criteria are fulfilled.
To illustrate the effect, the sparsity pattern of the Hessian of the cost function is
investigated. The dimension of the Hessian for the dense formulation of the opti￾mization problem is
Nu × Nu = 45 × 45 (4.81)
The dense character of the Hessian is shown in Fig. 4.7. All 2,025 entries of the
Hessian are structurally non-zero.
For the sparse formulation, the Hessian results have 32,400 entries. The dimen￾sions are
(2l Nu + nN2) × (2l Nu + nN2) = 180 × 180 (4.82)
The sparsity pattern in Fig. 4.8 shows that only 225 entries are non-zero. Additionally,
it is a so-called tridiagonal matrix, the 225 entries are located exclusively on the main,
super-, and sub-diagonals. In conclusion, the matrix for the Hessian of the sparse
formulation is much larger than that of the dense formulation, but nevertheless, much
fewer entries are structurally non-zero. If a solver is used that exploits the sparsity
pattern, advantages for the computation time can be realized.
The second advantage of the sparse formulation can be observed in terms of the
numerical conditioning of the resulting matrices, which is illustrated next. Exactly
the same plant model and MPC settings as those described in Example 4.1 are
investigated again. The only difference is that instead of the sparse formulation the
dense formulation is considered. Figure 4.9 shows the control result obtained with
the dense formulation.
The closed-loop system is unstable. In contrast, the sparse formulation resulted
in a stable closed-loop system, although all the settings were the same. For the dense
formulation, matrix potentiations are used for setting up the relevant matrices, such4.6 Numerical Examples for Linear MPC 93
Fig. 4.8 Sparsity pattern of
the Hessian of the sparse
MPC formulation
0 50 100 150
0
50
100
150
Fig. 4.9 Closed-loop control
result for unconstrained
LMPC (dense problem
formulation) – Example 4.2
-1
0
1
0 10 20 30
-1
0
1
as the Hessian. In the case of an unstable system, which is predicted over many
sampling steps, huge numbers result as entries in the matrix. Thus, small errors,
which may occur due to the restricted precision of digital computing, can lead to
big differences in the values of the matrix. As the sparse formulation does not use
matrix potentiations, it is less sensitive to these kinds of errors. In the worst case,
these propagated errors lead to an unstable closed-loop behavior, as given in this
example.94 4 Linear Model Predictive Control
Example 4.3 (Unconstrained LMPC with anticipatory action) The MPC algorithm
allows future reference values to be considered, as shown in this numerical exam￾ple for the unconstrained LMPC. The effect is demonstrated on the following sim￾ple example system. It is given by the continuous state-space model with matrices
A, B, C, and D.
A =

4.8 −4.8
5.1 −5.1

B =
 1
−1

C = 
0.04 0.04 D =0
(4.83)
A standard cost function J with the possibility to consider future reference values is
chosen.
J = 	
N2
i=N1
|| y(k + i|k) − r(k + i|k)||2
Q +
N
	u−1
i=0
||Δu(k + i|k)||2
R (4.84)
For the weighting matrices Q and R, the identity matrix is chosen. The horizons
are N1 = 1 (no dead-time is considered), N2 = Nu = 10, and the sampling time is
Ts = 0.2 s. For the reference, a step signal is applied.
Two different cases are investigated. In the first scenario, only the current reference
value is known. In each time step, the reference is assumed to be constant over the
entire prediction horizon r(k + i|k) = r(k|k) for i ∈ {N1,..., N2}. In the second
scenario, the entire reference trajectory is known to the controller in advance. In this
case, the MPC is able to anticipate the reference and act already in advance, such
that the reference is reached faster. The response of the system for both scenarios is
displayed in Fig. 4.10. For the anticipatory action, the actuated values are not only
shifted forward in time, instead an entirely different trajectory results.
Example 4.4 (Constrained LMPC) Example 4.3 is revisited. The system dynamics,
the cost function, and also its weighting are unchanged. However, this time, additional
constraints on the actuated values are considered. Specifically, the constraints are
given by umin = −0.2 and umax = 0.2. The resulting closed-loop step response is
shown in Fig. 4.11. The LMPC is able to systematically deal with the constraints on
the actuated values. A high-performance reference tracking can be achieved. The
resulting closed-loop controller is nonlinear due to the consideration of constraints.
Compared to conventional PID-based controllers, this performance can be achieved
without any additional measures such as anti-windup schemes.
Example 4.5 (Control of a nonlinear system with LMPC) In the following, a numer￾ical example is detailed which shows the ability of the LMPC algorithm to control a
nonlinear system. The plant model is based on the so-called Brusselator which was
formulated first in the 1950s by Prigogine and collaborators at the Universite Libre
de Bruxelles [9]. The Brusselator describes the chemical reactions from two educts
A, B to two products C, D with two intermediate species X1, X2. Specifically, four
different chemical reactions are considered.4.6 Numerical Examples for Linear MPC 95
0
0.5
1
1.5
0 5 10 15
-1
-0.5
0
0.5
1
Fig. 4.10 Influence of anticipatory action on closed-loop control for Example 4.3
0
0.5
1
1.5
0 5 10 15
-1
0
1
Fig. 4.11 Influence of constraints on actuated value on closed-loop control – Example 4.496 4 Linear Model Predictive Control
A k1
−→ X1
B + X1
k2
−→ X2 + C
2X1 + X2
k3
−→ 3X1
X1
k4
−→ D
The global reaction is given by:
A + B −→ C + D
The time trajectory of the intermediate species can be described by the following
ODEs:
x˙1 = k1a − k2bx1 + 3k3x1
2x2 − k4x1 (4.85)
x˙2 = k2bx1 − 3k3x 2
1 x2 (4.86)
The variables a, b, c, d, x1, and x2 denote the concentrations of the various species.
The constants k1,..., k4 are related to the reaction rates. The conventional Brussela￾tor assumes constant concentrations a, b. However, in order to allow for closed-loop
control, the system is modified in that the concentration a can be adjusted during
operation. Thus, it serves as actuated value u for closed-loop control. The concentra￾tion b is assumed constant, i.e. the species B is continuously fed into the system to
keep the concentration constant. The task of the closed-loop controller shall be the
reference-tracking of both intermediate species concentrations x1, x2. By using the
parameters k1 = 1, k2 = 2, k3 = 1, k4 = 4, and b = 2.475, the state-space system
becomes
x˙1 = −8.95x1 + 3x 2
1 x2 + u (4.87)
x˙2 = 4.95x1 − 3x 2
1 x2 (4.88)
The Brusselator is characterized by nonlinear dynamics and oscillatory behavior. A
distinct system property is the fact that the system enters a limit cycle for a constant
input of u = 1.7, for all initial conditions except of x0 = [0.425 3.882]
T. This point
is actually the only stationary point. Figure 4.12 depicts the system evolution in the
phase portrait for various initial conditions x0,1,..., x0,4. Clearly, the trajectories
x0,1,..., x0,3 converge to the limit cycle regardless of whether they start inside or
outside of it. The only trajectory that does not enter the limit cycle is the one starting
at the stationary point x0,4 = [0.425 3.882]
T. It remains stationary at this point.
Since the stationary point is unstable, a challenging control task is to force the
Brusselator to this point and then stabilize it there. For this task, the performance of4.6 Numerical Examples for Linear MPC 97
0123
0
1
2
3
4
5
Fig. 4.12 Phase portrait of the open-loop Brusselator for various initial conditions
the LMPC approach using a linearized model of the system is investigated. For the
optimization, the cost function J is used.
J = 	
N
i=1







x(k + i|k) − xref








2
Q + 	
N−1
i=0







u(k + i|k) − uref








2
R (4.89)
Within the cost function J , the deviation of the actuated values and the system states
to the references are penalized. The reference values are given by the stationary
point xref = [0.425 3.882]
T and uref = 1.7. The weighting matrices are chosen to
be Q = I and R = 1. The initial condition is set to x0 = [1 2]
T, the prediction and
control horizons to N = 50, and the lower control horizon to N1 = 1 as no dead-time
is considered. The sampling time is chosen to be Ts = 0.2s. Following constraints
on the actuated value, the change of actuated value and on the system states are
considered:
0 ≤ u(·|k) ≤ 5 and − 2 ≤ Δu(·|k) ≤ 2 (4.90)
0 ≤ x1(·|k) ≤ 2 and 0 ≤ x2(·|k) ≤ 5 (4.91)
Within LMPC, an LTI model is used. In order to derive this model, the nonlinear
model equation is linearized around a single operating point defined by xop, uop.
All predictions are performed using the resulting LTI model. The linearization is
conducted around the stationary point that is to be reached.98 4 Linear Model Predictive Control
xop =

0.425
3.882
and uop = 1.7 (4.92)
Using (4.77), the linearized continuous-time state-space model is obtained:
x˙(t) =
 0.950 0.542
−4.950 −0.542
x +

1
0

u (4.93)
With the poles of that system being at π1,2 = 0.204 ± 1.458i, the steady-state
point is an unstable equilibrium of the nonlinear system. Therefore, the sparse for￾mulation is used. An exact discretization with the sampling time Ts leads to the
following discrete-time state-space model:
x(k + 1) =
 1.151 0.111
−1.017 0.844
x(k) +
 0.216
−0.101
u(k) (4.94)
Figure 4.13 shows the closed-loop control results with LTI MPC. It depicts the
evolution of the state trajectories over time. Clearly, the LTI MPC is able to bring the
states to the steady-state point and stabilize them there. The system can be stabilized
0
0.5
1
2
3
4
0 2 4 6 8 10
0
1
2
3
Fig. 4.13 Closed-loop control result for Example 4.5: LTI MPC4.6 Numerical Examples for Linear MPC 99
0.4 0.6 0.8 1
2
2.5
3
3.5
4
Fig. 4.14 Closed-loop control result in the phase portrait for Example 4.5: LTI MPC
although it is nonlinear. The result shows that robustness is inherently present in
MPC. The state evolution is also visualized by the phase portrait in Fig. 4.14.
References
1. A. Alessio, A. Bemporad, A survey on explicit model predictive control, in Nonlinear Model
Predictive Control (Springer, Berlin, 2009), pp. 345–369
2. K.J. Aström, R.M. Murray, Feedback Systems: An Introduction for Scientists and Engineers
(Princeton University Press, Princeton, 2010)
3. A. Bemporad, M. Morari, V. Dua, E.N. Pistikopoulos, The explicit linear quadratic regulator
for constrained systems. Automatica 38(1), 3–20 (2002)
4. A. Bemporad, C. Rocchi, Decentralized linear time-varying model predictive control of a
formation of unmanned aerial vehicles, in IEEE Conference on Decision and Control (2011),
pp. 7488–7493
5. F. Borrelli, A. Bemporad, M. Morari, Predictive Control for Linear and Hybrid Systems (Cam￾bridge University Press, Cambridge, 2017)
6. S. Boyd, L. Vandenberghe, Convex Optimization (Cambridge University Press, Cambridge,
2004)
7. A. Domahidi, A.U. Zgraggen, M.N. Zeilinger, M. Morari, C.N. Jones, Efficient interior point
methods for multistage problems arising in receding horizon control, in IEEE Conference on
Decision and Control (2012), pp. 668–674100 4 Linear Model Predictive Control
8. H.J. Ferreau, C. Kirches, A. Potschka, H.G. Bock, M. Diehl, qpOASES: a parametric active-set
algorithm for quadratic programming. Math. Progr. Comput. 6(4), 327–363 (2014)
9. J.A. Gallas, Periodic oscillations of the forced brusselator. Mod. Phys. Lett. B 29, 1530018
(2015)
10. C.N. Jones, A. Domahidi, M. Morari, S. Richter, F. Ullmann, M. Zeilinger, Fast predictive
control: real-time computation and certification. IFAC Proc. Vol. 45(17), 94–98 (2012)
11. J. Ma, S.J. Qin, B. Li, T. Salsbury, Economic model predictive control for building energy
systems, in IEEE PES Innovative Smart Grid Technologies (2011)
12. J.M. Maciejowski, Predictive Control: with Constraints (Pearson Education, London, 2002)
13. M. Muehlebach, R. D’Andrea, Parametrized infinite-horizon model predictive control for linear
time-invariant systems with input and state constraints, inAmerican Control Conference (2016),
pp. 2669–2674
14. J. Nocedal, S.J. Wright, Numerical Optimization (Springer, Berlin, 2006)
15. W.H. Press, S.A. Teukolsky, W.T. Vetterling, B.P. Flannery, Numerical Recipes: The Art of
Scientific Computing (Cambridge University Press, Cambridge, 2007)
16. D. Simon, Optimal State Estimation: Kalman, H-infinity, and Nonlinear Approaches (Wiley,
New York, 2006)
17. Y. Wang, S. Boyd, Fast model predictive control using online optimization. IEEE Trans. Control
Syst. Technol. 18(2), 267–278 (2009)Chapter 5
Nonlinear Model Predictive Control
Abstract The nonlinear model predictive control (NMPC) approach allows more
challenging control problems to be handled than those dealt with by the linear model
predictive control (LMPC) method. For engine control problems, the consideration
of their nonlinear process behavior is particularly important as their treatment as a
linearized system is often not sufficient. In this chapter, the fundamentals of NMPC
are presented. A special focus is set on the real-time feasibility of the computation
algorithm, as this aspect poses a major challenge for engine control. The numerical
solution of the resulting nonlinear program (NLP) is discussed. As a suitable solu￾tion technique, the sequential quadratic programming (SQP) approach is explained.
Additionally, multiple shooting versus single shooting techniques are detailed, which
allows optimal control problems (OCP) to be discretized efficiently. Numerical exam￾ples are investigated to show the capabilities of the algorithms described.
5.1 Introduction to Nonlinear MPC
Most engine control tasks can be classified as reference tracking problems. Hence, the
MPC approaches are usually characterized by a quadratic cost function accounting
for deviations of the predicted states to the reference states. Additionally, affine
constraints on the actuated values and on the system states are considered. The
system model within LMPC is restricted to being a linear or a linearized model.
However, the use of a linear model is often insufficient for representing the system
behavior. In these cases, the NMPC approach allows for a better control performance
than the LMPC. The term NMPC is used typically when the resulting optimization
problem is neither a QP nor an LP. An NLP optimization problem results for MPC
when a nonlinear system model, nonlinear constraints or a non-convex cost function
is considered. For engine control tasks, the NMPC algorithm is especially used for
consideration of a nonlinear system model.
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_5
101102 5 Nonlinear Model Predictive Control
Typically, nonlinear models are present as continuous-time models, e.g. because
they are derived from physical modeling. The consideration of this continuous-time
nonlinear models in an optimization-based control algorithm results in an OCP. An
example of an OCP is depicted by the following optimization problem with cost
function Jocp.
Jocp(x(t), u(t)) = l f (x(t f )) +
 t f
t0
ls(x(t), u(t))dt (5.1)
The cost function Jocp in this example is subject to the system dynamics in (5.2b),
the initial state of the system at t = t0 in (5.2c), the equality constraints on the final
states in (5.2d), and the path constraints which are present as inequality constraints
in (5.2e).
min
x(t), u(t)
Jocp(x(t), u(t)) (5.2a)
s.t. x˙(t) = f(x(t), u(t), t), ∀t ∈ [t0, t f ], (5.2b)
x(t0) = x0, (5.2c)
h(x(t f )) = 0, (5.2d)
g(x(t), u(t)) ≤ 0, ∀t ∈ [t0, t f ] (5.2e)
Due to the infinite number of optimization variables, OCPs usually cannot be
solved in real time, especially when a nonlinear model is considered. Thus, the OCP
cannot be directly used for practical NMPC applications. However, in order to obtain
a tractable optimization problem, the OCP can be approximated by an NLP. The
transformation from the OCP to the NLP is conducted by a suitable discretization.
The process of the discretization is detailed in Sect. 5.3. An NLP also results if the
system model, cost function, and the constraints are directly given in discrete time.
For data-based modeling, usually a discrete-time system model results. The general
NLP is usually of the following form:
min
z ∈ Rn J (z)
s.t. h(z) = 0,
g(z) ≤ 0
(5.3)
The optimization variables are denoted by z ∈ Rn, while h defines the equality con￾straints and g the inequality constraints. A typical NMPC optimization problem for
engine control problems is presented in (5.4). To account for the reference tracking
problem, a quadratic cost function is used where the difference between predicted
states and reference is penalized along with the deviation of the actuated values
to the steady-state values. For nonlinear systems, characteristics such as superposi￾tion no longer exist. Thus, in contrast to LMPC, for NMPC no difference is made
between the horizons for control actuation and prediction of the states. While in
LMPC problems, the actuated values can be left constant after the control hori-5.1 Introduction to Nonlinear MPC 103
zon, in NMPC problems this approach is inappropriate, even for stable systems. To
account for the system dynamics, a time-discrete nonlinear system model of the form
x(k + 1) = f dis(x(k + i|k), u(k + i|k) is considered along with the initial states.
Additionally, box constraints on the actuated values and on the system states are
present in the optimization problem.
min x(·|k), u(·|k)
N
i=1
||x(k + i|k) − r(k)||2
Qi +
N
−1
i=0
||u(k + i|k) − uss(k)||2
Ri
s.t. x(k + i + 1|k) = f dis(x(k + i|k), u(k + i|k)), i = 0,..., N − 1,
x(k|k) = x(k),
umin ≤ u(k + i|k) ≤ umax , i = 0,..., N − 1,
xmin ≤ x(k + i|k) ≤ xmax , i = 1,..., N
(5.4)
One of the main challenges in applying NMPC for engine control is the calculation
of a suitable solution of the arising NLP in real time. Since in the case of engine
control problems, both the system dynamics and the constraint functions can be
modeled as continuously differentiable functions, gradient-based numerical methods
can be applied. There exist various gradient-based solution methods that allow for
the calculation of the minimizer within small timescales. They rely on first-order
derivative information and some algorithms additionally on second-order derivative
information. For real-time applications, these are typically calculated by automatic
differentiation (AD) which is efficient concerning the code size, fast and accurate,
and thus better suited than numerical differentiation and symbolic differentiation.
Software packages such as CasADi [2] can be used for AD.
The SQP method is a gradient-based optimization method with special advan￾tages for optimization problems comprising structures as arising in engine control
problems (5.4). Thus, it is introduced as a powerful numerical solution method for
engine control problems in Sect. 5.2. The best solution method depends on the spe￾cific real-time decision-making problem. Usually, the interior point (IP) methods are
superior to the SQP methods for motion planning problems, e.g. for autonomous
driving and robotics. In these problems, typically no reference exists and there are
nonlinear inequality constraints.
While the local minimizers can be calculated with the SQP method, the results do
not necessarily represent global minimizers. In the case of non-convex optimization
in the context of an online algorithm for NMPC, one is satisfied with local minimiz￾ers [7]. Ideally, the local minimizer of the optimization problem is obtained within
each sampling step. For the engine control tasks, very small sampling times are used,
e.g. in the order of milliseconds. In this case, the fully converged solution might not
be obtainable. Alternatively, the so-called real-time iteration (RTI) scheme can be
used [9]. Here, in every time step, a suboptimal solution is calculated and applied to
the plant, as explained in Sect. 5.3.5.
In Fig. 5.1, various MPC schemes are compared along the two dimensions of
computational complexity and capability of the resulting controller. Clearly, there is
a direct correlation between these two characteristics. Depending on the complexity104 5 Nonlinear Model Predictive Control
Fig. 5.1 Classification of various MPC schemes
of the control task, the available computation time, and hardware power, a suitable
algorithm can be chosen. The order of the complexity is given by LMPC, LTV MPC,
NMPC with a suboptimal solution, and NMPC with a fully converged solution.
5.2 Numerical Solution of the Resulting Nonlinear Program
For real-time NMPC, the arising NLP is solved during the runtime of the process.
Typically, the optimization problem cannot be solved analytically, instead the solution
has to be calculated numerically. In the following, solution methods are presented for
the unconstrained and constrained NLPs that are well established for the application
within NMPC. A general treatment of various solution methods for NLPs can be
found in [3, 4, 10].
5.2.1 Solving the Unconstrained NLP
First, unconstrained NLP problems are investigated. In this case, the optimization
problem is given by the minimization of the cost function J (z).
min
z ∈ Rn J (z) (5.5)
In most cases, it is not possible to solve the optimality condition ∇ J (z∗) = 0 ana￾lytically. Instead, numerical methods are used to find the minimizers. Most of the
numerical methods rely on a reduction of the cost function in every iteration step
J (zk+1) < J (zk ) starting from an initial guess z0. For finding the new iterate zk+1,
there exist two fundamental approaches. These are the line-search algorithms and5.2 Numerical Solution of the Resulting Nonlinear Program 105
the trust-region algorithms. Compared to trust-region methods, the line-search algo￾rithms are characterized by first determining the search direction and subsequently
the step length. In the following, the line-search algorithm is detailed. Its general
approach is as follows:
1. Set the index of iteration k = 0.
2. Choose the initial guess z0.
3. Determine the search direction pk .
4. Determine the step size αk > 0.
5. Set the new iterate zk+1 = zk + αk pk .
6. Check stop criterion, e.g. ||∇ J (zk+1)|| ≤ .
7. Start new iteration with k := k + 1 and continue with step 3.
The various line-search algorithms differ by the approach for the determination
of the search direction pk and for the step size αk . A suitable search direction has
to ensure that a reduction of the cost function is possible for a sufficiently small
step size α > 0, i.e. it is a descent direction. This can be translated into a sufficient
condition for the search direction [10] with · being the dot product:
pk · ∇ J (zk ) = pT
k ∇ J (zk ) < 0 (5.6)
If this condition is fulfilled, there exists an αmax such that for any α with 0 < α <
αmax , the following inequality must hold:
J (zk + α pk ) < J (zk ) (5.7)
Two suitable search directions pk are outlined: the steepest descent algorithm which
is based on gradient information and the Newton method which is based on gradient
and curvature information.
The Steepest Descent Method
The steepest descent method is the simplest method for the calculation of a descent
direction [10]. The search direction pk is set to
pk = −∇ J (zk ) (5.8)
The vector−∇ J (zk ) corresponds to the direction of the steepest descent. This method
is easy to implement as only first-order and no second-order derivative information
are needed. Additionally, it guarantees a decrease in J for a sufficiently small step
size αk , as the condition (5.6) is fulfilled. The steepest descent method converges lin￾early. It converges quickly into an area around the minimum. However, it has a slow
convergence around the minimum. Especially for ill-conditioned optimization prob￾lems, small step sizes might be necessary which leads to slow overall convergence.
In this case, scaling of the optimization problem is a possible remedy [11].106 5 Nonlinear Model Predictive Control
The Newton Method
The search direction pk for the Newton method can be derived by two different
approaches that lead to the same result. The search direction can be derived from
the minimization of the second-order Taylor approximation. The second approach,
from where also its name originates, applies the Newton method for root-finding to
the optimality condition [4].
The first approach minimizes the second-order Taylor approximation q( pk ) of J
at each iterate zk . The minimization is denoted by
min
pk
q( pk ) (5.9)
with
q( pk ) := J (zk ) + pT
k ∇ J (zk ) +
1
2 pT
k ∇2 J (zk ) pk
The stationary point for this optimization problem is given by
∇q( p∗
k ) = ∇ J (zk ) + ∇2 J (zk ) p∗
k = 0 (5.10)
The resulting solution of this optimization problem is denoted by p∗
k . The search
direction pk for the Newton method uses the solution of the optimization problem
as search direction within the line-search approach:
pk = −
∇2 J (zk )
−1
∇ J (zk ) (5.11)
The same search direction can also be derived by applying the Newton method to
the optimality condition ∇ J (z) = 0. In general, the Newton method can be utilized
to solve nonlinear root-finding problems. Assume the function f(z) is present and
the following equation is to be solved:
f(z) = 0 (5.12)
In order to iteratively determine a solution z which satisfies the equation, it is approx￾imated as a linear function in each iteration step.
f(zk + pk ) ≈ f(zk ) + pT
k ∇ f(zk ) = 0 (5.13)
For the linear approximation, the root can be directly calculated as
pk = −
∇ f(zk )
T
−1
f(zk ) (5.14)
By the solution of the linear approximation, the new iterate zk+1 can be calculated
as5.2 Numerical Solution of the Resulting Nonlinear Program 107
zk+1 = zk + pk (5.15)
This Newton method can be applied to the first-order necessary optimality condition
∇ J (z) = 0. In this case, the search direction in each iteration is given by
pk = −
∇2 J (zk )
−1
∇ J (zk ) (5.16)
This is the same search direction as the one obtained with the second-order Taylor
approximation. The search direction can be used within the line-search algorithm.
Following update equation is used in every iteration:
zk+1 = zk − αk

∇2 J (zk )
−1
∇ J (zk ) (5.17)
The Newton method shows a fast local convergence rate. Its convergence rate is
quadratic rather than linear, as obtained by the steepest descent method [10]. The
natural step size of the Newton method is αk = 1. If the initial points are chosen suffi￾ciently close to the local minimizer, the Newton method is mathematically guaranteed
to converge to this local minimizer. From remote initial points, z0 convergence can￾not be guaranteed. Globalization strategies are applied to improve convergence also
from remote initial points to the local minimizer. Globalization strategies concern
especially the step size and the search direction.
Applying the full step length can cause non-convergence, i.e. oscillation, or even
divergence. To overcome this problem, the step size αk ∈ (0, 1] must be chosen
accordingly to guarantee a decrease in the cost function. In practice, an initial step
size αk is chosen, which is iteratively reduced until some criteria on progress are met.
There exist various methods, such as the Armijo rule and the Wolfe conditions, to
evaluate whether sufficient progress has been made [10]. The Newton method with
reduced step size is also called the damped Newton method.
For remote initial points, besides the step size, the search direction can be inap￾propriate as well. The Newton method results in a descent direction as long as the
Hessian matrix is positive definite. It can fail when the Hessian matrix turns indef￾inite or negative definite. If such ill-conditioned Hessians occur, this problem can
be overcome by substituting the Hessian with a positive-definite approximation.
Actually, any positive-definite approximation will lead to a descent direction. One
possibility to obtain a positive-definite approximation is the use of regularization. A
simple approach is adding a positive curvature until the modified Hessian matrix H
is positive definite again.
H = H + β I (5.18)
However, completely excluding the Hessian matrix, e.g. by using high values for β,
respectively, the identity matrix for H leads to a simple steepest-descent algorithm.
This often features inferior convergence properties. There exist also more advanced
approaches for regularization to still exploit curvature information as much as pos￾sible [10].108 5 Nonlinear Model Predictive Control
5.2.2 Solving the Constrained NLP via Sequential Quadratic
Programming
Various solution algorithms exist to solve the constrained NLP, such as the IP NLP
method, the augmented Lagrangian method, and the SQP method [3]. In the fol￾lowing, SQP methods are investigated, since they perform very fast and have some
favorable properties for the reference-tracking NMPC problems that arise in engine
control.
The SQP method can be used within a line-search approach. In this context, the
SQP method is used to find an appropriate search direction pk . In every iteration
step, the search direction results from a solution of a quadratic program (QP). The
resulting QP can be solved, e.g. by using an IP QP method or an active set strategy.
After the calculation of the search direction, the step size αk can be determined. Only
by an appropriate choice of αk the convergence of the numerical solution method
can be ensured, as explained for the unconstrained NLP case. Similarly, the Hessian
matrix must be positive definite.
For the line search, a measure is needed to evaluate the progress toward the
KKT point. In the unconstrained case, the cost function J can be used to evaluate the
progress in each iteration. Within the constrained case, a measure is needed that takes
into account the progress in terms of the cost as well as in terms of the constraint
compliance. These functions are called merit functions [10]. One example is the use of
the so-called l1-penalty function m(zk ). It is based on the 1-norm denoted by ||a||1.
The factor σ weighs the constraint compliance against the reduction of cost. The
weight σ has to be chosen bigger than the maximum Lagrange multiplier associated
with the minimizer z∗ to ensure convergence within a line-search method [10].
m(zk ) = J (zk ) + σ
p
i=1
||hi(zk )||1 + σ

q
i=1
max{0, gi(zk )} (5.19)
The calculation of the search direction pk via the SQP method is introduced for
equality and inequality constrained problems in the following sections.
5.2.2.1 NLP with Equality Constraints
The numerical solution of the equality-constrained NLP with the SQP method is
investigated. Two different viewpoints are sketched to derive the resulting formulas,
namely, the application of the Newton method for root-finding on the Karush–Kuhn–
Tucker (KKT) conditions and the quadratic approximation of the Lagrange function.
In both cases, the following equality-constrained NLP is investigated:
min
z ∈ Rn J (z)
s.t. h(z) = 0
(5.20)5.2 Numerical Solution of the Resulting Nonlinear Program 109
Applying the Newton Method on the KKT Conditions
The derivation with the first viewpoint examines the Lagrange function L(z,λ). It
is given by
L(z,λ) = J (z) + λTh(z) (5.21)
In order to find the local minimizers z∗ of the equality-constrained problem, the KKT
conditions can be applied, which are denoted by
∇L(z∗,λ∗
) =

∇zL(z∗,λ∗
)
∇λL(z∗,λ∗
)

=

∇ J (z∗) + ∇h(z∗)λ∗
h(z∗)

= 0 (5.22)
Here ∇h(z), i.e. the transposed Jacobian matrix, results from the derivatives of the
constraints ∇h(z) = [∇h1(z), ∇h2(z), . . . , ∇h p(z)]. If ∇h(z)T has full row rank,
the linear independence constraint qualification (LICQ) is fulfilled, and there exist
unique Lagrange multipliersλ∗ such that every minimizer z∗ solves ∇L(z∗,λ∗
) = 0.
The KKT conditions are a system of nonlinear equations that consist of the same
number of unknowns as the number of equations. The main idea to solve this problem
is to use the Newton method for solving nonlinear root-finding problems, analogous
to the unconstrained case. This time, the Newton method is applied to root-finding of
the equation ∇L(z,λ) = 0. The search direction pk for the Newton iteration follows
as
∇L(zk ,λk ) + pT
k ∇2L(zk ,λk ) = 0 (5.23)
The KKT matrix is given by
∇2L(zk ,λk ) =

∇2
zzL(zk ,λk ) ∇h(zk )
∇h(zk )T 0

(5.24)
The problem can be expanded to

∇2
zzL(zk ,λk ) ∇h(zk )
∇h(zk )T 0
  pzk
pλk

= − 
∇ J (zk ) + ∇h(zk )λk
h(zk )

(5.25)
The update for the iterate can be calculated by

zk+1
λk+1

=

zk
λk

+
 p∗
zk
p∗
λk

(5.26)
Moving the term ∇h(zk )λk to the other side yields

∇2
zzL(zk ,λk ) ∇h(zk )
∇h(zk )T 0
  pzk
λk+1

= − 
∇ J (zk )
h(zk )

(5.27)
To calculate the update for the variables, the linear system of equations needs to be
solved. Solving (5.27) directly yields λ∗
k+1 and p∗
zk with which the update on zk+1110 5 Nonlinear Model Predictive Control
and λk+1 can be calculated. Instead of using the full step also a damped step can
be applied. The standard equation for a line-search update can be used to finally
calculate the new iterate:
zk+1 = zk + αk p∗
zk
λk+1 = (1 − αk )λk + αkλ∗
k+1
(5.28)
Second-Order Taylor Approximation of the Lagrange Function
The same search direction can be derived by an alternative approach. The alternative
approach uses a second-order Taylor approximation of the Lagrange function. The
Lagrange function is given by
L(z,λ) = J (z) + λTh(z) (5.29)
It can be approximated by a quadratic function around zk ,λk with
L Q P,k ( pzk , pλk ) = L(zk ,λk ) +

pT
zk pT
λk
	
∇L(zk ,λk ) +
1
2

pT
zk pT
λk
	
∇2L(zk ,λk )

pzk
pλk

(5.30)
As conducted above, the variables can be exchanged, e.g. pλk = λk+1 − λk . Using
this substitution and expanding the equation leads to
L Q P,k ( pzk ,λk+1) =1
2 pT
zk
∇2
zzL(zk ,λk ) pzk + pT
zk
∇ J (zk )
+ λT
k+1(∇h(zk )
T pzk + h(zk )) − λT
k h(zk ) + L(zk ,λk )
(5.31)
Neglecting the constant terms, the approximated Lagrange function L Q P,k ( pzk ,λk+1)
corresponds to the following equality-constrained QP [3]:
min
pzk
1
2 pT
zk
∇2
zzL(zk ,λk ) pzk + pT
zk
∇ J (zk )
s.t. ∇h(zk )
T pzk + h(zk ) = 0
(5.32)
The optimal Lagrange multipliers of this QP directly yield λ∗
k+1. In this QP, the
term ∇2
zzL(zk ,λk ) contains local curvature information of both J and h, while the
term ∇h(zk )T pzk + h(zk ) is the linearization of the equality constraints h(z) = 0 at
zk . The first-order necessary optimality conditions of this QP result in
∇L Q P,k ( p∗
zk
,λ∗
k+1) =


∇pzk
L Q P,k ( p∗
zk
,λ∗
k+1)
∇λk+1 L Q P,k ( p∗
zk
,λ∗
k+1)

=


∇2
zzL(zk ,λk ) p∗
zk + ∇ J (zk ) + ∇h(zk )λ∗
k+1
∇h(zk )T p∗
zk + h(zk )

= 0
(5.33)5.2 Numerical Solution of the Resulting Nonlinear Program 111
This equation can be reformulated to


∇2
zzL(zk ,λk ) ∇h(zk )
∇h(zk )T 0
 
 p∗
zk
λ∗
k+1

= − 

∇ J (zk )
h(zk )

(5.34)
This update equation is equal to the one derived by the application of the Newton
method on the KKT condition. The second derivation leads to a quadratic program
(QP) that is solved in each iterate. This is where the name Sequential Quadratic
Program originates.
In conclusion, for an equality-constrained optimization problem, the Newton
method applied on the KKT condition is the same as the SQP with the characteristic
of exact Hessian. The general approach for the SQP method within a line-search
framework is as follows:
1. Set the index of iteration k = 0.
2. Choose the initial guess z0,λ0.
3. Compute necessary values for QP approximation, i.e. ∇2
zzL(zk ,λk ),
∇ J (zk ), ∇h(zk )T, h(zk ).
4. Determine search direction p∗
zk and λ∗
k+1 by solving the QP (5.32).
5. Determine step size αk > 0.
6. Set the new iterate zk+1 = zk + αk p∗
zk
, λk+1 = (1 − αk )λk + αkλ∗
k+1.
7. Check stop criterion, e.g. ||∇zL(zk+1,λk+1)|| ≤ L and ||h(zk+1)|| ≤ h.
8. Start new iteration, k := k + 1, and continue with step 3.
Example 5.1 (Sequential Quadratic Programming) For demonstrating the working
principle of the SQP algorithm, the following optimization problem is investigated. It
consists of a quadratic cost function J (z) with the optimization variable z = [z1,z2]
T.
J (z) = 1.5z2
1 + 2z2
2 − 1.5z1z2 + 2z1 − z2 (5.35)
For the optimization problem, a quadratic constraint function h(z) is considered.
h(z) = z2
1 + z2
2 − 0.5z1 − z2 + 0.1 (5.36)
The overall optimization problem is given by
min
z1,z2
J (z)
s.t. h(z) = 0
(5.37)
Figure 5.2 shows the path starting from three initial guesses z0 when using the
SQP algorithm with exact Hessian calculation, i.e. no additional regularization is
used. The initial guess for the Lagrange multipliers is always set to λ0 = 0, and the
step size is chosen constant as α = 0.5. From all three initial guesses, the algorithm
converges to the solution of the optimization problem. All initial guesses are in the112 5 Nonlinear Model Predictive Control
Fig. 5.2 Graphical representation of the iterative solution of Example 5.1 with the SQP method
infeasible region. According to the function principle of the SQP algorithm, the
iterates move toward the KKT point, while the intermediate iterates are often in the
infeasible region of the original optimization problem.
Besides the paths from the three starting points, also the speed of convergence
depending on the initial point is shown in the figure. It is quantified by the number
of iterations needed until reaching the KKT point. The number of iterations strongly
depends on the initial guess. If the initial guess is close to the solution, only very few
iterations are needed. In contrast, from remote initial points, much more iterations
are necessary.
5.2.2.2 NLP with Equality and Inequality Constraints
The additional treatment of inequality constraints is discussed now. The following
general NLP optimization problem is investigated:
min
z ∈ Rn J (z)
s.t. hi(z) = 0, i = 1,..., p,
gi(z) ≤ 0, i = 1,..., q
(5.38)
The corresponding Lagrange function is denoted by L(z,λ, μ).
L(z,λ, μ) = J (z) +p
i=1
λihi(z) +
q
i=1
μigi(z)
= J (z) + λTh(z) + μTg(z)
(5.39)5.2 Numerical Solution of the Resulting Nonlinear Program 113
For this optimization problem, the KKT conditions can be set up as follows:
∇zL(z∗,λ∗
, μ∗) = 0
hi(z∗) = 0, ∀i = 1,..., p
gi(z∗) ≤ 0, ∀i = 1,..., q
μ∗
i ≥ 0, ∀i = 1,..., q
μ∗
i gi(z∗) = 0, ∀i = 1,..., q
(5.40)
The complementary slackness conditions imply a non-smooth solution manifold;
as for gi(z∗) < 0, the corresponding Lagrange multiplier has to be μ∗
i = 0 and
for gi(z∗) = 0, the Lagrange multiplier can take values μ∗
i ≥ 0. Due to this non￾smoothness, the Newton method for root-finding cannot be applied to the KKT
conditions. However, a quadratic approximation of the Lagrange function can be
set up as in the case of the equality constrained NLP. This approximation can be
transformed into a corresponding QP again [10]. It is defined by
min
pzk
1
2 pT
zk
∇2
zzL(zk ,λk , μk ) pzk + pT
zk
∇ J (zk )
s.t. ∇h(zk )
T pzk + h(zk ) = 0,
∇g(zk )
T pzk + g(zk ) ≤ 0
(5.41)
The solution of this QP results in the search direction p∗
zk
. The optimal Lagrange mul￾tipliers of this QP correspond to λ∗
k+1 and μ∗
k+1. The cost function term ∇2
zzL(zk ,λk )
contains local curvature information of J , h and g. The constraints consider the lin￾earization of the equality and the inequaltiy constraints at zk . With the values p∗
zk
,
λ∗
k+1, and μ∗
k+1, the next iterate can be calculated as
zk+1 = zk + αk p∗
zk
λk+1 = (1 − αk )λk + αkλ∗
k+1
μk+1 = (1 − αk )μk + αkμ∗
k+1
(5.42)
For a full step, the step size can be set to αk = 1. The overall procedure can be
summarized as follows:
1. Set the index of iteration k = 0.
2. Choose the initial guess z0,λ0, μ0.
3. Compute necessary values for QP approximation, i.e. ∇2
zzL(zk ,λk , μk ),
∇ J (zk ), ∇h(zk )T, h(zk ), ∇g(zk )T, g(zk ).
4. Determine the search direction p∗
zk
, λ∗
k+1, and μ∗
k+1 by solving the QP.
5. Determine step size αk > 0.
6. Set the new iterate zk+1 = zk + αk p∗
zk
, λk+1 = (1 − αk )λk + αkλ∗
k+1, μk+1 =
(1 − αk )μk + αkμ∗
k+1.114 5 Nonlinear Model Predictive Control
7. Check stop criterion, e.g. 


∇zL(zk+1,λk+1, μk+1)



 ≤ L , ||h(zk+1)|| ≤ h,
||max{0, g(zk+1)}|| ≤ g,



min{0, μk+1}



 ≤ μ, and 


μi,k+1gi(zk+1)



 ≤ μg.
8. Start new iteration, k := k + 1, and continue with step 3.
Example 5.2 (SQP with inequality constraints) In the following, the solution of an
inequality-constrained optimization problem with the SQP method is investigated.
Specifically, one iteration step of the SQP algorithm is detailed. In each iteration
step, one QP problem is solved which is illustrated in this example. The optimization
problem is given by
min
z ∈ R
J (z) = (1 − z)
2 + (1 − z2
)
2
s.t. g(z) = (z − 0.1)
2 − 0.1 ≤ 0
(5.43)
In every iteration step of the SQP algorithm, a QP of the following form is solved:
min
z ∈ R
Jsqp(z)
s.t. glin(z) ≤ 0
(5.44)
Three figures are used to illustrate the SQP algorithm at one iteration step, i.e.
iteration step k. They show the cost function Jsqp(z), the constraint function glin(z),
and the resulting next iterate of zk+1.
In Fig. 5.3, the original cost function J is plotted along with the inequality con￾straint function g(z). Furthermore, the cost function Jsqp is depicted, which is the
approximated cost function resulting from the SQP algorithm at iteration step k.
With μk being the iterate of the Lagrange multiplier of the inequality constraint, it is
calculated by
Jsqp(z) = 1
2
(∇2
zz J (zk ) + μk∇2
zzg(zk ))(z − zk )
2 + ∇z J (zk )(z − zk ) + J (zk )
(5.45)
For comparison, the second-order Taylor approximation Jquad of the original cost
function J at the point zk is illustrated as well.
Jquad (z) = 1
2
∇2
zz J (zk )(z − zk )
2 + ∇z J (zk )(z − zk ) + J (zk ) (5.46)
This shows the difference between the pure quadratic approximation of the cost
function and the cost function Jsqp resulting from the SQP algorithm. Using5.2 Numerical Solution of the Resulting Nonlinear Program 115
Fig. 5.3 Approximated cost function with SQP algorithm for Example 5.2
∇z J (z) = 4z3 − 2z − 2 (5.47)
∇2
zz J (z) = 12z2 − 2 (5.48)
∇zg(z) = 2z − 0.2 (5.49)
∇2
zzg(z) = 2 (5.50)
the approximated cost functions result to be
Jquad (z) = 2.73z2 − 5.9z + 3.16 (5.51)
Jsqp(z) = 5.41z2 − 10.16z + 4.83 (5.52)
Clearly, there is a difference between these two functions, as the function Jsqp
takes additional curvature information of the constraint into account. The current
iterate for the minimizer is zk = 0.79 and the current estimate for the Lagrange
multiplier is μk = 2.69.
Figure 5.4 shows the function glin which results from the linearization of the con￾straint g at the point zk . Additionally, the feasible region of the original optimization
problem is shown along with the feasible region of the approximated QP problem.116 5 Nonlinear Model Predictive Control
Fig. 5.4 Approximated constraint function with SQP algorithm for Example 5.2
glin(z) = ∇zg(zk )(z − zk ) + g(zk )
= 1.38z − 0.71 (5.53)
Finally, Fig. 5.5 shows the cost function Jsqp along with the constraint function
glin and the resulting feasible region. The solution of (5.44) results in the next iterate
zk+1 when the full step is used. The figure shows that the iterate zk+1 is already
very close to the minimizer of the original NLP z∗. For further convergence, within
the SQP method, the point zk+1 is taken as a new basis for generating an updated
quadratic cost function and linear constraint function.
5.2.3 Approximation of Hessian Matrix
Solving an NLP with SQP requires repeated calculations of the Hessian matrix
∇2
zzL(zk ,λk , μk ) at each SQP step k. The calculation of the Hessian matrix can
become computationally expensive. A reduction of the computation time thus can
be crucial for real-time applications. To combine a fast computation per iteration
step with a fast convergence speed, the Hessian matrix can be approximated using5.2 Numerical Solution of the Resulting Nonlinear Program 117
Fig. 5.5 Solution of the QP subproblem within the SQP algorithm for Example 5.2
only first-order derivative information, i.e. ∇2
zzL ≈ M. The methods using approxi￾mated Hessian matrices are called quasi-Newton methods. For instance, theBroyden–
Fletcher–Goldfarb–Shanno (BFGS) algorithm is a secant approximation using only
Jacobian information [3]. Another commonly used approximation is the Gauss–
Newton algorithm, which is efficient for nonlinear least-squares problems [14]. Thus,
it is well suited for optimization problems occurring in engine NMPC. The cost func￾tions investigated are of the following form:
J (z) = 1
2
|| f(z)||2 = 1
2 f(z)
T f(z) = 1
2
m
i=1
f 2
i (z), with f : Rn → Rm (5.54)
The corresponding optimization problem is present as
min
z ∈ Rn J (z)
s.t. hi(z) = 0, i = 1,..., p,
gi(z) ≤ 0, i = 1,..., q
(5.55)118 5 Nonlinear Model Predictive Control
For the generalized Gauss–Newton approximation, in each SQP iteration, the fol￾lowing QP problem is solved to determine the search direction pzk .
min
pzk
1
2 pT
zk
∇ f(zk )∇ f(zk )
T pzk + pT
zk
∇ f(zk ) f(zk )
s.t. ∇h(zk )
T pzk + h(zk ) = 0,
∇g(zk )
T pzk + g(zk ) ≤ 0
(5.56)
Compared to the SQP iteration with exact Hessian as given in (5.41), only the cal￾culation of the Hessian matrix changes. The gradient calculation of the cost function
and the constraints are unaltered. For the calculation of the Hessian matrix, all the
second-order derivative terms are neglected. On top of that, there is no information
of the Lagrange multipliers λk , μk entering the Hessian approximation. Hence, they
do not need to be calculated. The Hessian is approximated by M(zk ):
M(zk ) = ∇ f(zk )∇ f(zk )
T (5.57)
Effectively, the Gauss–Newton method uses a linear approximation of the function
f(z) within the cost function:
JG N ( pzk ) = 1
2
||∇ f(zk ) pzk + f(zk )||2
= 1
2
(∇ f(zk ) pzk + f(zk ))T(∇ f(zk ) pzk + f(zk ))
(5.58)
The approximation of the Hessian matrix by the Gauss–Newton method has
another advantage, besides the reduced computation time. The Hessian approxima￾tion is guaranteed to be positive (semi)definite, which is not true for the calculation
of the exact Hessian, where a regularization may be required to assure its positive
definiteness.
The Gauss–Newton approximation works well if all values of ∇2 fi(z) are small,
which means that all functions fi(z) are close to linear. The approximation is exact
if the functions fi(z) are linear. Additionally, it works well if the residuals fi(z) are
small, which means that the iterate is close to the optimum and J (z∗
k ) ≈ 0 [14].
In contrast to the quadratic convergence of the exact Newton method, the Gauss–
Newton method only converges linearly [14]. However, each single iteration step can
be computed much faster, which often results in an overall reduction of computation
time. Therefore, it can be helpful to trade convergence rate versus computational
complexity per iteration.5.3 Discretization of the OCP via Shooting Methods 119
5.3 Discretization of the OCP via Shooting Methods
There are various strategies to solve the OCP shown in (5.2a)–(5.2e). One possibility
is to set up the Hamilton–Jacobi–Bellman (HJB) equation, which results in a partial
differential equation (PDE). The HJB poses a sufficient optimality condition for
global optimality. This PDE has to be solved in order to find the minimizer. However,
the approach can only be used for very small problems in an online context [14].
Besides the HJB, there are the indirect and the direct methods. More details about
the various strategies can be found in [14]. For indirect methods, the problem is
optimized first and then discretized. The indirect methods are based on Pontryagin’s
Maximum Principle which poses a sufficient condition for local optimality. A two￾point boundary-value problem is solved for finding the optimal solution. For direct
methods, the order is reversed, the problem is discretized first, and then optimized.
For NMPC, they play a dominant role as they allow to achieve online solutions
within the critical timescales of real-time applications. Additionally, the treatment
of constraints on the system states is much easier compared to the other approaches.
In the following, the direct methods are further investigated.
For the direct methods, the infinite-dimensional OCP is approximated by a finite￾dimensional NLP via discretization. Methods that are applied for discretization
include single shooting, multiple shooting, and collocation [14]. In the following,
the single shooting and multiple shooting methods are introduced. Necessary back￾ground for these discretization schemes are numerical methods for the simulation of
ordinary differential equations (ODE).
5.3.1 Numerical Methods for Simulation
For engine control problems, typically the system dynamics are described by nonlin￾ear ODEs. Within NMPC the system states need to be predicted, for which numerical
simulation methods are used. They are also called integration methods. The goal of
numerical simulation is to compute the trajectory of x(t) which, starting from the
initial values, satisfies as best possible the system dynamics given by the ODE. This
problem is also referred to as an initial value problem. The system dynamics and the
initial value condition can be described by
x˙(t) = f(x(t), u(t), t) (5.59)
x(t0) = x0 (5.60)
The trajectory u(t) can be assumed to be part of the function f . Thus, the following
differential equation with simplified notation is examined in the remainder of this
section.120 5 Nonlinear Model Predictive Control
x˙(t) = f(x(t), t) (5.61)
x(t0) = x0 (5.62)
In general, for nonlinear ODEs it is complicated – or even impossible – to find an
analytic solution for the trajectory of system states x(t). Instead, numerical inte￾gration schemes are used to find approximate solutions of the system states x at
a discrete-time grid k + 1, k + 2, k + 3,... which correspond to the time points
tk+1 = (k + 1)T, tk+2 = (k + 2)T, tk+3 = (k + 3)T,... with T being the integra￾tion step size.
5.3.1.1 Characteristics of Simulation Methods
There exist many methods for numerical simulation. A good overview of this topic,
including proofs for the convergence rate, is given in [6]. In the following, various
properties and possibilities to classify numerical simulation methods are detailed.
One-Step Versus Multi-step Methods
One-step methods only use the values xk at the discrete time instance k to calculate
xk+1. Multi-step methods also use previous values xk , xk−1,... at the discrete time
instance k for the calculation of xk+1. One example for a one-step method is the
Runge–Kutta 4 method. Examples for multi-step schemes are the Adams–Bashforth
and the Adams–Moulton methods.
Implicit Versus Explicit Methods
Explicit methods use for the calculation of xk+1 only derivatives at previous values
of x, e.g. xk , xk−1, xk−2. The function f dis,ex shall represent the discretized system
dynamics gained by numerical integration with an explicit method. Using f dis,ex ,
the explicit methods can be characterized by
xk+1 = f dis,ex (xi, ti), i < k + 1 (5.63)
In implicit methods, xk+1 depends also on the derivative at xk+1. To determine the val￾ues xk+1, an iterative solution method as the Newton method has to be used. Implicit
methods are especially suited for stiff systems and systems that are described by
differential–algebraic equations (DAE). The function f dis,im shall represent the dis￾cretized system dynamics gained by numerical integration with an implicit method.
Implicit methods can be characterized by
xk+1 = f dis,im(xi, ti), i ≤ k + 1 (5.64)
An example is the Euler method which exists as an explicit and also an implicit
calculation scheme, as shown below.5.3 Discretization of the OCP via Shooting Methods 121
Convergence Order of the Simulation Method
An important characteristic to distinguish the various numerical methods is their
order p. It furnishes information about the local truncation error. For explicit one￾step methods, the simulated value after one integration step at k + 1 can be described
by
xk+1 = f dis(xk , tk ) (5.65)
The trajectory of the exact solution shall be denoted by x
(t). In this case, the
local truncation error is the difference between the exact solution x
(tk+1) and the
approximate solution xk+1. The values xk+1 are gained by the numerical integration
xk+1 = f dis(x
(tk ), tk ) starting from the exact values x
(tk ). The local truncation
error follows as
e(tk+1) = ||x
(tk+1) − xk+1|| (5.66)
With the integration step size T = tk+1 − tk , a numerical method is called convergent
when the simulated values approach the exact solution for T → 0. The numerical
integration scheme is said to have order p if the local truncation error satisfies (5.67).
lim
T→0
e(tk+1) = O(T p+1
) (5.67)
Higher-order techniques thus have typically smaller errors for the same integration
step size.
5.3.1.2 Runge–Kutta Methods
A well-established family of numerical simulation methods are the Runge–Kutta
methods, which include explicit and implicit one-step methods for numerical simu￾lation. The general s-stage explicit Runge–Kutta method is defined by
k1 = f(xk , tk )
k2 = f(xk + a21T k1, tk + c2T )
k3 = f(xk + a31T k1 + a32T k2, tk + c3T )
.
.
.
ks = f(xk + as1T k1 + as2T k2 +···+ as,s−1T ks−1, tk + csT )
xk+1 = xk + T
s
i=1
bi ki
(5.68)
In order to describe a specific Runge–Kutta method, the number of stages s has to
be given along with the constants ai j with 1 ≤ j < i ≤ s, bi with i = 1,...,s and
ci with i = 2,...,s.122 5 Nonlinear Model Predictive Control
One very common and simple simulation method is the explicit Euler method,
which corresponds to a one-stage Runge–Kutta scheme. The explicit Euler method
has order p = 1 and is defined as
xk+1 = f Euler(xk , tk ) = xk + T f(xk , tk ) (5.69)
Another very common method is the RK4 method, also called classical Runge–Kutta
method, which has four stages. The RK4 method has order p = 4 and is defined by
k1 = f(xk , tk )
k2 = f

xk +
T
2
k1, tk +
T
2

k3 = f

xk +
T
2
k2, tk +
T
2

k4 = f (xk + T k3, tk + T )
xk+1 = xk +
T
6 (k1 + 2k2 + 2k3 + k4)
(5.70)
The Runge–Kutta family also contains implicit simulation methods. The simplest
one is the implicit Euler method, which consists of one stage. It is defined by
xk+1 = xk + T f(xk+1, tk + T ) (5.71)
As the integration scheme depends on xk+1, the solution for xk+1 is implicitly defined.
The solution thus has to be determined iteratively. The equation can be rearranged to
be a root-finding problem. For determining xk+1, the Newton method can be applied
to this equation:
0 = xk + T f(xk+1, tk + T ) − xk+1 (5.72)
A detailed treatment of implicit methods within NMPC can be found in [12, 13].
Also higher-order implicit Runge–Kutta schemes can be realized. The generals-stage
implicit Runge–Kutta methods are defined by
k1 = f
⎛
⎝xk + T
s
j=1
a1 j k j, tk + c1T
⎞
⎠
.
.
.
ks = f
⎛
⎝xk + T
s
j=1
asj k j, tk + csT
⎞
⎠
xk+1 = xk + T
s
i=1
bi ki
(5.73)5.3 Discretization of the OCP via Shooting Methods 123
Example 5.3 (Numerical simulation methods) The properties of the simulation
methods are compared by the evaluation of an example. A simple, linear mass–
spring–damper system is investigated, which is a damped harmonic oscillator. The
ODE of the system is denoted as
x¨ +
b
m x˙ +
k
m x = 0 (5.74)
In this system, x is the position of the mass, m = 0.1 is the mass of the pendulum,
b = 0.6 is the friction coefficient, and k = 100 is the spring constant. For this linear
system, the analytic solution for the position exists as
x
(t) = x0e−Dt 
cos(ωt) +
D
ω
sin(ωt)

(5.75)
where
D = b
2m , ω0 =
 k
m , ω =

ω2
0 − D2 (5.76)
The conditions x(0) = x0 = 1 and x˙(0) = 0 are used as initial conditions and the
step size of the integration is set to T = 0.005s. Figure 5.6 shows the solution gained
with the Euler method, the RK4 method, and with the analytic solution.
The RK4 method is able to reproduce the analytic solution very accurately. The
Euler method, in contrast, already shows a noticeable difference to the analytic
solution, although the same step size is used. The increased accuracy of the RK4
method compared to the Euler method comes from the cost of higher computation
times.
Within the NMPC context, the choice of the integration scheme is very important.
On the one hand, an accurate simulation of the system trajectory has to be ensured. If
this is not the case, even for a setup without a model–plant mismatch, the predicted
system behavior deviates significantly from the real system behavior. On the other
hand, the computational demand is very critical. As depicted, there is a trade-off
between the accuracy of the simulation and the computation demands. Both factors
are affected by the integration step size and the order of the simulation method. If real￾time feasibility is critical, the integration step size for the simulation cannot be chosen
arbitrarily small in order to achieve high accuracy. Within real-time NMPC, it is often
better to use a higher-order method such as RK4, allowing for larger integration step
sizes, than the ones required, e.g. for the Euler method. As the system dynamics of
engine control problems often exhibit stiff behavior, implicit methods often must be
considered for real-world applications.124 5 Nonlinear Model Predictive Control
Fig. 5.6 Comparison of various numerical methods for simulation
5.3.2 Discretization of Actuated Values, Cost Function, and
Constraints
The goal of the discretization is to translate the OCP to a suitable NLP formulation.
For obtaining the NLP, the various components of the OCP have to be discretized,
namely the actuated values, the cost function, the constraints, and the system model.
In the following, all components with the exception of the system model are dis￾cussed.
In the context of NMPC, a suitable choice for the discretization of the trajectory
of actuated values u(t) is the approximation by piecewise constant functions, i.e.
zero order hold.
uk = u(t) = const., tk ≤ t < tk+1 (5.77)
The entire horizon of actuation is discretized in a fixed grid with N equally long
intervals, thus resulting in u = [u0, u1,..., uN−1], as shown in Fig. 5.7.
The constraints can be discretized by only evaluating the constraints on some
points. Usually, the same grid is taken as for discretization of the actuated values.5.3 Discretization of the OCP via Shooting Methods 125
Fig. 5.7 Discretization of the trajectory of actuated values
This obviously shows the approximative behavior of the discretization in that the
constraints are only enforced at some discrete points, but no longer in between.
h(x(t f )) = 0 → h(xN ) = 0 (5.78)
g(x(t), u(t)) ≤ 0 → g(xk , uk ) ≤ 0, k=0,…,N (5.79)
The rectangular method can be used for suitable discretization of the cost function,
where
min
u(t), x(t)
l f

x(t f )

+
 t f
t0
ls(x(t), u(t))dt (5.80)
leads to
min
u(·), x(·)
l f (xN ) + 
N−1
k=0
(tk+1 − tk )ls(xk , uk ) (5.81)
However, often it is not meaningful to reproduce the cost function of the OCP in a
discretized manner. Instead, a new cost function can be built that directly takes into
account the discretized system dynamics.
The influence of the discretized actuated values u(·) on the systems states x(·) is
found by numerical simulation methods such as RK4. As the standard engine control
problems do not depend on the time t, the parameter t is omitted within the ODE
to simplify notation. For a one-step explicit discretization method, the following
notation can be used:
x˙(t) = f(x(t), u(t)) −→ xk+1 = f dis(xk , uk ) (5.82)
The discretization of the system dynamics with single shooting and multiple shooting
is treated in the next sections.126 5 Nonlinear Model Predictive Control
5.3.3 Discretization via Single Shooting
Single shooting is a technique that originally was used for solving a boundary￾value problem. Within the single shooting method, the relevant system states xk+i
with i = 1,..., N are expressed in terms of the discretized actuated values u =
[uk , uk+1,..., uk+N−1] and the initial condition x0. Using the numerical simulation
from (5.82), it follows:
xk+1 = f dis(x0, uk )
xk+2 = f dis( f dis(x0, uk ), uk+1)
.
.
.
(5.83)
The system states at the time points xk+i can be calculated to be recursively using the
function f dis. The trajectory over the whole prediction horizon starting from x0 thus
can be simulated. Hence, the system states in the cost function can be substituted by
functions of the actuated values and the initial condition x0, such that they do not
appear explicitly any more in the cost function.
Assume the following OCP is given:
min
x(t), u(t)
Jocp(x(t), u(t)) (5.84a)
s.t. x˙(t) = f(x(t), u(t)), ∀t ∈ [t0, t f ], (5.84b)
x(t0) = x0, (5.84c)
g(x(t), u(t)) ≤ 0, ∀t ∈ [t0, t f ] (5.84d)
Once the various components are discretized, an NLP results. It can be summarized
by the following optimization problem:
min
u(·|k) ∈ RN
JNLP,SS(u(·|k))
s.t. g(u(k + i|k)) ≤ 0, i = 0,..., N − 1
(5.85)
In the case of single shooting, the optimization variables are given by the sequence
of actuated values u(·|k). The solution of this optimization problem can be calculated
by any NLP solution method, e.g. the SQP method described above. The advantage of
the single shooting method is the small number of optimization variables it requires.
Only an initial guess for the actuated values u(·|k) is needed, when using an SQP
method, for instance. However, if initial guesses for the states x(·|k) are available,
they cannot be exploited. Another disadvantage results from the recursive calculation
of the state trajectory. Due to the long simulation, the nonlinearity of the function
for the system states increases as it is propagated through all the intermediate steps.
This is especially critical for unstable systems.5.3 Discretization of the OCP via Shooting Methods 127
Example 5.4 (NMPC-based control of the Brusselator with single shooting) The
Brusselator shown in Example 4.5 is revisited to benchmark the NMPC algorithm.
The system dynamics of the Brusselator are given by
x˙1 = −8.95x1 + 3x 2
1 x2 + u (5.86)
x˙2 = 4.95x1 − 3x 2
1 x2 (5.87)
The task of the controller is to stabilize the system at the stationary point xSS =
[0.425 3.882]
T. For this purpose, an NMPC algorithm is set up using the single
shooting algorithm. The cost function is given by
J = 
N
i=1



x(k + i|k) − xref




2
Q + 
N−1
i=0



u(k + i|k) − uref




2
R (5.88)
The cost function J takes the deviation of the actuated values and the system states
to the references into account. The reference values are defined by the stationary
point xref = [0.425 3.882]
T and uref = 1.7 which is to be controlled. The horizon
is chosen to be N = 20, while the sampling time is Ts = 0.2s.
The differential equation is discretized by numerical integration. As the sampling
step is quite large, intermediate values are necessary for a stable simulation. Four
integration steps per control interval thus are used:
Tint = Ts
4 = 0.05s (5.89)
Every intermediate integration value is obtained by the RK4 algorithm, which itself
requires four function evaluations per step. The actuated values remain constant
during each of the four integration steps. Each integration step is calculated by
xk+1 = xk +
T
6 (k1 + 2k2 + 2k3 + k4) (5.90)
The formulation for the calculation of ki is shown in (5.70). The optimization problem
takes additionally the following constraints into account:
0 ≤ u(·|k) ≤ 5 and − 2 ≤ Δu(·|k) ≤ 2 (5.91)
0 ≤ x1(·|k) ≤ 2 and 0 ≤ x2(·|k) ≤ 5 (5.92)
After discretization, an NLP results that has the structure of (5.85). The initial states
are given by x0 = [1 2]
T. For the first step of the control algorithm, one NLP results
that can be solved using an SQP solution method. The software package CasADi
is used for the numerical solution of the NLP [2]. Figure 5.8 shows the converged
solution for the resulting NLP with x0 as the initial state. The solution is obtained
after 58 iterations.128 5 Nonlinear Model Predictive Control
0
1
2
0
2
4
0 2 4 6 8 10
0
1
2
Fig. 5.8 Converged solution obtained with single shooting after 58 iterations
5.3.4 Discretization via Multiple Shooting
The discretization with multiple shooting dates back to the 1980s [5]. For the dis￾cretization with multiple shooting, the general procedure is the same as in the single
shooting. The various components, the actuated values, the cost function, the con￾straints, and the system model are discretized in order to obtain a suitable NLP
formulation. The difference in single shooting results in the way the information
of the system dynamics enters the NLP formulation. With multiple shooting, the
simulation and optimization are conducted simultaneously.
The ODE describing the system dynamics is discretized on each interval [tk , tk+1]
starting with initial values xk . The result of the simulation after one integration step is
xk+1. This simulation is conducted for each interval. Using the numerical simulation
from (5.82), it follows:
xk+1 = f dis(xk , uk )
xk+2 = f dis(xk+1, uk+1)
.
.
.
(5.93)
Figure 5.9 shows a sketch of the prediction calculated with this approach.5.3 Discretization of the OCP via Shooting Methods 129
Fig. 5.9 The basic idea of multiple shooting
Assume following OCP is given:
min
x(t), u(t)
Jocp(x(t), u(t)) (5.94a)
s.t. x˙(t) = f(x(t), u(t)), ∀t ∈ [t0, t f ], (5.94b)
x(t0) = x0, (5.94c)
g(x(t), u(t)) ≤ 0, ∀t ∈ [t0, t f ] (5.94d)
In multiple shooting, the discretized system dynamics are added as equality con￾straints in the NLP. The transformation with multiple shooting yields the following
NLP:
min x(·|k), u(·|k)
JNLP,M S(x(·|k), u(·|k))
s.t. x(k|k) − x0 = 0,
x(k + i + 1|k) = f dis(x(k + i|k), u(k + i|k), i = 0,..., N − 1,
g(x(k + i|k), u(k + i|k)) ≤ 0, i = 0,..., N
(5.95)
The system dynamics are no longer contained in the cost function; instead, they
appear in the equality constraints. With multiple shooting discretization, more opti-130 5 Nonlinear Model Predictive Control
mization variables are present than with single shooting, which increases the size of
the optimization problem. The optimization variables are denoted by
z := (x(k|k), x(k + 1|k), . . . , x(k + N|k), u(k|k), u(k + 1|k), . . . , u(k + N − 1|k))
(5.96)
When using multiple shooting for NMPC, the whole formulation can be set up offline.
During runtime of the process, in each time step an NLP with the same structure has
to be solved. The NLP changes from time step to time step as the current system states
are updated, and the reference might change. The resulting NLP can be solved with
an iterative solution method, such as the SQP method. For the converged solution, a
feasible trajectory of system states results, which implies that the discretized system
dynamics are respected. However, for the initial guess, there can be a gap between
the initial values and the simulated values, as depicted in Fig. 5.9. The gap can also
occur for intermediate steps of the iterative solution.
Analytically, for multiple shooting the same optimization problem as in single
shooting is solved, i.e. they have the same global minimizer. However, due to the dif￾ferences in numerics, the intermediate steps are different and local solution methods
such as SQP can converge to different solutions.
The difference in formulation causes additional characteristics, which make mul￾tiple shooting often superior to single shooting for numerical solution. The division
of the entire simulation into small intervals in multiple shooting leads to a more lin￾ear behavior within each simulation step. Along with that, while for single shooting
first the entire simulation is done and then the optimization, for multiple shooting
the simulation and optimization occur simultaneously. This is advantageous for a
fast numerical solution of the optimization problem. The benefits result for nonlin￾ear systems in general and for unstable systems especially. The second advantage
results with multiple shooting as knowledge of the system states can be incorporated
as initial conditions. This advantage can especially be exploited with NLP solution
methods that strongly rely on initial conditions, such as the SQP method. The third
advantage is given by the resulting sparsity pattern of the NLP. In multiple shooting,
it is block sparse, thus sparsity-exploiting solvers can be used. As a result of all
these characteristics, a quick convergence to the solution can be achieved. Addition￾ally, typically after only a few iterations, a very good solution can be obtained with
multiple shooting that is close to the converged one [14].
Example 5.5 (NMPC-based control of the Brusselator with multiple shooting) To
demonstrate the differences between single and multiple shooting, the Brusselator
described in Example 5.4 is revisited. The same control task is to be solved, with
the only difference that now the multiple shooting scheme is used. Especially for
the combination of multiple shooting with SQP, the initialization plays an important
role. If no initial guess is available, a suitable choice is the reference point. Within
this example, all values along the horizon for xk , uk are initialized using the tar￾get stationary point xSS = [0.425 3.882]
T, uSS = 1.7. The initialization step of the
algorithm is displayed in Fig. 5.10. The initialization points are shown along with
the one-step simulation starting from each point. In this specific case, the continuity5.3 Discretization of the OCP via Shooting Methods 131
0.2
0.4
0.6
3.8
3.9
4
0 2 4 6 8 10
1
1.5
2
Fig. 5.10 Initialization of the Brusselator with multiple shooting
condition is fulfilled as the initialization values are a stationary point. Thus, there
is no gap between the one-step simulation and the subsequent states. However, in
general this is not the case; there can be a gap, especially for the initial values.
Figure 5.11 shows the fully converged solution with multiple shooting. The solu￾tion is the same as obtained with single shooting. For the converged solution, the
continuity conditions are always fulfilled along the entire trajectory. The solution
method needs 12 iterations until it reaches this solution, which clearly shows the
speedup gained over the single shooting that required 58 iterations.
Another considerable difference between single shooting and multiple shooting
results for the very first iteration step. Figure 5.12 thus shows the results after the first
iteration obtained by the two methods. The single shooting iterate is still far away
from the converged solution. In contrast, the multiple shooting solution is close to
the final result. With multiple shooting, the strong nonlinearity is avoided compared
to single shooting. This fact can be exploited also by other solution techniques such
as IP methods. For solution methods such as SQP, additionally, the possibility of
multiple shooting to initialize the system states and the actuated values along the
entire trajectory can be exploited.
5.3.5 Real-Time NMPC
So far, various methods have separately been discussed that are suited for use within
NMPC. In the following, the general procedure for real-time NMPC is described. If
the system dynamics are given in a continuous-time representation, the OCP can be132 5 Nonlinear Model Predictive Control
Fig. 5.11 Converged solution obtained with multiple shooting after 12 iterations
0
1
2
0
2
4
0 2 4 6 8 10
0
1
2
Fig. 5.12 Solution after one iteration of single and multiple shooting5.3 Discretization of the OCP via Shooting Methods 133
set up. For direct methods, this OCP is discretized to gain an NLP. In most cases,
multiple shooting discretization offers significant advantages over the single shooting
approach. The discretization step with multiple shooting is conducted offline.
If the system dynamics are present in a discrete-time representation, the NLP can
be built directly. Still, there is the choice of using a sequential or a simultaneous
approach for setting up the NLP. Within the sequential approach, all system states
are replaced in the cost function, as conducted in the single shooting discretization.
Alternatively, within the simultaneous approach, all the system states are kept as
optimization variables, as conducted in the multiple shooting discretization.
During runtime of the process, in every time step of the control algorithm, a new
instance of the NLP has to be solved. From one time step to the next, the structure
stays the same, but single parameters like the initial state changes and the reference
might change. Especially with the SQP method, the initialization can be exploited
in order to obtain a good initial guess. For this purpose, the solution of the last time
step can be used. The solution is reused, just shifted by one time step to account
for the development of time. The preceding solution for the optimization variables
as well as for the Lagrange multipliers can be used for initialization. For the last
state and actuated value in the prediction horizon, usually xk+N := xk+N−1 and
uk+N−1 := uk+N−2 are used as initial guesses. In the same way, the last Lagrange
multipliers can be initialized.
In each time step, the NLP can be solved until complete convergence. From
the minimizer, the first actuated values are applied to the process. If the available
computation time is limited and if the process is just slightly nonlinear, another
approach can be chosen, which is often referred to as the RTI scheme [9]. Instead of
solving the optimization problem until convergence in every time step, the RTI only
solves the NLP approximately. If suitable algorithms are used, the computation time
is reduced significantly, while stability can still be ensured under mild assumptions.
The assumptions concern, e.g. the solution quality of the underlying QP problem [8].
Due to the short computation times, the sampling time of the process can be decreased,
which leads to a fast disturbance rejection and increased robustness. Often, the RTI
scheme is implemented using a direct multiple shooting formulation in combination
with the SQP method [14]. In every time step, a single SQP step is performed, and
the first actuated values of this approximate solution are applied to the plant. For the
subsequent optimization problem, the shifted solution is used as an initial value. As
a consequence, instead of converging to the optimal solution in every time step, the
convergence is realized over multiple time steps during runtime. To further reduce
the computation time, the RTI algorithm often uses a Gauss–Newton approximation
for the calculation of the Hessian. Additionally, real-time-feasible NMPC often relies
on a constant step size within the line-search algorithm. A common setting is α = 1,
thus using the full step.
For NMPC, more parameters have to be set than for the LMPC algorithm. They
have to be tuned appropriately in order to realize a closed-loop controller that sat￾isfies real-time feasibility and high control quality. Figure 5.13 shows an overview
of the most important tuning parameters. Most of the tuning parameters result in a
trade-off between control performance and computational complexity. The optimal134 5 Nonlinear Model Predictive Control
Fig. 5.13 Overview of design choices for the NMPC algorithm – c [2016] IEEE. Reprinted, with
permission, from [1]
choices of these parameters have to be analyzed for the specific application to best fit
the available computation time and the system nonlinearities. There are the design
choices related to the simulation of the process. Important choices are the integration
scheme and the integration step size Tint . They have to be chosen appropriately to
satisfy an accurate simulation of the nonlinear process behavior. This is especially
critical for stiff and unstable systems. Other design choices concern the NLP opti￾mization algorithm. First, the optimization algorithm has to be chosen, for example,
IP or SQP method. The SQP method relies on solving QP problems, consequently
also a QP method has to be chosen. A common combination is the choice of an
SQP method with an active set solver. Besides the SQP method and also the QP
method, the maximum numbers of iterations NQ P and NSQP have to be determined.
Finally, there are also parameters concerning the NMPC formulation. This relates to
the length of the control interval Tc, the number of control intervals N, the weighting
factors, and also the choice of stability mechanism such as terminal cost.
Example 5.6 (LTI MPC and NMPC-based closed-loop control of the Brusselator)
The Brusselator presented in Example 5.4 is revisited. Now, the performance capa￾bilities of LTI MPC and two different NMPC approaches are compared. All three
controllers are applied in a closed-loop control fashion. LTI MPC uses one linear
model for the entire simulation. The linear model is obtained by the linearization of
the system dynamics at the stationary point. The first NMPC approach uses the RTI
scheme. The multiple shooting discretization is applied. One SQP-step is performed
in each iteration step. The first actuated value of the iterate is applied to the plant. The
latter NMPC approach uses the first actuated value of the fully converged solution
in every time step.5.3 Discretization of the OCP via Shooting Methods 135
0
0.5
1
2
3
4
0 2 4 6 8 10
0
1
2
3
Fig. 5.14 Closed-loop control simulations of LTI MPC, NMPC RTI, and NMPC (fully converged)
– state trajectory over time
Figure 5.14 shows the closed-loop control simulations obtained with various MPC
algorithms. It shows the trajectories of the system states over time. As expected, the
fully converged NMPC performs better than RTI and LTI MPC. The performance
improvement concerns especially the settling time of the state x2. RTI itself performs
better than LTI MPC. This behavior is as expected as both NMPC controllers take
additional information about the nonlinear system behavior into account. However,
the computational demands are in reversed order. The highest computational demands
are given for solving the NMPC optimization problem to the converged solution.
The RTI scheme only has slightly higher computational demands than LTI MPC.
The trade-off between computational demand and performance plays a major role in
real-world online engine applications of optimal control.
For the same closed-loop control simulations, Fig. 5.15 shows the trajectories in
the phase portrait. The curves of the NMPC-based solutions are longer compared to
the ones of the LTI MPC-based solution. However, the NMPC-based solutions go
to higher absolute values of the system states. As the system states correspond to a
speed, this procedure allows for shorter settling times, showing that they are able to
exploit the nonlinear system dynamics.136 5 Nonlinear Model Predictive Control
Fig. 5.15 Closed-loop
control simulations of LTI
MPC, NMPC RTI, and
NMPC (fully converged) –
phase portrait
0.4 0.6 0.8 1
2
2.5
3
3.5
4
References
1. T. Albin, F. Frank, D. Ritter, D. Abel, R. Quirynen, M. Diehl, Nonlinear MPC for combustion
engine control: a parameter study for realizing real-time feasibility, in IEEE Conference on
Control Applications (2016), pp. 311–316
2. J. Andersson, J. Akesson, M. Diehl, CasADi: a symbolic package for automatic differentiation
and optimal control, in Recent Advances in Algorithmic Differentiation (Springer, 2012), pp.
297–307
3. J.T. Betts, Practical Methods for Optimal Control and Estimation Using Nonlinear Program￾ming (SIAM, Philadelphia, 2010)
4. L.T. Biegler, Nonlinear Programming: Concepts, Algorithms, and Applications to Chemical
Processes (SIAM, Philadelphia, 2010)
5. H.G. Bock, K.J. Plitt, A multiple shooting algorithm for direct solution of optimal control
problems. IFAC Proc. Vol. 17(2), 1603–1608 (1984)
6. S.C. Chapra, R.P. Canale, Numerical Methods for Engineers (McGraw-Hill Higher Education,
Boston, 2010)
7. M. Diehl, H.J. Ferreau, N. Haverbeke, Efficient numerical methods for nonlinear MPC and
moving horizon estimation, in Nonlinear Model Predictive Control (Springer, 2009), pp. 391–
417
8. M. Diehl, R. Findeisen, F. Allgöwer, H.G. Bock, J.P. Schlöder, Nominal stability of the real￾time iteration scheme for nonlinear model predictive control. IEE Proc.-Control Theory Appl.
152(3), 296–308 (2005)
9. M. Diehl, H.G. Bock, J.P. Schloeder, A real-time iteration scheme for nonlinear optimization
in optimal feedback control. SIAM J. Control Optim. 43(5), 1714–1736 (2005)
10. J. Nocedal, S.J. Wright, Numerical Optimization (Springer, Berlin, 2006)
11. M. Papageorgiou, M. Leibold, M. Buss, Optimierung: Statische, dynamische, stochastische
verfahren für die anwendung (Springer, Berlin, 2015)References 137
12. R. Quirynen, M. Vukov, M. Zanon, M. Diehl, Autogenerating microsecond solvers for nonlinear
MPC: a tutorial using ACADO integrators. Optim. Control Appl. Methods 36, 685–704 (2014)
13. R. Quirynen, M. Vukov, M. Diehl, Auto generation of implicit integrators for embedded nmpc
with microsecond sampling times, in IFAC Nonlinear Model Predictive Control Conference
(2012), pp. 175–180
14. J.B. Rawlings, D.Q. Mayne, M. Diehl, Model Predictive Control: Theory, Computation and
Design (Nob Hill Publishing, Madison, 2017)Chapter 6
Formulation of the Optimization
Problem
Abstract In this chapter, various aspects concerning the formulation of the model
predictive control (MPC) optimization problem are discussed. The formulation of
the optimization problem directly determines the closed-loop control characteristics.
Hence, it plays a fundamental role in the practical application of MPC. The require￾ments on the control performance for the specific application have to be translated
into a suitable optimization task. An important and common requirement concerns
the accuracy of the reference tracking. Usually, a reference shall be tracked by the
closed-loop controller while rejecting disturbances. Ideally, the reference is tracked
without any control error in the steady state, i.e. offset-free control. The chapter dis￾cusses criteria that need to be satisfied such that offset-free control is made viable.
Another system characteristic that has to be taken care of by a special formulation of
the optimization problem is non-square systems. For non-square systems, the num￾ber of inputs is different from the number of outputs. Within engine control, some
overactuated systems are present with more actuated than controlled variables. The
overactuation can be explicitly used by a suitable consideration within the MPC
algorithm. The surplus degree of freedom can be exploited for improvements in the
control behavior, e.g. in terms of control performance and robustness. Besides the
performance requirements, there are also prerequisites that every MPC-based control
algorithm has to fulfill. The two properties that are required to safely employ MPC in
practice are the recursive feasibility of the optimization problem and the stability of
the closed-loop system. The recursive feasibility ensures that there exists a solution
of the optimization problem in every time step. The second property is stability. Even
if there exists a solution that is optimal with respect to the optimization problem,
the closed-loop system can still be unstable. The stability of a closed-loop system is
challenging to prove for practical applications such as in engine control. However,
mechanisms can be introduced to improve the stability properties.
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_6
139140 6 Formulation of the Optimization Problem
6.1 Soft Constraints
The MPC algorithm allows constraints to be considered on actuated values, system
states, and the system outputs. When constraints are incorporated in the optimization
problem, it might become infeasible at a certain time step. This implies that the
feasible set of the optimization problem is empty and thus there does not exist any
suitable solution of the optimization problem.
Based on three situations, Fig. 6.1 shows an introductory example of infeasibility.
Case I schematically depicts an optimization problem with box constraints on the
system states. A feasible solution exists to move from the initial states x0 to the
final states x f . In the next scenario, named Case II, a disturbance acts on the states
at k = 2 such that the states x(k = 3) lie outside of the constraints. Still, a solution
exists such that all subsequent states can be driven within the box constraints to reach
the final states within the prediction. The optimization algorithm can find a solution,
although it might come at the expense of high costs in the cost function, e.g. due to
high actuated values. In the last scenario, Case III, constraints on u are considered
in addition, i.e. umin ≤ u(·|k) ≤ umax . The states x(k = 3) lie so far outside of the
constraints such that the intersection of the maximum reachable set for one step and
the feasible set defined by the constraints is empty. As a consequence, there is no
possibility that the predicted states x(4|k = 3) can lie inside the box-constrained
region without exceeding the constraints on the actuated values. The solver thus
cannot find a solution anymore.
In an online-control algorithm for an engine, such a situation where no solution
can be found has to be strictly avoided. Typical reasons for infeasibility are [2]
• disturbances,
• mismatch between model and plant, and
• inappropriate choice of MPC tuning parameters, e.g. the prediction horizon chosen
is too short.
If only actuated values are constrained and these are set reasonably, i.e. the lower
limit value smaller than the higher limit value for box constraints, the problem of
infeasibility does not occur. The feasible set is directly given by the constrained set
of the actuated variables. As a consequence, the constraints on the actuated variables
can always be used as hard constraints. This also reflects the technical circumstances.
In reality, the actuated variables usually are hard constrained. For instance, the valve
cannot be more than 100% open. Whenever the system states or outputs are con￾strained, the feasibility issues discussed might occur. Additionally, the feasibility of
a single MPC step does not automatically guarantee that all of the following steps
are feasible, which is a property called recursive feasibility.
The most common approach to deal with infeasibility for practical applications
is the use of soft instead of hard constraints. The idea of soft constraints is to allow
for a violation of the original hard constraints at the expense of a very high cost in
the cost function. A suitable penalty function is added to the original cost function.
With this augmented cost function, the controller tries to minimize violation of the6.1 Soft Constraints 141
Fig. 6.1 Infeasibility of the optimization problem
originally hard constraints. Ideally, whenever the original optimization problem is
feasible, the optimizer of the augmented optimization problem should result in the
same solution. If this property is given, the penalty function is called exact [10]. The
soft constraints also reflect technical realities, as the constraints on the system states
and outputs usually are not hard. The turbocharger speed, as an example of engine
control, should be kept below a certain limit value. However, surpassing this limit
value for a short time and with low excess is tolerable. For linear MPC (LMPC), the
concept of soft constraints is detailed in the following.
Original Optimization Problem
The cost function of the original optimization problem shall be given by (6.1).142 6 Formulation of the Optimization Problem
Jorig = 
N2
i=N1
x(k + i|k) − xSS2
Q +
N
u−1
i=0
u(k + i|k) − uSS2
R (6.1)
The corresponding optimization problem is denoted by (6.2).
min
x(·|k), u(·|k)
Jorig
s.t. system dynamics,
initial conditions,
umin ≤ u(k + i|k) ≤ umax , i = 0,..., Nu − 1,
xmin ≤ x(k + i|k), i = N1,..., N2,
−xmax ≤ −x(k + i|k), i = N1,..., N2
(6.2)
The hard constraints on the system states can be relaxed by the introduction of the
slack variables . Within the augmented optimization problem, the slack variables are
considered as additional optimization variables which enter the cost function as well
as the constraints. In the following, various choices for the penalty function are dis￾cussed.Weighting matrices with positive values are used for appropriate penalization.
Quadratic penalty on the slack variables
First, a quadratic penalty on (·|k) ∈ Rnx (N2−N1+1) is investigated. The original cost
function is augmented by the penalty function Jpen, resulting in Jaug = Jorig + Jpen.
The resulting optimization problem is represented by (6.3).
min
x(·|k), u(·|k), (·|k)
=: Jaug   
Jorig + 
N2
i=N1
(k + i|k)2
Sq
s.t. system dynamics,
initial conditions,
umin ≤ u(k + i|k) ≤ umax , i = 0,..., Nu − 1,
xmin − (k + i|k) ≤ x(k + i|k), i = N1,..., N2,
−xmax − (k + i|k) ≤ −x(k + i|k), i = N1,..., N2,
(k + i|k) ≥ 0, i = N1,..., N2
(6.3)
One advantage of the quadratic penalty function is that if the original optimization
problem is strictly convex, the augmented optimization problem stays strictly convex
and the Hessian remains positive definite. However, for a high number of constraints
to be softened, many new optimization variables have to be introduced which increase
the necessary computation time.6.1 Soft Constraints 143
The quadratic penalty function does not introduce any exact penalties. Assume,
the minimizer of the original optimization problem is denoted by u∗
orig, x∗
orig. For
strictly active linear constraints, the original cost function has a negative gradient at
the constrained minimum that is proportional to the Lagrange multipliers μ∗
orig,λ∗
orig.
The penalty function has a gradient of 0 at the point u∗
orig, x∗
orig. The overall gradient,
i.e. the sum of the two gradients, thus can be negative. Hence, the optimizer of the
augmented cost function u∗
aug, x∗
aug can be different from the original minimizer
u∗
orig, x∗
orig. The optimizer can be shifted even though there exists a solution without
any violation of constraints.
Linear Penalty Function: 1-Norm
Instead of the 2-norm, the 1-norm can be used to penalize (·|k) ∈ Rnx (N2−N1+1)
.
The 1-norm penalizes the sum of the absolute values of the slack variables. For
weighting of the penalties, Sl ∈ Rnx is used. As the slack variables are defined to be
nonnegative, the following optimization problem can be used:
min
x(·|k), u(·|k), (·|k)
Jorig + 
N2
i=N1
ST
l (k + i|k)
s.t. system dynamics,
initial conditions,
umin ≤ u(k + i|k) ≤ umax , i = 0,..., Nu − 1,
xmin − (k + i|k) ≤ x(k + i|k), i = N1,..., N2,
−xmax − (k + i|k) ≤ −x(k + i|k), i = N1,..., N2,
(k + i|k) ≥ 0, i = N1,..., N2
(6.4)
The main advantage of using a linear penalty term by the 1-norm is the fact that
exact penalties can be obtained. The additional linear penalty function introduces
a gradient of Sl . The weightings Sl of the slack variables just need to be chosen
sufficiently high, such that the gradient of the penalty function is large enough [10].
When a feasible solution of the original problems exists, the location of the local
minimizer thus is not changed by the augmented optimization problem. Details about
the calculation of the necessary values for Sl are given in [10].
In the case of adding the linear penalty function, it has to be considered that
even if the original problem is strictly convex, the resulting optimization problem no
longer is strictly convex. When QP solvers are applied that rely on strictly convex
optimization problems, suitable regularization has to be added.
The formulations of (6.3) and (6.4) introduce many optimization variables such as
(·|k) ∈ Rnx (N2−N1+1)
. One possibility to reduce the number of optimization variables
is the introduction of the ∞-norm.
Linear Penalty Function: ∞-Norm
An alternative possibility is the penalization of the entire vector of slack variables
(·|k) by the ∞-norm denoted by (·|k)∞. The ∞-norm is given by the maximum144 6 Formulation of the Optimization Problem
of the absolute values of the components of the vector (·|k). This can be recast to a
linear cost term where only one scalar value  ∈ R is considered:
min
x(·|k), u(·|k),  Jorig + Sl
s.t. system dynamics,
initial conditions,
umin ≤ u(k + i|k) ≤ umax , i = 0,..., Nu − 1,
xmin −  ≤ x(k + i|k), i = N1,..., N2,
−xmax −  ≤ −x(k + i|k), i = N1,..., N2,
 ≥ 0,
(6.5)
As in the case of the 1-norm, a sufficiently high weighting of Sl leads to exact
penalties. Also, as in the case of the 1-norm, even if the original problem is strictly
convex, the resulting augmented optimization problem is no longer strictly convex.
Compared to the 1-norm, the formulation of (6.5) only introduces the one additional
optimization variable  ∈ R. This is computationally much more efficient. However,
the exclusive penalization of the maximum value is not sufficient in some appli￾cations. Clearly, medium pathways for complexity versus computation time can be
used as well, such as penalizing the maximum deviation over the entire prediction
horizon separately for each constrained state.
Quadratic Plus Linear Penalty Function
The combination of a quadratic and a linear penalty term combines the advantages
of both formulations. The combination sustains a strictly convex optimization prob￾lem. Additionally, for sufficiently high values of Sl , exact penalties are obtained. In
practice, the combination of quadratic and linear penalization functions is used most
widely. One example is shown in (6.6) where the maximum deviation, a scalar value,
over the entire prediction horizon and all states is penalized.
min
x(·|k), u(·|k),  Jorig + Sq 
2 + Sl
s.t. system dynamics,
initial conditions,
umin ≤ u(k + i|k) ≤ umax , i = 0,..., Nu − 1,
xmin −  ≤ x(k + i|k), i = N1,..., N2,
−xmax −  ≤ −x(k + i|k), i = N1,..., N2,
 ≥ 0,
(6.6)
For nonlinear MPC (NMPC), the same penalty functions can be used to soften the
constraints. In order to not shift the location of the local minimizer, the weighting6.1 Soft Constraints 145
factors have to be chosen such that the gradient of the penalty function at the original
constrained minimizer is sufficiently large. However, the addition of the penalty
function can lead to new minima in regions that previously were excluded by the
constraints. In general, new local minimizers that exceed the original constraints can
be found much easier for NMPC compared to LMPC. Hence, the NLP solver can find
unwanted local minima outside of the operating region. This has to be considered
when developing NMPC with soft constraints. This affects for instance the process
model. It needs to be suitable for usage within NMPC even outside of the feasible
region defined by the original hard constraints. This is especially true for data-driven
models as their extrapolation capabilities are limited.
6.2 Offset-Free Control
A commonly posed requirement on a closed-loop control system is that it should
be free of any offsets. More specifically, usually, it is demanded that for a step in
the reference signal and constant disturbances, the tracking error should vanish in
steady-state conditions. For MPC, additionally, the reference point has to be reach￾able despite the existence of constraints. Offset-free control implies the rejection
of all arising disturbances. In the case of an engine controller, many unmodeled
and unmeasured physical disturbances are acting on the system inputs, states, and
outputs. Additionally, there is always a considerable model–plant mismatch. It is
shown that the MPC algorithm only leads to offset-free control when the measured
outputs match the predictions obtained from the controller-internal model. In prac￾tical applications, the different disturbances lead to deviation of the prediction and
the measurement. Various schemes will be introduced below that allow to align the
prediction, even in the presence of disturbances.
Assume that the controller-internal model of the MPC is given by
x(k + 1) = Ax(k) + Bu(k)
y(k) = C x(k) (6.7)
The real system to be controlled is given by the following state-space representation
which includes constant disturbances acting on the system output:
x(k + 1) = Ax(k) + Bu(k)
d
(k + 1) = d
(k)
y
(k) = C x(k) + Cd d
(k)
(6.8)
Thus, the MPC controller is aware of the real system model matrices, i.e. A, B, and C,
and of the real system states, i.e. x(k), for instance based on full-state measurements.
However, the controller-internal model is unaware of the real disturbances d
. The
prediction of the system states thus is equivalent to the real plant behavior, but the146 6 Formulation of the Optimization Problem
output predictions differ. The predicted outputs from the controller-internal model
are denoted by y, whereas y denotes the real, e.g. measured, outputs.
A stabilizing MPC controller allows the closed-loop system to converge to a steady
state. The steady-state behavior is defined by the following conditions:
x = x∞, Δu∞ = 0, u∞ = const. (6.9)
With d
(k) = const., the stationary conditions of the real plant behavior can be
calculated.
x∞ = Ax∞ + Bu∞
y
∞ = C x∞ + Cd d (6.10)
The question arises whether offset-free control is realized in steady state. A con￾stant reference value r(k) = const. is to be tracked, such that for offset-free con￾trol, r = y
∞ has to hold. Given a stabilizing MPC controller, also assume that the
reference is reachable, i.e. no constraints limit reaching the reference. For an appro￾priate cost function, e.g. J =  y(·|k) − 1r2
Q + Δu(·|k)2
R, the minimum cost for
steady-state conditions is J ∗ = 0. In this case, the predicted error 
 y∞ − r

 also has
to go to zero. In steady state, the prediction of the controller-internal model becomes
y∞ = C x∞. Thus, the following equation holds for determination of the predicted
error:
e∞ = y∞ − r = C x∞ − r = 0 (6.11)
The predicted error is given by the difference between the reference and the pre￾dicted outputs from the controller-internal model rather than the measured outputs.
However, the real plant outputs y
∞ can differ from the outputs y∞ predicted by the
control-internal model.
y∞ = C x∞ ver sus y
∞ = C x∞ + Cd d (6.12)
Since the predicted outputs track the reference y∞ = r, these equations can be rear￾ranged to find what the actual system outputs will be in steady state:
y
∞ = r + Cd d (6.13)
As a consequence, an offset-free control system results when the disturbances d do
not influence the output, i.e. when Cd d = 0. In all other cases, a steady-state offset
error remains.
In general, offset-free control can be realized only when the predicted outputs of
the controller-internal model match in steady state the measured outputs. For this
example, a specific setting is shown. However, this holds true for the general case;
e.g. the disturbances can act anywhere.
Example 6.1 (MPC with model–plant mismatch)
The following example demonstrates the resulting closed-loop control error in case
of a MPC controller with model–plant mismatch. A plant is considered, whose exact6.2 Offset-Free Control 147
0
0.5
1
0 2 4 6 8 10 12 14 16 18 20
0
0.2
0.4
0.6
Fig. 6.2 Step response of the closed-loop control system described in Example 6.1 without and
with model–plant mismatch
discretization with a sampling time of Ts = 0.6 s is given by
Plant G p(z) = 0.25
z2 − 1.65z + 0.75 (6.14)
First, the plant is controlled without any model–plant mismatch, i.e. the MPC uses
G p as a controller-internal model. Figure 6.2 shows the response of the closed-loop
system for a step-wise change in the reference. As expected, offset-free control can
be realized. Now, the controller-internal model is changed such that a model–plant
mismatch is present. The controller-internal model is given by a slight offset in one
model parameter:
MPC-internal Model Gm(z) = 0.25
z2 − 1.65z + 0.70 (6.15)
Using Gm as controller-internal model, the MPC controller controls the plant G p.
Figure 6.2 shows the simulative closed-loop control result.
There is a significant steady-state error, even though the offset in the parameter
of the model is small. This behavior is due to the considerable difference in the
steady-state gain of the plant G p and the controller-internal model Gm.
G p,∞ = G p(z)


z=1 = 2.5, Gm,∞ = Gm(z)


z=1 = 5 (6.16)148 6 Formulation of the Optimization Problem
6.2.1 Observer-Based Offset-Free Control
For feedback control loops with classical controllers such as PID-based control algo￾rithms, integral action has to be present in the open-loop system to realize offset-free
control, e.g. in the controller or in the plant itself. Within MPC, the approach is dif￾ferent in that it consists of two tasks. First, the disturbances arising are estimated and
subsequently, they are accounted for in the prediction of the system behavior. The
consideration of the disturbances in the prediction allows to reject them by optimiz￾ing for the appropriate actuated values. A suitable observer is needed to estimate the
arising disturbances. In the following, the formulas are derived for the linear case.
The observer needs to estimate the unknown disturbances arising. The following
state-space system shall be given as a nominal controller-internal model.
x(k + 1) = Ax(k) + Bu(k) (6.17)
y(k) = C x(k) (6.18)
This nominal linear model is augmented by the disturbance model as shown in (6.19);
see [18].
x(k + 1) = Ax(k) + Bu(k) + Bd d(k)
d(k + 1) = d(k) (6.19)
y(k) = C x(k) + Cd d(k)
Commonly, the disturbances d are assumed to be constant over the duration of the
prediction. If information on the dynamics of the disturbances d is available, they
can be incorporated into the disturbance model. The disturbances are represented
by d ∈ Rp. For the following, it is assumed that the measurements of the system
correspond to the outputs y, and these shall also be the values that are to be tracked
offset-free.
This augmented model is applied for the prediction of the system dynamics within
the MPC algorithm and it is used within the observer as an internal model. The
purpose of the observer is the estimation of the system states and the disturbances.
The estimated values are denoted by xˆ, dˆ. A conventional Luenberger observer can
be used for instance. It is given by
	
xˆ(k + 1)
dˆ(k + 1)


=
	
A Bd
0 I

 	xˆ(k)
dˆ(k)


+
	
B
0


u(k) +
	
Lx
Ld

 
ym(k) − Cxˆ(k) − Cd dˆ(k)

(6.20)
The most recently measured output is denoted by ym(k). The goal of the observer
is to estimate the states and disturbances in such a way that the estimated output
converges to the measured outputs, i.e. Cxˆ + Cd dˆ → ym. If the observed outputs
converge to the measured outputs actually, offset-free control results. A rigorous6.2 Offset-Free Control 149
proof for this statement can be found in [14]. The fundamental approach does not
depend on the characteristics of the nominal system. It is as well independent of
the cause of the disturbance, e.g. model–plant mismatch or external disturbance
parameter and independent of where the disturbances are acting, e.g. on the system
states or on the outputs.
The estimated outputs converge to the measured outputs if two criteria are fulfilled.
On the one hand, the augmented system model has to be observable. On the other
hand, the dynamics of the observer have to be stable, such that estimation errors
converge to zero.
The augmented system is observable if the nominal system (A, C) is observable
and if the following matrix has full column rank, i.e. the rank is equal to the number
of systems states n plus the number of disturbances p [14].
rank 	
A − I Bd
C Cd


= n + p (6.21)
The linear algebra implies that this condition can only be satisfied if the number of
disturbances p is lower or equal to the number of outputs m, i.e. p ≤ m. If all output
values are to be tracked offset-free, a suitable choice for the amount of disturbance
variables is to be equal to the number of outputs p := m [14].
The augmented disturbance model is designed by the matrices Bd and Cd . As long
as the condition (6.21) is fulfilled, the matrices Bd and Cd can be freely designed.
There always exists a pair of matrices Bd and Cd such that the condition (6.21)
is fulfilled [18]. In general, the matrices Bd and Cd should reflect the influence of
the disturbances on the system states and on the outputs. For instance, if there is a
disturbance acting on the input, Bd := B is a suitable choice.
The second criteria concerns the stability of the observer. The closed-loop observer
dynamics are given by
	
xˆ(k + 1)
dˆ(k + 1)


=
	
A Bd
0 I

 	xˆ(k)
dˆ(k)


+
	
B
0


u(k) +
	
Lx
Ld


ym(k) −
	
Lx
Ld

 
C Cd

	
xˆ(k)
dˆ(k)


=
	
A − LxC Bd − LxCd
−LdC I − LdCd

 	xˆ(k)
dˆ(k)


+
	
B
0


u(k) +
	
Lx
Ld


ym(k)
(6.22)
The pole location of the observer can be determined by evaluating the eigenvalues of
the closed-loop state transition matrix of the observer. The transition matrix is given
by
	
A − LxC Bd − LxCd
−LdC I − LdCd


(6.23)
For an asymptotically stable observer, the poles need to lie within the unit disc.
The matrices Lx and Ld of the observer have to be designed such that the observer
becomes asymptotically stable. This implies that the estimation error vanishes, i.e.
Cxˆ + Cd dˆ → ym. There are various ways to design the observer matrices Lx , Ld .
In the classical Luenberger observer, Lx , Ld are designed to achieve specific pole150 6 Formulation of the Optimization Problem
locations. Another popular choice is to use the theory of optimal linear estimation,
resulting in a Kalman filter. More information on this approach in the context of
MPC can be found in [19].
To sum up, the resulting MPC procedure for obtaining offset-free control is as
follows: In every time step, a new measurement of the outputs ym(k) is taken. Based
on these measurements, the estimates of the disturbances and of the system states are
calculated. These disturbance estimates subsequently are used within MPC for the
internal prediction. In steady-state operation, this ensures that the predicted values
of y used in the MPC are equal to the measured values ym. In the final step, the opti￾mal actuated values Δu∗(·|k) are calculated under consideration of the disturbance
estimate.
The general algorithm for offset-free control is similar for LMPC and NMPC. In
fact, the same procedure is used in both cases. For NMPC, a nonlinear observer is
needed, for instance, an extended Kalman filter. The disturbance model itself can be
chosen as in the linear case. The generalization for the nonlinear case is not treated
within this section but can be found in [17].
6.2.2 Offset-Free Control Using a Deadbeat Observer
In some cases already a simple measure is sufficient to realize offset-free control in
MPC. Due to the ease of implementation, it is widely applied in practical applications.
First, the implementation is detailed, followed by an explanation that shows how this
measure is actually a special case of the estimator framework introduced in Sect. 6.2.1
with a deadbeat observer. The estimator framework derivation delivers some further
insight into this procedure.
The following state-space system is taken as a nominal controller-internal model.
x(k + 1) = Ax(k) + Bu(k) (6.24)
y(k) = C x(k) (6.25)
The disturbance estimate dˆ(k + 1) is calculated by
dˆ(k + 1) = ym(k) − C x(k) (6.26)
The current measurement ym(k) is used along with the states x(k) to calculate dˆ(k +
1). The states x(k) can be derived by measurements of the states or by an open-loop
estimation. In the prediction of the system behavior, the disturbance is assumed to
be constant.
dˆ(·|k) = dˆ(k + 1) (6.27)
For the prediction within MPC, the calculated disturbances are used as follows:
y(·|k) = Γ x(·|k) + dˆ(·|k) (6.28)6.2 Offset-Free Control 151
In many cases, this simple procedure already realizes offset-free control. The main
reason for the simplicity comes from the fact that no observer needs to be designed
explicitly. Instead, just the difference between the predicted outputs and the mea￾surements has to be calculated.
To analyze this procedure and show its limitations, the algorithm is converted
into an equivalent structure in the estimator framework as given in Sect. 6.2.1. The
strategy described implicitly uses the following augmented model:
x(k + 1) = Ax(k) + Bu(k)
d(k + 1) = d(k)
y(k) = C x(k) + d(k)
(6.29)
Compared to (6.19), the disturbance model here is characterized by the choices Bd =
0 and Cd = I. Next, an observer gain matrix L is chosen that produces a closed-loop
behavior that is equivalent to the strategy described above. To resemble (6.26), the
observer gain matrix L has to be chosen as follows:
L := 	
Lx
Ld


=
	
0
I


(6.30)
Knowing these choices, the observer dynamics can be evaluated. The dynamics
of the closed-loop observer become
	
x(k + 1)
dˆ(k + 1)


=
	
A 0
0 I

 	x(k)
dˆ(k)


+
	
B
0


u(k) +
	
0
I



=: L

ym(k) − C x(k) − dˆ(k)

(6.31)
The strategy described above thus can be transformed into the estimator frame￾work using the specific choices for the observer gain matrix Lx = 0, Ld = I and for
the augmented model Bd = 0 and Cd = I. To further analyze this strategy, especially
to derive its limitations, the criteria for suitable disturbance estimation mentioned
above can be evaluated. With these choices, the closed-loop state transition matrix
of the observer is given by
	 A 0
−C 0


(6.32)
The calculation of the eigenvalues of the state transition matrix shows that the poles of
the observer are the poles of the nominal system and a number of poles at the origin.
Clearly, using this method of estimation, an unstable nominal system will render an
unstable observer. As asymptotic stability would be lost, the procedure cannot be
applied for systems that are open-loop unstable or exhibit an integrative behavior.
The additional poles at the origin make it a deadbeat observer. This is exactly where
another limitation arises: as is shown in Example 6.2, all arising disturbances are152 6 Formulation of the Optimization Problem
directly fed through to the actuated values. This causes a problem for measurements
with considerable noise. However, in the case of a constant disturbance, the maximum
possible speed for a state estimation is given.
Example 6.2 (Offset-free control with a deadbeat disturbance observer) The system
of Example 6.1 is revisited. A mismatch between the plant G p and the MPC-internal
model Gm is considered.
Plant G p = 0.25
z2 − 1.65z + 0.75 (6.33)
MPC-internal Model Gm = 0.25
z2 − 1.65z + 0.70 (6.34)
Without additional measures, there is a steady-state offset for reference tracking, as
shown in Example 6.1. Now, a deadbeat observer such as the one shown in Sect. 6.2.2
is employed to achieve offset-free control. Figure 6.3 shows the step response of a
closed-loop system that includes a deadbeat observer. Two cases are depicted; mea￾surements without and with noise. The model mismatch can be compensated using
the disturbance estimation. As a result, offset-free reference tracking can be achieved.
With the deadbeat observer, a very desirable control performance is achieved when no
measurement noise is present. When measurement noise exists, the actuated values
exhibit high fluctuations due to the deadbeat fashion of the observer estimation. For
two reasons, this behavior is undesirable. It can damage the actuators, and the noise
is propagated through the actuation onto the states and therefore onto the output.
0
0.5
1
1.5
0 5 10 15 20
-1
0
1
Fig. 6.3 Step response of the closed-loop system described in Example 6.2 using a deadbeat
observer6.2 Offset-Free Control 153
To overcome the problem of measurement noise, the observer has to be designed
in order to explicitly account for the measurement noise, i.e. by use of a Kalman
filter. It reduces the convergence speed in favor of other desirable properties, such as
a minimum variance estimation for a normally distributed noise.
6.3 Reference Tracking
In this section, the topic of reference tracking is detailed by the introduction of two
methods. First, the delta formulation is explained which leads to reference tracking
in a quite natural fashion. Second, a two-layered approach is presented. It is compu￾tationally slightly more demanding but offers advantages in certain applications, e.g.
for non-square systems. Non-square systems are systems where the number of inputs
and the number of outputs are different. The ideas are presented for the linear case.
However, they can be extended to the nonlinear case. The same optimization prob￾lems can be used, just subject to the nonlinear instead of the linear model. Throughout
the section, the reference values are assumed to be constant over time.
6.3.1 Delta Formulation
Appropriate reference tracking can be achieved in many cases by the delta formula￾tion. The optimization problem takes into account the change of the actuated values
Δu. For instance, the following optimization problem can be used, where the distur￾bances are assumed to be constant in the prediction, i.e. d(·|k) = d(k + 1).
min
x(·|k), Δu(·|k)

N2
i=N1
C x(k + i|k) + Cd d(k + 1) − r2
Q +
N
u−1
i=0
Δu(k + i|k)2
R
s.t. system dynamics,
initial conditions,
constraints
(6.35)
For a stable closed-loop control system, the system can converge to a stationary
point (u, x, y) → (u∞, x∞, y∞) with Δu∞ = 0. The stationary point is character￾ized by being the minimizer of the optimization problem. For offset-free stationary
conditions, a cost of J ∗ = 0 is present. A higher value J ∗ > 0 results at stationary
conditions if e.g. the actuated values are constrained such that the reference is not
reachable. If the stationary point r is reachable and the closed-loop system is stable,
the point is attained by a MPC controller with the given cost function. As a result,154 6 Formulation of the Optimization Problem
the delta formulation can quite naturally achieve suitable reference tracking. The
disturbance variables d(k + 1) can be calculated as detailed in Sect. 6.2.
Alternative formulations do not that easily solve the task of reference tracking. As
counterexample to the delta formulation, a cost function is investigated that penalizes
the absolute actuated values instead of its change. The cost function shall be given
by
min
x(·|k), u(·|k)

N2
i=N1
C x(k + i|k) + Cd d(k + 1) − r2
Q +
N
u−1
i=0
u(k + i|k)2
R
s.t. system dynamics,
initial conditions,
constraints
(6.36)
The controller is able to regulate a linear system to the offset-free steady state with
u∞ = 0 and r = C x∞ + Cd d∞, as long as this point is reachable. At this stationary
point, the cost function reaches a minimum of J ∗ = 0. However, for reference values
that can only be achieved with u∞ 
= 0, there is a steady-state offset, even if no con￾straints are considered. In steady-state conditions, a trade-off exists between the cost
of tracking the reference values C x∞ + Cd d∞ − r2
Q and the penalization of the
absolute value of the actuated values u∞2
R. The two terms cannot simultaneously
be reduced below a certain threshold. Hence, the steady-state solution depends on
the weighting matrices Q, R. In contrast to the delta formulation shown in (6.35),
the formulation with absolute values u in (6.36) does not allow for an offset-free
tracking of arbitrary references, even if the references are reachable.
However, in specific applications, the delta formulation in (6.35) does not allow
for enough flexibility. Consider a general linear system given in state-space repre￾sentation, where the reference variables are denoted by r. Clearly, the steady state
(u∞, x∞) of the system must satisfy the following condition for offset-free reference
tracking:
x∞ = Ax∞ + Bu∞ + Bd d∞ (6.37)
C x∞ + Cd d∞ = r (6.38)
This can be written as follows:
	
I − A −B
C 0

 	x∞
u∞


=
	 Bd d∞
r − Cd d∞


(6.39)
The structure of the solution of this equation system depends on the number of
controlled outputs m compared to the number of actuated values l.6.3 Reference Tracking 155
Systems with as many actuated values as controlled values m = l are called square
systems. With a full-row rank matrix, there exists one unique solution. The delta
formulation is regulating the system to this specific point, as long as the closed-loop
system is stable and the point is reachable.
Systems with more controlled than actuated values m > l are called underactuated
and belong to the category of non-square systems. For a solution to exist for all r,
the matrix in (6.39) needs to have linearly independent rows and thus m ≤ l. As a
consequence, in the case of underactuated systems, no solution can be guaranteed for
arbitrary values of r, even if no constraints are active. In general, it is not guaranteed
that the reference point can be reached. The system is regulated to a point that
minimizes the given cost function. For the delta formulation, the resulting solution
in steady state depends on the initial states, i.e. no unique steady states result.
Systems with more actuated than controlled valuesl > m are called overactuated
and belong to the category of non-square systems. With a full-row rank matrix, there
can exist multiple instead of one unique solution. Thus, there exist degrees of freedom
for achieving offset-free control. The delta formulation is regulating the system to
the reference point, i.e. C x + Cd d → r, as long as the closed-loop system is stable
and this point is reachable. However, for overactuated systems, the resulting states in
steady state x∞ and the steady-state actuated values u∞ depend on the initial states,
i.e. no unique steady states result.
The delta formulation, such as in (6.35), leads to steady-state values that minimize
the cost function. However, for the non-square systems, for two different initial
conditions but same reference values, two different solutions in terms of x∞, u∞
might be found. This is shown in Example 6.3. For non-square systems often a
particular solution is preferred. For instance, while one actuator is expensive to
use, the other one is cheap to use. Thus, it is desirable to apply the cheap one as
much as possible. Another example is the classical mid-ranging control algorithm
where the actuated values are tried to be kept at medium values in steady-state
conditions. The regulation of the actuated values to medium values allows a high
control authority in both directions, e.g. in order to quickly reject disturbances. These
specific requirements cannot be handled with the delta formulation. Instead, a two￾layered approach has to be chosen, which offers more flexibility at the expense of
higher computational demands, as explained below.
6.3.2 Two-Layered Control Structure
In some applications, a desired steady-state value for the actuated values or for the
system states does exist. The steady-state target values xSS, uSS need either to be
known or need to be computed explicitly. Typically, there exist requirements on
them, e.g. the absolute value should be as small as possible to decrease energy
consumption. However, they are usually not known a priori, especially as the values
xSS, uSS change in dependence of the reference values and the recent disturbance
states d. Hence, these values need to be recalculated in every time step.156 6 Formulation of the Optimization Problem
Fig. 6.4 Two-layered control structure with target selector
In the following, a two-layered control structure is introduced that addresses these
requirements [19]. The structure of this two-layered control approach is shown in
Fig. 6.4. The actuated values are calculated by solving two optimization problems
sequentially in each time step. First, the ideal steady-state target values are calculated
by the so-called target selector. The target selector only takes the steady-state dynam￾ics into account. Subsequently, within the dynamic regulator, the actuated values are
calculated which are applied to the plant. The solution of the target selector serves
as input for the dynamic regulator where the entire system dynamics including the
transient behavior are considered. As two optimization problems need to be solved,
this formulation incurs additional overhead in terms of computational cost compared
to the delta formulation.
Target Selector
The objective of the target selector is to find the optimal steady-state values for the
actuated values uSS and for the system states xSS. The values need to be steady-state
values. The steady-state values are supposed to lead to the reference values, fulfilling
(6.39). Additionally, the constraints on the system states, defined by xSS ∈ X, and the
constraints on the actuated values, defined by uSS ∈ U, have to be considered. The
definition of the “optimal” target values depends on the specific task. In Example 6.3,
the actuated values are associated with energy consumption, such that a solution with
a minimal absolute value of actuated values is requested. For this specific case, a
possible optimization problem for a target selector is given by
min
uSS, xSS
uSS2
ST
s.t.
	
I − A −B
C 0

 	xSS
uSS

=
	 Bd d∞
r − Cd d∞


,
xSS ∈ X,
uSS ∈ U
(6.9)
The optimization problem takes into account the steady-state value of the disturbance
d∞. As the disturbances are assumed to be constant in the prediction, the value
d∞ := d(k + 1) is typically used. A weighting matrix ST is introduced to allow6.3 Reference Tracking 157
prioritization of the various actuated variables. The definition of the cost function
enables calculation of a unique steady state, even for an overactuated system. In this
formulation, constraints on actuated values and system states are considered while
simultaneously the outputs are enforced to be equal to the reference values. In this
case, feasibility issues can arise, i.e. the references r may not be reachable in steady
state with the constraints imposed. As a result, an infeasible optimization problem
is present. This can be handled via relaxation of the equality constraints by adding
slack variables as detailed in Sect. 6.1.
Dynamic Regulator
The objective of the dynamic regulator is to regulate the system values to the steady￾state values xSS, uSS that are calculated by the target selector. The regulation is
conducted such that the transient behavior toward the steady-state values is consid￾ered by including the system dynamics. A possible optimization problem for the
dynamic regulator is given by (6.41). All in all, this procedure allows to track the
reference without any offset if the reference is reachable. Additionally, even for an
overactuated system, the system is always steered to the same steady-state values,
independent of its initial condition. Assuming the disturbances to be constant, i.e.
d(·|k) = d(k + 1), the following optimization problem results:
min x(·|k), u(·|k)
N2
i=N1
C(x(k + i|k) − xSS) + Cd d(k + 1)2
Q +
N
u−1
i=0
u(k + i|k) − uSS2
R
s.t. system dynamics,
initial conditions,
constraints
(6.41)
Example 6.3 (Reference tracking with the delta formulation) In this example, the
properties of the delta formulation are exemplified. For this purpose, an overactuated
system is closed-loop-controlled with an MPC algorithm. The MPC uses the real
system model and no disturbances are considered, i.e. d = 0. As a plant, a system with
two actuated values and only one controlled value is given. The exact discretization
with a sampling time of Ts = 0.05 s leads to the following discrete-time system in
state-space representation:
AD =
	
1 0.05
0 1 

BD =
	
0.0013 0.0013
0.05 0.05 

C D = 
1 0 DD = 
0 0
(6.42)
The MPC controller is applied for tracking a constant reference value r. As ref￾erence value r = 1 is chosen. A prediction and a control horizon of N = 20 are
applied. The cost function of the MPC is given by the delta formulation. Addition￾ally, constraints on the actuated values are considered. The optimization problem is
given by158 6 Formulation of the Optimization Problem
-0.5
0
0.5
1
1.5
02468
-2
0
2
Fig. 6.5 Simulative closed-loop control result from Example 6.3 with x0 = [0 0]
T
-4
-2
0
2
4
6
02468
-2
0
2
Fig. 6.6 Simulative closed-loop control result from Example 6.3 with x0 = [3 3]
T6.3 Reference Tracking 159
min x(·|k), u(·|k), Δu(·|k)
N
i=1
C x(k + i|k) − r2
Q +
N
−1
i=0
Δu(k + i|k)2
R
s.t. x(k + i + 1|k) = Ax(k + i|k) + Bu(k + i|k), i = 0, ..., N − 1,
x(k|k) = x0,
u(k + i|k) = u(k − 1 + i|k) + Δu(k + i|k), i = 1, ..., N − 1,
u(k|k) = Δu(k|k),
	
−1
−2


≤ u(k + i|k) ≤
	
1
2


, i = 0, ..., N − 1
(6.43)
The closed-loop control simulation is conducted with the initial condition x0 =
[0 0]
T. Figure 6.5 shows the simulative closed-loop control result. Another simulation
with the initial state x0 = [3 3]
T is shown in Fig. 6.6, where all other settings are
identical to the preceding case. The two examples illustrate the properties of the delta
formulation; the reference value is reached in both cases in steady state. However,
the steady-state actuated values depend on the initial condition. If the actuation is
associated with energy consumption, it is preferable that the actuated values are
rather set to the resting position u∞ = 0 in steady state. The resting position is a
feasible solution for tracking the reference, i.e. the system exhibits an integrating
behavior.
Example 6.4 (Reference tracking with the two-layered control approach)
The system of Example 6.3 is revisited. Now, the MPC approach is based on the two￾layered control structure. The cost function of the dynamic regulator is extended by
an additional term which takes the deviation from the steady-state actuated values
into account.
J = 
N
i=1
C x(k + i|k) − C xSS2
Q +
N
−1
i=0
u(k + i|k) − uSS2
S +
N
−1
i=0
Δu(k + i|k)2
R
(6.44)
For the dynamic regulator, all other settings such as weighting parameters, are used
as those given in Example 6.3. The optimization problem of the dynamic regulator
is given by
min x(·|k), u(·|k), Δu(·|k)
J
s.t. x(k + i + 1|k) = Ax(k + i|k) + Bu(k + i|k), i = 0, ..., N − 1,
x(k|k) = x0,
u(k + i|k) = u(k − 1 + i|k) + Δu(k + i|k), i = 1, ..., N − 1,
u(k|k) = Δu(k|k),
	
−1
−2


≤ u(k + i|k) ≤
	
1
2


, i = 0, ..., N − 1
(6.45)160 6 Formulation of the Optimization Problem
-0.5
0
0.5
1
1.5
02468
-2
0
2
Fig. 6.7 Simulative closed-loop control result from Example 6.4 with x0 = [0, 0]
T
The steady-state actuated values uSS are calculated by a target selector where the
following optimization problem is solved. The optimization problem considers that
the actuated values are associated with energy cost. Thus, the absolute values of both
actuated values are minimized.
min
uSS, xSS
uSS2
ST
s.t.
	
I − A −B
C 0

 	xSS
uSS

=
	
0
r


,
	
−1
−2


≤ uSS ≤
	
1
2


(6.46)
The optimal target values for a reference ofr = 1 are given by uSS = [0 0]
T, xSS =
[1 0]
T. Figures 6.7 and 6.8 show the closed-loop simulation starting with the initial
condition x0 = [0 0]
T and x0 = [3 3]
T. The steady-state actuated values now are
independent of the initial conditions. As desired, they move to the resting position
u∞ = uSS = [0 0]
T in steady state.
6.4 Stability Mechanisms
In order to operate a system with MPC, in addition to the recursive feasibility of the
optimization problem, the closed-loop system has to be stable. While the actuated
values are optimal with respect to the optimization problem formulated, the closed-6.4 Stability Mechanisms 161
-4
-2
0
2
4
6
02468
-2
0
2
Fig. 6.8 Simulative closed-loop control result from Example 6.4 with x0 = [3, 3]
T
loop system can still be unstable. This holds true even for nominal stability, which is
the focus of this section. For nominal stability, nominal conditions are assumed, i.e.
the exact system behavior and the system states are known and no disturbances are
present. The nominal stability of the closed-loop system depends on many factors
of the MPC algorithm, such as the weighting factors, the length of the prediction
horizon, and the constraints considered.
An obvious complication about proving the stability of the closed-loop system
is the fact that the actuated values are computed during the runtime of the pro￾cess. Therefore, the closed-loop system dynamics are not known beforehand which
complicates its system analysis. Since a constrained MPC-controlled system is nec￾essarily nonlinear, nonlinear stability theory has to be applied. Almost all stability
proofs for MPC schemes are based on the Lyapunov stability, thus in the remainder
of this section, the notion of Lyapunov stability is used.
There exist several formulations of the MPC optimization problem that are theo￾retically well founded with respect to their stability properties. They offer rigorous
stability proofs such that, under certain assumptions, nominal closed-loop stability is
guaranteed. However, these MPC formulations are typically not suited for practical
applications. They can become computationally very complex and can be very lim￾iting concerning the initial states that result in a feasible solution of the optimization
problem [20]. Still, the investigation of nominal stability allows for mechanisms to
be developed that are advantageous for achieving closed-loop stability in practical
applications, although the guarantees are often lost. In the following, some possible
formulations for achieving closed-loop stability are sketched. Instead of a rigor￾ous treatment including proofs and all technicalities, the ideas of the formulations162 6 Formulation of the Optimization Problem
are depicted and the implications for practical usage are discussed. There are good
monographs treating the topic of stability for MPC in detail, especially [6, 19].
Lyapunov Stability
In the following, the Lyapunov stability is introduced. It is concerned with the stability
of the equilibrium point xeq of an autonomous, nonlinear dynamical system [11]. The
discrete-time system shall be given by x(k + 1) = f(x(k)) with f : D → Rn, and
f shall be locally Lipschitz in D ⊂ Rn. In this section, the origin is assumed to be
an equilibrium point, i.e. xeq = 0. This assumption holds without loss of generality
since the coordinate transformation x˜ = x − xeq can be used to shift any equilibrium
point to the origin, i.e. x˜ eq = 0. An equilibrium point xeq of a system is Lyapunov￾stable if any solution that starts close to the equilibrium stays close to it for all time.
Otherwise, the point xeq is unstable in the sense of Lyapunov. More formally, the
equilibrium point xeq = 0 is stable if for all  > 0, there is a δ() > 0 such that
||x(0)|| < δ() → ||x(k)|| < , ∀k ∈ {0, 1,...} (6.47)
The point xeq is asymptotically stable if it is stable and additionally, there is a region
around xeq from where the solution converges to the equilibrium point with increasing
time. Thus, a region r > 0 needs to exist, such that
||x(0)|| < r → lim
k→∞ x(k) = 0 (6.48)
If the equilibrium point is stable and additionally for any x(0) ∈ Rn, the system
converges to the origin, it is called globally asymptotic stable. The following criteria
need to be fulfilled:
∀x(0) → lim
k→∞ x(k) = 0 (6.49)
To prove stability of an equilibrium point, the so-called Lyapunov function can be
used. The existence of a Lyapunov function provides a sufficient but not necessary
condition for stability. A Lyapunov candidate function is a continuous function V :
D → R for which the following holds:
V(0) = 0 and V(x) > 0, ∀x ∈ D\{0} (6.50)
The equilibrium point xeq = 0 is stable if a Lyapunov candidate function V exists
such that
V( f(x)) − V(x) ≤ 0, ∀x ∈ D\{0} (6.51)
Moreover, the equilibrium point xeq = 0 is asymptotically stable if a Lyapunov
candidate function V exists such that
V( f(x)) − V(x) < 0, ∀x ∈ D\{0} (6.52)6.4 Stability Mechanisms 163
In the following, several MPC formulations are discussed which lead to guaranteed
closed-loop stability. These MPC schemes construct a cost function that is at the
same time a Lyapunov function for the closed-loop system.
6.4.1 Stability of the Infinite-Horizon MPC
First, a MPC problem with infinite horizon is investigated. The analysis of this prob￾lem helps to understand the various formulations that can be employed to show
stability of the conventional finite-horizon MPC scheme. The resulting cost for infi￾nite prediction N = ∞ is denoted as J∞(x(k)). Let the stage cost l(x, u) be a non￾negative function which is decrescent and where l = 0 holds only for the steady-state
conditions, which shall be given by x = 0, u = 0. A suitable and common stage
cost for reference tracking the origin is given by the weighted quadratic 2-norm, i.e.
l(x, u) = x(k + i|k)2
Q + u(k + i|k)2
R with positive definite weighting matrices
Q, R. The infinite-horizon problem shall be given by
min
x(·|k), u(·|k)
J∞(x(k)) = ∞
i=0
(x(k + i|k)2
Q + u(k + i|k)2
R)
s.t. x(k + i + 1|k) = f(x(k + i|k), u(k + i|k)), i = 0, ...,∞,
x(k|k) = x(k),
x(k + i|k) ∈ X i = 1, ...,∞,
u(k + i|k) ∈ U i = 0, ...,∞
(6.53)
For nominal conditions, i.e. perfect knowledge of the system and without distur￾bances, the open-loop trajectory is the same as the closed-loop trajectory for infinite
predictions. The reason behind this is Bellman’s principle of optimality. It states
that any subtrajectory of an optimal trajectory must itself be optimal. This property
facilitates to show that the cost function is a Lyapunov function [9, 15]. If some
conditions are fulfilled, such as stabilizability, the infinite-horizon problem ensures
an asymptotically stable closed-loop system. Additionally, a feasible solution of the
first optimization problem (6.53) needs to exist, which directly leads to recursive fea￾sibility of the optimization problem. The feasible set of the first optimization problem
can be empty, i.e. there does not exist any solution of the infinite-horizon MPC. How￾ever, if there does exist a solution, it is indeed found by solving the infinite-horizon
MPC. In fact, in this case, the optimization problem needs to be solved only once,
since all subsequent iterations lead to the same solution, shifted by the actuated val￾ues already applied. This procedure assumes that a solution can be found; however,
the optimization problem cannot be solved in practice due to the infinite number of
optimization variables. Still, the setup helps to develop stability mechanisms for the
finite-horizon MPC.164 6 Formulation of the Optimization Problem
6.4.2 Stability of Finite-Horizon MPC
There exists a key difference between the finite-horizon and the infinite-horizon
MPC. In general, due to the finite-horizon prediction in MPC, the open-loop trajec￾tory no longer is the same as the closed-loop trajectory. This is even true in nominal
conditions. The common way to still guarantee nominal stability for MPC is the intro￾duction of a stability mechanism in the optimization problem, i.e. by a modification
of the cost function or the constraints. This can be interpreted as an approximation
of the infinite-horizon MPC. The rigorous inclusion of these mechanisms offers a
sufficient condition for nominal stability. As these are sufficient conditions, stable
closed-loop control systems do exist which do not include these stability mechanisms.
This is a major conceptual difference from classical control loops where necessary
conditions for stability exist. The approaches for stabilizing MPC can be divided into
two subdomains:
1. By the use of stability constraints within the MPC formulation, e.g. by the inclu￾sion of a terminal cost and/or a terminal constraint.
2. Approaches without stability constraints, which are also called “unconstrained
MPC”. This refers to the fact that neither a terminal constraint nor a terminal cost
is used, still conventional constraints can be considered.
These subdomains can be combined into hybrid strategies which result in a large
number of distinct MPC formulations that each have their advantages and drawbacks.
In the following, these two subdomains are introduced.
Stability-Constrained MPC with Terminal Equality Constraint
In the following, finite-horizon MPC formulations with stability constraints are dis￾cussed. In this case, the optimization problem is modified by the inclusion of terminal
costs and/or terminal states. The term stability constraints refers to the fact that these
are added not due to physical reasons of the application, but in order to achieve
stability.
First, a simple mechanism is discussed where nominal stability is ensured by the
inclusion of a terminal equality constraint. The goal is to track a certain reference.
Without loss of generality, the regulation to the origin is exemplified where the origin
is assumed to be a steady state with x = 0, u = 0. As discussed above, for points
that are not at the origin, a shift can always be included for x and u. The idea is
to use a finite prediction horizon and to introduce an equality constraint at the end
of the prediction horizon, i.e. x(k + N|k) = 0. The resulting optimization problem
thus reads as follows:6.4 Stability Mechanisms 165
min
x(·|k), u(·|k)

N−1
i=0
(x(k + i|k)2
Q + u(k + i|k)2
R)
s.t. x(k + i + 1|k) = f(x(k + i|k), u(k + i|k)), i = 0, ..., N − 1,
x(k|k) = x(k),
x(k + i|k) ∈ X i = 1, ..., N − 1,
u(k + i|k) ∈ U i = 0, ..., N − 1,
x(k + N|k) = 0
(6.54)
Since the origin is assumed to be an equilibrium point of the system, the additional
constraint x(k + N|k) = 0 enforces that x(k + N + i|k) = 0 ∀i ≥ N, i.e. the system
stays at the origin without any control action. Thus, no additional cost is incurred
after reaching this terminal constraint. This property already renders the cost function
resulting from (6.54) a Lyapunov function that ensures asymptotic stability [9]. This
holds true for every initial state where a feasible solution of the optimization problem
does exist. Recursive feasibility is directly given: since there exists a solution for the
initial iteration ending at the origin, there always exists a feasible solution for the
subsequent iterations. Namely, the solution found in the preceding iteration shifted
by the first element. However, this is not necessarily the solution of the subsequent
iteration, since a trajectory with lower cost may be found.
The major drawback of this method is the fact that the inclusion of the equality
constraint can be unnecessarily restrictive. With the infinite-horizon formulation,
every theoretically possible initial state will lead to a feasible solution of the opti￾mization problem. In contrast, with the equality-constrained MPC formulation, the
region of attraction may become very small, as the final state has to be reached in
N time steps. The region of attraction is defined as all initial states that result in a
feasible trajectory. Its size depends strongly on the prediction horizon N. If the pre￾diction horizon is rather short, the feasible set can even be empty. Additionally, the
stability mechanism assumes that a numerical solution of the optimization algorithm
can be found in each time step. However, the inclusion of the equality constraints
makes numerical problem solving harder. In conclusion, the terminal equality con￾straint offers a simple, sufficient condition for asymptotic stability, but it significantly
reduces the initial states that result in a feasible solution.
Stability-Constrained MPC with Terminal Set and Terminal Cost
To increase the region of attraction, a terminal set and/or a terminal cost can be
introduced. The modified MPC contains the terminal set around the origin denoted
by X f and the terminal cost l f . A typical choice for terminal cost is given by l f =
x(k + N|k)2
P . The modified optimization problem results to be166 6 Formulation of the Optimization Problem
min
x(·|k), u(·|k)
x(k + N|k)2
P + 
N−1
i=0
(x(k + i|k)2
Q + u(k + i|k)2
R)
s.t. x(k + i + 1|k) = f(x(k + i|k), u(k + i|k)), i = 0, ..., N − 1,
x(k|k) = x(k),
x(k + i|k) ∈ X i = 1, ..., N − 1,
u(k + i|k) ∈ U i = 0, ..., N − 1,
x(k + N|k) ∈ X f
(6.55)
Various measures exist to design the terminal set X f , the terminal cost l f , or
the combination of both to guarantee stability [15]. The measures typically give an
upper bound on the infinite-horizon cost and thus can guarantee a decrease in the cost
function in each time step which makes the cost function a Lyapunov function [1].
One idea for the terminal set is to drive the states into the set X f [16]. Once inside
the terminal set, the controller is switched to a precomputed control law u = κ f (x)
which is stabilizing within X f . This approach can only work if X f is reachable in at
most N steps from the initial condition. This condition is less restrictive than reaching
the terminal equality constraints in N steps. Many approaches use a combination of
a terminal state with a terminal cost. Due to the inclusion of the terminal cost, the
controller does not need to be switched within the terminal set; see for instance [3]. If
the terminal costs are chosen appropriately, they act as a stabilizing controller within
the terminal set X f .
There also exist approaches that rely on the terminal cost, without using a terminal
set [8, 12]. The effect of using the terminal cost l f is that it drives the final state closer
to the origin. The terminal cost can be seen as the tail of the infinite-horizon MPC
cost, as it approximates the cost of the time steps from N + 1 to ∞. If the tail of
the infinite-horizon cost is captured appropriately in l f , then the stability guarantees
of the infinite-horizon MPC are recovered [8]. The cost function again constitutes a
Lyapunov function.
For linear systems, the terminal cost P and the terminal states X f can be chosen
to guarantee stability and recursive feasibility based on some results of the uncon￾strained infinite-horizon optimal controller, i.e. the linear quadratic regulator (LQR)
[2]. The terminal cost can be designed by calculating the unique stable solution of
the discrete algebraic Riccati equation (DARE). The DARE arises in unconstrained
infinite-horizon optimal control with A, B being the system matrices and Q, R the
weighting matrices. The terminal cost P can be calculated by solving the following
equation:
P = AT P A + Q − AT P B 
BT P B + R
−1 BT P A (6.56)
If a positive definite solution P exists, then this matrix can be seen as the weight
matrix for the infinite-horizon cost-to-go xN
T P xN for the linearly optimally con￾trolled system. The solution of the DARE can be chosen as terminal cost matrix for
the finite-horizon MPC problem, where P reflects the optimal cost from N to ∞.
The terminal set X f can be chosen to be the maximum invariant set of the closed-6.4 Stability Mechanisms 167
loop system. As a controller, an LQR controller u(k) = KLQR x(k) is chosen, which
results in the following system dynamics considered:
x(k + 1) = Ax(k) + BKLQR x(k) (6.57)
The maximum invariant set X f is the set that contains all points x for which holds
x(k) ∈ X f while satisfying for all k ≥ 0:
x(k + 1) = Ax(k) + Bu(k) (6.58)
u(k) = KLQR x(k) (6.59)
x ∈ X (6.60)
u ∈ U (6.61)
Intuitively, this means that once a trajectory of the system enters the maximum
invariant set, it will never leave it again. The state feedback matrix KLQR can be
derived according to the unconstrained LQR controller:
KLQR = −(BT P B + R)
−1
(BT P A) (6.62)
with P being the positive definite solution of the DARE. The design of an linear
MPC controller with the terminal cost weight matrix P and the terminal set X f leads
to guaranteed stability and recursive feasibility; the closed-loop system is stable for
every initial state that has a feasible solution of the optimization problem.
In conclusion, compared to the use of a terminal equality constraint, the region
of attraction is increased by using the terminal cost and/or the terminal state. The
resulting region of attraction by the inclusion of a terminal set might still be small.
Depending on the investigated system, the computation of the terminal set and the
terminal cost might be very complicated. Additionally, the appropriate terminal set
and/or terminal cost need to be calculated in dependence of parameters such as the
reference value. The inclusion of a terminal cost might put a lot of weight on the last
states, so that performance tuning can become difficult.
MPC Without Stability Constraints
Another approach is the “unconstrained” MPC, where no stability constraints are
included. An infinite prediction horizon N → ∞ guarantees recursive feasibility
and leads to x(k) → 0 as k → ∞, if the optimization problem is feasible for the
initial state. The idea is to emulate this behavior by using a long but finite predic￾tion horizon. Controllability assumptions are used to prove that a sufficiently long
prediction horizon is sufficient to ensure stability [4, 5]. If the prediction horizon is
chosen to be bigger than a certain limit value N > Nlim, the MPC cost function acts
as a Lyapunov function for the system and guarantees stability. A sufficiently long
prediction horizon implicitly fulfills the same purpose as a terminal set; namely to
enforce x(k + N|k) to be close to the equilibrium point.168 6 Formulation of the Optimization Problem
This scheme is attractive for practical usage because of its simplicity. The cost
function does not need to be modified, i.e. no terminal set or terminal cost needs to
be calculated. Additionally, it is less restrictive concerning the region of attraction
compared to other stability mechanisms. However, for a specific setting, it is hard to
find the exact minimum length of the prediction horizon that leads to stability. This
number also depends on parameters such as the reference values. Usually, this value
is determined numerically or by using simulations. It also has to be considered that
a sufficiently long prediction horizon may lead to unacceptably large computation
time.
Conclusions for Practical Applications
There exist many schemes that guarantee nominal stability for the closed-loop sys￾tem. However, they are usually not applied in practice due to their disadvantages,
such as the small region of attraction. Still, several conclusions can be drawn by
investigation of the stability mechanisms: The use of a prediction horizon that is as
long as possible, while satisfying the computational constraints, can be helpful to
realize stability. If due to the computational restrictions, the prediction cannot be
chosen very long, a terminal cost can be added. The authors of [20] show that the
addition of weighting terms in the unconstrained MPC controller yields improved
stability conditions. Additionally, the inclusion of terminal costs aside from a long
prediction horizon does not reduce the initial states that result in feasible solutions. In
reality, there is always a model–plant mismatch so that nominal conditions are never
given. Thus, besides the consideration of these stability mechanisms, it is inevitable
to test the convergence of the numerical algorithms, the recursive feasibility, and also
the stability thoroughly in simulations as well as in experiments.
Example 6.5 (Stability of MPC) This example investigates the effects of various
stability mechanisms. For this purpose, an open-loop unstable system is controlled
with an MPC algorithm. The discrete-time linear system is given by x(k + 1) =
Ax(k) + Bu(k) and has a sampling time of Ts = 0.5 s. The system is characterized
by
A =
	
1.1 0.5
0 1 

, B =
	
0.1
0.5


(6.63)
The MPC algorithm considers constraints on the actuated values and on the system
states. The optimization problem is given by6.4 Stability Mechanisms 169
min
x(·|k), u(·|k)
x(k + N|k)2
P + 
N−1
i=0
(x(k + i|k)2
Q + u(k + i|k)2
R)
s.t. x(k + i + 1|k) = Ax(k + i) + Bu(k + i), i = 0, ..., N − 1,
x(k|k) = x0,
−1 ≤ u(k + i|k) ≤ 1, i = 0,..., N − 1,
−3 ≤ x1(k + i|k) ≤ 3, i = 1,..., N − 1,
−5 ≤ x2(k + i|k) ≤ 5, i = 1,..., N − 1,
x(k + N|k) ∈ X f
(6.64)
For the closed-loop control system, nominal conditions are assumed; the MPC
has perfect model knowledge, there are no disturbances present, and full-state mea￾surement is available. The weighting factors are set to Q = I, R = 100, and the
initial state is given by x0 = [2.5, −2.5]
T. For implementation of the closed-loop
controller, the software packages YALMIP [13] and SeDuMi [21] have been used.
The first approach does not use any stability mechanism, i.e. X f = X and P = 0.
The control horizon is chosen to be N = 3. The closed-loop control result is depicted
in Fig. 6.9. The closed-loop system is unstable although nominal conditions are
present. The figure shows for k = 0, the current state in black and the predicted
values for the system states in red. For k = 1, the states have evolved. As no dis￾turbances are active, the new current system state corresponds to the one predicted
in the previous time step. The new predicted state trajectory is shown accordingly.
As the prediction horizon is finite, the new open-loop prediction can differ from
the ones of the previous time step. In this example, there is quite a big difference
between open-loop prediction and the resulting closed-loop trajectory. At the time
point k = 3, there is no possibility to satisfy all constraints on the system states and
the actuated values. Consequently, the optimization problem is infeasible which is
clearly unwanted.
The second MPC formulation uses a stability mechanism, i.e. stability constraints
are introduced. It relies on the same, small prediction horizon of N = 3, and addi￾tionally, terminal cost and a terminal set are added. The final cost P is calculated by
solving the DARE according to (6.56). It results to be
P =
	
25.6 49.3
49.3 141.5


(6.65)
The terminal set X f is chosen to be the maximum invariant set of the closed-loop
control system with an LQR. The LQR KLQR is designed with the system matrices
A, B and the weighting factors Q, R according to (6.62). The maximum invari￾ant set is calculated using the software package Multi-Parametric Toolbox 3.0 [7].
Figure 6.10 shows the closed-loop control result using this MPC formulation. The
MPC control algorithm allows for an asymptotic stable behavior in this setup. This
can be achieved although a small prediction horizon is used for the unstable system,170 6 Formulation of the Optimization Problem
Fig. 6.9 MPC without any
stability mechanism
Fig. 6.10 MPC with
terminal cost and terminal
set
thus resulting in low computation times. The major drawback of this approach is
the reduced region of attraction. Moreover, the stability constraints and the region
of attraction depend on the reference values. All in all, the addition of the terminal
set and costs has benefits if closed-loop stability is critical, i.e. when controlling an
unstable plant.
The third formulation mimics the MPC approach mentioned without stability
constraints. It uses a long control horizon of N = 20, which is chosen heuristically.
The stability constraints are neglected, i.e. X f = X and P = 0. All other weighting
factors are kept constant. Figure 6.11 shows the resulting closed-loop behavior. The
problem of infeasibility is avoided and instead, an asymptotically stable behavior can
be achieved. The MPC algorithm is able to steer the system states into the origin and
keep it there. Due to the long prediction horizon, the closed-loop trajectory is also
quite similar to the open-loop trajectories, although it is still not exactly the same.6.4 Stability Mechanisms 171
Fig. 6.11 MPC with a long
prediction horizon
Fig. 6.12 MPC with slightly
enlarged prediction horizon
and terminal costs
The major drawback of this stability mechanism is the presence of many optimization
variables within the optimization problem that has to be solved in each time step.
Lastly, a combination of the long prediction horizon and the terminal costs is
investigated. The terminal costs are added to prevent the need for an excessively long
prediction horizon. On the other side, the longer prediction horizon allows to choose
lower terminal costs, which is beneficial for performance tuning. In this example, a
heuristic choice of N = 5 and P = 20I gives good results. The closed-loop control
results are shown in Fig. 6.12. An asymptotic stable behavior can be observed. Just
increasing the prediction horizon to N = 5 without any terminal costs does not allow
for asymptotically stable behavior, neither does the inclusion of the terminal costs
P = 20I without any increase in prediction horizon. Only the combination of both
leads to an asymptotic stable behavior.172 6 Formulation of the Optimization Problem
References
1. F. Allgöwer, R. Findeisen, Z.K. Nagy, Nonlinear model predictive control: from theory to
application. J.-Chin. Inst. Chem. Eng. 35(3), 299–315 (2004)
2. F. Borrelli, A. Bemporad, M. Morari, Predictive Control for Linear and Hybrid Systems (Cam￾bridge University Press, Cambridge, 2017)
3. H. Chen, F. Allgöwer, A quasi-infinite horizon nonlinear model predictive control scheme with
guaranteed stability. Automatica 34(10), 1205–1217 (1998)
4. L. Grüne, Analysis and design of unconstrained nonlinear MPC schemes for finite and infinite
dimensional systems. SIAM J. Control Optim. (2009)
5. L. Grüne, NMPC without terminal constraints. IFAC Proc. Vol. 45(17), 1–13 (2012)
6. L. Grüne, J. Pannek, Nonlinear Model Predictive Control (Springer, Berlin, 2017)
7. M. Herceg, M. Kvasnica, C. N. Jones, and M. Morari, Multi-parametric toolbox 3.0, in 2013
European Control Conference (ECC) (2013), pp. 502–510
8. A. Jadbabaie, J. Hauser, On the stability of receding horizon control with a general terminal
cost. IEEE Trans. Autom. Control 50(5), 674–678 (2005)
9. S. Keerthi, E.G. Gilbert, Optimal infinite-horizon feedback laws for a general class of con￾strained discrete-time systems: Stability and moving-horizon approximations. J. Optim. Theory
Appl. 57(2), 265–293 (1988)
10. E. Kerrigan, J.M. Maciejowski, Soft constraints and exact penalty functions in model predictive
control, in UKACC International Conference (2000)
11. H. Khalil, J. Grizzle, Nonlinear Systems (Prentice Hall, 1996)
12. D. Limón, T. Alamo, F. Salas, E.F. Camacho, On the stability of constrained mpc without
terminal constraint. IEEE Trans. Autom. control 51(5), 832–836 (2006)
13. J. Lofberg, Yalmip: a toolbox for modeling and optimization in matlab, in 2004 IEEE Interna￾tional Conference on Robotics and Automation. IEEE, pp. 284–289
14. U. Maeder, F. Borrelli, M. Morari, Linear offset-free model predictive control. Automatica
45(10), 2214–2222 (2009)
15. D.Q. Mayne, J.B. Rawlings, C.V. Rao, P.O. Scokaert, Constrained model predictive control:
stability and optimality. Automatica 36(6), 789–814 (2000)
16. H. Michalska, D.Q. Mayne, Robust receding horizon control of constrained nonlinear systems.
IEEE Trans. Autom. Control 38(11), 1623–1633 (1993)
17. M. Morari, U. Maeder, Nonlinear offset-free model predictive control. Automatica 48(9), 2059–
2067 (2012)
18. G. Pannocchia, J.B. Rawlings, Disturbance models for offset-free model-predictive control.
AIChE J. 49(2), 426–437 (2003)
19. J.B. Rawlings, D.Q. Mayne, M. Diehl, Model Predictive Control: Theory, Computation and
Design (Nob Hill Publishing, 2017)
20. M. Reble, Model predictive control for nonlinear continuous-time systems with and without
time-delays, Ph.D. Thesis, University of Stuttgart (2013)
21. J.F. Sturm, Using sedumi 1.02, a matlab toolbox for optimization over symmetric cones. Optim.
Methods Softw. 11(1–4), 625–653 (1999)Part II
Introduction to Combustion Engine
ControlChapter 7
SI and CI Engine Control Architectures
Abstract In this chapter, the engine control structure for spark ignition (SI) and
compression ignition (CI) engines is examined. First, a general overview of engine
control is given. A suitable architecture is presented which can be used to handle
the demanding requirements on process control. By the use of hierarchization and
modularization, the complex interaction of the various components can be tackled.
For both the SI and the CI engine, a typical hardware setup is presented. Based
on the two examples, the main control loops are introduced for both combustion
concepts. The goals of the control tasks are outlined and exemplary sensitivities of
the controlled values on the actuated values are shown. Specifically, the tasks within
the air path, the ignition path, the combustion path, and the aftertreatment path are
investigated.
7.1 Overview of Engine Control Tasks
The engine controller has to manage all components of the engine to ensure the
desired performance, as discussed in Sect. 1.2. In order to handle the complex and
strong interactions between the components, the structure of the controller plays an
important role. A common approach to tackle the complexity of the arising tasks is the
use of hierarchization and modularization. The engine controller is often structured
by dividing the tasks into four layers, as shown in Fig. 7.1.
The first layer is the torque manager which calculates the requested torque, i.e. the
torque the engine should provide. An important input to this layer is the gas pedal
position, as by this interface the drivers express their torque demand for driving.
However, additional factors affect the requested torque, such as the torque needed
to drive the auxiliary devices. Also, the driving situation is evaluated, where modes
such as idle speed or fuel cutoff are considered, along with the stability of the vehicle
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_7
175176 7 SI and CI Engine Control Architectures
Fig. 7.1 Engine control architecture consisting of four layers
dynamics. The torque manager usually is a static map that is implemented via look-up
tables [17].
The second layer is the setpoint manager where desired references for physi￾cal quantities are calculated. The requested torque calculated by the torque manager
serves as the input for the setpoint manager. The calculated setpoints are subsequently
tracked by the third layer, where the main engine control loops are present. From
a control point of view, the setpoint manager is a supervisory control layer for the
various open-loop and closed-loop control tasks. The setpoints have to be calculated
in such a way that the requested torque is delivered, while additionally considering
requirements such as emissions and component protection. For this purpose, external
parameters such as the ambient temperature and pressure have to be accounted for.
The setpoint manager can be designed as a static feedforward controller. However,
such a design can lead to a suboptimal performance during the transients, especially
when dynamics with different timescales are present. One example is the interaction
between the air path and the combustion path where the dynamics of the air path
are much slower than that of the combustion path. If the setpoints for both paths
are optimized for the steady-state values only, emission peaks can occur during the
transients. In CI engines, the controller has to avoid soot peaks in the transients. This
is done by ensuring that the combination of air and fuel paths leads to an air–fuel
charge in the combustion chamber that is lean enough during the entire transients
[2, 28]. The higher the engine performance is, the more complex is the interaction
of the various components that have to be accounted for, not only in a steady-state
operation, but also during the transient dynamics. Consequently, a model predictive
control (MPC) solution offers several advantages for this layer [39]. One distinctive7.1 Overview of Engine Control Tasks 177
advantage MPC can offer on this layer is its ability to include preview informa￾tion. For example, the knowledge of the future torque profile due to a prediction
of the elevation and speed profile can be exploited for the engine control system
[22, 38, 45]. The MPC approach can systematically account for this by anticipatory
action.
The third layer contains the main engine control loops. These track the setpoints
calculated in the second layer. Typically, the overall task is divided into four modules:
air path, fuel path, ignition path, and aftertreatment path. Usually, separate controllers
are designed for each path. The division into separate controllers has the advantage
that each control task is easier to manage. However, the drawback is that optimality
is lost in terms of performance. The general control task of the four paths can be
summarized as follows.
• Air Path Controller
It ensures that the intake gas with appropriate properties concerning overall mass,
temperature, and chemical composition, especially with respect to the ratio of O2
(as an oxidizer) and burnt gas, is delivered.
• Fuel Path Controller
It ensures that fuel is delivered into the combustion chamber with appropriate
properties concerning amount, pressure, and timing.
• Ignition Path Controller
It initializes the combustion by ignition, e.g. via a spark plug.
• Aftertreatment Path Controller
It ensures the regulation of the emissions via control of the exhaust gas aftertreat￾ment systems.
The control tasks arising in the third layer represent the core of the engine con￾troller. Often, these control tasks are quite complex. They can be characterized by
multiple-input multiple-output (MIMO) dynamics with nonlinearities and the need
to consider constraints. For many of these control tasks, the MPC approach offers
the best solutions.
The fourth layer is the actuator layer, where low-level control actions take place.
They include the conversion from physical reference values to electrical quantities
and the closed-loop control of the actuator itself for the rejection of disturbances
on the actuator level. One example is the control of a valve, where the reference is
a certain opening position and a closed-loop controller sets the appropriate electric
voltage. In the low-level control layer, often either feedforward or simple feedback
controllers such as PID controllers are sufficient. While these plants usually are
characterized by rather simple single-input single-output (SISO) system dynamics,
there are exceptions, where the actuator shows distinctive complex nonlinear behav￾ior. An example are solenoid valves used for the air path [34] or electromagnetic
actuators [8].
The control architecture depicted is responsible for the fundamental control loops.
However, a multitude of other control loops is present in an engine system. These
include the control of auxiliary components, such as coolant temperature control [25],178 7 SI and CI Engine Control Architectures
control of the fan [42] as well as control of the fuel pump [6]. For these control loops
usually, simple control techniques are sufficient.
Obviously, the specific control tasks required depend on the individual engine.
A major difference exists in the combustion concept, e.g. SI versus CI. But there
are also other factors, such as the hardware applied, e.g. naturally aspirated versus
turbocharged engine, and the operation purpose of the engine, e.g. stationary versus
dynamic operation. These characteristics have an influence on which control tasks
are required, how complex they are, and also on the requirements for the closed-loop￾controlled system. The following overview of combustion concepts is presented as
they substantially affect the control loops necessary as well as the hardware involved.
A multitude of combustion concepts is used in ICEs. This book follows a classifi￾cation proposed in [23]. According to [23], there are three fundamental combustion
concepts, namely the SI concept, the CI concept, and the low-temperature combus￾tion (LTC) concept; see Fig. 7.2. The SI concept is characterized by the combustion
of a premixed charge which is triggered by a spark plug. Another important char￾acteristic is the air-to-fuel equivalence ratio λ. The value for λ can be calculated by
setting the air-to-fuel ratio AFR in relation to the stoichiometric air-to-fuel ratio
AFRs.
λ = AFR
AFRs
(7.1)
The AFR itself is defined as the ratio between the mass of air and the mass of fuel
used within the combustion process:
AFR = mair
m f uel
(7.2)
The value AFRs describes the ratio of air to fuel which is needed for stoichiometric
combustion, i.e. without excess of air. For gasoline combustion AFRs = 14.7 holds,
thus for the combustion of 1 kg of gasoline fuel 14.7 kg of air is needed.
In the SI concept, stoichiometric combustion is given, such that λ = 1. In the CI
concept, a diffusive (non-premixed) combustion of a lean charge is used, which is
triggered by a late injection of the fuel directly into the cylinder. The LTC concept
is characterized by the combustion of a premixed charge via autoignition, where
the charge can be lean or stoichiometric. All other combustion concepts, besides
the three fundamental ones, can be classified along the triangle shown. The non￾fundamental combustion concepts comprise properties of two different fundamental
concepts. One example is the concept of a lean burning SI engine, which would be
classified between the SI and the CI engine concepts [23]. As in an SI engine, it uses
a spark ignition to trigger the combustion, but it is operated with a lean charge like
that of a CI engine. In the following, the basic control loops of the three fundamental
combustion concepts are introduced.7.2 SI Engine Control Systems 179
Fig. 7.2 Three fundamental engine combustion concepts – reproduced with permission from [23]
c 2016 Wiley-VCH Verlag GmbH & Co
7.2 SI Engine Control Systems
The SI concept is characterized by the spark ignition of a homogeneous charge. In
order to achieve a homogeneous mixture, the fuel is either injected into the intake
port or directly into the combustion chamber, typically during the intake stroke or
early in the compression stroke. As a consequence, there is enough time to mix the
air and the fuel, which results in a premixed charge. The combustion is triggered
by a spark plug. This initiates a small flame kernel which is propagated through the
combustion chamber as a flame front [20]. This combustion mode relies on a fuel
that evaporates at sufficiently low temperatures. Currently, most SI engines run on
gasoline fuel. However, there are also SI engines which run with other fuels, such as
natural gas.
The homogeneous mixture has favorable properties concerning pollutant emis￾sions. For instance, only a little soot is produced. The amount is low enough that
often no aftertreatment for soot is necessary. However, especially for direct-injecting
gasoline engines, more and more gasoline particulate filters are used to filter soot
emissions. The remaining pollutant emissions are usually aftertreated by a three￾way catalyst (TWC) which combats nitrogen oxides NOx, carbon monoxide CO,
and unburned hydrocarbon HC emissions simultaneously. The pollutant emissions
are converted into nitrogen dioxide N2, carbon dioxide CO2, and water H2O [26].
Compared to a CI engine, the exhaust aftertreatment of an SI engine is cheaper and
simpler. The TWC only works effectively when the combustion takes place within a
narrow range of λ = 1 ± 0.005 [18]. To achieve a high conversion efficiency of the
TWC and thus low tailpipe pollutant emissions, the air-to-fuel equivalence ratio λ
is close-loop-controlled to be one. A quantitative load control concept is thus used,
i.e. the load is changed by adjusting the amount of air which is inducted into the
cylinder. The fuel is adapted to achieve a stoichiometric operation.180 7 SI and CI Engine Control Architectures
Fig. 7.3 Exemplary
structure of a turbocharged
SI engine
The main control loops of an SI engine are illustrated by an exemplary setup,
which is depicted in Fig. 7.3. In this setup, the fuel is injected into the intake port
and the charge is ignited by a spark plug. The engine is equipped with a throttle
and a single turbocharger. For the exhaust gas aftertreatment, a TWC is used. In the
following, the fundamental control tasks arising in the air path, the fuel path, and the
ignition path are discussed. For this SI engine, no aftertreatment path control system
is necessary. As it is a passive device, the TWC needs no dedicated control loop.
7.2.1 Air Path Controller
The main goal of an air path controller is to manage the conditions in the intake port.
In the given setup, only fresh air is present in the intake path, i.e. no external exhaust
gas recirculation is considered. The pressure in the intake manifold can be used
as a controlled variable. It correlates to the air mass inducted into the combustion
chamber, which is the relevant variable that has to be set. Due to the quantitative load
control in SI engines, the fuel mass injected is adapted to the air mass inducted, which
itself is determined by the intake manifold pressure, in order to fulfill λ = 1. Thus,
the air path controller directly determines the torque produced. The use of the intake
manifold pressure as a controlled value has the advantage that it can be measured
by a pressure sensor. In some cases, instead of a pressure sensor, an air mass flow
sensor is used along with a model to estimate the intake manifold pressure.
At least a throttle is needed in the air path of an SI engine to control the load.
In the setup investigated, in addition to the throttle, a turbocharger equipped with a
wastegate is installed. The parameters involved for actuation are the variables uth
which represents the opening position of the throttle and uwg which represents the7.2 SI Engine Control Systems 181
Fig. 7.4 Influence of throttle
position on steady-state
inducted air mass flow
wastegate opening position. Both are used to adjust the amount of air that is inducted
into the cylinder. As the buildup of torque is directly determined by the air path con￾troller, its proper design is a crucial aspect of driveability. Usually, the requirements
on driveability translate into a target time constant of an equivalent first-order system
for the closed-loop control of the intake manifold pressure; see [40].
By changing the position of the throttle plate, the flow into the intake manifold can
be restricted, and thus the amount of air entering the cylinder is adjusted. Figure 7.4
shows measurement data of the air mass flow aspirated in dependence of the throttle
position at steady-state conditions. The throttle can only act in one direction. Com￾pared to the upstream conditions of the throttle, the pressure can only be decreased.
Usually, electronic actuators are used for the throttle, which allows for closed-loop
control of the throttle position. The control of the load with the throttle inherently
decreases the efficiency of the entire engine process, as the closing of the throttle
causes pumping losses [20]. Using the throttle, the intake manifold pressure can be
changed with dynamics in the order of milliseconds, which is a fast change that leads
to an almost immediate torque response.
One concept to reduce fuel consumption is the application of “downsizing” by
the use of turbochargers. The goal of downsizing is the improvement of the engine
operating points concerning efficiency while maintaining the engine power. Using
a turbocharger, the engine size can be reduced without impairing the engine power.
The reduction of the engine size leads to a reduction of friction losses. Additionally,
in SI engines the throttle can be opened wider, thus reducing the pumping losses.
The turbocharger consists of a turbine and a compressor that are connected by a
common shaft. The turbine is powered by energy extracted from the hot exhaust gas.
The intake air of the combustion engine thus can be compressed to higher densities
than those achievable with a naturally aspirated engine. Compared to the upstream
conditions of the compressor, the pressure can only be increased.182 7 SI and CI Engine Control Architectures
To adjust the turbocharging to the specific operating point, variability is introduced
in these concepts. In SI engines, typically wastegates on the turbine side are used.
The wastegate adjusts the amount of mass flow that bypasses the turbine. The closing
of the wastegates leads to a higher mass flow through the turbine and thus higher
turbocharger speeds, higher intake manifold pressures, and higher exhaust gas back
pressures. The wastegate actuators are usually electro-pneumatic or electric.
As a direct coupling between the intake and exhaust paths exists with turbocharg￾ing, the process control has to address these couplings. In modern engines, the focus
is set on fuel efficiency; thus, the use of the throttle is avoided as much as possible
to reduce pumping losses. As a result, for turbocharged operation, the throttle is not
used for control but is fully opened. By the use of turbocharging, the intake manifold
pressure can be changed with dynamics in the order of seconds. This time lag is
perceptible to the driver and is known as “turbo lag”. The lag results from the inertia
of the turbocharger and the dynamics of the volumes to build up pressure.
Another important aspect in the control of turbochargers is the consideration of
their operation limits. The controller has to ensure that an operation at excessive
turbocharger speeds is avoided as well as an operation in the surge and the choking
mode [27]. These limits have to be obeyed in order to ensure a safe operation of a
turbocharger. Additionally, the exhaust gas back pressure has to be considered as it
influences the efficiency of the engine. For the load adjustment, usually two different
controllers are used. Whenever the load cannot be set with an open throttle, i.e. the
reference for the intake manifold pressure is lower than the base charging pressure,
the wastegate is fully opened and the throttle is used for control. For a turbocharged
operation, the throttle is fully opened and the wastegate is used for control.
7.2.2 Fuel Path Controller
In the setup investigated, the fuel is injected into the intake port. A common choice
for a gasoline injector are solenoid-actuated valve plungers with multiple fuel outlet
holes that improve spray atomization. The time point of injection needs to allow for
enough time to mix the air and the fuel, such that a homogeneous charge results.
Within a reasonable range, the injection timing has only a negligible influence on the
performance of the combustion process. The duration of injection udoi is used as an
actuated value.
The duration of injection udoi correlates in a nonlinear fashion with the fuel mass
injected. It is driven by the requirements of the TWC. The engine-out emissions
are lowest at slightly lean conditions, i.e. λ ≈ 1.2 [18]. However, the highest TWC
efficiency is achieved at λ ≈ 1. As a result, the lowest tailpipe emissions are achieved
for λ ≈ 1 as well. To keep the charge within the demanded narrow range of λ =
1 ± 0.005, an air-to-fuel ratio controller is used. It has a crucial task in an SI engine
in that it has to set the amount of fuel according to the air mass inducted into the
cylinder. It thus requires an accurate estimation of the air mass inducted. This estimate
can be used for feedforward control, which is essential during a transient operation.7.2 SI Engine Control Systems 183
Fig. 7.5 Conversion
efficiency of the three-way
catalyst in dependence of its
temperature
Additionally, lambda sensors are used to measure the air-to-fuel ratio in the
exhaust gas and therefore also the λ value. Often a combination of sensors is used.
A wide-band lambda sensor installed before the TWC furnishes continuous lambda
values, while a switch-type lambda sensor located after the TWC furnishes discrete
values, i.e. λ < 1 or λ > 1 [36]. The information from both sensors are processed in
the feedback controller. For the rejection of disturbances and thus for higher accu￾racy, a feedback controller is necessary in addition to the feedforward controller. The
value of udoi is set on a cycle-to-cycle basis.
For an appropriate control result, the specific characteristics of the TWC have
to be taken into account. The fact that the TWC has some oxygen storage capacity
can serve the closed-loop controller by damping small deviations from λ = 1 for a
short time. Another characteristic of the TWC is the dependence of its conversion
efficiency on its temperature. At low TWC temperatures, i.e. at cold-start conditions,
only a small fraction of the pollutant emissions NOx, CO, and HC are combated due to
the reaction kinetics [4]. Figure 7.5 shows the conversion efficiency of a TWC for the
emission levels of CO and HC in dependence of its temperature. One characteristic
point is the so-called light-off temperature, which is defined as the temperature where
50% of the emissions of the HC are converted [18]. In this example, the light￾off temperature is 500◦C. Therefore, until the light-off temperature is reached, the
controller should focus on increasing the TWC temperature by hot exhaust gases
rather than on achieving the highest combustion efficiency.
7.2.3 Ignition Path Controller
The combustion of the charge is triggered by a spark plug. For actuation, the spark
ignition timing usi results, which has a strong effect on the process of combustion.
The spark ignition timing has an influence on the trajectory of the heat release and184 7 SI and CI Engine Control Architectures
Fig. 7.6 Influence of the
combustion average CA50
on cylinder pressure trace
with that on the combustion average (CA50). The combustion average corresponds
to the time point where 50% of the fuel is burnt; its calculation will be detailed in
Sect. 14.3. The combustion average strongly influences combustion efficiency. In a
normal operation, the spark timing is set to achieve high combustion efficiency. Often
it is set such that a combustion average of CA50 ≈ 8 ◦CA results, as this represents
high efficiency. Influencing factors of the optimal ignition timing are the engine
speed, the load, and ambient conditions such as ambient temperature, pressure, and
air humidity [13]. Figure 7.6 shows the cylinder pressure trace in dependence of the
crank angle position for various timings of the combustion average. All of the traces
are operated at the same load by closed-loop control of the fuel amount. Besides
the efficiency, the allowable maximum cylinder pressure and the maximum exhaust
temperature have to be respected, as these pose a mechanical limit.
In some cases, the ignition timing is shifted on purpose to points with lower
efficiency. This retardation of the spark timing results in lower efficiency and in higher
exhaust gas temperatures. It can be used, for instance, to heat up the TWC. For cold￾start control, fast heating is required, such that light-off temperatures are reached as
quickly as possible [7, 19]. The retardation of the ideal spark timing is also used
as an actuated value in knock control. For high-load operations, the so-called knock
can occur in an SI engine [47]. Knock is an unwanted autoignition phenomenon with
drawbacks in terms of noise and mechanical stress. First, the knocking combustion
has to be detected [3]. Based on this detection, the spark timing is adjusted by a
feedback controller in order to shift operation toward non-knocking combustion
again [32]. For knock control, the spark timing is adjusted on a cycle-to-cycle basis.
7.2.4 Control Structure
Figure 7.7 shows the structure of the resulting SI engine controller. All the main con￾trol tasks in normal operation are shown. It consists of the air-to-fuel ratio controller
via the duration of injection. Additionally, within the ignition path, the combustion
average CA50 is controlled via ignition timing. Within the air path, the intake man-7.2 SI Engine Control Systems 185
Fig. 7.7 SI engine control architecture (normal operation)
ifold pressure is controlled via the throttle and the wastegate of the turbocharger.
Although separate controllers are used, the important cross-couplings of the various
paths have to be considered. This is especially important when the system dynamics
occur on different timescales. For instance, the fuel amount always has to match the
inducted air mass which is managed by the air path controller. The TWC needs no
dedicated control loop, as it is a passive device.
Many more control loops are necessary to run an SI engine. This concerns the
low-level controllers such as the controllers for the wastegate opening position as
well as the auxiliary functions such as lubrication control, as mentioned in Sect. 7.1.
Additionally, there exists for instance the idle speed controller. Its goal is to provide
certain minimum engine torque to avoid engine stall. This is ensured by appropriate
closed-loop control of the engine speed [18]. For idle speed control also MPC-based
solutions are investigated [9, 10]. Some SI engines additionally contain devices for
waste heat recovery which have to be controlled as well [35].
7.3 CI Engine Control
The CI engine is characterized by a diffusion-controlled combustion of a lean mixture.
The fuel is usually injected directly into the cylinder. In a CI engine, the fuel is injected
much later than in a direct-injected SI engine, i.e. the injection timing is at the end
of the compression stroke, close to the top-dead center. Due to the compression, at
high pressures at this point, hot gas is present in the combustion chamber. A typical
condition is given by a gas temperature of 900◦C and pressure of 70 bar. As a result,
autoignition conditions exist, such that combustion starts already during the injection
process. As the time available for mixing is very limited, the charge is stratified such
that a high portion of the fuel is combusted in a diffusion-controlled manner, where
the mixing of the fuel and the air as well as the combustion occurs simultaneously.
Most CI engines run on diesel fuel. An alternative is the use of bio-fuels [1].186 7 SI and CI Engine Control Architectures
For the CI engine, a so-called qualitative load control is used. The load is not set
by adjusting the amount of air, as in SI engines, but instead by adjusting the amount
of fuel. Excessive air is present, as the engine is always operating in a lean mode.
The main advantage of qualitative load control is the possibility of an unthrottled
operation. This is very fuel-efficient as pumping losses are avoided. However, this
combustion approach has disadvantages concerning pollutant emissions, e.g. a high
amount of engine-out soot emissions can result. Especially for conditions with λ <
1.3, excessive soot emissions result. These operating conditions thus are generally
avoided [18]. As CI engines run in a lean operating mode, a TWC can no longer be
used to combat NOx, CO, and HC simultaneously. As a result, the aftertreatment of
the exhaust gases is more complex than in SI engines. Usually, a single device is not
enough for the exhaust gas aftertreatment, i.e. a combination of several aftertreatment
devices is used to combat the produced emissions, which causes higher costs and
higher complexity of the aftertreatment system.
Figure 7.8 shows an overview of a standard setup of a CI engine. It consists of
a direct-injection system with exhaust gas recirculation and turbocharging. For the
exhaust gas aftertreatment, a diesel particulate filter (DPF) is used in combination
with a selective catalytic reduction (SCR) system. In the following, the fundamental
control loops typical of the fuel path, the air path, and the aftertreatment path are
discussed. The ignition is controlled by the fuel path controller. Hence, no dedicated
control loop for the ignition path is necessary.
Fig. 7.8 Exemplary
structure of a turbocharged
CI engine7.3 CI Engine Control 187
7.3.1 Fuel Path Controller
The central actuator of the fuel path in a CI engine is the fuel injector. In the setup
shown, the fuel is injected directly into the cylinder with a single injection. At the late
injection timings, the combustion chamber pressure is so high already that autoigni￾tion occurs. Various technologies are available for fuel injection, such as piezo￾actuated valves or solenoid-actuated injectors [12]. Additionally, a fuel pump is used
to set the rail pressure of the injector [29]. The main parameters which are used as
actuated values are the fuel pump control valve position u f p and parameters from the
injector, i.e. the start of injection usoi and the duration of injection udoi . The actuated
values allow to strongly influence the combustion process. Influences can be made
in terms of the shape of the heat release profile, e.g. concerning combustion average,
the maximum pressure, and the maximum pressure rise gradient.
The injection pressure is one of the values that is closed-loop-controlled by low￾level controllers. For this purpose, a rail pressure sensor is available. The high￾pressure fuel pump is used to set the rail pressure as necessary. Sometimes, addition￾ally, a pressure release valve is used. The control loop dynamics for controlling the
rail pressure are in the order of milliseconds. Modern injection systems are able to
attain rail pressures of more than 2000 bar. An increased injection pressure results
in better fuel evaporation, a lower ignition delay, and faster burn rates. Figure 7.9
shows the influence of the injection pressure on the emissions levels of NOx and
particulate matter PM. The PM can be decreased by higher rail pressures, while the
NOx emissions are increased. At the same time, the increased rail pressure also leads
to decreased overall efficiency due to the energy needed for the fuel pump. The rail
pressure reference is usually set in a feedforward manner, depending on parameters
such as engine speed and load [21].
Besides the rail pressure, the start of injections usoi and the duration of injec￾tions udoi are used as actuated values inside the control algorithm. Earlier injection
timings lead to earlier combustion, a higher peak temperature, and higher peak pres￾sures. This effect leads to increased NOx emissions and lower levels of PM emissions.
Figure 7.9 shows the sensitivity of NOx and PM emissions for single injection on
start of energizing of the injector usoe, based on measurements taken on an engine
test bench. The parameter start of energizing of the injector usoe is related to the start
of injection usoi by a simple dead-time which accounts for the physical delay. The
parameter duration of injection udoi has to be set such that the requested torque is
delivered.
Both the parameters usoi and udoi can either be set in a feedforward manner or
can be adjusted via feedback control. In the case of feedback control, a sensor is
needed, for instance, an in-cylinder pressure sensor can be applied. State of the art in
combustion control is the control of a few cycle-integral surrogate parameters. Most
commonly, the indicated mean effective pressure (IMEP) and the combustion average
CA50 are used. These values can be extracted from the cylinder pressure signal. The
injection parameters usoi and udoi are set on a cycle-to-cycle basis for control. In more188 7 SI and CI Engine Control Architectures
Fig. 7.9 Influence of the injection parameters start of energizing and rail pressure on pollutant
emissions
advanced combustion control concepts, the quasi-continuous combustion profile is
controlled. Both control concepts are introduced in more detail in Sect. 14.1.
7.3.2 Air Path Controller
In the given CI setup, exhaust gas recirculation is used in combination with tur￾bocharging. The setup allows the guide vane position uvtg and the EGR valve posi￾tion uegr to be adjusted. These two actuated values have an influence on the intake
manifold pressure and the chemical composition of the intake in terms of the burnt
gas ratio and, respectively, the oxygen concentration.
The general functionality of the turbocharging was described in Sect. 7.2.1. A
common difference between SI and CI turbocharging is the function principle of
actuation. In CI engines, variable turbine geometry (VTG) is the standard for the
introduction of variability. The VTG allows the guide vane position to be changed,
which adjusts the flow conditions. Narrow vane openings lead to a higher intake
manifold pressure, while wide vane opening reduces them. With a VTG actuation, no
mass flow is bypassed, the flow characteristics are adjusted instead. The VTG allows
for a more accurate and easier control compared to a wastegate [14]. For durability
reasons, in SI engines VTG is usually not used as SI engines have higher exhaust gas7.3 CI Engine Control 189
temperatures than CI engines. The VTG actuator can be electric or electro-pneumatic
and typically incorporates a position sensor that allows for closed-loop control of the
guide vane position.
In the given setup, the exhaust gas can be recirculated from the exhaust manifold
to the intake manifold where it is mixed with fresh air. Due to the lean combustion
conditions, the exhaust gas consists of burnt gas and (unburnt) air. The burnt gas,
which consists mainly of N2, H2O, and CO2, is an inert gas. It lowers the oxygen
concentration of the gas inducted by the cylinder and increases the heat capacity of
the gas. As a result, the combustion temperatures, especially the peak temperature,
are lowered. High temperatures and excess oxygen, i.e. high air-to-fuel ratios lead
to the formation of NOx emissions [37]. Increasing burnt gas ratios xbg thus lead to
lower levels of NOx emissions. However, at the same time, the emission levels of
PM tend to increase. Figure 7.10 shows the measured sensitivity of the PM and the
NOx emissions to the burnt gas ratio xbg and the intake manifold pressure pim. The
CI-inherent PM versus NOx trade-off is clearly visible. If PM emissions are lowered,
NOx is increased and vice versa. The actuated value uegr allows the valve position in
the EGR path to be adjusted. As the gas flow to the intake manifold is driven by the
pressure difference, the valve allows it to be controlled. Often, poppet valves with
electric or electro-pneumatic actuation are used as EGR valves. Increased EGR rates
also slow down the combustion, which reduces the noise levels.
Fig. 7.10 Influence of the air path parameters burnt gas ratio and intake manifold pressure on
pollutant emissions190 7 SI and CI Engine Control Architectures
Along with the burnt gas ratio xbg, the intake manifold pressure pim can be used
as controlled values. These two values are sufficient to specify the two combustion
relevant parameters, namely the amount of oxygen O2 inducted into the cylinder
and the amount of burnt gas inducted into the cylinder. An increased intake mani￾fold pressure leads to more mass in the cylinder and higher cylinder pressures, and
it influences the shape of the heat release profile and thus parameters such as the
combustion average. The turbocharger speed, i.e. the mechanical limit of the tur￾bocharger, and the back pressure of the exhaust gas have to be considered as well.
Either an intake manifold pressure sensor or an air mass flow sensor can be used.
Additionally, a pressure difference sensor across the EGR valve is used. Together
with the information on the EGR valve position, its data is used to estimate the EGR
mass flow and thus also the burnt gas ratio. The relevant dynamics for turbocharging
are in the order of seconds. They are dominated by the turbocharger inertia and the
pressure dynamics of the volumes. For EGR, the relevant timescale for the dynamics
is slightly faster. Due to the strong cross-couplings, the MIMO system dynamics
have to be accounted for in order to obtain an appropriate control system.
7.3.3 Aftertreatment Path Controller
For achieving low tailpipe pollutant emissions, a combination of various exhaust gas
aftertreatment systems is usually used in CI engines. In the given setup, a DPF and
an SCR system are combined.
The DPF is used to mechanically filter the PM emissions. For its proper operation,
the fact has to be considered that the PM is stored in the filter. As soon as the
maximum allowable PM loading is exceeded, the PM emissions need to be oxidized.
The regeneration can either be passive, with an operation at high loads, or an active
regeneration can be applied [41]. For the latter, the exhaust gases have to be at a
temperature level of at least 550 ◦C [5]. A pressure difference sensor is used across
the DPF to estimate its loading. The critical timescale is given by the dynamics of
the DPF loading. The repetition of the active regeneration has to be conducted in the
timescale of hours to days.
Various in-cylinder as well as out-of-cylinder measures exist to increase the
exhaust gas temperature. The temperature raised is used to heat up the DPF and
the SCR system. In the given setup, an exhaust flap is used for actuation. Increasing
the exhaust temperature using the exhaust flap leads to higher exhaust gas back pres￾sure and subsequently to higher gas exchange losses and reduced overall efficiency.
By using the exhaust flap, the exhaust gas temperature can be adjusted in the order
of seconds. The change in the exhaust gas temperature leads to an increase in the
DPF temperature, which itself changes in the order of minutes.
To combat the NOx emissions, a urea solution is injected upstream of the SCR cat￾alyst with a dosing valve. The urea decomposes to ammonia NH3 which is absorbed
on the SCR surface. There, the ammonia reacts together with NOx to form N2 and
H2O. The NOx conversion efficiency ηSCR depends in a nonlinear fashion on the tem-7.3 CI Engine Control 191
Fig. 7.11 Schematic SCR
conversion efficiency in
dependence of SCR
temperature and ammonia
surface coverage ratio
perature of the SCR ϑSCR and on the surface coverage ratio ΘNH3 [31]. Figure 7.11
schematically shows the conversion efficiency in dependence of the two parameters.
The management of an appropriate SCR temperature and ammonia surface cover￾age poses a complex closed-loop control task [30, 43, 44]. Due to the complex MIMO
system behavior also MPC-based approaches are investigated [33]. High conversion
efficiency is required to achieve a sufficiently low NOx emission level. Simulta￾neously, a temperature-dependent maximum ammonia storage capacity has to be
considered as a constraint in the controller. If this maximum capacity is exceeded,
harmful NH3 slip results. The various sensors used to estimate the ammonia sur￾face coverage ratio include NOx sensors mounted before and after the SCR, an NH3
sensor, and temperature sensors [46]. The dynamics of changing the exhaust gas tem￾perature are in the order of seconds. As a result, the SCR temperature changes in the
order of minutes. The urea injection, in contrast, is a fast actuator, which allows the
surface coverage ratio to be adjusted within seconds. Usually, a combined controller
is used that considers both actuated values.
7.3.4 Control Structure
Figure 7.12 summarizes the structure of the CI engine controller with the main con￾trol tasks for normal operation. The fuel path controller influences the fuel mass
injected, the combustion average, and the rail pressure. The air path controller sets
the conditions in the intake manifold in terms of the pressure and the burnt gas ratio.
The aftertreatment path controller adjusts the temperature of the exhaust gas and the
SCR conversion efficiency. The ignition is controlled by the fuel path controller, thus
no separate control loop is present. Many more control loops are necessary to run a
CI engine. They include the low-level controllers such as those that control the valve
positions and those required for the auxiliary functions such as lubrication control.
Besides these, there are additional control tasks such as idle speed control and the
cold-start control. For cold-start control, on the one hand, the control system actively192 7 SI and CI Engine Control Architectures
Fig. 7.12 CI engine control architecture (normal operation)
heats up the SCR catalyst such that the light-off temperature is reached quickly. On
the other hand, the injection parameters are adjusted to ensure a combustion pro￾cess with low pollutant emissions even at cold ambient conditions [11]. In some CI
engine applications, especially in heavy-duty trucks, additional devices for waste
heat recovery are used. In these applications, closed-loop control plays an essen￾tial role. Due to the complexity of the task also MPC approaches are investigated
[15, 16, 24].
References
1. C. Arcoumanis, C. Bae, R. Crookes, E. Kinoshita, The potential of di-methyl ether (DME) as
an alternative fuel for compression-ignition engines: a review. Fuel 87(7), 1014–1030 (2008)
2. J. Asprion, O. Chinellato, L. Guzzella, Optimal control of diesel engines: numerical methods,
applications, and experimental validation. Mathematical Problems in Engineering (2014)
3. P. Bares, D. Selmanaj, C. Guardiola, C. Onder, A new knock event definition for knock detection
and control optimization. Applied Thermal Engineering 131, 80–88 (2018)
4. D. Chatterjee, O. Deutschmann, J.Warnatz, Detailed surface reaction mechanism in a three-way
catalyst. Faraday Discussions 119, 371–384 (2002)
5. P. Chen, J. Wang, Control-oriented model for integrated diesel engine and aftertreatment sys￾tems thermal management. Control Engineering Practice 22, 81–93 (2014)
6. M. De Cesare, M. Parotto, F. Covassin, S. Sgatti, Electric low pressure fuel pump control for
fuel saving, SAE Technical Paper, no. 2013-01-0339 (2013)
7. Y. Deng, H. Liu, X. Zhao, E. Jiaqiang, J. Chen, Effects of cold start control strategy on cold
start performance of the diesel engine based on a comprehensive preheat diesel engine model.
Appl. Energy 210, 279–287 (2018)
8. S. Di Cairano, A. Bemporad, I.V. Kolmanovsky, D. Hrovat, Model predictive control of mag￾netically actuated mass spring dampers for automotive applications. Int. J. Control 80(11),
1701–1716 (2007)
9. S. Di Cairano, D. Yanakiev, A. Bemporad, I.V. Kolmanovsky, D. Hrovat, An mpc design flow for
automotive control and applications to idle speed regulation, in IEEE Conference on Decision
and Control (2008), pp. 5686–5691References 193
10. S. Di Cairano, D. Yanakiev, A. Bemporad, I.V. Kolmanovsky, D. Hrovat, Model predictive
idle speed control: design, analysis, and experimental evaluation. IEEE Trans. Control Syst.
Technol. 20(1), 84–97 (2011)
11. W. Dressler, S. Ernst, Start and ignition assist systems, in Handbook of Diesel Engines,
(Springer, Berlin, 2010), pp. 377–386
12. W. Egler, R.J. Giersch, F. Boecking, J. Hammer, J. Hlousek, P. Mattes, U. Projahn, W. Urner,
B. Janetzky, Fuel injection systems, in Handbook of Diesel Engines (Springer, Berlin, 2010),
pp. 127–174
13. L. Eriksson, Spark advance for optimal efficiency, in SAE Transactions (1999), pp. 789–800
14. L. Eriksson, L. Nielsen, Modeling and control of engines and drivelines (Wiley, 2014)
15. E. Feru, F.Willems, B. de Jager, M. Steinbuch, Model predictive control of a waste heat recovery
system for automotive diesel engines, in International Conference on System Theory, Control
and Computing (2014), pp. 658–663
16. E. Feru, F. Willems, B. De Jager, M. Steinbuch, Modeling and control of a parallel waste heat
recovery system for EURO-VI heavy-duty diesel engines. Energies 7(10), 6571–6592 (2014)
17. J. Gerhardt, H. Hönninger, H. Bischof, A new approach to functional and software structure
for engine management systems – BOSCH ME7, in SAE Transactions (1998), pp. 1173–1184
18. L. Guzzella, C.H. Onder, Introduction to Modeling and Control of Internal Combustion Engine
Systems (Springer, 2010)
19. R. Hedinger, P. Elbert, C. Onder, Optimal cold-start control of a gasoline engine. Energies
10(10), 1548–1564 (2017)
20. J.B. Heywood, Internal Combustion Engine Fundamentals (McGraw-Hill Education, 2018)
21. R. Isermann, Engine Modeling and Control (Springer, 2014)
22. L. Johannesson, N. Murgovski, E. Jonasson, J. Hellgren, B. Egardt, Predictive energy manage￾ment of hybrid long-haul trucks. Control Eng. Pract. 41, 83–97 (2015)
23. B. Johansson, Fuels and combustion, in Biofuels from Lignocellulosic Biomass: Innovations
Beyond Bioethanol (Wiley, 2016)
24. M. Keller, M. Neumann, K. Eichler, S. Pischinger, D. Abel, T. Albin, Model predictive control
for an organic rankine cycle system applied to a heavy-duty diesel engine, in IEEE Conference
on Control Technology and Applications (2020)
25. K. Kim, K. Choi, K. Lee, K. Lee, Active coolant control strategies in automotive engines. Int.
J. Autom. Technol. 11(6), 767–772 (2010)
26. P. Kiwitz, C. Onder, L. Guzzella, Control-oriented modeling of a three-way catalytic converter
with observation of the relative oxygen level profile. J. Process Control 22(6), 984–994 (2012)
27. O. Leufvén, L. Eriksson, A surge and choke capable compressor flow model - validation and
extrapolation capability. Control Eng. Pract. 21(12), 1871–1883 (2013)
28. G. Mancini, J. Asprion, N. Cavina, C. Onder, L. Guzzella, Dynamic feedforward control of a
diesel engine based on optimal transient compensation maps. Energies 7(8), 5400–5424 (2014)
29. U. Projahn, H. Randoll, E. Biermann, J. Brückner, K. Funk, T. Küttner, W. Lehle, J. Zuern,
Fuel injection system control systems, in Handbook of Diesel Engines (Springer, 2010), pp.
175–191
30. C.M. Schär, C.H. Onder, H.P. Geering, Control of an SCR catalytic converter system for a
mobile heavy-duty application. IEEE Trans. Control Syst. Technol. 14(4), 641–653 (2006)
31. C.M. Schär, C.H. Onder, H.P. Geering, M. Elsener, Control-oriented model of an SCR catalytic
converter system, in SAE Technical Paper (2004)
32. D. Selmanaj, G. Panzani, S. van Dooren, J. Rosgren, C. Onder, Adaptive and unconventional
strategies for engine knock control. IEEE Trans. Control Syst. Technol. 27(4), 1838–1845
(2019)
33. J. Sowman, D.S. Laila, A.J. Cruden, P. Fussey, A. Truscott, A predictive control approach to
diesel selective catalytic reduction, in European Control Conference (2015), pp. 3073–3078
34. A. Thomasson, O. Leufvén, I. Criscuolo, L. Eriksson, Modeling and validation of a boost
pressure actuation system, for a series sequentially turbocharged SI engine. Control Eng. Pract.
21(12), 1860–1870 (2013)194 7 SI and CI Engine Control Architectures
35. P. Tona, J. Peralez, A. Sciarretta, Supervision and control prototyping for an engine exhaust gas
heat recovery system based on a steam rankine cycle, in IEEE/ASME International Conference
on Advanced Intelligent Mechatronics (AIM) (2012), pp. 695–701
36. S. Trimboli, S. Di Cairano, A. Bemporad, I.V. Kolmanovsky, Model predictive control for
automotive time-delay processes: an application to air-to-fuel ratio control. IFAC Proc. Vol.
42(14), 90–95 (2009)
37. H. Tschöke, A. Graf, J. Stein, M. Krüger, J. Schaller, N. Breuer, K. Engeljehringer,W. Schindler,
Diesel engine exhaust emissions, in Handbook of Diesel Engines(Springer, 2010), pp. 417–485
38. G. Vagnoni, M. Eisenbarth, J. Andert, G. Sammito, J. Schaub, M. Reke, M. Kiausch, Smart
rule-based diesel engine control strategies by means of predictive driving information. Int. J.
Engine Res. 20(10), 1047–1058 (2019)
39. C. Vermillion, K. Butts, K. Reidy, Model predictive engine torque control with real-time driver￾in-the-loop simulation results, in American Control Conference (2010), pp. 1459–1464
40. D. von Wissel, A. Husson, V. Talon, L. Lansky, D. Pachner, M. Uchanski, Reducing engine
calibration time and cost with model predictive control, in IAV Automotive Powertrain Control
Systems Conference (2014)
41. A. Walker, Controlling particulate emissions from diesel vehicles. Topics in Catal. 28(1), 165–
170 (2004)
42. T.T.Wang, J.Wagner, Advanced automotive thermal management-nonlinear radiator fan matrix
control. Control Eng. Pract. 41, 113–123 (2015)
43. F. Willems, R. Cloudt, Experimental demonstration of a new model-based SCR control strategy
for cleaner heavy-duty diesel engines. IEEE Trans. Control Syst. Technol. 19(5), 1305–1313
(2010)
44. F. Willems, R. Cloudt, E. Van Den Eijnden, M. Van Genderen, R. Verbeek, B. de Jager,
W. Boomsma, I. van den Heuvel, Is closed-loop SCR control required to meet future emission
targets? inSAE Technical Paper, no. 2007-01-1574 (2007)
45. F. Willems, P. van Gompel, X. Seykens, S. Wilkins,Robust real-world emissions by integrated
ADF and powertrain control development, in in: Control Strategies for Advanced Driver Assis￾tance Systems and Autonomous Driving Functions (Springer, 2019), pp. 29–45
46. X. Yuan, H. Liu, Y. Gao, Diesel engine SCR control: current development and future challenges.
Emiss. Control Sci. Technol. 1(2), 121–133 (2015)
47. X. Zhen, Y. Wang, S. Xu, Y. Zhu, C. Tao, T. Xu, M. Song, The engine knock analysis-an
overview. Appl. Energy 92, 628–636 (2012)Chapter 8
Low-Temperature Combustion Engine
Control
Abstract Besides conventional spark ignition (SI) and compression ignition (CI)
engines, low-temperature combustion (LTC) engines are investigated as an alter￾native combustion concept for use in engine systems. They hold promise to lower
pollutant emissions while achieving a high efficiency. The working principle is based
on the autoignition of a highly premixed charge. These properties come along with
increased demands for the process control. In this chapter, three possibilities to real￾ize LTC combustion are detailed. They are gasoline controlled autoignition (GCAI),
the diesel-based premixed charge compression ignition (PCCI), and the dual-fuel￾based reactivity controlled compression ignition (RCCI). The chapter focuses on
the requirements and challenges concerning the process control. They are specific
for each concept. For instance, depending on the fuel reactivity, different measures
are applied to realize LTC conditions. As a consequence, the system dynamics also
depend strongly on the setup.
8.1 Introduction to LTC Engines
The use of LTC in engines holds the promise to combine the advantages of SI and
CI engines. It can deliver a high efficiency and give rise to considerably reduced
engine-out emissions. The application of LTC to engines is still in the phase of
ongoing development. However, it gains increasing attention due to its advantages.
The various approaches to realize LTC are characterized by a large degree of
homogenization of the air–fuel mixture and the autoignition of the charge. The com￾bustion is initiated by almost simultaneous autoignition at several points in the com￾bustion chamber, leading to a combustion process without a defined flame front. This
combustion initiation is entirely different from that of SI engines where the charge
is ignited via spark and from CI engines where the combustion is triggered by the
(late) injection timing. Instead, a reactivity controlled reaction takes place, which is
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_8
195196 8 Low-Temperature Combustion Engine Control
initiated by the temperature increase in the compression stroke. As a consequence,
the chemical reaction kinetics play an important role. The heat release is associated
with the LTC kinetics, which has distinctive characteristics, such as the negative
temperature coefficient (NTC) regime [2]. In this regime, the reactivity decreases
even though the temperature in the cylinder increases. The LTC process is operated
in a highly diluted fashion, which can be achieved by high amounts of recirculated
exhaust gas and by an excess of air. Indeed, lean as well as stoichiometric conditions
can be used for the LTC combustion.
The LTC engine has a different operating range concerning temperature and air￾to-fuel ratio compared to a CI engine which significantly affects the pollutant for￾mation [10]. At high local temperatures and at conditions with an excess of air,
nitrogen oxides (NOx) are produced. The formation of soot occurs at moderate tem￾peratures with a low oxygen content. For a conventional CI engine, the injection of
fuel occurs very late in the compression stroke. From the CI concept, a stratified
charge follows with high local temperatures, which results in the formation of soot
and NOx emissions. In LTC, the regions of NOx and soot formation are avoided.
The highly diluted charge leads to reduced peak temperatures in the cylinder and,
due to the large degree of homogenization, rich regions in the combustion chamber
are avoided [57]. At the same time, a high efficiency can be achieved due to several
reasons. These are the reduction of pumping losses due to a dethrottled operation,
an almost constant-volume combustion, the possibility to apply high compression
ratios, the reduced wall heat losses because of the reduced temperatures, and the
higher ratio of specific heat due to the diluted charge (carbon dioxide CO2 has a
higher specific heat than oxygen O2) [64]. Another reason for dilution with EGR
is the slowdown of the combustion process. This reduces the pressure rise gradient
which, due to the bulk autoignition, for LTC, is higher than that of conventional SI
and CI engines.
The LTC combustion process is largely determined by the low-temperature chem￾ical reaction kinetics, while conventional combustion processes are determined by
the stabilizing mixture-controlled high-temperature reactions. As a consequence, the
LTC regime is characterized by a high sensitivity to the global and local thermody￾namic state in the system. Many parameters influence the sensitive thermodynamic
properties. They include the temperature, the chemical mixture composition, and
the turbulent flow field, which affects the local composition of the mixture and thus
the stratification. Depending on this thermodynamic state, very early combustion
with very high pressure rise gradients or very retarded combustion up to the point
of unwanted misfires can result. Consequently, the sensitivities pose challenges con￾cerning stability and undesired emissions. Since the resulting irregular combustion
behavior and increased emissions cannot be tolerated, the mastering of these sensi￾tivities is a major task for the practical application of LTC. Another challenge for
practical application is the limited operating range. With recent approaches, the LTC
combustion can only be applied for a small operating range, i.e. especially medium
load operating regions [52].8.1 Introduction to LTC Engines 197
Closed-loop control strategies are commonly used to respond to these sensitivities
arising in LTC engines. For conventional SI and CI combustion control, feedforward
control in combination with simple linear feedback concepts are usually sufficient.
Several controllers are applied that individually deal with specific control tasks, such
as combustion average control [56]. The LTC process is characterized by high sensi￾tivity, the difficulty to measure all relevant parameters during operation, and strongly
nonlinear system dynamics with strong interaction of the different in- and outputs.
These characteristics preclude such linear control approaches and the separate treat￾ment of individual phenomena. Instead, the strongly nonlinear MIMO dynamics as
well as the limitations of the actuating elements must be considered by appropri￾ate feedback control approaches [61]. In the most common approaches, the control
algorithm relies on the in-cylinder pressure trace, which is directly measured by an
in-cylinder pressure sensor [63].
For an appropriate control of the process, the entire MIMO system dynamics have
to be considered due to the strong nonlinear cross-couplings. Decentralized control
approaches, e.g. separate controllers for the indicated mean effective pressure (IMEP)
and the combustion average, are not sufficient, especially when the entire operation
envelope is considered. As control algorithms, a broad range of control concepts is
evaluated. Initial control concepts relied on gain-scheduled PID controllers [55]. In
recent approaches, model-based control strategies are used primarily. The model￾based control strategies show promising advantages to handle the complex system
dynamics. Various model-based control strategies are investigated, such as sliding
mode control [4], adaptive control [6], reference governor control [29], switching
control [40], and model predictive control (MPC) [13, 14, 44, 47]. Especially, the
optimization-based concepts show a high potential since limitations on the actuators
and on the outputs have to be considered and, in some cases, non-minimum phase
behavior is present.
For the LTC combustion process, the fuel plays an important role. In general, LTC
is applicable to a wide range of fuels, such as gasoline [32], diesel [5], hydrogen [1],
bio-fuels [34], and natural gas [17]. In addition, much research is conducted to design
specific fuels that are advantageous for LTC [39, 41]. From a control point of view,
most differences exist especially with regard to three different categories:
1. applications with fuels that are characterized by a low reactivity such as gasoline,
2. applications of LTC to fuels with high reactivity such as diesel,
3. applications where the reactivity of the fuel is actively changed to realize LTC,
especially by use of two different injection systems to gain an in-cylinder fuel
blending.
All three applications necessitate closed-loop control due to the sensitivities dis￾cussed. However, the control challenges are quite diverse and depend on the specific
setup. In the following, one setup of each category is discussed.198 8 Low-Temperature Combustion Engine Control
8.2 Gasoline-Based LTC: Gasoline Controlled Autoignition
In this subsection, the control challenges associated with the gasoline-fueled LTC
process are to be discussed. Various names are used in literature for this concept,
such as GCAI or homogenous charge compression ignition (HCCI). The abbreviation
GCAI for this combustion process will be used in the remainder of this text. Compared
to the conventional SI engine, the GCAI process allows for an engine efficiency that
is up to 25% higher than that of a conventional SI engine [60]. The main reason for the
efficiency increase lies in the possibility of an unthrottled operation, which reduces
the pumping losses. Additionally, GCAI produces almost no measurable soot and
NOx emissions due to the homogenization and the dilution with recirculated exhaust
gas [60].
Gasoline is a low-reactivity fuel, i.e. it is less reactive than diesel fuel. The gaso￾line fuel for SI engines is designed such that knocking, an unwanted autoignition
phenomenon, is prevented [20]. However, for GCAI, conditions have to be created
where autoignition of the gasoline fuel occurs in a controlled setting. There exist
different measures such as intake air heating [62], internal recirculation of exhaust
gas [30], external recirculation of exhaust gas [35], or the use of variable compres￾sion ratios [7] that are combined with an appropriate fuel injection strategy. In the
following, one exemplary realization of LTC conditions with internal exhaust gas
recirculation is described.
As the basic engine setup, a SI engine with a moderately increased compression
ratio is used. The main difference from conventional SI engines is the considerable
recirculation of hot internal exhaust gas. Specifically, the exhaust gas from the last
cycle delivers the thermal energy to initiate the compression-induced autoignition in
the current cycle. A major control task is the appropriate adjustment of this quantity
depending on the current operating point, which is characterized by the load, speed,
and ambient conditions for instance. Inappropriate amounts of internal exhaust gas or
thermal energy can lead to advanced combustion with exceeding maximum pressure
rise gradients, retarded incomplete combustion, or even misfire.
For the development of control systems, the amount of recirculated internal
exhaust gas can be varied by means of a variable valve train (VVT). Various valve
strategies can be applied to recirculate the internal exhaust gas with a VVT. A com￾monly used strategy is the so-called combustion chamber recirculation (CCR) where
the exhaust gas is trapped in the combustion chamber. Figure 8.1 shows the resulting
cylinder pressure trace along with the valve timings. Alternatively, the exhaust gas
can be trapped in the intake or exhaust port and recirculated from there [36]. The
strategies differ in terms of the maximum amount of exhaust gas that can be recircu￾lated and the properties of the mixture, such as the temperature. Depending on the
valve strategy used, differences result in terms of stability and operating range of the
combustion process that can be realized [36].
As mentioned above, all LTC concepts exhibit high sensitivities to the local and
global thermodynamic states, which generally requires feedback concepts. In the
case of GCAI, the particularity of a strong coupling of consecutive cycles must be8.2 Gasoline-Based LTC: Gasoline Controlled Autoignition 199
Fig. 8.1 Typical GCAI cylinder pressure trace along with actuated values
considered in the control algorithm. This strong coupling distinguishes the GCAI
process from the diesel PCCI and the dual-fuel RCCI process to be described below.
Due to the initiation of the combustion by the exhaust gas from the preceding cycle,
the quality of combustion in the current cycle directly depends on the combustion
process of the preceding cycle. This presents a considerable control problem at
stationary conditions (especially at the limits of the operating range) and even more
so for load transients.
The coupling of the combustion cycles is also called the memory effect. For
instance, the disturbances arising from one cycle are propagated to the next cycles.
Incomplete combustion in one cycle transfers HC molecules to the next cycle, which
can lead to advanced combustion. This again affects the subsequent cycle. The strong
coupling of consecutive cycles leads to a high tendency toward unstable process
behavior [23].
In the case of load transients, these memory effects can be observed in terms of the
dynamic behavior of the outputs, as depicted in Fig. 8.2. It shows a load transient that
is conducted from one stable operating point to another stable operating point. The
actuated values, i.e. exhaust valve closure (EVC) and the duration of injection (DOI),
are changed in a step-wise manner. Directly after the application of the step input, the
combustion phase is very retarded when increasing the load, leading to a temporarily
incomplete combustion until a steady state is reached again. For steps toward lower
loads, a very advanced combustion results with high pressure rise gradients. The
dynamic behavior in load transients is due to the change in initial condition from
a low temperature of the exhaust gas (at low loads) to higher temperatures of the
exhaust gas (at high loads). If the load transients are bigger, even misfires can occur
for a step-wise change in the actuated values. An appropriate control system has to
take this dynamic behavior into account.
At the boundaries of the operating range, even in the case of stationary operation,
combustion instabilities can be observed. In these operating points, the sensitivities
mentioned are higher, and simultaneously the stochastic, cyclic variations increase,
e.g. due to the turbulent flow field. The combination with the distinctive coupling of
consecutive combustion cycles leads to bifurcative system dynamics such as those200 8 Low-Temperature Combustion Engine Control
Fig. 8.2 Memory effect for load transients
known from chaotic systems [16, 22]. In Fig. 8.3, a schematic of such a bifurcative
behavior is depicted by showing the return maps of the combustion average CA50.
The return maps plot many measurements of the combustion average at cycle k + 1
in comparison to cycle k. The left-hand plot shows a stable GCAI operating point.
For constant input values, a certain expected value results which is overlapped by a
Gaussian-distributed white noise. The right-hand plot shows an unstable operating
point which is located close to the limits of the operating range. Instead of a stationary
behavior, various limit cycles are triggered by small disturbances. For an appropriate
application of GCAI, a suitable closed-loop control system is required.
8.2.1 Cycle-to-Cycle-Based Control Strategies
The conventional approach to deal with these kinds of combustion problems is the use
of a cycle-to-cycle-based control strategy, as shown in Fig. 8.4. It is characterized by
two aspects; frequency of actuation and time resolution of the controlled variables.
On the one hand, the actuated values are recalculated once every combustion cycle.
On the other hand, they are based on integral surrogate parameters that characterize an
individual engine cycle [15]. Important surrogate parameters include the following:8.2 Gasoline-Based LTC: Gasoline Controlled Autoignition 201
Fig. 8.3 Stable behavior (left-hand) and bifurcative behavior (right-hand) of GCAI combustion
Fig. 8.4 Cycle-to-Cycle combustion control strategy
• the IMEP as a correlator for the load,
• the combustion average, i.e. the crank angle position where 50% of the heat is
released (CA50) as an indicator for the efficiency, and
• the maximum pressure rise gradient (DPMAX) as an indicator for the noise.
These values are calculated based on sensor data obtained from the preceding cycle,
as explained in more detail in Sect.14.3. Typically, a cylinder pressure sensor is
used. Based on these surrogate parameters, the control algorithm determines the
actuated values for the subsequent cycle. In order to simultaneously affect the various
controlled values (IMEP, CA50, DPMAX), a combination of fuel path parameters
and valve timings is applied as actuated values. For the realization of CCR, the202 8 Low-Temperature Combustion Engine Control
VVT is used by an early closing of the exhaust valve, which leads to the desired
trapping of a part of the exhaust gas of the last combustion cycle in the combustion
chamber. By a symmetric adjustment of the timing of the closure of the exhaust valve
and of the opening of the intake valve, the negative valve overlap can be changed,
and thus, the amount of exhaust gas is adjusted. Additionally, a split injection of
fuel can be applied in the case of direct injection. The first injection is applied in
the recompression phase. This early injection leads to first chemical reactions. The
second injection is the main injection. The timing of the injections is usually fixed
and thus cannot be used for closed-loop control. The durations of the first injection
(DOI1) and of the second injection (DOI2) are applied in the closed-loop setting [51].
Several control approaches have attempted to also include the deterministic coupling
of subsequent cycles to reduce cyclic variations [21, 31].
A significant disadvantage of the GCAI process with cycle-to-cycle-based con￾trollers is its limitation to a rather small range of operation in which the LTC can
be stabilized [52]. Especially for the transient performance in practical applications,
small parameter changes near the boundaries of the window of operation can lead
to significant instabilities with adverse consequences for the combustion efficiency
and the emissions. This holds especially true if external exhaust gas recirculation or
turbocharging is used [37]. These are implemented for an extension of the operating
range. However, they increase the fluctuations in the initial conditions of combustion.
The major disadvantage of the cycle-to-cycle-based control approaches is the fact
that only the system dynamics and disturbances that occur on a cycle-averaged time
scale can be controlled. However, the delicate balance between chemistry and mix￾ture formation in the LTC process occurs on smaller time scales. Consequently, the
relevant physico-chemical processes determining the stability and emissions char￾acteristics of LTC cannot be controlled sufficiently under all arising circumstances
using a cycle-to-cycle-based controller with cycle-integral surrogate parameters.
8.2.2 Multi-scale Control Strategies
To overcome the drawbacks of cycle-to-cycle-based control strategies, multi-scale
control algorithms are being investigated. They allow smaller time scales to be con￾trolled than those possible with cycle-to-cycle-based control systems. Within multi￾scale control approaches, an in-cycle controller is used in addition to the cycle-to￾cycle controller. The in-cycle controller calculates feedback based on measurements
of the same combustion cycle. The architecture of such a multi-scale control approach
is shown in Fig. 8.5. An in-cycle controller can counteract disturbances arising within
the same cycle and can thus substantially increase the stability in critical operation
regions due to a faster feedback [59]. From a technical point of view, the in-cylinder
pressure has to be evaluated fast. One possibility to do this is the use of a FPGA
in order to determine the amount of unburnt fuel based on the pressure trace in
the recompression phase, which significantly affects the subsequent main combus￾tion [18, 60]. This information can be exploited for an in-cycle feedback that adjusts8.2 Gasoline-Based LTC: Gasoline Controlled Autoignition 203
Fig. 8.5 Multi-scale control architecture for combustion control
the main injection. Other possibilities for in-cycle actuation are the adjustment of
intake valve closure timing [38] or the use of direct water injection into the combus￾tion chamber [59].
8.3 Diesel-Based LTC: Premixed Charge Compression
Ignition
The LTC combustion can also be realized with diesel fuel, which is named PCCI
or diesel HCCI. In the following, the abbreviation PCCI will be used for the diesel￾based LTC process. In contrast to gasoline, diesel fuel is much more reactive. In
a conventional CI engine, the diesel fuel is ignited via autoignition. Compared to
conventional CI engines, the diesel-based LTC produces significantly less NOx due
to lower peak temperatures. It also produces lower soot emissions due to the high
degree of homogenization, while the fuel efficiency is approximately equivalent to
that of a conventional CI engine.
In order to achieve this high performance, the process has to fulfill several require￾ments. The combustion timing has to be set appropriately, which means that the
combustion should not take place either too early or too late. At the same time, the
formation of a suitable mixture has to be ensured. Ignition delay times that are too
short can lead to the formation of an incomplete mixture. Ignition delay times that
are too long can lead to high cyclic variations or even to complete misfires. A suf￾ficient homogenization of the mixture thus has to be ensured, while simultaneously
the unburned hydrocarbons (HC) and carbon monoxide (CO) emissions as well as
the combustion noise and high efficiency must be considered [53]. Concerning the204 8 Low-Temperature Combustion Engine Control
engine hardware, slightly modified conventional CI engines can be used. Modifica￾tions include the piston bowl geometry, for instance [42].
In order to establish the conditions discussed for PCCI, a lean mixture is applied.
In addition, high amounts of cooled exhaust gas are recirculated to decrease peak
temperatures and to increase the ignition delay times [48]. The high EGR rates also
slow down the combustion process, which positively affects the maximum pressure
rise gradient. As LTC combustion in general, the PCCI combustion is sensitive to
the local and global thermodynamic states. Due to this sensitivity, the control of the
air path becomes more important than it is in the conventional CI engine. Especially,
the rate of recirculated exhaust gas and the intake pressure have to be controlled
accurately and fast. The boundary condition of combustion is defined by the initial
cylinder condition with respect to pressure, chemical composition, and temperature.
Small deviations in these boundary conditions can lead to significant decreases in the
performance of the engine. This is especially the case for transient operation when
boundary conditions such as the EGR rate are changing quickly along with their
influence on the ignition delay, for instance. The overall process control also has to
take into account the cross-coupling of the air path and the combustion. A coordinated
control approach of the air path and the combustion process thus is necessary. Various
solutions exist, such as the use of a cascaded control law [12] or by taking into account
the cross-couplings of the air path parameters on the combustion controller [24].
As the air path controlled variables are too slow for cycle-to-cycle-based con￾trol, the actuated variables from the combustion have to be used for this purpose.
The combustion controller has to act very fast to ensure the appropriate PCCI con￾ditions under all circumstances. The main actuator for combustion control is the
fuel injector. Several possibilities exist to realize a high degree of homogenization.
One possibility for a single injection is to inject the fuel very early. However, this
approach allows suitable PCCI conditions only in a very narrow operating range. The
early fuel injection in combination with high injection pressures leads to distinctive
wall-wetting [3]. The initially low temperatures of the wall cause an incomplete
combustion, resulting in high amounts of HC emissions that exceed the allowable
range. Another challenge is the loss of the control authority as the injection timing
only has a small effect on the combustion timing for early injections with (almost)
homogeneous combustion [64].
Therefore, the application of a partially premixed charge is preferable for diesel￾fueled LTC. Low pollutant emissions can be realized for a wider range of operation,
while the combustion noise is decreased and a better controllability of the combustion
timing is achieved [65–67]. A common approach is the use of a multi-pulse fuel
injection strategy, which allows some portion of the fuel to be injected very early with
a high degree of homogenization [9, 50]. The typical approach to control the IMEP
and the combustion average CA50 is not sufficient for multi-pulse fuel injection.
Figure 8.6 shows three different combustion traces. They are realized by the three
injection strategies; single, double, and triple injection and still result in the same
values for IMEP and CA50. Although these two typical performance parameters are8.3 Diesel-Based LTC: Premixed Charge Compression Ignition 205
40
60
80
100
-20 -10 0 10 20 30
0
50
100
150
0
500
1000
Fig. 8.6 Three different cylinder pressure traces (1 vs. 2 vs. 3 injections) with the same combustion
average and load along with the injector voltage (dashed curve)
Table 8.1 Performance parameters for the three pressure traces depicted in Fig. 8.6
Number of Inj. IMEP [bar] CA50
[
◦CAaTDC]
η [%] NOx [ g
kW ] DPMAX
[bar/◦CA]
1 9 15 37.05 1.66 3.21
2 9 15 37.12 1.84 5.87
3 9 15 36.81 2.49 7.46
similar, the performance varies. Table 8.1 lists the differences in NOx, efficiency η,
and in the maximum pressure rise gradient DPMAX for the three traces.
Thus, the reference tracking of the two cycle-integral surrogate parameters, CA50
and IMEP cannot guarantee achieving high-performance combustion in the entire
operating range. Instead, controlled variables can be used that offer a higher resolu￾tion concerning the temporal development of the cylinder pressure or the temporal
development of the heat release in the engine, respectively. They allow more in-cycle
effects to be considered. This concept is called combustion rate shaping and can be
applied for conventional CI as well as for PCCI conditions. The combustion rate
shaping will be introduced in more detail in Sect. 14.4.206 8 Low-Temperature Combustion Engine Control
8.4 Dual-Fuel-Based LTC: Reactivity Controlled
Compression Ignition
An alternative approach to realize LTC combustion is the use of a dual-fuel concept.
Two different injection systems are applied to inject one fuel with a low reactivity
and one with a high reactivity. Changing the ratio of the two fuel masses is used to
appropriately blend the in-cylinder fuel. Thus, control-relevant parameters such as
the ignition delay and the reactivity of the overall charge can be adapted. Depending
on the conditions such as speed and required load, the fuel blending ratio can be
adjusted for satisfying LTC conditions with a suitable mixture formation as well
as appropriate combustion timings. As this ratio of the fuels can be adjusted on a
cycle-to-cycle basis, it allows for a fast closed-loop combustion control. The control
algorithm can be used for instance to reject disturbances and to allow for reference￾tracking in load-transient operation. This combustion concept is known under the
abbreviation RCCI [49]. The RCCI concept can be applied with a variety of different
fuel combinations. Examples are the combination of gasoline with diesel [8], ethanol
with diesel [54], and natural gas with diesel [43].
The mixing of natural gas with diesel offers several advantages. Natural gas con￾sists mainly of methane (CH4), which has a high hydrogen-to-carbon ratio and thus
causes inherently lower CO2 emissions to be formed during combustion. Methane
produces CO2 emissions of 55 g
MJ, whereas the long-chained hydrocarbon surro￾gate of diesel C15H28 emits 74.2 g
MJ and the surrogate for gasoline C7H15 emits
73.3 g
MJ CO2 emissions [33]. Thus, natural gas is able to lower CO2 emissions lev￾els by approximately 25% just due to its chemical structure. Also, methane can be
easily stored, transported, and it can be produced synthetically by power-to-gas pro￾cesses [19]. This feature allows surplus energy from fluctuating renewable energy
carriers to be stored. Methane is even less reactive than gasoline, which has bene￾fits in terms of the knock resistance, i.e. high compression ratios are feasible with
advantages in terms of efficiency.
Various technologies exist to ensure combustion in a methane engine, such as the
use of a spark plug. However, the use of a spark plug limits the applicability to a
certain range of air-to-fuel ratios, thus prohibiting a very lean operation. Alternatively,
methane can be ignited by the use of an additional diesel fuel injection. If diesel fuel
is used as an ignition source, the operating range concerning the air-to-fuel ratio is
much higher. The ignition energy of the diesel fuel can easily be adjusted by the
diesel fuel mass injected, with the possibility to also operate at very lean conditions.
A typical setup is the injection of methane into the intake port in order to gain
a premixed charge of air and methane. Diesel as a high reactivity fuel is injected
directly into the cylinder, as shown in Fig. 8.7.
The actuated values for closed-loop control are the duration of injection of
methane, the duration of injection of diesel, and the time of injection of the diesel
fuel. With these values, the load and the combustion timing are controlled. Compared
to combustion control in conventional diesel engines, one surplus degree of freedom8.4 Dual-Fuel-Based LTC: Reactivity Controlled Compression Ignition 207
Fig. 8.7 Engine setup with dual-fuel combustion – Reproduced from [26], originally published
open access under a Creative Commons CC BY 4.0 license, https://doi.org/10.3390/en10101450
remains. This degree of freedom can be optimized to achieve low emissions while
maintaining a high efficiency and specific ratios of methane-to-diesel fuel mass.
Depending on the timing of diesel injection, different combustion concepts result,
namely the diesel-ignited dual-fuel (DDF), the RCCI, and the diesel-minimum oper￾ation. Figure 8.8 shows the static behavior of the MIMO system. The combustion
average is plotted for various diesel injection timings and various substitutions rates
S R, i.e. the ratio S R = mgas
mdiesel+mgas . For sufficiently late diesel injections, a DDF
combustion results. The homogeneous methane–air mixture is burnt by flame prop￾agation resulting from the diesel pilot injection. This pilot ignition leads to mixing￾controlled combustion comparable to a conventional SI combustion. On the other
hand, the diesel can be injected very early, which leads to an RCCI combustion. The
autoignition of a highly premixed charge of methane, diesel, and air results. The
ignition delay is much longer than that of a DDF, such that enough time remains for
the mixture formation. In fact, the same combustion average can be achieved with
RCCI and DDF, although the timing of the diesel injection is very different. The third
principle possibility is the diesel-minimum operation. The minimum diesel fuel is
achieved at the minima of the parabolic curves in Fig. 8.8. Thus, for diesel-minimum
operation, the surplus degree of freedom is exploited to achieve a certain combustion
average and load with minimal substitution rate [68].
In all three combustion regions, DDF, diesel-minimum, and RCCI, different levels
of pollutant emissions, efficiency, and CO2 emissions result. The choice of the most
appropriate combustion regime depends on the specific application. For a reduction
of the NOx emissions, for instance, the RCCI region is most appropriate [11]. How￾ever, if the goal is to lower the emissions levels of CO2, the diesel-minimum operating
regime should be applied. For closed-loop control, it is important to take the non￾linearity of the process into account. This concerns especially the cross-coupling of208 8 Low-Temperature Combustion Engine Control
Fig. 8.8 Influence of diesel start of injection on combustion average
the various actuated values and also the reverse of the sign in the combustion timing
[28, 45].
In addition to the MIMO system dynamics described, further control challenges
arise in an RCCI operation. As in the case of diesel PCCI, the parameters of the air
path, especially the intake pressure and the recirculated exhaust gas, have a strong
effect on the amounts of pollutants emitted. Thus, it is important to control these
parameters accurately and fast. Additionally, the strong interaction between the air
path and the combustion has to be accounted for [58]. Another challenge arises as the
operating range of a dual-fuel engine is limited to medium and high loads [26]. At low
loads, the dual-fuel combustion cannot be used. Instead, a pure diesel combustion
has to be applied. The engine controller thus has to be capable also of operating in
pure diesel mode. Additionally, for load-transient operations, the switching between
operating modes (RCCI, DDF, pure diesel) has to be accomplished as well [25, 27].
The requirement is that switching between combustion modes can be achieved with￾out any degradation in torque and while avoiding peaks in the pollutant emissions.
The necessity to be able to operate the engine in dual-fuel and also in diesel mode
affects the injector as well. In a dual-fuel mode, only very small quantities of diesel
are injected. On the other hand, in a pure diesel mode, very high quantities can be
injected. The injector thus has to handle the entire range from very small to very
high fuel quantity injections. Especially, in the RCCI mode, where the combustion
is sensitive to the injection parameters, very high requirements exist on the injection
quality, such as a shot-to-shot reproducibility. In [46], an injector is presented where
the fuel amount injected is closed-loop-controlled in order to fulfill the requirements
arising. The closed-loop control of the injection quantity allows for drifts over a
lifetime to be compensated.References 209
References
1. J.G. Antunes, R. Mikalsen, A. Roskilly, An investigation of hydrogen-fuelled HCCI engine
performance and operation. Int.J. Hydrog. Energy 33(20), 5823–5828 (2008)
2. F. Battin-Leclerc, Detailed chemical kinetic models for the low-temperature combustion of
hydrocarbons with application to gasoline and diesel fuel surrogates. Progr. Energy Combust.
Sci. 34(4), 440–498 (2008)
3. H. Bendu, S. Murugan, Homogeneous charge compression ignition (HCCI) combustion: mix￾ture preparation and control strategies in diesel engines. Renew. Sustain. Energy Rev. 38,
732–746 (2014)
4. M. Bidarvatan, M. Shahbakhti, S. Jazayeri, C. Koch, Cycle-to-cycle modeling and sliding mode
control of blended-fuel HCCI engine. Control Eng. Pract. 24, 79–91 (2014)
5. A. Carlucci, D. Laforgia, S. Motz, R. Saracino, S. Wenzel, Advanced closed loop combustion
control of a LTC diesel engine based on in-cylinder pressure signals. Energy Convers. Manag.
77, 193–207 (2014)
6. C.-J. Chiang, C.-C. Chou, J.-H. Lin, Adaptive control of homogeneous charge compression
ignition (HCCI) engines, in American Control Conference (2012), pp. 2066–2071
7. M. Christensen, A. Hultqvist, B. Johansson, Demonstrating the multi fuel capability of a homo￾geneous charge compression ignition engine with variable compression ratio. SAE Trans.
2099–2113 (1999)
8. S. Curran, R. Hanson, R. Wagner, R.D. Reitz, Efficiency and emissions mapping of RCCI in a
light-duty diesel engine, SAE Technical Paper, no. 2013-01-0289 (2013)
9. W. de Ojeda, P. Zoldak, R. Espinosa, R. Kumar, Development of a fuel injection strategy for
partially premixed compression ignition combustion. SAE Int. J. Eng. 2(1), 1473–1488 (2009)
10. A.B. Dempsey, S.J. Curran, R.M. Wagner, A perspective on the range of gasoline compression
ignition combustion strategies for high engine efficiency and low NOx and soot emissions:
effects of in-cylinder fuel stratification. Int. J. Eng. Res. 17(8), 897–917 (2016)
11. E. Doosje, F. Willems, R. Baert, Experimental demonstration of RCCI in heavy-duty engines
using diesel and natural gas, SAE Technical Paper (2014)
12. P. Drews, T. Albin, F.-J. Hesseler, N. Peters, D. Abel, Fuel-efficient model-based optimal MIMO
control for PCCI engines. IFAC Proc. Vol. 44(1), 12 998–13 003 (2011)
13. K. Ebrahimi, C.B. Koch, Real-time control of HCCI engine using model predictive control, in
American Control Conference (2018), pp. 1622–1628
14. S.M. Erlien, A.F. Jungkunz, J.C. Gerdes, Multicylinder HCCI control with coupled valve
actuation using model predictive control. J. Dyn. Syst., Meas., Control 135 (2013)
15. M. Fathi, O. Jahanian, M. Shahbakhti, Modeling and controller design architecture for cycle￾by-cycle combustion control of homogeneous charge compression ignition (HCCI) engines -
a comprehensive review. Energy Convers. Manag. 139, 1–19 (2017)
16. C.E.A. Finney, B.C. Kaul, C.S. Daw, R.M. Wagner, K.D. Edwards, J.B. Green Jr., A review
of deterministic effects in cyclic variability of internal combustion engines. Int. J. Eng. Res.
16(3), 366–378 (2015)
17. D. Flowers, S. Aceves, C. Westbrook, J. Smith, R. Dibble, Detailed chemical kinetic simulation
of natural gas HCCI combustion: gas composition effects and investigation of control strategies.
J. Eng. Gas Turb. Power 123(2), 433–439 (2001)
18. D. Gordon, C. Wouters, M. Wick, F. Xia, B. Lehrheuer, J. Andert, C.R. Koch, S. Pischinger,
Development and experimental validation of a real-time capable field programmable gate array￾based gas exchange model for negative valve overlap. Int. J. Eng. Res. 21(3), 421–436 (2018)
19. M. Götz, J. Lefebvre, F. Mörs, A.M. Koch, F. Graf, S. Bajohr, R. Reimert, T. Kolb, Renewable
power-to-gas: a technological and economic review. Renew. Energy 85, 1371–1390 (2016)
20. L. Guzzella, C.H. Onder, Introduction to Modeling and Control of Internal Combustion Engine
Systems (Springer, 2010)
21. E. Hellström, J. Larimore, S. Jade, A.G. Stefanopoulou, L. Jiang, Reducing cyclic variability
while regulating combustion phasing in a four-cylinder HCCI engine. IEEE Trans. Control
Syst. Technol. 22(3), 1190–1197 (2014)210 8 Low-Temperature Combustion Engine Control
22. E. Hellström, A. Stefanopoulou, J. Vavra, A. Babajimopoulos, D. Assanis, L. Jiang, H. Yilmaz,
Understanding the dynamic evolution of cyclic variability at the operating limits of HCCI
engines with negative valve overlap, SAE Technical Paper (2012)
23. E. Hellström, A.G. Stefanopoulou, L. Jiang, Cyclic variability and dynamical instabilities in
autoignition engines with high residuals. IEEE Trans. Control Syst. Technol. 21(5), 1527–1536
(2013)
24. M. Hillion, J. Chauvin, N. Petit, Combustion control of an HCCI diesel engine with cool flame
phenomenon, in European Control Conference (2009), pp. 3827–3832
25. R. Hutter, S. Hänggi, T. Albin, C.H. Onder, Optimal transition control between combustion
modes in a diesel-ignited gas engine. Control Eng. Pract. 97, 104327 (2020)
26. R. Hutter, J. Ritzmann, P. Elbert, C. Onder, Low-load limit in a diesel-ignited gas engine.
Energies 10(10), 1450–1476 (2017)
27. A. Indrajuana, C. Bekdemir, E. Feru, F. Willems, Towards model-based control of RCCI-CDF
mode-switching in dual fuel engines, SAE Technical Paper (2018)
28. A. Indrajuana, C. Bekdemir, X. Luo, F. Willems, Robust multivariable feedback control of
natural gas-diesel RCCI combustion. IFAC-PapersOnLine 49(11), 217–222 (2016)
29. S. Jade, E. Hellström, J. Larimore, A.G. Stefanopoulou, L. Jiang, Reference governor for load
control in a multicylinder recompression HCCI engine. IEEE Trans. Control Syst. Technol.
22(4), 1408–1421 (2014)
30. S. Jade, J. Larimore, E. Hellström, A.G. Stefanopoulou, L. Jiang, Controlled load and speed
transitions in a multicylinder recompression HCCI engine. IEEE Trans. Control Syst. Technol.
23(3), 868–881 (2015)
31. A.F. Jungkunz, N. Ravi, H.-H. Liao, S.M. Erlien, J.C. Gerdes, An analytical method for reducing
combustion instability in homogeneous charge compression ignition engines through cycle-to￾cycle control. Int. J. Eng. Res. 16(3), 485–500 (2014)
32. G.T. Kalghatgi, P. Risberg, H.-E. Angström, Advantages of fuels with high resistance to auto￾ignition in late-injection, low-temperature, compression ignition combustion, SAE Technical
Paper (2006)
33. P.E. Kapus, A. Fuerhapter, H. Fuchs, G.K. Fraidl, Ethanol direct injection on turbocharged SI
engines – potential and challenges, SAE Technical Paper (2007)
34. N. Komninos, C. Rakopoulos, Modeling HCCI combustion of biofuels: a review. Renew. Sus￾tain. Energy Rev. 16(3), 1588–1610 (2012)
35. Y. Kugimachi, Y. Nakamura, N. Iida, Model-based combustion control of a HCCI engine using
external EGR and the exhaust rebreathed, SAE Technical Paper (2014)
36. O. Lang, W. Salber, J. Hahn, S. Pischinger, K. Hortmann, C. Bücker, Thermodynamical and
mechanical approach towards a variable valve train for the controlled auto ignition combustion
process. SAE Trans. 722–734 (2005)
37. B. Lehrheuer, B. Morcinkowski, S. Pischinger, M. Nijs, Low temperature gasoline combustion
– potential, challenges, process modeling and control, in Active Flow and Combustion Control
(Springer, 2015)
38. B. Lehrheuer, S. Pischinger, M. Wick, J. Andert, D. Berneck, D. Ritter, T. Albin, M. Thewes,
A study on in-cycle combustion control for gasoline controlled autoignition, SAE Technical
Paper (2016)
39. W. Leitner, J. Klankermayer, S. Pischinger, H. Pitsch, K. Kohse-Höinghaus, Advanced bio￾fuels and beyond: chemistry solutions for propulsion and production. Angewandte Chemie
International Edition 56(20), 5412–5452 (2017)
40. H.H. Liao, A. Widd, N. Ravi, A.F. Jungkunz, J.M. Kang, J.C. Gerdes, Control of recompression
HCCI with a three region switching controller. Control Eng. Pract. 21(2), 135–145 (2013)
41. X. Lu, D. Han, Z. Huang, Fuel design and management for the control of advanced compression￾ignition combustion modes. Progr. Energy Combust. Sci. 37(6), 741–783 (2011)
42. M.P. Musculus, P.C. Miles, L.M. Pickett, Conceptual models for partially premixed low￾temperature diesel combustion. Progr. Energy Combust. Sci. 39(2–3), 246–283 (2013)
43. D.E. Nieman, A.B. Dempsey, R.D. Reitz, Heavy-duty RCCI operation using natural gas and
diesel. SAE Int. J. Eng. 5(2), 270–285 (2012)References 211
44. E. Nuss, M. Wick, J. Andert, J. De Schutter, M. Diehl, D. Abel, T. Albin, Nonlinear model
predictive control of a discrete-cycle gasoline-controlled auto ignition engine model: simulative
analysis. Int. J. Eng. Res. 20(10), 1025–1036 (2019)
45. T. Ott, F. Zurbriggen, C. Onder, L. Guzzella, Cylinder individual feedback control of combus￾tion in a dual fuel engine. IFAC Proc. Vol. 46(21), 600–605 (2013)
46. E. Rauer, M. Rotter, M. Willmann, C. Senghaas, Intelligent injectors - digitization in the
injection technology of large engines. MTZ Worldwide 80(6), 58–65 (2019)
47. N. Ravi, H.H. Liao, A.F. Jungkunz, A. Widd, J.C. Gerdes, Model predictive control of HCCI
using variable valve actuation and fuel injection. Control Eng. Pract. 20(4), 421–430 (2012)
48. R.D. Reitz, Directions in internal combustion engine research. Combust. Flame 160(1), 1–8
(2013)
49. R.D. Reitz, G. Duraisamy, Review of high efficiency and clean reactivity controlled compres￾sion ignition (RCCI) combustion in internal combustion engines. Progr. Energy Combust. Sci.
46, 12–71 (2015)
50. S.Z. Rezaei, F. Zhang, H. Xu, A. Ghafourian, J.M. Herreros, S. Shuai, Investigation of two-stage
split-injection strategies for a dieseline fuelled PPCI engine. Fuel 107, 299–308 (2013)
51. D. Ritter, J. Andert, D. Abel, T. Albin,Model-based control of gasoline-controlled auto-ignition.
Int. J. Eng. Res. 19(2), 189–201 (2018)
52. S. Saxena, I.D. Bedoya, Fundamental phenomena affecting low temperature combustion and
HCCI engines, high load limits and strategies for extending these limits. Progr. Energy Combust.
Sci. 39(5), 457–488 (2013)
53. L. Shi, Y. Cui, K. Deng, H. Peng, Y. Chen, Study of low emission homogeneous charge com￾pression ignition (HCCI) engine using combined internal and external exhaust gas recirculation
(EGR). Energy 31(14), 2665–2676 (2006)
54. D. Splitter, R. Hanson, S. Kokjohn, R.D. Reitz, Reactivity controlled compression ignition
(RCCI) heavy-duty engine operation at mid- and high-loads with conventional and alternative
fuels, SAE Technical Paper (2011)
55. P. Strandh, J. Bengtsson, R. Johansson, P. Tunestal, B. Johansson, Cycle-to-cycle control of a
dual-fuel HCCI engine. SAE Trans. 589–598 (2004)
56. M. Thor, B. Egardt, T. McKelvey, I. Andersson, Closed-loop diesel engine combustion phasing
control based on crankshaft torque measurements. Control Eng. Pract. 33, 115–124 (2014)
57. H. Tschöke, K. Mollenhauer, R. Maier, Handbuch Dieselmotoren (Springer, 2017)
58. R. van der Weijst, T. van Keulen, F. Willems, Constrained multivariable extremum-seeking for
online fuel-efficiency optimization of diesel engines, in Control Engineering Practice (2019),
pp. 133–144
59. M. Wick, J. Bedei, D. Gordon, C. Wouters, B. Lehrheuer, E. Nuss, J. Andert, C.R. Koch, In￾cycle control for stabilization of homogeneous charge compression ignition combustion using
direct water injection. Appl. Energy 240, 1061–1074 (2019)
60. M. Wick, B. Lehrheuer, T. Albin, J. Andert, S. Pischinger, Decoupling of consecutive gasoline
controlled auto-ignition combustion cycles by field programmable gate array based real-time
cylinder pressure analysis. Int. J. Eng. Res. 19(2), 153–167 (2018)
61. A. Widd, H. Liao, H. Gerdes, J.C. Tunestal, R. Johansson, Hybrid model predictive control of
exhaust recompression HCCI. Asian J. Control 2, 370–381 (2014)
62. A. Widd, K. Ekholm, P. Tunestal, R. Johansson, Physics-based model predictive control of
HCCI combustion phasing using fast thermal management and VVA. IEEE Trans. Control
Syst. Technol. 20(3), 688–699 (2011)
63. F. Willems, Is cylinder pressure-based control required to meet future HD legislation? IFAC￾PapersOnLine 51(31), 111–118 (2018)
64. M. Yao, Z. Zheng, H. Liu, Progress and recent trends in homogeneous charge compression
ignition (HCCI) engines. Progr. Energy Combust. Sci. 35(5), 398–437 (2009)
65. L. Yin, M. Lundgren, Z. Wang, P. Stamatoglou, M. Richter, Ö. Andersson, P. Tunestål, High
efficient internal combustion engine using partially premixed combustion with multiple injec￾tions. Appl. Energy 233, 516–523 (2019)212 8 Low-Temperature Combustion Engine Control
66. L. Yin, G. Turesson, P. Tunestål, R. Johansson, Evaluation and transient control of an advanced
multi-cylinder engine based on partially premixed combustion. Appl. Energy 233, 1015–1026
(2019)
67. L. Yin, G. Turesson, T. Yang, R. Johansson, P. Tunestål, Partially premixed combustion (PPC)
stratification control to achieve high engine efficiency. IFAC-PapersOnLine 51(31), 694–699
(2018)
68. F. Zurbriggen, R. Hutter, C. Onder, Diesel-minimal combustion control of a natural gas-diesel
engine. Energies 9(1), 58 (2016)Part III
In-Depth Case Studies: Air Path ControlChapter 9
Fundamentals of Control-Oriented Air
Path Modeling
Abstract This chapter outlines the fundamentals of air path modeling for the pur￾pose of optimization-based control. First, an overview of the requirements is given.
To realize appropriate real-time optimization, a suitable trade-off is needed between
the accuracy of a model and its computational complexity. Additionally, if gradient￾based methods are applied for a numerical solution of the optimization problem,
models are required that are continuously differentiable. Gray-box modeling is pro￾posed as a suitable solution. Wherever it is computationally feasible, models based on
first principles are applied. When such first-principle models become very complex,
data-driven approaches are investigated instead. Based on these considerations, the
various components of the air path are reviewed and suitable models are proposed.
Among the components investigated are volumes, flow restrictions, and turbocharg￾ers.
9.1 Introduction to Control-Oriented Air Path Modeling
The air path of an engine can be modeled using various approaches. Depending
on the purpose of the model, one or another approach is preferable. In the context
of model predictive control (MPC), the main modeling challenge is the trade-off
required. While the accuracy of the model determines the quality of the closed-loop
control algorithm, the model still has to be simple enough to be useable in a real￾time optimization control setting. A common way to achieve real-time-feasibility,
especially when considering nonlinear models, is the use of powerful gradient-based
optimization methods. In order to make use of them, the model has to consist of
continuously differentiable functions. Additionally, the model has to be robust against
outliers. For instance, an outlier in a state estimation should not produce a division
by zero or the square root of a negative value during the calculation of the gradient.
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_9
215216 9 Fundamentals of Control-Oriented Air Path Modeling
In the following, the requirements on the control-oriented air path models are sum￾marized. Subsequently, the requirement of continuous differentiability is detailed.
Based on these fundamentals, common components of the air path are revisited in
order to highlight reasonable models for use within MPC. The purpose is twofold. On
the one hand, an overview of model equations is presented which have been proven
to work well in an MPC context. On the other hand, the goal is to demonstrate
that even with strong simplifications, models can be developed that are suitable for
a good reproduction of the system dynamics while allowing for real-time-feasible
optimization algorithms.
For use within MPC, nonlinear state-space models offer a suitable description of
the air path. The submodels have to be combined into a single model that describes
the entire air path. The various components are connected via their in- and outputs.
Most commonly, two different types of components are present. The first type can be
classified as a volume. Its internal states are pressure and temperature, and it requires
at least the in- and outflowing masses as model inputs. The other type consists of
the class of flow restriction models. These take the pressure states of the connecting
volumes as inputs and compute at the very least a mass flow through the restriction.
In most cases, the flow restriction models are connected to volumes and vice versa.
9.1.1 Requirements on Control-Oriented Air Path Models
In order to find applicable models, two important considerations are the timescale and
the spatial resolution to be modeled. If the goal is the geometrical design of certain
components such as the intake manifold or the piping, detailed simulations should
be conducted such as 3D CFD simulations. They can resolve processes with small
timescales. For instance, the dynamics resulting from the opening and closing of
the intake or exhaust valves are resolved. These are non-steady processes occurring
during the strokes, which introduce oscillations in the air path. However, if the target
application is the closed-loop control of the engine air path, these processes on a very
small timescale do not need to be considered. The dominant dynamics are given by
the dynamics of the turbochargers and the volumes. For quite some time, so-called
mean-value models thus have been the quasi-standard for control applications. A
good overview on this topic is given in [3, 5].
All mean-value models are characterized by only resolving the dynamics on
timescales that are relevant for control. Processes occurring on very small timescales
are not modeled, e.g. the dynamics mentioned resulting from the valve opening or
closing are one order of magnitude smaller than the turbocharger dynamics. If these
dynamics were considered as well, very stiff models would result that will introduce
unnecessary complexity. Furthermore, the mean-value models are always simpli￾fied such that spatial uniformity results. Instead of spatially resolving the dynamics,
developers thus lump together entire volumes. The modeling of a pipe results in a 0D
modeling approach, for instance. From a system-theoretic point of view, the models
are described by ordinary differential equations (ODE) instead of partial differential9.1 Introduction to Control-Oriented Air Path Modeling 217
equations (PDE). The models resulting from a simplification of spatially distributed
physical systems into discrete entities are called lumped-parameter models.
In order to find a reasonable trade-off between accuracy and complexity, gray￾box models are typically used. They represent the combination between physically
motivated white-box models and data-driven black-box models; see [9]. The white￾box models usually have better properties concerning their ability to be generalized.
In the best cases, a suitable process model is obtained by determining just a few
parameters, e.g. by system identification. The resulting models usually are strongly
nonlinear and represent multiple physical domains. For some physical processes,
simple white-box models do exist. However, for other processes, a physics-based
approach can result in a model that is too complex to be used within optimization￾based control systems.
One advantage of black-box models is the fact that they allow for the simulation
of complex nonlinear system dynamics with very low computational effort. Even
processes which result in complex physics-based models can be reproduced in a
computationally efficient manner with black-box models. Many black-box models
even are universal function approximators. If enough basis functions are used, they
can approximate any continuous function arbitrarily well. Various methods exist
to develop black-box models. Depending on the specific purpose, a tailor-made
black-box modeling approach should be used. Some of the examples are polyno￾mial models, Gaussian process models, neural networks, and local linear model
trees (LoLiMoT) [12]. The drawback of black-box models is their decreased capa￾bility for extrapolation. Additionally, enough data is needed to reproduce the system
behavior in an accurate manner. Those have to be obtained by measurements or via
simulations of complex models.
9.1.2 Continuous Differentiability
An important requirement is the continuous differentiability of the air path model.
This allows to use the powerful gradient-based optimization methods. For conven￾tional air path models, this requirement is often not that important. Hence, many
available air path models are not continuously differentiable. For instance, they often
contain “if-else” conditions and look-up tables.
Typically these expressions can be approximated by a continuously differentiable
function. Two examples are detailed in the following. First, “min” and “max” func￾tions are considered. These often occur when certain states are supposed to be above
or below a certain limit. For instance, limiting values of ylim to be greater than zero
can be expressed by
ylim(x) = max(x, 0) (9.1)
A continuously differentiable alternative with  chosen to be positive and close to
zero is given by218 9 Fundamentals of Control-Oriented Air Path Modeling
ylim,approx (x) = 1
2

x 2 +  + x
2 (9.2)
This approximation can also be used to prevent divisions by zero. If the replacement
function given in (9.2) is applied to the entire denominator, the minimum value is
always greater than zero up to numerical accuracy. A more generally approximation
can be set up, for the case that x is supposed to be greater than a value a.
ylim(x) = max(x, a) (9.3)
A continuously differentiable alternative with  chosen to be positive and close to
zero is given by
ylim,approx (x) = 1
2

(x − a)2 +  + (x + a)
2 (9.4)
Equivalently, the case can be handled that x is supposed to be smaller than a value a.
ylim(x) = min(x, a) (9.5)
A continuously differentiable alternative with  chosen to be positive and close to
zero is given by
ylim,approx (x) = −1
2

(x − a)2 +  + (x + a)
2 (9.6)
Besides enabling a continuous differentiability, these approximation functions can
also be used to increase the robustness of the model against outliers. It can be ensured
that a certain expression stays within a specific region.
Furthermore, piecewise functions exist in conventional air path models. They
typically occur when case distinctions are necessary, e.g. by if-else statements or
look-up tables. It is important to ensure a smooth transition between the various
regions. Sigmoid functions can be used to enable if-else statements in a closed-form
state-space description. The if-else statement can be approximated by a continuous
differentiable function by adding sigmoid functions. The sigmoid function is given
by
yr(x) =

1 + exp
−x − γ
δ
−1
(9.7)
In the state equation, all the cases are summed up with a weighting of either yr(x) or
(1 − yr(x)), depending on whether they belong to the if or the else statement. The
variable γ can be adapted to shift the sigmoid function to the left or the right. A proper
choice of γ allows the location of the case distinction to be reproduced. The slope
of the sigmoid function can be adjusted by the variable δ, which thus controls the
smoothness of the transition. Smaller values of δ lead to more steep transitions. The
continuous differentiable function replacement is demonstrated with one example.9.1 Introduction to Control-Oriented Air Path Modeling 219
Assume, the following if-else statement is given:
g(x) =

a(x), for x > xlim
b(x), for x ≤ xlim
(9.8)
The piecewise function (9.8) can be replaced by the following continuously differ￾entiable function, where δ = 1 is chosen:
gc(x) = 1
1 + exp(−(x − xlim))a(x) +

1 − 1
1 + exp(−(x − xlim))
b(x) (9.9)
9.2 Volume
Important components of the air path model are the volumes. Examples in an engine
system which can be described by this module are the intake and exhaust manifolds.
For the volumes, the potential variables are given by the mass and the energy. The
volume exchanges the flow variables, specifically the in- and the outflow of mass
and enthalpy with the connected components.
In order to develop a reduced-order model, several assumptions are made. The spa￾tial distribution inside the volumes is neglected, thus resulting in a lumped-parameter
model. The gas inside the volume is assumed to have constant gas properties. This
concerns especially cp and cv, which represent the specific heats at constant pres￾sure and constant volume, respectively. Additionally, the gas is assumed to be ideal,
meaning that it can be well approximated by the ideal gas law:
p(t)V = m(t)Rϑ(t) (9.10)
The volume is given by V, the pressure is denoted by p, the mass by m, and the
temperature by ϑ. The specific gas constant R = Ru
M is calculated by dividing the
universal gas constant Ru by the molar mass M. The relationship between R and the
specific heats can be expressed by R = cp − cv.
The dynamics of the volumes can be derived by the conservation laws of mass
and energy, which are shown in (9.11) and (9.12).
d
dt
m(t) = ˙min(t) − ˙mout(t) (9.11)
d
dt
U(t) = H˙in(t) − H˙out(t) − Q˙(t) (9.12)
Here, m˙ in(t) and m˙ out(t) correspond to the in- and outflowing masses, U(t) is the
internal energy, while H˙in(t) and H˙out(t) describe the enthalpy flows. The heat trans￾fer out of the volume is given by Q˙(t).220 9 Fundamentals of Control-Oriented Air Path Modeling
Pressure and Temperature
From a technical point of view, the pressure p(t) and the temperature ϑ(t) are the
most relevant parameters, as they can be directly measured. In the following reduced￾order models are derived for their calculations. The internal energy can be expressed
by the pressure and the temperature as follows:
U(t) = m(t)cvϑ(t) = 1
κ − 1 p(t)V (9.13)
The ratio of specific heats is given by κ, i.e. κ = cp/cv. The enthalpy flows can be
expressed with respect to the temperature, as shown in (9.14)–(9.15). The temperature
of the outflowing gas is set equal to that inside the volume.
H˙in(t) = ˙min(t)cpϑin(t) (9.14)
H˙out(t) = ˙mout(t)cpϑ(t) (9.15)
Substituting (9.13)–(9.15) in (9.12) yields
d
dt
 1
κ − 1 p(t)V

= ˙min(t)cpϑin(t) − ˙mout(t)cpϑ(t) − Q˙(t) (9.16)
Finally, for obtaining an expression describing the pressure dynamics, this equation
can be rearranged as follows:
d
dt
p(t) = κ − 1
V

m˙ in(t)cpϑin(t) − ˙mout(t)cpϑ(t) − Q˙(t)
 (9.17)
When deriving the equations for the temperature dynamics, the internal energy shown
in (9.13) has to be differentiated with respect to time.
d
dt
U(t) = cvϑ(t)
d
dt
m(t) + cvm(t)
d
dt
ϑ(t) (9.18)
The substitution in (9.12) yields
cvϑ(t)
d
dt
m(t) + cvm(t)
d
dt
ϑ(t) = ˙min(t)cpϑin(t) − ˙mout(t)cpϑ(t) − Q˙(t) (9.19)
Using the ideal gas law, the equation governing for temperature can be derived.
d
dt
ϑ(t) = Rϑ(t)
cv p(t)V

m˙ in(t)cpϑin(t) − ˙mout(t)cpϑ(t) − Q˙(t) − cvϑ

m˙ in(t) − ˙mout(t)
		
(9.20)
Heat Transfer
In some cases, the heat transfer Q˙(t) has to be accounted for, e.g. due to considerable
wall heat losses. A common approach to model the heat transfer is given by Newton’s9.2 Volume 221
law of heat transfer [7].
Q˙(t) = kvol Avol
ϑ(t) − ϑamb(t)
	
(9.21)
The parameter kvol represents the heat transmission coefficient, Avol the surface area
of the volume, and ϑamb the ambient temperature. However, often simplifications are
made regarding the heat transfer, as described below.
Adiabatic Model Simplification
A common assumption for volumes is the adiabatic model simplification. In this
case, the heat transfer is assumed to be zero, i.e. Q˙ = 0. The result is the adiabatic
model, where the two following equations result:
d
dt
ϑ(t) = Rϑ(t)
cv p(t)V

m˙ in(t)cpϑin(t) − ˙mout(t)cpϑ(t) − cvϑ

m˙ in(t) − ˙mout(t)
		
(9.22)
d
dt
p(t) = κ R
V

m˙ in(t)ϑin(t) − ˙mout(t)ϑ(t)
	
(9.23)
Isothermal Model Simplification
Another common assumption is the isothermal model simplification. In this case, the
temperatures are assumed to be constant, i.e. ϑin(t) = ϑamb(t) = ϑ(t). The equations
governing can be directly derived from the ideal gas law. Due to the isothermal
assumption, the pressure dynamics can be simplified to
d
dt
p(t) = Rϑ
V
d
dt
m(t)
= Rϑ
V

m˙ in(t) − ˙mout(t)
	
(9.24)
Gas Composition
In the case of exhaust gas recirculation, not only the pressure and the temperature
inside the volume are of interest, but also the gas composition in the volume. The
concentration of a species x is denoted as Fx . The term Fx is defined as the fraction
of the mass of species x denoted as mx of the total mass m.
Fx = mx
m (9.25)
The change of mass mx (t) in the volume can be expressed in relation to the concen￾tration Fx,in(t) of the inflowing and the concentration Fx (t) of the outflowing mass
flow. The concentration Fx (t) of the outflowing mass flow is set equal to that inside
the volume.
d
dt
mx (t) = Fx,in(t)m˙ in(t) − Fx (t)m˙ out(t) (9.26)222 9 Fundamentals of Control-Oriented Air Path Modeling
In order to calculate the change in the fraction Fx (t), the expression (9.25) needs to
be differentiated with respect to time:
d
dt
Fx (t) = m(t) d
dt mx (t) − mx (t) d
dt m(t)
m2(t) (9.27)
Substituting (9.11) and (9.26) in this equation leads to
d
dt
Fx (t) =
m(t)

Fx,in(t)m˙ in(t) − Fx (t)m˙ out(t)
	
− mx (t)

m˙ in(t) − ˙mout(t)
	
m2(t)
(9.28)
The equation governing for Fx (t) can be obtained, by inserting the relation mx (t) =
Fx (t)m(t) and the use of the ideal gas law to replace m(t).
d
dt
Fx (t) = Rϑ(t)
p(t)V

Fx,in(t) − Fx (t)
	
m˙ in(t) (9.29)
9.3 Engine
In the context of optimization-based air path control, the engine does not have to
be modeled in the detail level that the crank-angle-based dynamics are resolved; a
mean-value model is sufficient. A common approach is to model the engine as a
volumetric pump that enforces a continuous average volume flow [5]. Especially the
following quantities are of interest for control: the in- and out-mass flows of the total
gas, the gas composition of the mass flows, and the engine-out temperature.
Total Gas Mass Flow
Once per engine cycle, the displaced volume is aspirated from the intake manifold
into the cylinders. If the entire volume were displaced, the average mass flow m˙ asp,th
given in (9.30) would result.
m˙ asp,th (t) = ρim(t)V˙(t) = pim(t)
Rϑim(t)
neng(t)
N
Vdis (9.30)
It involves the pressure in the intake manifold pim, the specific gas constant R, and the
temperature in the intake manifold ϑim. The displacement volume of all the cylinders
combined is given by Vdis, which is divided by the number of revolutions per cycle
N with N = 1 for a two-stroke engine and with N = 2 for a four-stroke engine. The
engine speed neng is given in revolutions per second. The first term represents the
density of the gas inside the intake manifold:
ρim(t) = pim(t)
Rϑim(t) (9.31)9.3 Engine 223
However, in reality, the volume is not displaced entirely due to effects such as pressure
oscillations in the intake and exhaust port, the internal exhaust gas recirculation, or the
influences among the cylinders. To account for these losses, the volumetric efficiency
ηv is introduced, which describes the effectiveness of the gas aspiration.
m˙ asp(t) = ηvρim(t)V˙(t) = ηv
pim(t)
Rϑim(t)
neng(t)
N
Vdis (9.32)
Modeling the volumetric efficiency ηv in a physical manner is very difficult due to
numerous underlying processes. Data-driven approaches thus are usually applied
instead. For the parameter identification of ηv, steady-state measurements are con￾ducted at various conditions. The parameter ηv can be assumed to be constant. Alter￾natively, for a more accurate modeling, it can be modeled as a function that depends
on parameters such as the engine speed neng, the intake manifold pressure pim, the
intake manifold gas density ρim, the exhaust manifold pressure pem, or the pres￾sure ratio over the engine pem
pim . For a function, low-order polynomials yield good
approximations [3], such as
ηv = f

neng, ρim, pim, pem (9.33)
In the case of port-fuel injection, it is reasonable to assume that the aspirated mass
flow calculated by (9.32) consists of the entire fuel mass injected m˙ f uel as well as
fresh air and potentially recirculated exhaust gas, consisting of air and burnt gas. The
engine-out mass flow m˙ eo is equal to this aspirated mass flow m˙ asp.
m˙ asp = ˙mair,asp + ˙mbg,asp + ˙m f uel (9.34)
m˙ eo = ˙masp (9.35)
For the case of a direct-injection engine, the aspirated mass flow only consists of
fresh air and perhaps some recirculated exhaust gas. The engine-out mass flow is
given by the aspirated mass flow m˙ asp and the fuel mass injected into the cylinder
m˙ f uel :
m˙ asp = ˙mair,asp + ˙mbg,asp (9.36)
m˙ eo = ˙masp + ˙m f uel (9.37)
Gas Composition of the Mass Flow
When exhaust gas recirculation is applied, not only the total gas flow is of rele￾vance but also its composition. In the case of a stoichiometric operation, a complete
combustion with an air-to-fuel equivalence ratio of λ = 1 can be assumed. Thus, all
exhaust gas is burnt gas. The burnt gas is defined to be the products from combustion,
i.e. mainly CO2, H2O, and N2. As a consequence, the following engine-out mass flow
concentrations result:224 9 Fundamentals of Control-Oriented Air Path Modeling
FO2,eo = Fair,eo = 0 (9.38)
Fbg,eo = 1 (9.39)
In fact, for stoichiometric operation, controlling the exhaust gas fraction and the
oxygen fraction in the intake manifold is equivalent. Consequently, either of the two
can be tracked.
For controlling the combustion process of a lean burning engine, such as a CI
engine, it is advantageous to not only know the amount of recirculated exhaust gas but
also its chemical composition. Due to the lean operation, the recirculated exhaust gas
consists of burnt gas, which does not contain oxygen, as well as unburnt air, which
does contain oxygen. The varying amounts of oxygen in the recirculated exhaust
gas can participate in the subsequent combustion process. As a result, it is advisable
to track either the oxygen fraction or the burnt gas fraction in the various volumes
rather than the exhaust gas fraction. The two values, oxygen fraction FO2 and the
burnt gas fraction Fbg, can be converted into each other by taking into account the
mass fraction of oxygen in the air FO2,air, which for typical ambient conditions is
FO2,air = 0.23:
Fbg = 1 − FO2
FO2,air
(9.40)
As the lambda sensor can measure the oxygen content, the use of oxygen fraction or
burnt gas fraction has slight advantages compared to the tracking of the air fraction.
The total engine-out exhaust gas can be split up into the engine-out burnt gas fraction
Fbg,eo and the engine-out air fraction Fair,eo.
Feg = Fbg,eo + Fair,eo = 1 (9.41)
The air fraction Fair can be converted to the oxygen fraction FO2 by
FO2 = Fair FO2,air (9.42)
The engine-out air fraction Fair,eo and the engine-out air mass flow m˙ air,eo directly
depend on the air-to-fuel equivalence ratio λ of the combustion process. In order
to calculate these values, the air remaining after combustion needs to be calculated
with AFRs being the stoichiometric air-to-fuel ratio. For direct-injection engines, it
results:
m˙ air,eo = ˙maspFair,im − ˙m f uel AFRs = ˙maspFair,im 
1 − 1
λ

(9.43)
This yields the oxygen fraction flowing out of the cylinder:
Fair,eo = m˙ aspFair,im − ˙m f uel AFRs
m˙ eg
(9.44)9.3 Engine 225
Correspondingly, the engine-out oxygen fraction can be calculated:
FO2,eo = m˙ aspFO2,im − ˙m f uel AFRs FO2,air
m˙ eg
(9.45)
Engine-Out Temperature
The temperature of the exhaust gas flow out of the engine ϑeo depends on numerous
parameters, such as the engine speed, the engine load, the air-to-fuel ratio, the amount
of recirculated exhaust gas, and the spark timing in SI engines or the injection timing
in CI engines. Due to the many processes involved, the physical modeling is quite
complex. The data-driven approach is also quite demanding due to the measurement
situation characterized by the hot temperatures and the unsteady flow conditions.
Hence, simple models for ϑeo are used often within MPC.
Typically, data-driven approaches are applied where the temperature only depends
on a few parameters. One simple formulation is given in [3] for the case of a standard
SI engine which is run at optimal spark timing and with λ = 1. The engine-out
temperature is modeled to be linearly dependent on the engine-out mass flow. In
the model, the values of ϑeo,0 and the proportionality constant k are fitted to data
obtained on a testbench.
ϑeo = ϑeo,0 + k m˙ eo (9.46)
Another approach to model the engine-out temperature is the use of a polynomial
function f that depends on the engine speed neng and the fuel mass flow m˙ f uel :
ϑeo = f

neng, m˙ f uel (9.47)
9.4 Flow Restriction Model
In the following, models are described for components that restrict the airflow. The
driving potential for the mass flow is the difference between the upstream pressure
pus and the downstream pressure pds. There are many components in the air path
which can be described by this module, e.g. passive devices such as air filters and
intercoolers. Also, there are components among these that are used for actively
controlling the gas flow, such as valves and throttles. In general, there exist two types
of flow restriction models, and they are distinguished by whether the gas is assumed
to be incompressible or compressible. Within the engine, this differentiation mainly
depends on the speed of the gas within the component [3]. The incompressible flow
restriction model is used when small gas velocities are present, i.e.the speed of the
gas through the component is well below 30% of the speed of sound; see [5]. The
compressible flow restriction model is used when this limit is surpassed.226 9 Fundamentals of Control-Oriented Air Path Modeling
9.4.1 Incompressible Flow Restriction Model
The components which can be represented well by the incompressible flow restriction
model are characterized by small gas velocities within the component. Typically, a
small pressure ratio or a large cross-section area is present. Several components exist
in the air path which can be described by this model, such as air filters, intercool￾ers, and the exhaust gas aftertreatment systems. For deriving the equations, various
assumptions are made such as no friction in the flow, zero-dimensional flow phenom￾ena, and isolated conditions. With these assumptions, Bernoulli’s law can be applied
to derive (9.48); see [6] for details.
m˙(t) = cd A


2
Rϑus(t)
pus(t)ψ
Π (t)
	
(9.48)
The discharge coefficient is denoted by cd , and A is the reference flow area. Although
the discharge coefficient cd generally is not constant because it depends e.g. on the
pressure ratio, the variations are usually very small, such that it can be assumed to
be constant. Generally, the factor cd A is used as a parameter which is identified to
fit the measurement data. For incompressible flow restriction models, the so-called
flow function ψ depends on the pressure ratio Π over the component. The pressure
ratio is defined as
Π = pds
pus
(9.49)
The flow function ψ can be determined by
ψ = √
1 − Π (9.50)
This relation cannot be directly used within the nonlinear MPC (NMPC) concept.
The flow function presented is not defined for values of Π > 1, and for Π = 1,
the derivative approaches infinity, i.e. pus = pds. The function ψ(Π ) thus does not
fulfill the Lipschitz condition, which is needed for the existence and uniqueness of
the solution. In order to use the function within NMPC, it needs to be slightly adapted
such that continuous differentiability and the Lipschitz condition are fulfilled. One
suitable approximation of the flow function is given by
ψapprox =  flim (1 − Π) (9.51)
flim(x) = 1
2

x 2 +  + x
2 (9.52)
The changes in the potential and kinetic energy are sufficiently small that they can
be neglected. Thus, there is no temperature change in the flow restriction model [3].
ϑds = ϑus (9.53)9.4 Flow Restriction Model 227
9.4.2 Compressible Flow Restriction Model
Compressible flow restriction models are well suited for components with large gas
velocities. Typically, large pressure ratios or small cross-section areas are present in
this case. Examples where these models are commonly used are throttles, valves,
turbine wastegates, and compressor bypasses. In these components, the gas velocity
can go up to the speed of sound for a nearly closed position of the actuator. The
effects of compressibility in the gas thus become significant when the mass flow
is considered. The mass flow of the compressible flow restriction model can be
described by the following model, as derived in detail in [6]. As in the case of
the incompressible flow restriction model, the changes in the temperature can be
neglected.
ϑds = ϑus (9.54)
The mass flow is calculated by
m˙(t) = cd A pus(t)
√Rϑus(t)
ψ (Π (t)) (9.55)
The factor cd is assumed to be constant and is used as a parameter which is identified
to fit the measurement data. The model is often applied for components which allow
for an active control of the gas flow by changing the effective opening area. Thus,
the opening area is usually a function of the actuated value A(t) = f (u(t)), which
is set by the controller.
For calculation of the flow function, two cases are distinguished, i.e. pressure
ratios smaller and bigger than the critical pressure ratio. The critical pressure ratio
Πcr is defined to be
Πcr =
 2
κ + 1
 κ
κ−1
(9.56)
For pressure ratios Π smaller than Πcr, the flow can be considered to be choked.
In this case, the gas velocity is limited by the speed of sound in the gas. The flow
function ψ(Π ) for the compressible flow restriction model is given by
ψ (Π) =
⎧
⎪⎨
⎪⎩

κ ·
 2
κ+1
 κ+1
κ−1 , Π ≤  2
κ+1
 κ
κ−1
Π 1
κ

2κ
κ−1 ·

1 − Π κ−1
κ
	
, Π>  2
κ+1
 κ
κ−1
(9.57)
This compressible flow restriction model cannot be used directly within the NMPC
approach. It is defined in a piecewise manner. On top, it is not defined for Π > 1,
and the Lipschitz condition is not fulfilled. To overcome these issues, the function
needs to be adapted. The formulation in (9.57) can be transformed to the following
equivalent relation:228 9 Fundamentals of Control-Oriented Air Path Modeling
ψ (Π) = Π 1
κ
a
 2κ
κ − 1 ·

1 − Π κ−1
κ
a
	
, Πa = max (Πcr, Π) (9.58)
This allows the derivation of a suitable approximation, which is usable within NMPC:
ψapprox (Π) = Π 1
κ
a,lim 2κ
κ − 1 flim 
1 − Π κ−1
κ
a,lim	
Πa,lim = 1
2

(Π − Πcr)2 + 1 +
Π + Πcr
2
flim(x) = 1
2

x 2 + 2 + x
2
(9.59)
9.5 Turbocharger
As described in Sect. 7.2, a turbocharger consists of a compressor and a turbine
which are connected by a common shaft. In the following, control-oriented models
for turbine and compressor are investigated.
9.5.1 Compressor
Historically, turbocharging components often have been studied by looking at dimen￾sionless quantities [13]. A remainder of that view are the corrections used to nor￾malize the mass flow and the rotational speed. Both quantities are normalized with
respect to the inlet temperature ϑus and pressure pus, such that the process behavior
can be compared across various operating conditions. Thus, the complexity of the
models and the amount of measurement data needed to characterize their behavior
can be reduced. The corrections are shown in (9.60) and (9.61). In these equations,
the reference values for temperature and pressure are defined by the inlet conditions
at which the tests were conducted. For compressors, these typically are ϑref = 20%
and pref = 1bar.
m˙ c,corr(t) = ˙mc(t)


ϑus(t)
ϑref (t)
pref
pus(t) (9.60)
ntc,corr(t) = ntc(t)


ϑref
ϑus(t) (9.61)
The pressure ratio over the compressor Πc is described by (9.62). In normal operation,
the pressure ratio Πc is greater than one.9.5 Turbocharger 229
Πc(t) = pds(t)
pus(t) (9.62)
Compressing the intake gas requires energy that is delivered to the compressor by a
rotational momentum. Therefore, the model of the compressor has to compute the
power consumed during the compression process as well as the gas conditions down￾stream of the compressor. When modeling the compression process, an isentropic
process is typically used as a reference. The value ηc expresses the efficiency of the
compressor to represent further losses compared to the isentropic reference. Based
on the equation for power Pc = ˙mcΔh and the standard enthalpy difference equation
Δh = cpΔϑ, the equations for temperature ϑds and power consumption Pc can be
derived:
ϑds(t) = ϑus(t) +
ϑus(t)
ηc
·
 pds(t)
pus(t)
κ−1
κ
− 1

(9.63)
Pc(t) = cpm˙ c(t)
ϑus(t)
ηc
·

Π κ−1
κ
c (t) − 1
	
(9.64)
The compression is characterized by the interplay between the mass flow through
the compressor m˙ c, the pressure ratio Πc, the turbocharger speed ntc, and the effi￾ciency of operation ηc. A compressor map graphically represents the operation of
a turbocharger described by these four main quantities. Figure 9.1 shows a typical
compressor map. The pressure ratio is shown on the y axis. The x axis shows the cor￾rected mass flow through the compressor. The dotted lines indicate operating points
with the same corrected turbocharger speed, while the efficiency of the compression
process is shown by the solid isolines. The data for generating these compressor
maps can typically be obtained from the component supplier.
Compressors have limited operating regions that depend on their design. In the
compressor map shown, the operating region is bounded by several limits. The right
dashed line presents the choke limit. It is characterized by the maximum mass flow
the compressor can manage. The velocity of the fluid reaches the speed of sound
in the narrowest passage of the compressor and thus cannot be further increased.
The left dashed line presents the surge limit. Operating points to the left of this limit
are unstable, and the compressor has to transport the intake gas against a pressure
ratio that is too high. If the turbocharger speed is insufficient to internally maintain
a pressure as high as the back pressure, the direction of the flow is reversed and the
gas flows backward through the compressor until the flow is stabilized again. Such a
cyclic behavior can cause serious damage to the compressor. A detailed study of the
surge behavior in compressors is described in [4]. There are also limits concerning
the rotational speed of the turbocharger. Operation above the maximum speed limit
leads to mechanical damage. At zero rotational speed, the compressor is blocking
and acts as a flow restriction.
Modeling a compressor is difficult because the four quantities efficiency, pressure
ratio, mass flow, and turbocharger speed that describe the operating point are coupled230 9 Fundamentals of Control-Oriented Air Path Modeling
Fig. 9.1 Compressor map –
Reproduced from [2],
originally published open
access under a Creative
Commons CC BY 4.0
license, https://doi.org/10.
3390/en9070530
in a nonlinear fashion. Data-based models are used typically to represent this process
behavior. In the following models for the efficiency, the compressor mass flow and
the direct calculation of the pressure ratio are revisited.
Efficiency
The authors of [5] develop a simplified model to describe the compressor efficiency
ηc in dependence of the corrected compressor mass flow and the pressure ratio. For
normal operation, the functions shown in (9.65) and (9.66) are proposed. Within this
model, the matrix Q ∈ R2x2 is used for the parametrization of the model. In total,
seven parameters are contained, namely the matrix Q, and the parameters at optimal
operation ηc,opt , Πc,opt , and m˙ c,corr,opt .
ηc(Πc(t), m˙ c,corr(t)) = ηc,opt − XTQ X (9.65)
XT = [Πc(t) − Πc,opt, m˙ c,corr(t) − ˙mc,corr,opt] (9.66)
The seven parameters have to be fitted to either measurement data gained during
engine operation or to the compressor map delivered by the supplier.9.5 Turbocharger 231
Mass Flow
The compressor mass flow can be modeled as a function in dependence of the tur￾bocharger speed and the pressure ratio. Within the overall model, the compressor
module is connected to a volume on the inlet and the outlet, such that the pressure
ratio serves as an input for the calculation. Various data-driven models have been
proposed such as neural networks and multivariate polynomials [10]. To achieve a
low-order polynomial model, the corrected mass flow can be calculated in depen￾dence of the corrected turbocharger speed and the pressure ratio:
m˙ c,corr(t) = f (Πc(t), ntc,corr(t)) (9.67)
The parameters of the multivariate polynomial have to be fitted to either measurement
data or to the compressor map. Attention has to be paid when using the compressor
maps. They are typically measured at a gas test bench. For several reasons, they do
not precisely reflect the behavior of the turbocharger in an engine installation, e.g.
due to different conditions of operation [8].
Approximation of the Compressor Pressure Ratio
Alternatively to calculating the mass flow through the compressor, in some applica￾tions, the compressor pressure ratio can be directly calculated. In [11], the authors
identify a strong linear relationship between the pressure ratio Πc and the squared
corrected turbocharger speed n2
tc,corr, which itself correlates to the kinetic energy.
This model is extended in [1] by taking into account the engine speed neng. The
resulting model is given by
Πc(t) = n2
tc,corr(t) − b neng(t) − d
a neng(t) + c (9.68)
In some applications, this can be simplified to
Πc,simp(t) = n2
tc,corr(t) − bsimp
asimp
(9.69)
The parameters a, b, c, d resp. asimp, bsimp are determined by identification with
measurement data. Figure 9.2 shows such a correlation for two different compressors.
The measured behavior of the compressor (a) can be reproduced very well with the
model given in (9.68). For the compressor (b), the engine speed dependency can be
neglected, such that (9.69) results in a very good correlation.
The reasoning for the quality of the fit is detailed in Fig. 9.3 where the compressor
map is shown along with engine operating points for the compressor (a) in Fig. 9.2.
For low mass flows m˙ c,corr, the lines of constant turbocharger speed have a slope
close to zero. Thus, in this operating range, one turbocharger speed corresponds to a
single pressure ratio. As a consequence, one linear fit is sufficient, independent of the
engine speed. For larger mass flows, the lines of constant turbocharger speed do have232 9 Fundamentals of Control-Oriented Air Path Modeling
Fig. 9.2 Measured and simulated data for the correlation between pressure ratio and squared
corrected turbocharger speed for two compressors – c [2015] IEEE. Reprinted, with permission,
from [1]
a negative slope. Therefore, an additional offset for the relation between the pressure
ratio and the corrected mass flow results which depends on the engine speed. The
operating points of the compressor (a) are in this region.
The result can be utilized to compute the pressure ratio directly given the corrected
turbocharger speed and the engine speed. This approach contradicts the common
modeling philosophy of independent components, which are connected solely via
in- and output flow variables. The main advantage is that it enables a very lean model
structure and thereby a computationally rather efficient model. At the same time, the
simulation is numerically very robust. The correlations with slopes that are close to
zero, which are numerically demanding, are not used in this approach. For instance,
the relation between mass flow and pressure ratio at constant turbocharger speed for
low mass flows has a slope close to zero. However, typically differential–algebraic
equations (DAE) result, such that implicit integration schemes have to be applied.
To calculate the power consumed during the compression process, the compressor
mass flow is still needed. It is approximated by the mass flow of the next downstream
component, which may be a throttle, another compressor, or the engine directly. For
instance, when the next downstream component is the engine, it is assumed that the
mass flow through the compressor is equal to the aspirated mass flow of the engine:9.5 Turbocharger 233
Fig. 9.3 Engine
speed-dependent operating
points in the compressor map
– Reproduced from [2],
originally published open
access under a Creative
Commons CC BY 4.0
license, https://doi.org/10.
3390/en9070530
m˙ c(t) = ˙masp(t) (9.70)
This implies that the pressure dynamics in the volume between the compressor and
downstream component are negligible. Thus, the pressure immediately goes to a
constant state, such that the in- and outflowing masses in the volume are equal.
9.5.2 Turbine
Turbines are the counterparts of compressors. They extract enthalpy from the hot
exhaust gases and deliver it to the compressor via the turbocharger shaft. For turbines,
corrected quantities are applied as well, which originate from dimensional analysis.
These are used in order to make different inlet conditions comparable. The spread
of inlet conditions is bigger for turbines than for compressors. Thus, the corrections
actually play a greater role for turbines. The mass flow and the turbocharger speed
are modified in the same way as described for compressors:234 9 Fundamentals of Control-Oriented Air Path Modeling
m˙ t,corr(t) = ˙mt(t)


ϑus(t)
ϑref
pref
pus(t) (9.71)
ntc,corr(t) = ntc(t)


ϑref
ϑus(t) (9.72)
For turbines, the reference temperature typically is ϑref = 600 ◦C, while the refer￾ence pressure is at pref = 1bar [3]. The expansion ratio Πt is not defined unanimously
in the literature. Both the form shown in (9.73) as well as the reciprocal are used.
Within the book, the following definition is used:
Πt(t) = pus(t)
pds(t) (9.73)
The expansion ratio is Πt > 1 for normal operation. The fluid mechanics in turbines
are fundamentally different from those in compressors. Instead of transporting the
fluid against a high downstream pressure, the fluid is expanded. Therefore, stall
cannot happen inside a turbine. The only operation limit that has to be considered
in few cases is the turbine inlet temperature; a too high temperature can damage the
turbine.
For modeling the expansion process, an isentropic process is typically used as a
reference. The value ηt expresses the efficiency of the turbine to represent further
losses compared to the isentropic process. Based on the equation for power Pt =
m˙ tΔh and the standard enthalpy difference equation Δh = cpΔϑ, the equations for
the temperature ϑds and the power generated Pt can be derived:
ϑds = ϑus + ϑusηt ·
 pds
pus κ−1
κ
− 1

(9.74)
Pt(t) = cpm˙ t(t)ηt(t)ϑus,t(t) ·

1 − Π 1−κ
κ
t (t)
	
(9.75)
In the following, models for the mass flow through the turbine m˙ t as well as for the
turbine efficiency ηt are revisited.
Mass Flow
The mass flow through the turbine m˙ t depends mainly on the pressure ratio Πt . The
turbocharger speed only has a minor impact on the mass flow. Thus, the dependency
on the turbocharger speed is often neglected for modeling. To characterize the mass
flow through a turbine, simple formulations are commonly applied. The turbine
mass flow is often modeled as an orifice, as for example in [5]. The standard orifice
equations presented in (9.55) and (9.59) can be applied. Also, modified versions of
the orifice equation exist to model the turbine mass flow. For instance, a model based
on [11] is given by9.5 Turbocharger 235
m˙ t(t) = cd A pus(t)
√Rϑus(t)
ψ(Πt(t)) (9.76)
ψ (Πt(t)) = Π κ−2
2κ
t
 2κ
κ − 1 flim 
1 − Π −κ+1
κ
t
	
(9.77)
flim(x) = 1
2

x 2 + 2 + x
2 (9.78)
The actuators of the turbocharger belong to the main actuators for the air path
control. Two types of actuators typically exist to control the turbocharger, namely a
wastegate on the turbine side and a variable turbine geometry (VTG). The wastegate
simply enables a part of the mass flow to bypass the turbine. The model equations
for the turbine stay the same even when the turbine is equipped with an additional
wastegate. The VTG actuation affects the inlet geometry of the turbine and thereby
the angle of incidence for the rotor. This changes the mass flow behavior of the
turbine. Within the orifice equation, this can be taken into account by modeling the
factor cd A by a data-driven function that depends on the VTG position:
cd A(t) = f

uvtg(t)
 (9.79)
An alternative to the use of orifice-like equations to model the mass flow through
the turbine is the application of polynomial models. The parameters in the polynomial
model are identified for a best fit of the measurement data of the corrected turbine
mass flow:
m˙ t,corr(t) = f (Π (t)) (9.80)
If the turbine is equipped with a VTG, a multivariate polynomial model can be used:
m˙ t,corr(t) = f

Π (t), uvtg(t)
 (9.81)
Efficiency
A very common approach to model the efficiency is based on the dimensionless
blade speed ratio (BSR) [3]. The BSR characterizes the ratio between the speed of
the blade tip and the fluid velocity. When the blade speed is much lower than that
of the fluid velocity, the kinetic energy of the fluid is lost, while a very fast blade is
slowed down by the fluid. There exists a sweet spot in between these two situations
where the maximum efficiency is reached. The efficiency is often approximated as
a quadratic function of BSR with a unique maximum. The calculation of the BSR is
shown in (9.82), whereas (9.83) can be used to compute the turbine efficiency. The
radius of the blade is given by rt ; the angular speed of the turbocharger is denoted
by ωtc. The tuning parameters ηt,max and BSRopt can be used to shape the parabola.
These values are estimated to either fit measurement data or a turbine map. These
formulations were proposed in [3]; however, similar approaches exist that employ a
different parametrization for the parabola, as in [5], for example.236 9 Fundamentals of Control-Oriented Air Path Modeling
BSR(t) = ωtc(t)rt 
2cpϑus(t)

1 − Π(1−κ)/κ
t
	
(9.82)
ηt (BSR(t)) = ηt,max ·

1 −
BSR(t) − BSRopt
BSRopt 2

(9.83)
In case of VTG actuation, the parameter ηt,max can be modeled as a polynomial
function in dependence of the VTG position:
ηt,max = f (uvtg) (9.84)
9.5.3 Turbocharger Dynamics
The turbocharger dynamics are given by the interaction between the turbine on the
exhaust gas side and the compressor on the inlet side. In transients, the momenta
of the turbine as well as that of the compressor and the friction are not in balance
causing an acceleration or a deceleration of the turbocharger shaft until steady-state
conditions are reached where the momenta are in balance again. Newton’s second
law can be used to derive the equations of motion:
d
dt
ωtc(t) = 1
Jtcωtc(t)

Pt(t) − Pc(t) − Pfric(t)
 (9.85)
The turbine delivers the power Pt by the extraction of enthalpy from the hot exhaust
gases, while the compressor consumes the power Pc in order to compress the intake
gas to a higher pressure, thus increasing the gas density. For the description of the air
path dynamics, the moment of inertia of the turbocharger Jtc plays a significant role.
The value of Jtc mainly depends on the sizing of the turbocharger and can vary in the
order of one magnitude. The angular velocity of the turbocharger is represented by
ωtc. Additionally, a friction power Pfric is considered to describe the losses occurring
in the bearings. Typically, either Pfric is assumed to be constant, Pfric = const., or
it can be modeled as a function that depends on the angular speed of the turbocharger
Pfric = f (ωtc).
An alternative approach to consider the friction losses is the introduction of the
mechanical efficiency ηtc of the turbocharger which can be accounted for the turbine:
d
dt
ωtc(t) = 1
Jtcωtc(t)
(ηtcPt(t) − Pc(t)) (9.86)
The equations are not defined for ωtc(t) = 0. In normal operation, it holds that
ωtc(t) > 0. If situations occur with ωtc(t) ≤ 0, limiting functions can be introduced
to increase numerical robustness. For instance, the following model can be used:9.5 Turbocharger 237
d
dt
ωtc(t) = 1
Jtcωtc,lim(t)
(ηtcPt(t) − Pc(t))
ωtc,lim(t) = 1
2

ω2
tc(t) +  + ωtc(t)
2
(9.87)
References
1. T. Albin, D. Ritter, D. Abel, N. Liberda, R. Quirynen, M. Diehl, Nonlinear MPC for a two-stage
turbocharged gasoline engine airpath, in IEEE Conference on Decision and Control (2015),
pp. 849–856
2. T. Albin, D. Ritter, N. Liberda, D. Abel, Boost pressure control strategy to account for transient
behavior and pumping losses in a two-stage turbocharged air path concept. Energies 9(7), 530–
545 (2016)
3. L. Eriksson, L. Nielsen, Modeling and Control of Engines and Drivelines (Wiley, New Jersey,
2014)
4. E.M. Greitzer, Surge and rotating stall in axial flow compressors - part I: theoretical compression
system model. J. Eng. Power 98(2), 190–198 (1976)
5. L. Guzzella, C.H. Onder, Introduction to Modeling and Control of Internal Combustion Engine
Systems (Springer, Berlin, 2010)
6. J.B. Heywood, Internal Combustion Engine Fundamentals (McGraw-Hill Education, New
York, 2018)
7. R. Isermann, Engine Modeling and Control (Springer, Berlin, 2014)
8. O. Leufvén, L. Eriksson, Engine test bench turbo mapping, SAE Technical Paper (2010)
9. L. Ljung, Perspectives on system identification. Ann. Rev. Control 34(1), 1–12 (2010)
10. P. Moraal, I. Kolmanovsky, Turbocharger modeling for automotive control applications, SAE
Technical Paper (1999)
11. P. Moulin, J. Chauvin, Modelling and control of the air system of a turbocharged gasoline
engine, in Control Engineering Practice (2011), pp. 287 – 297
12. O. Nelles, Nonlinear System Identification: From Classical Approaches to Neural Networks
and Fuzzy Models (Springer, Berlin, 2013)
13. N. Watson, M.S. Janota, Turbocharging the Internal Combustion Engine (Macmillan Press
Ltd., 1982)Chapter 10
Combined Exhaust Gas Recirculation
and VTG: Modeling and Analysis
Abstract In this case study, a very common control task within the air path of a
compression ignition (CI) engine is discussed. The engine setup investigated uses
exhaust gas recirculation (EGR) in combination with a turbocharger that is equipped
with variable turbine geometry (VTG). The topic of investigation is the simultaneous
control of the burnt gas ratio and the pressure in the intake manifold. The present
chapter outlines the process modeling and an analysis of the system dynamics. A
state-space model based on ordinary differential equations (ODE) is derived which
consists of five dynamic states. The process model is validated for the static and
the dynamic behavior by the use of measurement data from an engine test bench.
The model shows a good correlation with the measurement data while it is still
computationally efficient. This validated model is subsequently used to analyze the
system dynamics of the process. Control-relevant characteristics, such as pole-zero
location and relative gain array (RGA) matrix are discussed. The air path exhibits
complex system dynamics including nonlinearity and sign reversal.
10.1 System Setup
To achieve low tailpipe pollutant emissions for a CI engine, two approaches are
applied. First, the engine is operated such that low engine-out emissions are formed.
Second, to further lower the emissions to the limits set by legislation, aftertreatment
systems are used. One common measure to obtain already low levels of engine-out
emissions while still achieving a high efficiency is the use of EGR in combination
with a VTG turbocharger. For the appropriate reduction of the pollutant emissions
with these devices, the air path control plays a crucial role. Section 7.3.2 describes
details on this system and on the physical effects. In the present case study, the
complex process control problem of this setup is investigated. Figure 10.1 shows the
CI engine setup investigated.
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_10
239240 10 Combined Exhaust Gas Recirculation and VTG: Modeling and Analysis
Fig. 10.1 Investigated CI
engine setup
The EGR valve position uegr and the guide vane position uvtg of the VTG are
used as actuated variables. They allow to control the intake manifold pressure pim
and the burnt gas ratio xbg in the intake manifold. The value pim is measured by the
use of a pressure sensor. For the determination of xbg, an oxygen sensor in the intake
manifold is applied. The sensor measures the fraction of oxygen mass in the intake
manifold denoted by Fim. The variable FO2,air denotes the oxygen mass fraction in
the air which is assumed constant, i.e. FO2,air = 0.23. The burnt gas ratio xbg can be
correlated to these two values by a simple algebraic relation:
xbg(t) = 1 − Fim(t)
FO2,air
(10.1)
The system is characterized by nonlinear dynamics and strong cross-couplings
between EGR and VTG. The control of the EGR system in combination with VTG
turbocharging has been widely covered in scientific publications due to its importance
in emissions reduction. Various kinds of control concepts were applied for the SI as
well as for the CI engine. While there exist publications for the SI case such as [4,
5, 11], the majority of research for this system setup has been conducted for the CI
case. Especially initial publications investigated the application of classical control
algorithms such as gain-scheduled PI/PID-based control [1, 10], sliding mode control
[8], control Lyapunov functions [9], and flatness-based control [6]. More recent
publications especially demonstrate the advantages of nonlinear model predictive
control (NMPC) over the classical control approaches, such as [2, 3, 7]. The following
case study details the benefits of NMPC for this application.10.1 System Setup 241
In the remainder of this chapter, a system model is derived with a special focus
on the trade-off between the accuracy of the model and its computational demands.
Subsequently, a model-based analysis of the process is conducted. In Chap. 11,
an NMPC method is developed for controlling this system. The results then are
compared to PID and linear MPC (LMPC) controllers.
10.2 Control-Oriented Process Model
As a process model, a nonlinear state-space model is developed which takes the
following form:
x˙(t) = f(x(t), u(t))
y(t) = g(x(t)) (10.2)
Two actuated variables are available for the control purpose, the guide vane position
of the VTG uvtg and the EGR valve position uegr, which are summarized by u(t).
u(t) =

uvtg(t)
uegr(t)
 position VTG
position EGR valve (10.3)
These two actuated variables allow the burnt gas ratio and the intake manifold pres￾sure to be controlled which are summarized by y(t).
y(t) =

pim(t)
xbg(t)
 intake manifold pressure
burnt gas ratio (10.4)
All in all, the system is described by five system states which are summed up as x(t).
Two gas volumes are present, i.e. the intake manifold and the exhaust manifold. Each
gas volume is described by its pressure p(t) and its oxygen mass fraction F(t). The
angular speed of the turbocharger ωtc(t) acts as an additional state variable.
x(t) =
⎡
⎢
⎢
⎢
⎢
⎣
ωtc(t)
pim(t)
pem(t)
Fim(t)
Fem(t)
⎤
⎥
⎥
⎥
⎥
⎦
angular speed of turbocharger
pressure at intake manifold
pressure at exhaust manifold
oxygen mass fraction in intake manifold
oxygen mass fraction in exhaust manifold
(10.5)
The system state pim(t) is the first controlled variable of the system. The second
controlled variable xbg(t) can be calculated from the system state Fim(t) by (10.1).
The differential equations characterizing the five system states are developed
according to the descriptions in Chap. 9. For determining the turbocharger speed,
Newton’s second law is used. Within the equation of motion (10.6), the power gen￾erated by the turbine Pt , the power consumed by the compressor Pc, and the friction
losses Pf are considered. The friction losses Pf are assumed to be constant. The242 10 Combined Exhaust Gas Recirculation and VTG: Modeling and Analysis
value Jtc describes the moment of inertia of the turbocharger. Both values Pf and Jtc
are determined by system identification for best fit with measurement data. For the
two gas volumes, the pressure dynamics are defined using the isothermal model sim￾plification, i.e. the inlet temperature is equal to the outlet temperature. The dynamics
of oxygen fractions in the intake F˙
im and the exhaust manifold F˙
em are well described
by (10.9) and (10.10). For the thermodynamic calculations, the gas properties of air
are used, i.e. the specific gas constant is chosen as R = 287 J
kgK , the specific heat
capacity as cp = 1005 J
kgK , and the heat capacity ratio as κ = 1.4. Due to the lean
operation of the engine, the air is a dominant content within the entire air path.
ω˙tc(t) = 1
ωtc(t)Jtc


Pt(t) − Pc(t) − Pf

(10.6)
p˙im(t) = Rϑim
V1


m˙ c(t) + ˙megr(t) − ˙masp(t)

(10.7)
p˙em(t) = Rϑem
V2


m˙ eo(t) − ˙megr(t) − ˙mt(t)

(10.8)
F˙
im(t) = Rϑim
V3 pim(t)


FO2,air − Fim(t)

m˙ c(t) +


Fem(t) − Fim(t)

m˙ egr(t)

(10.9)
F˙
em(t) = Rϑem
V4 pem(t)


Feo(t) − Fem(t)

m˙ eo(t)

(10.10)
All terms that have no explicit dependence on time, i.e. Jtc, Pf , R, ϑim, ϑem, V1, V2,
V3, V4, and FO2,air, are assumed to be constant. The conditions upstream of the com￾pressor and downstream of the turbine are assumed to be identical to constant ambient
conditions with pamb = 1bar, ϑamb = 293K, and FO2,air = 0.23. Alternatively, sen￾sors may be employed to continuously measure the ambient conditions. For ϑim and
ϑem, the numerical values are chosen to represent medium values of their value range.
This avoids the inclusion of additional temperature relations which would result in
more accurate models, but increases its complexity. The values V1,...V4 are chosen
to reflect the dynamic behavior.
The terms Pt(t), Pc(t), m˙ c(t), m˙ egr(t), m˙ asp(t), m˙ eo(t), m˙ t(t), and Feo(t) are deter￾mined by algebraic relations as detailed in the following. Many quantities depend on
pressure ratios, which are denoted by Π. More specifically, the following pressure
ratios over the engine, the turbine, and the compressor are used:
Πeng = pem
pim
(10.11)
Πt = pem
pamb
(10.12)
Πc = pim
pamb
(10.13)10.2 Control-Oriented Process Model 243
Three different engine mass flows are considered, i.e. the mass flow m˙ asp aspirated
into the engine from the intake manifold, the mass flow of fuel injected directly
into the cylinders m˙ f uel , and the engine-out mass flow exhausted from the engine
m˙ eo. Taking the direct injection of the fuel into account, the mass flow m˙ eo can be
calculated by
m˙ eo = ˙masp + ˙m f uel (10.14)
The value for m˙ f uel is available in the engine control unit as it is an actuated value. The
aspirated mass flow into the engine m˙ asp is determined by a data-driven approach. The
following function that depends on the exhaust manifold pressure pem, the angular
engine speed ωeng, and the pressure ratio over the engine Πeng is used. The constants
i0,...,i3 are identified to fit the measurement data.
m˙ asp = i0 + i1 pim + i2Πeng + i3ωeng (10.15)
Based on the engine mass flows, the relation for the engine-out oxygen mass fraction
is calculated by (10.16). The relation takes the stoichiometric air-to-fuel ratio AFRs
into account, i.e. for diesel fuel, it holds AFRs FO2,air = 3.4.
Feo = 1
m˙ eo
·

Fimm˙ asp
− ˙m f uel AFRs FO2,air  (10.16)
The mass flow through the EGR valve is determined using a data-driven model. The
function depends on the position of the EGR valve uegr and the pressure ratio over
the engine Πeng. The constants h0,..., h8 are fitted to the measurement data.
m˙ egr = h0
1 − exp 
−  uegr (t)+h1
h2
h3 
h4 exp 
− h5Πeng

+ h6
+ flim(h7uegr(t) − h8) (10.17)
The limit function flim is defined as
flim(x) = 1
2

x 2 + ε +
1
2
x (10.18)
The turbocharger is described by the following equations. The power generated by
the turbine Pt and the power consumed by the compressor Pc are calculated by
Pt = cpηtϑemm˙ t

1 − Π 1−κ
κ
t
 (10.19)
Pc = cpϑamb
m˙ c
ηc

Π κ−1
κ
c − 1
 (10.20)
For ηc and ηt , constant values are assumed. They are determined by system identifi￾cation with measurement data.244 10 Combined Exhaust Gas Recirculation and VTG: Modeling and Analysis
The mass flow through the compressor m˙ c is determined by a polynomial model.
The constants involved li j are fitted to reproduce the measurement data. The correc￾tion term, as given in (9.60), does not have a big influence on the compressor mass
flow in this case, as the compressor is operated at ambient conditions that are very
similar to the reference conditions. Thus, no correction is conducted. The polynomial
function is given by
m˙ c = l02ω2
tc + l20Π2
c +
1
i=0

1
j=0
li jΠi
cωj
tc (10.21)
For calculation of the mass flow through the turbine m˙ t as well a polynomial
model is used. More precisely, the polynomial model calculates the corrected mass
flow through the turbine. The constants of the polynomial model ti j are fitted to
reproduce the measurement data. For the correction term, the reference pressure is
assumed to be equal to the ambient pressure pref = pamb. The following relations
result:
m˙ c = l02ω2
tc + l20Π2
c +
1
i=0

1
j=0
li jΠi
cωj
tc (10.22)
m˙ t,corr = 
4
i=0

3
j=0
ti jΠi
t u j
vtg (10.23)
m˙ t = ˙mt,corrΠt

ϑref
ϑem
(10.24)
There is also a considerable dead-time arising in the process. The dead-time is
mainly acting on the system output, i.e. by sensor delay. As a consequence, the
model lumps together all arising dead-times as one that is acting on each output.
Both dead-times are assumed to be constant.
ypim = pim(t − TD,1) (10.25)
yxbg = xbg(t − TD,2) (10.26)
The dead-times are identified via system identification.
10.3 Validation of the Process Model
To validate the process model derived, it is compared to data gathered from an engine
test bench. The engine is a 2-liter production-type diesel engine with a compression
ratio of 16.5:1 and four cylinders. All validations are conducted for a constant engine10.3 Validation of the Process Model 245
Fig. 10.2 Comparison of measurement data and simulative data of the process model
speed and for a constant diesel fuel mass injected. Figure 10.2 shows the transient
behavior gained from experimental measurements and from simulations with the
process model. For validation purposes, steps with various heights are applied on
uvtg and on uegr. The experimental data exhibits overshoots as well as non-minimum
phase behavior. Both are reproduced by the process model. The model accurately
captures the transient dynamics. In certain areas, a slight offset in the steady-state
behavior can be observed. For the intake manifold pressure ypim , the dead-time is
identified to be TD,1 = 0.1s and for the burnt gas ratio yxbg , the value TD,2 = 0.4s is
used. With these values, the dead-time can be captured very well.
Figures 10.3 and 10.4 detail the steady-state behavior of the burnt gas ratio xbg and
the intake manifold pressure pim in dependence of the two actuated values uegr and
uvtg at a constant engine speed. The measured values as well as the ones resulting
from simulation of the process model are depicted. The process model is able to
capture the steady-state behavior sufficiently well over the entire operating range.
Quantitatively, the maximum error is acceptable for both values. Qualitatively, the
process model is able to capture the nonlinearities of the system behavior. The process
model can be further improved by the inclusion of additional submodels. Submodels
e.g. for capturing the efficiencies of the turbine and the compressor or for capturing
the temperature dynamics can be added. However, such submodels cause a higher
model complexity.
In summary, the process model quantitatively and qualitatively shows a good
reproduction behavior. Both the steady-state and the transient behavior can be246 10 Combined Exhaust Gas Recirculation and VTG: Modeling and Analysis
Fig. 10.3 Steady-state
values of burnt gas ratio
captured. The model is a low-order nonlinear model that represents a good com￾promise between accuracy and complexity. Furthermore, it fulfills the requirement
to be continuously differentiable.10.3 Validation of the Process Model 247
Fig. 10.4 Steady-state
values of intake manifold
pressure248 10 Combined Exhaust Gas Recirculation and VTG: Modeling and Analysis
10.4 Analysis of the System Dynamics
First, an analysis of the system dynamics of the air path system has to be conducted in
order to develop suitable model-based control algorithms. In the following, various
characteristics such as pole-zero locations as well as the RGA matrix are investigated
based on the process model derived.
10.4.1 Nonlinearity
The nonlinear behavior of the plant is readily visible in the steady-state maps shown
in Figs. 10.3 and 10.4. To further quantify these nonlinearities, the sensitivities at
steady-state operation are investigated. These are calculated for all input–output
combinations by determining the gradients at stationary conditions.
∂ yi
∂uj




x0, u0
with f(x0, u0) = x˙ = 0 (10.27)
Figure 10.5 shows the sensitivity of each of the two actuated values to each of the
two controlled variables. A linear plant has a constant sensitivity over the entire
operating range, i.e. the DC gain. In contrast, the nonlinear EGR VTG system has
very variable sensitivities, i.e. the sensitivities of the system are strongly dependent
on the operating point. Additionally, in some operating regions, a sign reversal occurs.
When uvtg = 1 is kept constant and uegr is reduced from 1 to 0, then the sensitivity
for pim to uegr is at first positive, while for values uegr < 0.4, the sign subsequently
switches to negative values. This behavior is known as sign reversal and generally is
very difficult to control.
To illustrate the nonlinearities in the transient behavior, a simulation is conducted
with a linearized system model. The model is linearized around the steady-state
operating point resulting from uegr = uvtg = 0.5. Figure 10.6 shows the simula￾tion differences between the linearized and the nonlinear system. While a moderate
change in the VTG position can be captured quite well with the linearized model,
considerable discrepancies occur at a moderate step input of the EGR position.
10.4.2 Pole-Zero Locations
Crucial insights of the system behavior can be gained by an inspection of the pole-zero
locations of the linearized plant. For the analysis, the linearizations are calculated
over the entire operating range of the actuated values – all at steady-state conditions.
Figure 10.7 shows the location of the pole with the highest value of the linearized
MIMO transfer function in dependence of the steady-state actuated values. Numeri￾cal values for three exemplary operating points are highlighted. Clearly, at any point10.4 Analysis of the System Dynamics 249
0
1
5
1
104
sensitivity [1]
u
vtg
to pim
u
egr [1]
0.5
u
vtg [1]
10
0.5
0 0
-15
1
-10
1
sensitivity [1]
104
-5
u
egr
to pim
u
egr [1]
0.5
u
vtg [1]
0
0.5
0 0
0
1
0.2
1
0.4
sensitivity [1]
u
vtg
to xbg
u
egr [1]
0.6
0.5
u
vtg [1]
0.5
0 0
0
1
0.5
1
sensitivity [1]
1
u
egr
to xbg
 u
egr [1]
0.5
 u
vtg [1]
1.5
0.5
0 0
Fig. 10.5 Sensitivities of the input–output behavior at steady-state conditions
of the linearization, all poles are negative. The linearized plants thus are asymptoti￾cally stable. As a result, all possible equilibrium points of the nonlinear system are
asymptotically stable within the operating range investigated.
Figure 10.8 shows the location of the zero with the highest value of the MIMO
transfer function in dependence of the point of linearization. The numerical values for
three exemplary linearization points are highlighted. In the entire operation range,
the linear plant always includes a non-minimum phase zero. For the design of a
conventional controller such as a PID controller, the non-minimum phase zeros limit
the achievable crossover frequency of a controller and thus its possible performance.
In fact, the nonlinear system also exhibits this typical non-minimum phase behavior,
as the step response in Fig. 10.2 shows.250 10 Combined Exhaust Gas Recirculation and VTG: Modeling and Analysis
Fig. 10.6 Comparison of the transient behaviors of the linearized and the nonlinear model
Fig. 10.7 Maps with
maximum poles of the
linearized MIMO transfer
function
-4
1
-3
-2
1
max [1]
-1
u
egr [1]
0.5
uvtg [1]
0
0.5
0 010.4 Analysis of the System Dynamics 251
Fig. 10.8 Maps with
maximum zeros of the
linearized MIMO transfer
function
0
1
10
1
max [1]
20
u
egr [1]
0.5
uvtg [1]
30
0.5
0 0
10.4.3 Relative Gain Array
In Sect. 2.1.2, the RGA matrix Λ(s) is introduced as a measure to quantify the
cross-couplings in MIMO systems. Figure 10.9 shows the values of the RGA matrix
of the linearized system for the various linearization points. The RGA matrix is
evaluated at the steady state s = 0. Specifically, the first values of Λ(0), i.e. Λ11(0),
are illustrated, which correspond to the channel uvtg → pim. In the case of 2 × 2
MIMO systems, one element of Λ(s) always is sufficient to define the entire matrix,
since all columns and rows of Λ(s) must add up to 1. The numerical values for
three exemplary linearization points are highlighted. The effects of cross-couplings
strongly depend on the operating point.
• OP1: With 11(0) = 0.97, the plant is diagonally dominant, i.e. using two SISO
controllers for the channels u1 → y1 (here uvtg → pim) and u2 → y2 (here uegr →
xbg) should work satisfactorily.
• OP2: Here, the entry 11(0) = 0.66 clearly differs from 1; therefore, a MIMO
approach should be pursued for controlling the plant in this operating point.
• OP3: As 11(0) = 0.48, the off-diagonal entries are even closer to 1. In fact, the
RGA suggests that it is better to control pim with uegr and xbg with uvtg.
In summary, in certain operating conditions, the diagonal entries differ significantly
from unity. Hence, the RGA matrix reveals that achieving a satisfactory control
performance with a pure SISO control approach is unlikely. Instead, a decoupling
matrix should be used for conventional control approaches.252 10 Combined Exhaust Gas Recirculation and VTG: Modeling and Analysis
Fig. 10.9 Steady-state
relative gain array of the
linearized MIMO transfer
function
References
1. M. Ammann, N.P. Fekete, L. Guzzella, A.H. Glattfelder, Model-based control of the vgt and
egr in a turbocharged common-rail diesel engine: theory and passenger car implementation.
SAE Trans. 527–538 (2003)
2. D. Gagliardi, T. Othsuka, L. del Re, Direct c/gmres control of the air path of a diesel engine.
IFAC Proc. Vol. 47(3), 3000–3005 (2014)
3. M. Huang, H. Nakada, K. Butts, I. Kolmanovsky, Nonlinear model predictive control of a
diesel engine air path: a comparison of constraint handling and computational strategies. IFAC￾PapersOnLine 48(23), 372–379 (2015)
4. M. Keller, S. Geiger, D. Abel, T. Albin, Physics-based modeling and mpc for the air path of
a two-stage turbocharged si engine with low pressure egr, in European Control Conference
(2020)
5. M. Keller, S. Geiger, M. Günther, S. Pischinger, D. Abel, T. Albin, Model predictive air path
control for a two-stage turbocharged spark-ignition engine with low pressure exhaust gas recir￾culation. Int. J. Engine Res. 21(10), 1835–1845 (2020)
6. P. Kotman, A. Kugi et al., Flatness-based feedforward control of a diesel engine air system
with egr. IFAC Proc. Vol. 43(7), 598–603 (2010)
7. A. Murilo, M. Alamir, D. Alberer, A general NMPC framework for a diesel engine air path.
Int. J. Control 87(10), 2194–2207 (2014)
8. V. Utkin, H.-C. Chang, I. Kolmanovsky, J.A. Cook, Sliding mode control for variable geometry
turbocharged diesel engines. Am. Control Conf. 1(6), 584–588 (2000)
9. M. Van Nieuwstadt, I. Kolmanovsky, P. Moraal, A. Stefanopoulou, M. Jankovic, Egr-vgt control
schemes: experimental comparison for a high-speed diesel engine. IEEE Control Syst. Mag.
20(3), 63–79 (2000)
10. J. Wahlstrom, L. Eriksson, L. Nielsen, Egr-vgt control and tuning for pumping work minimiza￾tion and emission control. IEEE Trans. Control Syst. Technol. 18(4), 993–1003 (2009)
11. A.P. Wiese, A.G. Stefanopoulou, A.Y. Karnik, J.H. Buckland, Model predictive control for low
pressure exhaust gas recirculation with scavenging, in American Control Conference (2017),
pp. 3638–3643Chapter 11
Combined Exhaust Gas Recirculation
and VTG: Control
Abstract In this chapter, various control algorithms for the combined control of
burnt gas ratio and intake manifold pressure are investigated. Based on the process
model derived, three model-based controllers are designed. The most elaborate one of
them is a nonlinear model predictive control (NMPC) algorithm. The design aspects
which have been covered in the book, such as offset-free control, are implemented.
The choice of several parameters, such as the number of SQP steps or the length of the
control horizon, is investigated in detail for the NMPC algorithm. For comparison, a
linear MPC (LMPC) algorithm is developed as well, which relies on the linearization
of the nonlinear model. Additionally, a decentralized control approach based on PI
controllers is investigated. For an appropriate decentralized control synthesis, several
modules have to be included, such as decoupling control and anti-reset windup.
Finally, the three concepts are compared, including the validation of the NMPC
algorithm on an engine test bench.
11.1 Nonlinear MPC Algorithm
An NMPC approach is presented for the control of the air path of a CI engine. The
investigated CI engine setup is depicted in Fig. 10.1. The objective is to simulta￾neously control the burnt gas ratio and the pressure in the intake manifold. First,
the controller-internal model is discussed. Subsequently, the parametrization of the
control algorithm is investigated.
11.1.1 Controller-Internal Model
The controller-internal model used within the NMPC algorithm has to be continu￾ously differentiable and of low complexity in order to be implemented for a gradient￾based real-time optimization scheme. The base model used for this case study is
presented in Sect. 10.2 and consists of two inputs u(t), two outputs y(t), and five
system states x(t). The model is defined by an ODE system.
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_11
253254 11 Combined Exhaust Gas Recirculation and VTG: Control
Within the NMPC algorithm, a discretized model is applied. The continuous-time
model is discretized using an integration scheme. For comparison, various integration
schemes are investigated, i.e. the Runge–Kutta 4 scheme and the implicit Euler
method. The continuous-time dead-time TD is discretized using the sampling time
Ts to the integer value kD =
TD
Ts

. The general discretized model has the following
form, where k is the discrete sampling instant and f dis represents the discretized
dynamics:
x(k + 1) = f dis(x(k), u(k))
y(k) = g(x(k − kD)) (11.1)
One of the goals of the closed-loop controller is to achieve an offset-free tracking
even in the presence of disturbances and a model–plant mismatch. More precisely,
the goal is to track the reference of both outputs, namely the intake manifold pressure
pim and the burnt gas ratio xbg, without offset for references and disturbances that are
asymptotically constant. Since the plant is stable, observable and the noise is negli￾gible, an approach using a deadbeat observer is applied as discussed in Sect. 6.2.2.
For this purpose, a model for disturbance estimation is needed. A pure output
disturbance model is used. The nominal outputs are thus augmented by additional
disturbance states d(k) ∈ R2. The following model for disturbance estimation results:
x(k + 1) = f dis(x(k), u(k))
yaug(k) = g(x(k − kD)) + d(k) (11.2)
The states x(k) are calculated by an open-loop estimation. A deadbeat observer
is used to estimate the disturbances dˆ(k + 1) and thus to achieve an offset-free
control algorithm. The disturbance estimates dˆ(k + 1) are calculated with the recent
measurement of the outputs ym(k) by
dˆ(k + 1) = ym(k) − g(x(k − kD)) (11.3)
The disturbance states are assumed to be constant over the prediction horizon.
dˆ(·|k) = dˆ(k + 1) (11.4)
11.1.2 Formulation of the Optimization Problem
The task of the controller is to drive the values y(k), i.e. the intake manifold pressure
and the burnt gas ratio to its reference values r(k). The reference values r(k) are
assumed to be constant over the prediction horizon. For this purpose, a reference
tracking problem formulation is used. The cost function uses quadratic costs on the
reference tracking term and on the change of actuated values.11.1 Nonlinear MPC Algorithm 255
J = 
N
i=1





g(x(k + i|k)) + dˆ(k + 1) − r(k)






2
Qi
+

N−1
i=0
||u(k + i|k) − u(k + i − 1|k)||2
Ri
(11.5)
For the controller-internal model that is used for optimization, the dead-time can
be neglected as the dead-time is present solely on the outputs and the reference in
each time step is assumed to be constant over the prediction horizon. In the given
case, the dead-time only has to be considered for disturbance estimation (11.3). The
discrete-time model enters the optimization problem as given for multiple shooting.
The optimization problem also considers the initial state, the last actuated value
applied, and the box constraints on the actuated values. The resulting NLP looks as
follows:
min u(·|k), x(·|k)
J
s.t. x(k + i + 1|k) = f dis 
x(k + i|k), u(k + i|k)

, i = 0,..., N − 1,
x(k|k) = x(k),
u(k − 1|k) = u(k − 1),
0 ≤ u(k + i|k) ≤ 1, i = 0,..., N − 1
(11.6)
11.1.3 Parametrization of the Numerical Solver
In this case study, an SQP algorithm is used to solve the resulting NLP given by
(11.6). The design of the numerical solver significantly influences various important
performance parameters. There is especially one trade-off that dominates the choice
of parameters: the trade-off between the computational effort, measured in CPU
time, and the control performance, measured for example in the sum of tracking error
and the change of actuated values. This trade-off concerns most of the parameters
discussed. Any gain in one of the metrics is “paid for” by a decrease in the other.
Important choices that affect these performance parameters are the calculation of
the Hessian matrix and the numerical integration scheme. Either the exact Hessian can
be used or an approximation can be applied instead. As a reference tracking problem
is used within the NMPC algorithm, the Gauss–Newton scheme is investigated as an
approximation. The system exhibits stiff system dynamics, i.e. fast as well as slow
dynamics are present. Thus, the use of implicit integration schemes for numerical
simulation becomes relevant. To evaluate the influence of these choices, the following
three setups are compared.256 11 Combined Exhaust Gas Recirculation and VTG: Control
Fig. 11.1 Comparison of the
three numerical solvers
settings in terms of
computation time
• Exact Hessian calculation with five Runge–Kutta 4 integration steps per sample
time
• Gauss–Newton Hessian calculation with five Runge–Kutta 4 integration steps per
sample time
• Gauss–Newton Hessian calculation with one implicit Euler integration step
To study the influence of these three setups, various simulations are carried out.
All other parameters, such as sampling time Ts and number of prediction steps N,
are set equal. Figure 11.1 shows a comparison of the computation times of the three
setups in dependence of the number of SQP steps. The average computation time of
one NMPC step is depicted. The computation time grows linearly with the number
of SQP steps. Compared to the exact Hessian, the calculation of the Hessian matrix
with the Gauss–Newton approach considerably reduces the computation time. The
replacement of five Runge–Kutta 4 steps by a single implicit Euler integration scheme
further reduces the computational effort.
In addition to the computation time, the control quality is the essential perfor￾mance parameter. Closed-loop control simulations are carried out for comparing the
three setups. A step in the intake manifold pressure as well as the burnt gas ratio
at t = 1 s is used as a reference. Figure 11.2 shows the closed-loop control result
for the three design choices, each with one SQP step. All choices result in a similar
tracking behavior. In theory, the exact Hessian has a better convergence rate than the
Gauss–Newton calculation. Still, there is no visible difference. Besides the reduced
computation time, the Gauss–Newton Hessian calculation has the advantage that the
approximated Hessian matrix calculated is always positive semidefinite.
The number of SQP steps performed in each sampling step to solve the resulting
NLP has a direct effect on how close the actuated value applied is to that of the fully11.1 Nonlinear MPC Algorithm 257
Fig. 11.2 Comparison of the three numerical solvers settings in terms of control performance
converged solution. Possible choices are to only perform one step, as proposed in
the real-time iteration (RTI) scheme, perform multiple SQP steps, or even let the
algorithm run until it converges. Figure 11.3 shows a comparison between using 50
SQP steps where a converged solution is gained in most of the sampling steps and
using one SQP step. The solution found with one SQP step is almost as good as the one
that is nearly converged. The reason lies in the combination of the receding-horizon
principle, multiple shooting discretization, and the SQP method. This combination
allows open-loop predictions to be initialized with the solution of the preceding step.
Thus, each solution is continuously improved in every time step. After a few time
steps, the initialization is already close to the optimal solution.
For a further analysis of the air path control problem, the following choices are
made. As the difference in the closed-loop control performance is small, the RTI
scheme is used, which consists of a single SQP step Nsqp = 1. As all three setups
yield comparable results for the tracking performance, the fastest NLP formulation
is used for the further analysis, which is the Gauss–Newton approximation for the
Hessian matrix with an implicit Euler integration scheme.
11.1.4 Parametrization of the Cost Function
In the following, the design parameters of the cost function are analyzed. First, the
influence of the number of prediction steps N is investigated. Figure 11.4 shows its
influence on the NMPC tracking cost and on the computation time. All simulations
use a fixed shooting interval of Tsh = 0.1 s. Hence, the increase in the number of258 11 Combined Exhaust Gas Recirculation and VTG: Control
0 20 40
0
0.5
1
1
1.2
1.4
0
0.1
0.2
0.3
0 20 40
0
0.2
0.4
0.6
Fig. 11.3 Effect of the number of SQP iterations on the closed-loop solution
prediction steps also leads to an increase in the time horizon that is predicted, i.e. the
prediction horizon H. The prediction horizon H is determined by the number of pre￾diction steps N and the length of the shooting interval Tsh by H = TshN. Figure 11.4
shows that the tracking cost significantly decreases with an increasing number of
prediction steps. However, there is a threshold where any further increase of pre￾diction steps has no effect. Figure 11.4 shows that the computation time increases
exponentially with the number of prediction steps. With an increasing number of
prediction steps, the number of optimization variables increases too, which is the
reason for the exponential increase in computation time.
0 10 20 30
0
5
10
15
20
25
0 10 20 30
0
5
10
15
20
25
Fig. 11.4 Effect of number of prediction steps on tracking cost and computation time11.1 Nonlinear MPC Algorithm 259
Another design choice within NMPC is the length of the shooting interval Tsh.
Typically, it is chosen to be equal to the sampling time Ts. However, it can also be
chosen to be bigger than the sampling time Ts. The length of the shooting interval
Tsh itself almost has no effect on the computation time, in contrast to the number of
prediction steps N which directly correlates to the number of optimization variables.
Thus, increasing the shooting interval Tsh allows for a long prediction horizon H
while having a reduced number of optimization variables. However, the shooting
interval Tsh affects the tracking cost. Figure 11.5 depicts the influence of the predic￾tion horizon H and the number of prediction steps N on the tracking cost. For an
appropriate control performance, the prediction horizon H has to be higher than a
certain threshold, regardless of the number of prediction steps N. The number of pre￾diction steps N has to be higher than a certain threshold as well. Any further increase
in one of these two values does not improve the performance of the controller.
For determining suitable parameters, first, the maximum number of prediction
steps N can be chosen such that an acceptable computation time results. In the given
setup, an acceptable computation time is 10 ms, which allows the use of N = 20.
The prediction horizon H can be chosen according to Fig. 11.5 for low tracking cost.
A suitable shooting interval is Ts = 0.1 s, which is equivalent to the sampling time
Ts. The prediction horizon results to be H = 2 s.
Once the various design choices are made, the tuning parameters such as Q and R
can be determined. The tuning of the parameters can be conducted within a simulative
environment. It is important to have a different model than the one used within the
controller. For instance, a more complex system model can be used as a plant for the
closed-loop simulation.
Fig. 11.5 Tracking cost in
dependence of the prediction
horizon and the number of
prediction steps260 11 Combined Exhaust Gas Recirculation and VTG: Control
11.2 Model-Based Synthesis of PI Controllers
PID-based controllers are state of the art for series-production engine control algo￾rithms. The fundamentals for the design of the PID-based controllers for typical
engine characteristics are discussed in Chap. 2. In the following, those methods are
applied for the EGR VTG control problem, and their performance is analyzed sub￾sequently.
11.2.1 Decentralized Synthesis of PI Controllers
The EGR VTG control problem is characterized by multiple-input multiple-output
(MIMO) system dynamics. Thus, decentralized controllers are designed. The pairing
of inputs to outputs is based on the RGA matrix analysis described in Sect. 10.4.3.
In this case study, two single-input single-output (SISO) PI controllers are used. The
controllers C1 and C2 are designed, where the first one controls the plant from uvtg
to pim, while the second one controls from uegr to xbg according to the RGA matrix.
This corresponds to the intuitive choice.
First, the system is treated as a decoupled system to design the controllers, thus
ignoring the cross-couplings arising. The controllers C1 and C2 both are designed
to achieve a certain bandwidth. For this reason, the crossover frequencies are set to
0.8 rad
s for controller C1 and 0.5 rad
s for controller C2. The sampling time is chosen
to be Ts = 0.05 s. It is chosen to be smaller than the one used for NMPC to account
for the reduced computation time compared to the NMPC controller. A summary of
all parameters is shown in Table 11.1. For the design of the controllers, a linearized
model is used. The linearization point is chosen to be the steady state xss(ulin) for
the input ulin = [0.5 0.5]
T.
While for the design, the plant is assumed to consist of two perfectly decoupled
linear SISO plants, in the real application, the plant is a coupled, nonlinear system.
As the PI controllers are designed on the simplified plant, no guarantee can be
given concerning their performance on the nonlinear plant or even on the full linear
plant, i.e. including the cross-couplings. To evaluate the difference in control quality,
simulations are conducted. Figure 11.6 shows a comparison of the closed-loop control
results gained in simulation. The controllers are tested against the linear decoupled
system (simplified), against the linear system including cross-couplings (linear), and
against the nonlinear system model (nonlinear). While the controllers perform very
Table 11.1 Controller specification for the SISO controllers
Crossover frequency of C1 0.8 rad/s
Crossover frequency of C2 0.5 rad/s
Sampling time Ts 0.05 s11.2 Model-Based Synthesis of PI Controllers 261
1
1.1
1.2
1.3 10 5
0
0.1
0.2
0
0.5
1
20 40 60 80 100
0.4
0.6
0.8
Fig. 11.6 Simulation of the decentralized SISO controllers on the decoupled linear plant, linear
plant with cross-couplings, and the nonlinear plant
well on the simplified, decoupled plant, the controllers perform already significantly
worse on the full linear plant due to the cross-couplings. As expected, the worst
performance is observed in the simulation with the nonlinear process model. In the
case of a nonlinear plant model, the control quality is unacceptable, as very high
oscillations result. To take the cross-couplings into account and thus further improve
the control result, a decoupling matrix can be added.
11.2.2 Decoupling Control Approach
To improve the control behavior of the SISO controllers for the air path system, a
decoupling matrix can be added, as discussed in Sect. 2.1.3. With the goal to recover
the diagonal entries of the original plant, the decoupling matrix can be calculated by262 11 Combined Exhaust Gas Recirculation and VTG: Control
D11 = G22
G11G22 − G12G21
G11, D12 = −G12
G11
,
D22 = G11
G11G22 − G12G21
G22, D21 = −G21
G22
.
(11.7)
Due to the system dynamics present, i.e. non-minimum phase zeros, exact decou￾pling leads to rather complex decoupling terms. A simple, approximate decoupling
approach is used instead. One feasible approach is the use of static gains for decou￾pling. They result to be
D11(s = 0) = 0.66 D12(s = 0) = 1.52
D21(s = 0) = −0.33 D22(s = 0) = 0.66 (11.8)
To evaluate the improvement in performance due to the decoupling matrix, simula￾tions are conducted. The same decentralized SISO controllers C1 and C2 as designed
in Sect. 11.2.1 are used. The simulations are conducted with the nonlinear plant.
Figure 11.7 shows the results of the simulation with and without the decoupling
matrix.
Even though only static decoupling is implemented, the decoupling matrix signif￾icantly improves the performance of the decentralized PI controllers. The overshoots
can be drastically reduced, while the effects of the cross-couplings are considerably
attenuated as well.
11.2.3 Anti-windup and Dead-Time
There exist constraints on the actuated values which have to be taken into account
for control design. Both actuated variables are subject to box constraints which stem
from physical constraints.
0 ≤ uvtg ≤ 1 (11.9)
0 ≤ uegr ≤ 1 (11.10)
Active constraints on actuated values may cause controllers with integrative
behavior to windup. To prevent integrator windup, controllers with integrative behav￾ior have to be enhanced with anti-windup measures. In this case, the back-calculation
scheme, which is introduced in Sect. 2.2.1 is implemented.
In addition to constraints, the real air path system is also subject to dead-times.
The closed-loop control simulations with the PI-based controllers in this subsection
neglected this dead-time in the plants and the controller design so far. It is generally
hard to deal with dead-times in MIMO systems with decentralized controllers. How￾ever, the handling is simplified in this specific case as the dead-times only arise on
the outputs. The same controllers C1 and C2 can be used; however, to compensate for11.2 Model-Based Synthesis of PI Controllers 263
1
1.1
1.2
1.3 10 5
0.1
0.15
0.2
0.2
0.4
0.6
0.8
20 40 60 80 100
0.4
0.6
Fig. 11.7 Performance of the decentralized SISO controllers with and without decoupling with
nonlinear plant
the dead-times, an additional Smith predictor is used. In this case, a Smith predictor
can be applied for each output to compensate for the effect of each dead-time [1, 2].
11.3 Simulative Comparison of the Controllers
In the following, the closed-loop control results obtained by simulations of the
designed PI and NMPC controllers are compared. For this comparison, an LMPC is
evaluated as well. The LMPC is characterized by the use of a constant linear process
model, given by
x(k + 1|k) = Ax(k|k) + Bu(k|k)
y(k|k) = C x(k|k) (11.11)264 11 Combined Exhaust Gas Recirculation and VTG: Control
1
1.1
1.2
1.3
0 5 10 15
0.2
0.4
0.6
0.8
0 5 10 15
0.15
0.2
0.25
0.3
0.35
0.02
0.03
0.04
0.05
0.06
Fig. 11.8 Comparison of closed-loop control results for LMPC, NMPC, and PI for a step in the
reference signal of the intake manifold pressure against a high-fidelity nonlinear model
The linear state-space matrices are derived by a linearization of the nonlinear model
and a subsequent discretization. The same linearization point as the one used for
the PI design is chosen. It is the steady-state value of xss(ulin) for the input ulin =
[0.5 0.5]
T. The resulting state-space model is augmented by states that represent the
dead-time. The dead-time is mapped into poles in z = 0. For the LMPC algorithm,
a sampling time of Ts = 0.05 s is used to account for the reduced computation time
compared to the NMPC controller. The value for the number of prediction steps is
increased, i.e. N = 50.
In all simulations, the same plant model is used. It is a nonlinear model that is
more complex, i.e. it contains more system states than the one presented in Chap. 10.
Thus, it is also different from the controller-internal model of the NMPC controller.
Figure 11.8 shows the control results for a step input for the intake manifold
pressure reference and a constant reference value for the burnt gas ratio. All control
algorithms are able to track the references in an offset-free manner. However, the
transient behavior differs. As expected, the NMPC controller performs best. It takes
into account the main nonlinearities and allows for a suitable reference tracking.
The LMPC performs slightly worse. It shows oscillatory behavior on the intake
manifold, and the burnt gas ratio drops during the step input. The response time
of the intake manifold pressure is significantly slower when using the PI control
algorithm. Additionally, a considerable drop in the burnt gas ratio is visible. These
results are according to the expectations. The control performance corresponds to the
available model knowledge of the various controllers. While LMPC already allows
to systematically take into account cross-couplings, dead-times, and constraints, its11.3 Simulative Comparison of the Controllers 265
-0.1
0
0.1
0.2
0.3
0 20 40
0
0.2
0.4
0.6
0.8
1
0 20 40
-0.2
0
0.2
0.4
0.6
0.8
1
1.1
1.2
1.3
1.4
1.5
1.6
Fig. 11.9 Comparison of closed-loop control results for LMPC, NMPC, and PID against a high￾fidelity nonlinear model
performance is especially appropriate close to the region of the state-space at which
the model is linearized. The NMPC does not contain this restriction and offers a high
performance in the entire state-space.
Figure 11.9 shows the closed-loop control result obtained in simulations of the
three controllers for a more complex reference trajectory. The NMPC is able to
reference-track the profiles for the intake manifold pressure and the burnt gas ratio
with a very high control quality. The LMPC is able to reference-track the profiles as
well. However, it is slower in the transients than the NMPC. The PI control algorithm
is able to appropriately track the burnt gas ratio, but the tracking of the intake manifold
pressure is rather slow.
11.4 Experimental Validation
In the simulations, the NMPC controller outperforms the LMPC and the PI con￾troller for the air path control problem. The simulative environment makes compar-266 11 Combined Exhaust Gas Recirculation and VTG: Control
0
0.1
0.2
0.3
xbg [1]
0 10 20 30 40 50
t [s]
0
0.2
0.4
0.6
0.8
1
uvtg [1]
0 10 20 30 40 50
t [s]
0
0.2
0.4
0.6
0.8
1
uegr [1]
1
1.1
1.2
1.3
1.4
1.5
pim [bar]
Reference
Simulation
Measurement
Fig. 11.10 Experimental validation of the NMPC controller, along with simulations of the closed￾loop control behavior
isons possible, as the controllers can be tested with identical conditions. However, to
validate the suitability of the NMPC algorithm for practical applications, an exper￾imental validation is mandatory. The design of the NMPC controller still depends
on the assumption that the nonlinear process model is a good approximation of the
real engine behavior. Additionally, further requirements such as real-time feasibility
have to be achieved.
Figure 11.10 shows the closed-loop control results of the NMPC algorithm at the
engine test bench. They show that the NMPC algorithm is able to track the reference
on a real engine with a high control quality. All requirements on the control algorithm,
such as offset-free control and real-time feasibility, can be fulfilled. The trajectory of
the simulated closed-loop control result is depicted together with the measurement
data from the engine test bench. For both the simulation and the actual measurements,
the same reference trajectory is used. The two trajectories match very well, with only
slight offsets. This validates the suitability of the simulation.
References
1. N. Abe, K. Yamanaka, Smith predictor control and internal model control – a tutorial, in SICE
Conference (2003), pp. 1383–1387
2. Q.-G. Wang, Decoupling Control (Springer, Berlin, 2002)Chapter 12
Two-Stage Turbocharging: Modeling and
Analysis
Abstract A second case study for a control system of the air path is examined.
While the first one investigated the combined control of burnt gas ratio and VTG
turbocharger for a CI engine, now, the control of the intake pressure for an SI engine
is investigated. A setup is examined with two turbocharging units which are placed
in series. This setup allows for a fast transient increase in load and at the same time
for high specific power. In this chapter, the modeling of the two-stage turbocharging
system is inspected. A suitable state-space model is derived which is computationally
efficient and is still able to reproduce the system behavior with reasonable accuracy.
Additionally, the system dynamics are analyzed, which becomes especially important
for the design of suitable formulations of the optimization problem. This concerns
for example the influence of the actuation on the pumping losses.
12.1 Introduction
Conventional turbocharger architectures consist of a single turbine and a single com￾pressor which are connected by a common shaft. These single-stage turbocharging
concepts exhibit inherent limitations on the simultaneous improvement of transient
load performance and increase of the specific power which is advantageous to reduce
fuel consumption. The sizing of the charging unit directly affects this trade-off. Large
devices enhance the specific power output and reduce fuel consumption, especially
at high engine speeds. However, they impair the transient load performance. Small
devices, on the other side, provide a fast torque response and therefore, improve the
driveability of the vehicle, especially at low engine speeds but cannot offer high spe￾cific power. To attain a combination of the best aspects of large and small devices,
increasingly complex air path architectures are investigated which cope with the
severe requirements. For SI engines, the two-stage turbocharging is one of the con￾cepts analyzed. In this case study, the control system of a two-stage turbocharging
unit with a nonlinear model predictive control (NMPC) algorithm is investigated.
The chapter summarizes the results of earlier publications by the author [1–4].
The two-stage turbocharging concept typically consists of a small high-pressure
turbocharger and a larger low-pressure turbocharger combined in series. Compared to
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_12
267268 12 Two-Stage Turbocharging: Modeling and Analysis
a single-stage concept, an improvement of the transient behavior is realized due to the
small high-pressure stage, while the large low-pressure stage enables a higher power
output. In order to fully exploit the system capabilities given by the hardware, the
closed-loop control system has to manage the coordinated timing of the engagement
and disengagement of the stages. The control task is to track the reference value for
the charging pressure pchar while rejecting any disturbances acting on the system.
The requirements on the closed-loop control behavior result from various aspects.
Due to the quantitative load control of a SI engine, a fixed air-to-fuel ratio is main￾tained for the combustion. As a consequence, there is a direct correlation between the
charging pressure, the amount of air inducted in the cylinder, the fuel amount injected,
and the torque generated. The reference value for the charging pressure should thus be
reached as quickly as possible, as this determines the transient acceleration capability
of the vehicle. However, in case of a step on the reference value, the output should
additionally be achieved without any strong overshoots as they negatively influence
the driving behavior. For CI engines, this requirement is not as pronounced. The
working principle of a CI engine does not require a fixed air-to-fuel ratio. Instead,
as an excess of air is present all the time, the torque is mainly based on the fuel
amount injected. Therefore, in a CI engine, the torque and the charging pressure are
decoupled such that oscillations can be tolerated up to a certain amount. Addition￾ally, the control algorithm for the two-stage turbocharging system must respect the
upper limit constraints for the high-pressure and low-pressure turbocharger speeds,
as exceeding these limits might damage the turbocharger. This becomes especially
challenging as the exhaust gas temperatures from an SI engine are very high, such
that the limits can be reached relatively quickly and the turbocharger speed typically
is not measured in a series-production configuration.
In summary, three substantial requirements have to be fulfilled at the same time,
which are
• quick reference tracking,
• no oscillatory behavior for a step reference, and
• considering limits on turbocharger speeds.
These demands have to be fulfilled while the system to be controlled is very nonlinear,
the system dynamic behavior is very dependent on disturbance signals such as the
engine speed, and a considerable dead-time is present.
Various control concepts have been investigated for the control of turbochargers.
Due to the complex system dynamics, especially model-based control techniques
are applied. An exemplary approach is presented in [12, 13], where flatness-based
control is used based on a model derived in [21]. The work published in [18, 19]
use advanced internal model control (IMC) algorithms for the control task. Among
the various model-based control techniques, especially the MPC algorithm shows
advantages, due to the fact that it can consider constraints on actuated signals and
on system states, for instance, constraints on the turbocharger speeds must be con￾sidered. Various MPC techniques have been investigated, and these concern online
optimization techniques [6, 7, 11, 17, 20] as well as explicit MPC formulations such
as [8, 9].12.1 Introduction 269
For more complex turbocharging architectures, such as two-stage turbocharg￾ing, one investigated strategy is to ascribe the system to the well-known one-stage
turbocharging problem which is approached as a single-input single-output (SISO)
system. This is achieved by introducing a logic that switches between feedback con￾trolling either the LP or the HP stage depending on the current operating point [15,
16]. For low exhaust gas enthalpy (e.g. at low engine speeds), the small turbocharger
is feedback controlled while for high exhaust gas enthalpy (e.g. at high engine
speeds), the LP stage is feedback controlled. The NMPC offers the advantage that
the entire multiple-input multiple-output (MIMO) control problem including all aris￾ing requirements can be tackled in a systematic manner. For this reason, the NMPC
framework is a suitable choice for the control algorithm. The following case study
shows that the nonlinear system dynamics can be handled with a high control quality
and that the NMPC approach is able to respect the constraints on the system states.
12.2 System Setup
Figure 12.1 shows the schematic setup of the air path architecture investigated. Each
turbocharging stage consists of a compressor and a turbine that are connected by a
common shaft. For an experimental analysis of the system, the architecture depicted
was built up and implemented in a demonstrator vehicle with a 1.8 L four-cylinder
SI engine with gasoline fuel. The control algorithm was implemented in the vehicle
on rapid control prototyping hardware. The experiments conducted in this case study
were all recorded with this demonstrator vehicle. A more detailed overview on the
system is provided in [5, 10].
Fig. 12.1 Two-stage
turbocharging setup270 12 Two-Stage Turbocharging: Modeling and Analysis
12.2.1 Sensors
The controlled variable of the system is the charging pressure pchar, which is mea￾sured with a pressure sensor positioned between the intercooler and the throttle valve.
The application of sensors and advanced actuators in the exhaust gas path is unfavor￾able for a SI engine series configuration. Significant drawbacks in terms of durability
and cost result due to the high exhaust gas temperatures in SI engines. Thus, the con￾trol approach presented does not include any sensor signal from the exhaust gas path.
Besides the controlled variables, several measured variables are employed, i.e. the
engine speed ωeng, the ambient pressure pamb, and the ambient temperature ϑamb.
All three values are available in a series-production vehicle. For the purpose of mod￾eling and validation of the control algorithm, additional sensors are installed in the
car. However, they are not used in the controller. Especially the turbocharger speeds,
the pressure between the compressors and in the exhaust manifold which yield the
pressure ratio over the two compressors, are measured in the demonstrator vehicle
for modeling and validation purposes, but they are not used as inputs for the control
algorithm.
12.2.2 Actuators
As actuators for the control system, a wastegate on the high-pressure uwg,hp and on
the low-pressure stage uwg,lp is used. Commonly, electronic wastegates are applied
for turbocharging. They have the advantage of containing a position feedback sensor,
which allows for an accurate setting of the valve opening area. In this case study, the
use of simpler and cheaper pneumatic actuators is investigated. For instance, they do
not have any additional sensors for position feedback, which makes the development
of the controller more demanding. The wastegate actuation signals are pulse-width￾modulated (PWM) signals with an operating range of uwg,hp = [0 ... 100]% and
uwg,lp = [0 ... 100]%. They allow manipulation of the pilot pressure, influencing
the effective opening area of the wastegate. Thus, the amount of exhaust gas that
passes the turbine can be adjusted. A value of uwg = 0% opens the wastegate, while
a value of uwg = 100% closes the wastegate as much as possible. When the wastegate
is fully open, the majority of the exhaust gas bypasses the turbine, whereas a fully
closed wastegate allows all the exhaust gas to flow through the turbine. The archi￾tecture considered also contains a throttle valve which is controlled via a separate
controller that is not part of the turbocharger controller. At very high mass flows,
the high-pressure stage no longer delivers an increase in the charging pressure. Still,
no additional high-pressure bypass was used, thus allowing efficiency losses at high
mass flows.12.2 System Setup 271
12.2.3 Engine Control Algorithm
The control concept investigated focuses on the closed-loop control of the charging
pressure pchar by actuating the high-pressure and low-pressure wastegate PWM
signals uwg,hp and uwg,lp. The engine speed ωeng, the ambient pressure pamb, and
the ambient temperature ϑamb are used as measured disturbances. In today’s series
applications, the throttle valve is only used in the non-turbocharged region. In the
turbocharged region, the throttle valve is set completely open, for reasons of fuel
efficiency. As a consequence, the charging pressure pchar is equal to the intake
manifold pressure pim in the turbocharged region and is thus directly correlated
to the torque of the engine. The throttle valve is not investigated further for the
turbocharger control concept. The setpoint for the charging pressure is determined
based on the requested engine torque, as commonly done in torque-oriented engine
control structures; see Fig. 7.7. All other parameters of the engine control structure,
such as ignition, injection, and camshaft position, are equal to the standard calibration.
The air path NMPC control algorithm and all other engine control functions such as
the setpoint calculation and ignition timing are implemented on one single dSPACE
MicroAutoBox II system.
12.3 Nonlinear Process Model for Two-Stage
Turbocharging
In the following, the derivation of the nonlinear state-space model is introduced
which is used as a basis for the controller-internal model of the NMPC algorithm.
The resulting model is compared to measurement data obtained from experiments
conducted on the vehicle.
12.3.1 Fundamental Equations of Two-Stage Turbocharging
For determining the turbocharger angular speed on the high-pressure ωtc,hp and on
the low-pressure stage ωtc,lp, Newton’s second law is used. The equation of motion
is described in (12.1) and (12.2), where the powers generated by the turbines Pt,hp
and Pt,lp are considered as well as the powers consumed by the compressors Pc,hp
and Pc,lp. The mass moment of inertia of the turbochargers are given by Jtc. The
values for Jtc,hp and Jtc,lp are determined via system identification.
ω˙tc,hp(t) = 1
ωtc,hp(t)Jtc,hp

Pt,hp(t) − Pc,hp(t)

(12.1)
ω˙tc,lp(t) = 1
ωtc,lp(t)Jtc,lp

Pt,lp(t) − Pc,lp(t)

(12.2)272 12 Two-Stage Turbocharging: Modeling and Analysis
The expressions (12.3) and (12.4) calculate the consumed power on the two stages
of the compressor. Similarly, the relationship for the generated power of both turbine
stages is expressed in (12.5) and (12.6).
Pc,hp = ˙mc,hp(t)cp,airϑuc,hp
1
ηc,hp 

κair −1
κair
c,hp − 1

(12.3)
Pc,lp = ˙mc,lp(t)cp,airϑuc,lp
1
ηc,lp 

κair −1
κair
c,lp − 1

(12.4)
Pt,hp = ˙mt,hp(t)cp,exhϑut,hpηt,hp 
1 − 
1−κexh κexh
t,hp 
(12.5)
Pt,lp = ˙mt,lp(t)cp,exhϑut,lpηt,lp 
1 − 
1−κexh κexh
t,lp 
(12.6)
The specific heat capacity is given by cp, i.e. cp,air = 1005 J
kgK and cp,exh = 1117 J
kgK
are used. The heat capacity ratio is denoted by κ, i.e. κair = 1.4 and κexh = 1.33
are applied. The mass flows through the compressors and the turbines are denoted
by m˙ . The efficiencies are denoted by η and are assumed to be constant. They are
determined via system identification. Within the equations, the temperature upstream
of the compressors and the turbines are denoted by ϑ. They represent a constant,
medium value in their operating range. The pressure ratios relate the upstream and
downstream conditions, and they are given by
t = put
pdt
(12.7)
c = pdc
puc
(12.8)
The compressor is modeled by correlating the rotational kinetic energy of the tur￾bocharger to the pressure ratio over the compressor via an affine mapping. For the
low-pressure stage, an affine map with c,lp as input is used. Due to the large spread
of exhaust enthalpy and operating points of the compressor, the high-pressure stage
has to be modeled in dependence of c,hp and the angular speed of the engine ωeng.
The constants are identified by a linear regression with measurement data.
ω2
tc,lp = alpc,lp + blp (12.9)
ω2
tc,hp = 
ahpωeng + chp
c,hp + 
bhpωeng + dhp (12.10)
As described in [1, 14], the model can be simplified by a model order reduction
technique called singular perturbation. The application of a singular perturbation
confirms that the dynamics of the volumes can be neglected. As a consequence, the
mass flows in all cross-section areas of the intake and the exhaust path are assumed
to be equal, yielding the relations (12.11)–(12.12). In the exhaust path, the total mass
flow is equal to the mass flow through the turbine plus the mass flow through the12.3 Nonlinear Process Model for Two-Stage Turbocharging 273
wastegate.
m˙ asp = ˙mc,hp = ˙mc,lp (12.11)
m˙ asp + ˙m f uel = ˙mt,hp + ˙mwg,hp = ˙mt,lp + ˙mwg,lp (12.12)
A simplified model is used to calculate the aspirated mass flow of the engine. It
uses a constant volumetric efficiency ηv, the charging pressure pchar, and the intake
manifold temperature ϑim which is assumed to be constant and represents a medium
value of its operating range, the displacement volume of all the cylinders combined
Vdis, the specific gas constant R, the engine speed neng given in revolutions per
second, and the number of revolutions per cycle, i.e. N = 2. The pressure upstream
of the low-pressure compressor is set equal to the measured ambient pressure puc,lp =
pamb.
m˙ asp = ηv pchar(t)Vdisneng(t)
Rϑim N
= ηv pamb(t)c,lp(t)c,hp(t)Vdisneng(t)
Rϑim N
(12.13)
The fuel mass flow can be calculated by taking into account the stoichiometric air￾to-fuel ratio AFRs, i.e. AFRs = 14.7 can be used for gasoline combustion. For the
direct-injection engine it results:
m˙ f uel = m˙ asp
AFRs
(12.14)
The mass flow through the wastegates can be calculated by a compressible flow
restriction model, where only the non-choked region is taken into account. The
expressions designated by a star  hold for the high- and the low-pressure stage, i.e.
 = {lp, hp}.
m˙ wg, = cd Awg,(uwg,) pdt, Rϑut,
t,ψt, 
t,
ψt, 
t,
= −1
κ
t,	 2κ
κ − 1 · flim 
1 − −κ+1
κ
t, 
flim(x) = 1
2

x 2 + ε +
1
2
x
(12.15)
The mass flow through the turbine is calculated by a slightly modified version of the
compressible flow equation model. The modified version shows a better fit to the
measurement data than the standard equations.274 12 Two-Stage Turbocharging: Modeling and Analysis
m˙ t, = cd At,
pdt, Rϑut,
t,ψt, 
t,
ψt, 
t,
= κ−2
2κ
t, 	 2κ
κ − 1 · flim 
1 − −κ+1
κ
t, 
flim(x) = 1
2

x 2 + ε +
1
2
x
(12.16)
For the high-pressure and the low-pressure wastegate, different actuation principles
are used. At the high-pressure stage, a system is used that actuates the wastegate by
means of underpressure delivered by a vacuum pump. The opening area Awg,hp is
approximated well by a linear correlation with the actuation signal.
Awg,hp =

1 − uwg,hp
100

Awg,hp,max (12.17)
For opening the low-pressure stage wastegate, a system is used that is driven by
excess pressure, i.e. the charging pressure. The opening area of the wastegate is
modeled in a black-box model fashion by the application of sigmoid functions.
Awg,lp = f (pambc,lpc,hp, uwg,lp) (12.18)
For several reasons, the implementation of the turbocharger architecture in a vehicle
causes a quite considerable dead-time. A major impact results from the working
principle of the pneumatic actuation. A change in the actuation signal must first
result in a pressure change inside the wastegate actuator before the wastegate position
changes. Instead of modeling all these effects individually, they are summarized as
one overall dead-time TD which acts directly on both actuated values. The same
dead-time can be used for both actuated values.
uwg, = uwg,(t − TD) (12.19)
12.3.2 Overall State-Space Model
The various equations can be combined to one overall state-space model. The
resulting model consists of a set of differential–algebraic equations (DAE). For this
purpose, let x(t) ∈ Rnx denote the differential states, x˙(t)the differential state deriva￾tives, z(t) ∈ Rnz the algebraic variables, while u(t) ∈ Rnu represents the actuated
values and u˙(t) their derivatives. The system is governed by introducing the differ￾ential states x1 = c,lp, x2 = c,hp, and the algebraic states z1 = t,lp, z2 = t,hp.
The output functions are defined by (12.20)–(12.22).
pchar = pambc,lpc,hp (12.20)12.3 Nonlinear Process Model for Two-Stage Turbocharging 275
ωtc,lp =


alpc,lp + blp (12.21)
ωtc,hp =


ahpneng + chp
c,hp + 
bhpneng + dhp (12.22)
The DAE model is of index one and consists of two differential and two algebraic
states. The output y1 corresponds to the charging pressure pchar, which forms the
tracking objective. The outputs y2 and y3 correspond to the low-pressure and the
high-pressure turbocharger speeds ωtc,lp and ωtc,hp, which are to be constrained as
part of the NMPC formulation.
12.4 Analysis of the System Dynamics
The implementation of an NMPC algorithm requires a model of the process as well
as a suitable formulation of the optimization problem. In the particular case of a
two-stage turbocharging unit, the choices need to reflect that the transient behavior
should be as fast as possible and that the wastegates should be actuated taking into
account the fuel economy, which is influenced by the pumping losses. The pump￾ing losses describe the work required to aspirate gas into and out of the cylinders.
These performance requirements can be incorporated in various ways. To derive a
suitable optimization problem, the system dynamics are investigated with respect to
the control requirements.
12.4.1 Stationary System Behavior
One distinct property of the two-stage turbocharging system is its overactuation. Two
actuated values are present to control one output value. A desired charging pressure
can be realized by numerous combinations of wastegate positions for the low- and
the high-pressure stage. The split over these two stages influences the exhaust gas
back pressure. The exhaust gas back pressure itself correlates to the pumping losses
and thus to the efficiency and the fuel consumption of the engine. During the exhaust
stroke, the cylinder pressure can be assumed to be equal to the exhaust gas back
pressure pcyl = pexh, whereas during the intake stroke, the cylinder pressure can
be assumed to be equal to the charging pressure pcyl = pchar. Using Vdis for the
displacement volume of all cylinders, the pumping losses Wp can be calculated by
Wp = (pexh − pchar)Vdis (12.23)
The pumping loss mean effective pressure (PMEP) is calculated as follows:
PMEP = pexh − pchar (12.24)276 12 Two-Stage Turbocharging: Modeling and Analysis
Figure 12.2 shows the resulting charging pressure and the exhaust gas back pressure in
dependence of the wastegate positions. For a constant charging pressure, the pumping
losses directly correlate to the exhaust gas back pressure. The dependence of the
exhaust gas back pressure on the wastegate position is shown by the isocurves for
pchar = 1.5 bar and pchar = 1.9 bar. The measurement data depicted in Fig. 12.2
show that for pchar = 1.5 bar at an engine speed of neng = 3500 1
min , the PMEP
ranges from a minimum of PMEP = 0.3 bar when uwg,hp = 0 to a maximum of
PMEP = 0.7 bar when uwg,lp = 0. At pchar = 1.9 bar, the difference ranges from
PMEP = 0.5 bar to a maximum of PMEP = 1.0 bar. This result implies that
choosing the correct control strategy can improve the PMEP by up to 0.5 bar,
which corresponds to approximately 3 kW.
The experimental results show that for reducing pumping losses, it is always best to
use the combination with a maximum application of the low-pressure turbocharging
stage. This can be realized by closing the low-pressure wastegate and opening the
high-pressure wastegate as much as possible to realize a certain charging pressure.
This characteristic is valid for high as well as for low engine speeds, although at low
engine speeds, the difference in the exhaust gas back pressure declines.
12.4.2 Transient System Behavior
The two-stage turbocharging system is used to improve the transient response behav￾ior while at the same time allowing for high power outputs. A high-pressure stage
thus allows for a faster increase of the charging pressure due to the smaller mass
moment of inertia Jtc,hp and the significantly lower flow cross-sections of the com￾pressor and the turbine. On the other hand, the low-pressure stage is larger which,
due to the larger mass moment of inertia Jtc,lp, results in a slower increase of the
charging pressure.
For the experimental analysis, a vehicle dynamometer was used to measure at
several constant engine speeds. Various step inputs were applied to the two waste￾gates. The value that describes the time required until 95% of the steady-state value
is reached for the first time is the characteristic value t95. The value t95 is used to
compare the transient response. Figure 12.3 shows an exemplary experimental result
of the transient behavior of the high- and low-pressure stages. The plot shows a nor￾malized expression of the charging pressure with respect to the steady-state value

pchar /
pchar,ss, the rotational speed of the two turbochargers, and the wastegate
signals applied. The colors each correspond to one independent measurement. In both
cases, the step is applied at t = 0 s. When the step is applied on the low-pressure
wastegate, the step response shows a characteristic time value of t95,lp = 2.8 s. By
contrast, when the step is applied on the high-pressure wastegate, the value can be
reduced to t95,hp = 1 s. As long as the high-pressure stage is able to deliver the torque
required, for the entire operating range investigated, from a transient perspective, it
is recommendable to use the high-pressure stage.12.4 Analysis of the System Dynamics 277
Fig. 12.2 Maps with charging and exhaust gas back pressure for various engine speeds with charg￾ing pressure isocurves – Reproduced from [2], originally published open access under a Creative
Commons CC BY 4.0 license, https://doi.org/10.3390/en9070530278 12 Two-Stage Turbocharging: Modeling and Analysis
Fig. 12.3 Measured step responses for steps in high- and low-pressure wastegates at constant
engine speed – Reproduced from [2], originally published open access under a Creative Commons
CC BY 4.0 license, https://doi.org/10.3390/en9070530
12.5 Validation of Reduced-Order Model
In order to validate the proposed model, measurement data was obtained using the
demonstrator vehicle at constant engine speed as well as at varying engine speeds.
For measurements at constant engine speed, a dynamometer test bench was used,
where the engine speed was set to various values between neng = 1500 1
min and
neng = 3500 1
min .12.5 Validation of Reduced-Order Model 279
Fig. 12.4 Validation of the
dynamic behavior of the
model [3], adapted with
permission from
IFAC-PapersOnLine,
c 2015 International
Federation of Automatic
Control (IFAC)
1
0.5
0
100
50
0
100
50
0
0246
Figure 12.4 shows a validation of the dynamic behavior. The measurement of a step
response on the low-pressure wastegate is compared to a simulated step response.
Both are obtained at a constant engine speed of neng = 2500 1
min . For comparing
the transient behavior, the output, i.e. the charging pressure, is normalized, thus
neglecting the stationary offset between these two values. The model is able to
reproduce the transient behavior of the system very well, including effects such as
the dead-time. Based on the measurement data, the resulting dead-time is estimated to
be TD = 0.45 s. This value is quite large and makes the control task more challenging
for the NMPC implementation.280 12 Two-Stage Turbocharging: Modeling and Analysis
Fig. 12.5 Validation of the
steady-state behavior of the
model – c [2015] IEEE.
Reprinted, with permission,
from [1]12.5 Validation of Reduced-Order Model 281
Figure 12.5 shows the result of a validation experiment for steady-state behavior.
The upper plot shows the steady-state measurement data for the charging pressure
pchar recorded on a grid of various values for uwg,lp and uwg,hp at a constant engine
speed of neng = 2500 1
min . The plot in the middle shows the steady-state data for the
charging pressure pchar obtained by simulating the model. The lower plot shows the
resulting model error with absolute values. The model is able to qualitatively and
quantitatively reproduce the measurement data quite well.
References
1. T. Albin, D. Ritter, D. Abel, N. Liberda, R. Quirynen, M. Diehl, Nonlinear MPC for a two-stage
turbocharged gasoline engine airpath, in IEEE Conference on Decision and Control (2015),
pp. 849–856
2. T. Albin, D. Ritter, N. Liberda, D. Abel, Boost pressure control strategy to account for transient
behavior and pumping losses in a two-stage turbocharged air path concept. Energies 9(7), 530–
545 (2016)
3. T. Albin, D. Ritter, N. Liberda, S. Pischinger, D. Abel, Two-stage turbocharged gasoline
engines: experimental validation of model-based control. IFAC PapersOnLine 48(15), 124–
131 (2015)
4. T. Albin, D. Ritter, N. Liberda, R. Quirynen, M. Diehl, In-vehicle realization of nonlinear MPC
for gasoline two-stage turbocharging airpath control. IEEE Trans. Control Syst. Technol. 26(5),
1606–1618 (2018)
5. F. Buchner, S. Wedowski, A. Sehr, S. Glueck, C. Schernus, In-vehicle optimization of 2-stage
turbocharging for gasoline engines. Int. J. Autom. Eng. 2(4), 143–148 (2011)
6. P. Dickinson, K. Glover, N. Collings, Y. Yamashita, Y. Yashiro, T. Hoshi, Real-Time Control
of a Two-Stage Serial VGT Diesel Engine Using MPC. IFAC-PapersOnLine 48(15), 117–123
(2015)
7. P. Drews, K. Hoffmann, R. Beck, R. Gasper, A. Vanegas, C. Felsch, N. Peters, D. Abel, Fast
model predictive control for the air path of a turbocharged diesel engine, in European Control
Conference (2009), pp. 3377–3382
8. J. El Hadef, S. Olaru, P. Rodriguez-Ayerbe, G. Colin, Y. Chamaillard, V. Talon, Explicit non￾linear model predictive control of the air path of a turbocharged spark-ignited engine, in IEEE
Conference on Control Applications (2013), pp. 71–77
9. J. El Hadef, S. Olaru, P. Rodriguez-Ayerbe, G. Colin, Y. Chamaillard, V. Talon, Nonlinear
model predictive control of the air path of a turbocharged gasoline engine using Laguerre
functions, in International Conference on System Theory, Control and Computing (2013), pp.
193–200
10. S. Glück, Charging concepts for a two-stage turbocharging gasoline engine. Ph.D. Thesis,
RWTH Aachen University (2013)
11. M. Huang, H. Nakada, K. Butts, I. Kolmanovsky, Nonlinear model predictive control of a
diesel engine air path: a comparison of constraint handling and computational strategies. IFAC￾PapersOnLine 48(23), 372–379 (2015)
12. P. Kotman, M. Bitzer, A. Kugi, Flatness-based feedforward control of a two-stage turbocharged
diesel air system with EGR, in IEEE Conference on Control Applications (2010), pp. 979–984
13. P. Kotman, A. Kugi et al., Flatness-based feedforward control of a diesel engine air system
with egr. IFAC Proc. 43(7), 598–603 (2010)
14. P. Moulin, Air systems modeling and control for turbocharged engines. Ph.D. Thesis, École
Nationale Supérieure des Mines de Paris (2010)
15. P. Moulin, O. Grondin, Control design for a second order dynamic system: two-stage tur￾bocharger, in Proceedings of Advances in Automotive Control (2013), pp. 460–466282 12 Two-Stage Turbocharging: Modeling and Analysis
16. P. Moulin, O. Grondin, L. Fontvieille, Control of a two-stage turbocharger on a diesel engine,
in IEEE Conference on Decision and Control (2009), pp. 5200–5206
17. A. Murilo, M. Alamir, D. Alberer, A general NMPC framework for a diesel engine air path.
Int. J. Control 87(10), 2194–2207 (2014)
18. R. Nitsche, D. Schwarzmann, J. Hanschke, Nonlinear internal model control of diesel air
systems. Oil Gas Sci. Technol.-Revue de l’IFP 62(4), 501–512 (2007)
19. Z. Qiu, M. Santillo, M. Jankovic, J. Sun, Composite adaptive internal model control and its
application to boost pressure control of a turbocharged gasoline engine. IEEE Trans. Control
Syst. Technol. 23(6), 2306–2315 (2015)
20. M. Santillo, A. Karnik, Model predictive controller design for throttle and wastegate control
of a turbocharged engine, in American Control Conference (2013), pp. 2183–2188
21. D. Schwarzmann, R. Nitsche, J. Lunze, Modelling of the air-system of a two-stage turbocharged
passenger car diesel engine, in Proceedings of the MATHMOD (2006)Chapter 13
Two-Stage Turbocharging: Control
Abstract This chapter investigates a model predictive control (MPC) algorithm for
the two-stage turbocharging concept of an SI engine. Due to the working principle of
an SI engine, quick reference tracking is demanded for the air path control while no
oscillatory behavior should be present for a step in the reference signal. At the same
time, the speed limits for the turbocharger have to be respected. Within the two-stage
turbocharging setup, an additional requirement is present due to the overactuation.
In stationary operation, the reference is to be tracked in a fuel-efficient manner while
quick transients must be achieved. A nonlinear MPC (NMPC) algorithm is investi￾gated that allows all the demanding requirements on the closed-loop system to be
satisfied. The present chapter outlines a suitable controller-internal model, a prob￾lem formulation, and numerical solution techniques. For the validation of the control
algorithm developed, exemplary simulations as well as in-vehicle experiments are
presented.
13.1 Nonlinear MPC Algorithm
In the following, an NMPC concept for the two-stage turbocharging system is pre￾sented. All necessary components, the controller-internal model, the problem formu￾lation, and the numerical solution techniques are outlined. The NMPC algorithm is
based on the process model and the analysis derived in Chap. 12. A special emphasis
is placed on the exploitation of the overactuated hardware setup. For this purpose, a
tailor-made formulation of the optimization problem is derived.
13.1.1 Controller-Internal Model
The controller-internal model of the NMPC algorithm is based on the process model
derived in Sect. 12.3. This base model is defined as an differential–algebraic equation
(DAE) system and consists of two inputs u(t), two differential states x(t), two
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_13
283284 13 Two-Stage Turbocharging: Control
algebraic states z(t), one output that is reference tracked ypchar (t), and two outputs
that are considered as constraints yωtc (t).
For the NMPC algorithm, a discretized model is required. To discretize the
continuous-time model, a numerical integration algorithm is applied. Since the model
comprises a DAE system, an implicit integration method is required, as discussed
in [5]. As the DAE is of index one, the Jacobian matrix ∂ f (·)
∂(z,x˙) is invertible, which
is a requirement of most simulation methods. In this case, an implicit Runge–Kutta
method of fourth order is applied. For the discrete dead-time, kd = Td /Ts is used
where Ts is the sampling time. The function f d (x(k), u(k − kd )) denotes the numer￾ical simulation of the nonlinear states throughout one sampling step, starting from
the given state x(k) and using the actuated values u(k − kd ) that are constant over
each integration step. The overall discretized model looks as follows, where k is the
discrete sampling instant:
x(k + 1) = f d (x(k), u(k − kd ))
y(k) = g(x(k)) (13.1)
The closed-loop controller is required to achieve offset-free tracking even in the
presence of disturbances or a model–plant mismatch. For the two-stage turbocharging
application, the goal is that the reference of the charging pressure ypchar is tracked
without any offset for a reference and disturbances that are asymptotically constant.
In order to compensate for model–plant mismatch and disturbances, an additional
disturbance model is introduced. The calculation of the charging pressure is thus
augmented by an additional disturbance state d(k) ∈ R, which acts on the output, as
introduced in Sect. 6.2.2.
ypchar ,aug(k) = gpchar (x(k)) + d(k) (13.2)
For the prediction within the NMPC algorithm, the disturbance state is assumed to
be constant over the prediction horizon.
d(·|k) = d(k) (13.3)
All system, disturbance, and output states are assumed to exhibit zero mean Gaussian
white noise. An extended Kalman filter (EKF) is used for the estimation of the system
states xes and the disturbance d.
13.1.2 Formulation of the Optimization Problem
The formulation of the optimization problem plays a fundamental role in the closed￾loop control performance. The requirements of the control system have to be taken
care of appropriately. For the two-stage turbocharging setup, this concerns especially13.1 Nonlinear MPC Algorithm 285
Fig. 13.1 Two-layered approach for handling the multi-objective targets – Reproduced from [1],
originally published open access under a Creative Commons CC BY 4.0 license, https://doi.org/
10.3390/en9070530
the appropriate exploitation of the overactuation. A fast transient response has to be
realized while achieving a high efficiency at steady-state operation. For fast transient
response, the high-pressure stage has to be used as much as possible to quickly
increase the charging pressure. At steady-state conditions, the low-pressure stage
must be used as much as possible. A suitable strategy is using the high-pressure stage
in the transients and then shifting to the low-pressure stage. Thus, multi-objective
targets need to be satisfied. In the following, a two-layered approach is presented to
realize this behavior. It consists of two optimization problems, i.e. the target selector
and the dynamic regulator as shown in Fig. 13.1.
Target Selector
The target selector calculates the optimal steady-state values for the actuated values
uss and for the system states xss. Within this optimization problem, the reference
value of the charging pressure pchar,ref , the measured values ωeng, pamb, and ϑamb
as well as the estimated disturbance d serve as inputs. The following optimization
problem is solved within the target selector:
min
xss, uss, ss
uT
ss Rluss + Sss (13.4a)
s.t. 0 = xss − f d (xss, uss), (13.4b)
pchar,ref = gpchar (xss) + d, (13.4c)
umin ≤ uss ≤ umax , (13.4d)
yωtc ,ss ≤ ωtc,max + ss, (13.4e)
0 ≤ ss (13.4f)
The target selector calculates values that strongly rely on the low-pressure stage
by appropriate penalization Rl within the cost function such that the goal of high
efficiency in steady-state operation is realized. Within the optimization problem,
steady-state dynamics are considered as a constraint (13.4b). The reference value
is incorporated as equality constraint (13.4c). Within the closed-loop control val￾idations, the reference value has proven to be always feasible; thus, this equality
constraint is not softened. Additionally, the physical constraints on the actuated val￾ues are considered as (13.4d) shows. The constraints on the turbocharger speeds are286 13 Two-Stage Turbocharging: Control
implemented, including slack variables (13.4e)–(13.4f). The vector of slack variables
are denoted by ss ∈ R2. The slack variables enter the cost function in a linear fash￾ion. The solver applied uses automatic regularization, thus no additional quadratic
terms are applied for penalization of the slack variables.
Dynamic Regulator
The second optimization problem is formed by the dynamic regulator. In this layer, the
actuated values are calculated that are applied to the plant. Unlike the target selector,
the dynamic regulator also incorporates the transient system behavior. The optimal
steady-state values uss, xss, the estimated states xes as well as the measured values
ωeng, pamb, and ϑamb serve as inputs. The optimization problem for the dynamic
regulator is set up as given by multiple shooting. An equidistant grid of N + 1
shooting intervals is considered over the predicted horizon. Within each shooting
interval, a piecewise constant control parametrization u(τ ) = ui for τ ∈ [ti, ti+1) is
applied. The cost function of the optimization problem for the dynamic regulator
reads as follows:
J = 
N
i=0

||x(k + kD + i + 1|k) − xss(k)||2
Qi + ||u(k + i | k) − uss(k)||2
Rss,i
+ ||u(k + i | k) − u(k + i − 1 | k)||2
Rd,i + S(k + i | k)

(13.5)
The optimization variables are given by the trajectory of actuated values u(·|k), the
system states x(·|k), and the slack variables (·|k). In the cost function, various terms
are considered. The first term takes into account the deviation from the reference
value, which is given by xss, weighted by matrix Qi . The reference signal pchar,ref
and thus also xss are used as a constant value over the prediction horizon as no future
values are known. Second, the deviation from the optimal steady-state actuated values
uss is penalized. The change of the actuated values u(k + i | k) − u(k + i − 1 | k)is
represented by the third term, while the final term considers the slack variables. This
cost function allows the high-pressure stage to be used in the transient phase plus
the subsequent shift to the low-pressure stage approaching the optimal steady-state
values.
Within the constraints, the initial value embedding is considered, where the param￾eter xes ∈ Rnx denotes the state estimate (13.6b). Due to the dead-time, the last kD
actuated values applied are also considered as initial values (13.6c). The discretized
dynamics are considered by (13.6d). The box constraints for the actuated values are
defined in (13.6e). In (13.6f)–(13.6g), the slack variables  are used to penalize viola￾tions of the constraints on the turbocharger speeds. The solver applied uses automatic
regularization, thus no additional quadratic terms are applied for penalization of the
slack variables. The NLP is given by13.1 Nonlinear MPC Algorithm 287
min u(·), x(·), (·)
J (13.6a)
s.t. x(k|k) = xes(k), (13.6b)
u(k − i|k) = u(k − i), i = 1,..., kD, (13.6c)
x(k + i + 1|k) = f d (x(k + i|k), u(k − kD + i|k)),i = 0,..., N + kD,
(13.6d)
umin ≤ u(k + i | k) ≤ umax , i = 0,..., N, (13.6e)
yωtc (k + kD + i + 1 | k) ≤ ωtc,max + (k + i | k), i = 0,..., N, (13.6f)
0 ≤ (k + i | k), i = 0,..., N (13.6g)
13.1.3 Numerical Solution of the Optimization Problem
Both NLPs need to be solved at each sampling instant. This case study uses sequen￾tial quadratic programming (SQP) to solve the NLPs. For the approximation of the
Hessian, the generalized Gauss–Newton method is used. To further reduce the com￾putation time, the real-time iteration (RTI) scheme is applied, i.e. only one SQP iterate
is solved in each sampling instant. The sensitivities of the nonlinear functions in the
NLP are calculated with algorithmic differentiation. In the algorithm presented, con￾densing has been used in combination with the QP solver qpOASES [3]. To obtain
a real-time feasible NMPC implementation on the embedded control hardware, the
ACADO code generation tool has been used as presented in [4, 5].
13.2 Validation of the NMPC Algorithm by Simulations
To validate the NMPC algorithm, simulations with MATLAB®/Simulink® are con￾ducted. The NMPC algorithm presented is referred to as a multi-objective controller,
as it tries to find a trade-off between fast transient raise and fuel-efficient steady￾state operation. To evaluate the effectiveness of this trade-off, it is compared to two
alternative strategies. The first alternative is optimized for the transient behavior and
does not consider fuel efficiency. Based on the analysis of the system dynamics, this
behavior can be realized by using the high-pressure stage as much as possible during
the entire time, while considering its speed limit. As a second alternative, a control
strategy is applied which is optimized for reducing the pumping losses and which
does not take the transient behavior into account. In contrast to the first alternative, the
high-pressure stage here is used as little as possible. In both alternative strategies, the
optimization problem and its weightings differ from the multi-objective controller.
The results presented are extracted from [1] where one multi-objective controller
is compared to a fuel-efficient controller and a fast transient raise controller. The288 13 Two-Stage Turbocharging: Control
controllers are comparable to the strategies presented above. The various control
strategies are tested in a closed-loop control setting. For these tests, the controller￾internal model is identical to the plant model; just measurement noise is added to
the outputs. This allows the influence of the control strategy to be validated without
dealing with effects such as a model–plant mismatch.
Figure 13.2 shows the closed-loop control performance of the three strategies. Two
step-wise changes are applied for the reference, each with a different step height.
The control strategy, which is focused on the reduction of pumping losses, uses
static actuated values. They are to ensure that the reference is tracked in steady state
with a maximum actuation of the low-pressure wastegate. As the focus lies on the
reduction of pumping losses, the transient behavior is entirely neglected. The second
controller, which is to optimize the transient behavior, uses the high-pressure stage
as much as possible. This correlates to the operation at the limit of the high-pressure
turbocharger speed. The multi-objective controller uses a strategy in between these
two. At the beginning of the transient phase, the actuated values correspond to those of
the controller with optimal transients. The actuated values then shift to the solution of
the controller with optimally reduced pumping losses. The multi-objective controller
is thus able to be fast in the transients. It is only slightly slower in reference tracking
than the controller that is purely optimized for the transients. Simultaneously, it
reduces pumping losses in the steady-state behavior. At steady state, the actuated
values of the multi-objective controller are the same as those of the controller that is
optimized for pumping losses.
The multi-objective control strategy is also suited for nonuniform reference tra￾jectories. Figure 13.3 shows a simulation obtained with such a reference trajectory.
The NMPC algorithm is able to accurately track the reference. At the same time, the
turbocharger speed limits are respected.
13.3 Experimental In-Vehicle Validation of the NMPC
Algorithm
The simulation tests of the control algorithm provide important insights. However,
various factors require additional experimental validations. The control algorithm
has to deal with random reference trajectories that occur in real driving situations,
with disturbance signals as well as model–plant mismatches in a system that is highly
nonlinear. For the experimental validation of engine control algorithms, various types
of experiments usually are conducted. First, the controller is validated on an engine
test bench. This has the advantage that adjustments of certain parameters, such as the
intake air temperature, are straightforward. The control algorithm then is tested on
a vehicle dynamometer. This allows the air path control to be tested with the entire
vehicle. Still, certain parameters can be easily adjusted; for instance, the algorithm
can be tested at various constant engine speeds, which is especially for air path control
very advantageous. As the last step, the control algorithm is tested in the vehicle on
a road, where it has to handle all the arising complexities to the full extent.13.3 Experimental In-Vehicle Validation of the NMPC Algorithm 289
Fig. 13.2 Validation of the control algorithm by simulations (1) Reduction of pumping losses;
(2) Fast transients; (3) Multi-objective – Reproduced from [1], originally published open access
under a Creative Commons CC BY 4.0 license, https://doi.org/10.3390/en9070530290 13 Two-Stage Turbocharging: Control
Fig. 13.3 Validation of the control algorithm by simulations for a nonuniform reference profile
– Reproduced from [1], originally published open access under a Creative Commons CC BY 4.0
license, https://doi.org/10.3390/en907053013.3 Experimental In-Vehicle Validation of the NMPC Algorithm 291
Fig. 13.4 Validation of the control algorithm on a vehicle dynamometer – c [2018] IEEE.
Reprinted, with permission, from [2]
In [2], such an NMPC algorithm for two-stage turbocharging is validated with a
vehicle dynamometer and with vehicle tests on the road. The road tests with random
driving have been performed on an automotive testing track and on public roads. The
NMPC deployed is comparable to the one described in this chapter. Two examples of
the tests conducted in [2] are reproduced to showcase the capabilities of the NMPC
algorithm. The NMPC algorithm is used with a sampling time of Ts = 0.05 s.
Figure 13.4 shows a closed-loop control result from a vehicle dynamometer test.
The vehicle dynamometer allows testing at a constant engine speed and using uniform
as well as nonuniform reference signals. The presented closed-loop control result is
obtained at a constant engine speed of neng = 2000 1
min . As a reference trajectory,
a step input is applied. The reference value for the charging pressure is tracked by
the NMPC algorithm without any overshoots. The control algorithm uses the high￾pressure stage in the transients to quickly increase the charging pressure. In the
progress of the trajectory, there is a shift toward the use of the low-pressure stage.
This enables a fuel-efficient stationary operation. The pressure ratios of the two
stages show that the control algorithm is capable of engaging and disengaging the
two stages without any negative impact on the charging pressure. Thus, the control
algorithm is able to exploit the capabilities of the specific hardware setup.
Figure 13.5 shows a control result from tests with the vehicle on an automotive
testing center. Due to the real-world driving, the reference profile is rather nonuniform
and the engine speed varies continuously. Still, the controller is able to track the
reference trajectory very accurately. A certain lag is present between the reference
trajectory and the system output. This lag cannot be reduced due to the physics of
the system, such as the dead-time present and the inertia of the turbochargers. The
consideration of the limit values on the turbocharger speeds allows reduction of
overstepping.
In conclusion, the experiments show that the NMPC algorithm developed is able
to deliver high performance for all driving profiles in the entire operating range. It
can cope with all complexities arising for an in-vehicle implementation and it meets292 13 Two-Stage Turbocharging: Control
Fig. 13.5 In-vehicle validation of the control algorithm on the road – c [2018] IEEE. Reprinted,
with permission, from [2]
all requirements specified. The optimization-based method allows to account for the
specifics of the two-stage turbocharged system such that the goals associated with
the hardware design can be realized. Additionally, the demanding system properties
can be handled by using a very systematic development approach. A critical point for
using NMPC is its real-time feasibility, which is achieved by using a reduced-order
model in combination with tailor-made numerical solution methods.
References
1. T. Albin, D. Ritter, N. Liberda, D. Abel, Boost pressure control strategy to account for transient
behavior and pumping losses in a two-stage turbocharged air path concept. Energies 9(7), 530–
545 (2016)
2. T. Albin, D. Ritter, N. Liberda, R. Quirynen, M. Diehl, In-vehicle realization of nonlinear MPC
for gasoline two-stage turbocharging airpath control. IEEE Trans. Control Syst. Technol. 26(5),
1606–1618 (2018)
3. H.J. Ferreau, C. Kirches, A. Potschka, H.G. Bock, M. Diehl, qpOASES: a parametric active-set
algorithm for quadratic programming. Math. Program. Comput. 6(4), 327–363 (2014)
4. B. Houska, H.J. Ferreau, M. Diehl, An auto-generated real-time iteration algorithm for nonlinear
MPC in the microsecond range. Automatica 47(10), 2279–2285 (2011)
5. R. Quirynen, M. Vukov, M. Zanon, M. Diehl, Autogenerating microsecond solvers for nonlinear
MPC: a tutorial using ACADO integrators. Optim. Control Appl. Methods 36, 685–704 (2014)Part IV
In-Depth Case Studies: Combustion
ControlChapter 14
Fundamentals of CI Engine Combustion
Control and Modeling
Abstract This chapter presents the basics of the combustion control of compression
ignition (CI) engines. In this context, a control-oriented model is presented that can be
used for control purposes, e.g. as a controller-internal model for optimization-based
control. A single-zone model is detailed with a focus on the high-pressure working
process. The simplifications are chosen such that a computationally efficient model
results that is still capable of reproducing the cylinder pressure trace with reasonable
accuracy. The basic conservation equations for mass and energy are derived. Addi￾tionally needed submodels such as the one for wall heat losses are introduced as well.
The chapter also details the two fundamental concepts for combustion control. First,
the cycle-to-cycle control of cycle-integral combustion parameters is presented. The
cycle-integral parameters are derived from the cylinder pressure trace and are used as
surrogate parameters for the combustion performance. Second, the combustion rate
shaping is presented. For combustion rate shaping, the heat release rate is controlled
in a highly time-resolved manner, thus offering a high number of degrees of freedom
for combustion control.
14.1 Introduction to Combustion Control
The combustion control plays an important role in CI engines as the combustion pro￾cess influences the overall performance, e.g. the level of pollutant and noise emissions
as well as the efficiency of operation. In CI engines, a multitude of parameters is
available that can actively control the combustion process. There exist several air
path parameters, such as the pressure and the burnt gas ratio, in the intake manifold.
They influence the combustion process only on a slow time scale. On the other side,
there are several parameters available from the fuel path. They allow for influencing
the combustion process on a combustion cycle time basis. Modern injection systems
that are applied in series production are characterized by increased rail pressures and
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_14
295296 14 Fundamentals of CI Engine Combustion Control and Modeling
decreased dwell times, i.e. the minimum time distance between two injection events.
They offer a high flexibility in terms of many injection events per combustion cycle.
Each injection event is parametrized by the time of injection and the duration of the
injection, which yields twice as many actuated values as the number of injections.
Recent injection systems are capable of delivering up to nine injection events per
cycle [10, 26]. Thus, a high number of degrees of freedom are present for achieving
the highest performance concerning fuel efficiency, noise, and pollutant emissions.
In general, there exist two fundamental approaches for the control of the com￾bustion process. In the first approach, a limited number of cycle-integral combustion
parameters are used as controlled variables. The actuation is updated on a cycle￾to-cycle basis. The control concept along with the most important cycle-integral
combustion parameters is introduced in Sect. 14.3. An alternative procedure is the
so-called combustion rate shaping. To its fullest extent, the entire quasi-continuous
trace of the heat release is controlled based on a cycle-to-cycle frequency. While the
cycle-to-cycle-based control of cycle-integral combustion characteristics can be con￾sidered as state of the art, the combustion rate shaping is a topic of current research.
The combustion rate shaping is detailed in Sect. 14.4. For the understanding of the
two combustion control concepts, first, a brief summary of the control-relevant fun￾damentals of the thermodynamics of the engine process is given. For this purpose, a
simplified process model is introduced. Readers interested in a detailed description
of the fundamentals are referred to books such as [12, 18].
14.2 Control-Oriented Process Model
In the following, the engine process of a four-stroke CI engine with direct injection
of fuel is investigated. In this case, a full working cycle is given by four strokes,
which corresponds to a rotation of the crankshaft by 720 ◦CA. Each stroke refers to
the the full upward respectively the full downward movement of the piston inside
the cylinder. They are given by
1. Intake stroke
2. Compression stroke
3. Power stroke
4. Exhaust stroke
The intake and the exhaust stroke determine the charge exchange process, i.e. fresh
air is aspirated into the cylinder and the exhaust gas is pushed out. Due to the low
pressure inside the cylinder, these two strokes are called low-pressure cycle. Within
the compression and the power stroke, the air–fuel mixture is compressed and sub￾sequently, combustion takes place which results in expansion and work done on the
piston. The two strokes are called high-pressure cycle due to the high pressure levels
inside the cylinder.14.2 Control-Oriented Process Model 297
Figure 14.1 shows relevant parameters of the CI combustion process around the
top-dead center during the high-pressure cycle. The phases of compression, fuel
injection, combustion, and expansion are shown. The digital injector actuation signal
actinj is shown along with the fuel mass flow into the cylinder m˙ f uel,inj . The pressure
inside the combustion chamber p is shown for the fired and for the motored operation,
i.e. without any fuel injection and combustion. Additionally, the accumulated heat
release Qcomb from combustion and its time derivative, the heat release rate Q˙ comb
from combustion are depicted.
The progress in the variables is shown in dependence of the crank angle φ. The
crank angle φ can be related to the time t using the engine speed neng in 1
s or the
angular velocity of the engine ωeng. Assuming the engine speed to be constant during
one working cycle, i.e. dωeng = dneng = 0, the relationship between time and crank
angle can be described by:
φ = ωengt = 2πnengt (14.1)
dφ = ωengdt (14.2)
Setting the actuation signal of the injector to actinj = 1 leads, with some time
delay, to a mass flow of fuel into the cylinder. The time point where actinj = 1 is
set is called start of energizing SOE. Setting the actuation signal of the injector
again to actinj = 0 leads, with some time delay, to a decrease of the fuel mass flow
until it entirely stops. The time period where actinj = 1 holds is called the duration
of energizing DOE. A single injection event is parameterized with the two values
SOE and DOE. While the fuel is injected, already a high pressure is present inside
the cylinder. Thus, the fuel autoignites during the injection process. The combustion
of the fuel occurs after the so-called ignition delay. A significant measure for the
progress in combustion is the accumulated heat release Q and its derivative the heat
release rate Q˙ . In the heat release rate trace depicted, two distinctive peaks are visible.
The initial phase with the characteristic first peak results from the combustion of a
premixed air–fuel mixture. The subsequent phase of the combustion, with the second
peak in it, is dominated by diffusive combustion. Finally, the heat release rate decays
exponentially, which is the so-called burn-out phase. The heat release increases the
temperature of the charge and the cylinder pressure.
In the following, the fundamentals of modeling the in-cycle, i.e. crank-angle￾resolved CI engine process, are detailed. A lumped-parameter process is presented,
where the volume is assumed to be ideally mixed. Thus, the gas states such as temper￾ature, pressure, and mixture composition are not spatially distributed. Additionally,
it is assumed that the gas is well described by ideal gas laws. This modeling approach
allows for low computation times. These kinds of models are typically called zero￾dimensional or single-zone models [12]. They offer reasonable model quality for
reproducing the cylinder pressure trace. However, they are not suited for reproduc￾ing pollutant emissions, as their formation results mainly from local effects in the
combustion chamber.298 14 Fundamentals of CI Engine Combustion Control and Modeling
Fig. 14.1 CI combustion
process around the top-dead
center during the
high-pressure cycle14.2 Control-Oriented Process Model 299
14.2.1 Mass Balance
An important quantity of the process is the mass m of the total charge inside the
combustion chamber. The change of the total mass with respect to the time d
dt m is
given by the sum of all mass flows flowing inside and outside of the combustion
chamber:
d
dt
m = ˙mint + ˙mexh + ˙mfuel,inj (14.3)
The mass flows entering and exiting through the intake and exhaust valves are denoted
by m˙ int and m˙ exh. The mass flow of the fuel injected is given by m˙ fuel,inj. To simplify the
model, it is assumed that the injected fuel evaporates instantaneously when entering
the combustion chamber. There exist additional mass flows due to leakage effects.
For modern CI engines, they can be neglected without significantly impairing the
model quality [18]:
m˙ leak = 0 (14.4)
Low-Pressure Cycle
During the low-pressure cycle, the gas exchange process takes place. As no fuel
is injected in the low-pressure cycle, m˙ fuel,inj = 0 holds. Within the intake stroke,
the exhaust valves are closed, resulting in m˙ exh = 0. On the other side, the intake
valves are closed during the exhaust stroke, resulting in m˙ int = 0. The mass flow
through the intake valves during the intake stroke and the mass flow through the
exhaust valves during the exhaust stroke can be described by the compressible flow
restriction model. The mass flow through the valves can be calculated by
m˙ valve(t) = cd A(t) pus(t)
√Rϑus(t)
ψ (Π (t)) (14.5)
The flow function ψ(Π ) for the compressible flow restriction model is determined
by
ψ (Π) =
⎧
⎪⎨
⎪⎩

κ ·
 2
κ+1
 κ+1
κ−1 , Π ≤  2
κ+1
 κ
κ−1
Π 1
κ
	
2κ
κ−1 ·


1 − Π κ−1
κ

, Π>  2
κ+1
 κ
κ−1
(14.6)
A continuously differentiable alternative and a more detailed description of the
parameters involved can be found in Sect. 9.4.2. For calculation of the mass flow
through the valves, the factor cd A(t), i.e. the multiplication of the discharge coeffi￾cient cd and the reference flow area A, has to be modeled carefully. The factor needs
to take the motion of the valves into account. A model for the reference flow area
A(t) that considers the valve motion is presented in [18].300 14 Fundamentals of CI Engine Combustion Control and Modeling
For more detailed models, besides the total mass, also the mixture composition
plays an important role. In this case, the gas exchange model calculates the total
in-cylinder charge mass and the composition at intake valve closing (IVC). This is
used subsequently as the initial condition for the calculations of the high-pressure
cycle. The mixture composition is especially of relevance when a detailed caloric
model is used.
High-Pressure Cycle
During the high-pressure cycle, the exhaust and the intake valves are closed. It results
m˙ int = 0 (14.7)
m˙ exh = 0 (14.8)
Thus, the total mass balance (14.3) can be simplified. The change of total mass is
directly determined by the mass flow of fuel inside the combustion chamber:
d
dt
m = ˙mfuel,inj (14.9)
Typically, a model is needed that relates the actuation signal such as start of energizing
SOE and duration of energizing DOE to the mass flow through the injector m˙ fuel,inj.
One data-based approach that is suitable for the purpose of combustion rate shaping
is presented in Sect. 15.3.
14.2.2 Energy Balance
The governing equations for the cylinder pressure p can be derived by the use of
the energy balance via the first law of thermodynamics. Typically, the kinetic and
potential energies are neglected, such that the change of the total energy dE is
assumed to be equal to the change of the internal energy dU:
dE = dU (14.10)
For the open system, the change of the internal energy with respect to differential
changes in the crank angle dφ can be calculated by [21]
d
dφ
U = d
dφ
Wmech +
d
dφ Qwall +
d
dφ Qcomb
+
d
dφ
Hint +
d
dφ
Hexh +
d
dφ
Hleak +
d
dφ
Hfuel,inj (14.11)
Various processes affect the change in the internal energy. These are the change of
heat release by combustion of the fuel d
dφ Qcomb, the change in performed mechanical14.2 Control-Oriented Process Model 301
work d
dφ Wmech that results from cylinder volume change work, the change in heat
transfer to the combustion chamber walls d
dφ Qwall as well as the change of enthalpy
flows into and out of the combustion chamber, i.e. through the intake and exhaust
valves d
dφ Hint and d
dφ Hexh, by fuel injection d
dφ Hfuel,inj, and due to leakage d
dφ Hleak.
The heat necessary for the evaporation of the liquid fuel is neglected.
For the process control, only the cylinder pressure trace of the high-pressure
cycle is of relevance. For the high-pressure cycle, further going simplifications can
be made in order to obtain a computationally simple model. First, a closed system
can be assumed, where all mass flows into and out of the combustion chamber are
neglected. As the intake and exhaust valves are closed, the mass flows are given by
m˙ int = ˙mext = 0 and thus d
dφ Hint = d
dφ Hexh = 0. The leakage mass flow and the fuel
mass flow are neglected as well for the internal energy, resulting in d
dφ Hfuel,inj = 0
and d
dφ Hleak = 0. Compared to the other terms in (14.11), these enthalpy flows have
a minor effect. A simplified relation for the internal energy results:
d
dφ
U = d
dφ
Wmech +
d
dφ Qwall +
d
dφ Qcomb (14.12)
The term d
dφU is reformulated to express it in terms of measurable quantities. For
this purpose, first the following relation can be applied for the internal energy:
d
dφ
U = d
dφ (mu) = m d
dφ u + u d
dφ m (14.13)
As the change of mass is neglected, the change of internal energy is due to changes
in the specific internal energy d
dφ u. The specific internal energy u can be expressed
as a function that depends on the temperature ϑ and the specific heat at constant
volume cv, i.e. u(ϑ) = cvϑ. Thus, it follows for the change in internal energy:
d
dφ
U = mcv
d
dφ
ϑ (14.14)
The gas is modeled as an ideal gas. Thus, the following equation holds:
pV = m Rϑ (14.15)
The equation can be expressed in differential form, taking into account that the mass
is assumed to be constant dm = 0. Additionally, it can be assumed that the specific
gas constant stays constant as well, i.e. dR = 0. It follows for the differentials:
pdV + Vd p = m Rdϑ (14.16)
Inserting (14.16) in (14.14) allows to derive an expression with measurable quantities:302 14 Fundamentals of CI Engine Combustion Control and Modeling
d
dφ
U = cv
R

p
d
dφ
V + V
d
dφ p

= 1
κ − 1

p
d
dφ
V + V
d
dφ p

(14.17)
The ratio between cv and R is expressed in terms of the isentropic exponent κ using
the specific heat at constant pressure cp [12]:
κ = cp
cv
(14.18)
R = cp − cv (14.19)
For a computationally efficient model approach, the caloric properties, i.e. the specific
heats, the isentropic exponent, and the specific gas constant, are assumed to be
constant. However, for a more accurate modeling, the caloric properties need to
be modeled in dependence of the temperature and the gas composition. Often, the
temperature dependency of the constant pressure specific heat is modeled using the
so-called NASA polynomials [5, 8]. A full approach using the NASA polynomials
is depicted in [15].
The inclusion of (14.17) in the energy balance (14.12) results in
1
κ − 1

p
d
dφ
V + V
d
dφ p

= d
dφ
Wmech +
d
dφ Qwall +
d
dφ Qcomb (14.20)
The change in performed mechanical work d
dφ Wmech is given by the change in volu￾metric work:
d
dφ
Wmech = −p
d
dφ
V (14.21)
Using this equation, the final relation for the energy balance can be derived:
1
κ − 1
V
d
dφ p +
κ
κ − 1 p
d
dφ
V = d
dφ Qcomb +
d
dφ Qwall (14.22)
Typically, the gross heat release Qgross and the net heat release Qnet are distinguished
[12]. The gross heat release Qgross describes the total heat release by combustion. Its
change is calculated by
d
dφ Qgross = d
dφ Qcomb (14.23)
The net heat release Qnet describes the effective work done on the piston. It takes
all loss terms into account. For instance, for the simplified approach described, it
follows14.2 Control-Oriented Process Model 303
d
dφ Qnet = d
dφ Qcomb +
d
dφ Qwall (14.24)
14.2.3 Applications of the Single-Zone Model
The single-zone model can be used for the purpose of engine process simulation and
for heat release analysis. Within the engine process simulation, the pressure of the
combustion chamber p is determined. For this application, the fuel injection profile
is used as input. For optimization-based control, the model is used in the same way.
Based on (14.22), the equation for the pressure change can be determined.
d
dφ p = − κ
V p
d
dφ
V +
κ − 1
V
 d
dφ Qcomb +
d
dφ Qwall
(14.25)
For the prediction of the pressure trace, various submodels are needed. A submodel
is needed that calculates the volume in dependence of the crank angle as detailed
in Sect. 14.2.4. Additionally, a submodel is needed that calculates the loss terms. A
model for the wall heat losses is detailed in Sect. 14.2.5. Another important submodel
is the combustion model that calculates the heat release by combustion Qcomb. A data￾based approach that is suitable for combustion rate shaping is explained below in
Sect. 15.2.
The second application of the model is the heat release analysis. In this case,
the heat release is calculated and the pressure trace serves as input. For instance,
the heat release analysis can be used to calculate the net heat release based on
a measured cylinder pressure profile. For calculation of the net heat release, the
following equation results:
d
dφ Qnet = 1
κ − 1
V
d
dφ p +
κ
κ − 1 p
d
dφ
V (14.26)
In fact, the net heat release can be calculated, when the pressure trace, the volume,
and the isentropic coefficient are known. For the validity of the heat release analysis,
the quality of the measured cylinder pressure trace data needs to be high. Thus, the
data needs to be recorded appropriately and the data needs to be preprocessed; see [1]
for details. For calculation of the gross heat release, additional submodels for the heat
losses are needed.
14.2.4 Combustion Chamber Volume
For the process simulation (14.25) as well as for the heat release analysis (14.26),
the change of the volume dV needs to be calculated. The relevant volume V is given304 14 Fundamentals of CI Engine Combustion Control and Modeling
by the combustion chamber, where the boundaries are given by the piston, the cylin￾der liner walls, and the cylinder head. The volume V is changing in dependence of
the crank angle φ due to the movement of the piston, defined by the crank kine￾matics. The distance from the top-dead center (TDC) to the piston is denoted by
s(φ). At φ = 0, the position TDC is present where the combustion chamber volume
equals the minimum volume, the so-called compression volume Vc. At φ = 180◦,
the bottom-dead center (BDC) is reached where the combustion chamber volume is
at its maximum, i.e. it equals the so-called displacement volume Vd . The position of
the piston s can be calculated by [12]
s(φ) = rcs ·

1 +
1
λcr
− cos(φ) − 1
λcr

1 − λ2
cr sin2(φ)
(14.27)
In this equation, rcs defines the radius of the crank shaft and λcr = rcs
lcr is the ratio of
the radius of the crank shaft rcs and the length of the connecting rod lcr.
Taking into account the cross-section area of the cylinder Acyl and the bore diam￾eter db, the combustion chamber volume V is well approximated by
V(φ) = Vc + Acyls(φ) with Acyl = πd2
b
4 (14.28)
With ωeng being the engine speed, the derivative of the combustion chamber volume
with respect to the crank angle dV
dφ is given by
dV
dφ (φ) = Acylrcsωeng ·
⎛
⎝sin(φ)
λcr
2
sin(2φ)

1 − λ2
cr sin2(φ)
⎞
⎠ (14.29)
Alternatively, the position can be approximated by a simplified relation [9]:
s(φ) = rcs ·

1 − cos(φ) +
λcr
2
sin2
(φ)
(14.30)
The combustion chamber volume V can be expressed in terms of the compression
ratio 
. The compression ratio is defined by

 = Vd + Vc
Vc
(14.31)
Considering that the full stroke has a length of 2rcs, the combustion chamber volume
V results to be [9]
V(φ) = Vd
1

 − 1
s(φ)
2rcs
(14.32)14.2 Control-Oriented Process Model 305
The mean piston velocity cm is a characteristic value that is used for various purposes
such as the calculation of the heat transfer through the combustion chamber walls;
see Sect. 14.2.5. It is calculated by
cm = 1
π
 π
0
ds
dφ (φ)
dφ
dt
dφ = 2rcsωeng
π
(14.33)
14.2.5 Heat Transfer Through Combustion Chamber Walls
For the process simulation of the cylinder pressure as well as for the determination of
the gross heat release, a submodel is needed that captures the heat transfer between
the in-cylinder charge and the combustion chamber walls. The physical processes
involved are quite complex, and in-detail models have high computational demands.
Simplified approaches only model the convective effect of the heat transfer by a
Newtonian approach of the following form:
Q˙ wall = αA (ϑwall − ϑ) (14.34)
In this equation, α denotes the heat transfer coefficient, ϑwall the wall temperature,
and A the surface area of heat transfer. The value ϑ denotes the in-cylinder charge
temperature which can be expressed in terms of the pressure by the ideal gas state
equation (14.15). All terms in this equation depend on the time or crank angle, respec￾tively. In the following, simplified relations for the various terms are described.
Heat Transfer Surface Area
The heat transfer surface area A depends on the position of the piston s(φ). For
simplification, only three areas can be considered, namely the cylinder head area
Ahead, the area of the piston Apis, and the area of the cylinder liner Aliner(φ) that is a
function of the crank angle due to the piston motion. It results
A(φ) = Ahead + Apis + Aliner(φ) (14.35)
The cylinder liner area is given by
Aliner(φ) = πdbs(φ) (14.36)
For determination of Ahead and Apis, the geometry of the combustion chamber is
needed. However, typically rough estimates are sufficient that rely on simplified
geometrical relations.
Heat Transfer Coefficient Based on Woschni Modeling Approach
A multitude of approaches are available to model the heat transfer coefficient α;
see for instance [3, 6] or [13]. A commonly used approach is the one developed by306 14 Fundamentals of CI Engine Combustion Control and Modeling
Woschni [27, 28] and reproduced in [2]. The heat transfer coefficient is determined
by the following empirical relation:
αwoschni = 130d−0.2
b p0.8
ϑ−0.53 
C1cm + C2
Vdϑivc
pivcVivc
(p − pm)
0.8
(14.37)
In this equation, the term db denotes the bore diameter, p the combustion chamber
pressure, ϑ the temperature of the charge in the cylinder, cm is the mean piston
velocity, and pm the pressure for motored operation. The values ϑivc, pivc, Vivc define
the conditions at the time point intake valve closing, which serves as a reference point.
The constants C1,C2 have to be determined based on simulations or experiments.
According to [9], if the effect of the swirl can be neglected, the parameters C1, C2
can be chosen to be
C1 = 6.18 (14.38)
C2 = 0.00324 [m/(sK)] (14.39)
Wall Temperature
The wall temperature ϑwall is typically assumed to be quasi-stationary, i.e. no dynamic
effects are modeled. One approach presented in [14] follows an empirical approach:
ϑwall = 360 + 9λ0.4

nengdb [K] (14.40)
The air-to-fuel ratio of the in-cylinder charge is denoted by λ, neng is used for the
engine speed in 1
min , while db denotes the bore diameter.
14.3 Control of Cycle-Integral Combustion Parameters
The state-of-the-art combustion control algorithms rely on the use of a limited number
of cycle-integral surrogate parameters. Within the control algorithm, these parame￾ters, typically, between two and four, are used as controlled variables. They reflect the
quality of the combustion process within the individual combustion cycle, e.g. they
are used as surrogates for performance parameters such as the torque generated, the
process efficiency, or the combustion noise emissions. Sensor data, especially those
from an in-cylinder pressure sensor, from the preceding cycle are used to determine
these parameters. The values obtained are utilized by the control algorithm to calcu￾late the actuated values for the subsequent cycle. In order to account for the MIMO
dynamics, approx. the same number of parameters is needed from the actuation side.
These consist of parameters from the air and fuel path. For the control purpose, only
a limited number of injection events is applied. The publication in [24] describes
the use of two pilot, one main, and one post injection. The actuation is updated on
a cycle-to-cycle basis. In the following, the most relevant cycle-integral parameters
are introduced.14.3 Control of Cycle-Integral Combustion Parameters 307
Indicated Mean Effective Pressure
An important surrogate parameter for combustion control is the indicated mean
effective pressure (IMEP). The IMEP correlates with the torque generated and thus
can be used as a controlled variable in order to satisfy the desired engine torque
which is calculated by the torque manager as described in Sect. 7.3.4. The IMEP is
defined as the ratio between the total performed mechanical work during one engine
cycle Wt , i.e. the volume change work which is conducted on the piston and the
displacement volume Vd [12]:
IMEP = Wt
Vd
(14.41)
Using the indicated pressure p and the volume V, it can be calculated with the
following integral over one working cycle:
IMEP = 1
Vd

pdV (14.42)
Using the relation given in (14.28), this can be reformulated to
IMEP = 1
Vd

p(φ)Acylds(φ) (14.43)
For the mean indicated torque Mind, it follows
Mind = Vd
4π
IMEP (14.44)
Accordingly, the indicated power Pind can be calculated using the angular speed of
the engine ωeng:
Pind = Mindωeng (14.45)
Combustion Average
An important performance parameter of the combustion process is the indicated
efficiency ηi . The efficiency ηi can be calculated by the ratio between the mechanical
work and the total energy of the fuel injected, where mfuel,tot is the total fuel mass
injected and Hlhv is the lower heating value [12]:
ηi = IMEP Vd
mfuel,tot Hlhv
(14.46)
A widely used surrogate parameter for the indicated efficiency is the combustion
average [23]. The combustion average is defined as the crank angle position where
50% of the total fuel mass injected is burnt. It is denoted as CA50:308 14 Fundamentals of CI Engine Combustion Control and Modeling
Qcomb(φ = C A50) = 50 % mfuel,tot Hlhv (14.47)
The characteristic value CA50 works well as a surrogate parameter for efficiency in
the case of conventional CI and SI engine operation. In other applications, the corre￾lation to efficiency is not that unanimous. This concerns especially operation modes
of CI engines with high shares of post injections [15] or combustion modes such as
premixed charge compression ignition (PCCI) with very early injections [11]. One
example is shown in Fig. 8.6.
Peak in-Cylinder Pressure
The peak in-cylinder pressure PMAX serves as an important parameter for engine
control. It is given by the maximum pressure arising within the combustion cycle:
PMAX = (p(φ))max (14.48)
The engine control has to ensure that a critical value for PMAX is not surpassed as
the peak pressure correlates with the mechanical load of the engine. The value of
the limit depends on the hardware design. Modern CI engines typically operate at
peak pressures of 180–220 bar [23]. However, it is desirable to achieve a PMAX
that is as high as possible within the specified limit. High peak pressures approx￾imate the ideal isochoric working process, thus increasing the indicated efficiency ηi .
Combustion Noise Indicators
Another performance parameter that has to be taken care of in the combustion control
algorithm is the CI engine noise. The most significant reason for noise can be found
in the excitation of the combustion chamber walls due to the acting gas forces. A good
surrogate parameter for the combustion noise is the maximum in-cylinder pressure
gradient DPMAX [15]:
DPMAX =
d p
dφ

max
(14.49)
In order to maintain a good noise, vibration, and harshness (NVH) behavior, an upper
limit for DPMAX has to be sustained by the combustion control algorithm.
14.4 Combustion Rate Shaping
The combustion rate shaping enables highly accurate control of the combustion
process. Instead of controlling a few cycle-integral parameters that indirectly reflect
the quality of the combustion process, the combustion process itself is controlled in a
highly time-resolved manner. The actuated values are updated with a cycle-to-cycle
frequency.14.4 Combustion Rate Shaping 309
Fig. 14.2 Combustion rate shaping for PCCI
The scheme of combustion rate shaping is depicted in Fig. 14.2. In order to be
able to shape the combustion process, a high number of degrees of freedom on the
actuation side have to be available that have an effect on the combustion process
on a cycle-to-cycle basis. This requirement makes the injector the main actuator for
combustion rate shaping. The necessary high number of degrees of freedom is given
in modern injection systems. They offer the possibility of multiple injection events in
one combustion cycle with a high flexibility concerning the timings and the durations
of the injection events. As a result, the manipulation of injection events is used as
the main actuated values to conduct combustion rate shaping.
The combustion rate shaping is a promising concept for advanced combustion
concepts and in applications with demanding requirements. A combustion concept
where the combustion rate shaping is very promising is the PCCI; see Sect. 8.3.
Combustion rate shaping can reduce the emissions of noise, particulate matter, and
nitrogen oxide while maintaining high levels of efficiency and similar levels with
respect to the emissions of carbon monoxide and unburned hydrocarbon [7].
In general, the combustion rate shaping can be used for two scenarios. It can
be used as a feedback algorithm where the actuated values, i.e. the injection rate
profile, are adjusted on a cycle-to-cycle basis during real operation. This allows
to reject disturbances and ensures a high-performance quality of the combustion
process during the lifetime of the combustion engine. Disturbance parameters that
can be compensated for are the fuel quality and the wear and tear of the injector [22].
The second possibility is the use of combustion rate shaping in order to derive
feedforward maps. In this case, combustion rate shaping is applied in the develop￾ment phase at the engine test bench. The feedforward maps derived are used for
real operation without any feedback portion. Due to the high amount of calibration
parameters in modern injection systems, their tuning becomes very complex. The
combustion rate shaping allows to systematically calibrate these parameters for var-310 14 Fundamentals of CI Engine Combustion Control and Modeling
ious influencing variables, e.g. engine speed and rail pressure [17]. This allows the
full exploitation of the many degrees of freedom that are present.
To realize combustion rate shaping, various control strategies have been devel￾oped, which differ in terms of the control algorithms used and the level of detail
concerning the resolution of the controlled combustion rate. The fact that the MIMO
system dynamics are considered is common to all these concepts. One possibility is
given by the introduction of new combustion metrics in addition to CA50, such as
CA30, where 30% of the heat is released [19]. These extended metrics can be con￾trolled using multivariable PI controllers [20]. Alternatively, the highly time-resolved
combustion process can be controlled. In this case, the quasi-continuous in-cylinder
pressure trace or the quasi-continuous heat release rate trace can be used as controlled
variables. Thus, an accurate control of the time evolution of the combustion process
can be achieved. In [25], pressure profile tracking is presented by the use of MPC.
In [17], a combustion rate shaping approach based on an invertible model is applied.
The model consists of simplified physics-based relations. Another possibility is the
use of iterative learning control methods in order to control the profile in an iterative
fashion [16, 17, 29]. The iterative learning control allows to track a reference profile
of the controlled values by cycle-to-cycle adjustment of the profile of the actuated
values [4].
References
1. C. Barba, Erarbeitung von verbrennungskennwerten aus indizierdaten zur verbesserten prog￾nose und rechnerischen simulation des verbrennungsablaufes bei pkw-de-dieselmotoren mit
common-rail-einspritzung, Ph.D. Thesis, ETH Zurich, 2001
2. M. Bargende, Wärmeübergang und wärmebelastung im dieselmotor, Handbuch Dieselmotoren
(Springer, 2016), pp. 471–496
3. G. Borman, K. Nishiwaki, Internal-combustion engine heat transfer. Prog. Energy Combust.
Sci. 13(1), 1–46 (1987)
4. D. Bristow, M. Tharayil, A. Alleyne, A survey of iterative learning control. IEEE Control Syst.
Mag. 26(3), 96–114 (2006)
5. M.W. Chase, NIST-JANAF Thermochemical Tables (American Institute of Physics, 1998)
6. M. Chiodi, M. Bargende, Improvement of engine heat-transfer calculation in the three￾dimensional simulation using a phenomenological heat-transfer model, SAE Technical Paper,
2001
7. E.G. Giakoumis, Driving and Engine Cycles (Springer, Berlin, 2017)
8. S. Gordon, B.J. McBride, Computer program for calculation of complex chemical equilib￾rium compositions, rocket performance, incident and reflected shocks, and Chapman-Jouguet
detonations, in National Aeronautics and Space Administration (1971)
9. L. Guzzella, C.H. Onder, Introduction to Modeling and Control of Internal Combustion Engine
Systems (Springer, Berlin, 2010)
10. J. Hammer, M. Raff, D. Naber, Advanced diesel fuel injection equipment – a never ending
BOSCH story, in Internationales Stuttgarter Symposium (2014), pp. 31–45
11. S. Hänggi, G. Moretto, T. Albin, C. Onder, The potential of heat release rate and cylinder pres￾sure feedback control for conventional and premixed charge compression ignition combustion.
Int. J. Engine Res., p. 1468087420948314 (2020)
12. J.B. Heywood, Internal Combustion Engine Fundamentals (McGraw-Hill Education, 2018)
13. G.F. Hohenberg, Advanced approaches for heat transfer calculations, SAE Transactions, pp.
2788–2806 (1979)References 311
14. R. Isermann, Engine Modeling and Control (Springer, Berlin, 2014)
15. C. Jörg, Development of a combustion rate shaping controller for transient engine operation on
a direct injection compression ignition engine, Ph.D. Thesis, RWTH Aachen University, 2018
16. C. Jörg, T. Schnorbus, S. Jarvis, B. Neaves, K. Bandila, D. Neumann, Feedforward control
approach for digital combustion rate shaping realizing predefined combustion processes. SAE
Int. J. Engines 8(3), 1041–1054 (2015)
17. C. Jörg, J. Schaub, D. Neumann, S. Pischinger, Diesel combustion control via rate shaping.
MTZ Worldwide 79(4), 16–21 (2018)
18. U. Kiencke, L. Nielsen, Automotive Control Systems (Springer, Berlin, 2005)
19. X. Luo, M. Donkers, B. de Jager, F. Willems, Multi-pulse fuel injection controller design using
a quadratic model, in IEEE Conference on Control Applications (2016), pp. 305–310
20. X. Luo, M. Donkers, B. de Jager, F. Willems, Systematic design of multivariable fuel injection
controllers for advanced diesel combustion. IEEE Trans. Control Syst. Technol. 99, 1–12 (2018)
21. G. Merker, C. Schwarz, G. Stiesch, F. Otto, Simulating Combustion: Simulation of Combustion
and Pollutant Formation for Engine-Development (Springer, Berlin, 2014)
22. D. Neumann, P. Muthyala, C. Frenken, J. Schaub, C. Jörg, M. Kötter, Flex-fuel capability via
advanced digital combustion rate shaping and airpath control. Internationaler Motorenkongress
2019, 333–350 (2019)
23. T. Schnorbus, M. Lamping, T. Körfer, S. Pischinger, New challenges for combustion control
in advanced diesel engines. MTZ Worldwide 69(4), 18–26 (2008)
24. F. Tschanz, S. Zentner, C.H. Onder, L. Guzzella, Cascaded control of combustion and pollutant
emissions in diesel engines. Control Eng. Pract. 29, 176–186 (2014)
25. G. Turesson, L. Yin, R. Johansson, P. Tunestål, Predictive pressure control with multiple injec￾tions. IFAC-PapersOnLine 51(31), 706–713 (2018)
26. T. Wintrich, S. Rothe, K. Bucher, H.-J. Hitz, Diesel injection system with closed-loop control.
MTZ Worldwide 79(9), 54–59 (2018)
27. G. Woschni, Die Berechnung der Wandverluste und der thermischen Belastung der Bauteile
von Dieselmotoren. Motortechnische Zeitschrift 31(12), 338–353 (1970)
28. G. Woschni, A universally applicable equation for the instantaneous heat transfer coefficient
in the internal combustion engine, in SAE transactions (1968), pp. 3065–3083
29. R. Zweigel, F. Thelen, D. Abel, T. Albin, Iterative learning approach for diesel combustion
control using injection rate shaping, in European Control Conference (2015), pp. 3168–3173Chapter 15
Combustion Rate Shaping Control
Abstract The current state-of-the-art combustion control concepts are based on
cycle-to-cycle actuation and the control of cycle-integral values. A more advanced
combustion control concept, the so-called combustion rate shaping, aims to control
the combustion process in a highly time resolved manner. In case of the fullest extent,
the crank-angle-resolved in-cylinder pressure signals are controlled. The concept
relies on the actuation side on injection systems that are highly flexible as given
for modern injection systems. In this chapter, two aspects of the combustion rate
shaping are detailed. First, the modeling of the combustion process is investigated. A
low-order model is required that is able to reproduce the combustion process in case
of highly flexible injection events. A suitable approach based on data-based models
is presented. Second, the digitalization of a continuous injection profile is examined.
Digitalization is needed when a series-production injector is applied as they are
only capable of realizing digital injection events. In both parts, optimization-based
methods are depicted.
15.1 Introduction
The goal of combustion rate shaping is the control of a highly time-resolved com￾bustion profile. One prerequisite is the usage of an injector that is highly flexible. In
general, there exist two injection systems that can be applied for this purpose. Fuel
injectors can be applied that are capable of injecting a continuously shaped injection
rate profile [14]. Thus, as actuated values the trace of the injection shape profile can
be manipulated. These kinds of fuel injectors are only available as prototypes for
research [11]. Alternatively, conventional fuel injection systems can be applied that
are used in series production. The electric actuation signal turns the injector “on”
and “off” for each injection event, making it “digital”. The “on” and “off” switching
can be conducted multiple times within one combustion cycle. Thus, a multi-pulse
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7_15
313314 15 Combustion Rate Shaping Control
fuel injection strategy results with a flexible number of injection events [13, 16].
As actuated values the timings and the duration of the various injection events can
be chosen. Often, these two approaches are referred to as continuous vs. digital
combustion rate shaping. The maximum achievable control quality is higher for con￾tinuous combustion rate shaping, but it poses higher demands on the injection system.
The achievable quality of digital rate shaping is strongly dependent on the injection
system applied. This concerns hardware-specific parameters such as the minimum
amount of fuel that can be injected per injection event and the minimum time dis￾tance between two injection events, the so-called dwell time. For the calculation of
a suitable injection profile, the consideration of these limitations is essential to fully
exploit the capabilities of the injection system applied [23].
Figure 15.1 shows a possible control structure for the realization of digital com￾bustion rate shaping which is reproduced from previous collaborative work of the
author in [23]. In this concept, a continuously shaped trace of heat release rate is
used as a controlled variable. Thus, the desired trace of heat release rate is needed
which is used as a reference profile. The desired trace of heat release rate needs to
fulfill criteria such as providing the requested torque and achieving low pollutant
emissions and also low noise emissions. Based on the reference trace and the current
measurements, a controller calculates a continuous injection rate profile. Due to the
nonlinearities of the system to be controlled, model-based approaches are advan￾tageous for this task. In turn, a model of the combustion process is necessary. For
digital combustion rate shaping, an injector is applied that cannot inject a continuous
injection rate profile. Thus, subsequently, an injection rate digitalization is necessary.
The goal of the digitalization process is to obtain the digital actuated signals of the
injector that resemble as close as possible the continuous injection rate profile.
Two aspects of the combustion rate shaping are depicted. First, a data-based
approach is presented for the modeling of the combustion process. This model can
be used within the combustion controller that transforms the desired heat release
trace along with the measurements into a continuous injection profile. Second, an
Fig. 15.1 Control structure for digital combustion rate shaping – reproduced from [23] with per￾mission of the American Automatic Control Council15.1 Introduction 315
optimization-based approach for injection rate digitalization is presented. The data￾based injector model is presented along with the optimization problem.
15.2 Combustion Modeling
For model-based combustion rate shaping, a low-order model of the combustion
process is needed. The combustion model uses the injection rate profile as input
variables, and the relevant output is the accumulated heat release from combustion
Qcomb(φ). Typically, the progress is represented in dependence of the crank angle φ
as an independent variable. The main challenge arises as the inputs and the outputs
are high-dimensional, as they represent quasi-continuous traces, and the input–output
correlation is strongly nonlinear. Multiple approaches exist to model the combustion
process. They vary in terms of the detail level and the computational complexity.
15.2.1 Overview on Combustion Modeling Approaches
The most detailed models are given by Reactive Computational Fluid Dynamics
models. They describe the physical and chemical processes involved by first-principle
models, e.g. for the fuel spray vaporization, the turbulent flow dynamics, and the
chemical reactions [17, 21]. Typically, the mathematical model is given by partial
differential equations (PDEs). As the effect of the engine geometry can be predicted,
they are, for instance, well suited for applications such as the design of the combustion
chamber [10]. However, they are many orders of magnitude too complex for real-time
optimization-based control.
There exist two alternatives that can be used for optimization-based control. One
possibility is given by data-based models which use global empirical relations in
order to approximate the measured system behavior. They can approximate the behav￾ior very well with low computational demands. However, they are only well suited if
enough measurement data is available, i.e. they have little capability of extrapolation.
Another possibility is given by simplified physics-based models, often referred as
phenomenological models. They are better suited in terms of extrapolation capability
but usually are more complex than data-based models. Phenomenological models
use various submodels in order to describe the heat release by combustion. The sub￾models are represented by simplified physical relations or by data-based models.
Thus, phenomenological models cover a broad spectrum regarding computational
complexity and detail level [18]. Depending on the level of detail described, sub￾processes like spray development and mixture formation can be included [22]. A
computationally inexpensive model is described in [6, 7]. The model is based on
the idea that the heat release rate is proportional to the recent fuel mass available
for combustion. To account for this, the difference between the energy of the total
fuel mass injected into the cylinder up until that moment Qfuel(φ) and the energy316 15 Combustion Rate Shaping Control
of the already burnt fuel mass which is equivalent to the accumulated heat release
Qcomb(φ) is considered in the differential equation:
dQcomb
dφ (φ) = C(φ) 
Qfuel(φ) − Qcomb(φ) (15.1)
The progress-dependent proportionality factor C(φ) can be interpreted in a physi￾cal sense, i.e. it represents the local density of the turbulent kinetic energy. Other
researchers as [5, 16, 19] have extended this approach in order to include the ignition
delay. In this case, a time-variant ignition delay time τign(φ) is added. Using Hlhv as
lower heating value and mfuel,inj as the injected fuel mass, it results:
Qfuel(φ) = Hlhvmfuel,inj(φ − τign(φ)) (15.2)
As the input for these kind of models is given by the profile of injected fuel mass,
they are applicable for combustion rate shaping. Several approaches for combus￾tion rate shaping have been presented that are based on phenomenological models.
The models are, for instance, well suited for feedforward control. Combustion rate
shaping approaches are detailed in publications such as [16, 19].
15.2.2 Data-Based Combustion Models
Data-based combustion models can be used within single-zone models as presented
in Sect. 14.2. They offer the possibility to reproduce the combustion process with
low computational demands. They use basis functions for the approximation of the
system behavior. These basis functions are also called replacement burn functions.
The parameters of the model are given as a function that depends on global variables
describing the current operating point such as the engine speed. The suitability of a
certain replacement burn function depends heavily on the combustion type investi￾gated. For instance, different functions are needed for SI and CI combustion and for
single-pulse injection and multi-pulse injection. Thus, the replacement burn function
has to be chosen carefully according to the given system setup.
In the following, the most common replacement burn function, the Vibe function,
is introduced. More specifically, the classical Vibe function is introduced along with
an extension to a Vibe mixture model. The Vibe mixture model is suited for modeling
the CI combustion process arising for CI combustion rate shaping.
Vibe Combustion Model
The Vibe function is the most common replacement burn function that is used for
data-based modeling of the combustion process [12]. The original publication dates
back to 1956 [26]. The Vibe function describes the accumulated heat release from
combustion Qcomb(φ) with the progress in crank angle φ as an independent variable.
The analytic function which is defined for φ ≥ φSOC is given by15.2 Combustion Modeling 317
Qcomb(φ) = Qtot ·

1 − E−a
 φ−φSOC Δφbd m+1
(15.3)
The value Qtot = mfuel,totHlhv denotes the total energy of the fuel injected over the
combustion cycle. The instant of start of combustion is denoted by φSOC. The duration
of combustion is given by Δφbd. The two parameters a and m determine the shape
of the resulting heat release profile.
The differentiation of (15.3) with respect to φ yields the analytic function for the
heat release rate dQcomb
dφ (φ):
dQcomb
dφ (φ) = aQtot · (m + 1) ·
φ − φSOC
Δφbd m
E−a·
 φ−φSOC Δφbd m+1
(15.4)
Figure 15.2 shows an exemplary variation of a and the resulting profiles for the
heat release rate and the accumulated heat release. Similarly, Fig. 15.3 shows an
exemplary variation of the parameter m.
The classical Vibe function is well suited for the approximation of the combus￾tion process of an SI engine. In fact, it was developed for reproducing the SI engine
behavior. However, it is not well suited for CI combustion. The single Vibe function
cannot reproduce the characteristic phases of CI combustion, i.e. the premixed com￾0 10 20 30 40 50
0
1
2
3
4.0
6.9
15.0
Value of a
0 10 20 30 40 50
0
1
Fig. 15.2 Vibe function model for various values of the shape parameter a318 15 Combustion Rate Shaping Control
0 10 20 30 40 50
0
1
2
3
4
1.0
2.5
5.0
Value of m
0 10 20 30 40 50
0
1
Fig. 15.3 Vibe function model for various values of the shape parameter m
bustion phase, the subsequent diffusive combustion phase, and the burn-out phase.
For data-based modeling of the CI combustion, several adaptations have been pro￾posed. This includes the use of multiple Vibe functions [18] as well as the use of
other replacement burn functions, such as the use of hyperbolic profiles or polygon￾hyperbola functions [3, 25]. In the following, the use of multiple Vibe functions,
so-called Vibe mixture models, is introduced.
Vibe Mixture Combustion Model
Vibe mixture combustion models have been proposed for accurately reproducing
the behavior of CI combustion for combustion rate shaping applications [24]. The
main idea is the representation of the heat release rate by the linear superposition of
multiple Vibe functions. The basic principle is depicted in Fig. 15.4 where the sum
of three Vibe functions is calculated to derive the overall heat release rate. The linear
superposition of various Vibe functions allows to reproduce complex combustion
profiles.
One Vibe mixture combustion model approach was presented in collaborative
work of the author [24], which is detailed in the following. In this case, the continuous
fuel injection profile is discretized into Nu samples, i.e. u = [u1 ... uNu ]
T. The unit
of each discretized input shall be given by the injected energy, i.e. ui = mfuel,iHlhv.
The sum of all discretized injected energy packages is equal to the total energy
injected in one cycle:15.2 Combustion Modeling 319
Fig. 15.4 Linear superposition of various Vibe functions, adapted by permission from Springer
Nature: [24], copyright 2020
Qtot = 
Nu
i=1
ui (15.5)
The Vibe mixture model relates the i fuel packages ui to the accumulated heat release
denoted by Qcomb,i(φ). For the Vibe mixture model, it is assumed that the injected
fuel is burnt entirely and that each injected fuel package results in a distinctive heat
release Qcomb,i(φ). The overall heat release is given by the sum of all the individual
heat release functions.
Qcomb(φ) = 
Nu
i=1
Qcomb,i(φ) = 
Nu
i=1
ui ·

1 − E−ai
 φ−φSOC,i
Δφbd,i mi +1
(15.6)
For each of the Nu Vibe functions, the parameters mi , Δφbd,i, and φsoc,i need to
be determined. The parameters ai are typically fixed to a constant value. In [24], a
value of a = 6.908 is chosen, which results in 99.9% burnt fuel after the duration of
combustion Δφbd,i, which is a reasonable assumption.
The identification of the various parameters within the Vibe mixture model can
be conducted by numerical solution of an optimization problem where measured
data is used as input. Within the optimization problem, constraints can be considered
such that a reasonable solution results. The overall optimization problem can be
formulated as follows, where Qcomb,meas,k denotes the measured accumulated heat
release at the discrete-time point k and Qcomb,k denotes the one predicted by the Vibe
mixture model at the discrete-time point k.320 15 Combustion Rate Shaping Control
min
m, φsocΔφbd

N
k=1
Qcomb,meas,k − Qcomb,k (m, Δφsoc, φbd )2 (15.7a)
s.t. φsoc,min ≤ φsoc ≤ φsoc,max , (15.7b)
Δφbd,min ≤ Δφbd ≤ Δφbd,max , (15.7c)
mmin ≤ m ≤ mmax , (15.7d)
φsoc,i ≤ φsoc,i+1i = 1, .., Nu − 1, (15.7e)
φsoi,i ≤ φsoc,i i = 1, .., Nu − 1 (15.7f)
In the optimization problem, a least-squares cost function is used which penalizes
the deviation from the measured data. Box constraints are defined for the parame￾ters m, φsoc, Δφbd ; see (15.7b)–(15.7d). These constraints limit the parameter range
to realistic values. Additionally, the constraint in (15.7e) ensures that the order of
combustion is maintained, i.e. φsoc,i ≤ φsoc,i+1. The constraint in (15.7f) forces the
start of combustion φsoc,i of a package i to be after the start of injection of the
corresponding fuel injection package, which is denoted by φsoi,i .
One possibility to solve this optimization problem is given by sequential quadratic
programming (SQP). As a least-squares objective is used, the Gauss–Newton approx￾imation can be applied. Figure 15.5 shows a validation plot of a Vibe mixture model.
In this case, the fuel injection was realized with a series-production injector. In the
combustion cycle shown, four injections have been realized. The continuous injection
profile has been discretized using Nu = 60 packages. Each of the Nu = 60 packages
results in a specific Vibe function. Within the figure, the sum of all individual Vibe
Fig. 15.5 Validation of the Vibe mixure model against measured data, adapted by permission from
Springer Nature: [24], copyright 202015.2 Combustion Modeling 321
functions is shown. The figure shows that the complex combustion profile can be
reproduced very accurately using the Vibe mixture model.
The speed of the SQP algorithm even allows to solve the optimization problem
during the runtime of the process. This can be exploited for the purpose of deriving
feedforward maps at the combustion engine test bench. For instance, a learning-based
control algorithm can be applied. In this case, in each iteration, the parameters of
the model are adapted, i.e. by model parameter identification, to improve the model
accuracy. The updated model itself is used subsequently to generate the actuation
profile for the next iteration. This algorithm relies on fast updates of the model
parameters, which can be accomplished with the SQP algorithm.
15.3 Optimization-Based Fuel Injection Rate Digitalization
Several approaches have been proposed to “digitalize” the continuous fuel injection
profile. For instance, in [15], an iterative approach is presented. Boundary conditions
such as the dwell time which specifies the minimum time between two subsequent
injection events and the minimum fuel quantity injected are considered using heuris￾tic rules. An alternative possibility was presented in the collaborative work of the
author [23]. It uses real-time optimization for the digitalization task. The formulation
as an optimization problem has the advantage that the nonlinear model of the injection
system can be taken into account. Additionally, limitations of the hardware such as
the dwell time can be considered directly as constraints of the optimization problem.
Thus, the optimal digitalized injection strategy can be found that is effectively real￾izable with the given injection system. The real-time optimization-based approach
from [23] is detailed below. First, the data-based fuel injection model is introduced
along with its validation. Based on this, the formulation of the optimization problem
is detailed. Finally, results from the digitalization process are highlighted.
15.3.1 Data-Based Fuel Injection Model
For the optimization-based fuel injection rate digitalization, a model is needed that
correlates the actuated values start of energizing SOEi and duration of energizing
DOEi of the ninj injection events to the output which is the overall volume flow
of injected fuel V˙
fuel,inj(t). The model needs to be of low order for usage within
optimization-based control. At the same time, a continuously differentiable model
makes the application of gradient-based optimization methods possible.
There exist several approaches to model the injector fuel volume flow. For
instance, physical models can be used, such as proposed in [8, 9]. All the components
of the injection system are modeled, such as the fuel flow dynamics, mechanical dis￾placement of moving parts, and pressure wave propagation. A very detailed model
results that captures the most important physical effects occurring in the injection322 15 Combustion Rate Shaping Control
system. However, the resulting model is of high order which makes it too complex
to be used for real-time optimization. Alternatively, data-based models can be used
which are typically computationally cheap such that they are suitable for real-time
optimization. Usually, a sum of multiple instances of a base-function is used with
the individual energizing timing SOEi and DOEi as inputs. The overall fuel volume
flow V˙
fuel,inj is given by the sum of each individual injection event i:
V˙
fuel,inj(t) = ninj
i=1
V˙
fuel,inj,i(t, SOEi, DOEi) (15.8)
The superposition reproduces the real behavior appropriately well as long as the
injection events are not influenced by a preceding injection event. This assumption
holds true when the time between two injection events is sufficiently long, i.e. longer
than the dwell time τdwell.
Various base-functions have been applied to reproduce the behavior of the injec￾tion system. For instance, in [16, 20], the use of trapezoidal shapes has been proposed.
The trapezoidal base-function can reproduce the system behavior quite well; how￾ever, it has the disadvantage that it is not continuously differentiable. In [23], the use
of second-order step response functions with dead-time as base-function is suggested
which are smoothly connected such that the overall model is continuously differen￾tiable. Additionally, an empirical function is used to describe the injection dead-time
τinj between the start of energizing SOE and the start of injection SOI. Physically, this
dead-time is caused by the delay of the piezoelectric stack and the needle [4]. The
model can reproduce the fuel volume flow very accurately. An exemplary validation
from [23] is shown in Fig. 15.6.
15.3.2 Formulation of the Optimization Problem
The optimization variables are given by the start timings and the durations of ener￾gizing for the various injection events SOEi, DOEi ∈ R for i = 	
1,..., ninj

. The
number of injection events ninj ∈ N itself is an optimization variable, as the opti￾mal number can vary based on the reference trace and the rail pressure applied.
The inclusion of integer optimization variables makes the optimization problem a
mixed-integer problem. For appropriate injection rate digitalization, the optimiza￾tion problem has to consider various aspects. The main goal of the digitalization
method is to calculate the optimization variables that reproduce as good as possi￾ble the continuous reference signal V˙
fuel,ref(t). The rail pressure is considered as an
external parameter. At the same time, the limitations of the hardware are considered
as constraints.
Formulation of the Continuous-Time Optimal Control Problem
A continuous-time finite-horizon mixed-integer nonlinear optimal control problem is
set up in order to achieve the goals mentioned above. Within the cost function (15.9a),15.3 Optimization-Based Fuel Injection Rate Digitalization 323
Fig. 15.6 Validation of
injection rate model for
various rail pressures prail
and durations of energizing
DOE – reproduced from [23]
with permission of the
American Automatic Control
Council
the least-squares deviation between the integrated fuel volume flow and the integrated
reference trace is used. The consideration of the integrated fuel volume flow has
advantages compared to the non-integrated volume flow. The integration has a low￾pass characteristic, thus a higher sampling time can be used which decreases the
computational complexity. Additionally, the integration preserves the information
of the preceding fuel injection events, which avoids undersampling where small
injection events are crossed over.
min
SOEi,DOEi,ninj
for i∈{1,...ninj}
 TN2
TN1

Vfuel,inj(t) − Vfuel,ref(t)


2
dt (15.9a)
s.t.
V˙
fuel,inj(t) = ninj
i=1
V˙
fuel,inj,i(t, SOEi, DOEi), (15.9b)
Vfuel,inj(TN1 ) = 0, (15.9c)
Vfuel,inj(TN2 ) = Vfuel,ref(TN2 ), (15.9d)324 15 Combustion Rate Shaping Control
SOIi(SOEi) ≥ EOIi−1 (SOEi−1, DOEi−1) + τdwell, i ∈ 	
2,..., ninj

,
(15.9e)
SOI1(SOE1) ≥ TN1 , (15.9f)
EOIninj(SOEninj, DOEninj) ≤ TN2 , (15.9g)
DOEmin ≤ DOEi ≤ DOEmax, i ∈ 	
1,..., ninj

, (15.9h)
1 ≤ ninj ≤ ninj,max (15.9i)
The data-based model of the injector is added as equality constraint (15.9b). The
boundary conditions for the beginning and the end of the integrated fuel volume flow
are incorporated in (15.9c)–(15.9d). The consideration of the terminal constraint is
important in order to maintain the amount of injected fuel volume respectively fuel
mass and thus the generated torque. Additionally, hardware-related limitations of
the injection system are incorporated. The inequality constraint (15.9e) ensures that
the dwell time is considered. The start of injection SOI and the end of injection EOI
are given by data-based models that depend on the optimization variables. For the
injections timings, a minimum and a maximum value are defined, which are included
by (15.9f)–(15.9g). For the durations of injections, minimum and maximum values
are defined as well by (15.9h). The upper limit for the number of injection events
ninj is considered by (15.9i).
Discretization and Numerical Solution of the Resulting Mixed-Integer NLP
For discretization, a single shooting approach is used, due to the structure of the
model, i.e. the injection events are decoupled in the model. All in all, N discretization
intervals are used with a sampling time of Ts = TN2−TN1
N . The numerical integration
of the fuel volume flow is conducted with nint integration steps per interval using a
third-order explicit Runge–Kutta integration scheme, resulting in
Vfuel,inj(k + 1) = ninj
i=1
fdis(Vfuel,inj(k), SOEi(k), DOEi(k)) (15.10)
The following optimization problem results:
min
SOEi,DOEi,ninj
for i∈{1,...ninj}

N
k=1

Vfuel,inj(k) − Vfuel,ref(k)


2 Ts (15.11a)
s.t.
Vfuel,inj(k + 1) = ninj
i=1
fdis(Vfuel,inj(k), SOEi(k), DOEi(k)), k ∈ {0,..., N − 1},
(15.11b)
Vfuel,inj(k = 0) = 0, (15.11c)
Vfuel,inj(k = N) = Vfuel,ref(k = N), (15.11d)15.3 Optimization-Based Fuel Injection Rate Digitalization 325
SOIi(SOEi) ≥ EOIi−1

SOEi−1, DOEi−1

+ τdwell, i ∈ 	
2,..., ninj

,
(15.11e)
SOI1(SOE1) ≥ TN1 , (15.11f)
EOIninj(SOEninj, DOEninj) ≤ TN2 , (15.11g)
DOEmin ≤ DOEi ≤ DOEmax, i ∈ 	
1,..., ninj

, (15.11h)
1 ≤ ninj ≤ ninj,max (15.11i)
For numerical solution of the optimization problem, the problem is split up into
several NLPs. More specifically, for each integer possibility of number of injection
events ninj = 1,..., ninj,max, a single NLP is solved. Each of this NLPs is solved by
an SQP algorithm. The overall minimizer can be obtained by comparing the various
solutions, i.e. the one with the lowest cost is the overall minimizer. As a least-squares
tracking term is given in the cost function, the Gauss–Newton Hessian approximation
can be employed. CasADi is used for automated calculation of the derivatives [1].
15.3.3 Validation of the Fuel Injection Rate Digitalization
Concept
In the following, the validation of the fuel injection rate digitalization method is
detailed. For this purpose, a reference trace for the continuous injection rate is dig￾italized with the optimization-based method. Figure 15.7 shows the results of an
exemplary digitalization. The reference trace is a so-called “boot”-shaped injection
profile which is commonly used for advanced CI combustion. From a combustion
point of view, it offers the advantage that the peak of the premixed portion is reduced,
and a combustion with a quite constant pressure rise gradient results [2]. At the same
time, it is a profile that is challenging to be reproduced with digital injection events,
due to the flat slope at the beginning of the injection. The digitalization method is
applied for three rail pressures. In all three cases, the approach detailed is able to
find suitable injection profiles that reproduce the continuous injection very well. For
quantification of the performance, the root mean squared error (RMSE) is used. The
optimal number of injections depends on the rail pressure applied as the maximum
fuel volume flow depends on the rail pressure setting. As well, all the profiles com￾ply with the constraints formulated, such as the dwell time and the total fuel volume
injected over all injections.326 15 Combustion Rate Shaping Control
Fig. 15.7 Validation of
injection rate digitalization
for various rail pressures
prail – reproduced from[23]
with permission of the
American Automatic Control
Council
References
1. J. Andersson, J. Akesson, M. Diehl, CasADi: a symbolic package for automatic differentiation
and optimal control, inRecent Advances in Algorithmic Differentiation (Springer, Berlin, 2012),
pp. 297–307
2. F. Atzler, O. Kastner, A. Rotondi, A. Weigand, Multiple injection and rate shaping – Part 1:
Emissions reduction in passenger car diesel engines. SAE Technical Paper, no. 2009-24-0004
(2009)
3. C. Barba, Erarbeitung von verbrennungskennwerten aus indizierdaten zur verbesserten prog￾nose und rechnerischen simulation des verbrennungsablaufes bei pkw-de-dieselmotoren mit
common-rail-einspritzung. Ph.D. Thesis, ETH Zurich (2001)
4. G. Bianchi, S. Falfari, F. Brusiani, P. Pelloni, G. Osbat, M. Parotto, Numerical investigation
of critical issues in multiple-injection strategy operated by a new CR fast-actuation solenoid
injector. SAE Technical Paper, no. 2005-01-1236 (2005)
5. A. Catania, R. Finesso, E. Spessa, Predictive zero-dimensional combustion model for DI diesel
engine feed-forward control. Energy Convers. Manag. 52(10), 3159–3175 (2011)
6. F. Chmela, G. Orthaber, Rate of heat release prediction for direct injection diesel engines based
on purely mixing controlled combustion. SAE Trans. 152–160 (1999)
7. F. Chmela, G. Pirker, A. Wimmer, Zero-dimensional ROHR simulation for DI diesel engines
- a generic approach. Energy Convers. Manag. 48(11), 2942–2950 (2007)
8. C. Dongiovanni, M. Coppo, D. Siano, Accurate modelling of an injector for common rail
systems. Fuel Inject. 95–119 (2010)
9. R. Garrappa, P. Lino, G. Maione, F. Saponaro, Model optimization and flow rate prediction in
electro-injectors of diesel injection systems. IFAC-PapersOnLine 49(11), 484–489 (2016)References 327
10. H.-W. Ge, Y. Shi, R.D. Reitz, D. Wickman, W. Willems, Engine development using multi￾dimensional cfd and computer optimization. SAE Technical Paper (2010)
11. P. Grzeschik, H.-J. Laumen, U. Schlemmer Kellig, FEV HiFORS injector with continuous
rate shaping: influence on mixture formation and combustion process. Energy Environ. 1(9),
123–135 (2016)
12. L. Guzzella, C.H. Onder, Introduction to Modeling and Control of Internal Combustion Engine
Systems (Springer, Berlin, 2010)
13. J. Hammer, M. Raff, D. Naber, Advanced diesel fuel injection equipment – a never ending
BOSCH story, in Internationales Stuttgarter Symposium (2014), pp. 31–45
14. J. Hinkelbein, F. Kremer, M. Lamping, T. Körfer, J. Schaub, S. Pischinger, Experimental
realisation of predefined diesel combustion process using advanced closed-loop combustion
control and injection rate shaping. Int. J. Engine Res. 13(6), 607–615 (2012)
15. C. Jörg, Development of a combustion rate shaping controller for transient engine operation on
a direct injection compression ignition engine. Ph.D. Thesis, RWTH Aachen University (2018)
16. C. Jörg, T. Schnorbus, S. Jarvis, B. Neaves, K. Bandila, D. Neumann, Feedforward control
approach for digital combustion rate shaping realizing predefined combustion processes. SAE
Int. J. Eng. 8(3), 1041–1054 (2015)
17. S. Kumar, M.K. Chauhan et al., Numerical modeling of compression ignition engine: a review.
Renew. Sustain. Energy Rev. 19, 517–530 (2013)
18. G. Merker, C. Schwarz, G. Stiesch, F. Otto, Simulating Combustion: Simulation of Combustion
and Pollutant Formation for Engine-Development (Springer, Berlin, 2014)
19. D. Neumann, C. Jörg, N. Peschke, J. Schaub, T. Schnorbus, Real-time capable simulation of
diesel combustion process for HiL applications. Int. J. Eng. Res. 19(2), 214–229 (2018)
20. R. Payri, J. Gimeno, R. Novella, G. Bracho, On the rate of injection modeling applied to direct
injection compression ignition engines. Int. J. Eng. Res. 17(10), 1015–1030 (2016)
21. R. Reitz, C. Rutland, Development and testing of diesel engine cfd models. Progress Energy
Combust. Sci. 21(2), 173–196 (1995)
22. D. Rether, M. Grill, A. Schmid, M. Bargende, Quasi-dimensional modeling of CI-combustion
with multiple pilot- and post injections. SAE Int. J. Eng. 3(1), 12–27 (2010)
23. D. Ritter, M. Korkmaz, H. Pitsch, D. Abel, T. Albin, Optimization-based fuel injection rate
digitalization for combustion rate shaping, in American Control Conference (2019)
24. J. Schilliger, N. Keller, S. Hänggi, T. Albin, C. Onder, Data-based modeling for the crank
angle resolved ci combustion process, in Data Analysis for Direct Numerical Simulations of
Turbulent Combustion (Springer, Berlin, 2020), pp. 197–213
25. G. Stiesch, Modeling Engine Spray and Combustion Processes (Springer Science & Business
Media, Berlin, 2003)
26. I.I. Vibe, Semi-empirical expression for combustion rate in engines, in Proceedings of Confer￾ence on Piston Engines, USSR Academy of Sciences (1956), pp. 185–191Index
A
Aftertreatment path controller, 177
Air path controller, 177
Air-to-fuel ratio, 178
Anti-windup mechanism, 29
B
Back-calculation scheme, 29
C
CI engines, 178
Classification of control algorithms, 6
Combustion average, 197, 307
Combustion chamber recirculation, 198
Combustion rate shaping, 205, 296
Control of cycle-integral parameters, 296
Convex function, 43
Convex set, 42
Crank kinematics, 304
Cycle-to-cycle control, 200
D
Decentralized control, 18
Delta formulation, 153
Dense formulation, 75
Diesel-ignited dual-fuel, 207
Direct methods, 119
Disturbance model, 148
Dynamic regulator, 156
E
Emissions regulations, 2
Engine control architecture, 175
Engine process simulation, 303
Euler discretization, 65
Euler method, 120
Exact discretization, 66
Exact penalty function, 141
Exhaust gas recirculation, 186
F
Fuel injection rate digitalization, 314
Fuel path controller, 177
G
Gasoline controlled autoignition, 195
Gauss–Newton approximation, 117
Globalization strategies, 107
Gray-box model, 217
H
Hard constraints, 140
Heat release analysis, 303
Heat release rate, 297
Hessian matrix, 41
High-pressure cycle, 296
Homogenous charge compression ignition,
198
I
Ignition path controller, 177
In-cycle control, 202
Indicated mean effective pressure, 197, 307
Interior point method, 85
© Springer Nature Switzerland AG 2021
T. Albin Rajasingham, Nonlinear Model Predictive Control of Combustion Engines,
Advances in Industrial Control,
https://doi.org/10.1007/978-3-030-68010-7
329330 Index
J
Jacobian matrix, 40
K
KKT conditions, 55
KKT system, 52
L
Light-off temperature, 183
Linear Independence Constraint Qualifica￾tion (LICQ), 51
Linear time-variant MPC, 87
Line-search algorithms, 104
Look-up tables, 33
Low-pressure cycle, 296
LTC engines, 178
Lyapunov stability, 162
M
Maximum pressure rise gradient, 201
Mean-value model, 216
Merit functions, 108
Model predictive control, 8
Multiple-input multiple-output systems, 17
Multiple shooting, 119
Multi-pulse fuel injection, 204
N
Newton method, 105
Nonlinear program, 38
O
Observer, 148
Offset-free control, 145
Optimal control problem, 45
Optimization problem formulation, 11
P
Phenomenological combustion models, 315
Premixed charge compression ignition, 195
Process model, 12
Q
Quadratic program, 46
Qualitative load control, 186
Quantitative load control, 179
R
Reactivity controlled compression ignition,
195
Real-time iteration scheme, 133
Recursive feasibility, 140
Regularization, 107
Relative gain array, 21
Requirements engine control, 4
Return map, 200
Runge–Kutta method, 120
S
Selective catalytic reduction, 186
SI engines, 178
Single shooting, 119
Single-zone model, 297
Soft constraints, 140
Sparse formulation, 78
SQP method, 114
Stability-constrained MPC, 164
State-space model, 63
Steepest descent method, 105
T
Target selector, 156
Terminal constraint, 164
Terminal cost, 164
Three-way catalyst, 179
Turbocharging, 181
U
Unconstrained linear MPC, 69
V
Variable turbine geometry, 188
Vibe combustion model, 316
Vibe mixture combustion model, 318
Volume model, 219
Volumetric efficiency, 223
W
Wall heat transfer, 305

Python Apps on Visual Studio Code
Develop apps and utilize the true potential of Visual Studio Code
Swapnil Saurav
www.bpbonline.comFirst Edition 2024
Copyright © BPB Publications, India
ISBN: 978-93-55519-504
All Rights No part of this publication may be reproduced, distributed or
transmitted in any form or by any means or stored in a database or
retrieval system, without the prior written permission of the publisher with
the exception to the program listings which may be entered, stored and
executed in a computer system, but they can not be reproduced by the
means of publication, photocopy, recording, or by any electronic and
mechanical means.
LIMITS OF LIABILITY AND DISCLAIMER OF WARRANTY
The information contained in this book is true to correct and the best of
author’s and publisher’s knowledge. The author has made every effort to
ensure the accuracy of these publications, but publisher cannot be held
responsible for any loss or damage arising from any information in this
book.
All trademarks referred to in the book are acknowledged as properties of
their respective owners but BPB Publications cannot guarantee the
accuracy of this information.www.bpbonline.comDedicated to
My beloved wife:
Rupali
&
My Son OjassAbout the Author
Swapnil Saurav is a highly accomplished and versatile professional with
over 20 years of experience in various industries, including CPG and
Retail. Passionate about understanding customer challenges and driving
business growth in competitive markets. Skilled in process consulting,
market analysis, sales and marketing support, product development,
customer service, and project management. Known for being a perceptive
troubleshooter with a unique ability to solve large-scale problems using
data analytics skills. Career progression includes roles in product
development, value delivery in sales cycle, and IT operations. Strong
educational background includes an MBA from S. P. Jain Institute of
Management & Research and a Master of Science in Software Systems
from BITS, Pilani.
Swapnil is a results-oriented leader with a track record of driving
organizational success. He has a proven ability to effectively manage large
teams and motivate employees to achieve their full potential. He excels at
creating a positive and collaborative work environment, fostering a culture
of continuous improvement and innovation.Acknowledgement
First and foremost, I would like to express my deepest gratitude to my
family and friends for their unwavering support and encouragement
throughout this book’s writing, especially my wife Rupali, my son Ojass
and my sister Smriti, I could not have achieved this milestone without
your unending support..
I would like to extend my heartfelt appreciation to my publishers, who
believed in the potential of this manuscript and gave me the opportunity to
share my thoughts with the world. Their unwavering support, insightful
feedback, and meticulous editing have been instrumental in shaping this
book into its final form. I am truly grateful for their expertise and
professionalism.
To my friends and colleagues, thank you for your invaluable contributions
and inspiration. Your insightful conversations, wise advice, and
constructive criticism have played a vital role in shaping my ideas and
improving the quality of this book.
I would also like to extend my appreciation to the team of reviewers who
provided their valuable feedback, thank you for your time and dedication
in crafting constructive suggestions.
Lastly, I would like to thank the readers for their interest in this book.
Your support and enthusiasm continue to fuel my passion for writing, and
for that, I am truly grateful. I hope that the words within these pages
resonate with you, inspire you, and bring about positive change in your
technical career.This book would not have been possible without the support and
contributions of these incredible individuals. I am deeply grateful to each
and every one of you for your role in the creation of this work. May this
book serve as a testament to our collective belief in the power of
knowledge, dedication, and unity.Preface
Welcome to the world of Python Apps on Visual Studio In this book, we
aim to provide you with a comprehensive guide on building Python
applications using the Visual Studio Code editor. Python has gained
immense popularity in recent years due to its simplicity, versatility, and an
ever-growing community of developers. As a result, there has been a surge
in demand for tools and editors that cater specifically to Python
development.
Visual Studio Code, commonly known as VS Code, has emerged as one of
the most preferred code editors for Python developers. Its lightweight
nature, extensive customization options, and powerful features make it an
ideal choice for anyone looking to write Python applications. Whether you
are a beginner or an experienced Python developer, this book presents a
step-by-step approach to using Visual Studio Code for Python
development. We will cover essential concepts, techniques, and best
practices that will empower you to build robust Python applications
efficiently.
In this book, readers take their basic programming skills to more
productive and delivering outstanding results and fully functioning
applications using a rich tool, VS Code. This book helps lazy
programmers skip the long learning hours and start being efficient and
effective as a smart python developer.
In this book, the author covers practical teaching, how to use Python in
developing desktop GUI applications, websites and web applications. Youwill explore VS Code and its capabilities. You will also get to know all the
popular and high performing extensions available in VS Code.
Furthermore, you will learn to work around various python high￾performing libraries such as Flask, NumPy, Pandas, and others. You will
come across how to code data structures and implement algorithms, how
to configure web servers, how to add authentication to apps and various
tools to improve the capabilities of your python apps.
Throughout this book, we have strived to provide practical examples, code
snippets, and tips to help you grasp the concepts and apply them to your
own projects. We believe that by the end of this book, you will not only
have a solid understanding of Python development on Visual Studio Code
but also be equipped with the necessary skills to build sophisticated
Python applications.
We hope you find this book to be a valuable resource in your quest to
become a proficient Python developer.
Happy coding!
Chapter 1: Introduction to VS Code - This chapter covers the basics of
using Visual Studio Code, a popular and versatile code editor. Its features
and functionalities, such as creating and managing projects, writing code,
debugging, and integrating with other tools and extensions are covered.
We also learn various tips and tricks to enhance productivity and
efficiency while using Visual Studio Code for coding and development
tasks.
Chapter 2: Setting up the Environment - covers the nuts and bolts of the
VS Code environment and builds the first Python program. This chapter
covers the installation of Python and VS Code, setting up the Pythonenvironment using Python extension, installing default extensions along
with it, and learning about editing settings.
Chapter 3: Top Extensions in VS Code for Python - This chapter covers
the top 10 popular extensions used by developers across the world and the
powerful features of these extensions. Also, you will learn how to
configure these Python extensions and the Python-specific settings, which
can be edited in VS Code. This chapter also covers the installation of
packages in Python. Python, and focuses focuses on how to create
functions, modules, and packages for application development.
Chapter 4: Developing Visualizing Python App in VS Code - In this
chapter, we will cover the Python concepts such as Numpy, Scipy, Pandas,
and Matplotlib and work on data analysis. This chapter also introduces
basic statistical concepts and focuses on how to plot using Matplotlib. The
chapter then explains the practice of data analytics by analyzing sample
datasets. This chapter also provides clear explanations and examples to
help the reader understand these concepts and apply them in practice.
Towards the end of the chapter, the authors guide the reader on how to use
GitHub with VS Code.
Chapter 5: Developing Desktop Application using Database - In this
chapter, the author discusses how Python applications can be used to
create and manage databases for various purposes. Python’s
comprehensive object-oriented library and its ability to interface with
popular database systems make it an ideal choice for the rapid
development of database applications. This chapter emphasizes the
importance of learning to use Python for database applications, an
efficient tool for data analysis and processing. In the last part of thechapter, the author covers debugging in VS Code. Debugging helps
identify potential performance issues and allows for code optimization.
Chapter 6: Advanced Algorithm Design - This chapter focusses on
learning and using different algorithms. The following algorithms are
covered in this chapter: Divide and conquer, Backtracking Binary tree,
Heaps, Hash table, and Graph algorithm. This chapter discusses the
concept of Big O notation, which is a way of measuring the complexity of
an algorithm.
Chapter 7: Building Multithreading Application - This chapter provides an
overview of the concept of threads and how they can be utilized to
optimize the execution of multiple tasks simultaneously. This chapter
discusses the threading module in Python and its various components,
such as threads, locks, and semaphores. It explains how to create and
manage threads, as well as how to implement synchronization
mechanisms to prevent data corruption and race conditions. The chapter
also explores different threading techniques, including thread pooling and
communication between threads.
Chapter 8: Building an Interactive Dashboard using Jupyter Notebook -
This chapter introduces the process of developing a dashboard using
Jupyter Notebooks on Visual Studio Code. This chapter explains how to
set up the necessary environment and dependencies, including installing
the Jupyter extension. The chapter also provides step-by-step instructions
on creating a new Jupyter Notebook file within VS Code and importing
libraries such as Pandas and Matplotlib for data manipulation and
visualization. This chapter concludes with an example of creating a simple
dashboard by analyzing and displaying data from a CSV file.Chapter 9: Editing and Debugging Jupyter Notebook - This chapter
provides a comprehensive guide for effectively editing and debugging
Jupyter Notebooks using VS Code. By reading this chapter, you will
understand various features and functionalities that VS Code offers for
editing Jupyter Notebooks, such as cell manipulation, code execution, and
markdown formatting. This chapter also covers debugging techniques,
including setting breakpoints, inspecting variables, and using the built-in
debugger in VS Code.
Chapter 10: Mastering Tkinter GUI Capabilities using VS Code - This
chapter provides a comprehensive overview of Tkinter’s GUI capabilities
and demonstrates how to utilize them effectively using Visual Studio
Code. The chapter begins with an introduction to the Tkinter library and
its features and then dives into the process of building a graphical user
interface using Tkinter in Visual Studio Code. The topics covered includes
creating windows and frames, adding buttons and labels, using various
widgets and layout managers, and handling events.
Chapter 11: Developing Flask-based Web Applications - In this chapter,
we learned how to build web applications using the Flask framework
provided by Python. The chapter covers a wide range of topics, from
setting up a development environment and creating a basic Flask
application to implementing authentication and authorization, handling
forms, and database interactions. This chapter also provides clear
explanations, step-by-step instructions, and practical examples, making it
an invaluable resource for both beginner and experienced developers
looking to build their own Flask-based web applications.Chapter 12: Working with Containers in Azure - This chapter details the
necessary steps for working with containers in Azure from Visual Studio
Code using Python. By using the right tools and a bit of knowledge,
developers can easily containerize their code in Azure. This chapter also
covers deploying the Flask App developed in Chapter 11 on Azure.Code Bundle and Coloured Images
Please follow the link to download the
Code Bundle and the Coloured Images of the book:
https://rebrand.ly/98a8d0
The code bundle for the book is also hosted on GitHub at
In case there’s an update to the code, it will be updated on the existing
GitHub repository.
We have code bundles from our rich catalogue of books and videos
available at Check them out!
Errata
We take immense pride in our work at BPB Publications and follow best
practices to ensure the accuracy of our content to provide with an
indulging reading experience to our subscribers. Our readers are our
mirrors, and we use their inputs to reflect and improve upon human errors,
if any, that may have occurred during the publishing processes involved.
To let us maintain the quality and help us reach out to any readers who
might be having difficulties due to any unforeseen errors, please write to
us at :
errata@bpbonline.comYour support, suggestions and feedbacks are highly appreciated by the
BPB Publications’ Family.
Did you know that BPB offers eBook versions of every book published,
with PDF and ePub files available? You can upgrade to the eBook version
at www.bpbonline.com and as a print book customer, you are entitled to a
discount on the eBook copy. Get in touch with us at :
business@bpbonline.com for more details.
At you can also read a collection of free technical articles, sign up for a
range of free newsletters, and receive exclusive discounts and offers on
BPB books and eBooks.
Piracy
If you come across any illegal copies of our works in any form on the
internet, we would be grateful if you would provide us with the location
address or website name. Please contact us at business@bpbonline.com
with a link to the material.
If you are interested in becoming an authorIf there is a topic that you have expertise in, and you are interested in
either writing or contributing to a book, please visit We have worked with
thousands of developers and tech professionals, just like you, to help them
share their insights with the global tech community. You can make a
general application, apply for a specific hot topic that we are recruiting an
author for, or submit your own idea.
Reviews
Please leave a review. Once you have read and used this book, why not
leave a review on the site that you purchased it from? Potential readers
can then see and use your unbiased opinion to make purchase decisions.
We at BPB can understand what you think about our products, and our
authors can see your feedback on their book. Thank you!
For more information about BPB, please visit
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the
Authors:
https://discord.bpbonline.comTable of Contents
1. Introduction to VS Code
Introduction
Structure
Why use VS Code?
What is VS Code?
VS Code: Context view
VS Code: Development view
Standardization
Technical Debt
VS Code: Functional view
Functionalities
External InterfacesPerformance and Scalability
Desired quality
Applicability
Concerns
Tactics
VS Code vs Visual Studio
Conclusion
2. Setting up the Environment
Introduction
Structure
Objectives
Setting up a working development environment
Setting up a Python environment
Setting up VS Code EnvironmentInstalling Python extension
Code Runner extension
Project Work: Design a Simple Battleship Game
Random module
Setting and configuring the editor
User setting
Workspace settings
Settings and security
Keyboard arguments
Conclusion
3. Top Extensions in VS Code for Python
Introduction
Structure
ObjectivesTop VS Code extensions
Pylance
Auto-imports
Semantic highlighting
Type checking
Code Runner
Indent Rainbow
Path Intellisense
Tabnine AI Autocomplete
Jupyter
Error Lens
Better Comments
Lightrun
Python Test ExplorerPython-specific settings
Installing and using Python packages
Functions, modules, and packages in Python
Functions
Classes
Method
More about Class and Objects
Inheritance
Polymorphism
Data abstraction
Encapsulation
Modules
PackagesConclusion
4. Developing Visualizing Python App in VS Code
Introduction
Structure
Virtual Environment Concept
Python topics
Numpy
Scipy
Example 4.1
Pandas
Example 4.2
MatPlotLib
Seaborn
Learning the Basics of StatisticsDiscrete data
Continuous data
Interval data
Ratio data
Categorical data (or Qualitative data)
Nominal data
Ordinal data
Visualization for Data Analysis
Data analysis and Business outcome
Working with GitHub
How to set up a repository?
Conclusion
5. Developing Desktop Application using DatabaseIntroduction
Structure
Database introduction and RDBMS
Problem statement: Developing an application
Developing the solution
Database design
Creating tables and adding Constraints
Working with MYSQL
Students class
Books class
Executing the project: Performing CRUD operations
Debugging in VS Code
Conclusion
6. Advanced Algorithm DesignIntroduction
Structure
Objectives
Introduction to algorithm analysis
Divide and conquer
Backtracking
Binary tree
Heaps
Hash table
Graph algorithm
BigO notation: Methodology for analyzing algorithms
Conclusion
7. Building Multithreading ApplicationIntroduction
Structure
Objectives
Introduction to multithreading concepts
Starting a new Thread
Synchronizing threads
Inter-thread communication in Python
Thread pooling with Python
Multithreaded priority queue
Optimizing Python threads for performance
Snake game: Using multithreading and turtle
Conclusion
8. Building an Interactive Dashboard using Jupyter Notebook
IntroductionStructure
Objectives
Introduction to Jupyter Notebook
Setting up a Jupyter Notebook environment on VS code
Working with widgets and visualizations in Jupyter Notebook
Developing a sample program using widgets and visualization
Problem statement
Explanation
Matplotlib Library
Project: Covid-19 interactive dashboard
Interactive dashboard with Panel
Interactive dashboard with Voila
Conclusion9. Editing and Debugging Jupyter Notebook
Introduction
Structure
Objectives
Introduction to debugging in Jupyter Notebook
Debug the program line by line
Full debugging option
Types of errors
Checking your code syntax
Verifying the output
Conclusion
10. Mastering Tkinter GUI Capabilities using VS Code
Introduction
StructureObjectives
Introduction to Tkinter
Understanding Tkinter widgets
Working with Tkinter events
The bind() method
The bind_all() method
The event_generate() method
Creating menus and toolbars with Tkinter
Creating toolbars with Tkinter
Customizing menus and toolbars
Developing an application: A quiz game
Problem statement
ObjectivesRequirements
Solution
Design
Driving code
Implementation
Future enhancements
Conclusion
11. Developing Flask-based Web Applications
Introduction
Structure
Objectives
Set up and create a basic application
Develop a Profile Application
Templates and static contentSetting up Database (SQLite3)
Integrate Flask-Login
Testing the database
Completing the Application
Conclusion
12. Working with Containers in Azure
Introduction
Structure
Objectives
Porting FlaskApp database from SQLite to Postgres
Deploy the Flask application on Azure
Conclusion
IndexChapter 1
Introduction to VS Code
People don’t buy what you do, they buy why you do it.
— Simon SinekIntroduction
Welcome to the first chapter of this book, Python Apps on Visual Studio
You would have guessed correctly by now that we will build lots of
Python applications in this book. But why Visual Studio Code or VS
Code? The first step to learning any programming language is to pick a
code editor and learn the tips and tricks to get the most out of your code
editor. You will come across many code editors to program in Python
from, but the most popular, and my favourite, is VS Code. Do not confuse
VS Code with Visual Studio. VS Code is a free, open-source platform, and
you will learn more about this editor in this chapter.
Over a decade ago, Simon Sinek in his TedTalk, had said, People don’t
buy what you do, they buy why you do It is stuck in my mind till today.
So, the first thing we will talk about is why we should use VS Code for
Python. Next, we will discuss what VS Code is and how to use it.
Visual Studio Code is an open-source code editor that is free to use and
fully supports development in Python programming language. It has
useful features, such as real-time collaboration with other programmers
around the world. This chapter is meant to introduce VS Code to help you
understand its development process and its different components. This
chapter is for readers who have not yet heard about VS Code and wonder
why they should even consider it for their development work. This chapter
will provide information about VS Code; we will discuss why it is
probably the most popular code editor, look at its features, and discuss the
different components of VS Code. We will look at the architecture of VS
Code to understand why it is a perfect tool for software developmentneeds and how a developer can quickly perform a code-build-debug cycle
and leave more complex workflows to fuller featured IDEs, such as
Pycharm or Visual Studio IDE.Structure
We will be looking at the following topics in this chapter:
Why use VS Code?
What is VS Code?
VS Code: Context View
VS Code: Development View
VS Code: Functional View
Performance and Scalability
VS Code vs Visual Studio
Now, let us dive deep into each of these topics.Why use VS Code?
Visual Studio Code, or VS Code, is the best code editor by far for multiple
reasons. As per the official documentation, VS Code provides the delightfully
frictionless edit-build-debug cycle means less time fiddling with your
environment, and more time executing on your ideas. In terms of the number
of users, VS Code has the largest user base (December 2021, source:
JetBrains/Python Software Foundation). JetBrains, along with Python
Software Foundation, conducted a Python developer survey in which
respondents were asked one question, ‘What is the main editor you use for
your current Python development?’ More than 23,000 Python developers
answered the survey. Around 35% answered VS Code, making it number one,
ahead of PyCharm. One interesting finding was that the web developers
preferred PyCharm and VS Code almost equally (about 39%), but data
scientists preferred VS Code as their main editor. The result is represented in
FigureFigure Main IDE/Editor (source: JetBrains/Python Software Foundation)
According to a report published by Visual Studio Magazine July 2022), the
Python extension for Visual Studio Code has seen over 60 million installs,
which is, by far, the highest number of installs. Jupyter has (40.8 million),
Pylance (33.5 million), and Jupyter Keymap (23.4 million), with these
extensions (also related to Python), taking the second, third, and fifth
positions, respectively. But, this did not happen overnight. Visual StudioCode, along with GitHub, Codespaces, and Azure Machine Learning, have
been investing substantially into tools and platforms to make the lives of
Python data scientists easier (source: EuroPython show 2021). The amazing
thing is that we will cover all these in the later chapters of this book, so rest
assured that you will learn the best tools available today.
Let us look at some of its features and why it has become programmers’
favourite code editor:
It is a free open-source (under the MIT License) cross-platform application.
It is easy to use.
It is a lightweight, fast but powerful source code editor.
It can be integrated with scripting tools and perform common tasks like
developing everyday workflows.
It comes with built-in support for tools like IntelliSense code completion,
code refactoring, parameter hints, multi-cursor editing, and rich semantic
code understanding, which takes programming to the next level. For example,
if the user forgets to declare a certain variable before being used in the
program, intelli-sense will declare that variable. A sample screenshot is
shown in the FigureFigure Auto completion in VS Code using Intelli-Sense
It has an integrated interactive debugger, which helps step through the code,
inspect values of variables, and view call stacks. It can also execute
commands in the console. Figure 1.3 shows the various options of integrated
interactive debugger marked on the image:Figure Debugging in VS Code
It runs on a desktop and is available for Windows, macOS, and Linux. Earlier,
editors used to support one of the operating systems, Windows, Linux, or
Mac. But VS Code is cross-platform, so it can easily work on all three
platforms.
It is fully customizable to fit any developer’s preferences and project
requirements.
It has great support from the community and tons of extensions. So, if a
programmer cannot find support for a given programming language, they can
easily download the extension and continue working.
It has built-in support for web programming languages like JavaScript,
TypeScript, and Node.js. It also has an ecosystem of extensions for multiple
other languages and runtimes, such as C++, C#, Java, Python, PHP, Go, and
.NET. These are just a few of more than 30 languages that are supported. This
has another advantage here; VS Code can easily detect if there is any fault in
the cross-language reference.
It can be configured to anybody’s liking through its various settings:
language, user, and workspace. Several scopes for settings are provided by
VS Code, which enables us to modify almost every part of Code’s editor, user
interface, and functional behavior.
It provides comprehensive facilities to computer programmers to be instantly
productive with features like syntax highlighting, bracket-matching, auto￾indentation, box-selection, snippets, and many more.It has support for Git, which means the programmers can work with source
control without leaving the editor, even for viewing pending changes
differences.
It supports multiple projects. It is possible to work with projects containing
multiple files/folders that can be opened simultaneously. These projects or
folders can even be unrelated to each other.
It provides an ides inbuilt terminal/console, so the user need not switch
between VS Code and command prompt or terminal.
It is liked by front-end and back-end developers because of the multiple
language support. Along with this, common zoom-in, zoom-out, brightness,
and theme selection features are also available.
It is updated monthly with new features and bug fixes.What is VS Code?
Now, let us understand why VS Code is probably a better choice among all
the code editors available right now. First, it is free to use and has very useful
features that fully featured IDEs generally have. It enables a programmer to
write code, debug, and autocomplete or correct the code. It is difficult for a
code editor to have such features, but since VS Code has Intelli-sense
integrated with itself, it makes this possible. In this section, we will learn
what the VS Code editor is and how VS Code can integrate such powerful
features. Figure 1.4 shows a sample program running on VS Code editor:
Figure VS Code running a multiple regression code on Windows 10
VS Code is developed with the Electron Framework and made open-source
by Microsoft to create a lightweight alternative to Microsoft’s Visual Studio,
a complex, fully featured Integrated Development Environment There aredifferences between an IDE and Code Editor. IDEs are robust and self￾contained software aimed at making programming easier. All the tools of an
IDE are integrated. On the other hand, a code editor is a text editor, which has
robust built-in features. IDEs also have code editors built into themselves
where the developers write their code. The source-code of VS Code is under
the MIT License and is maintained at the VS Code repository at GitHub
Though VS Code ships under a standard Microsoft product license, it’s free to
use. The commercial license is attached because it has a small percentage of
Microsoft-specific customizations. As it is open-source, developers can
contribute to improving VS Code by adding issues or making pull requests
from the GitHub location. Electron’s open-source framework, maintained by
GitHub, is designed to develop desktop-based applications using web
technologies like HTML, Javascript, and CSS.VS Code: Context view
In this section, we will look at the context diagram of VS Code. A System
Context Diagram is a block or engineering diagram that defines the boundary
of the system and its environment and represents all the external entities that
interact with the system. This provides a high-level understanding of the
system. The objective of creating and understanding a system context
diagram is to understand and focus on external components and events
considered in developing the entire system. Figure 1.5 shows the context
view diagram; we identify different entities and see how they connect to
Visual Studio Code:
Figure Context Diagram for Visual Studio CodeThe preceding Figure 1.5 shows multiple stakeholders and external processes
that are involved with the development, maintenance, and use of VS Code.
The VS Code project is built using the Electron framework. This framework
uses programming languages like HTML, Javascript, CSS, and TypeScript,
and it builds the installers for different operating systems. The VS Code
website then distributes the installers for each of the three operating systems.
VS Code website also provides documentation (Docs), updates on new
releases (Updates), VS Code Community Discussion (Blog), documentation
related to APIs (API), and a list of extensions available (Extensions). The use
of extensions can also help personalize the VS Code editor, for example,
choosing your own font type and size for the editor.
GitHub provides a cloud-based Git repository that provides software
development and version control services. VS Code’s code and issues/bugs
are managed and tracked by developers at GitHub, where they are solved
through contributions made by the community. The wiki contains information
such as project structure, how one can contribute to the code, and links to
various resources.
Next in the context diagram are the main stakeholders. Microsoft developed
the VS Code. Developers contribute to adding new features or fixing bugs
identified by the community. Atom, Vim, Emacs, and Sublime Text are some
of the editors identified as the competitors, as these are also lightweight text
editors used to develop applications. We do not consider IDEs like Visual
Studio, Pycharm, or IntelliJ as competitors, as these are more complex than
code editors.VS Code: Development view
The development or implementation view illustrates a software system from a
programmer’s perspective and is about software management. In this section,
we will look at the architecture and software development process, how the
code is structured, and how design and testing are performed.
VS Code has a layered and modular core (folder location at github: These can
be extended while using extensions. Extensions run in a separate process
called the extension host and are implemented by utilizing the extension API.
Built-in extensions are available in the extensions folder. Six core layers work
together to make VS Code a powerful editor. These layers are shown in
FigureFigure VS Code Module Diagram
Let us now understand the purpose of these layers:
This folder has user interface building blocks and general utilities, which any
other layer can use. This common environment approach provides, among
others, the structure to handle errors, process events, and do other web-related
things. In the common environment, the code ranges widely, from simple
functions to reduce code duplication, such as returning a hash value for anobject, to complex code that handles asynchronous processes. It also has
other functionalities, such as:
Reading the configuration files,
Handling the checksum for encryption,
Character encoding and decoding,
Operating system functionalities for directory and file manipulation, and
Network handling to interact with the web.
This layer defines service injection support and the base services for VS Code
that are shared across layers, and it excludes editor or workbench-specific
code or services. Most of the services around which the VS Code project is
organized are defined in the platform layer. The platform layer builds upon
the base layer, creates instances, and registers services for almost everything.
Extensions are all instantiated and registered through the platform layer. The
workbench layer is built upon the platform layer, which initializes much more
details, like CSS, that are not handled by the platform.
By now, we know that VS Code has a high-productivity code editor, which
gives the power of an IDE and the efficiency of a text editor. Now, let us look
at how this is possible at all! The power behind VS Code editor is Monaco
editor. Monaco started as a project at Microsoft’s Switzerland lab, which was
part of a plan to build online development tools. It was built using TypeScript
and launched in 2013. The first job of Monaco editor was as Azure’s website
editing tool, and it was also used as the editor for Office 365’s extension
development site. The editor layer handles everything from syntaxhighlighting for different languages to user input, like copying, pasting, and
selecting text. Services defined in the editor layer can be used by the
controllers to fetch certain data. One of these services is TextMate, which
interprets grammar files for text highlighting. The final part of the editor layer
is contributions. Contributions extend functionalities like hiding and unhiding
(blocking) comments, code indentation, and the usage of links.
It contains the Monaco editor and code notebooks. It also provides the
framework for panels like the Explorer, Status Bar, or Menu Bar. It leverages
the Electron framework to implement the VS Code desktop application and
browser APIs for VS Code for the web. The actual GUI of the workbench is
implemented using the electron-browser environment. When the main
component fires up the workbench, the shell component is called first. The
shell component has five components that constitute the actual workbench:
It handles the workbench in case of a crash.
It saves the settings of the workbench.
It handles the different keybindings that can be used in the workbench.
It handles the different extensions installed in the workbench.
It handles all sorts of actions that can be done in the workbench, such as
zooming in/out, switching from the window, and opening a new window.
It puts Electron main file, shared process, and the CLI together and forms the
entry point to the desktop app.
This forms the entry point to the server app for remote development.Extensions use the extension API and run in a separate process called the
extension host. Inside each layer, VS Code is organized by the target runtime
environment to ensure that only the runtime-specific APIs are used. The VS
Code project has the following target environments:
Source code that needs only basic JavaScript APIs and runs in all the other
target environments
Source code that requires the browser APIs
Source code that requires Nodejs APIs
Source code that requires the Electron renderer-process APIs
Source code that requires the Electron main-process APIs
There are advantages to such a layered approach. It becomes easy to inject a
service into VS Code.Standardization
VS Code has a large, vibrant community of developers that helps find and
resolve software bugs. Without following a standard process for coding
and testing, it would become a mess to manage the code base. In this
section, we will briefly see how a contributor can suggest new features,
submit bug details, build extensions, comment on new ideas, or submit
pull requests.
But before you can proceed as a contributor, you need to understand the
standard very well. VS Code has a wiki where developers can find
information about the code base and instructions on how to work with the
source code. A detailed explanation of how you can contribute and coding
guidelines are listed on the wiki. It defines how code should be written to
keep every file readable and maintainable.
Visual Studio Code uses tools, called linters, to enforce the coding
guidelines. These tools have configuration files and are set up in the Git
root of VS Code. By installing these linters as extensions in Visual Studio
Code, developers get notified by visualized errors and other kind-of
messages in the editor.
Visual Studio Code is tested by using the JavaScript testing framework
Mocha. A smoke test is performed before each release. This smoke test is
carried out to ensure that all major functionalities work as intended. VS
Code uses Travis CI and Appveyor for continuous integration on GitHub.
Travis CI is used for testing Linux and Mac OS builds. whereas AppVeyor
runs the build test on Windows.Technical Debt
Technical debt, also known as design debt or code debt in the software
engineering world, is a concept that shows and reflects the extra
development work that is a result of software developers choosing limited
or easy development work to address an issue instead of using a better
approach that would take longer time and possibly delay the release.
Technical debt can also arise from implementing poor programming
syntaxes, leading to poor code readability and difficulty in maintaining
code later. The term ‘technical debt’ was coined by software developer
Ward Cunningham, one of the 17 Agile Manifesto authors who created the
first wiki. He first used the technical debt metaphor to explain the non￾technical stakeholders at WyCash why they should invest in resources for
code refactoring to improve the existing code and add new features.
VS Code has multiple extensions available for the users to catch poor
code, and manage and reduce technical debt. These extensions can be
installed on demand. Some extensions that help in achieving better and
efficient code are Stepsize, TODO Highlight, SonarLint, and Code
Runner. A linter (or simple Lint) derives its name from a Unix utility
originally written to manage C language source code, and it is a static
code analysis tool. Linters highlight programming errors, bugs, coding
standard errors, and possible construct errors. In the linters, the rules for
naming conventions, type casting, and code styles are written to ensure
that the contributors do not increase technical debt. If a developer pushing
the code to VS Code GitHub, does not install linters, then they get notified
by the pre-commit checks for the same. If these pre-commit checks fail,some technical debt must be fixed before being able to commit and push
the desired contribution.VS Code: Functional view
The functional view of VS Code defines the architectural elements that
add to the functionalities. It talks about what VS Code can and can’t do. In
this section, we will look at the key functionalities and the external
interfaces.Functionalities
The functionalities are listed in the following table:
table:
table: table: table: table: table: table: table: table: table: table: table:
table: table: table: table: table: table: table: table: table: table: table:
table: table: table: table: table: table: table: table: table: table: table:
table: table:
table: table: table: table: table: table: table: table: table: table: table:
table: table:
table: table: table: table: table: table:
table: table: table: table: table: table: table: table: table: table: table:
table: table: table:
Table List of core functions of Visual Studio CodeExternal Interfaces
There are several external interfaces to which VS Code connects. Listed
here are just a few of them:
them:
them: them: them: them: them: them: them: them: them: them: them:
them: them: them: them: them: them: them:
them: them: them: them: them: them: them: them: them: them: them:
them: them: them:
them: them: them: them: them: them: them: them:
them: them: them: them: them: them: them: them: them: them: them:
them: them: them: them: them:
them: them: them: them: them: them: them: them: them: them: them:
Table List of external interfacesPerformance and Scalability
The source code for any software can get much larger and more complex.
Code editors’ performance and scalability have become very important
considerations for the development team. Performance is an indication of
the responsiveness of a system to execute any action within a given time
interval, while scalability is the ability of a system either to handle
increases in load without impact on performance or for to increase the
available resources. Let us look at a few factors considered while
choosing VS Code over other editors.Desired quality
The desired quality of Visual Studio Code is to be a lightweight code
editor while supporting multiple programming languages. Language
support will include debugging, implementation, and displaying results
regardless of the type of application.Applicability
It is recommended to use a processor of 1.6GHz or faster and at least 1
GB of RAM. Though the performance of Visual Studio Code itself is
tested and known, there are elements like extensions, whose performance
is unknown. This is so because the extensions available on the
marketplace are developed by third-party developers and they do not
necessarily test on various platforms and different conditions.Concerns
One of the biggest concerns for Visual Studio Code is the response time. It
is important that users do not have to wait long to open files, since this
reduces the time they can spend on productive tasks like software
development. This response time can be combined with the peak load
behavior when large files are opened. This causes third-party behavior
concerns since the whole file needs to be loaded at once. To reduce these
concerns, Visual Studio Code tries to tackle the predictability concern by
providing stable releases every month.Tactics
Tactics in Visual Studio Code refer to a set of strategies or techniques that
can be used to improve productivity and efficiency while working with the
code editor. Visual Studio Code tries to optimize processing is by
spending an entire week after a release to test and optimize the
implementation. Some parts of the code may be rushed to ship with the
release. Since Visual Studio Code depends on certain frameworks such as
IntelliSense, which can make large files difficult to handle. In such cases,
prioritization of code becomes important. Modules are divided into
different layers, base and common, to minimize the use of shared
resources. Visual Studio Code uses asynchronous processing in the form
of a worker. Workers can be used to run desired processes in the
background, which do not affect the performance of the current page of
Visual Studio Code. Tactics, along with various extensions and
customization options available in Visual Studio Code, can significantly
enhance your coding experience and productivity.VS Code vs Visual Studio
Visual Studio Code and Visual Studio are Microsoft-made products with
similar-sounding names, but that is where the similarity ends. They have
different features and uses. We have already seen that Visual Studio is a
full-fledged Integrated Development Environment with many features that
are loved by millions of developers worldwide. But VS Code is proving to
be a tough competitor to Visual Studio. Let us get into the details to
understand when to use VS Code and when to use Visual Studio.
Visual Studio helps develop desktop applications, web applications, web
services, and mobile applications with the help of Microsoft’s software
development platform, that is, Windows API, Windows Presentation
Foundation, Windows Forms, Microsoft Silverlight, and Windows Store.
They help produce and manage the code. VS Code is used to write, edit,
and debug the code in a single editor, without requiring any web support.
Everything that is required is built-in.
To develop programs using Visual Studio, developers do not need to
install any special software. VS Code is very powerful, but you need to
know the right tools to be installed before you realize their benefits.
Looking at the license cost, VS Code wins hands down. VS Code is free,
while Visual Code can cost you around $45 per month. You can refer to
the Visual Studio website for detailed pricing.
Visual Studio is available for Windows and macOS but not for Linux
platforms, whereas VS Code is available for all three platforms.Let us look at a few situations where Visual Studio can be used:
Since Visual Studio is functionally feature-rich, developers do not need to
install extensions or plugins. So, when you do not want to keep looking
for the right plugin, this is your choice of IDE.
Visual Studio provides the right collaboration platform where the entire
team can come together and debug the code; collaboration is super
smooth.
For heavy-duty code analysis, Visual Studio has no match. It has
incredible options for debugging and performance profiling.
Game development, Augmented Reality / Virtual Reality industries prefer
Visual Studio because they can work effortlessly to build cross-platform
applications. UNITY, a multi-platform environment, is integrated with
Visual Studio.
Now, let us look at a few situations where Visual Studio Code should be
preferred:
VS Code is a lightweight application that doesn’t require a lot of
computing power or hard disk space.
VS Code works faster as compared to Visual Studio.The code generated by VS Code is incredibly flexible and can be moved
to another platform easily.
Visual Studio Code is the number #1 choice for web development.Conclusion
New technologies are emerging every day, and new frameworks are
developed to use these technologies efficiently and effectively for our
work. With the focus of software developers in today’s times, and more so
with cloud computing booming, the shift has focused on developing
applications faster and more securely. It is a sure thing to learn this new
framework thoroughly to make the best of it; this is where VS Code scores
over other code editors.
This chapter introduced readers to the open-source project Visual Studio
code and helped them understand its architecture. We discussed why VS
Code is programmers’ favorite choice of tool for developing different
types of applications. We looked at the different layers of VS Code, which
makes it powerful and, at the same time, retains its lightweight nature. We
also looked at VS Code from different perspectives like context view,
development view, performance and scalability, and technical debt.
Another thing we can say for sure is that as new frameworks are
developed in the future, these will be made available to VS Code using
extensions. This would bring into play a great variety of code
effectiveness and help programmers, testers, and data administrators–
experienced and newbies–to write better and more effective code faster.
The community drives visual Studio Code development, prioritization of
features comes from issue tracking, and a feature is implemented and
optimized by the internal development team every week.
In the next chapter, we will see how to install VS Code and Python
extension and set up the path so that we are ready to code our applications.Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the
Authors:
https://discord.bpbonline.comChapter 2
Setting up the Environment
I will prepare and someday my chance will come.
— Abraham LincolnIntroduction
The first chapter aimed to introduce you to the VS Code, and this chapter
is about getting started. You must be excited to do the first program in
Python on VS Code. That will also help us understand different concepts
well. This chapter will use simple programming concepts to revise basic
Python programs and VS Code features like task running, editing the
default settings, getting to know keyboard shortcuts, and running a Python
program. The first thing we must do is set up a working development
environment. We will start with Python installation and VS Code
installation, and then we will set up the Python environment. The second
part of the chapter is about understanding the what and how of the global
and virtual environment. You must be excited to build and debug our first
Python program. Let us get started!Structure
In this chapter, we will discuss the following topics:
Setting up a working development environment
Installing Python extension
Project Work: Design a Simple Battleship Game
Setting up and configuring the editor
Keyboard argumentsObjectives
The objective of this chapter is to introduce simple programming concepts
to revise basic Python programs, but before that, we need to familiarize
ourselves with the VS Code features. You will look at tasks like
debugging, task running, and version control, to name a few. We will
demonstrate the concepts with the help of programs.Setting up a working development environment
This section focuses on downloading and installing the VS Code, setting
up the VS Code environment, setting up the Python environment, and
writing our first program.Setting up a Python environment
First, the Python interpreter needs to be installed. We must connect to
python.org and select the correct installer based on your operating system.
Python is also available in the Microsoft Store on Windows devices. If you
are on Linux, you might have Python3. You can verify if Python is already
installed on your computer by typing python3 --version in a terminal. If it
gives an error, it means you need to install it.
Follow these steps to install the software:
Open your favorite browser, type download Python, and click on the first link
that appears on your search result – it should take you to Alternatively, you
can directly enter the following address in the browser:
Python interpreter is available for all the major platforms, including Refer to
the following figure:
Figure Screenshot from Python download web pageInstalling on Windows
You can directly click on Download Python 3.11.0 or navigate to the Python
Releases for Windows section and click the download link to get the latest
Python 3 release. As of today, the latest version is Python 3.11.0. Select the
Python installer executable for 32-bit or 64-bit and click on download. When
the download is finished, move to the next step.
Run the downloaded installer file by double-clicking on it. A dialog box
similar to the one shown in Figure 2.2 will appear:
Figure Python interpreter installer
There are a few things one needs to know before clicking on Install Now to
move ahead:Install Now shows where Python will be installed and run from.
The Customize installation option customizes the location and additional
installation features. We can also manage this later using the pip command.
The Install launcher for all users (recommended) box is checked by default on
the dialog box. It can be unchecked to restrict other users from launching
Python.
Add Python.exe to PATH (unchecked by default). Python allows the
installation of multiple versions on a single machine, and different projects
can connect to different versions of Python. This is possible by creating
multiple virtual environments. We also create a global environment by adding
Python.exe to PATH (under environment variables). If you are installing for
the first time, then checking this option is recommended.
Make the customization based on your needs and then click Install Wait for
the installation to complete. Refer to the following figure:Figure Successful installation
Now you have Python installed on your machine. We are ready to code
Python!
Installing on macOS
Older macOS versions (up until macOS Catalina) came with Python 2 (an old
and phased-out version). Python needs to be installed on new Mac machines.
Installing Python from www.python.org (the official website) is the most
reliable method.
You can navigate to the Python Releases for macOS section and click the
download link for the latest Python 3 release. As of today, the latest version is
Python 3.11.0. Click on download. When the download is finished, move to
the next step.Run the macOS installer by double-clicking the file that was downloaded.
You must click the Continue button a few times before agreeing to the
software license agreement presented on the screen. Accept the agreement,
and a window will pop up with details like install destination and how much
space it will take, among other options. You can continue with the default
location and click Install to proceed. The installer will finish copying files;
you know this when you see the Close option. Click on Close to close the
installer window. Congratulations! Python 3 is now installed on your macOS
computer.
You can refer to the online tutorial to install Python interpreters on
Linux/UNIX machines.Setting up VS Code Environment
Let us shift our focus to installing and setting up VS Code environments.
First, we will see how to download the VS Code and install it. Let us go step
by step:
Open your favorite browser and type download visual studio code. The first
link you will see is
Go to the link and choose the installer based on the operating system, as
discussed in Chapter 1, Introduction to VS VS Code is available for and Click
on download based on the OS and the machine type. Refer to the following
figure:
Figure 2.4: Screenshot from https://code.visualstudio.com/download
After the download is complete, install it like any other application. It is
lightweight; the file size is less than 100 MB for Windows and Linux
machines, and the Mac file could be about 200 MB. It is lightning fast to
install. Refer to the following figure:Figure 2.5: Installing on Windows 10
VS Code is now installed on your computer. Now you are ready to program.
If you are planning to program in HTML, then you are ready to go, but we
need to install a Python extension to develop Python applications.Installing Python extension
We will install the Python extension, which is a must to run Python programs
from VS Code. The Python extension is helpful; it is what converts the
lightweight VS Code editor into a powerful editor. It not only supports the
Python language (for all actively supported versions of the language: >=3.7)
but also includes features like IntelliSense (Pylance), linting, debugging, code
navigation, code formatting, refactoring, variable explorer, and test explorer.
We discussed these features in Chapter 1, Introduction to Visual Studio so if
you missed it and are wondering what they means, you can revisit the
previous chapter.
You can run a Python file from VS Code by taking the Python interpreter’s
help and ignoring the VS Code’s capabilities. Open your VS Code editor and
select New File from the File menu. Type the following code in the editor:
print("Hello from VS Code")
Now, save this file to your desktop as Python files have the .py extension, so
save it in this format.
Next, click on the Terminal menu in VS Code, and you will see the Terminal
window open at the bottom of your screen, similar to what you see in FigureFigure VS Code screen with Python code and Terminal open
In the terminal window, browse to desktop since our program is saved there.
Then, type the following:
py myfile1.py
You will see the following output printed on the screen:
Hello from VS Code
This is shown in FigureFigure 2.7: Screenshot of Terminal running Python program
In this example, we used the VS Code as a simple editor to write code and
execute it on Terminal by calling the Python interpreter. This can be achieved
using Notepad editor as well. In the next few sections, we will see how to
install the Python extension on VS Code and use its features to enhance our
code efficiency.
Go to the extension tab (on the left side of the screen) and search for the
Python extension. The first result, as shown in Figure is what we need to
install. Click on the Install option that would be displayed next to the
extension. As soon as you do that, the Python extension gets installed.Figure 2.8: Python extension in search result
The Python extension automatically installs the Pylance and Jupyter
extensions to simplify programming and improve the coding experience.
Note: Pylance is an optional dependency, which means the Python extension
will function even it is uninstalled later.Code Runner extension
Chapter 3, Top Extensions in VS is dedicated to installing extensions, but we
will install two important extensions before we run any program: Code
Runner extension and Pylint extension. Code Runner is necessary to avoid
going to the terminal again and again to run a Python program. It is designed
to support all the most widely used programming languages, like Javascript,
HTML, C, C++, Java, and Python; these are among the 25 languages that it
supports. Additional languages can also be supported. Search for Code
Runner in the extension search box and install it. It had almost 16 million
installations at the time of writing this chapter. Figure 2.9 shows the
CodeRunner extension preview as shown in VS Code:
Figure CodeRunner Extension installation
Successful installation of Code Runner will make a play button ( ) appear in
the top-right corner of your VS Code editor. This button can be used to run
the code.
The second important extension is Pylint (preview shown in Figure Pylint is a
linting tool for Python that helps developers identify and fix code issues
quickly and easily. The Pylint extension in VS Code provides an excellent
linting experience for Python in VS Code, enabling you to quickly seeproblems with your code and take corrective action. The extension provides
enhanced linting features, such as checking code for PEP8 compliance and
quickly identifying issues. It also includes support for running Pylint from the
command line. With this extension, you can efficiently write better Python
code, save time, and get more productive.
Figure 2.10: Pylint Extension Preview
Linting tools are programming tools that help ensure that a program’s code
adheres to coding standards and is correctly formatted. It can detect and flag
potential programming errors, such as undefined variables, inconsistent
formatting, errors in logic, and unclosed loops. Linting tools are often used to
detect and eliminate programming errors before the code is compiled and run.Project Work: Design a Simple Battleship Game
Let us look at the following problem statement and solve using Python in VS
Code:
Design a simple battleship Let us develop a simple strategic guessing game
between humans and computers. The program creates a 5*5 board, and the
computer conceals its battleship in a row and column (generated using a
random number). Human users call shots by guessing where the computer has
concealed its battleship. If the guess is right, the computer’s fleet is destroyed,
and the user wins. Figure 2.11 shows the sample output:
Figure 2.11: Sample outputRandom module
We need to use the random module to develop this simple battleship
application. This is a built-in module that can help create random numbers.
Some of its popular methods are listed in Table 2.1:
2.1:
2.1: 2.1: 2.1: 2.1: 2.1:
2.1: 2.1: 2.1: 2.1: 2.1: 2.1: 2.1: 2.1:
2.1: 2.1: 2.1: 2.1: 2.1: 2.1: 2.1: 2.1:
2.1: 2.1: 2.1: 2.1: 2.1: 2.1: 2.1: 2.1:
2.1: 2.1: 2.1: 2.1: 2.1: 2.1: 2.1: 2.1: 2.1: 2.1: 2.1:
2.1: 2.1: 2.1: 2.1: 2.1: 2.1: 2.1: 2.1: 2.1:
Table List of commonly used methods of random module
Let us look at the complete code:
import random
battle_pattern = []
for i in range(5):
battle_pattern.append(['O '] * 5)def display(pattern):
for p in pattern:
print(" ".join(p))
print("Battleship Challenge - GAME ON!")
display(battle_pattern)
def get_random_row(pattern):
return random.randint(0, len(pattern) - 1)
def get_random_col(pattern):
return random.randint(0, len(pattern[0]) - 1)
ship_row = get_random_row(battle_pattern)
ship_col = get_random_col(battle_pattern)
print(f"hint: row={ship_row}, col={ship_col}")
for option in range(4):
input_row = int(input("Enter Guess Row (Starts with 0):"))input_col = int(input("Enter Guess Col (Starts with 0):"))
if input_row == ship_row and input_col == ship_col:
print("You Win! You sunk my battleship!")
break
else:
if option == 3:
battle_pattern[input_row][input_col] = "X "
display(battle_pattern)
print("Sorry Player... Game Over!")
print("\nShip is here: [" + str(ship_row) + "]["+ str(ship_col) + "]")
else:
if (input_row < 0 or input_row > 4) or (input_col <0 or input_col > 4):
print("Where did you fire ? Over the ocean.")
elif (battle_pattern[input_row][input_col] == "X"):print("You have already got that wrong.")
else:
print("You totally missed my battleship!")
battle_pattern[input_row][input_col] = "X "
print("Attempt : ",option + 1)
display(battle_pattern)
Here is how to execute the preceding program in VS Code editor:
Click on file and then on new file.
Type a file name without any spaces and give it the py extension, for
example,
Now, hit enter. It will open the file browser to select a location to save your
file. Browse to a folder location and save the file there.
New code editor will open. Type the preceding program in the editor. Be
careful about the indentation. Indentation is critical to writing Python
programs.
Now, click on the Play button to begin the execution of the program. Output
can be seen on the terminal screen below the editor. Snapshot of the program
code is shown in Figure 2.12:Figure 2.12: Screenshot of the code and the highlighted play button
The preceding code generates multiple O-shaped battleship patterns, as
shown in
FigureFigure Screenshot of the output below the screen
Autocomplete extension helps improve the coding speed by suggesting the
complete code based on the characters entered and allowing the programmer
to select the suggested code. IntelliSense Python extension supports code
completion based on the current interpreter version. Linting extension
analyses the completed Python code and looks for potential errors. This
makes navigation in the lines of code easy and helps correct the different
problems. We have successfully executed our first program. Let us
understand a few components of Python that we have used in this program.
Apart from using the random module, we have also done the following:
Using a List battle_board to store the locations
Using for loop and if-elif-else to build the logic
Declaring and using user-defined functions: get_random_row and
get_random_col
Conditional statements for decision-making (if – elif - else):
Let us say the code needs to greet the user of your application based on the
time of the day. For example, good morning if it’s morning (after midnight to
before noon) and good evening from noon till midnight. Good Evening and
Good Morning, both options are present in the code, but based on a certain
condition, the code needs to print only one of them at a given time. That is
possible using conditional statements.If-blocks are logic statements used to control the flow of a program. They are
used to test conditions and execute different code depending on the result of
the test. An if-block consists of an if statement, followed by one or more
optional elif (else if) statements and an optional else statement.
Generally, the syntax for an if-block in Python is as follows:
if condition1:
statement1
elif condition2:
statement2
...
else:
statementN
The if statement contains a condition (condition1). If the condition evaluates
to True, the associated statement (statement1) is executed.
If the condition evaluates to False, the statement is not executed, and the elif
or else statement is tested. If the condition in the elif statement evaluates to
True, the associated statement (statement2) is executed. This process is
repeated until a condition is found to be True or the else statement is reached.The else statement is optional and is used to execute code when no other
condition evaluates to True. If no conditions are found to be True, the code in
the else block is executed.
An if-block can contain any valid Python statements, including loops,
function calls, and variable assignments. It is also possible to nest if-blocks,
enabling more complex logic.
To check a single condition, only the if statement is used; elif and else are
used for multiple conditions.
Let us look at an example to find the highest value among the three numbers.
The algorithm is explained with the comments added within the code:
#Finding the highest value among 3 variables
a,b,c = 55,44,33
if a >= b:
if a >= c:
#A is either equal to or greater than all the given values
print("A variable is greatest!")
else:
#C is greater hence C is the highestprint("C variable is greatest!")
else:
#Means B is greater than A
if b >=c:
#B is highest
print("B variable is greatest!")
else:
#C is higher than C
print("C variable is greatest!")
print("Thank you for using our program")
In the preceding example, we used Nested-IF condition. Nested if statements
are if statements that are the target of another if statement. They are useful
when you want to check multiple conditions at the same time. Nested if
conditions are a frequently used piece of code where the evaluation of one
condition is necessary before a decision can be made on another condition. In
other words, nested if conditions are used when a certain condition needs to
be met before a certain action happens.
Here is how you can handle nested if conditions step-by-step:First, create an If-Else statement and determine the condition you will be
evaluating.
Next, inside the body of the If-Else statement, include an additional If-Else
statement. This nested If-Else statement should contain a second condition
you need to evaluate, which depends on the result of the first If-Else
statement.
Then, add the code that will be executed if both Conditions 1 and 2 are met.
Next, include the necessary Else statements for Condition 1 and Condition 2,
which will be executed if either Condition 1 or Condition 2 is not met.
Finally, end the nested If-Else statement, and end the containing code block
with an end statement.
After these steps, the nested if condition should be fully functional and set up
correctly, and the block of code should execute correctly.
Iterating using Loop
There would be a situation while developing a logic where there is a
requirement of iterating over a sequence of code multiple times. This is called
a loop in programming terminology and Python, and it is achieved using
keywords WHILE and The while loop statement is when we do not know
how many times the statements need to be repeated but we have a condition
until which we need to execute the same block of code. A while state can
sometimes have an else clause, but that is not mandatory.When the number of times statements need to be repeated is known, we
prefer the for..in statement. The range() function can be used to generate
sequence to repeat. Range(5) will generate values: 0,1,2,3,4 (0 is the starting
value when not mentioned, the default increment value is 1, and ending value
always excludes the given number).
Both For and While have defined ways to stop the iteration when work is
done, but at times, we have to stop the loop before that assigned value. This is
where the break statement comes into the picture. When the break statement
is encountered, the loop stops execution even if the while loop condition has
not become false or the for loop has not yet completed iteration over the
sequences.
The continue statement is used where there is a need to inform Python to skip
executing the rest of the statements in the current loop and go back to the
beginning of the loop.
The program will exit when it encounters the exit function without
continuing.
Let us practice a program that uses the while loop to check the size of the
entered text:
while True:
#Directly using True instead of a conditional statement
# will make it an infinite running loops= input('Enter something: ')
if s.lower()=='quit':
#lower() will convert s content into lowercase break
break
print("Length of the given text is ", len(s))
print("Goodbye")
The preceding program will continue to print the size of the text entered until
it encounters the quit statement. The lower function will convert the input
variable into a small case irrespective of what the user entered.
User-Defined Functions (UDFs)
Functions are written once but are used in multiple places, so we call them
reusable pieces of programs. First, the function must be defined and named to
a block of statements. The def keyword is placed before the function name,
followed by an identifier name. Identifier is followed by a pair of parentheses
that may enclose some variables’ names (optional), and it ends with a colon.
Next comes the block of statements that are part of this function. Defining
alone does not make a function work; we need to call the function by name to
run that block. We have already seen the workings of many built-in functions,
such as print() and In the battleship program, we created theget_random_row() and get_random_col() user-defined functions to get values
from the user. Let us see an example:
#Define the function
def greet(name):
print("Hello, " + name + ". Have a good day!")
#calling the function
greet("Sachin Tendulkar")
The preceding function is used to greet a person. This function greets the
person whose name is passed in as parameter to the greet() function.
Using list in Python
A list is a data structure that holds an ordered collection of items, that is, you
can store a sequence of items in a list. The values are separated (comma) and
enclosed within a pair of square braces Consider this example:
var1 = [5,10,15,20] #List
Some of the popular list methods are listed in the following table:
table:
table:table:
table:
table: table: table:
table: table: table:
table: table:
table: table: table:
table:
table:
table:
table:
Table 2.2: Important methods of List datastructure
Let us write a program and understand the list concepts:
months = [
'January', 'February','March',
'April','May','June',
'July','August','September',
'October','November','December']
endings = ['st', 'nd', 'rd'] + 17 * ['th'] + ['st', 'nd', 'rd'] + \
7 * ['th'] + ['st']
year = input("Enter Year: ")
month = int(input("Enter Month: "))
day = int(input("Enter the Day: "))
month_no = months[month - 1]
days = str(day) + endings[day - 1]
print("The date you have entered is ", days, " ", month_no, " ", year)
The preceding program reads the date in year, month and day format then
returns it in a combined format, with the month number converted to words.
Figure 2.14: Output of List ProgramSince we are not covering the basic programming concepts in detail in this
book, readers are encouraged to refer to the basic programming textbook to
understand these concepts. We recommend Learn and Practice Python by
Swapnil but you can choose any other as well.Setting and configuring the editor
VS Code can be customized to the core. It allows almost every component
of the user interface and functional behavior to be customized to the
programmer’s preferences through its various setting options. There are
two important settings that one notices when the workspace is opened:
User Settings that care for users’ preferences are applied globally to any
instance of VS Code the same user opens.
Workspace Settings specific to the particular workspace are stored inside
the workspace, which are applied when the workspace is opened.
Let us see how one can customize these settings.User setting
User settings are customized by editing the settings editor settings. Here are
the steps you can follow to open the settings editor:
Windows/Linux: Goto File | Preferences | Settings
macOS: Goto Code | Preferences | Settings
A screen similar to Figure 2.15 will open:
Figure 2.15: Screenshot of User Settings
One can also use the keyboard shortcut to open the settings editor by typing:
in Windows and Command + , (comma) in Mac.In the search bar, one can discover the settings they want. While searching in
the bar, one will notice that it will not only show and highlight the settings
matching the criteria but also apply a filter to remove those not matching.
This makes the search quick and easy to use.
All the editor-related settings, such as settings groups, search, and filtering
behave the same for user and workspace settings. For a given project
workspace editor-related settings are given preference over user settings. Still,
some application-related settings, such as updates and security, cannot be
overridden by workspace settings. For this reason, one will not even be able
to access these settings in workspace settings but are very much available in
the user settings. One can see the list of settings available by clicking on the
respective tabs for user and workspace, as shown in Figure
Figure 2.16 shows all the options for font search results. When one changes
here, it is applied to the VS Code immediately. One can also see all the
settings that have been modified as they are indicated with a blue color box.Figure 2.16: Search result for Font in User Settings
Clicking on the gear icon will open a context menu with the option to reset
the setting to its default value. This will undo all the changes made to the
settings. This can also be used to copy the setting ID or JSON name-value
pair.
Figure Gear icon presents reset setting to default and other optionsSettings generally have three options using which edits can be made. Settings
can be edited by selecting given values from a checkbox or a dropdown or
even entering the value using an input to change to the desired settings.
Related settings are added together in groups and presented in a tree view so
that it is easy to find and navigate to. Groups that show popular
customizations are generally at the top. To the right of the search bar, one can
see a funnel and filter buttons. Users can add several filters to the search bar
to manage settings easier, as shown in Figure
Figure 2.18: Different filter options added to search bar
The @modified filter is added in the Search bar shows the settings that have
been configured. If the editor is not behaving as expected and the developer
wants to check if this is because of customization or wrong configuration, this
filter is useful.
The following is the list of other VS Code filters:
Edit settings specific to any extension
Edit settings specific to a features subgroup, for example, File explorerFind a setting based on the setting ID, for example,
@id:workbench.activityBar.visible
Apply a language filter. Figure 2.19 shows the Filters in the Search bar:Figure 2.19: Filters included in the search bar
VS Code extensions can also be edited with custom settings. These settings
are visible under an extensions section. One can also review an extension’s
settings. This can be done from the extensions view by selecting the
extension and clicking on reviewing the feature contributions tab.
So far, we are trying to edit the settings in UI, but there is a settings file where
we can edit the values directly. The file is called To open the settings.json file,
go to Preferences: Open Settings (JSON) command in the Command Palette
(Ctrl+Shift+P). This is shown in Figure
Figure How to open JSON Settings in the Command Palette (Ctrl+Shift+P)
One can review and edit this file. Figure 2.21 shows a sample settings.json
file:Figure Sample Settings (JSON) file
Once the file is open in an editor, settings can be written in the JSON format.
The JSON format has setting ID and its corresponding value. For example,
Figure 2.20 shows the applied theme in One can edit/delete/add a new ID and
corresponding value to the settings. VS Code can return to the default settings
when all the content between the two curly braces {} is deleted and the file is
saved. Like code editor, the settings.json file also has full IntelliSense with
smart completions settings. If any error creeps in due to an incorrect JSON
style, the portion of the code also gets highlighted, just like a Python code.
Some settings, such as Workbench: Color can only be edited in In Figure
colorCustomization has been set to #4000ff, making line numbers appear in
blue (hex equivalent color code).Figure 2.22: colorCustomizations in Settings (JSON) file
Earlier, we discussed that Settings will open the settings editor UI, but those
who prefer to always work directly with the settings.json file can set the
workbench.settings.editor: json option so that Preferences| Settings and
keybinding Ctrl+ will always take you to the settings.json file.
You can look for user settings file here:
On Windows platform: %APPDATA%\Code\User\settings.json
On macOS platform: $HOME/Library/Application\
Support/Code/User/settings.json
On Linux platform: $HOME/.config/Code/User/settings.jsonWorkspace settings
Workspace settings, unlike user settings, are not global; they are specific to a
project. This allows settings to be shared across developers working on the
same project. Workspace settings are always designed to override user
settings. You can edit via the settings editor Workspace tab or open that tab
directly with the preferences: open Workspace Settings command.
Figure Workspace settings
Workspace Settings are stored in a settings.json file, just like user settings.
This can be edited directly via the Preferences: Open Workspace Settings
(JSON) command. If you are looking for the workspace settings file, you can
find it in the folder in your root location. When a workspace settingssettings.json file is added to the project or the source control, the settings for
the project are shared with all the users of that project.
We have been talking about workspace, but what is it? Workspace in VS
Code is usually just your project root folder. All the workspace settings and
configurations, like debugging and task configurations, are also stored at the
root itself, in the .vscode folder. It is possible to have more than one root
folder in a VS Code workspace through a feature called multi-root
workspaces.
Let us now turn our discussion toward language-specific editor settings.
There are two different ways to open language-specific editor settings and
customize them:
The first method is opening the settings editor, clicking the Filter button, and
selecting the language option to add a language filter based on the
programming languages.
The second available option is to directly type a language filter of the
@lang:languageId form into the search widget option.Figure 2.24: Opening language-specific settings
The language-specific settings will show only the configurable options for
that specific language. We will look at Python-specific settings in Chapter 3,
Top Extensions in VSSettings and security
Some settings allow specifying an executable VS Code that can run to
perform certain operations. The setting allows choosing the shell that the
integrated terminal would use. Understandably, for various security
reasons, such settings can be defined only in the user settings and not in
the workspace scope that multiple users can use. A few other settings are
not available in the workspace scope, like andKeyboard arguments
Intuitive keyboard shortcuts, easy customization, and community-contributed
keyboard shortcut mappings let you easily navigate your code. VS Code
provides rich, customized and easy-to-edit keyboard shortcuts. After
displaying the options, one can easily change, remove, and reset their
keybindings using the available actions. Displaying a list of keybindings is
also easy; it can be done using a search box on the top. The search box helps
find commands or keybindings and directly navigate to them. Those using VS
Code on Windows platform can open this editor by going straight to the menu
under Preferences| Keyboard (macOS users can do so by going to Keyboard
Keymap extensions are a great feature that will help the users of other editors
to start using VS Code editor quickly. Anyone who wants to see the list of
popular keymap extensions can go to Migrate Keyboard Shortcuts from...
This will bring up the list of popular keymap extensions. These extensions
modify the VS Code shortcuts to match those of other editors, so you do not
need to learn new keyboard shortcuts while switching to VS Code.Figure List of a few editors from which keyboard shortcut migration is
supported
A printable version of the keyboard shortcuts can be downloaded from
Keyboard Shortcut reference (Refer Figure It gives a condensed PDF
document generated specific to the platform you are using. This document
can be printed and stuck near your monitor for easy reference.
Figure Help|Keyboard Shortcut Reference: to get a condensed PDF list of
keyboard shortcutsConclusion
We are at the end of the chapter and have done a great job writing and
building our first Python program. Whenever we move to a new
environment, it always makes sense to spend some time trying to
understand the nuts and bolts of the environment; that was our goal for
this chapter. We have successfully installed Python and VS Code, set up
Python environment using Python extension, installed default extensions
along with it, and learned about editing settings. Spend some more time
working with settings, edit your font to your liking, and get the theme of
your choice so that you love working with the editor.
Now, it is time to move on to the next chapter. In the next chapter, we will
learn about more useful Python extensions and edit Python-related
settings.Chapter 3
Top Extensions in VS Code for Python
Technology is nothing. What’s important is that you have a faith in people,
that they’re
basically good and smart, and if you give them tools, they’ll do wonderful
things with them.
— Steve JobsIntroduction
Extensions to VS Code editor are invaluable. They help improve code
quality and speed up the development work too. We will look at some
general-purpose extensions that are must-haves. Two big areas where
Python programming is used are data science and web development. We
will also look at the popular extensions that apply to data scientists and
web developers. In this chapter, we will explain the functionality of
popular extensions and how to find them in the VS Code marketplace, and
we will install and manage these extensions. No doubt, these extensions
are what make VS Code the most popular IDE, so we added this chapter
to benefit all. Apart from that, we will discuss functions, modules, and
packages in Python. These concepts help us manage lengthy code easily
and efficiently.Structure
We are going to cover the following topics in this chapter:
Top VS Code extensions
Python-specific settings
Installing and using Python packages
Functions, modules, and packages in Python
Now, let us dive deep into these topics.Objectives
The objective of this chapter is to provide an overview of the top
extensions for Python programming in Visual Studio Code and explain
how to install and use these extensions. We will also talk about their
purpose and characteristics. Extensions add more functionality to VS
Code for Python, such as linting, debugging, and code formatting.
Additionally, many popular extensions provide IntelliSense, which
provides smarter code completion based on variable types, function
definitions, and imported modules. This makes it easier and faster to write
and understand code. We will also learn about functions, classes and
modules and look at the implementation of these concepts in Python.Top VS Code extensions
So, you have installed VS Code now and maybe even created your first
program if you have followed our chapters. There are a few extensions that
will simply increase the power of your VS Code. Using VS Code extensions,
you can add different language support (we did that in Chapter 2, Setting Up
the debuggers, and various other tools to make your development experience
better. By creating extensions, developers take advantage of VS Code’s rich
extensibility, which allows them to plug their extensions directly into the VS
Code UI, making it available to VS Code users. To start using the extensions,
take the following steps to download any extension:
Step 1: Browse for extensions
The first step is to find these extensions in the marketplace. One can easily
browse and install extensions from VS Code itself. Clicking on the
extension’s icon in the activity bar or by typing the extensions command will
bring up the extensions view, which looks like the icon shown in FigureFigure Extensions icon
You can filter the search results using the filter option available at the top-left
of the screen, as shown in FigureFigure Extension search result with filter option
A popular list of extensions can be seen in FigureFigure 3.3: Popular extensions list
Each result in the list will include a brief description of the extension, the
publisher of that extension, the total number of downloads, and the rating on
a 5-star scale. When the extension is selected, the extension’s details page is
displayed, where one can learn more.
Step 2: Search for an extension
One can search for an extension by typing the extension name in the search
box at the top of the extensions view. Clear the existing text if any and type in
the complete or part of the extension name you are looking for. So, if you
type Python, it will bring up a list of Python language extensions. Knowing
the extension ID can help if there are many extensions with similar names.
For example, wayou.vscode-todo-highlight is the ID for the TODO Highlight
extension. One can directly type the ID in the search box as well.
Step 3: Install the extension
To install the extension of your choice, click the install button. It will
transform into the manage gear button after the installation is complete. In
Figure the Python extension has a gearbox indicating that it is already
installed on the local machine, whereas the C/C++ option has the install
option, which means it has not been installed. Clicking the install button will
install the C/C++ extension to run C/C++ programs on VS Code.
Step 4: Manage extensionsIt is easy to manage the extensions in VS Code. VS Code allows the users to
install/enable/disable/update or uninstall extensions through the extensions
view, the command palette, or command-line switches. Commands have the
Extensions: as a prefix in the command palette.
How to list installed extensions
When a user launches VS Code, by default, the extensions view is presented
with the extensions that are currently installed and enabled, all recommended
extensions, and a collapsed view of the extensions disabled by the user.
How to uninstall an extension
Users can select the manage gear button of an extension and then choose the
uninstall option from the dropdown menu to uninstall an existing extension.
This action will also prompt the user to reload VS Code.
How to disable an extension
Uninstalling permanently removes the extension, but in case a user wants to
remove the extension temporarily, they can choose the disable option in the
gear button. The user has the option to disable an extension globally or for the
current workspace, as shown in Figure Disable extension will also prompt to
reload VS Code. There is also an option named disable all installed
extensions command available under more actions in the command palette
dropdown menu.Figure Disable option in the each extension
Enable an extension
All disabled extensions remain disabled until the users choose to enable them.
Users can re-enable the extensions with the enable or enable (workspace)
commands available in the dropdown menu. To enable all extensions, you can
choose the option from the command palette or from more actions which
provides a dropdown menu. This is the quickest way to enable all the
extensions.
Extension auto-update
VS Code constantly checks for extension updates and installs them
automatically if the auto-update option is checked. Users are asked to reload
VS Code if any extension has been updated. Some users prefer to update the
extensions manually, in which case they have to disable the auto-update
option with the disable auto-updating extensions command that sets the
extensions.autoUpdate setting to false. Auto-update is shown in FigureFigure Auto update option for extensions
Update an extension manually
Users can look for the extensions that have updates available by using the
show outdated extensions command that uses the outdated filter. Then, by
clicking the update button for the outdated extension, the update will be
installed. The update all extensions command can be used to update all your
outdated extensions at the same time.
Recommended extensions
Users also see a list of recommended extensions by default or can look for
recommended extensions by setting recommended filter active.
Recommendations can be based on the following:
Workspace Based on other users of the workspace
Other Based on recently opened files
Users can list, install, and uninstall extensions from the command line, which
helps in automation. One has to keep in mind that to find an extension, onehas to provide the full name, along with its for example,
Here is an example:
Setting the root path for an extension:
code --extensions-dir
Listing the already installed extensions:
code –list-extensions
To see the versions of already installed extensions use:
--list-extension
Show versions:
code --show-versions
Installs an extension:
code --install-extension ( | )
Uninstalls an extension:
code --uninstall-extension ( | )Enables proposed API features for extensions:
code --enable-proposed-api ()
Now we will move to the list of some of the important extensions that will
help in Python programming.Pylance
Pylance by Microsoft can massively enhance your productivity. Pylance is
a Python language server, offering enhancements to IntelliSense, syntax
highlighting, and a host of other features for an amazing development
experience for Python developers. IntelliSense is more like a generic name
for various code editing features that would include code completion,
parameter info, quick info, and member lists. IntelliSense features are also
known by names like code completion, content assist, and code hinting.
ntelliSense quickly shows the probable methods, class members, and
documentation you may want to use as you type. One can trigger
completions at any time with Ctrl+Space. Pylance enhances the help
provided by IntelliSense. Some of the features provided by Pylance are as
follows:
Docstrings
Signature help and type information
Parameter suggestions
Code completion
Auto-imports (add and remove import)
As-you-type reporting of code errors and warnings
Code outlineCode navigation
Type checking mode
Native multi-root workspace support
IntelliCode compatibility
Jupyter notebooks compatibility
Semantic highlighting
Let us move to see the top three most popular features in the next section.Auto-imports
The Pylance extension has a feature that automatically adds imports to the
top of the Python files whenever a reference to a dependency is made in
the environment. It does not install the dependency, but if it is already
installed and available in the Python environment, then it adds it. At the
same time, it removes the reference if it is no longer used in the program.
One can see a lightbulb icon with suggestions to add or remove imports
depending on the scenario.Semantic highlighting
Semantic highlighting highlights (that is, colors) classes, functions,
properties, and other Python object types to make them more readable.Type checking
There is a new concept called type hinting, which is the practice of specifying
expected data types for variables or functions or even for classes. Type
hinting is new to Python, and even though Python does not enforce it, most
programmers consider it as a best practice. Pylance helps developers to
understand if their code violates any documented type hints if it has a type￾checking setting enabled.
One has to make the required settings change to make this enabled. Figure 3.6
shows the steps to edit the settings:
Figure 3.6: Steps to edit the settings for Pylance extension
The following text can be added to settings.json to enable the type hinting:
{"python.analysis.typeCheckingMode": "basic"
}
Type-checking mode can take either basic or strict:
Basic: Checking basic datatype
Strict: Highest error severity, all type checking rules
It is recommended to have a basic setting at the moment.
Figure 3.7 shows the implementation. Look at the error message, it says the
Expression of the type is and it also refers to the Pylance extension.
Figure Type error when trying to assign an integer value to a string variableCode Runner
The second must-have extension based on our recommendation is Code
Runner. It runs the code instantaneously and supports multiple programming
languages. The view of Code Runner extension is shown in Figure
Figure Installing Code Runner extension
Code by default, is set to use its panel for showing the results of the Python
script. It is recommended to be set up in a way that will show the results of
the integrated terminal. Follow these steps to change the settings so that the
results can be displayed in the terminal:
Press ctrl+ or click on the gearbox located in the bottom-left corner of the
screen to open the settings panel.
To open the settings, type code runner terminal on the search bar.
You will now see an option, Code-runner: Run In
Tick the option to enable it, and you are done. This looks very much like the
option shown in FigureFigure Change the settings of Code Runner so that the results can be
displayed in the terminal
Let us run a program and see the output in the Terminal, as shown in FigureFigure Program running in the terminalIndent Rainbow
Indent Rainbow is a simple yet powerful extension that colorizes each tab
space to make indentation more visible and readable for the programmers.
The image of the extension is shown in Figure
Figure Indent Rainbow extension
Indent Rainbow helps make code more readable by displaying different
indentation levels with different colors. It helps you spot indentation errors
and visualize the structure of the code, as shown in Figure
Figure Program running in the terminalBy default, Indent Rainbow uses VIBGYOR color, hence the name Rainbow;
but we can always change the default settings by editing the User The
following code is an example that shows how you can edit the Indent
Rainbow color settings:
"indentRainbow.colors": [
"rgba(245, 40, 145,0.1)",
"rgba(245, 40, 145,0.3)",
"rgba(245, 40, 145,0.6)",
"rgba(245, 40, 145,0.8)",
"rgba(245, 40, 145,0.2)"
]
You can pick your color from here:
https://rgbacolorpicker.com/Path Intellisense
Path Intellisense is a Visual Studio Code extension that autocompletes
filenames for you when you are typing in file paths. Figure 3.13 shows the
view of the extension. It helps you save time and increase productivity by
providing you with the ability to quickly find, open, and insert the right files
in your project. It also provides an easy way to quickly add new files to your
project.
Figure Path Intellisense extension
Path Intellisense is the VS Code plugin that autocompletes filenames. Figure
3.14 shows the suggestions made by Path Intellisense when we select a
folder:Figure Suggestions are shown by Path Intellisense extension
VS Code supports both relative and absolute paths. The absolute path is the
complete path, including the drive name. The relative path takes the path
from the location mentioned in the terminal. Here is an example of how a
terminal might look:
C:\Users\hpTabnine AI Autocomplete
Tabnine AI Autocomplete in VSCode is a powerful code autocompletion tool
powered by artificial intelligence. This extension uses machine learning
algorithms to understand the context in which the code is used and suggest
the best code completion options. It integrates seamlessly with Visual Studio
Code and can help developers quickly complete their code with fewer errors.
The extension looks as shown in Figure
Figure 3.15: Tabnine AI Autocomplete extension
Tabnine is better than most of the other autocomplete extensions because it
can predict and complete the whole line based on context and syntax and also
suggest your next lines of code. Figure 3.16 shows the difference between
suggestions made with and without Tabnine:Figure Tabnine AI Autocomplete even adds file1.read
Python Indent
Python indent in VSCode is a setting that gives the ability to set the number
of spaces used for indenting code blocks. This is useful for keeping your code
neat and organized and for making it easier to read. The extension looks as
shown in Figure
Figure Python Indent extension
In the default settings, every time you hit the Enter key in a piece of Python
code, the cursor will go to the beginning of the next line. The Python Indent
extension parses the Python file up to the location of the cursor. As seen in
Figure this extension can determine exactly how much the next line should be
indented and how much other lines should be un-indented.Figure Python Indent extension indenting better than the default settingsJupyter
Jupyter Extension in VS Code is an extension that allows you to write and
execute Jupyter notebooks directly in the VS Code editor. It includes support
for debugging, embedded Git Control, syntax highlighting, intelligent code
completion, snippets, and code refactoring. The extension also allows you to
easily switch between Python and R programming languages, and other
languages such as Julia, C++, and Go. Figure 3.19 is a screenshot of the
Jupyter extension:
Figure Jupyter extension
Jupyter, earlier known as IPython Notebook, is an open-source project that
helps us combine markdown text and executable Python code onto a single
platform called a notebook. Jupyter extension is available in VS Code, using
which we can run programs in the notebook. To work with Jupyter, one has to
install the Jupyter extension, and then to open or create a notebook, one has to
open the command palette and select Create: New Jupyter as shown in FigureFigure Creating a new file in Jupyter
Executing the Jupyter Notebook program:
Type your program code in the editor. Run your program by clicking on the
run icon to the left of the code cell or by using the shortcut The output
appears directly below the code cell.
One can run multiple cells by clicking the Run All option. One can even
select run all above or run all
Using the Export option, Python code can be exported to PDF or HTML
format. Export option is shown in Figure
To save your Jupyter click on the file option and then select the save option or
use the shortcut
Figure Various options available in Jupyter NotebookError Lens
The Error Lens Extension in VS Code displays errors and warnings in the
editor’s ‘problem’ area and in the editor gutter. It helps identify and fix errors
quickly and easily. It can be used to navigate to the source of the problem.
Figure 3.22 is a screenshot of Error Lens extension:
Figure Error Lens extension
The Error Lens extension displays the error, warning, and diagnostic
messages in line with the code itself. It eliminates the need for developers to
hover over or click any other options or execute the code to see the error. This
extension also highlights the code line with different colors to provide better
visualization of errors, differentiating between errors and warnings easily. We
can see the difference in Figure
Figure Error message appearing along with the code with Error LensBetter Comments
The best comment extension for Visual Studio Code is the ‘Better Comments’
extension. This extension provides a variety of comment types, such as alerts,
queries, todos, and highlights. It also allows you to easily adjust the colors of
these comment types, making it easier to differentiate between them. Figure
3.24 is a screenshot of the Better Comments extension:
Figure Better Comments extension
As the name suggests, it improves the comment by giving the capability to
customize different colors for comments. Comment can be classified using
the following properties:
! for alerts /important comments
? for questions
TODO for the task
The mentioned properties of the Better Comments extension are shown in
FigureFigure Better Comments extensionLightrun
Lightrun is an open-source Visual Studio Code extension that provides an
easy way to run and debug programs from within the text editor. Lightrun is
available for other programming languages, like Python, Java, C, C++, and
Rust. With Light Runner, you can quickly test and debug code without
needing to leave the editor or manually set breakpoints. Figure 3.26 is a
screenshot of the Lightrun extension:
Figure Lightrun extension
We are introducing a real-time debugging platform: Lightrun. It supports
multiple languages apart from Python. The reason for its popularity is that it
has an intuitive interface for the developers to add logs, traces, and metrics in
production for debugging the code in real time. One can debug by exploring
the stack trace and variables after adding Lightrun snapshots in real time and
on demand. It supports multi-instance too. The community edition of
Lightrun is free to use, but its professional edition costs for the additional
capabilities it provides.Python Test Explorer
The Python Test Explorer extension in VS Code is a plugin that enables
developers to quickly and easily run unit tests, check code coverage, and
debug test failures in Python projects. With this extension, developers can
quickly assess the quality of their code, identify areas that need improvement,
and make sure their code is bug-free before pushing it to production. Figure
3.27 is a screenshot of Python Test Explorer extension:
Figure Python Test Explorer extension
The Python Test Explorer extension for VS Code offers various user-friendly
features, such as the ability to run Unittest, Pytest, or Testplan tests. The
sidebar of the extension shows a complete view of the tests and test suites
with their state, which helps the developer focus on tests that failed.Python-specific settings
The Python extension required to execute Python code is a highly
configurable extension that provides users with the power to customize
entire setting options. Overall, in the version that was available at the time
of writing this book, there are 79 settings available. We will look at the
important ones in Table
Table Python extension settings valueInstalling and using Python packages
One of the main reasons why Python programming language is so popular is
because it supports various packages, which can be downloaded from PyPI.
Let us now write a program that will use the matplotlib and numpy packages
to create a graph. Matplotlib is a standard library for creating static or
animated or interactive visualizations in Python. Figure 3.28 shows how to
import packages or modules and the error if those libraries are not installed:
Figure Error for libraries not installed
Unless you have a previously installed matplotlib package, you would get the
message, No module named matplotlib, as shown in Figure This error
message indicates that the required package is not available in the system. To
install the matplotlib package, use the command palette to run terminal:
create new terminal This command opens a command prompt for your
selected interpreter.
It is not recommended to avoid the packages in a global interpreter
environment. One should use a project-specific virtual environment, as it
helps isolate the installed packages from other environments and create
version-specific conflicts. One can use the following commands to create a
virtual environment and then install the required packages:
Windows:py -m venv .venv
.venv\scripts\activate
MacOS/Linux:
python3 -m venv .venv
source .venv/bin/activate
When a new virtual environment is created, VS Code prompts you to set it as
the default for the current workspace folder. Select your new environment
using the Python: Select interpreter command from the command palette, as
shown in Figure
Figure Selecting interpreter path
Here are the ways to install the packages on various operating systems:
MacOS
python3 -m pip install matplotlibWindows
python -m pip install matplotlib
Linux (Debian)
apt-get install python3-tk
python3 -m pip install matplotlib
Rerun the program now, and the errors will be resolved.Functions, modules, and packages in Python
To begin with, we need to understand that a package is a collection of
modules, and a module contains functions and classes. As depicted in Figure
we can say that functions are the subset of and Modules are the subset of
Figure Functions, modules, and packagesFunctions
A function is a block of code put together under one name, and it only runs
when it is called. One can pass data (known as parameters) into a function,
and the function can return data to where it is called.
Figure 3.31 shows the types of functions we come across in Python:
Figure Types of Python functions
There are two types of functions: one which is already built and available for
use and called Built-in functions, and the other wherein the user has to writethe code for the function from scratch known as user-defined functions. Let’s
understand them better:
Built-in Functions: There are several built-in functions in Python that are
readily available for use. Listed here are a few of them:
them: them: them: them: them: them: them: them: them: them: them:
them: them: them: them: them: them: them: them: them: them: them:
them: them: them: them: them: them: them: them: them: them: them:
them: them: them: them: them: them: them: them: them: them: them:
them: them: them: them: them: them: them: them: them: them: them:
them: them: them: them: them: them: them: them: them: them: them:
The dir(builtins) in Python returns a list of all the names in the built-in
module The builtins module contains functions and variables that are built-in
in Python and can be used without being imported. The dir() function, in
general, returns a sorted list of names in the specified namespace. The
following code can help you view the list:
import builtins
print(dir(builtins))
Let us execute a few of these functions; readers are encouraged to run them
and see the results:
∘ Printing on the screen:
print("Welcome to Python World")∘ Print the eval result:
print(eval("4+5*2"))
bin(50)
a=input("Enter Your Name: ")
abs(-789)
User-defined functions: Functions that we create ourselves to perform
specific tasks are referred to as user-defined functions. Functions in Python
are defined using the def keyword, followed by with a pair of parentheses.
There may be variable names enclosed within the parentheses and a colon at
the end of the line; what follows under indentation is the block of statements
that are added for this function. When the function is called, the values are
passed as arguments; in the same way, we define parameters.
Let’s build our first user-defined function now. We will name the function
Note: The names given in the function definition are called parameters, and
the values supplied to the function call are called arguments.
Code will look something similar to the following:
#Function definition
def func(x):
isoutput = "Changed X locally to " + + " in the function"
return output
result = func(x)
is still
In the preceding program example, we defined a function named which takes
one parameter x and returns one variable output. In this example, if the value
for argument x is not provided while calling, it would result in an error, so the
x is the required argument.
In the following example, we are specifying default argument values for
parameters. The default value is added by appending the assignment operator
to the parameter name in the function definition, followed by the default
value, as demonstrated in the following example:
Here is the function definition:
def displayinfo(name, city="Delhi"):
# Printing a passed info in this function
print("Name: ",name, "\nCity ", city)
return
Now you can call the printinfo function:displayinfo(city="Mumbai", name="Sachin")
displayinfo(name="Virat")
In the preceding example, at the time of call, if no value is provided to the
city, it will use the default value In the first function call, we are providing the
value for the city, so the function will take This example also demonstrates
how keyword arguments work in a function call. The calling function
identifies the arguments by the parameter names in this case, that is, city =
"Mumbai" and name= Keyword arguments help skip arguments or place them
out of order. The Python interpreter uses the keywords passed to match the
values with parameters. Apart from not worrying about the order of the
arguments, an advantage is that only those parameters will be given the
values which we need. This is only when other parameters have default
argument values.
Sometimes, we may not know exactly how many arguments the caller may
pass; in such cases, we have the option to use variable length parameters,
which is achieved using * (stars). When we declare a single-starred
parameter, such as all the arguments from that point till the end are collected
in a tuple format, called And when you declare a double-starred parameter
like then all the keyword arguments from that point till the end are collected
in a dictionary format, called
Let us implement a function total that takes a variable number of arguments
both as Tuple and This is a simple example that accepts the arguments and
prints them in the function body:
def *numbers, **keywords):
count = initial
for num in numbers:
count+=numfor key in keywords:
count+=keywords[key]
return count
Functions have an inbuilt mechanism to handle documentation. The concept
is called DocString. They are an important part of the Python language and
are used to make code more readable, maintainable, and reusable.
DocString
A docstring is a string value that occurs as the first statement in a function,
class, method or module definition. When a module, function, class, or
method is called, the interpreter scans the definition for a docstring and, if
found, it is passed as the first argument to the function. A docString is used to
document a brief explanation of what a function does, though it is optional
but always recommended. DocString is a comment added immediately below
the function header. Generally, triple quotes are used so that the description
can extend up to multiple lines. Docstring is available to us as the __doc__
attribute of the function. Let’s implement docstring in a program. In the
following function greet, the first line given in triple quote (“””) is docstring:
def greet(name):
""" This function is used to greet a person.
This function greets to the person passed in as
" + name + Have a good
You can, at any point in time, display the docstring content of any function.
Writing the code to check the doc string of the function greet() which we
created above:Now, let us check the doc string for built-in function print():
Docstrings are used to document the purpose of a function, method, class, or
module and provide usage examples and other useful information.
Python also has a third type of function called the one line function or
Lambda function. For cases where the entire logic can be built with just one
line, this is preferred to make code short and simple:
Lambda Lambda operator or lambda function is used for creating small, one￾time, and anonymous function objects in Python. Its basic syntax is as
follows:
lambda arguments : expression
The lambda operator can take any number of arguments, but it can have only
one expression. It cannot contain any statements and returns a function object
that can be assigned to any variable; for example, in the following example,
add represents the lambda function.
Here is a program to demonstrate a function using the lambda operator:
add = lambda x, y: x ** y
a =
Normally, the preceding program would be written as follows:
def power(x, y):return x ** y
Call the function:
a
Now, let us see how recursive functions can be implemented in Python:
Recursion functions: A recursive function in Python is a function that calls
itself. It is an algorithm that calls itself, with an updated version of its own
input, until it reaches a solution. This type of function can be very powerful
for solving complex problems that can be broken down into smaller chunks.
Recursive functions can be used to traverse data structures, implement
mathematical algorithms, and even solve games. Recursion is a way of
coding, in which a function calls itself one or more times in its body, usually
as the returning value of the function call, and the function is called a
recursive function.
A recursive function terminates if the solution of the problem is downsized
and moves toward a base case. It is where the problem can be solved without
further recursion. A recursion can end up in an infinite loop if the base case is
not met in the calls.
Let us take a situation where recursion is best suited, calculating the factorial
of a number. A factorial of 4 would be the multiplication of all the numbers
between 1 and 4. Here is an example:
4! = 4 * 3 * 2 * 1
Or, we can write this as follows:4! = 4 * 3!
3! = 3 * 2!
2! = 2 * 1
This is a classic scenario to use the recursion concept. The terminating
condition would be when we try to find a factorial of 1 or lower value, which
is called the base case.
Let us write a program to implement the factorial of a number using
recursion. Intermediate steps can be tracked by adding two print() functions
to the previous function definition:
def factorial(n):
has been called with n = " +
if n ==
return 1
res = n *
n, " * factorial(" "):
return res
Now, test the function:
The output is given in FigureFigure Output from the factorial recursion programClasses
Classes are the building blocks of Object-Oriented Programming OOP in
Python is a programming paradigm that uses classes and objects to create a
model of real-world objects and their interactions. It is a way of organizing
and structuring code to make it more readable, maintainable, and reusable.
OOP in Python includes class definitions, inheritance, encapsulation,
abstraction, and polymorphism. It allows developers to create objects that
have specific properties and behaviors, which can then be used to create
applications and programs.
Now, let us examine the terms you will encounter in discussions about OOP:
Object: An object is an entity that has a state and behavior. It may be physical
and logical. For example, a mouse, keyboard, chair, table, pen, etc.
Everything in Python is an object, and almost everything has attributes and
methods.
Class: Class can be defined as a collection of objects. It is a logical entity that
has specific attributes and methods. For example, if you have a student class,
then it should contain an attribute and method, that is, an email ID, name,
age, roll number, etc.
A class creates a new data type where objects are instances of the class. An
object is defined as a real-world entity related to the problem domain, with
crisply defined boundaries. Objects are encapsulated with attributes (called
fields in Python) and behavior or services (called methods in Python).Figure 3.33 shows the members of a class. Members of a class in Python
include attributes, methods (services), and class variables. Attributes are used
to define the properties of a class, such as its data and behavior. Methods are
functions that are associated with a particular class and can be used to
manipulate the data and behavior of that class. Finally, class variables are
variables that are shared among all instances of a class and can be used to
store information that is applicable to all the instances.
Figure Example of classes
As depicted in Figure the patient is a class that has its set of members.
Patients can be either in-patients or out-patients.Method
Method is a function that is associated with an object. In Python, the
method is not unique to class instances. Any object type can have
methods. Objects can store data using variables (also called fields) that
belong to them. Objects also have functionality by using methods.
Methods are the functions defined in a class. In terms of definition,
functions and methods are similar, the difference being that the functions
are independent, whereas methods belong to a class or object. A class is
created using the class keyword. The fields and methods of the class are
listed in an indented block.
Let us create an example class in Python and look at its workings:
Here is an example of declaring a class:
class Book:
"""Represents a Book class example"""
#declaring a class variable:
book_count = 0
Now initialize the variable using the init
def #self keyword represents instance (object) of the class
''' Initialize the data'''
= title
the title of the book:
#When a book is created, it should increase the total book count by 1
Book.book_count #Since its a class variable, Class name.variable is useddef
'''Removing book from the list'''
is being removed from the
Book.book_count -= 1
if Book.book_count <=
was the last book in the shelf. You don't have any more
are still {} books in the
def
"""Hello from the book class"""
from Class Book, I am being called by
@classmethod
def
"""Prints current number of books available"""
there are {} books in the
#### Below code is used to create object of the class Book
#Creating objects and initializing the title using __init__
#Automatically called while creating objects
book1 = A to Z of Retail
book2 = and Practice Python
book3 = your
#calling class variable using classname
number of books available in the shelf:
#Calling functionsbook1.say_hi()
book2.remove()
#calling class variable using object
number of books available in the shelf:
We used the __init__() method in the preceding example to initialize the
variables. Let’s understand the significance of this method.
The init method
There are a few methods that have special significance in Python classes,
including the init method. The __init__ (double underscore init double
underscore) method is executed as soon as an object of a class is
instantiated. Since the method is automatically called, it is used to
initialize the object.
Note: The double underscores are at both the beginning and the end of the
init.More about Class and Objects
Class variables (owned by class) are shared, and they can be accessed by
all instances of that class. There is only one copy of the class variable,
unlike object variables, which are duplicated for each object. When any
one object makes a change to a class variable, the change will be seen by
all the other instances as there is a single copy.
Object variables belong to each object/instance of the class. Each object
has its copy of the field, i.e., they are not shared and are not related in any
way to the field by the same name in a different instance.
The classmethod() is a built-in function in Python, which establishes
ownership of the method to the given class. Class methods can be called
by both class and object.
In the preceding example, book_count belongs to the book class and
hence, is a class variable. The title variable belongs to the object and is
assigned using The population class variable is referred to as
Book.book_count and not as Object variable name is referred to using the
self.title notation in the methods of the object. Instead of it can also be
referred to as self.__class__.population as every object can be referred to
its class via the self.__class__ attribute.
The init method is used to initialize the book instance with a name, and we
increase the book_count by 1 since a book is added. In the remove()
method, we simply decrease the Book.book_count by 1. All classmembers are public, which means they can be accessed from any class or
even from the main. If data members have names with the double
underscore prefixed, such as Python uses name mangling to effectively
make it a private variable. Any variable that is meant to be used only
within the class or the object should begin its name with an underscore,
and all other names are public and can be used by other classes/objects.
This is only a convention and is not enforced by Python (except for the
double underscore prefix, which is to make the members private).
There are four important pillars of class and objects:
Inheritance
Polymorphism
Data abstraction
EncapsulationInheritance
Inheritance is a process by which objects of one class acquire the
properties of the objects of another class. Inheritance provides code
reusability, makes it easier to create and maintain an application. In this
section, we will cover the basics of inheritance.
What is inheritance in Python?
Inheritance is a way of creating a new class (called a child class) from an
existing class (called a parent class). The child class will have the same
properties and behaviors as the parent class, but it can also have its own
unique properties and behaviors. Inheritance provides a way to reuse code
from the parent class and extend it.
Syntax of Inheritance
In Python, inheritance is specified using the following syntax:
class ChildClass(ParentClass):
# code
Here, ChildClass is the name of the child class and ParentClass is the
name of the parent class.
How does inheritance work in Python?Inheritance works by allowing a child class to inherit the properties and
behaviors of a parent class. When a child class inherits a parent class, it
automatically inherits the methods and attributes of the parent class. This
means the child class can use the inherited methods and attributes without
having to define them again.
For example, suppose we have a class called which has an attribute called
name and a method called We can create a new class called which inherits
from
# Example of Inheritance in Python
class Animal:
def __init__(self, name):
self.name = name
def speak(self):
print("%s says 'hello!'" % self.name)
class Dog(Animal):
def bark(self):print("%s barks 'woof!'" % self.name)
# Create an instance of the Dog class
d = Dog("Fido")
# Call the speak() method
d.speak()
# Output
Fido says 'hello!'
# Call the bark() method
d.bark()
Output
Fido barks 'woof!'
In this example, we defined a class named which has an attribute called
name and a method called We then created a class called which inherits
from This means that the Dog class gets the methods and attributes of the
Animal class automatically.When we create an instance of the Dog class, we can call the speak()
method inherited from the Animal class, as well as the bark() method
defined in the Dog class. This is how inheritance works in Python.
Inheritance provides a number of advantages, including the following:
Code Inheritance allows us to reuse existing code instead of having to
write it from scratch. This saves time and makes the code easier to
maintain.
Inheritance makes it easier to extend existing code instead of having to
rewrite it. This makes the code simpler and easier to understand.
Inheritance makes it possible to add new features to an existing class
without having to modify any existing code. This makes it easier to extend
an application as needed.Polymorphism
Polymorphism allows programs to execute different behaviors in different
contexts; for example, consider the following code:
class Animal:
def make_sound(self):
print("This animal makes a sound!")
class Dog(Animal):
def make_sound(self):
print("Woof!")
class Cat(Animal):
def make_sound(self):
print("Meow!")
dog = Dog()
cat = Cat()dog.make_sound()
cat.make_sound()
The output of this code is:
Woof!
Meow!
In this code, we defined a superclass, and two subclasses: Dog and The
Dog and Cat classes both inherit the make_sound() method from the
Animal class. However, they each override the method, so when the
make_sound() method is called on each object, the respective sound of a
dog or cat is printed. This is an example of polymorphism, as the same
method can execute different behaviors depending on the context in which
it is called.Data abstraction
Data abstraction is the process of hiding the implementation details from
the user and providing only the functionality to the user. In Python, data
abstraction is provided by abstract classes and interfaces. Abstract classes
contain one or more abstract methods. Abstract methods must be
implemented by any non-abstract subclass. An interface class contains
only abstract methods.
Let us consider an example to understand data abstraction. We have a
class called which is an abstract class. It contains three methods:
get_perimeter() and The get_area() and get_perimeter() methods are
abstract methods, since they are not implemented in the Shape class. The
draw() method is a concrete method, as it is implemented in the Shape
class:
class Shape:
def get_area(self):
pass
def get_perimeter(self):
pass
def draw(self):print("Drawing a shape")
Now, let us create a subclass of Shape called It implements the get_area()
and get_perimeter() methods, which are abstract methods of the Shape
class:
class Square(Shape):
def __init__(self, side):
self.side = side
def get_area(self):
return self.side * self.side
def get_perimeter(self):
return 4 * self.side
In this example, the Square class implements the abstract methods of the
Shape class. The user of the Square class will only know that it is a shape
and will not know how it is implemented. This is data abstraction.Encapsulation
Encapsulation is a mechanism of wrapping the data and the functions that
operate on that data within a single unit. This allows the programmer to
protect the data from outside interference and misuse and to easily reuse
the code.
For example, let us say we want to create a class that represents a vehicle.
We can create a class called Vehicle and add two data members to it: one
for the make and one for the model of the vehicle. We can also add a
method to the class to calculate the total cost of the vehicle:
class Vehicle:
def __init__(self, make, model):
self.make = make
self.model = model
def calculate_total_cost(self):
# calculate total cost here
return 100Now that we have our class, we can create an instance of the Vehicle class
and use it to represent a specific vehicle:
my_car = Vehicle("Honda", "Civic")
total_cost = my_car.calculate_total_cost()
In this example, we have encapsulated the data (make and model) and the
methods inside the Vehicle class. This allows us to easily reuse the code
and protect the data from outside interference. Encapsulation is an
important feature of object-oriented programming, as it allows the
programmer to create a well-structured, maintainable program. It also
allows the programmer to easily reuse code and protect data from outside
interference.Modules
The module is a Python file that contains code to perform a set of related
tasks. A Python module may contain variables, functions, classes, etc. Let us
say your friend has written some wonderful functions and classes, and you
want to use the code from them. You can ask them for the .py file and put that
in the same folder as your file. You can start using it by simply importing it
into your code.
Let us create a dummy but working module ourselves by writing the
following code in a file called
# defining a class AboutMe
class AboutMe:
# defining the __init__ method
def name, city):
= name
= city
# defining the getCity method
def
+ " lives in the city " +
# defining the function hello
def hobbies():
love playing badminton and have my interest in"
"Creative arts, including writing and
# creating a variable
work = 'I am a Technoculturist'if __name__ ==
when invoked
# calling the function hobbies()
hobbies()
# creating the object captain
captain =
# calling the getCity() method for the object
captain.getCity()
#printing the variable work present in aboutme.py
When you execute the aboutme.py file, the content inside the if condition will
be executed. __name__ == , __main__ will result to true because the Python
interpreter reads the source file before executing and defines a few special
variables. One such variable is which is set to value __main__ for the file that
is directly called. When we execute the condition becomes true, but when the
same file is referenced from another Python file, __name__ will be set to the
module’s name. The module’s name is available as value to __name__ global
variable.
Now, let us use this as a module and call its member from a different file.
Create another file though the name does not matter in this case. Type the
following code to call the members from the aboutme.py file:
# importing the module aboutme.py
#Class, Function and Variable all are now imported
import aboutme# calling the function hobbies() from aboutme.py
aboutme.hobbies()
# creating the object captain of class AboutMe
captain =
# calling the getCity() method for the object
captain.getCity()
#printing the variable work present in aboutme.py
The output displayed is shown in Figure
Figure Output of calling a module
We have seen how to add classes, variables, and functions to a module. Now,
let us see how modules are added together in a package.Packages
We all will work on big projects at some point in time, and that means dealing
with large amounts of code. Writing everything together in a single file will
make our code complex to handle. The recommended way is to separate the
code into multiple files, keep related codes together in packages, and use the
package when required in the projects. This is a great way to reuse the codes.
One possible organization of packages and modules while developing a game
could look as shown in Figure
Figure Example of a Python package
The FunDo game directory has a file named which is a must for Python to
consider it as a package. The developer has the option to leave this file empty,but generally, they place the initialization code for the given package in the
__init__.py file.
One can import modules from packages using the operator. For example, if
we want to import the outfit module in the preceding example, it can be done
as follows:
import FunDo.Graphics.outfit
Now, if this module contains a function named we must use the full name to
reference it.
FunDo.Graphics.outfit.change_shoes("blues")
There is an alternate way to call the functions without giving a lengthy name.
This time, we give an alias to the import package, as follows:
import FunDo.Graphics.outfit as fgo
We now reference it as follows:
fgo.change_shoes("blues")
We can also call them differently than what we have named, so that we do not
have to give the full package name while referencing, as follows:
from FunDo.Graphics import outfit
We can now call the function simply as follows:Another way of importing is to call the required function from a module, as
follows:
from FunDo.Graphics.outfit import change_shoes
Now we can directly call this function:
change_shoes("blues")
Although this might look easier, it is not recommended. Using the full
namespace avoids confusion and prevents two same identifier names from
colliding.Conclusion
are what make VS Code efficient for Python programming. We have
learned about the top 10 popular extensions used by developers across the
world and the powerful features of these extensions. Python extension for
VS Code is highly configurable, so it makes sense to configure it to make
the development of applications easy. For that purpose, we looked at some
of the Python-specific settings, which can be edited in VS Code. We
learned how to install packages available in Python Package Index which
is the official third-party repository for Python packages. In the last
section of the chapter, we focused on understanding how to create
functions, modules, and packages for application development. We are
getting closer to developing amazing applications.
In the next chapter, we will build our first Python app using all the basic
concepts, but before that, we will learn to handle 2D data using numpy,
scientific calculation using scipy, and table structure using pandas. We
will also solve a business problem using data visualization; in the last
section, we will learn to work withChapter 4
Developing Visualizing Python App in VS Code
If I can’t picture it, I can’t understand it.
— Albert EinsteinIntroduction
People like visuals and the importance of visuals, as it helps us visualize
simple and complex concepts, interact with the presented data, and bring
everyone on the same page, regardless of their level of expertise. Every
industry wields data and analytics as competitive weapons, operational
accelerants, and innovation catalysts. Data-Driven Decision-making is
about using facts, metrics, and data to make strategic business decisions
aligned with organizational goals, objectives, and initiatives. Based on
historical and current data, businesses use predictive analytics, statistics,
and modeling to determine potential outcomes and future performance.
But at the same time, it is getting difficult to make sense of trillions of
data rows created daily. This is where visualization is playing an
increasingly key role. Experts use data visualization to tell stories that
everybody in the organization can understand. They do this by curating
data into an easily understood form, highlighting the trends and outliers.
In this chapter, we will look at a couple of examples of visualization that
tell a story by removing the noise from data and highlighting useful
information, and then showing how this can help the business make
decisions.
This chapter assumes that the readers have some knowledge of Python
topics like Numpy, Scipy, Pandas, Matplotlib, and Seaborn. We will get an
overview of these topics in this chapter, so even if you have no working
knowledge, it should be fine.
We will also look at using the basics of Git version control in Visual
Studio Code We will learn about integrated Git support and understandhow to work with remote repositories. We will conclude the chapter by
learning how to debug the application.
Refer to the GitHub location to access the dataset.Structure
In this chapter, we will cover the following topics:
Virtual Environment Concept
Python topics:
Learning the basics of statistics
Visualization for Data Analysis
Working with GitHub
Now, let us dive deep into the topics.Virtual Environment Concept
Before we get into the Python topics, let us understand the concept of
virtual environment. This is the right time to discuss it. Creating a virtual
environment is a great way to keep your Python projects organized and
separate from each other. It allows you to install libraries and
dependencies specific to a project without affecting your global Python
installation. Here is how you can create a virtual environment and install
libraries in it:
Open your command line or terminal.
Install the virtualenv package if you don’t have it already. You can do this
by running the pip install virtualenv command.
Once virtualenv is installed, navigate to the directory where you want to
create your virtual environment.
Run the command to create a new virtual environment called You can
choose any name you like. This command creates a new directory with the
same name as your virtual environment within the current directory.
Activate the virtual environment by running the appropriate command for
your operating system:
- On Windows: `myenv\Scripts\activate`
- On macOS/Linux: `source myenv/bin/activate`Once the virtual environment is activated, your command-line prompt will
change to indicate that you are now working within the virtual
environment.
You can now install libraries into your virtual environment. For example,
to install the `numpy` library, run the pip install numpy command. This
will download and install the library into your virtual environment.
You can install multiple libraries by running additional pip install
commands.
You can check the installed libraries in your virtual environment by
running the pip list command.
When you are done working in your virtual environment, you can
deactivate it by running the `deactivate` command. This will restore your
global Python environment.
By creating and using virtual environments, you can easily manage your
Python projects and their dependencies with minimal conflicts or
interference between them.Python topics
Numpy, Scipy, Pandas, Matplotlib and Seaborn are popular Python
libraries used for data analysis and manipulation:
Numpy is used for scientific computing, array manipulation, and linear
algebra.
Scipy is used for scientific and technical computing, statistics, and more.
Pandas is used for data manipulation and analysis, data cleaning, and data
wrangling.
Matplotlib is used for data visualization and plotting.
Seaborn is used for statistical data visualization and plotting.
These libraries are important because they make it easier to manipulate,
analyze, and visualize data, which is critical for data science and machine
learning applications. Let’s learn about them in detail.Numpy
Numerical Python is used for working with arrays in Python. It has functions
for linear algebra, Fourier, and so on. NumPy arrays are stored in memory at
one continuous place so that processes can access and manipulate them
efficiently. Numpy is used in Python programming after installing and
importing the numpy library in your Python applications. Numpy can be
installed using pip command and imported in the program using the import
keyword. In the following example, we have imported Numpy and then
created an alias np while importing:
import numpy as np
The preceding the statement will import NumPy and make it ready to use. In
the next line, we will see how to create a list to Numpy array:
Array1 = numpy.array([10, 20, 30, 40, 50])
print(array1)
ndarray is the array object of NumPy that is used to work with arrays. NumPy
ndarray object is created using the array() function. Consider this example:
import numpy as np
array1 = np.array([2, 4, 6, 8, 10])
print(array1)print(type(array1))
In the following example, let us create a 2D array with two arrays:
import numpy as np
array1 = np.array([[1, 3, 5], [4, 5, 6]])
print(array1)
NumPy Arrays provides the ndim attribute that tells how many dimensions
the array has. Take a look at this example:
import numpy as np
array1 = np.array([[[1, 3, 5], [2, 4, 6]], [[3, 2, 1], [1, 2, 3]]])
print(array1.ndim)
Let us look at some of the important attributes of an ndarray object in Table
Table Attributes of ndarrayLet us use Numpy to solve a linear equation:
2x + 5y + 2z = -38
3x – 2y + 4z = 17
-6x +y -7z = -12
Here is how it is solved using Numpy:
import numpy as np
#A: Coefficient Matrix
A=np.array(A)
#print(type(A))
#B: Constant Matrix based on Solution
b=np.array(b)
#print(type(B))
detA=np.linalg.det(A)
if
is not
InvA = np.linalg.inv(A)
C= np.matmul(InvA,b)
x = {}, y= {},
The output of the preceding code is shown in FigureFigure 4.1: Output of linear equationScipy
The scipy library is used for scientific computing and is free and open
source. To use the scipy library in Python, follow these steps:
Install Run the following command in your terminal or command prompt:
pip install scipy
Import the necessary functions/classes from
from scipy import function/class
Replace function/class with the specific function or class you want to use
from Important subpackages available in scipy are listed in Table
Table 4.2: Subpackages under ScipyExample 4.1
Let us look at how to solve a combination problem using Scipy.
Let us take an example where we have a group of 4 girls and 6 boys; 4
children are to be selected to chair a college committee. How many ways can
we select the group such that at least one boy should be in all the
possibilities?
We have four options:
∘ Selecting all 4 boys: 6C4
∘ Selecting 3 boys and 1 girl: 6C3 × 4C1
∘ Selecting 2 boys and 2 girls: 6C2 × 4C2
∘ Selecting 1 boy and 3 girls: 6C1 × 4C3
It can be solved using the Scipy.special.comb package as follows:
from scipy.special import comb
#find combinations of 5, 2 values using comb(N, k)
#selecting 4 boys: 6C4
com = exact =
sum+=com
#selecting 3 boys and 1 girl: 6C3 × 4C1com = *
sum+=com
#selecting 2 boys and 2 girls: 6C2 × 4C2
com = *
sum+=com
#selecting 1 boy and 3 girls: 6C1 × 4C3
com = *
sum+=com
combination possible:
The preceding code will generate the total combination, and the output is
represented as shown in Figure
Figure 4.2: Output of combination problemPandas
The Pandas package is for data extraction and preparation. Pandas is a
very popular library that provides high-level data structures, which are
simple to use and intuitive. It provides data structures like dataframes for
handling tabular data and a wide range of functions for data manipulation.
Here is a basic guide to using Pandas in Python:
Install Use pip or conda to install Pandas if you have not already. Open
your terminal or command prompt and run the following command:
pip install pandas
or
conda install pandas
Import Import the Pandas library in your Python script or notebook using
the following line of code:
import pandas as pd
Reading Pandas can read data from various file formats, such as CSV,
Excel, and SQL databases. Use the appropriate function, like or read_sql()
to read the data into a dataframe. Consider this example:df = pd.read_csv('data.csv')
Pandas has many inbuilt methods for grouping, combining data and
filtering, and performing time series analysis. Pandas can easily fetch data
from different sources like SQL databases, CSV, Excel, and JSON files,
and manipulate the data to perform operations on it.Example 4.2
Let us look at a demonstration of reading three datasets from GitHub and
merging them:
∘ Contains users’ monthly mobile usage statistics
∘ Contains details of ‘use’ of the system by individuals, with dates and data
from the device
∘ Dataset with device and manufacturer data, listing all Android devices and
their model codes
Read In the following code, we will use the method provided by Pandas to
read the CSV files from the GitHub location directly:
import pandas as pd
#Read the 3 csv files
d1 =
# monthly mobile usage statistics
d2 =
#check the device and OS version for each user
d3 =
#contains details of all Android devices with model number and manufacturer
Let us look at the linking attributes between these datasets. We see that use_id
is a common column in user_usage and user_device dataframes. Model
column of the devices and device column of the user_device dataset containcommon codes. Now, let us form a single dataframe with columns for user
usage figures (like calls per sms per month, and so on ) and device
information and so on). Let us merge (or join) our sample datasets into a
single dataset before performing analysis.
Let us add the device and platform columns to the user_usage dataframe
using the merge command of Pandas:
#adding device and platform columns to the user_usage
result = pd.merge(d1,
Merging requires parameters like a left dataset, a right dataset, and a common
column to merge on. By default, an inner merge operation. Let us start the
analysis and check the sizes or shapes of inputs and outputs:
#Analyze the dimensions of the dataframes
Dimensions:
Dimensions:
Dimensions:
The preceding code will give the output shown in Figure It shows that final
number of rows is 159 and columns is 6:Figure Output of Combination dataset
We started with 240 rows in user_usage and 272 rows in but the resultant
dataframe has only 159 rows, as shown in Figure Why do we see that the
result differs in size from the original dataframes?
An inner merge/join keeps only the common values in the result’s left and
right dataframes. In this example, only the rows that contain use_id values
that are common between user_usage and user_device remain in the result
dataset. Let us validate what we just said by looking at how many values are
common between the left and right datasets. The following code will display
the common rows as and no match will return
#how many values are common
The output of the preceding code is shown in Figure we see that only 159
rows are common:
Figure True indicates the number of datapoints that are common
Other Merge types
Apart from Inner Merge/ Join, other types of joins are as follows:Left Merge / Left outer Keep every row in the left dataframe even if the
corresponding values are in the right dataset. Adds NaN/empty values for
missing values of the on variable in the right dataframe.
Right Merge / Right outer Keep every row in the right dataframe and add
empty / NaN values in the output for any missing values in the left dataframe.
Outer Merge / Full outer An outer merge or full outer join returns all the rows
from the left and right dataframes, and matches up rows where possible, with
NaNs elsewhere.
We can change the merge to a left-merge with the how parameter in merge
command, as shown in the following code:
#Changing the merge to a left-merge with the "how" parameter
result = pd.merge(d1,
indicator
result.head()
Dimensions:
Dimensions:
are {result['device'].isnull().sum()} missing values in the
Let’s see how to use left_on and right_on to merge with different columns.
Now, let us add the third dataframe. We will redo the first merge to get back
to inner merge and then merge devices dataframe. The code is presented here:
# Adding platform and device to the user usage
result = pd.merge(d1,# Merging on the "device" column in result
# match the "Model" column in devices (d3)
result = pd.merge(result,MatPlotLib
Matplotlib is the basic plotting library for the Python programming. It is
also an extension of numerical NumPy. It provides an object-oriented API
for embedding plots into applications using general-purpose GUI toolkits
like Tkinter.Seaborn
The Seaborn library uses Matplotlib underneath to plot graphs. Matplotlib
is preferred for basic plots, while Seaborn is used for more advanced
statistical plots and provides more attractive default color palettes.
We will see MatPlotLib and Seaborn in action while building the
application.Learning the Basics of Statistics
We always have to fight for the right and useful datasets to solve business
problems. Let us understand the components of a dataset. A dataset is a set of
data from a study or experiment. An instance is a single row of data, and the
collection of instances that share a common attribute is called dataset. Data
can come in many forms, but our analysis in this chapter will rely on two
primary data types: numerical and categorical. Numerical or quantitative data
is any measurable data, for example, height, weight, or the phone bill cost.
You should be able to perform arithmetic operations like multiplication,
average, and so on. Numerical data can be of two types: discrete and
continuous.Figure 4.5: Types of numerical dataDiscrete data
Discrete data is information broken up into smaller units or discrete variables.
Each variable can only take on certain values (for example, 0, 1, 2, 3, 4, 5). A
more practical example will be counting the cups of water required to empty
a bucket.
Data can be represented using various charts. The following is an example
where a stacked bar chart captures the quarterly average collection of GST
from 5 cities. Let us learn to plot such a chart. Refer to Figure 4.6 to see how
a stacked bar graph looks:Figure 4.6: Example of stacked bar chart
Here is the Python code to generate the plot shown in Figure
import matplotlib.pyplot as plt
from matplotlib import rc
import numpy as np
import pandas as pd
# put y-axis in bold
# Values of each group
Y22Q1 =
Y22Q2 =
Y22Q3 =
# Heights of bars1 + bars2
bars = np.add(Y22Q1, Y22Q2).tolist()
# Creating 5 positions for the bars on x-axis
r =
# Names of group and bar width
names =
barWidth = 1
# Create brown bars
plt.bar(r, Y22Q1,
# Creating green bars (middle), on top of the first bar
plt.bar(r, Y22Q2,
# Create green bars (top)
plt.bar(r, Y22Q3,
# Custom X axis
plt.xticks(r, names,
thousandAverage GST
5 Cities in
# Show graphic
plt.show()Continuous data
Continuous data can take on any value within a range. Examples of
continuous data include weight, temperature, time, and speed. They are
measured and not counted, often represented by a continuous line graph.
An example is the Cumulative Grade Point Average (CGPA) in a 5-point
grading system that defines first-class students as those whose CGPA falls
under 4.5 - 5.0, upper second-class as 3.50 - 4.49, lower second-class as
2.50 - 3.49, third class as 1.5 - 2.49, pass class as 1.00 - 1.49 and fails as
0.00 - 0.9. Continuous data is uncountable finite.
Continuous data can be subdivided into two types: interval and ratio data.Interval data
Interval data is continuous quantitative data where the difference between two
values has meaning. This data type is measured on an equal interval scale,
meaning the difference between each set of values is consistently equal across
the data set. Examples of interval data include temperature, height, and time.
Interval data is numerical values that can take up only addition and
subtraction operations.
For example, the temperature measured in degrees Celsius (or Fahrenheit) is
considered interval data, and this temperature does not have a zero point.
Trend analysis on interval data is conducted by capturing data using an
interval scale survey using the same question. It is one of the most popular
analysis techniques to plot trends and insights by presenting data over a
certain period. In Figure let us see the 5-year percentage trend in revenue (in
USD) for Infosys:Figure 4.7: 5-year trend exampleRatio data
Ratio data is continuous data with a zero point, for example, the temperature
measured in Kelvin. Suppose we measure the temperature of two things as
10°C and 20°C, respectively; it doesn’t mean that the second thing has two
times higher temperature than the first one because 0°C doesn’t mean the
absence of temperature.
Cross-tabulation analysis technique can be a method to understand the
relationship between multiple variables. The contingency table (or a crosstab)
is used to establish a correlation between multiple ratio data variables in a
tabular format. An example of a crosstab is shown in Figure Crosstab can be
used with any data level: ordinal or nominal; and it treats all data as nominal
data (nominal data is not measured but categorized). For example, you can
analyze the relation between two categorical variables like age and purchase
made.
Figure 4.8 shows a crosstab analysis based on two questions:
What is the age of the respondent?
Which electronic gadgets are they likely to buy in the next 1 month?Figure 4.8: Example of Cross Tabulation
General characteristics/features of numerical data:
Numerical data is quantitative in nature.
You can perform arithmetic operations like addition and multiplication.
They can be both estimated and precise.
The difference between each interval on a numerical data scale is equal.
Numerical data can be visualized in different ways, depending on scatter
plots, dot plots, stacked dot plots, histograms, and so on.Categorical data (or Qualitative data)
Categorical data can be classified into distinct categories or groups, for
example, gender, social class, ethnicity, and hometown. It is non￾quantitative and great for grouping individuals or ideas with similar
attributes, helping machine-learning models streamline data analysis.
This can be further classified as nominal and ordinal data.Nominal data
Nominal data represents values (or categories) that can be put in any
order. It represents only the individual category or name and only
represents quality and not information about the size of the difference.
Values have no specific order and can be written in any order. Examples
of such data are as follows:
{Male, Female}
{North Zone, South Zone, East Zone, West Zone}
{Maruti, Tata Motors, Mahindra, Toyota, Ford}Ordinal data
Ordinals are categorical where the value follows some order and we can
determine the direction of the difference of a variable, but we cannot
determine the size of the difference. There is a meaning in the order, like Very
Good would be greater than Good, but these are categorical because we do
not know by how many times Very Good is greater than Good.
For examples, refer to the various options mentioned here:
here:
Table Rating options for a training course
course
Table 4.4: Students’ grade
grade grade
Table 4.5: Preferences
We know the order in the ordinal data is like this:
Excellent > GoodThe order is maintained no matter what value we assign to them. Categorical
data can be summarized in a table that lists individual categories and their
respective frequency count, for example, frequency distribution.
One can also use a relative frequency distribution that lists the categories and
proportion with which each occurs. Figure 4.9 depicts the frequency and
relative frequency of the placement data of a business school. For example, it
indicates that 73 students were placed in an accounting role, which
constituted 28.9% of the entire student population.
Figure Frequency Distribution Table
Frequency and relative frequency distributions can also be summarized as bar
and pie charts, respectively. Refer to Figure 4.10 for the visualization:Figure 4.10: Bar graph and pie chart from frequency distribution tableVisualization for Data Analysis
In this section, we will learn to use Matplotlib and Seaborn to visualize the
data. The first plot we will discuss is scatter plot. A scatter plot shows the
relationship between two datasets represented on the X and Y axes. They can
be used to show trends, clusters, patterns, and relationships in a cloud of data
points, especially a very large one.
Problem: What causes Job Stress for Managers in Software Industry?
Software engineers experience psychosocial work stress that may negatively
affect physical and mental health over time. A researcher wants to study the
impact of various factors on job stress for managers working in the software
industry. They have identified three factors, family support, work-family
conflict, and sleep, that can impact stress levels. They worked with 3683
respondents and documented the findings in They want to check if these
factors can help us predict software engineers’ stress levels. Let us analyze
the data using Python. Refer to the following steps:
Define the problem
Presented here are a few examples of the problem statement. You can develop
your problem statements based on questions like the following:
Which factors help us influence the stress levels of managers in the software
industry?
Can we predict the stress levels of managers working in the software industry
based on family support, work-family conflict and sleep as factors?Get the data
We are going to use the JobStressData.csv file. You can download the file
from the given GitHub location. First, let us understand which libraries we
need to use. If you do not have them, you can install them using the pip
command. Refer to Chapter 3, Top Extensions in VS Code for Python, for
more details.
The code shows the libraries that are required to plot, including matplotlib
and
import numpy as np
import pandas as pd
from scipy import stats
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import pearsonr
Let us read the data into the Pandas dataframe:
data =
# shows number of rows, columns
The JobStressData.csv dataset is on GitHub to download.
Data cleaningThe next step would be to clean and read the relevant data. The given dataset
has data for both managers and non-managers, so let us filter to get only the
manager-relevant data.
Let us summarize the data to find the types of data we have. If the DataFrame
contains numerical data, the description contains this information for each
column:
The number of not-empty values
The average (mean) value
The standard deviation
the minimum value
The 25% percentile*
The 50% percentile*
The 75% percentile*
The maximum value
The following code will summarize the data after filtering based on role value
ofsummary = data.describe()
# Filter the data for job role = MANAGER
manager_df = ==
manager_df =
Figure 4.11 shows the correlation coefficient between all the columns. This is
the output from the preceding code:
Figure 4.11: Correlation coefficient between various factors
The last line prints the correlation coefficient between all the columns. The
coefficient of correlation is a statistical metric to find the strength of a linear
relationship between two variables. Coefficient values can range from -1 to 1.
When the correlation coefficient is -1, it describes a perfect negative, inverse
correlation, with values in one series rising as those in the other decline, and
vice versa. A coefficient of 1 shows a perfect positive correlation or a direct
relationship, and a coefficient value of 0 means there is no linear relationship.
In the dataset we have, most of the values are between -0.5 and +0.5,
indicating there is no or very little correlation between these factors.
Analyze the dataWe can represent the preceding data using A heatmap is a plot that shows the
magnitude of a phenomenon as color in two dimensions. The color variation
may be by hue or intensity. The following code shows how to plot a heatmap
using the seaborn library.
# plotting the heatmap for correlation
ax = sns.heatmap(manager_df.corr(),
plt.show()
The heatmap output from the preceding code is plotted in Figure
Figure 4.12: Heat map of correlation values
In a scatter the independent variable is plotted on the x-axis, and the
dependent variable is plotted on the y-axis. Scatter plots show the extent of
correlation, if it exists, between the attributes. Let’s plot using the following
code:# Scatterplot
ax =
Stress vs. Work-Family
plt.show()
The preceding code generates the scatter plot shown in Figure
Figure 4.13: Scatter plot of Job Stress versus Work family Conflict
In Figure we can see that there is one very high value that is not giving us a
good view of the entire data. This is an outlier value. Let us remove this value
and plot the values again. There will be an impact on the correlation value;
we will see that later in this section:
# Let's use .loc to restrict values of 'WorkFamilyConflict' displayed
manager_df =ax =
Stress vs. Work-Family
plt.show()
Figure 4.14: Scatter plot of Job Stress versus Work family Conflict after
removing the outlier value
Figure 4.14 shows the updated scatter plot. We can see a slightly positive
trend but not big enough to conclude that there is a high positive correlation
value. Later, we will calculate the Pearson Correlation constant to check the
value, as indicated in Figure Before that, we will also learn to plot the best-fit
line and see the trend.
Visualize the data
As discussed earlier, a scatter plot visualizes the correlation concept. Let us
see the possible types of correlation shown by a scatter plot. Refer to Figure4.15 to know the behavior of correlation:
Figure 4.15: Types of Correlation shown by Scatter plots
Best-fit line gives a trend based on all the scatter plot points. Let us see the
Python code for plotting the scatter plot along with the best-fit line below:
# Adding a best fit line
data=manager_df)
Stress vs. Work-Family
plt.show()
Figure 4.16 shows the scatter plot with the best-fit line:Figure 4.16: Scatter plot with best-fit line for WorkFamilyConflict v
JobStress
There is a small positive trend visible in the best-fit line shown in the scatter
plot in figure 4.16. Let us add a third dimension as a hue to the scatter plot.
Hue is to group similar attributes and represent them in the same color. The
following code use Hue concept to group similar values using this Python
code:
# Adding FamilySupportScore as a third dimension
Stress vs. Work-Family
plt.show()The preceding code will result in a scatter plot as shown in Figure 4.17 along
with the Hue value:
Figure 4.17: Scatter plot with Hue
Summarize the outcome
Pearson correlation coefficient is also known as Pearson’s r. It is a measure of
linear correlation between two given variables. Calculated as the ratio
between the covariance of two variables and the product of their standard
deviations, it is essentially a normalized measurement of the covariance. The
result will always have a value between −1 and 1. Let us calculate the
Pearson’s correlation of our dataset:
# Coefficient of correlation
from scipy.stats import pearsonrcorr, _ =
correlation: %.3f' % corr)
Figure 4.18 shows the correlation value to be around 0.265:
Figure 4.18: Correlation value for WorkFamilyConflict v JobStress
Earlier while plotting the heatmap, it was 0.588 but removing that one outlier
value reduced the correlation value to 0.265. Such a low value (less than 0.5)
indicates an extremely weak correlation between job stress and work-family
conflict and it is not possible to predict job stress based on work-family
conflict.Data analysis and Business outcome
In the previous example, we created and analyzed a problem with a scatter
plot. Another plot that is widely used in data analytics is histogram. We
discussed frequency distribution and seen a small example in demonstrated in
the plot in Figure Let us simulate a business problem where we will use a
histogram to solve it:
Let us assume you are the marketing manager of a large telephone service
provider. You want to analyze your customers’ international call charges, so
you randomly select 200 customers and note their monthly bill amount. You
want to extract meaningful data to help you make strategic decisions for the
company. Let us look at the data by reading through Python code and later
analyze my approach for the analysis.
Get the data
The dataset has been uploaded to the GitHub location mentioned earlier. The
numbers are in US$. Let’s use Python code to read the dataset as Pandas
dataframe:
import numpy as np
arr =
Figure 4.19 shows a part of the dataset:Figure 4.19: Sample from the dataset
Exploratory data analysis
There is very little information we can get by reading 200 observations. You
will probably notice that the highest value is $119.63 and the lowest is 0.0,
but this is not enough to make any meaningful decision. You can construct a
frequency distribution and then a histogram plot from it. Let’s look at the
code for constructing the histogram:
import matplotlib.pyplot as plt
#create bin
bin = * i for i in
# plot histogram
plt.hist(arr, bin)
plt.show()
Refer to Figure 4.20 for how the histogram would look with the data we have:Figure 4.20: Histogram
Observation
Histogram gives a clear view of how observations are distributed. Let us
divide the customers into three groups: i) small – those whose bill is less than
$30, ii) medium – those whose bill is between $30 and $90, and iii) high –
those whose bill is above $90. Refer to Figure 4.21 to see the different groups
we have created:Figure 4.21: Observation of data points from Histogram plot
Interpretation
It requires domain knowledge to interpret such results. Let us suppose the
same data was being analyzed by the marketing manager of a retail store;
they would be disappointed to know that only 30% of their customers shop
big. They would make plans like Buy One Get One to encourage customers to
move from small to medium and to high-value purchases. But since in this
case we are talking about a telephone service provider, their focus will be
these high customers. These high-paying customers are easy targets for their
competitors to snatch away by offering cheaper plans. So, for a telecom
provider, the priority is to move these high bills payers into the medium
group to retain them in the business. That is precisely why you will notice so
many plans by companies; the goal is to offer something for everyone.Working with GitHub
GitHub is a cloud-based application providing services for storing and
sharing source code with fellow programmers. Using Visual Studio Code (VS
Code) with GitHub allows for sharing and collaboration on source code
directly within the editor. One can interact with GitHub in multiple ways, for
example, via their website at github.com or the Git Command-Line Interface
But by using the GitHub pull requests and issues extension, one can directly
work with GitHub from the editor. In this section, we will learn the following:
How to add an existing VS Code project to git and GitHub
How to do commit and push whenever changes happen
How to clone an existing project from GitHub to VS Code
How to remove project to git
Let us get started:
Install Git
VS Code leverages local installation of Git, so the users need to install Git
before performing any action. Minimum requirement is to have at least Git
2.0.0 version. We will use the git command-line interface, which can be
downloaded from the following:
https://git-scm.com/book/en/v2/Getting-Started-Installing-GitFollow the instructions to download and install it on your Mac or PC. You
can check the version of your Git using the following command. Any version
more than 2.0.0 is good for us to continue:
Figure 4.22: Check the Git version
Create a GitHub account
Go to github.com and sign up if you do not have an account already:
Figure 4.23: Creating new account on Github
Create a repository on GitHubNow we create a repository for our project. On the top left, you will see the
New button; click on it. You can do the same by clicking on the + sign in the
top-right corner and then clicking New
Figure 4.24: Showing two options to create a new repository
This will open the form to add values to create the repository, as shown in
FigureFigure 4.25: Add details to create a new repository
Give a name to your repository; a description is optional. Select the default
Public option so that it can be shared with everyone. We have created
BookPythonAppsOnVSCode for our examples. Initializing the project with a
README file is always a good practice.
Install the GitHub Pull Requests and Issues extension:
Accessing GitHub without leaving VS Code becomes easier with the GitHub
Pull Requests and Issues extension.Figure 4.26: Github Pull Requests and Issues Extension
We already discussed how to install extensions in the previous chapter.
Follow the same steps that we discussed in Chapter 3, Top Extensions in VS
Code for for installing extensions for VS Code, and install the GitHub Pull
Requests and Issues extension on your VS Code editor.
First, one has to sign into the GitHub Pull Requests and Issues extension. You
can log in by following the prompts to authenticate with GitHub in the
browser and return to VS Code. Authentication can also be done by adding an
authorization token manually. The authorization token can be in the browser
window; copy this token and switch back to VS Code. Select Signing into
github.com in the status bar, paste the token, and hitHow to set up a repository?
A user can set up a repository by searching for and cloning a repository from
GitHub using the Git: Clone command in the Command Palette It can also be
done by clicking the Clone Repository button in the source control view. The
source control view will show up only when you have no folder open. Refer
to Figure
Figure 4.27: Connecting to Github repositoryFilter and pick the repository cloned locally from the GitHub repository
dropdown or directly type the path. If you have not logged into GitHub from
VS Code earlier, you will be prompted to authenticate with your GitHub
account before proceeding. You can provide the repository URL directly or
search GitHub for the repository you want by typing in the text box. Figure
4.27 indicates the place where you need to add the repository location:
Figure 4.28: Typing the Github repository location
The VS Code window will reload the repository once you have selected a
repository or made a pull request. You will see the repository contents in the
File Now, you can open files (with full syntax highlighting and bracket
matching), make edits if required, and commit changes, much like you would
working on a local repository clone. Refer to the following figure:Figure 4.29: Saving program directly to the Github remote repository
However, there is one difference you will notice here. When a change is
committed with the GitHub repository extension installed in VS Code, the
changes are pushed directly to the remote repository, similar to working in the
GitHub web interface. Another feature of the GitHub repositories extension is
that every time you open a repository or branch, you are presented with the
up-to-date sources available from GitHub. This eliminates the need to
remember to make a pull to refresh, as we would do with a local repository.
Refer to Figure
Figure 4.30: Github branch indication
VS Code provides another advantage: we can easily switch between branches
by clicking on the branch indicator in the status bar, without needing to stash
uncommitted changes. The extension remembers the changes and reapplies
them when you switch branches.
Sometimes you will want to switch to working on a repository in a
development environment with support for a local file system and full
language and development tooling. The GitHub repositories extension makes
it easy for you to do the following:
Clone the repository locallyCreate a GitHub codespace, if there is the GitHub codespaces extension
Clone the repository into a Docker container, if you have Docker and the
Microsoft Docker extension installedConclusion
We have come to the end of the chapter! We found it interesting to write
this chapter as we love working through data and making sense of it. We
reviewed some Python concepts, like Numpy, Scipy, Pandas, and
Matplotlib. We also introduced you to basic statistical concepts and helped
you learn to plot using Matplotlib. We analyzed sample datasets to
practice two important data analytics concepts: scatter plot and histogram.
In the last section, you learned to use GitHub with VS Code.
In the next chapter, we will see how to connect to Databases from Python
and develop a desktop-based application. You will also be introduced to
MYSQL concepts and learn to debug a Python program on VS Code.
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the
Authors:
https://discord.bpbonline.comChapter 5
Developing Desktop Application using Database
Errors using inadequate data are much less than those using no data at all.
— Charles BabbageIntroduction
This chapter will teach us to develop an application using database skills.
Databases are an important part of any application and provide a way of
storing and managing efficient and secure data. This chapter will explore
the fundamentals of working with a database application.
Database design is the process of creating a detailed data model of a
database. It defines the logical structure of a database and determines how
data will be stored, organized, and accessed. Database design involves
classifying data and identifying relationships among the data items. The
goal of database design is to produce a model that correctly represents the
data and is flexible, efficient, and easy to maintain.
We will look at the different types of databases, the different ways of
accessing them using Python, and the tools Python provides to manage the
database. We will also examine the basics of designing and implementing
a database application. Finally, we will discuss the importance of testing
and maintaining a database application.Structure
In this chapter, we will discuss the following topics:
Database introduction and RDBMS
Problem statement: Developing an application
Working with MYSQL
Executing the Project: Performing CRUD operations
Debugging in VS CodeDatabase introduction and RDBMS
A database is a data collection organized for easy storage, access, and
manipulation. It is usually managed by a Database Management System
which provides users with a systematic way to create, retrieve, update, and
manage data. The data in a database is typically organized into tables,
fields, and records.
There are different types of databases in use; some of them are as follows:
Relational This type of database stores data in structured tables with rows
and columns. It follows a predefined schema and uses Structured Query
Language for querying and managing data. Examples include Oracle,
MySQL, and SQL Server.
Object-oriented This type of database stores data in objects, which can
contain both data and behavior. It is useful for storing complex,
interconnected data structures and supports inheritance and
polymorphism. Examples include MongoDB and Couchbase.
Hierarchical This type of database organizes data in a tree-like structure,
with parent-child relationships between data elements. It is mainly used
for storing hierarchical data, such as file systems. Examples include
IBM’s Information Management System and Windows Registry.
Network This type of database stores data with complex relationships,
using a network data model. It is similar to the hierarchical database butenables more flexible relationships between data elements. Examples
include Integrated Data Store and Integrated Definition Language
NoSQL This term refers to a class of databases that do not adhere to a
strict tabular structure, like in relational databases. NoSQL databases are
designed for scalability, high performance, and handling unstructured and
semi-structured data. Some popular types of NoSQL databases are
document databases (example, MongoDB), key-value stores (example,
Redis), columnar databases (example, Cassandra), and graph databases
(example, Neo4j).
Time-series This type of database is optimized for handling time series
data, which is data that is recorded with a timestamp. It is commonly used
in fields like financial services, IoT, and log analysis to store and analyze
large volumes of time-stamped data efficiently. Examples include
InfluxDB and TimescaleDB.
Graph This type of database is designed to store and analyze highly
interconnected data, such as social networks, recommendation engines,
and fraud detection systems. It stores data as nodes (entities) and edges
(relationships), allowing efficient traversal and querying of complex
relationships. Examples include Neo4j and Amazon Neptune.
Spatial This type of database is specialized for storing and querying
spatial or geographic data. It supports indexing and analysis of 2D and 3D
data types, such as points, lines, polygons, and spatial relationships.
Examples include PostGIS and Oracle Spatial.In-memory This type of database stores data entirely in memory, rather
than on disk, for faster access and processing. It is used in situations
where speed is crucial, such as real-time analytics and high-speed trading.
Examples include SAP HANA and VoltDB.
Cloud This term refers to databases that are hosted and provided as a
service through a cloud computing platform. These databases are scalable,
highly available, and accessible from anywhere via the internet. Popular
examples include Amazon Web Services RDS, Microsoft Azure Cosmos
DB, and Google Cloud Firestore.
In this chapter, we will develop an application with Relational Database
Management Systems RDBMSes are used to store and manage data in
structured tables. They are popular because they offer the ability to easily
query data, join data from multiple tables, and enforce data integrity. They
also offer features such as transactions, data security, and scalability.
Relational databases are used in many applications, such as financial
systems, customer relationship management systems, and e-commerce
sites.
Some of the popular RDBMS databases are as follows:
Oracle
MySQL
Microsoft SQL Server
PostgreSQLIBM DB2
MariaDB
Sybase
Informix
Firebird
Apache Derby
In this chapter, we will develop a working Library Management System
with MYSQL database as the back end. MySQL is an open-source
Relational Database Management System that uses Structured Query
Language to add, access, and manage data. It is one of the most popular
databases in the world and is used in a wide range of applications, from
small web applications to large enterprise applications. Many popular
websites, including Facebook, Google, Twitter, and YouTube, also use
MySQL.Problem statement: Developing an application
Before we begin building the application, let us understand the
requirements. A Library Management System is software used to track
items in a library, such as books, periodicals, audio-visual materials, and
electronic documents. It provides a centralized system for cataloguing,
organizing, and tracking library materials and managing library materials’
circulation to library patrons. Library management systems automate
library activities and processes, such as cataloguing and circulating
materials. In this example, we will develop a mini LMS system with the
following options:
BOOK ISSUE
BOOK DEPOSIT
ADMINISTRATION MENU
CREATE STUDENT RECORD
DISPLAY ALL STUDENTS RECORD
DISPLAY SPECIFIC STUDENT RECORD
MODIFY STUDENT RECORD
DELETE STUDENT RECORDCREATE BOOK
DISPLAY ALL BOOKS
DISPLAY SPECIFIC BOOK
MODIFY BOOK
DELETE BOOK RECORD
EXIT
Let us build an application to implement these features. This is a
comparatively large application to build. We must follow a standard
practice to ensure that we develop the application within the given
timeline and cost and also ensure good quality.
We will follow these steps:
Break the application into Start by breaking it into parts and understanding
how they interact. This will help you map out the application’s structure
and identify which parts require the most development effort. In this
application, we will break the design into the following subcomponents:
Create the menu for the user.Create the database objects required to handle the back end of the system.
Create the required classes and modules that will implement the features.
Identify user Consider how users interact with the application and identify
key user scenarios. This will help you understand which features will be
the most important for your application and help you prioritize
development efforts. We have already created this for our example in the
problem statement section.
Design the Design an architecture for the application that will scale and be
easy to maintain. This includes making design decisions about technology,
hosting, databases, and other core components. In our example, database
design becomes important, so we will spend some time doing that in the
next section.
Develop the Once the architecture is designed, start developing the
application in stages. This will help you identify any problems early on
and make changes as needed. Write the code for each of the features
identified.
Test the Test the application thoroughly before releasing it to users. This
will help ensure that the application is stable and any bugs are identified
and fixed.
Monitor and maintain the Monitor the application regularly and make
changes as necessary. This will help keep the application running
smoothly and ensure that any new features or changes are implemented
correctly.Now that we understand the various steps, let us dive into them.Developing the solution
We have created a file named which will be our main file. Let us first
build the and then we will connect the different functions and methods to
them. We will use the infinite loop concept till the user wants to keep
running the menu:
def adminmenu():
the Option from
1. CREATE
2. DISPLAY ALL
3. DISPLAY SPECIFIC
4. MODIFY STUDENT
5. DELETE STUDENT
6. CREATE
7. DISPLAY ALL
8. DISPLAY SPECIFIC
9. MODIFY BOOK
10. DELETE BOOK
11. TAKE BACK TO THE MAIN
adminchoice = your choice from the above:
if adminchoice ==
return True
elif adminchoice ==
return True
elif adminchoice ==
return True
elif adminchoice ==return True
elif adminchoice ==
return True
elif adminchoice ==
return True
elif adminchoice ==
return True
elif adminchoice ==
return True
elif adminchoice ==
return True
elif adminchoice ==
return True
elif adminchoice ==
return False
Choice. Try
return True
def menu():
LIBRARY MANAGEMENT
the Option from
1. BOOK
2. BOOK
3. ADMIN
4. DISPLAY OUT
5.
mainchoice = your choice from the above:
if mainchoice ==
return True
elif mainchoice ==
return True
elif mainchoice ==adm_cont = True
while adm_cont:
adm_cont = adminmenu()
# Admin menu exited but still in main menu
menu()
elif mainchoice ==
return True
elif mainchoice ==
return False
Option Try
return True
# calling mainmenu
cont = True
while cont:
cont = menu()Database design
Database design includes the organization of data according to the business
requirement. The database designer determines what data must be stored and
how these elements interrelate. One of the widely used tools for database
design is the Entity Relationship diagram. An Entity-Relationship Diagram
visually represents different data using standardized symbols and connectors.
It illustrates the relationships between entities, which are used to describe the
structure of a database. ERDs are used to model and design relational
databases, which organize data into tables that can be linked through
relationships.
Here is how to create an ERD:
Identify the entities and their Start by brainstorming for a list of all the major
entities involved in the problem domain. These could include people, places,
organizations, or other things. For each entity, identify the related entities and
their relationships.
Determine the attributes of the For each entity, determine the attributes that
describe it and the data that needs to be stored.
Create a Once the entities and their relationships have been identified, draw
the diagram using a tool like Microsoft Visio.
Validate the Check it to ensure that it accurately reflects the entities,
attributes, and relationships identified.Refine the Make any changes to the diagram based on feedback from
stakeholders or other domain experts.
Let us build ERD for our example:
Figure 5.1: ER diagram for a simple Library Management SystemCreating tables and adding Constraints
Now, convert ER diagram to table objects by following the given steps:
Identify the entities in the diagram
We need to create three tables:
A table to store books information
A table to store students’ information
A table to store transaction details to record who borrowed or returned the
book and when
Create a table for each entity and assign appropriate data types to the
columns.
Let us create three tables, as shown here:
here:
here: here: here: here: here: here: here: here: here: here: here: here:
here: here: here: here:
Table 5.1: List of tables and their columnsThese are the minimum set of columns to design our database effectively.
Identify the relationships in the diagram.
Tables BOOKS and STUDENTS may not be directly related here, but the
TRANSACTIONS table needs to connect to BOOKS and STUDENTS to
make sure relevant information is only saved as transactions.
Create foreign keys in the appropriate tables to represent the relationships.
In this example, only TRANSACTIONS table will have foreign keys.
BOOKID should be linked to BOOKS.BOOKID, and MEMBERID
should be linked to STUDENTS.MEMBERID.
Generate the table objects in your database using the appropriate SQL
commands.
Table 1: To store students’ information.
Name: STUDENTS
Columns: MemberID, Name, Email, Phone, JOIN_DATE (Default
today’s)
SQL Query to Create TableCREATE TABLE STUDENTS(MEMID INTEGER PRIMARY KEY,
NAME VARCHAR2(30),
EMAIL VARCHAR2(25),
PHONE VARCHAR2(12),
JOIN_DATE DATE DEFAULT (CURRENT_DATE))
Add initial set of data if available.
Let us add some data to both the STUDENTS and BOOKS tables so that
we have some data to begin working with:
INSERT INTO STUDENTS(NAME,EMAIL,PHONE)
VALUES('Sachin','sachin@email.com','346377');
INSERT INTO STUDENTS(NAME,EMAIL,PHONE)
VALUES('Virat','virat@email.com','544343466');
INSERT INTO STUDENTS(NAME,EMAIL,PHONE)
VALUES('Dhoni','dhoni@email.com','5645654');
INSERT INTO STUDENTS(NAME,EMAIL,PHONE)
VALUES('Kapil','kapil@email.com','4576457');
INSERT INTO BOOKS(TITLE,AUTHOR,COPIES) VALUES('Learn and
Practice Python','Swapnil Saurav',3);
INSERT INTO BOOKS(TITLE,AUTHOR,COPIES) VALUES('Learn and
Practice SQL','Swapnil Saurav',3);INSERT INTO BOOKS(TITLE,AUTHOR,COPIES) VALUES('Learn and
Practice Data Visualization','Swapnil Saurav',3);
INSERT INTO BOOKS(TITLE,AUTHOR,COPIES) VALUES('Learn and
Practice Machine Learning','Swapnil Saurav',3);Working with MYSQL
MySQL is a relational database management system used for accessing and
managing records in a database. In this section, we will understand how
MYSQL can be installed with VS Code, connecting from VS Code to
MySQL using Python, and running the tables and insert queries we created in
the previous section.
Let us look at the steps to download and install MySQL server on your local
machine running on Microsoft:
Download MySQL installer from https://dev.mysql.com/downloads/installer/
and execute it.
Choose the appropriate setup type for your system. Typically, you will choose
Developer Default to install MySQL server and other MySQL tools related to
MySQL development, helpful tools like MySQL workbench.
Complete the installation process by following the instructions. This will
install several MySQL products and start the MySQL server.
Get more details from
Here are the details we have used:
Servername: MySQLServer 8.0.17
Username: rootPassword: learnSQL
MYSQL Workbench is one of the tools that would be very helpful to us.
Figure 5.2 shows how the MYSQL workbench looks:
Figure 5.2: Important options in MySQL Workbench
Let us create a Schema titled where we will create all our database objects.
This can be done by clicking the Create a new Schema in the connected
server option, as shown in Figure
MYSQL server is installed and database schema is created, so we are all set
from the MYSQL side. Now, let us focus on VS Code. Refer to the following
steps to connect to MySQL Server using VSCode:
In the VS Code, Go to Extensions and search for the MySQL extension. Open
the extension called MySQL Management Tool and install it, as shown in thefollowing figure:
Figure 5.3: MySQL Management tool
MYSQL is now added to explorer. You can check by clicking on explorer
option (first option on the left of your VS Code screen or by clicking Ctrl +
Shift + E). Now, navigate to the MYSQL section and click on the + sign. It
will ask you to enter the following details:
host: localhost
user: root
password: learnSQL
port: 3306
certificate file path: leave it blank
All the information is now saved and would appear as shown in FigureFigure 5.4: MySQL connected to VS Code
We can see the libraryms schema in the list when we expand; it is the same
schema we created in the last section. Schema in MySQL is a logical
collection of database objects such as tables, views, stored routines, and
triggers. A schema is associated with a single database and contains all tables
and other objects for that particular database. MySQL allows multiple users
to have their schema, and each user is allowed to have their schema that is
completely isolated from other schemas. As a root user, we can access all
databases.
You can directly manage MYSQL as a root user, but we intend to execute
SQL commands using Python code. We will create another file called sql.py
and perform all the database-related queries from here.
We need to install and import pymysql library. PyMySQL is a pure-Python
MySQL client library that provides us with functions to connect to the
database. Also, we will declare a global variable with a database name as
To use the pymysql library in Python, you need to follow these steps:
Install the pymysql library using pip:
$ pip install pymysql
Import the pymysql module in your Python script:
import pymysqlEstablish a connection to the MySQL database by specifying the host, user,
password, and database:
connection = pymysql.connect(host='localhost', user='root',
password='password', database='mydatabase')
Replace localhost with the hostname of your MySQL server, root with the
MySQL username, password with the MySQL password, and mydatabase
with the name of your database.
Create a cursor object to execute SQL queries:
cursor = connection.cursor()
Execute SQL queries using the cursor object:
cursor.execute("SELECT * FROM mytable")
Fetch the results of the query in case of SELECT:
results = cursor.fetchall()
You can access the rows of the query result using the results variable.
Close the cursor and connection:
cursor.close()connection.close()
It’s important to close the cursor and connection to free up resources. Now,
let us see the code relevant to us:
import pymysql
db_name = "libraryms"
We will add the first function, to this file. This function will also call for
database interaction from all other files. This file will take the database name,
query and values, which would be for holding dynamic query values in tuple
format. Dynamic query in SQL is a type of query that is generated at runtime
based on program variables or user input. It enables generating different SQL
statements on the fly rather than being pre-defined in the code. This makes
building applications that can respond to changing requirements or user input
easier. Let us look at an example of how dynamic query is implemented in
MYSQL:
sql = "SELECT 'id', 'password' FROM 'users' WHERE 'email'=%s and
id=%d"
cursor.execute(sql, ('contact@mysite.com',121))
In the preceding query, id and password will be displayed for dynamic values
of id and Since email is of string type, we say email = whereas we say id=%d
because it is of integer type. Values in a tuple are then passed as separate
parameters in the execute method.The following is the complete code for
from datetime import datetime
import pymysql
def perform_db_actions(db_name, query):
'''This function will be called for any kinds of
database interaction from all other files as well.
@db_name: the name of the database
@query: the query to be executed
@values: the values for dynamic query in tuple format
returns: Select query will return the recordset, other queries will return none
'''
connect =
cursorobj = connect.cursor()
data = []
data = cursorobj.execute(query)
data = cursorobj.fetchall()
connect.commit()
cursorobj.close()
return data
Now, we create another function that will execute the CREATE table and the
INSERT commands we created earlier during database design:
from datetime import datetime
def create_db(db_name):'''One time create database queries'''
# Table 1 Students getting created
t1 = '''Create table STUDENTS(
MEMID INTEGER PRIMARY KEY AUTO_INCREMENT,
NAME VARCHAR(30),
EMAIL VARCHAR(15),
PHONE VARCHAR(12),
JOIN_DATE DATE DEFAULT (CURRENT_DATE))'''
# call DB action
perform_db_actions(db_name, t1)
t2 = '''Create table BOOKS(
BOOKID INTEGER PRIMARY KEY AUTO_INCREMENT,
TITLE VARCHAR(30),
AUTHOR VARCHAR(15),
PUBLISHER VARCHAR(15),
PRICE REAL,
COPIES SMALLINT)'''
perform_db_actions(db_name, t2)
t3 = '''Create table TRANSACTIONS(
TID INTEGER PRIMARY KEY AUTO_INCREMENT,
BOOKID INTEGER REFERENCES BOOKS(BOOKID),
MEMID INTEGER REFERENCES STUDENTS(MEMID),
ISSUE_DATE DATE,
RETURN_DATE DATE)'''
perform_db_actions(db_name, t3)
add_students = ['''INSERT INTO STUDENTS(NAME,EMAIL,PHONE)
VALUES('Sachin','sachin@em.com','346377')''',
'''INSERT INTO STUDENTS(NAME,EMAIL,PHONE)
VALUES('Virat','virat@em.com','544343466')''','''INSERT INTO STUDENTS(NAME,EMAIL,PHONE)
VALUES('Dhoni','dhoni@ema.com','5645654')''',
'''INSERT INTO STUDENTS(NAME,EMAIL,PHONE)
VALUES('Kapil','kapil@ema.com','4576457')''']
for q in add_students:
perform_db_actions(db_name, q)
add_books = ['''INSERT INTO BOOKS(TITLE,AUTHOR,COPIES)
VALUES('Practice Python','Swapnil Saurav',3)''',
'''INSERT INTO BOOKS(TITLE,AUTHOR,COPIES) VALUES('Practice
SQL','Swapnil Saurav',3)''',
'''INSERT INTO BOOKS(TITLE,AUTHOR,COPIES) VALUES('Practice
Data Visualization','Swapnil Saurav',3)''',
'''INSERT INTO BOOKS(TITLE,AUTHOR,COPIES) VALUES('Practice
Machine Learning','Swapnil Saurav',3)''']
for q in add_books:
perform_db_actions(db_name, q)
print("Your data has been created successfully!")
if __name__ == "__main__":
create_db("libraryms") #Onetime
We will return to it later and add main menu functions for ISSUE_BOOKS
and RETURN_BOOKS. For now, we will move to creating Students and
Books classes.Students class
Let’s create another Python file titled and we will implement methods
specific to Students like add display student display specific student
update student record and delete student
In the create_student method, we will get all the information from the
user, form a dynamic query, and pass it on to the perform_db_actions() to
create a new student record. That is why we need to import
The Display_all() and Display_specific() functions will display all the
data about students. The only difference is that display_specific() will ask
for the member ID before firing the select command.
Modify_student() is little tricky as we do not know beforehand which
column value to change, so it has been implemented to display all the
values one by one, and then the user can choose specific columns to
change and provide new values.
Delete_student() is another simple function that deletes the given record
from the Students table.
The following is the complete code for your reference:
""" Students Example"""
import sql
import datetime as dtclass
"""Class for Students Example"""
def dbname):
""" Initialize the class """
= dbname
def
""" Create a new student record """
name = the name of the student:
email = the email id of the student:
phone = the phone of the student:
query = f'''INSERT INTO STUDENTS(NAME, EMAIL, PHONE)
query)
added Student record to the
def
""" Display all the student records in the database"""
query = '''SELECT * FROM STUDENTS'''
rows = query)
in the
for student in rows:
def
""" Display the details of a specific student record """
memid = the Membership ID of the the student:
query = f'''SELECT * FROM STUDENTS WHERE memid =
rows = query)
for student in rows:
def"""Modify the details of a specific student record"""
memid = the Membership ID of the student record to be updated:
query = f"SELECT name, email, phone FROM STUDENTS WHERE
memid =
rows = query)
if rows:
cols =
update_query = "UPDATE STUDENTS SET"
if >
for i, col in
is
ch = y to modify:
if ch.lower() ==
inp = the new
update_query += f" =
if >
update_query = + f" WHERE memid =
rows = update_query)
has been
to
such data
def
""" Delete a specific student record """
memid =the Membership ID of the student record to be deleted:
query = f'''SELECT memid FROM STUDENTS where memid =
rows = query)
if ==
such data
query = f'''DELETE FROM STUDENTS WHERE memid =
query)
studentBooks class
Let us create another Python file titled and we will implement methods
specific to like add books, display books, display specific book, update
books, and delete books.
In the create_book method, we will get all the information from the user,
form a dynamic query and pass it on to the perform_db_actions() to create
the record. That is why we need to import
The Display_all() and Display_specific() functions will display all the
data about books. The only difference is that display_specific() will ask
for the Book ID before firing the select command.
Modify_book() is little tricky as we do not know beforehand which
column value to change, so it has been implemented to display all the
values one by one, and then the user can choose specific columns to
change and provide new values.
Delete_book() is another simple function that deletes the given record
from books table.
The following is the complete code for your reference:
""" Books Example"""
import sql
class""" Books Class"""
def dbname):
""" Initialize books class"""
= dbname
def
""" Create a new book record """
title = the Title of the Book:
author = the Author name of the Book:
publisher = the Publisher of the Book:
price = the Price id of the Book:
copies = the Copies of the Book:
query = f'''INSERT INTO BOOKS(title, author, publisher, price, copies)
query)
added book record to the
def
""" Display all the books in the database """
query = '''SELECT * FROM BOOKS'''
rows = query)
available in the Library
for book in rows:
def
""" Display a specific book record """
book_id = the ID of the Book:
query = f'''SELECT * FROM BOOKS WHERE bookid =
rows = query)
for book in rows:def
"""Modify the details of a specific book record"""
bid = the ID of the book record to be updated:
query = f"SELECT title, author, publisher, price, copies FROM BOOKS
WHERE bookid =
rows = query)
if rows:
cols =
update_query = "UPDATE BOOKS SET"
if >
for col, value in
is
ch = y to modify:
if ch.lower() ==
if col in # string values
inp = the new
update_query += f" =
elif col in # numeric values
inp = the new
update_query += f" =
if >
update_query = + f" WHERE bookid =rows = update_query)
has been
to
such data
def
""" Delete a specific book record"""
book_id = the ID of the Book record to be deleted:
query = f'''SELECT bookid FROM BOOKS WHERE bookid =
rows = query)
if ==
such data
else :
query = f'''DELETE FROM BOOKS WHERE bookid =
rows = query)Executing the project: Performing CRUD operations
CRUD stands for Create, Read, Update, and Delete. It is a set of
operations that are commonly used in database management systems to
manipulate data. CRUD operations are the fundamental operations used in
database systems:
The Create operation enables users to create new records in the database.
This operation can be used to add new data to existing tables or create
new tables. In order to successfully create records, users must be aware of
the database structure and must have the appropriate permissions to add
new records.
The Read operation enables users to retrieve existing records from the
database. This operation is used to access existing data and can be used to
search for specific records or display all records in a table.
The Update operation enables users to modify existing records in the
database. This operation can be used to modify existing data or to add new
data to existing records. In order to successfully update records, users
must be aware of the database structure and must have the appropriate
permissions to modify existing records.
The Delete operation enables users to delete existing records from the
database. This operation can be used to delete existing data or to remove
records from a table. In order to successfully delete records, users must be
aware of the database structure and must have the appropriate permissions
to delete existing records.CRUD operations are essential for database systems as they enable users
to create, read, update, and delete data. These operations are the basic
building blocks for database operations and are used by developers and
administrators to manage data.
Before we execute, let’s add three more functions to the SQL module,
which we will use to perform CRUD operations.
The check_outbooks() function will check the transactions table in the
database and pick up the ones that do not have return dates and then
display them. Return value null indicates that the book has still not been
returned to the library. Let’s implement the check_outbooks() function
now:
def check_outbooks(db_name):
list of
heading = 'Member 'Book 'Issue
q1 = '''Select tid,memid,bookid,issue_date from transactions where
return_date is null'''
rows = perform_db_actions(db_name, q1)
if rows ==
books is pending for
for r1 in rows:
The issue_book() function will take the MemberID and the and if there are
enough copies of the book left in the library, it will update the Transaction
table to indicate that the book has been issued to the student. This will
decrease the count of total number of copies by one:def issue_book(db_name):
memid = the Member ID:
bookid = the Book ID:
book_count =
# checking if MEMID in the database
q1 = '''Select MEMID from Students where MEMID = %d''' % (memid)
row1 = perform_db_actions(db_name, q1)
# checking if BOOKID in the database and if yes then get the count
q1 = '''Select Copies from Books where bookid = %d''' % (bookid)
row2 = perform_db_actions(db_name, q1)
if < 1 or <
Either BookID or Membership ID is missing, please check and re-try
elif <
There are no more copies left in the
#print(" ======== ", datetime.now().strftime('%d-%m-%Y'))
book_count =
q2 = '''INSERT INTO
TRANSACTIONS(MEMID,BOOKID,ISSUE_DATE)
VALUES(%d,%d,'%s')''' % (memid, bookid,
perform_db_actions(db_name, q2)
# update the copies
q2 = '''Update Books Set Copies = %d where BookID=%d''' % (
bookid)perform_db_actions(db_name, q2)
issued the
The return_book() function will update the database as the book is
returned. It will add the return date to the database and update the number
of copies in the books table:
def return_book(db_name):
check_outbooks(db_name)
given_id = are the list of transactions for borrowed book. "
"Enter the transaction id alone or Membership ID,Book ID:
val1 = 0
tid =
bookid =
if ',' in given_id:
ID and Books ID
val1 =
=
=
val1 =
q1 = '''Select tid from Transactions where memid=%d and bookid= %d
and return_date is null ''' %
rows = perform_db_actions(db_name, q1)
if >=
tid =
bookid =Could not find the given
ID
val1 =
q1 = "Select tid, bookid from Transactions where return_date is null and
tid=%d" % (
val1)
rows = perform_db_actions(db_name, q1)
if >=
tid = val1
bookid =
Could not find the given
except
Data not found/Error Occurred! Please try
the
# increase copies count
q1 = "Select Copies from Books where bookid=%d" % (bookid)
rows = perform_db_actions(db_name, q1)
q1 = "Update Books Set Copies =%d where Bookid=%d" % (
bookid)
perform_db_actions(db_name, q1)
# update transaction
q1 = '''Update Transactions Set return_date = '%s'
where tid =%d''' % tid)
rows = perform_db_actions(
db_name, q1)
recordsLet us go to our main file MyLMS.py and update the code with function
and method name. This is how the MyLMS.py file will look:
import ClassStudents
import ClassBooks
import sql
DB_NAME = "libraryms"
def adminmenu():
print("\n\nADMIN MENU")
print("Select the Option from below:")
print("\n\tAdmin 1. CREATE STUDENT")
print("\tAdmin 2. DISPLAY ALL STUDENTS")
print("\tAdmin 3. DISPLAY SPECIFIC STUDENT")
print("\tAdmin 4. MODIFY STUDENT RECORD")
print("\tAdmin 5. DELETE STUDENT RECORD")
print("\n\tAdmin 6. CREATE BOOK")
print("\tAdmin 7. DISPLAY ALL BOOKS")
print("\tAdmin 8. DISPLAY SPECIFIC BOOK")
print("\tAdmin 9. MODIFY BOOK RECORD")
print("\tAdmin 10. DELETE BOOK RECORD")
print("\tAdmin 11. TAKE BACK TO THE MAIN MENU")
adminchoice = input("Enter your choice from the above: ")
if adminchoice == "1":
s1.create_student()
return True
elif adminchoice == "2":
s1.display_all()
return Trueelif adminchoice == "3":
s1.display_specific()
return True
elif adminchoice == "4":
s1.modify_student()
return True
elif adminchoice == "5":
s1.delete_student()
return True
elif adminchoice == "6":
b1.create_book()
return True
elif adminchoice == "7":
b1.display_all()
return True
elif adminchoice == "8":
b1.display_specific()
return True
elif adminchoice == "9":
b1.modify_book()
return True
elif adminchoice == "10":
b1.delete_book()
return True
elif adminchoice == "11":
return False
else:
print("Invalid Choice. Try again!")
return True
def menu():print("\n\n\n LIBRARY MANAGEMENT SYSTEM")
print("Select the Option from below:")
print("\n\tOption 1. BOOK ISSUE")
print("\tOption 2. BOOK DEPOSIT")
print("\tOption 3. ADMIN MENU")
print("\tOption 4. DISPLAY OUT BOOKS")
print("\tOption 5. EXIT")
mainchoice = input("Enter your choice from the above: ")
if mainchoice == "1":
sql.issue_book(DB_NAME)
return True
elif mainchoice == "2":
sql.return_book(DB_NAME)
return True
elif mainchoice == "3":
adm_cont = True
while adm_cont:
adm_cont = adminmenu()
# Admin menu exited but still in main menu
menu()
elif mainchoice == "4":
sql.check_outbooks(DB_NAME)
return True
elif mainchoice == "5":
return False
else:
print("Invalid Option Try Agin!")
return True
# Creating objects
# creating object of ClassStudentss1 = ClassStudents.Students(DB_NAME)
# creating object of ClassBooks
b1 = ClassBooks.Books(DB_NAME)
# calling mainmenu
cont = True
while cont:
cont = menu()
We have successfully implemented a mini library application using
MYSQL database—another topic under our belt.Debugging in VS Code
Debugging is an important part of programming, as it helps identify and
remove any errors or bugs from the code. This helps ensure that the code runs
as expected, without any unexpected behavior or errors. We generally come
across three types of errors in programming:
Syntax This is easiest of all the errors to identify. This is because Python is
designed so well and the error messages are very well commented, which
helps us know where and what went wrong in terms of syntax.
Runtime Runtime errors are mistakes that occur during the execution of a
program and can cause the program to crash or produce incorrect results. For
example, trying to convert text containing alphabets into an integer or
dividing a number by zero.
Logical These are the mistakes in a program’s source code that result in
incorrect or unexpected program behavior. These errors are caused by a
programmer’s incorrect assumptions or misunderstandings about the
program’s environment, or by mistakes in the program’s logic.
Logical and runtime errors are typically more difficult to detect and fix than
syntax errors, since the program may appear syntactically correct despite the
incorrect logic. This is where programmers need to use their debugging skills
to figure out the piece of code responsible for those errors. VS Code provide
us an option to debug the code.
Here is how to perform debugging of Python code in VS Code:Open the Python File in VS Code.
On the left side of the VS Code window, click the Run and Debug icon
available in the activity bar (keyboard shortcut
Select the Python file option from the drop-down menu, as shown in Figure
5.5. Selecting Python file will open a launch.json file in the editor view. If the
launch.json file has not yet been created, it will prompt you to create one. In
case you get a prompt to create, then click on the create a as shown in Figure
Figure 5.5: Run and Debug option in the Activity Bar
Here is the launch configuration generated for Python debugging:
{
// Use IntelliSense to learn about possible attributes.
// Hover to view descriptions of existing attributes.
// For more information, visit:
[
{
"Python: Currenttrue
}
]
}
Figure 5.6 shows a program in debug mode with breakpoints. In the top-right
corner, we have the Debug toolbar, which performs the actions listed in Table
Figure 5.6: Debugging
Debugging
Debugging Debugging Debugging Debugging Debugging Debugging
Debugging Debugging Debugging Debugging Debugging Debugging
Debugging Debugging Debugging Debugging Debugging Debugging
Debugging Debugging Debugging
Debugging Debugging Debugging Debugging Debugging Debugging
Debugging Debugging Debugging Debugging Debugging Debugging
Debugging Debugging Debugging
Debugging Debugging Debugging Debugging Debugging Debugging
Debugging Debugging DebuggingDebugging Debugging Debugging Debugging Debugging Debugging
Debugging Debugging Debugging Debugging Debugging Debugging
Debugging Debugging Debugging Debugging Debugging Debugging
Debugging Debugging Debugging Debugging Debugging Debugging
Debugging Debugging Debugging
Debugging Debugging Debugging Debugging Debugging Debugging
Debugging Debugging Debugging Debugging Debugging Debugging
Debugging Debugging
Debugging Debugging Debugging Debugging Debugging
Table 5.2: Debug toolbar with their description
Follow the given steps to debug a Python program:
Add a breakpoint to the code by clicking on the left side of the line of code.
Now, click the green Play button to start the debugging process.
When you reach the breakpoint, the debugger will pause the execution,
allowing you to inspect the variables, view the call stack, and step through the
code.
Press the Stop button or Shift + F5 keys to end the debugging session.Conclusion
Python applications can create and manage databases that store data for
various purposes. Python enables rapid development of database
applications due to its comprehensive object-oriented library and ability to
interface with many popular database systems. In the example we covered
in this chapter, we saw how to create a library management system by
connecting to the MYSQL database. Python’s support for database
development also offers advantages like scalability, portability, and
maintainability. Python makes it easy to create database applications that
are secure, efficient, and cost-effective. It can also analyze data, allowing
businesses to gain valuable insights into their data quickly and easily.
Python is an efficient tool for data analysis and processing, so learning to
use a database using Python has become important. Our example uses
Python to connect to databases, create data structures, perform
calculations, and analyze data.
In the last part of the chapter, we learnt to perform debugging in VS Code.
Debugging helps improve the code by identifying potential performance
issues, making it easier to optimize the code. Furthermore, debugging
allows developers to understand the code better and can help them better
understand how it works and why a particular bug is occurring.
The next chapter is about advanced algorithm design. We will introduce
the process of designing, developing, and implementing algorithms for a
given problem. It involves the use of techniques like data structures,
problem-solving techniques, and software engineering principles to create
efficient and effective algorithms. Algorithm design is an essential part ofcomputer science and is used in many applications, such as web
development, artificial intelligence, and data analysis.Chapter 6
Advanced Algorithm Design
An algorithm is like a recipe.
— Muhammad WaseemIntroduction
An algorithm is a set of steps or procedures to solve a problem. Algorithm
design refers to developing a step-by-step approach to solve a problem. In
computing, algorithms process data, improve search results, optimize web
pages, and more. Algorithm design is integral to computer science,
allowing us to solve complex problems efficiently. It involves finding the
right combination of data structures, programming language constructs,
and problem-solving techniques to solve a problem efficiently. It also
involves creating algorithms that are easy to understand and implement.
Algorithms are used to solve various problems, from sorting data to
finding the shortest route for a delivery truck. Typical problems solved
with algorithms include finding the best way for a delivery truck, sorting
data, searching for patterns in data, solving mathematical equations, and
optimizing resources. They are also used in artificial intelligence, data
mining, natural language processing, and robotics.
To learn algorithm design in computing, it is essential to understand the
basics of computer science, including data structures and algorithms,
programming languages, and problem-solving fundamentals. Additionally,
algorithm design and analysis courses can help deepen the understanding
of this topic. It is also essential to practice writing and implementing
algorithms. This is precisely what we will focus on in this chapter. We will
learn the design by practice and cover some of the essential topics under
algorithm design learning.Structure
In this chapter, we will discuss the following topics:
Introduction to algorithm analysis
Divide and conquer
Backtracking
Binary tree
Heaps
Hash table
Graph algorithm
Big-O notation: Methodology for analyzing algorithms
Now, let us dive deep into the topics.Objectives
The objective of learning algorithm design is to develop an understanding
of how to design, analyze, and implement algorithms that solve complex
problems. This includes understanding the fundamental principles of
algorithms, analyzing the complexity of algorithms, and implementing
efficient data structures. This is exactly what this chapter is all about.
Additionally, readers will understand the different approaches to algorithm
design and the different techniques used to implement algorithms. Finally,
readers will learn how to apply the knowledge acquired in algorithm
design to solve real-world problems.Introduction to algorithm analysis
Before we dive into algorithm analysis, let us understand the approach one
should take to solve a problem:
Understand the problem you are trying to solve. Algorithms are used to solve
various issues, so understanding the end goal of using an algorithm is
essential. Let us say that the problem statement is ‘improving the customer
experience when interacting with a company’. We want to determine how to
make the customer experience more efficient, effective, and enjoyable. We
need to find ways to increase customer satisfaction and loyalty, reduce
customer churn, and increase the value of the customer experience. We also
need to find ways to improve the customer journey and make it easier for
customers to see what they need. Then, we need to develop our algorithms to
support the efficient design of the solution.
Identify the data structures and algorithms most appropriate for the problem.
Some of the popular data structures are as follows:
Linked They are data structures that store collections of data elements, called
nodes, where each node contains a reference to the next node in the sequence.
Linked lists are commonly used in algorithm design because they allow
efficient insertion and removal of elements and fast traversal of the list.
Binary They are data structures that store data hierarchically, with each node
in the tree having up to two children. Binary trees are commonly used in
algorithm design because they allow efficient searching and sorting of data.They are a type of data structure that store data as nodes connected by edges.
They are often used in algorithm design because they allow efficient
representation of relationships between data points and can be used to solve
complex problems, such as finding the shortest path between two points.
Hash Data structures store data using a hash function to generate an index for
each data item. They are commonly used in algorithm design because they
allow fast access to data and can be used to store large amounts of data
efficiently.
Analyze the time and space complexity of your algorithm. Its time
complexity will depend on what operations it performs and how it is
implemented. Time complexity is an analysis technique used in computer
science to determine the efficiency of an algorithm. It measures the amount of
time an algorithm takes to run as a function of the input size. The time
complexity of an algorithm helps understand how the algorithm’s
performance will scale with larger inputs. It is used to compare different
algorithms and determine which one is more efficient in terms of time.
Common time complexity notations include O(1) for constant time, O(n) for
linear time, O(n^2) for quadratic time, O(log n) for logarithmic time, and
O(2^n) for exponential time.
Space complexity is another analysis technique used in computer science to
determine the amount of memory an algorithm requires as a function of the
input size. Common space complexity notations include O(1) for constant
space, O(n) for linear space, O(n^2) for quadratic space, O(log n) for
logarithmic space, and O(2^n) for exponential space. It is worth noting that
space complexity can depend on various factors, such as the data structures
used, the recursion depth, and the temporary variables created during the
execution of the algorithm. Therefore, it is important to consider the specific
implementation details when analyzing the space complexity of an algorithm.Design a step-by-step procedure for solving the problem. There are certain
steps to unravel even complex issues:
Identify the problem
Break down the problem into smaller, more manageable pieces
Design an algorithm that solves each piece of the problem
Test the algorithm to make sure it works correctly
Analyze the algorithm for time complexity, memory usage, and other factors
Optimize the algorithm if necessary
Implement the algorithm in a programming language. Convert the algorithm
into Python code and run it.
Test the algorithm to ensure that it produces the expected results. Create test
cases with known input and known output and check whether the output
generated by the program matches our known output.
Document the algorithm and program.
Deploy the program and use it to solve the real-time problems.
Let us follow the mentioned steps to solve a problem:Problem Write a program to find the smallest window in a given string
containing all characters of the other string.
Understand the When a user provides two strings, that is, string and pattern,
the task is to find the main string’s smallest substring containing all the input
pattern’s characters. We need to read all the characters of the given string and
generate all substrings of the string containing the pattern character. And then
we need to print the smallest substring containing all characters of the pattern.
Example
I am on a seafood diet. i see food and i eat it.
fast
Window: seafood diet
The minimum length of the window is 12
All the correct combinations are shown in Figure The smallest substring of
the given string that has the pattern is seafood diet:Figure All the correct combinations, along with the one with the minimum
length highlighted
Data structure required
We will handle the data using a list that will work like a map representing all
possible 256 characters that can be entered in a pattern. The index will be the
character, and the value will be the count. Figure 6.2 shows the map:
Figure Map representing 256 characters
Algorithm
The problem might look easy. You will think of creating all the possible
subarrays (with variable lengths) and then go over each of them, comparing
the pattern. Then, among all the matched ways, you will look for the length,
and the one with the smallest length will be our answer. However, this would
take a lot of time. Regarding time complexity, it will take O(N*N) or to create
different subarrays. Then, searching the pattern would take another resulting
in Time complexity is the time required for an algorithm to complete its task.
The Big O notation is a way to measure the time complexity of an algorithm.
It is expressed as where n is the number of operations required to complete
the algorithm.
In a later section, we will see how Big O notation is used to compare the
relative performance of two algorithms: first algorithm that we just discussed
and the other one is sliding window technique. Sliding window algorithm isthe preferred algorithm in this case because its time complexity of O(N) is
better than
The sliding window technique is an algorithm design technique used to solve
problems involving sequences, such as string matching, by breaking the line
down into small chunks and shifting the piece by a certain number of
elements at a time. The sliding window algorithm sounds complicated, but it
is a window or section formed over parts of your data, and in our case, data is
a string. We move this window in increments over our data to perform some
computation, which would be finding the minimum window substring. This
technique helps find patterns in large datasets and solve problems with time
constraints.
Window or section is a variable length group that starts increasing from
where the first value is met and rises to the point of the last match. We
increase the size of the window by one element at a time. As demonstrated in
Figure we form the window when the first character match is found in the
main string and goes up to the last character match. Here, the first match is
found when a is located at index A window starts to form and increases up to
when t is found. This is one subarray and also a possible solution. Next, we
begin reducing this window by eliminating it from behind till the next match
is found. This time, we get another subarray from index This is another
subarray, and it is a better solution than the first one, as the size of this
subarray is the minimum of what we got so far. We continue to build
windows and change their size until all the elements have been considered.Figure Working of sliding window
Let us do a step-by-step walkthrough of the algorithm using our string and
pattern:
Let us create a map to generate a count of all the characters in the pattern as
we iterate through the main string; we will know how many characters we
have seen. We get F=1, A=1, S=1,
We need a couple of different variables to be used:
To begin with, we will declare i and j pointers, pointing at index = 0.
The variable count will be initialized to the number of unique characters in
the pattern, which we can get from the map. So, we make count = 4 (for
FAST).
Initialize a left and right variable, which will be used to keep track of the
minimum substring positions we come across as we iterate through the string.
The minlength variable is used to keep track of the difference between the
right and left pointer, which will give us the substring from the string.
Initially, we will make it one more than the string length, as it would indicate
a non-efficient solution. The step is illustrated in FigureFigure Variables all initialized
The j pointer will start from index 0 of the main string and stop when there is
a match with the variable in the map. In our case, when j reaches index there
is a match (character A is found). We need to decrease the value of the
character by 1 in the map. If the case value reaches zero, we also decrease
count by 1, now equal to We get A = 0 and We need to continue looking for T
(=1) to find a successful minimum window.
We continue to move the j pointer ahead looking for other characters from the
map. j will continue to move until When j reaches index 8, there is another
match; decrease the count of A by 1, so now it is -1. The count value is not
affected here because it is only decreased when the value in the map reaches
0, not for any other number (-1 in this case).
Now j moves to 10, and there is a match again. This time, the value of S goes
to so count is decreased by 1 and is now 2.
j moves to 12 and the map value of A goes to -2.Now, j moves to 13 and there is a match again. This time, the value of F goes
to zero, so count is decreased by 1 and now it becomes 1.
Now j keeps moving until index 21; T is made 0 and count also becomes That
means we have found a subarray.
Since i is less than it moves till it gets first match (at index 2). Now, count of
matching character A is increased by 1 (to now -1) in the MAP. The
minlength is calculated as a potential solution. Since A is negative, indicating
that there is another A value that will have a shorter subarray. i moves to 10
(A=0, count=0), and now i comes to 12, that is, when A value in map changes
to 1 and count is set to 1. This is the first potential solution (when count
becomes positive). minlength is calculated as 21-12 =9 (j=21, i=12), and the
subarray is
After this, j continues executing, repeating the same steps and finding all
possible subarrays and their corresponding lengths. If the next subarray found
has a length lower than the previous subarray, then current subarray becomes
the potential solution; otherwise, we stick to the previous result. The
algorithm ends when j reaches the end of the
This is how the sliding window algorithm can find the solution within a
single loop; thus, time complexity is
Now, let us implement the mentioned login using Python code:
total_chars = 256
#total 256 all possible characters
def smallestWindow(mainstr, pattern):n =
if n <
return
mp =
# Starting index of ans
start = 0
# Length of ans
ans = n + 1
cnt = 0
# creating map
for i in pattern:
+= 1
if ==
cnt += 1
# References of Window: j will move by each character
#i will be used to remove the duplicate entry
i,j =
# Traversing the window
< n):
# Calculating
-= 1
if ==
cnt -= 1
# Condition matchingwhile cnt ==
if ans > j - i +
# calculating answer.
ans = j - i + 1
start = i
# Sliding I:removing from I
+= 1
if >
cnt += 1
i += 1
j += 1
if ans > n:
return "-1"
return mainstr[start:start+ans]
Now, we are writing the code to execute the mentioned function:
# Driver code
s = 'i am on a seafood diet. i see food and i eat it.'
t = 'fast'
small_window = smallestWindow(s, t)
if small_window
such window
is "{small_window}" and Minimum length between'
f'the substring is
OutputWindow is seafood diet and minimum length between the substrings is 12.
Let us summarize the steps to work on while analyzing algorithms:
Describe the The first step in analyzing an algorithm is to describe it in clear
and concise terms. This should include the input and output, any variables
used, and the steps taken in the algorithm.
Assess the Once the algorithm has been described, it is important to evaluate
its efficiency. This should include assessing the time and space complexity.
Identify potential After assessing the efficiency of the algorithm, it is
important to identify potential bottlenecks or areas of the algorithm that can
be improved.
Optimize the Once the potential bottlenecks have been identified, the next
step is to optimize the algorithm. This may include changing the data
structure, simplifying the code, or changing the order of operations.
Test the Finally, the algorithm should be tested to ensure that it works
correctly. This should include testing the algorithm with various input values
to ensure that it produces the expected output.
Now that we have understood the process, let us look at some of the
approaches to solving problems.Divide and conquer
Algorithms like the greedy method, dynamic programming, and divide and
conquer are fundamental techniques that have various applications. In this
section, we will use the divide and conquer technique to solve examples. The
general idea behind this technique is to solve a problem by breaking it down
into subproblems that are easier to solve.
For example, the merge sort algorithm is a divide and conquer algorithm. It
works by taking a list of numbers and breaking the list into two halves until
the list only contains one number. It then sorts the two halves and merges
them together in the correct order. This process is repeated until the entire list
is sorted.
Binary search is another classic example of a divide-and-conquer algorithm.
It works by dividing a sorted array in half and then comparing the target value
to the value in the middle of the array. If the target is less than the value in the
middle, then the algorithm searches the left side of the array. If the target is
more than the value in the middle, it searches the array’s right side. This
process is repeated until the target is found or there are no more elements to
search.
Quick sort is another example of a divide and conquer algorithm. It works by
choosing a pivot element from the list and then partitioning the list into two
halves based on the pivot. The elements less than the pivot are placed on one
side of the list, and those more significant than the pivot are placed on the
other. This process is repeated on each partition until all elements are sorted.
Exponential problem solving using divide and conquerLet us Traditionally, this is solved using a loop that would perform x * x * x
… * x and so on. This algorithm runs in the linear order of n, as shown in the
following code:
exp= 1
for I in
exp *=x
to the power of {n} =
The preceding program runs a for loop to calculate 12 to the power of 5. The
time complexity of this algorithm is We look to improve the running time of
the algorithm using divide and conquer. In the divide and conquer approach,
the exponential of is achieved by creating subproblems of size This is
demonstrated in Figure
Figure Exponential calculation using divide and conquer
The exponential calculation is shown in FigureFigure Exponential calculation representation using divide-and-conquer
technique
Now, let us see the implementation of the preceding logic using Python code:
def calc_pow(x,n):
'''
Exponential value calculation using Divide and Conquer technique
:param x: number
:param n: power
multiplication of x and n
'''
==
return 1
elif n % 2 ==
return *
return x *
exp_val = calc_pow(x,n)
to the power of {n} =
Exponential value calculation is done by breaking the logic into smaller, more
manageable pieces. It works by dividing the problem into smaller
subproblems, solving each subproblem recursively, and then combining the
solutions of the subproblems to form the final solution. In this example,divide and conquer can be used to reduce the time complexity of the
calculation. The algorithm works by breaking the problem into smaller parts,
computing the exponential value of each part, and then combining the results
to form the overall answer. The size of each subproblem can be chosen based
on the desired accuracy of the result. By breaking the problem down into
smaller pieces, the computation time can be significantly reduced toBacktracking
Backtracking is a type of algorithm that tries different solutions until it finds
the right one. It is a systematic, step-by-step approach that incrementally
builds candidates to the solutions. It is used to find all possible solutions to a
problem by exploring all possible paths. It works by repeatedly making
choices, backtracking when a choice leads to a dead end, and tracking the
best solution found so far. This process is repeated until a solution is found or
all possibilities are exhausted.
These algorithms can be applied to different types of problems. For example,
a backtracking algorithm can be used to solve a maze, by trying different
paths until the end is reached. It can also be used to solve a Sudoku puzzle, by
testing each possible number in each empty cell. Even though it can be a
tedious process, it provides an efficient way to solve complex problems.
To illustrate how backtracking works, consider the following example:
We have an array of numbers, and we want to find a subset of the numbers
that add up to a given sum. Let us say we have the array [1, 3, 7, 5, 9, 11], and
we want to find a subset that adds up to 12.
To solve this problem using a backtracking algorithm, we start by looking at
the first number in the array: 1. We add 1 to our running total and move on to
the second number: 3. We add 3 to our running total, then move on to the
third number: 5. We add 5 to our running total and now have a total of 9.
Since 9 is less than 12, we continue to the following number: 7. We add 7 to
our running total and now have 16. Since 16 is greater than 12, we backtrack
to the previous number, 5, and remove it from our running total. We nowhave a total of 4. We continue this process until we find a subset of numbers
that gives the sum of 12. In this case, the subset of numbers that adds up to 12
is [1, 11], [3, 9], and [7, 5].
Let us look at the Python implementation of the mentioned problem:
class find_subset_sum:
'''
Class to implement a method to find
whether or not there exists any subset
of array that sum up to targetSum
'''
def
= 0 #to count the total possibilities
= [] #to store the valid values for subset
#BACKTRACKING ALGORITHM
def st_idx,target):
if target == sum:
=>
if st_idx <
sum - st_idx, target)
#generate nodes
for i in
#store to find sum
sum + list_val[i], i + target)
#remove as now longer valid
#Driving code
c1 = find_subset_sum()
,c2 = find_subset_sum()
,
Output
Subset => [1, 2, 7]
Subset => [3, 5, 2]
Subset => [3, 7]
Result: 3
Subset => [1, 11]
Subset => [3, 9]
Subset => [7, 5]
Result: 3
Some of the applications of the backtracking algorithm are as follows:
Solving problems that require It is widely used to solve problems that require
decision-making. Examples include the famous 8 queen problem, the
Hamiltonian circuit problem, the knapsack problem, and the Sudoku puzzle.Finding all possible The algorithm can be used to find all possible solutions
to a problem. For example, it can be used to generate all possible
permutations of a string.
Optimization It is used to solve optimization problems, for example, it can be
used to find the shortest path between two points in a graph.
It is used in many parsing algorithms, such as those used in compilers.
Artificial Backtracking is a powerful tool for solving problems in artificial
intelligence, such as game playing.
Backtracking algorithms can also be used to solve various real-world
problems, such as the following:
Solving a maze (finding a path from the start to the end point)
Finding all possible combinations of items in a set (all possible combinations
of a list of ingredients)
Generating all possible permutations of a given string
Finding the shortest path between two nodes in a graph
Solving a Sudoku puzzle
Generating all possible subsets of a given set of elementsWe will now solve the queens puzzle. The N-Queen is the problem of placing
n queens on a chessboard of dimensions N×N such that no queen can attack
another queen in a single move. We need to check if such an arrangement of n
queens exists, and if it does, then print the arrangement. Note that a queen in
chess can attack in any of the eight directions, that is, left/right,
upward/downward, diagonally upward/downward. An example of 4x4 puzzle
solution is shown in Figure
Figure 6.7: Four queens on a 4X4 chessboard
The algorithm starts by placing a queen in the first row and then tries to place
the remaining queens in the subsequent rows, one at a time. For each row, the
algorithm iterates over all possible positions of the queen in that row and
checks if it is safe to place the queen in that position. If it is safe, the queen is
set, and the algorithm recursively calls itself to place the remaining queens insubsequent rows. If unsafe, the algorithm backtracks and tries the next
possible position. Once all the queens are placed, the algorithm returns true,
indicating that a solution has been found. If no resolution is found, the
algorithm returns false. Figure 6.8 depicts the steps we just discussed as
algorithmic steps:
Figure Pseudocode that uses a backtracking technique to solve the n-queens
problem
The Python code implementation is shown here:
queenscnt = 0def IsSafe (board, row, col) :
# Check if there is a queen 'Q' on the left of col in same row.
for c in range(col) :
if (board[row][c] == 'Q') :
return False
# Check if there is a queen 'Q' on the upper-left of col in same row.
for r, c in zip(range(row-1, -1, -1), range(col-1, -1, -1)) :
if (board[r][c] == 'Q') :
return False
# Check if there is a queen 'Q' on the lower left of col in same row.
for r, c in zip(range(row+1, len(board), 1), range(col-1, -1, -1)) :
if (board[r][c] == 'Q') :
return False
return True
def PlaceAll (board) :
for row in board :
for val in row:
print(val,end=" ")
print()
def NQueensSolution (chessboard, col) :
# If all the columns have a queen 'Q', solution has been found.
global queenscnt
if (col >= len(chessboard)) :queenscnt += 1
print("\nBoard " + str(queenscnt)+" :")
print("----"*col)
PlaceAll(chessboard)
print("===="*col)
else :
#Placing the queen in each row of the column and verify if its safe
for row in range(len(chessboard)) :
chessboard[row][col] = 'Q'
if (IsSafe(chessboard, row, col) == True) :
# Placing Queen safe hence, trying to place Q in the next column.
NQueensSolution(chessboard, col + 1)
# restore empty space as previously placed queen is not valid
chessboard[row][col] = '.'
#Driver code
board = []
NSize = int(input("Enter chessboard size : "))
for i in range(NSize) :
row = ["."] * NSize
board.append(row)
# place the queen 'Q' from the 0'th column.
NQueensSolution(board, 0)
Figure 6.9 displays the output:Figure Screenshot of one of the solutions for 6-queens problem
The first solution can take any position, the second will take among and so
on. The time complexity is O (N) * (N - 1) * (N - 2) * … This results in time
complexity of O ( N!Binary tree
A binary tree is a data structure used in algorithm design to organize data
into a tree-like structure, with each node having up to two children. It is
commonly used in the design of search algorithms, sorting algorithms, and
various other types of algorithms. Binary trees are composed of nodes,
each of which contains a value, and each node has up to two children,
referred to as the left and right nodes. The root node is the topmost node
in the tree, and each node has a unique path from the root. Binary trees
have the advantage of being efficient for certain operations, such as
inserting, retrieving, and deleting data, because their structure allows
quick access to any node in the tree. Some of its applications are as
follows:
Binary Search Tree It is used to store and search items in a sorted order.
It is used for implementing priority queues, which are used in scheduling
algorithms such as Dijkstra’s algorithm.
Huffman It is a form of data compression that uses a binary tree to store
and encode data efficiently.
Expression They are used to represent mathematical expressions and are
used in compilers and interpreters.
It is a type of self-balancing tree used to store data on disk efficiently.Before we look at the implementation of the BST, let’s understand why
BSTs are important and when they are preferred.
A binary search tree can manage database indexes to store and retrieve
data from a database efficiently. It is a type of binary tree data structure in
which each node has a value greater than or equal to the importance of the
nodes in the left subtree and less than or equal to the values of the nodes
in the right subtree. The left and right subtrees nodes must also adhere to
this property where the nodes on the left have a lower or equal value and
nodes on the right have a higher or equal value to the node. A database
can quickly traverse an index by utilizing a binary search tree to locate the
desired data. This is because a binary search tree stores data so that it can
be accessed in a logarithmic time. This means that even if the database has
millions of records, a binary search tree can locate the desired records in a
fraction of a second. Furthermore, it can be used to store data in a sorted
manner, which can be beneficial in managing large databases.
Let us see how we can add members to a BST, and how we can delete and
traverse it:
To insert a new node into a binary search tree, we first need to find the
correct position of the new node. We do this by starting at the root node
and then comparing the new node’s value to the root node’s value. If the
new node is smaller than the root node, we move to the left subtree. If it is
more extensive, we move to the right subtree. We repeat this process until
we find an empty spot where the new node can be inserted.To delete a node from a binary search tree, we first need to find the node.
We do this by starting at the root node and then comparing the value of the
node to be deleted to it. If the node to be deleted is smaller than the root
node, we move to its left subtree. If it is more extensive, we move to its
right subtree. We repeat this process until we find the node to be deleted.
Once the node is found, we delete it by replacing it with the minor node in
its right subtree (if it has one) or the largest node in its left subtree (if it
has one).
To search for a node in a binary search tree, we start at the root node and
then compare the value of the node to be found to the value of the root
node. If the node to be searched for is smaller than the root node, we move
to its left subtree. If it is larger, we move to its right subtree. We repeat
this process until we find the node or reach an empty subtree.
Let us look at the Python implementation of the code:
COUNT = #spaces away from previous layer
# Binary Search Tree
class BSTree:
# Function to insert a new node with given data
def root, val):
# check for empty tree
if root is
return newNode(val)
# If given val is less than root val, then find in left subtree
if val < root.val:
root.left = val)
# If given val is more than root val, then find in right subtreeroot.right = val)
return root
# Search a given val in BST
def root, val):
# Base case
if root is None or root.val == val:
return root
# If given val is less than root's val, then it lies in left subtree
if root.val > val:
return val)
# If given val is more than root's val, then it lies in right subtree
return val)
# Delete a node from BST
def root, val):
# Base case
if root is
return root
# If given val is less than root's val, then it lies in left subtree
if val < root.val:
root.left = val)
# If given val is more than root's val, then it lies in right subtree
elif val > root.val:
root.right = val)
# If current node is the node to be deleted
# Node with only one child or no child
if root.left is
temp = root.right
root = Nonereturn temp
elif root.right is
temp = root.left
root = None
return temp
# Node with two children
# Get the inorder successor (smallest in the right subtree)
temp =
# Copy the inorder successor's content to this node
root.val = temp.val
# Delete the inorder successor
root.right = temp.val)
return root
# Helper function to find the smallest node in the given tree
def node):
current = node
# loop down to find the leftmost leaf
while (current.left is not
current = current.left
return current
# Binary Tree Node: Create a new Node
class newNode:
# __init__ functions to create a newNode
def key):
= key
= None
= None# Function to print binary tree in 2D
# It does reverse inorder traversal
def printTreeUtil(root, space):
# Base case
if (root ==
return
# Increase distance between levels
space +=
# Process right child first
printTreeUtil(root.right, space)
# Print current node after space
# count
for i in space):
# Process left child
printTreeUtil(root.left, space)
# Wrapper over print2DUtil()
def printTree(root):
# Pass initial space count as 0
printTreeUtil(root,
# Driver Code
if __name__ ==
bst = BSTree()
root = Noneroot = bst.insert(root,
root = bst.insert(root,
root = bst.insert(root,
root = bst.insert(root,
root = bst.insert(root,
root = bst.insert(root,
root = bst.insert(root,
root = bst.insert(root,
root = bst.delete(root,
printTree(root)
The final structure of the tree is shown in FigureFigure Reading the output from the BST algorithmHeaps
Heaps is a sorting algorithm that uses a data structure called a heap. It is
efficient and is used to rearrange elements in an array into a heap. The heap is
a special type of binary tree with the property that each node is greater than or
equal to each of its children. This allows us to quickly identify the largest
element in the array. The algorithm works by repeatedly swapping the root
element with the last element in the heap and then adjusting it to maintain the
heap property. This process continues until the heap is sorted. It is managed
in the form of a complete binary tree, so a new value is always inserted into
the leftmost vacant position at the last level.
The Heaps algorithm can be used to create a graph of the shortest possible
path between two points, taking into consideration factors like terrain, traffic,
and weather. The algorithm will examine all the possible paths and determine
the shortest one that meets the criteria. This could be used to help plan a route
for a delivery driver or for a traveller who is looking for the quickest route to
their destination. The algorithm can be used to implement a priority queue,
for example, a hospital may use a priority queue to manage the order in which
patients are seen by a doctor. Patients with the most urgent medical conditions
would be given the highest priority and placed at the front of the queue. The
heap algorithm could be used to ensure that the highest-priority patient is
always at the top of the queue.
Let us implement an example to insert and delete from a heap. The root node
always has to be higher than its left and right child. For every insert and
delete, the tree has to readjust to maintain the properties discussed earlier.
Let’s see the implementation of Heap algorithm below:class Heap:
def
# initialize Heap array
= []
def
#Display the content in 1-D array format
def i):
#formula to get access to the parent
return (i - // 2
def k):
i = - 1
#move up if required
#display
def i):
p =
#if parent is lower than the child's value then swap
while p >= 0 and <
=
i = p
p =
def i):
'''
heapify the subtree to manage delete
:param i: root with node i
'''
left = 2 * i + 1 #access to left child
right = 2 * i + 2 #access to right childlargest = i
# If left child is larger than root
if left < and >
largest = left
# If right child is larger than largest so far
if right < and >
largest = right
# If largest is not root
if largest != i:
=
def i):
#deleting element at ith position
n =
if n ==
return None
- = -
del -
# display
#Testing the above code
h1=Heap()
#Run 1: [50]
#Run 2: [50, 10]
#Run 3: [50, 10, 30]
#Run 4: [50, 30]
#Run 5: [50, 30, 20]
#Run 6: [80, 50, 20, 30]
#Run 7: [80, 50, 30]
#Run 8: [80, 70, 30, 50]
The value changed in the tree is shown in FigureFigure Heap tree changing with insert and delete operations
Time O(log(n)) (where n is no of elements in the heap)Hash table
Hash table is a data structure used to store key-value pairs and are
commonly used as part of an algorithm design to optimize the
performance of an algorithm by reducing the time complexity of searches,
insertions, and deletions. Hash tables use a hashing function to map the
keys to an index in an array, which allows quick lookups and insertions.
The key-value pairs can be stored in any data structure, like an array,
linked list, or tree, depending on the algorithm design. The dictionary,
which is a familiar data structure in Python, is a hash table
implementation. Dictionaries are used to store data in the form of key￾value pairs. Each element is accessed using a key. These keys must be
unique, immutable objects, and usually strings or numbers. Values can be
any type of object. Some of the methods available in the dictionary are
listed in Table
Table Inbuilt methods provided by the dictionary class
Let us look at a simple program that implements dictionary:my_dict = {
"UK"
}
# Accessing the dictionary items
# Adding an item
= "Male"
# Removing an item
del
# Looping through a dictionary
for key, value in my_dict.items():
+ ": " + value)
We will write another program to generate a random password that is 8
characters long, consisting of a combination of lower case letters, upper
case letters, numbers and special characters using dictionary:
import string
import random
#Create a dictionary of all possible characters
possible_characters = {
'lowercase_letters': string.ascii_lowercase,
'uppercase_letters': string.ascii_uppercase,
'numbers': string.digits,
'special_characters': string.punctuation
}#Create an empty list to store the password
password = []
#Loop 8 times and randomly pick one character from each dictionary
for i in range(8):
#Randomly select one of the 4 character types
character_type = random.choice(list(possible_characters.keys()))
#Randomly select one character from the selected character type
character = random.choice(possible_characters[character_type])
#Add the character to the password list
password.append(character)
#Join the characters in the password list together
password = ''.join(password)
#Print the password
print("Your new random password is:", password)
There exists different types of dictionary that have been created to
perform certain tasks:
It is a special type of dictionary that keeps track of the number of
occurrences of a particular item. It is an unordered collection of objects
that can store any type of data, and it is often used to count the number of
times an item appears in a list or other collection of data.
It is a dictionary subclass that remembers the order in which its contents
are added. It can be particularly useful when you want to have a consistentoutput order for a dictionary or when you want to make sure a dictionary
is processed in a particular order.
It is a dictionary-like object in Python that provides a way to handle
missing keys. It is a subclass of the built-in dict class. The only difference
is that when a key is not found, instead of a KeyError being raised, a new
entry is created. The type of this new entry is given by the argument of the
defaultdict constructor.
It is a type of data structure in Python that is used to store multiple
dictionaries in a single mapping. It allows you to create a single, unified
view of multiple mappings, which makes it easier to look up and
manipulate values stored in multiple dictionaries at once.Graph algorithm
It is a method for solving problems in graph theory. It solves problems by
exploring the graph and looking for a path that leads from one node to
another. The algorithm is based on the assumption that the graph is undirected
and has no cycles. A graph algorithm takes a graph data structure as input and
provides a solution to a specific problem. It is used to solve various problems,
including finding the shortest path between two nodes, determining whether a
graph is bipartite, finding the lowest cost path between two nodes, and
finding the maximum flow between two nodes.
The most common graph algorithm finds the shortest path between two
nodes. This algorithm uses a breadth-first search algorithm to traverse the
graph. It starts at one node and explores its neighbors before moving on to the
next node. This process is repeated until the destination node is reached. The
number of edges from the starting node to the destination node determines the
shortest path between the two nodes.
Another standard graph algorithm is the minimum spanning tree algorithm. It
uses Kruskal’s algorithm to find the minimum spanning tree of a graph. The
algorithm starts with the set of all edges and then selects the border with the
lowest weight. This process is repeated until all edges are included in the
minimum spanning tree.
The maximum flow algorithm is another common graph algorithm. It finds
the maximum flow between two nodes and uses the Ford-Fulkerson algorithm
to find the maximum flow between two nodes. It starts by assigning a flow
value to each edge and then it iteratively updates the flow values until the
maximum flow is found.Finally, the graph coloring algorithm is used to color a graph. It uses the
Welsh-Powell algorithm and assigns a color to each vertex, and then it
iteratively updates the colors until no two adjacent vertices have the same
color. The algorithm is complete when there are no two adjacent vertices with
the same color.
Let us look at the Python implementation of Dijkstra’s algorithm, finding the
shortest path from the source to all nodes.
Algorithm
Step Set all distances from the source node to infinity, except for the source
node itself, which is set to 0.
Step Set the unvisited node with the shortest distance as the current node.
Step Calculate the distance of each unvisited node from the current node.
Step Set the unvisited node with the shortest distance as the new current node
and mark it as visited.
Step Repeat steps 3 and 4 until all nodes have been visited.
Step Return the shortest distance from the source node to all other nodes.
Figure 6.12 shows the source (O) and the distance to other vertices:Figure Problem statement with distance from O to other vertices
Here is the Python code:
import numpy as np
class GenGraph():
def vertx):
= vertx
= for col in
for row in
def dist):
from
for node in
node, dist[node])
# Find the vertex with minimum distance value
# from the set of vertices not yet in shortest path
def dist, spSet):
min = np.inf # default max distance
min_idx = 1
# look for not nearest vertex not in shortest pathfor v in
if dist[v] < min and not spSet[v]:
min = dist[v]
min_idx = v
return min_idx
# Implementing Dijkstra's shortest path algorithm
# using graph using adjacency matrix representation
def source):
dist = [np.inf] *
dist[source] = 0
spSet = *
for cout in
# Pick the minimum distance vertex
# x is always equal to src in first iteration
x = spSet)
# Put the min distance in the shortest path
spSet[x] = True
# Update dist value if distance is greater than new distance
# and the vertex in not in the shortest path tree
for y in
if > 0 and spSet[y] == False and \
dist[y] > dist[x] +
dist[y] = dist[x] +
if __name__ ==
prb1 =
prb1.plot_graphThe final solution is shared in Figure
Figure Final solution of finding distances from O to other verticesBigO notation: Methodology for analyzing algorithms
Big O notation is a way of measuring the complexity of an algorithm. It is
often used to express the worst-case scenario of an algorithm, which is the
amount of time or memory it will take to complete its task. Big O notation is
a mathematical expression that describes the upper bound of an algorithm’s
running time or space complexity. It is expressed as where f(n) is the
complexity of the algorithm in terms of the size of the input, usually
expressed as n. This means the algorithm will take no more than f(n) time or
memory to complete its task. It is used to represent the upper bound of an
algorithm’s complexity.
For example, if an algorithm has a complexity of then it will take no more
than n*n steps to complete its task. This type of notation is useful because it
allows us to quickly compare the relative complexity of different algorithms
without having to actually measure the exact time or memory it takes for each
one.
Big O notation is useful for analysing algorithms in terms of their
performance and scalability. It is often used to compare different algorithms
and determine the most efficient one. Figure 6.14 shows a complexity chart of
different Big O values:Figure Big O complexity chart
(Image bigocheatsheet.com)
Let us look at some of the widely used algorithms and their time and space
complexities in FigureFigure Time and space complexities for some common data structure
operations
(Image bigocheatsheet.com)Conclusion
Algorithms are like tools; they help us accomplish tasks more efficiently
and effectively, and they also help increase our productivity. They can
help us perform tasks that would otherwise be difficult or impossible to do
by manual effort. You can use specialized or general-purpose tools to do
your work. They are designed to perform one specific task or a set of
related tasks. They tend to be designed for efficiency so that they can do
the job quickly and accurately. However, they tend to be expensive or not
at all versatile when used for tasks for which they are not intended.
General-purpose tools are designed to perform a wide range of tasks. They
are usually more affordable than specialized tools and are often more
versatile because they can be used for a variety of tasks. However, they
may not be as efficient as specialized tools. We discussed both types of
algorithms in this chapter. We looked at specialized algorithms like sliding
window and general-purpose fundamental algorithms like divide and
conquer. We also looked at tree-type data structures and graph-type data
structures. There is only one way to master these concepts, and that is by
practice. Practice these concepts as much as you can.
In the next chapter, we will learn to build multi-threading applications.
Multi-threading is a process that allows a single process to have multiple
threads of execution running concurrently. This means that multiple pieces
of code can be running at the same time within a single process, enabling
more efficient utilization of resources and faster completion of tasks.
Multi-threading also allows better responsiveness and scalability, as
multiple threads can be used to handle more concurrent requests. Inaddition, it can provide better fault tolerance, as one thread can take over
the work of another if it fails.
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the
Authors:
https://discord.bpbonline.comChapter 7
Building Multithreading Application
Everybody who learns concurrency thinks they understand it, ends up
finding mysterious races they thought weren´t possible, and discovers that
they didn´t actually understand it yet after all.
— Herb Sutter, chair of the ISO C++ standards committee, MicrosoftIntroduction
Multithreading is a programming technique that allows a program to
execute multiple threads (or tasks) concurrently. Each thread runs
independently and can work on its task while sharing resources with other
threads in the same program. It is used in many applications and different
ways. It can be used to improve performance and scalability, to provide a
better user experience, or to make programming easier. For example, a
web server can use multiple threads to handle multiple requests at once.
This improves the web server’s performance since it can process multiple
requests at once.
This chapter will look at the concept of multithreading and its
implementation in Python. We will cover topics like the differences
between multithreading and multi-processing, the use of the threading
module, synchronization techniques, and strategies for utilizing multiple
cores of a processor. It will also explain techniques like thread pooling and
parallel processing, and it will provide examples of their use. Parallel
processing is a technique in which multiple threads are executed
concurrently to increase the speed and performance of a program. These
threads can run independently, in parallel, and share resources like
memory and processors. Finally, it will discuss best practices for
programming with threads in Python, such as handling thread errors in a
safe and effective manner.
Multithreading in Python can be used to improve the performance of a
program. For example, it can be used to process multiple streams of data
simultaneously, run multiple tasks simultaneously, or execute multiplepieces of code concurrently. This can be achieved using the threading
module, which provides the basic functions for creating and running
threads.
Python threads can also communicate with each other using shared
memory. This communication is called inter-thread communication,
allowing threads to exchange data and synchronize their execution. This
can be used to coordinate tasks and achieve greater efficiency.
It can also make programs more responsive, as threads can handle user
input while other threads run in the background. This can help reduce
latency and improve the user experience.
Overall, multithreading in Python can achieve greater performance and
responsiveness in programs.Structure
In this chapter, we will discuss the following topics:
Introduction to the multithreading concepts
Synchronizing threads
Inter-thread communication in Python
Thread pooling with Python
Multithreaded priority queue
Optimizing Python threads for performance
Snake Game: Using multithreading and turtle
Now, let us dive deep into the topics.Objectives
The main objective of learning multi-threading in this chapter is to enable
developers to write code that will increase performance, reduce latency by
spreading out tasks across multiple threads, improve reliability, and ensure
easier program maintenance. The topics covered here are in accordance
with this objective.Introduction to multithreading concepts
Multithreading is the process of running multiple threads at once. It is a
way to improve the performance of an application by running multiple
tasks simultaneously. Threads are lightweight processes that share the
same memory space and can therefore, communicate with each other
easily.
Multithreading is achieved by allowing multiple threads to run
concurrently. This is done by dividing the program code into multiple
small tasks or processes. Each process is given its thread, and each thread
can execute its own instructions. By doing this, the program can use
multiple processors or cores in a single computer. Let us look at an
example.Starting a new Thread
By default, every program will have one main thread running. If you want
to spawn a second thread, you can do by calling the Thread() method
available in the threading module:
threading.Thread(target=function).start()
The start() method will begin executing the thread. Then there is another
method, which waits for a thread/process to terminate. This will make the
main thread wait until it completes the execution. To see the difference,
run the following program and then run it again after uncommenting the
join() method:
import threading
def thread_action():
for x in
by Child
thread1 =
thread1.start()
#thread1.join()
Program Thread
Note: If you are using a powerful computer with high RAM then you may
not see the difference.In the preceding program, we see that the child and main thread run
almost simultaneously in the first run, but when we call the main thread
waits until the child thread completes execution.
Multithreading can help improve the efficiency of the program by
allowing it to take advantage of the extra computing power available. This
is because each thread can be assigned to a different processor or core,
allowing more tasks to be done simultaneously. It also allows the program
to use resources more efficiently, as there is no need to wait for a single
process to finish before starting another. Let us look at another Python
program, as follows:
import time
import threading as th
def cal_square(list_num):
SQUARE OF NUMBERS:
for i in list_num:
#wait for a second
def cal_cube(list_num):
CUBE OF NUMBERS:
for i in list_num:
#wait for a second
#Main calling
num =
thread1 = =
thread2 = =# creating two threads here t1 & t2
thread1.start()
thread2.start()
# starting threads at the same time
thread1.join() #making main thread to wait
thread2.join() #making main thread to wait
am from Main, expecting both the threads to have terminated by
In the preceding example, we can see that both functions run in parallel,
making the best use of CPU time.
Multithreading can be implemented at both the hardware and software
levels. The program code is divided into multiple threads on the software
side, and each thread is assigned to a different processor or core. On the
hardware side, the processor is designed to run multiple threads
simultaneously.Synchronizing threads
It refers to the process of ensuring that multiple threads of execution are
performing operations in a coordinated manner. This is typically used to
ensure that critical sections of code cannot be accessed by more than one
thread at a time, preventing race conditions and ensuring data integrity. A
critical section is part of a multithreaded application that accesses a shared
resource and must be executed in a thread-safe way. A synchronization object
such as a mutex, semaphore, or spinlock usually protects the critical section.
The critical section allows only one thread to enter at a time, ensuring that the
shared resource is not corrupted by simultaneous access from multiple
threads. Figure 7.1 is an illustration of the critical region being accessed by
threads A, B, and C:
Figure Three critical sections: Threads accessing shared resources at the same
time
A race condition occurs when two or more threads or processes compete for a
shared resource (such as a critical section of code, a data item, a hardware
device, or a network connection) and the behavior of the program or systemdepends on the timing of events that occur while the threads or processes are
executing. In other words, the outcome of the program may vary depending
on the order in which the threads or processes access the shared resource.
Race conditions can cause unexpected or incorrect results in programs, such
as deadlocks or data corruption. Reading data does not cause any harm but
writing/editing can give unexpected result. The readers-writers problem is a
classic example of a multithreading synchronization problem. It describes a
situation wherein multiple threads try to access a shared resource. The
problem is that either readers or writers can access the resource, but not both
at the same time. This generally leads to a condition in which writers need to
wait for readers to finish before they can write, or readers have to wait for
writers to finish before they can read. This results in one type of thread
accessing a resource while it is locked or blocked by another type. Let us take
a simple implementation of the readers-writers problem here. Consider the
following Python program that lets both readers and writers perform their
tasks. When we run the following code multiple times, we get different
outputs:
import threading as thread
import time
global val #Shared value
val = 0
def Reader():
global val
is Reading Shared Value: val)
def Writer():
global val
is increasing value of val byval += 1 #Write on the shared value
done: val
#Driver code
if __name__ ==
for i in
ThreadA = = Reader)
ThreadA.start()
ThreadB = = Writer)
ThreadB.start()
ThreadA.join()
ThreadB.join()
Now, we will rewrite the same code, treating the reading and writing portions
of the code as critical sections. The next program is a simple example where
we are not using inter-thread communication. Writer tasks are competing for
and readers compete for the reading sections. The data will not be written by
another writer process until the previous process completes it. The same logic
goes for the readers block.
import threading as thread
import time
global val #Shared value
val = 0
lock = thread.Lock() #Lock for synchronising access
def Reader():
global vallock.acquire() # Acquire lock before Reading
is Reading Shared Value: val)
lock.release() # Release the lock before Reading
def Writer():
global val
lock.acquire() # Acquire the lock before Writing
is increasing value of val by
val += 1 #Write on the shared value
done: val
lock.release() # Release the lock after Writing
#Driver code
if __name__ ==
for i in
ThreadA = = Reader)
ThreadA.start()
ThreadB = = Writer)
ThreadB.start()
ThreadA.join()
ThreadB.join()
Thread synchronization in Python is achieved using locks, semaphores,
events, and conditions. A lock is a synchronization primitive, which ensures
that only one thread is executing a piece of code at one time. Semaphores are
also used to control access to shared resources, while events and conditions
are used to synchronize threads. Locks, semaphores, and events are provided
by Python’s threading module, while conditions are provided by thethreading.Condition class. Let us understand the components of thread
synchronization:
They are the basic form of thread synchronization. At any given time, a lock
will allow only one thread to enter a protected section of code. The other
threads are blocked until the lock is released. A lock is acquired by calling the
lock.acquire() method, and it is released by calling the lock.release() method.
It is used to control access to the critical or shared resource. A semaphore
maintains a counter that represents the number of available resources. The
semaphore has an internal counter that is initialized to a given value. When a
thread wants to access the shared resource, it acquires the semaphore. When
the semaphore’s counter goes above 0, the thread can access the resource, and
the counter is decremented. If the counter is 0, the thread is blocked until the
semaphore is released by another thread. The semaphore is released by
calling the release() method.
These are another form of synchronization used to signal changes in the state
of a thread. An event is created by calling the threading.Event() function. The
event can then be set or cleared using the set() and clear() methods. The
wait() method blocks the thread until the event is set.
It is a synchronization primitive that is similar to an event, but with the added
ability to wait for multiple conditions. We will discuss this in detail in the
next section.Inter-thread communication in Python
Inter-thread communication is a method of communication between two
or more threads in a process. It is a way to synchronize the execution of
multiple threads, allowing them to exchange information, share resources,
and coordinate their actions. This communication in Python can be
achieved using queues, events, semaphores, or conditions.
Queues are a type of thread-safe data structure for storing data that can be
accessed by multiple threads. They allow these threads to put data into the
queue and take data from the queue, ensuring that no data is lost and that
no thread is blocked from accessing the queue.
It is a synchronization primitive that is similar to an event, but with the
added ability to wait for multiple conditions. A condition is created by
calling the threading.Condition() function. The condition can then be set
or cleared using the acquire() and release() methods. A thread can wait for
a condition to be set by calling the wait() method. The wait() method
blocks the thread until the condition is set.
Using the condition() method of threading is better than using the event
object for inter-thread communication. Condition represents some type of
state change between threads, like send notification or got notification.
The methods used here are as follows:
This method frees the condition object from their tasks and releases the
internal lock obtained by the threads.The compulsory acquire() is used to obtain the internal lock system.
notify() is used to send notifications to exactly one thread that is in
waiting; notifyAll() is used to send notifications to all waiting threads.
This can be used to make a thread wait till the notification is received; in
other words, this thread is to wait until the execution of the notify()
method is done.
Let us look at an example where we will implement communication
between two threads:
from threading import Condition, Thread
import random
patients =
doctors =
class BookAppointment:
def
condition_obj.acquire()
{random.choice(patients)} is waiting for the
condition_obj.wait() # Thread enters wait state
Successfully
condition_obj.release()
def
condition_obj.acquire()
{random.choice(doctors)} is checking time for
time =
Booked for {}condition_obj.notify() #communication made
condition_obj.release()
condition_obj = Condition()
class_obj = BookAppointment()
TP =
TD =
TP.start()
TD.start()
Thread TP or TD can start first, but TP has to wait till TD fires notify. In a
way, notify tells TP to continue as the appointment condition has been
met. The acquire() and release() methods are used to obtain or acquire the
condition object and release the condition object, respectively.Thread pooling with Python
Thread pooling is a way of executing multiple threads simultaneously in a
single application. It involves creating a pool of threads that can be reused to
execute a variety of tasks. This is useful for applications that need to handle a
large number of tasks concurrently, such as web servers. The main advantage
of thread pooling is that it allows efficient utilization of system resources,
such as CPU and memory, by avoiding the overhead associated with creating
and managing a large number of threads.
The pool manages a fixed number of threads and controls when the threads
are created, such as just-in-time, when they are needed. The pool also decides
what a thread does when not in use, for example, making them wait without
letting them consume computational resources.
Threads in the pool are called worker threads. Each worker thread is agnostic
to the type of tasks that are executed. They are designed for reuse once the
task is completed. It provides protection against the unexpected failure of the
task, like raising an exception, with no impact on the worker thread itself. It is
much more efficient to use a thread pool over the manual process of starting,
managing, and closing threads, more so when there are a large number of
tasks.
Python provides a thread pool via the ThreadPool and ThreadPoolExecutor
classes. The main difference between the two is that ThreadPool is a module
from the Python standard library, while ThreadPoolExecutor is a class from
the concurrent.futures module, which is part of the Python 3.2+ standard
library. ThreadPool is a high-level interface that abstracts away the process of
creating and managing threads, making it easier to use. It provides a pool ofthreads that can be used for executing tasks. The number of threads are
created at the time of class instantiation.
ThreadPoolExecutor is a more low-level interface. It provides an executor
that can be used to manage threads. It allows more control over the thread
pool, such as setting the maximum number of threads, the minimum number
of threads, and the maximum number of tasks that can be queued up. It also
provides methods for submitting tasks and retrieving the results.
ThreadPoolExecutor class has three methods:
It takes a task to execute.
It executes a task by element (iterable).
It shuts down the execution.
ThreadPool has many methods. Essentially, they work in four stages: create,
submit, wait, and shutdown.
Let us implement a simple task to check whether the given Wikipedia page
exists. First, we will check without using thread, and then we will run both
ThreadPool and We will also record the time taken to execute the program.
Here are the libraries that we need:
from multiprocessing.pool import ThreadPool
from concurrent.futures import ThreadPoolExecutor, as_completed
import time
import requestsLet us write the function (task) first, which looks something like the one that
follows. Python List url_list has the list of Uniform Resource Locator (URL)
for which we will verify whether pages for them exist or not.
url_list =
def is_wiki_page_exist(url,
response =
page_status = "unknown"
if response.status_code ==
page_status = "Exists"
elif response.status_code ==
page_status = "Can not find"
return url + " - " + page_status
Now, we will execute the program without creating a thread:
1: Running without
method1_start = time.time()
for url in url_list:
+ url))
method1_end = time.time()
taken without method1_end - method1_start)
Let us see how we can manage the thread pool using
2: Using
method2_start = time.time()with ThreadPoolExecutor() as executor:
futures = []
for url in url_list:
urls =
futures.append(executor.submit(is_wiki_page_exist,
for future in as_completed(futures):
print(future.result())
method2_end = time.time()
taken with method2_end - method2_start)
Let us see how we can manage the thread pool using
3: Using
method3_start = time.time()
# create the thread pool: count exists
with as pool:
# creating the arguments
urls = []
for url in url_list:
args = [(url, for url in urls]
# dispatch all tasks
results = pool.starmap(is_wiki_page_exist, args)
# report results in order
for result in results:
print(result)
method3_end = time.time()
taken with method3_end - method3_start)Using thread made the program dramatically faster. Even for a small program
where we are checking eight pages, we can see so much improvement. Output
from the code will be in the format shown in Figure
Figure Time taken by the program to execute with no thread management and
with ThreadPoolMultithreaded priority queue
It is a thread-safe implementation of a priority queue in Python, which
allows multiple threads to access and manipulate the queue without any
interference or race conditions. Priority queues in threading are used to
ensure that items with higher priority are processed first. For example, in a
web server, requests with higher priority can be processed first, and
requests with lower priority can wait until the higher priority requests
have been serviced. Priority queues in threading also provide an efficient
way to store and retrieve data in a multi-threaded application.
A multithreaded priority queue in Python can be implemented using the
queue class from the Python standard library. We will look at an example,
where we create a random value and random priority in producer()
function. In this example, consumer() function will consume the value
with the highest priority first (which is the one with the lowest priority
number). Let us implement this with an example; the explanation is given
along with the code. As with any Python program, step 1 is to import the
required libraries.
Step 1: Import the required libraries
from queue import PriorityQueue
from random import random, randint
from threading import Thread
from time import sleep
Step 2: Create the producer() to generate random values and priorityThe task here is to iterate 10 times in a for loop, where each iteration will
generate a new random value (using and priority, which is a random
integer (created using The value and priority are paired into a tuple and
passed to the priority queue. Once the task is complete, the join() function
blocks on the queue until all items have been processed and marked as
done by the consumer. This is called a sentinel value and is a common
way for threads to communicate via queues to signal an important event,
like a shutdown. It is important that we send this signal after all items
have been processed, as it will not be comparable with our tuples,
resulting in an exception. Now, let us look at the implementation:
# generates random numbers
def producer(pqueue):
method is running
# generate value
for i in
# creating work: generating a random number
value = random()
# generating a priority
priority =
= {value} : Priority =
# create tuple with priority and value
item = (priority, value)
# adding to the priority queue
pqueue.put(item)
# wait for all items to be processed
pqueue.join()
# send sentinel valueis
Step 3: Create the consumer() to use up the values based on the priority
The consumer() function takes the queue instance as an argument. In each
iteration, it finds an item from the queue and blocks it if there is no item
available. The task will break the loop when the item retrieved from the
queue has the value none, and will terminate the thread. The
implementation is as follows:
# consume the work generated by producer
def consumer(pqueue):
is now
# consuming the work
while
# get a unit of work
item = pqueue.get()
# check for stop
if item is
break
# block
# report
==> Consuming :
# mark it as processed
pqueue.task_done()
# all done
is
Step 4: Execute the programWe have now configured the start of the producer thread to generate tasks.
They are added to the priority queue and available for the consumer to
access. The main thread waits (blocked) until the producer and consumer
threads terminate; then, the main thread terminates itself. Let us look at
the code for this:
# create the shared queue
pq = PriorityQueue()
# start the producer
producer =
producer.start()
# start the consumer
consumer =
consumer.start()
producer.join()
consumer.join()
When you run the preceding program, you can see that a lower priority
number is always consumed before its higher number counterpart. This is
how a multithreaded priority queue can be implemented.Optimizing Python threads for performance
Programs using threads are supposed to perform better than loops, but if
you try on your computer, you may not see the difference; in fact, you
might see loops performing better than multi-threading programs. This is
because threads in Python are subject to the Global Interpreter Lock
GIL is a mechanism used in Python to ensure that only one thread can
execute at any given time. This lock is necessary because the Python
interpreter is not thread-safe, so if multiple threads were to execute Python
code simultaneously, it could lead to unexpected behavior. The GIL is
implemented by acquiring a lock before executing any Python bytecode
and releasing the lock when the execution is finished. This ensures that
only one thread can execute at any given time, preventing any
concurrency issues. GIL are only allowed to run some X Python
instructions before releasing the GIL to another thread. That is why for
simple operations, the cost of creating a thread, locking, and context
switching is much bigger than the cost of simple computation. However, it
works well if you have large number of computations in a program.Snake game: Using multithreading and turtle
In the section, we will learn to build the classic snake game. This game was
first released on Nokia phones in 1997. It was pre-installed on many Nokia
phones and is still available to be downloaded on some Nokia phones. The
game itself is a simple one. Control a snake-like creature around the screen,
eating the little dots, and avoiding running into the walls or itself. Let us build
it. The opening screen of the game would look something like
FigureFigure Starting screen
Let us program to see how this game is implemented. We will briefly describe
our approach here:
Step 1: Import the libraries#### Developing Snake game in python
import turtle
import time
import random
import threading
Step 2: Set the initial values
delay = 0.1
final = 0
# Score
flag = 0
score = 0
high_score = 0
a,b,n,m =
z,i,t,eat =
Step 3: Set up the screen
ts = turtle.Screen()
wid,hgt =
# Turns off the screen updates
Step 4: Create snake head
head = turtle.Turtle()
head.penup()
head.direction = "stop"
st = 1Step 5: Create snake food (round ball)
food_1 = turtle.Turtle()
food_1.penup()
a1 = food_1.xcor()
b1 = food_1.ycor()
ff = 0
food_2 = turtle.Turtle()
food_2.penup()
segments = []
Step 6: Create welcome screen
# Pen
load = turtle.Turtle()
load.penup()
draw = turtle.Turtle()
draw.penup()
draw.hideturtle()
to my world!! \n New
draw.clear()
0 High Score: New
Step 7: Write the functions to control the directions
def go_up():
if head.direction !=head.direction = "up"
def go_down():
if head.direction !=
head.direction = "down"
def go_left():
if head.direction !=
head.direction = "left"
def go_right():
if head.direction !=
head.direction = "right"
def move():
if head.direction ==
y = head.ycor()
head.sety(y +
if head.direction ==
y = head.ycor()
head.sety(y -
if head.direction ==
x = head.xcor()
head.setx(x -
if head.direction ==
x = head.xcor()
head.setx(x +
def coll_border():
global score, delay, head, z, final
if head.xcor() > 280 or head.xcor() < or head.ycor() > 260 or head.ycor() <
z = 1final = score
score = 0
# Reset the delay
delay = 0.1
def coll_food():
global delay, score, high_score, food_1, head, a, b, flag, i, m, n, t, eat, a1, b1
for j in segments:
if j.distance(a1, b1) <
# j.color("black")
if head.distance(food_1) < 50 or head.distance(food_2) <
if head.distance(food_1) <
# Move the food to a random spot
a1 = food_1.xcor()
b1 = food_1.ycor()
a =
b =
# Shorten the delay
delay -= 0.001
# Increase the score
score += 10
if score > high_score:
high_score = scoreif flag !=
ran =
if i % ran == 0 and i % 70 == 0 and i != 0 and head.xcor() !=
while
m =
n =
if m != food_1.xcor() and n != food_1.ycor():
t = 1
flag = 1
break
if flag ==
if head.distance(food_2) <
# Move the food to a random spot
flag = 0
t = 0
eat = 1
# Shorten the delay
delay -= 0.001
# Increase the score
score += 20
if score > high_score:
high_score = score
def coll_body():
global z, score, delay, segments, final
for segment in segments:
if segment.distance(head) <z = 1
# Reset the score
final = score
score = 0
# Reset the delay
delay = 0.1
def do1():
global z
head.direction = "stop"
# time.sleep(1)
for i in segments:
segments.clear()
draw.clear()
ts.update()
Over!! \n
New
# score = 0
draw.clear()
{} High Score: high_score),New
z = 0
def do2():
global a, b, a1, b1
# last.goto(a1, b1)
food_1.goto(a, b +
# Add a segment
new_segment = turtle.Turtle()
new_segment.penup()
segments.append(new_segment)
draw.clear()
{} High Score: high_score),
New
a,b =
# Keyboard bindings
ts.listen()
ts.onkeypress(go_up,
ts.onkeypress(go_down,
ts.onkeypress(go_left,
ts.onkeypress(go_right,
if __name__ ==
while
ts.update()
t1 =t2 =
t3 =
t1.start()
t2.start()
t3.start()
t1.join()
t2.join()
t3.join()
if z ==
do1()
if a < wid:
do2()
if flag ==
if m < hgt:
food_2.goto(m, n)
m = 1000
n = 1000
t = t + 1
if t >
flag = 0
t = 0
draw.clear()
{} High Score: high_score),
New
if eat ==
draw.clear()
{} High Score: high_score),New
eat = 0
if t !=
draw.clear()
if t:
if ff ==
if st ==
st = 2
elif st ==
st = 3
ff = 1
if st ==
st = 2
elif st ==
st = 1
ff = 0
HighScore:{} high_score, 40 - t),
New
for index in -
x = segments[index -
y = segments[index -
segments[index].goto(x, y)
# Move segment 0 to where the head is
if >
x = head.xcor()
y = head.ycor()
y)if b1) <
move()
i = i + 1
time.sleep(delay)
ts.mainloop()
This ends our program. It was fun developing this simple yet powerful game
implementing thread concepts, wasn’t it?Conclusion
Threading in Python is used to run multiple threads (tasks, function calls)
at the same time. This does not mean that they are executed on different
CPUs. Python threads will not make your program faster if it already uses
100% CPU time. In that case, you probably want to look into parallel
programming.
Python threads are used in cases where the execution of a task involves
some waiting. One example would be interaction with a service hosted on
another computer, such as a web server. Threading allows Python to
execute other code while waiting; this is easily simulated with the sleep
function.
Running several threads is similar to running several different programs
concurrently, but with the following benefits:
Multiple threads within a process share the same data space with the main
thread and can therefore, share information or communicate with each
other more easily than if they were separate processes.
Threads are sometimes called light-weight processes, and do not require
much memory overhead; they come cheaper than processes.
A thread has a beginning, an execution sequence, and a conclusion. It has
an instruction pointer that keeps track of where within its context it is
currently running.It can be pre-empted (interrupted).
It can temporarily be put on hold (also known as sleeping) while other
threads are running; this is called yielding.
In conclusion, multi-threading is a useful way to improve the performance
of an application by running multiple tasks simultaneously. It can be
implemented at both the hardware and software levels and can help
improve the efficiency of the program.
Now, it is time to add some color to our work. In the next chapter, we will
cover the building of an interactive dashboard. An interactive dashboard is
important because it allows users to gain insights into their data quickly
and efficiently. With dashboards, users can quickly visualize their data in
simple, easy-to-read graphics. This allows them to quickly spot trends,
outliers, or any other patterns that might not be apparent from simply
looking at tables or lists of raw data.
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the
Authors:
https://discord.bpbonline.comChapter 8
Building an Interactive Dashboard using Jupyter Notebook
Data-driven dashboards are the key to unlocking the powerful insights that
can drive success.
— Satya Nadella, CEO of MicrosoftIntroduction
Dashboards are the best way to analyze business data because they
provide a comprehensive overview in an easy-to-understand, visual
format. Dashboards present data in a way that is easy to digest and can
provide insights that may not be obvious when looking at raw data.
Dashboards also provide an interactive platform, allowing users to drill
down into the data and view more detailed information or create reports.
Dashboards can be customized to display the data that is most relevant to
a business, allowing users to quickly identify issues and make informed
decisions. They also provide a way to track performance over time,
allowing businesses to quickly identify changes in trends or performance
gaps.
Jupyter Notebook with VS Code is a powerful combination for creating
interactive dashboards. With Jupyter Notebook, you can easily create and
share documents that contain live code, equations, visualizations, and
explanatory text.Structure
In this chapter, we will discuss the following topics:
Introduction to Jupyter Notebook
Setting up a Jupyter Notebook environment on VS code
Working with widgets and visualizations in Jupyter Notebook
Developing sample program using widgets and visualization
Project: Covid-19 Interactive dashboardObjectives
The objective of this chapter is to introduce you to Jupyter Notebook on
VS Code and create interactive dashboards using widgets. In this chapter,
we will learn to create a COVID-19 dashboard that can help us access,
understand, and share information about the coronavirus pandemic
quickly and easily. In the process, we learn about libraries like Matplotlib,
Seaborn and dashboarding frameworks like Panel and Voila. We will also
learn to connect to the data sources, clean the data before using, and
perform exploratory data analysis to understand more about the data.Introduction to Jupyter Notebook
Jupyter Notebook is a web-based, open-source tool that allows you to
create and share documents containing live code, equations,
visualizations, and narrative text. It supports various programming
languages, including Python, R, Julia, and Scala, and is widely used in
data science, scientific computing, and machine learning. It is used by
some of the world’s leading companies to power their data science and
machine learning workflows. Jupyter Notebook provides an interactive
environment with various features, including the following:
Code execution: You can execute code directly in your browser and see
the results in real time.
Visualizations: Rich graphical outputs are supported, including interactive
plots and maps.
Collaboration: Jupyter Notebook supports collaboration, allowing multiple
users to work on the same notebook.
Notebook You can share your notebooks with others via the web or email.
Documentation: You can write narrative text, equations, and other
information directly in your notebook, making it easier to document and
share your work.
Overall, Jupyter Notebook is a powerful tool for data science, scientific
computing, and machine learning. It is easy to use, allows collaboration,and enables rapid prototyping and testing of ideas.Setting up a Jupyter Notebook environment on VS code
You can use Jupyter Notebook in Visual Studio Code. Visual Studio Code has
an extension for Jupyter Notebooks that allows you to easily create and edit
Jupyter Notebooks. This extension allows you to easily access the Jupyter
Notebook environment directly from Visual Studio Code, making it easier to
work with large notebooks and complex code.
The following are the steps to install Jupyter Notebook in a VS code:
Open Visual Studio Code.
Navigate to the Extensions tab in the left sidebar (or press Ctrl + Shift +
Search for Jupyter in the search bar.
Select the Jupyter extension from the list of results and click
After the installation is complete, click Reload to activate the extension.
Open the Command Palette by pressing Ctrl + Shift +
In the Command Palette, type Jupyter and select the Jupyter: Launch
Notebook option.
Select a directory to save the notebook, give it a name, and click
A new tab will open with the Jupyter Notebook, as shown in FigureFigure 8.1: Launching Jupyter notebook on VS Code
You will see an option to create a new Jupyter notebook as shown in Figure
Click on Create New Jupyter Create a new file and save it as file.
Then, write the code for your program in the cell of the newly created Jupyter
Notebook.
To execute the program, press the Run button at the top of the Notebook.The program will be executed, and you will be able to see the output in the
output cell. A sample program and the output is shown in Figure
Save the Notebook.
The running program will look as shown in the following figure:
Figure 8.2: An example program running in Jupyter notebook on VS Code
Now we are ready to work with Jupyter Notebook in VS Code.
Note: The mentioned installation steps may be slightly different if you are
using macOS. On macOS, create a virtual environment (venv) and then install
the Jupyter package. Once it is installed successfully, you can execute the
Jupyter Notebook.Working with widgets and visualizations in Jupyter Notebook
Widgets are interactive elements in Jupyter Notebooks that allow users to
manipulate and visualize data in real time. By using widgets, users can
interact with visualizations, plots, and images; filter and sort data; and even
control the execution of code. Widgets are a part of the ipywidgets library,
which is installed automatically when you install Jupyter Notebook. They are
easy to use and can be used to quickly build interactive applications with very
little code. In addition, widgets can be used with other libraries like
matplotlib, pandas, and scikit-learn. They allow users to control the behavior
of their code and the visualization of the data they are working with, making
it easier to explore and understand the data.
You need to import ipywidgets to use these widgets in the programs. In case
you get a module not found error while running the widgets program, you
will have to install ipywidgets library. Follow these steps to install the library:
Install Open the integrated terminal | Terminal or Ctrl in VS Code and run the
following command:
pip install ipywidgets
Enable In the terminal, run this command:
jupyter nbextension enable --py --sys-prefix widgetsnbextension
Restart the kernel: Finally, you will need to restart the kernel to ensure that
the extension is properly loaded. In the notebook, open the Kernel menu andselect Restart
Now, you can use ipywidgets in Jupyter Notebook in VS Code.
Note: The mentioned installation may not be required if you are using
macOS. You can proceed with the following steps.
Run the following sample code to see if widgets are appearing correctly:
import ipywidgets as widgets
# Create a sample text widget
txt_wid = to VS Code
# Display the widget
display(txt_wid)
# Create a sample button widget
btn_wid = the
# Display the widget
display(btn_wid)
The output for the code is shown in FigureFigure 8.3: Output of the sample widget code
Visualization is the process of creating plots, charts, maps, and other visual
representations of data to gain insights and make more informed decisions.
Visualization helps to quickly identify patterns, trends, and correlations
between multiple variables, which can help identify areas that require further
investigation. Popular visualization libraries used in Jupyter Notebook Python
include matplotlib, seaborn, bokeh, and plotly. Matplotlib is the basic plotting
library for the Python programming language and its numerical mathematics
extension It provides an object-oriented Application Programming Interface
for embedding plots into applications using general-purpose Graphical User
Interface toolkits like Tkinter, wxPython, Qt, or GTK+.
Install matplotlib at the terminal using this command:
pip install matplotlib
Run the following sample code to see if the plots are appearing correctly:
import matplotlib.pyplot as plt
lineplt.show()
The output will be as shown in Figure
Figure 8.4: Output of the preceding sample matplotlib codeDeveloping a sample program using widgets and visualization
In this section, we will develop a sample program connecting widgets and
visualization.Problem statement
We need to display the total municipal tax collected by five major cities of
the country. The taxes collected are in the ratio of To the bar graph, we
will add a slider so that the graph is updated based on the multiple values
selected on the slider. Let us look at the code:
import ipywidgets as widgets
import matplotlib.pyplot as plt
# Define data
x_data = 'City 'City
y_data = #initial value
# Define a slider widget
slider_wid =
# Define a function to update the graph when slider value changesdef
# x is of type: 'traitlets.utils.bunch.Bunch'>
val =
plt.clf()
plt.bar(x_data , [element * val for element in y_data])
Tax Collection (Rs
plt.show()
# Call the function when the slider value changes
slider_wid.observe(update_graph,
# Display the slider
display(slider_wid)Explanation
The preceding code creates a bar graph with five data points and links it with
a slider ipywidget to control the bar graph. Firstly, the necessary libraries,
such as matplotlib, and ipywidgets are imported. Secondly, the x-axis and y￾axis data sets are created. The third step is to create the slider widget using
the IntSlider function. This function takes in the min and max values, step
size, readout format, and other parameters of the slider. In the fourth step, we
have the update_graph() function that plots the bar graph. Finally, the graph is
linked to the slider using the observe() method of the widget. The observe()
method takes in the update_graph function name and value from the slider as
arguments and calls the update_graph function to plot the bar graph taking in
the value of the slider. Figure 8.5 illustrates the explanation through a bar
graph:Figure Data visualization linked with ipywidget exampleMatplotlib Library
Matplotlib is a comprehensive library for creating static, animated, and
interactive visualizations in Python. It provides a large number of different
plotting capabilities, such as line plots, bar charts, histograms, and scatter
plots. It is also capable of creating 3D plots and pseudo-color plots.
Matplotlib is designed to be a flexible and powerful tool for creating all
kinds of visualizations. It is highly customizable and provides many
options for controlling the look and feel of the plots. For example, it
allows the user to choose the colors, line widths, font properties, and even
the layout of the plot.
In addition to the basic plotting capabilities, Matplotlib provides a number
of other features. These include the ability to customize the plot with
annotations and labels, and the ability to export the plot in various
formats, such as PDF, SVG, and EPS. It also supports logarithmic and
semi-logarithmic plots and provides several options for creating contour
plots. Matplotlib also provides various functions for creating statistical
plots, such as box plots, violin plots, and kernel density estimation plots. It
is also capable of creating animations and interactive plots and can be
used to generate interactive web applications.
In the next section, we will take public data and create a dashboard for
tracking Covid-19 cases.Project: Covid-19 interactive dashboard
In this section, we will build the Covid-19 dashboard to provide a
comprehensive overview of the Covid-19 pandemic. This dashboard will
provide a visual representation of the latest data taken from CSV files on
the pandemic, making it easy for users to quickly analyze and track the
spread of the virus. The dashboard will display a range of metrics,
including the number of confirmed cases, active cases, recoveries, and
deaths related to the virus around the world. The dashboard will be
designed to be both easy to use and informative, giving users a detailed
overview of the current situation in the fight against the virus. This
dashboard can become an invaluable resource for anyone looking to stay
informed about the global pandemic.
Let us build the dashboard step by step.Interactive dashboard with Panel
Panel is an open-source Python library that allows you to create interactive
dashboards and data visualizations within Jupyter Notebooks. It is a powerful
tool for data exploration and analysis. Jupyter notebook provides a simple yet
powerful way to create interactive dashboards along with other data-driven
applications. While Panel is relatively new, it has already been used to create
some impressive dashboards and applications. It is an excellent tool for
creating interactive, data-driven dashboards in Jupyter notebooks. Follow
these steps to create a dashboard with Panel:
Import the required libraries
If you have not installed them already, it is time to do so. We need to use the
pip command to install the following libraries before importing the following
libraries: seaborn, and For example, to install you can use the following:
pip install matplotlib
Now, you can start importing them as shown here:
import pandas as pd
import numpy as np
import panel as pn
import matplotlib.pyplot as pltimport seaborn as sns
import plotly.graph_objs as go
import plotly.express as px
from numerize import numerize
pn.extension('tabulator')
import hvplot.pandas
import geopandas as gpd
Read the datasets (Covid and Vaccines)
# cache data to improve dashboard performance
if 'data' not in pn.state.cache.keys():
df = pd.read_csv('WHO-COVID-19-global-table-data.csv')
pn.state.cache['data'] = df.copy()
else:
df = pn.state.cache['data']df_vaccination = pd.read_csv('vaccination-data.csv')
df_vaccination.shape
# Make DataFrame Pipeline Interactive
idf = df.interactive()
Understand the data and the content
WHO-Covid 19 data:
df.describe()
Vaccines data:
df_vaccination.shape
df_vaccination.describe()
Perform data cleaning
WHO-Covid 19 data:
# Check null values in each column in percentage(df.isnull().sum() / * 100
# This heatmap shows us the null columns for WHO Covid 19 data
sns.heatmap(df.isnull(),
The output from the preceding code is shown in FigureFigure 8.6: Heatmap showing missing columns in WHO Covid 19 dataset
Drop columns that have almost blank values:
- newly reported in last 24 inplace =
Now, let us drop the rows that have null values:
# Check null values in each column in percentage
(df.isnull().sum() / * 100
Now all columns have got rid of null values, and you get the output shown in
FigureFigure 8.7: Null values in each column after cleaning the WHO Covid 19
dataset
Get the unique list of region names:
country_list =
country_list
Now columns:
df.columns
Data cleaning of Vaccines data that has been imported:
# Check null values in each column in percentage
(df_vaccination.isnull().sum() / * 100
# This heatmap shows us the null columns
sns.heatmap(df_vaccination.isnull(),
Figure 8.8 shows the heatmap output:Figure 8.8: Heatmap showing the missing columns in the Vaccines dataset
Drop all the rows with null values:
=
vacinated_country_list =
df_vaccination.columns
Perform data visualization
First Visual:
# Creating Bar Graph in Hvplot
colors = {
'Western
'Eastern
'South-East '#ff595e'}
def
return 'Cases - cumulative
rot =
Cases across
plot_bars_1()
Figure 8.9 shows the first visual we get:
Figure 8.9: First visual, i.e., a bar graph showing cumulative cases across
regionsSecond Visual:
# Creating Bar Graph in Hvplot
colors = {
'Western
'Eastern
'South-East '#ff595e'
}
def
return 'Deaths - cumulative
rot =
DeathDeath Cases across
plot_bars_2()
The figure given below will be the second visual we get:
Figure 8.10: Second visual, i.e., a bar graph showing cumulative death cases
across regions
Third Visual:
columns = list(df.columns[1:-1])
x = pn.widgets.Select(value='Cases - cumulative total', options=columns,
name='x')
y = pn.widgets.Select(value='Deaths - cumulative total', options=columns,
name='y')scatter_plot = pn.Row(pn.Column('## Covid Scatter Plot', x, y),
pn.bind(df.hvplot.scatter, x, y, by='Name', width = 1190, height = 500))
scatter_plot.show()
The third visual is created using Panel widgets, which are displayed in a web
browser; so, the preceding code will open a web browser, as shown here:
Figure 8.11: Third visual, i.e., scatter plots showing Cases versus Deaths
across regions
Prepare for creating a dashboard with Panel
# Card 1 - Total Vaccinated person
TOTAL_VACCINATION = df_vaccination.TOTAL_VACCINATIONS.sum()
# Card 2 - Total Vaccinated person
FULLY_VACCINATED_PEOPLE =
df_vaccination.PERSONS_FULLY_VACCINATED.sum()# Card 3 - Total Vaccinated person
TOTAL_BOOSTER_DOSE =
df_vaccination.PERSONS_BOOSTER_ADD_DOSE.sum()
# Card 4 - Total Vaccinated person
= - cumulative - - cumulative
TOTAL_PEOPLE_RECOVERED =
df.TOTAL_PEOPLE_RECOVERED.sum()
TOTAL_VACCINATION = numerize.numerize(TOTAL_VACCINATION)
FULLY_VACCINATED_PEOPLE =
TOTAL_BOOSTER_DOSE =
numerize.numerize(TOTAL_BOOSTER_DOSE)
TOTAL_PEOPLE_RECOVERED =
numerize.numerize(TOTAL_PEOPLE_RECOVERED)
table =
vaccination_vs_country_bar = height = rot =
Create a dashboard using Panel#Layout using Template
from panel.template import DarkTheme
template = = 'Covid-19 theme = DarkTheme,
Total Vaccination Completed : " +
Fully Vaccinated People : " +
Total Booster Dose Completed : " +
Total Recovered Population : " +
],
main = [
pn.Row(plot_bars_1(), plot_bars_2()),
pn.Row(vaccination_vs_country_bar),
pn.Row(scatter_plot),
] )This will launch the server, and you will get a message, which is something
like the following:
Launching server at http://localhost:65185
Clicking on the URL will launch a dashboard shown in Figure
Figure 8.12: Dashboard viewInteractive dashboard with Voila
Voila is preferred when it comes to creating dashboards in Jupyter Notebook
because it provides an interactive environment for building and sharing
interactive dashboards in Jupyter Notebook. Voila allows users to combine
their data, code, and narrative into a single, interactive experience by
leveraging the power of the Jupyter Notebook. It also provides extensive
support for interactive widgets, which makes it easy to create interactive
dashboards without having to write any code. Finally, Voila is highly
extensible, which allows users to customize the look and feel of their
dashboards.
In this section, we will build another dashboard with widgets and maps and
display using Voila. First, folium library needs to be installed before
proceeding with the following code:
Import libraries
import folium
from ipywidgets import Layout
import ipywidgets as widgets
import matplotlib.pyplot as plt
from folium import plugins
from ipywidgets import Layoutimport pandas as pd
import seaborn as sns
import numpy as np
Folium library will give access to folium maps, which we will draw using
Latitude and Longitude values given in the Vaccines
Check the dataset
df_vaccination =
df_vaccination.shape
df_vaccination.describe()
Perform the same set of analysis as done in the previous section.
Perform data cleaning
Check and drop the null values from the dataset:
# Check null values in each column in percentage
(df_vaccination.isnull().sum() / * 100# This heatmap shows us the null columns
sns.heatmap(df_vaccination.isnull(),
=
Add ipywidgets
Now, we will add three widgets: one for slider and two multiple selectors to
select the country and region:
style =
limit_case = widgets.IntSlider(
unique_country = df_vaccination.COUNTRY.unique()
unique_region = df_vaccination.WHO_REGION.unique()country = widgets.SelectMultiple(
options = unique_country.tolist(),
value =
#rows=10,
layout =
)
category = widgets.SelectMultiple(
options = unique_region.tolist(),
value =
#rows=10,
layout =)
Create the Update() function
Add the update function to read the changes in the widgets and update the
dashboard:
def 
#df_vaccination
latitude = 60
longitude =
df_country =
df_category =
cat_unique =
country_unique =
fig, (ax1, ax2) =
# create map and display it
country_map = longitude],country_count = plugins.MarkerCluster().add_to(country_map)
# loop through the dataframe and add each data point to the mark cluster
for lat, lng, label, in df_category.lng, df_category.WHO_REGION):
folium.Marker(
lng],
# show map
#Bar graph to show Fully Vaccinated Person per 100
Vaccinated Person per
country_unique)Vaccinated Person per
plt.show()
Execute the dashboard
Display the dashboard using the interactive() function of
widgets.interactive(update_map, country = country, category =
The dashboard will look like the following figures. Figure 8.13 shows the
selection widgets. Figure 8.14 shows the world folium map, and Figure 8.15
shows the bar graph connected to the selection widget:
Figure Widgets created for the dashboardFigure Countries presented on the map using foliumFigure Bar graph connected to multiple select widget
Use Voila to present the dashboard
If you have not installed the voila library yet, you must install it before
exporting the dashboard.
To install the library: at the terminal, type the following:
pip install voila
Then, run the following command at the terminal to launch the dashboard in a
web browser:
voila path/to/your/notebookfilename.ipynb
Apart from Panel and Voila, which we have used earlier, there are two
popular dashboarding frameworks available in Python: Streamlit and Plotly
Dash. Readers are encouraged to practice two other frameworks as well. Here
is a brief description to just understand these frameworks:
Streamlit: It turns Python scripts into interactive dashboard applications,
which are shareable as well.
Dash: Dash is built on top of a JavaScript library for creating interactive,
web-based data visualizations. With Dash, users can create interactive, data￾driven dashboards and data visualizations that are responsive and look great
on any device. Dash also provides a wide range of user-friendly features, suchas a drag-and-drop GUI, built-in user authentication, and a range of powerful
data manipulation and plotting tools.
Voilà: It converts Jupyter Notebooks into standalone interactive web-based
dashboard applications, along with the exploratory data analysis phase.
Panel: It is a flexible dashboard framework that works the same in Python
script files and Jupyter Notebook.Conclusion
In this chapter, we learnt to work with Jupyter Notebook and to create
interactive and shareable dashboard. Dashboards allow us to quickly
identify areas with high concentrations of cases, compare countries, and
track the impact of interventions. Creating a COVID-19 dashboard is not a
simple task; it requires careful planning, data collection, and analysis. It is
important to ensure that the data and information included in the
dashboard is accurate and up to date. Furthermore, it is important to
ensure that the dashboard is user friendly and easily understandable, as it
should be accessible to a wide range of audience.
Overall, this dashboard provides users with an interactive and detailed
view of the global spread of COVID 19. It is a useful tool for
understanding the current situation and for tracking the progress of the
virus.
In the next chapter, you will learn how to use VS Code interface to edit,
and debug in Jupyter Notebook. This will include setting up breakpoints,
inspecting variables, and creating and managing launch configurations.
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the
Authors:
https://discord.bpbonline.comChapter 9
Editing and Debugging Jupyter Notebook
Program testing can be used to show the presence of bugs, but never to
show their absence.
— Edsger W. Dijkstra, Computer ScientistIntroduction
Editing and debugging are two important tasks that need to be done when
writing computer code. Editing is correcting errors in the code and making
it more readable, while debugging is the process of finding and fixing
errors in the code. In Chapter 8, Jupyter Covid-19 Interactive Dashboard,
we built an application using Jupyter Notebook, and now we will learn
how to debug a Jupyter Notebook program in Visual Studio Code (VS
This chapter introduces the process of debugging a Jupyter Notebook file
in VS Code. Debugging is an essential skill for any software professional,
and Jupyter Notebook is a popular open-source tool for interactive
computing, data analysis, and scientific computing. VS Code is a popular
source code editor with a wide array of features and extensions, making it
a great choice for debugging Jupyter Notebook files.
This chapter covers the basics of debugging Jupyter Notebook files in VS
Code. First, we will discuss the basics of configuring VS Code for
debugging. This includes setting up breakpoints, inspecting variables, and
creating and managing launch configurations. Then, we will discuss how
to debug a Jupyter Notebook file in VS Code. We will also cover the roles
of the Python Interactive Window and the Debug Console, and we will
look at debugging tips and best practices. Finally, we will discuss how to
debug Jupyter Notebook files without using VS Code.Structure
In this chapter, we will discuss the following topics:
Introduction to debugging in Jupyter Notebook
Types of errors
Checking your code syntax
Verifying the outputObjectives
Continuing with the interactive dashboard application from the previous
chapter, in this chapter, you will learn how to use VS Code interface to
edit and debug in Jupyter Notebook. You will learn how to edit and
arrange cells. In the Notebook environment, you will learn about editing
features like code completion, definition, declaration, and formatting. By
the end of this chapter, you should have a solid understanding of how to
debug a Jupyter Notebook file in VS Code.Introduction to debugging in Jupyter Notebook
A good program to practice debugging is the classic FizzBuzz It prints out
numbers from 1 to 100, replacing any number divisible by 3 with the word
Fizz and any number divisible by 5 with the word Any number divisible
by both 3 and 5 should be replaced with
This program is simple enough to understand and complex enough to
require debugging. Writing the code out and debugging should give you
the practice you need to become a better programmer.
The program goes like this:
class MyFizzBuzz:
def __init__(self, start, end):
self.start = start
self.end = end
def run(self):
for value in range(self.start, self.end+1):
if value % 3 == 0 and value % 5 == 0:print("FizzBuzz")
elif value % 3 == 0:
print("Fizz")
elif value % 5 == 0:
print("Buzz")
else:
print(value)
fb = MyFizzBuzz(1, 100)
fb.run()
The expected output is as follows:Figure 9.1: Output from the program
There are two ways to debug a Jupyter Notebook:
Run by line - a simpler mode
Full debugging mode
To debug in any of these modes, make sure you have the following:
Need to have installed: ipykernel 6+ in the environment
Need to have kernel based on Python 3.7+
VS Code version should be v1.60+
Jupyter extension version should be v2021.9+
Follow these steps to install ipykernel:
Open the terminal and activate the Notebook environment.
Run: pip install -U ipykernel
Close and reopen VS Code. Now, when you open a Jupyter notebook file,
you should be able to select the kernel you just installed from the kerneldropdown menu (top-right corner of the notebook interface). In case of
any problem, go to The Developer: Reload Window command and reload
it.
Note: This installation may look different if you are using macOS.Debug the program line by line
Run by line allows you to execute a cell one line at a time without being
distracted by other VS Code debug features.
Figure 9.2: Line-by-line options
Follow these steps to debug the program line by line in Jupyter notebook:
To begin, click the Run by Line button in the cell toolbar. This will open the
debug control which will let you step through the code line-by-line.
You can also set breakpoints, examine variables, and more without leaving
the cell. You can use the same Run by Line button to advance to the next
statement in your code. To stop before the end of the cell, click the Stop
button. To continue running to the end of the cell, click the Continue the
toolbar.Launch the debugger by clicking on the Run by Line option or hitting
When the debugger is running, you will notice another option available,
which is to Continue Execution or use the shortcut option
The original options are shown in Figure 9.2, and the in-progress option is
shown in
Figure
Figure 9.3: Line by line debugging in-progress
Follow these simple steps to debug:
Run the program by pressing the Run Cell button.If the program does not produce the expected output, go back and check the
logic of each line of the program.
If you find any mistakes in the logic, correct them and then run the program
again.
If the program produces the expected output, go back and check the input
values to ensure that they are correct.
If the input values are incorrect, correct them and then run the program again.
If the program still does not produce the expected output, use the print()
statement to print out the intermediate results of each step of the program.
This will help you identify the bug.
Once you have identified the bug, correct it and then run the program again.
If the program produces the expected output, you can be sure that the has
been successfully debugged.Full debugging option
The full set of debugging features supported in VS Code can be used. Some
of the features available here are breakpoints, the ability to step into other
cells, and the ability to step into imported modules.
Follow these steps to debug the program thoroughly:
Open VSCode and the Python file containing the code you want to debug.
Click on the Debug tab at the top of the window, as shown in Figure
Figure 9.4: Option to start full debugging
On the Debug tab, select Python: Attach to Jupyter Kernel from the drop￾down list.Click the green play button to start the debugger.
Set breakpoints in the code by clicking in the left gutter of the code editor.
Run the code in Jupyter, and the debugger will hit the breakpoints when
encountered.
If you are new to VS Code, you will see many new things here, as shown in
Figure
Figure 9.5: Full debugging option in action
Let us understand them to get some clarity on their purpose.
Variables pane: You can easily inspect the variables that are created while
debugging is in progress. You can see the entire list of variables with their
current values stored. You can also see the difference between global andlocal variables. The local variables are the ones that have limited scope, for
example, variables in the function.
Watch This pane is like a subset of the variables pane, which shows only the
variables you are interested in and not the entire list. You can add the
variables you are interested in to the watch pane by clicking on the + icon
when we hover over the pane. The watch pane is a great way to watch and
monitor only the variables that seem not to work.
Call stack Consider a situation where you have multiple inner methods to
debug to precisely reach the line of code that is throwing the error or not
working as expected. The call stack pane helps in such cases to navigate deep
inside a stack data structure where the output of the functions is stored and
helps by precisely identifying the area from which the error came.
We discussed earlier as well that breakpoints are a very important concept
while debugging. In normal execution, you do not define or specify any
breakpoints as you want the program to run without any stoppage and give us
the desired outcome. But when there is an error, the execution stops at the
line that caused the error. However, while debugging you might want to
control the execution of a program earlier and monitor the state of the
variables at a particular point to understand what could have caused the error.
So, you can place a breakpoint by simply clicking to the left of the line
number in the editor. The created breakpoint will be indicated by a red dot,
similar to what we see in Figure The advantage of running the script with
breakpoints is that it will stop at the breakpoint and watch what has happened
to the program.
Use the debugger controls to step through the code line by line, inspect
variables and evaluate expressions. Other options available here are as listed
here:It executes the next line of code in the current function. If there is no next line
of code, the execution jumps to the next statement outside the current
function.
Step It executes the next line of code in the current function. If it encounters a
function or method call, the debugger will enter the code of that function or
method.
Step It executes the next line of code in the current function. If it encounters a
function or method call, the debugger will execute that line of code without
entering the code of that function or method.
Step It exits the current function and executes the next line of code outside
the function.
Set Breakpoint: It sets a breakpoint at the specified line of code. The
debugger will pause the execution of the program when it reaches the
breakpoint.
Clear Breakpoint: It removes breakpoint from the specified line of code. The
debugger will no longer pause the execution of the program when it reaches
the breakpoint.
When finished, click the red stop button to end the debugging session.
You can use the Debug Debug and other options as well from the Debug
Toolbar as you normally would in VS Code.We learned about adding breakpoints and using them to check the program’s
status. It is important to know that VS Code has three different types of
breakpoints, each one for a different purpose. To select one of these, first you
need to create a normal breakpoint, and then right-click on it and select Edit
as shown in Figure
Figure Breakpoint options available after creating one
Now, let us understand the purpose and characteristics of the different types
of breakpoints:
Expression: This is the normal breakpoint, which triggers and stops the code’s
execution when the condition is met. The condition can be seen in the watch
pane or the variable pane. You can set the code to stop executing when the
given condition is met. Also, this type of breakpoint is characterized by
having “=” in the breakpoint red dot. Expression breakpoints allow you to set
a breakpoint based on an expression. This expression can be a variable, an
object, or a function. When the expression evaluates to be accurate, the
breakpoint will be triggered. Expression breakpoints can be set in the
debugger and used in conjunction with other types of breakpoints. Figure 9.7
shows how to add Expression breakpoint:Figure 9.7: Types of Breakpoint options to choose
Hit Count: A hit count breakpoint allow you to set a breakpoint that will be
triggered after a line of code has been executed a certain number of times.
This breakpoint is helpful for debugging code that has a loop or is executed a
set number of times.
Log Message: Log message breakpoints allow you to set a breakpoint that
will be triggered when a certain message is logged in the console. This type
of breakpoint is helpful in monitoring a program’s progress or debugging an
issue related to a particular message. A log message breakpoint can be set in
the debugger and used in conjunction with other types of breakpoints. This
breakpoint does not stop the execution; instead, it is used for printing out
some message to the log in the debug console.
A breakpoint can be disabled by right-clicking it and selecting Disable
These are the different options available to debug a Python program for
Jupyter in VS Code.Types of errors
Errors in Python programs occur when the program encounters an
unexpected situation that is beyond its capacity to handle. These errors
can stem from syntax issues, runtime problems, or logical flaws.
Programmers and developers tend to make three types of errors:
Syntax Syntax errors are the basic type of error and occur when the
programmer fails to follow the proper syntax for the language. This type
of error will produce a Syntax error exception when the code is run.
Examples of syntax errors include missing parentheses, incorrect
indentation, and misspelled keywords.
Runtime Runtime errors occur when the code is syntactically correct but
fails to execute properly. These errors usually occur when the code tries to
perform an action that it cannot, such as dividing by zero. These errors
will produce a runtime error exception when the code is run.
Logical errors: Logical errors occur when the code is syntactically correct
and executes without producing any runtime errors, but the result is not
what was intended. These errors are usually caused by incorrect logic in
the code or incorrect assumptions about the data. These types of errors are
often difficult to track down and fix.
Now, that we understand the types of errors that can occur, let us look at
how to debug in Python.Checking your code syntax
When debugging a Python program, there are a few basic steps you can
take to check your code syntax and identify any errors.
Check your indentation: Python relies on indentation to denote the scope
of code blocks and functions. Therefore, it is important to make sure all
indentation is correct. If there are any errors in the indentation, your
program may not run as expected.
Check your variable names: It is important to make sure that all your
variable names are correct and match up with the correct objects. This can
help avoid errors such as trying to assign a value to a variable that does
not exist.
Check your syntax: Make sure all the syntax in your program is correct.
This includes ensuring that all punctuation, brackets, and quotes are in the
right places.
Check your logic: Make sure the logic of your program is sound. This
includes ensuring that loops are running correctly and conditions are
checked correctly.
Check your functions: Make sure all your functions are being called
correctly and returning the expected results.
Jupyter helps fix most of these things by highlighting the error in the code.Verifying the output
Always test your program’s output by giving known values and verify that
it works fine. While testing, make sure the following techniques are kept
in mind:
Functional tests: Functional tests are usually done by manually executing
the application and verifying that the expected results are produced.
Functional tests often involve a combination of manual and automated
tests, such as test scripts, to ensure that all aspects of the system are tested.
Algorithmic tests: Algorithmic tests are tests used to assess a person’s
ability to think logically and solve complex problems. Check if the logic
has been correctly and efficiently implemented.
Positive tests: Positive testing is a form of software testing that aims to
verifies that the functionality of a system or application confirms to its
predetermined specifications. It involves testing the system with valid
input to see if the expected output is produced. Positive testing, also
known as confirmation testing, is used to ensure that a system works as
expected.
Negative tests: Negative testing is a type of software testing that involves
testing the system by providing invalid or unexpected inputs to ensure that
the system handles the input correctly. This type of testing helps ensure
that the system can detect invalid inputs and respond accordingly.
Negative testing is often used to identify boundary conditions, errors in
input validation, and unexpected system behaviour.Boundary tests: Boundary tests (or edge case tests) verify the behaviour of
a program or system when the inputs are at the boundaries of the range of
valid inputs. These tests are designed to check how the system behaves
when given values that are slightly beyond the normal range of inputs.
Debugging can be a complicated process, but it will get easier with
practice. We are suggesting some easy tips to follow to debug your
program easily:
Use print statements: Print statements are one of the most helpful tools
when debugging in Python. By adding print statements to your code, you
can see what is happening and determine where the error is occurring.
Use a is a tool that allows you to step through your code line by line,
which helps you to identify exactly where the error is occurring.
Check for typos: Typos can often be the cause of errors. Make sure you
double-check your code for any typos before running it.
Simplify the code: If you are having trouble finding the error, try
simplifying the code. This means removing any unnecessary code and
making the code as simple as possible.
With these tips, you can debug your code quickly and efficiently!Conclusion
In this chapter, we have seen the basics of debugging in Jupyter Notebook
running in VS Code. Debugging is the process of finding and fixing errors
in a program. The purpose of editing and debugging in programming is to
ensure that the code is error-free and follows the language’s syntax.
Editing also makes the code more readable, allowing others to understand
it better. Debugging a Jupyter Notebook file using VS Code is a great way
to find and fix errors in your code. VS Code provides an interactive
debugging environment where you can set breakpoints, inspect variables,
view the stack trace, and step through code. It also integrates with the
Jupyter Notebook, allowing you to debug code within Jupyter Notebooks
as well.
By using VS Code for debugging, you can quickly and easily find and fix
errors in your Jupyter Notebook files.
In the next chapter, we will build graphical user interface applications
using Tkinter. Tkinter is a Python library used for building GUI. It
provides a set of tools and widgets for creating windows, buttons, menus,
dialog boxes, and more. Tkinter is included with the standard Python
distribution and is easy to learn and use, making it a popular choice for
GUI development in Python.Chapter 10
Mastering Tkinter GUI Capabilities using VS Code
The graphical user interface is the point of contact between people and
computers,
and it should be designed to let people get the most out of their machines.
— John Maeda, a popular contemporary American graphic designer
and also a renowned author and computer scientist.Introduction
Tkinter is a Python library that allows Python applications to create
Graphical User Interfaces It is a thin object-oriented layer on top of
Tcl/Tk. Tcl/Tk is an open-source, cross-platform GUI toolkit that provides
powerful GUI elements, such as buttons, labels, frames, and menus. It is
commonly used for creating graphical user interfaces, rapid prototyping,
and scripting. Tkinter provides various controls, such as buttons, labels,
and text boxes used in a graphical user interface to interact with a user. It
is the most popular and easy-to-use GUI library for Python, making it a
great choice for developing desktop applications.
Tkinter provides various widgets, such as labels, buttons, frames,
checkboxes, radio buttons, list boxes, and scroll bars. These widgets are
used as building blocks for creating a graphical user interface. They can
be used to create interactive applications with a graphical interface.
Widgets can be arranged in a window using various layout managers, such
as pack, grid, and place. Tkinter also provides a mechanism for binding
events to user interface elements, such as mouse clicks, keypresses, and
other events.
Tkinter is a popular choice for developing GUI applications in Python due
to its simplicity and ease of use. It is also available as part of the standard
Python distribution, making it easy to create a graphical user interface in
Python. It is also well supported by a wide range of third-party libraries
and resources.Structure
In this chapter, we will discuss the following topics:
Introduction to Tkinter
Understanding Tkinter widgets
Working with Tkinter events
Creating menus and toolbars with Tkinter
Developing an application: A quiz gameObjectives
The objective of learning Tkinter in Python is to gain an understanding of
how to develop GUIs and widgets using the Tkinter package. By learning
Tkinter, you will be able to create more interactive and user-friendly
programs to suit your needs. Additionally, you will understand the basic
principles of object-oriented programming, which is essential for creating
GUIs.Introduction to Tkinter
The window is the foundation element of Tkinter Some features of Tkinter
window are listed here:
A window in Tkinter is an object that contains a graphical window.
It is the main window object and provides access to all other window objects
and widgets.
It provides methods for creating and manipulating all types of widgets, such
as buttons, labels, menus, and frames.
It allows the creation of complex graphical user interfaces.
Widgets are the components that are used to create a graphical user interface,
such as buttons, labels, and text boxes. Widgets are used to interact with a
user, display information, and manage the layout of the GUI.
Let us build our first GUI program with a window and a couple of widgets.
But before that, we need to import the Tkinter
Step 1: Import the Tkinter Module
You can import the Tkinter module in Visual Studio Code (VS Code) by
going to your project directory in the terminal and typing:
pip install tkinterThis will install the Tkinter module in your project directory. Then, you can
import the module by typing the following at the top of your Python file:
import tkinter
Step 2: Creating First GUI Program
Create your Python file; the first line in the code should be as follows:
import tkinter as tk
Next, you need to create a window that is an instance of Tkinter’s Tk class.
Using the following code, you can create a new window and assign it to the
variable my_window and add labels and button widgets:
import tkinter
#Create the main window
my_window = tkinter.Tk()
#set window size
#widthxheight
#Set window title
TKinter GUI capabilities using VS
#Create a label
label = tkinter.Label(my_window, is a samplelabel.pack()
#Create a button
button = tkinter.Button(my_window, Here to
button.pack()
#Start the mainloop
my_window.mainloop()
In the preceding code, you can see that we have set the window size to 300 x
300 pixels using the geometry() method. The title() method has been used to
set the title of the window that appears on the top. This is seen in the output,
as shown in Figure The last line of the program, is added to run the Tkinter
event loop. This method runs infinitely and listens for any events that could
be fired, like a button click. The window that you see in Figure 10.1 appears
on a Windows machine. The appearance will change based on the operating
system.Figure 10.1: Tkinter window (on Windows)
We have added basic widgets in this example. In the next section, we will
learn more about widgets.Understanding Tkinter widgets
Tkinter provides a wide variety of widgets that can be used to build GUIs.
These widgets are used to create interactive applications in Python. To create
a widget, you must first create a window using the Tk() function and then
create the widget using its constructor function. Finally, you can add the
widget to the window and bind it to a function. Some of the commonly used
Tkinter widgets are as follows:
A widget used to create a button that can be used to execute a command or
perform an action
A widget used to display static text or an image
Check A widget used to create a checkbox that can be used to select or
deselect an option
A widget used to create a single-line text entry field
List A widget used to create a list of items from which the user can select one
or more given options
A widget used to create a menu bar with pull-down menus
A widget used to display a multi-line text message
Radio A widget used to create a radio button that can be used to select one
option from a group of optionsA widget used to create a slider that can be used to set a value on a scale
A widget used to create a scrollbar that can be used to scroll through a list of
items
A widget used to create a multi-line text entry field
Once the window has been created, you can create a Tkinter widget using the
widget’s constructor function. For example, to create a button widget, you
would use the following code:
button = tkinter.Button(root, text="Click Me!")
The first parameter of the constructor function is the parent window (in this
case, the root window), and the second parameter is a dictionary of options
that configure the widget. Once the widget has been created, you can add it to
the window using the grid() or pack() method. Take a look at this example:
button.grid(row=0, column=0)
This will add the button to the window at the specified row and column. The
next step is to add functionality. We will discuss this in the next section:
Working with Tkinter
Let us build a mini example where we will add different widgets. In the next
section, where we talk about events, we will add events to this example, and
similarly, we will add a menu bar when we discuss Menus andWe will first import the required packages:
import tkinter
import tkinter.messagebox as msgbox
Now, we will add the driving code which will have widgets:
if __name__
root = tkinter.Tk()
and Analysis
createmenu(root) #we will add the tool bar in this function later
root_label0 = tkinter.Label(root, Database Alpha
root_label1 = tkinter.Label(root, Username:
root_e1 = tkinter.Entry(root, # Display in text form
root_label2 = tkinter.Label(root, Password:
root_e2 = tkinter.Entry(root, # Display in ciphertext form
root_label3 = tkinter.Label(root, Digit Access Key:
root_e3 = tkinter.Entry(root, # Display in text form
root_label02 = tkinter.Label(root, Database Beta
root_label12 = tkinter.Label(root, Username:
root_e12 = tkinter.Entry(root, # Display in text form
root_label22 = tkinter.Label(root, Password:root_e22 = tkinter.Entry(root, # Display in ciphertext form
#Check button
chkbutton_Var1 = tkinter.IntVar()
chkbutton_Var2 = tkinter.IntVar()
ChkBttn = = "Select
ChkBttn2 = tkinter.Checkbutton(root, text = "Select
#Radio button
radiobutton_Var1 = tkinter.StringVar()
RBttn = tkinter.Radiobutton(root, Step
RBttn2 = tkinter.Radiobutton(root, Step
#Scale implementation
scale_label1 = tkinter.Label(root, your rating (1-10):
scale_var1 = tkinter.DoubleVar()
scale = tkinter.Scale(root,
#Scrollbar linked to a Listbox
scrollbar = tkinter.Scrollbar(root)
mylist = tkinter.Listbox(root,
for line in
mylist.insert(tkinter.END, "This is line number " +
#Save info
root_button1 = tkinter.Button(root, my info for thisroot.mainloop()
The preceding code will display a window with all the widgets added to itself,
as shown in Figure
Figure 10.2: Multiple Tkinter widgets added to a Window
In the preceding example, we added labels, text boxes, buttons, check boxes,
radio buttons, list box, scale, and scrollbar. In the last line, you will see thatthe button calls a function which we will implement in the Working with
Tkinter Events section.
Note: This application may look different if you are using macOS.Working with Tkinter events
Events are an important part of any GUI application, as they allow the
user to interact with the application. In this section, we will learn how to
use Tkinter events to create interactive applications. Events are user
actions that can be generated by the user or by the system. Examples of
user events include mouse clicks, mouse movements, and keyboard
presses. System events, such as timer events or window size changes, are
generated by the system. Events can trigger changes in an application,
such as updating the display or changing the state of the application.
Tkinter provides several methods for handling events. The bind() method
is used to bind an event to a function or method to be executed when the
event occurs. The bind_all() method is used to bind an event to all widgets
in the application. The event_generate() method is used to generate an
event programmatically.The bind() method
The bind() method is used to bind an event to a specific widget. The
syntax is as follows:
widget.bind(event, handler)
In the preceding example, the widget is to bind the event, the event
variable takes the event name, and the handler is the function or method to
be executed when the event occurs. The event name is a string
representing the event type, such as for a mouse click or for the return key.
Let us look at the example to capture any keypress on your keyboard. In
this example, we created a button widget and then used
bind(,button_function) to detect any key pressed on the keyboard:
import tkinter
import random
#Create the main window
my_window = tkinter.Tk()
#set window size
#Create button
button = tkinter.Button(my_window, Any Key on
def
score is:
button_function)#Start the mainloop
my_window.mainloop()The bind_all() method
The bind_all() method is used to bind an event to all widgets in the
application. The syntax is as follows:
root.bind_all(event, handler)
Here, root is the application’s root window, the event is the event name,
and the handler is the function or method to be executed when the event
occurs.The event_generate() method
The event_generate() method is used to generate an event programmatically.
The syntax is as follows:
widget.event_generate(event, **options)
In the preceding example, the given widget is to generate the event, the event
variable takes the event name, and options are optional keyword arguments.
Let us look at an example of how to use Tkinter events. We will create a
simple application that prints the co-ordinates of the mouse when the user
clicks on the window:
import tkinter as tk
#First, let's create the window and set the title:
root = tk.Tk()
#Next, we will define a function to handle the mouse click event:
def
# Get the coordinates of the mouse click
x = event.x
y = event.y
at x, y)
#Finally, we will bind the mouse click event to the window and start the main
loop:
on_click)
root.mainloop()Output:
Clicked at 138 53
Clicked at 125 69
Clicked at 54 105
Clicked at 58 50
When the user clicks the window, the coordinates of the mouse click will be
printed in the console.
Now, let us return to the mini project we started building in the previous
section. First, add a dummy event that we will link to all the widgets to
indicate that we are still adding the code. As we move ahead, we will replace
the dummy event code with the respective event’s code.
def
a sample function to handle all the
Let us now complete which is called by the main program:
def
alphausername = root_e1.get()
alphapassword = root_e2.get()
alphakey = root_e3.get()
betausername = root_e12.get()betapassword = root_e22.get()
text_disp = ""
if >
text_disp += "Beta Username:
if >
text_disp += ", Beta Password:
if >
text_disp += ", Alpha Username:
if >
text_disp += ", Alpha Password:
if >
text_disp += " and Alpha Key:
if chkbutton_Var1.get() ==
text_disp += ", \n Option 1 selected"
if chkbutton_Var2.get() ==
text_disp += ", \n Option 2 selected"
if
text_disp += ", Goto step 3 selected"
if
text_disp += ", Goto step 7 selected"
if
text_disp += ", Rating given:
#get list of selected items:
for i in mylist.curselection():
text_disp += ",
if <text_disp = "NONE"
"Following information have been saved for the current session only: +
text_disp)
The preceding code will be called when the Save All Info button is clicked.
This function demonstrates how we can read the values from different
widgets. This will open a message box with information that looks like Figure
Figure 10.3: Capturing the values from the widgets using an event
Let us now move on to the next section to add the toolbar.Creating menus and toolbars with Tkinter
Menus and toolbars are essential components of any GUI. They provide
users with a way to navigate a program, access important features, and
carry out tasks. This section will teach us to create menus and toolbars
with Tkinter, the standard Python GUI toolkit. We will go through the
basics of how to create menus and toolbars, and we will also learn how to
add items and customize the look and feel. By the end of this tutorial, you
should have a better understanding of how to create and customize menus
and toolbars with Tkinter.
Once we have created a window object using the Tk() function, we will
use this window object to create our menu. To create a menu, we must
first create a Menu object. This can be done using the following line of
code:
menu = Menu(window)
The Menu object takes one argument, which is the window object we
created earlier. Once the Menu object is created, we can add items using
the method. This method takes two arguments: a label, which is a string
that will be displayed on the menu; and a command, which is a function
that will be called when the item is selected. For example, to create an
item with the Open label and the open_file() command, we would use the
following line of code:
menu.add_command(label="Open", command=open_file)We can also add separators to our menu using the add_separator() method.
This method takes no arguments. Once all the items have been added to
the menu, we can display it using the window object’s method. This
method takes one argument, which is the menu object we created earlier.
For example, to display the menu on the window, we would use the
following line of code:
window.configure(menu=menu)Creating toolbars with Tkinter
Creating toolbars with Tkinter is just like creating menus. To create a
toolbar, we must first create a Toolbar object. This can be done using the
following line of code:
toolbar = Toolbar(window)
The Toolbar object takes one argument, which is the window object we
created earlier. Once the Toolbar object has been created, we can add
buttons using the method. This method takes three arguments: an which is
a bitmap image to be used as the button’s icon; a which is a function that
will be called when the button is clicked; and a which is a string that will
be displayed when the user hovers over the button.
For example, to create a button with the image the command and the
tooltip Open we would use the following line of code:
toolbar.add_button(image="icon.gif", command=open_file, tooltip="Open
File")
Once all the buttons have been added to the toolbar, we can display all of
these buttons using the window object’s configure() method. This method
takes one argument, which is the toolbar object we created earlier. For
example, to display the toolbar on the window, we would use the
following line of code:
window.configure(toolbar=toolbar)Customizing menus and toolbars
Once menus and toolbars have been created, they can be customized to suit
the user’s needs using the configure() method. This method takes two
arguments: an option, which is a string specifying the option to be
configured; and a value, which is the value to be set for the option. For
example, to select the font size of a menu to 12, we would use the following
line of code:
menu.configure(fontsize=12)
Let us now turn our focus to the mini project we have been building over the
last two sections and add the function to create a toolbar:
#Create UI Design
def
menubar = tkinter.Menu(root)
himenu = tkinter.Menu(menubar,
Demo
dcmenu = tkinter.Menu(menubar,
Demo
etmenu = tkinter.Menu(menubar,
file_new)
etmenu = tkinter.Menu(menubar,
command = run_sample)etmenu = tkinter.Menu(menubar,
1: Bi-weekly
2: Failed
3:
4:
Now, let us add an event to the File -> New menu:
def
clean_ui(root) #remove the existing widgets
file_new_design() # add new set of widgets
clean_ui() will look something like this:
#Clean UI Design
def
for widgets in root.winfo_children():
if widgets.winfo_class() !=
widgets.destroy()
file_new_design() will have new set of widgets added:
def
root_label0 = tkinter.Label(root, Database Alpbha
root_label1 = tkinter.Label(root, Username:
root_e1 = tkinter.Entry(root, # Display in text formroot_label2 = tkinter.Label(root, Password:
root_e2 = tkinter.Entry(root, # Display in ciphertext form
root_label3 = tkinter.Label(root, Digit Access Key:
root_e3 = tkinter.Entry(root, # Display in text form
root.mainloop()
The final output looks as shown in Figure Clicking the New menu under File
will delete the existing set of widgets (by calling and will create a new set of
widgets by callingFigure 10.4: Mini project final screen view
Note: This application may look different if you are using macOS.Developing an application: A quiz game
Learning programming by developing applications is an effective way to
gain hands-on experience and develop problem-solving skills. By writing
code and creating applications, you can learn to think logically and
develop algorithms to solve problems. This process can help you
understand the core principles of programming, such as variables,
functions, loops, and classes. Let us get started.Problem statement
This project aims to develop a Graphical User Interface quiz application
that allows users to answer multiple-choice questions and receive
immediate feedback on their answers. The application should also provide
users with a score summary of their performance and allow them to
navigate between questions easily. Furthermore, the application should
provide some kind of animation to make the application look interesting.
So, we will add some concepts from Zango tower-making game to this.
For each correct answer, a block will be added to the tower. A player will
have maximum three lives to play the game.Objectives
The objective is to collect as many blocks as possible while avoiding
giving wrong answers to the questions asked in the quiz show. Each
correct answer will put a block indicating 1 point scored by the player.
Along with these, the following features will be added to the game:
Take the player’s name as input.
Track the points scored. Also, save the highest point scored, along with
the player’s name.
Make questions from three difficulty levels available.
Use the maximum features of Tkinter while building the application.
Creating a quiz game show using Tkinter in Python is a great way to
engage users and learn more about them. With a few simple steps, you can
create a highly interactive and engaging quiz game show experience.Requirements
Based on the given problem statement and objectives, following are the
requirements:
Develop a GUI-based Tkinter quiz game that allows users to answer
questions and receive feedback on their performance.
Monitor the performance, player is provided with 3 lives, and the number
decreases with each wrong answer.
Create a user-friendly interface that allows users to answer multiple￾choice questions in an interactive way.
Create a live scoreboard to show the score. Each correct answer gets one
positive point and no negative marks for incorrect answers.
Design the game to be intuitive and easy to understand for users of all age
groups.
Utilize a text file to save the name of the player and score details of the
all-time highest scorer.Solution
The basic steps followed to develop this game are listed here:
Define the questions and answers for your quiz.
Create a window using the Tkinter library and set the title of the window.
Create a Tkinter frame to hold all the elements of the quiz game:
Create a label to hold the questions and answer options.
Create buttons to display the options; the users can click on the button to
select their answer.
Create a label to display the player’s name, top scorer, number of lives
left, and the current scorecard.
On one side, display blocks on top of each other as the score count
increases.
Display specific messages using MsgBox to announce the result.
Create a function to select the questions from the questions bank randomly
and, at the same time, make sure no questions are repeated.
Create an Exit menu on the menu bar to exit from the quiz.Design
We will create two screens: the first to accept names and the second with all
the components mentioned under the solution. This would look something
like Figure
Figure 10.5: Screens for the game
For this project, we will create four files:
will contain all the questions and answers. This file will contain three lists,
one each for the difficulty-level questions. Each member of the list will be a
dictionary that will store the questions and the responses. The list would look
something like this:
level1_questions = [
'What is 5+3 equal
'Sachin Tendulkar played which
...]
Each member of the list has three keys: question, choices for 4 options, and
reference to the correct answer. Similarly, build level2_questions and
level3_questions lists.
MyQuizGame.py: This is the main file where all the actions will take place.
We will have different sections within this file, like the following:
Importing modules and libraries:
We will import, of course, tkinter.messagebox along with pillow (PIL) for
handling images and a random module to select random questions from the
questions bank. Databank will also be imported to access the questions bank
in the list form.
Global variables
Important global variables like current score, highest score, number of lives,
and player’s name are declared, which will be accessible by all the functions
of the file.
Initialization of variables
Read the content of MyQuizGameScore.txt and assign this content to the
global variables. Also, read the level 1 questions from the
Declare the functionsWe will be using the following functions:
This main function will keep the game going. It will keep track of the score
and fetch the questions from Level 1 or 2, or 3 list based on the score. It does
not take any input or return any value. Question content is updated every time
this is run. This function has to run to keep the game moving till the end.
a_response(), b_response(), c_response(), These functions handle the
responses (button clicks) for options A, B, C, and D. Each button has a
different function associated with itself and prints whether the answer is
correct or incorrect.
This function checks the number of lives available and if indeed life is more
than 1, then continue with the main logic; if the answer is correct, build the
tower at the specific position. If life becomes zero, then the game exits, but
before that, it checks if the current player has broken the highest score. If yes,
then the MyQuizGameScore.txt is updated with the player’s name and score.
The gameover() function is called when all the lives are lost to close the
game.
It verifies the name entered during the welcome screen.
It is used to end the program whenever the user wants.Driving code
Two windows are created: the main welcome screen that accepts name and
the second window for playing the game.
The welcome screen is shown in Figure
Figure 10.6: Welcome screen of the project
Let us add a menu bar to the main screen. In this case, we will only
implement the Exit option but will add a label to start a new game and save
the existing game for future implementation. The menu would appear as
shown in FigureFigure 10.7: Menu bar option
The main screen has all the components and looks like FigureFigure 10.8: Screen 2 when a game is in progress
The complete code has been added under the implementation section for your
reference.
This file will store the highest score information, along with the name.
Initially, the file’s content would be as shown in Figure 10.9. This file will
update itself whenever someone scores higher than the previous highest
score.Figure 10.9: Image of the block
Block.png: This is the image of the block that would appear when the user
gets the answer right. The block image would look like Figure
Figure 10.10: Image of the blockImplementation
You have already seen the content of Databank.py, and In this section, the
complete code of the main file, which is is given for your reference. The
comment has the details for the code as well.
Here is the entire code for you to practice:
In the next section, we will import the required libraries:
from tkinter import *
import tkinter.messagebox as msgbox
from PIL import ImageTk, Image
from Databank import level1_questions,level2_questions,level3_questions
import random
import time
Now, let us declare and assign default values to the variables that will be
used later, like number of correct answers (answer), score tracking (score),
total lives remaining (life), player name, highest score so far, name of the
person who holds the highest score, and so on.
answer = 0
score = 0
life = 3
player_name = ""
highest_score = 0
highest_name = ""
tower_height = 27
timer_text = 30We need to save highest score details so that they can be fetched every
time the game is started. We will save it in the MyQuizGameScore.txt file.
If this file does not exist, then we will create it.
with as hs:
if hs.read():
data = hs.read().split()
highest_name =
highest_score =
except
pass
r = random.choice(level1_questions) #default level 1
In the next section, we develop a function called fetching_questions() to
keep track of the score and fetch the questions from Level 1 or 2 or 3 List
based on the score. It does not take any input nor does it return any value.
Question content is updated every time this is run. This function has to run
to keep the game moving till the end. The code for the
fetching_questions() function is given below:
def
global r, level1_questions,level2_questions,level3_questions, level2,level3
iflevel1_questions.remove(r)
if level1_questions:
r = random.choice(level1_questions)
, "Sorry, we have run out of
elif score #level 2
if
to the Next You now move to Level
if level2_questions:
r = random.choice(level2_questions)
level2_questions.remove(r)
"Sorry, we have run out of
#level 3
if
to the Next
"Congratulation! You have now moved to the Level
if level3_questions:
r = random.choice(level3_questions)
level3_questions.remove(r)
"You have completed the game. Good Job
Now, we will focus on writing functions to handle the answers. Since we
give four options to the user, we will have four functions: one each for
options A, B, C and D:def
"""Handle answer response A if the answer is correct or not"""
global answer
answer = 1
check_answer()
def
"""Handle answer response B if the answer is correct or not"""
global answer
answer = 2
check_answer()
def
"""Handle answer response C if the answer is correct or not"""
global answer
answer = 3
check_answer()
def
"""Handle answer response D if the answer is correct or not"""
global answer
answer = 4
check_answer()
The next function that we will write is which will check the number of
lives available and find out if at least one life is available for the player. If
life becomes zero, then the game ends, but before that it checks whether
the current player has broken the highest score. If yes, then
MyQuizGameScore.txt is updated with the player’s name and score. The
code for the check_answer() function is given below:def
"""checks the number of lives available and if indeed life is more than 1
then continue with the main logic, if answer is correct build the tower at
the
specific position.
"""
global score, answer, life, r, current_score
if life >
if answer ==
score = score + 1
loc = score * tower_height
660 - loc,
Right! "
"Your tower is now higher by one more
that's not correct. You lost a
life = life - 1
#Play the game
fetching_questions()
canvas.itemconfig(ques,
canvas1.itemconfig(rem_life, lives : *
=
=
=
=
current_score_canvas.itemconfig(score_current, Current Score :
if score >= highest_score:
with as f:Joys and Struggles of Life: "
"You are now the highest rated player and also the end of your game
Now we will develop two fundamental functions: one for handling the end
of the game and another for initiating the game. When life remaining
reaches zero, we stop the game by calling
For starting the game, we verify the name of the player before launching
the game.
def
"""Game over function when all the lives are lost"""
"You lost third life too. The game is
def
"""verifies the name entered during the welcome screen"""
global player_name
if name.get():
player_name = name.get()
first.destroy()
'Please Enter Your
Let us now define a timer function:
# Define a timer.
def
p = 30.00
t = time.time()
n = 0# Loop while the number of seconds is less than the integer defined in "p"
while n - t < p:
n = time.time()
if n == t + p:
timer_text up!"
timer_text = - t)
Next is a function that will chconfirmation before quitting:
def
"""To end the program whenever the user want to"""
choice = msgbox.askyesno(root, "Do You Really Want to
if choice:
In the next section, we will write the driving code that will call the
preceding functions:
if __name__ ==
first = Tk()
#hexadecimal code for blue color
#Bar to display the Title of the game
cs = Canvas(first, #yellow
QUIZ GAME
#Second Bar to message and accept the input
cs1 = Canvas(first,
Your Name:
# accept the name in textbox
name = Entry(first,#add the button and the text on it
sub =
first.mainloop()
#Start of second Window
if player_name:
root = Tk()
#Create Menu
menubar = Menu(root,
file = Menu(menubar,
Quiz
# metrics and question block
welcome = Canvas(root,
WELCOME
canvas2 = Canvas(root,
curr_score = SCORE : "
towers by
canvas1 = Canvas(root,
rem_life = lives : *
#Questions board
canvas = Canvas(root,
ques =
#placing option buttonsb1 = Button(root,
b2 = Button(root,
b3 = Button(root,
b4 = Button(root,
# tower code
canvas_tower = Canvas(root,
img2 =
resized_image2 = tower_height), Image.LANCZOS)
new_image2 = ImageTk.PhotoImage(resized_image2)
#Score label position
current_score_canvas = Canvas(root,
score_current = current Score :
#Display the block below score card
canvas_always = Canvas(root,
img1 =
resized_image1 = Image.LANCZOS)
new_image1 = ImageTk.PhotoImage(resized_image1)
root.mainloop()Future enhancements
So far, we have developed this application, but if you are interested in
taking it forward, you can extend this application and add a few other
features, like the ones listed here:
Provide a mechanism to save the game and load it back when the user
wants; only one last game saved would be available.
Ensure that the quiz game includes a timer to keep track of user progress
and provide feedback at the end of the game.
Provide users with a summary of their performance at the end of the
game, including total score, time taken, and number of correct and
incorrect answers, through a couple of visualizations.
Utilize a database to store user data and enable users to track their
progress over time.
Enhance it with additional features such as displaying images and playing
audio clips.
In this section, we developed a quiz game. Hopefully, this has given you a
chance to practice most Tkinter features. The purpose of adding this
example is to help you understand how different program components
interact with each other and how to debug and optimize code for better
performance.Conclusion
In this chapter, we saw that the Tkinter library provides an easy way to
create and manipulate GUI elements such as buttons, menus, and various
kinds of entry fields, and arrange them in a window. It is designed to be
used in Python scripts and is available as part of the standard Python
distribution. It is written in Python and uses the Tcl/Tk toolkit for the GUI.
It is easy to learn and use and is widely available on all platforms. With
Tkinter, we created attractive and powerful graphical user interface
applications with just a few lines of code.
Python comes with various GUI frameworks, but the Tkinter framework is
the only part of the Python standard library. Tkinter offers many
advantages, such as its cross-platform compatibility and reliance on native
operating system elements to render visuals. This results in applications
built with Tkinter appearing as though they are native to the platform they
are run on. It is lightweight and relatively easy to use as compared to other
frameworks, making it an attractive choice for building GUI applications
in Python, particularly when the main focus is to quickly create something
that functions well and is compatible with various platforms.
Now, we will focus on developing amazing interactive websites using the
Flask framework.
In Chapter 11, Developing a Flask-Based Web we will develop a website
using Flask. Flask is a lightweight web application framework written in
Python. It provides tools, libraries, and technologies that allow developers
to build a web application. It is an open-source project maintained by a
thriving community of developers.Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the
Authors:
https://discord.bpbonline.comChapter 11
Developing Flask-based Web Applications
The web is the most democratic application platform that has ever existed.
— Tim Berners-Lee, Computer ScientistIntroduction
Flask is a powerful web development framework for Python that is
designed to make the development of web applications easier. It is a
lightweight web application framework that offers an extensive set of
features and tools to help developers create highly functional web
applications. Flask was created in 2010 by Armin Ronacher and was
released under the BSD license. Flask is based on the Werkzeug WSGI
toolkit and the Jinja2 template engine. The main goal of this framework is
to help developers build a solid web application foundation and simplify
the development process. Flask is designed to be lightweight, modular,
and extensible. It is often called a microframework because it does not
require particular tools or libraries.
Flask has been used in many projects, including Pinterest and and is well
suited for creating APIs, simple web applications, and larger web
applications. It is often used with other frameworks, such as Django and
Flask takes advantage of several features that make it an ideal framework
for developing web applications. It offers a flexible yet powerful
architecture for creating web applications and services. It also uses object￾oriented programming, allowing developers to build and maintain
complex web applications easily.
Flask provides a great amount of flexibility in terms of the components
and features that can be used. It provides several core components that can
be used to build a web application quickly. These components include a
basic web server and request/response handling, URL routing, and supportfor templates. Additionally, Flask offers a wide range of extensions and
modules that can be used to add new features and capabilities to a web
application.
Flask also uses various development tools and platforms that make the
development process easier and more efficient. These tools include an
Integrated Development Environment a debugger, and an integration
Continuous Integration server. A CI server is a software tool that
automates the process of building, testing, and deploying software
changes. It helps teams to continuously integrate code changes from
multiple developers into a shared repository and ensure that they are error￾free. Additionally, Flask offers several libraries and frameworks that can
be used to add functionality to a web application.Structure
In this chapter, we will discuss the following topics:
Set up and create a basic application
Develop a Profile Application
Templates and static content
Setting up Database (SQLite3)
Integrate Flask-Login
Testing the databaseObjectives
The objective of this chapter is to learn Flask, as it is a popular web
framework for Python. It provides a lightweight layer of abstraction to
allow developers to create web applications quickly and easily, without
having to worry about the details of setting up a web server. Flask also
provides greater flexibility and customization than many other web
frameworks, making it a preferred choice for developers who want to
create unique, custom web applications. We will also see how to use
existing Python libraries and frameworks to create powerful web
applications. We will work to create a personal website using the features
of Flask.Set up and create a basic application
Flask needs to be installed. For this, you do not need to install a server to run
a Flask application. Flask is a web framework written in Python. It provides a
development server and a debugger that allows you to run your application
locally.
We assume that you are already working with Python in VS Code, and we
need to install Flask extension now. Create a folder named all our codes will
be in this folder. Follow the given steps to get the Flask application running
on your local machine:
Create a virtual environment using the virtualenv package: The first step to
creating a virtual environment using the virtualenv package is to install the
package. To do this, open a command line window and type pip install as
shown in
Figure 11.1: Installing virtual environment
This will install the virtualenv package. The main purpose of creating virtual
environments in Python is to create separate, isolated Python environments
for each project. This helps keep project-specific dependencies and libraries
organized and separate from other projects. It also helps avoid conflicts
between dependencies of different projects.Once the virtualenv package has been installed, you can create a new virtual
environment. To do this, open a command line window and type the
following:
virtualenv of environment>
As shown in Figure a virtual environment by the name of env has been
created:
Figure 11.2: Creating a virtual environment
This command will create a new virtual environment and place it in the
current directory.
Activate the virtual Once the virtual environment has been created, you need
to activate it. To do this, open a command line window and type the
following:
Mac OS/Linux: source of environment>/bin/activate`
Windows: of environment>\Scripts\activate
Make sure to replace of environment> with the name of the environment you
created. This will activate the virtual environment, and you will see the name
of the environment in parentheses next to the command prompt. In our case,
it would be as follows:Mac OS/Linux: source env/bin/activate`
Windows: env\Scripts\activate
Figure 11.3 shows how to run the preceding script:
Figure 11.3: Activate the virtual environment
Note: You may get the following error on Windows when you try to run the
preceding command: activate.ps1 cannot be loaded because running scripts is
disabled on this system. For more information, see about_Execution_Policies
at https:/go.microsoft.com/fwlink/?LinkID=135170.
The error occurs because the activate script command tries to run the
Activate.ps1 PowerShell script (.ps1 is an extension for PowerShell scripts).
Windows 10 system has the Execution Policy set to restricted by default, so
PowerShell cannot execute any script. We need to change the PowerShell
execution policy to remotesigned to fix this error.
Open the Start Menu on Windows, search for Powershell, and right-click on
it. Click on run as Type the following command in the PowerShell admin
window to change the execution policy:
> set-executionpolicy remotesignedYou will be prompted to accept the change, type A (Yes to all), and press
Enter on your keyboard to allow the change. Close the PowerShell admin
window, and go back and run the activate command.
Install the Flask extension in Visual Studio Code: Now that the virtual
environment is activated, you can install packages into it. To do this, open a
command line window and type the following:
pip install name>
Make sure to replace name> with the name of the package you wish to install.
This will install the package into the virtual environment. The package we
will now install is a Flask extension, simplifies the integration of
SQLAlchemy into Flask applications, providing useful tools and methods to
interact with your database using Figure 11.4 shows how to install
Figure 11.4: Installing package Flask-SQLAlchemy
You will also need to install flask_migrate and flask_login for future
functionalities.
Flask-Migrate is an extension that handles SQLAlchemy database migrations
for Flask applications using Alembic. This makes it easy to change your
database structure and integrate it with Flask as your application expands.
Flask-Login provides user session management for Flask. It handles thecommon tasks of logging in, logging out, and remembering your users’
sessions over extended periods. After installing these libraries, let us import
them in our program:
pip install flask_migrate
pip install flask_login
pip install flask_wtf
pip install email_validator
pip install pillow
We also need to install Flask-WTF is a Flask extension that provides
integration with the WTForms library. It helps simplify the process of
creating secure forms with minimal code. The extension provides multiple
features, such as form generation, validation, and auto-population of fields
with data from the database. Flask-WTF makes it easier to create secure,
multifunctional web forms on a Flask-based web application.
The email_validator module is a Python package that checks the syntax and
structure of email addresses. It is an API for validating emails that can be
used to prevent users from submitting invalid emails. This library can block
invalid email addresses from registering, reducing the amount of spam on a
system.
Python Imaging Library is a free library for the Python programming
language that adds support for opening, manipulating, and saving several
different image file formats. It is used by web developers and professionalimage editing applications. We will import pillow to manage the registered
user’s profile picture.
Create a new project folder and open it in Visual Studio Code: Now that the
virtual environment has been created and activated, you can open the VS
Code and start working on it. To do this, open VS Code and select the File >
Open option. This will open a file browser window. Navigate to the directory
where you created the virtual environment and select the folder. The folder
structure will look similar to the tree diagram shown in Figure VS Code will
now open the virtual environment, and you can begin working in it.
Figure 11.5: Folder structure
Create a file named app.py, which will be the main file for your Flask
application: Create a new file named app.py in the folder we just created
(FlaskApp). Now, let us create a basic Flask application. It will give us a
structure for the future application code. We will write the following code in
the app.py file:
#FlaskApp/app.py#Import libraries
from flask import Flask
#Set application, referencing this file
app = Flask(__name__)
#Set URL route
def hello_world():
return 'Hello, Flask Application is running'
if __name__ ==
App.py is a Python script file in a Flask application that contains the code for
the application. It is the main entry point for the application and contains the
code for setting up the application and its routes. The app.py code discussed
earlier typically contains the following:
Import the Flask The first step is to import the Flask module and other
modules that the application may need. This is usually done at the beginning
of the file.
Create the Flask This is done by calling the Flask() constructor.Configure the Flask app: This includes setting the base URL, the debug flag,
the secret key, the template folder, and other configuration options. We have
not set any of these in this example, but we will do this in the next example.
Create the This is done using the app.route() decorator. This decorator is used
to define the URL for each view function that the application will use.
Create the view This is done by creating functions that will be used to handle
requests. The view functions typically take in arguments for the request and
return a response.
Open the terminal in Visual Studio Code and run the application: The final
step is to run the application. This is done by calling the app.run() method.
This will start the application and make it available to handle requests. On the
terminal, type the following command:
python app.py
This will launch the server, and the output will look as shown in Figure
Remember, we have launched the development server now. When we
complete our work and are ready to deploy, we will switch to the production
version instead.Figure 11.6: Python code to execute app.py and the launch of the server
As shown in Figure the server is running on Open any browser and open You
will see that flask is running, as shown in Figure
Figure 11.7: Flask application running in the browserDevelop a Profile Application
We will learn the concepts of Flask application by developing an application.
Let us call this application My Profile Application and describe the
requirements:
The website will have the following web pages: Home, Education, Expertise,
Projects, and Testimonials.
Home will be a static page, whereas Education, Expertise, Projects, and
Testimonials will display the details from the database.
The website should have a user login page with username/password
authentication for access.
Only the admin users should be able to add content to the database for
education, expertise, and projects; any registered user should be able to add
testimonials to the page.
Admin should also be able to control the Testimonial page from the back end.
Flask applications have Views are functions in a Flask application controller
responsible for processing user requests and returning response data to the
user. The views are responsible for communicating with the model to retrieve,
edit, create, and delete data from a database and for formatting this data as a
response to the user. Views are typically written as Python functions that take
an HTTP request object and an optional array of parameters as arguments.
Figure 11.8 depicts the Views or Functions that we will create and add to this
website:Figure 11.8: Features available in the application
The functionalities shown under the core are to display the content to
everyone. Functionalities (or Views) under Users like login, logout, register,
account, and post testimonials are to be handled for registered users.
Testimonials functionalities are to make edits to Testimonials.
Let us start coding the application in the upcoming sections. But before that,
let us create a folder called where your app.py file is placed, as shown in
Figure All the files related to the My Profile application will be added to this
folder.
Figure 11.9: Folder structure for the projectWe need to add an empty __init__.py file in myprofile to mark this directory
as a package so that Python can recognize it as such. This file can be used to
initialize the package or set the __all__ variable. Under the myprofile folder,
create three folders named and testimonials to handle the views related to the
functionalities. Now, add an empty __init__.py file in all three folders.Templates and static content
The first set of content that we deal with while developing a Flask application
are templates and static. Let us create the static and templates folders under
the myprofile folder. Static and Templates have special meaning, so Flask
knows what to expect in these folders.
Templates in a Flask application are the front-end files used to render HTML.
They are written in HTML and use a special syntax to add dynamic content.
Flask uses the Jinja2 template engine to render templates and provide data
from the back end.
In Flask, static files refer to files that remain static, for example, image files,
CSS, JavaScript, and other files that a web application or website may need in
order to render properly. These files are typically stored within a static folder,
which is separate from the Python application and template files. Flask
provides a useful means to reference these static files through its static
directory. Flask provides a feature to define these in a folder outside the app’s
package directory for easy maintenance. This folder can be called and any
files inside it will be loaded whenever the application is run.
The main content for the static folder for this project would be the stylesheet
and the images. The profile.css file is used as the stylesheet, and the code
looks like the following:
*{
padding:
margin:
font-family: sans-serif;
}header{
background-color:
color: white;
height:
padding:
}
.resume_title{
text-align: center;
}
.skills{
display: flex;
justify-content: space-around;
}
.skill_title{
background-color:
color: white;
border-radius:
padding:
font-size:
}
.exp_title, .org_name, .org_date, .exp ul{
margin:
}
.exp_title, .org_name, .org_date{
color:
}
li{font-size:
}
.projects{
display: flex;
justify-content: space-around;
}
.project_details{
margin-right:
}
.projects ul{
margin:
}
footer{
background-color: black;
color: white;
padding:
}
.top_foot{
display: flex;
justify-content: space-between;
align-items: center;
}
.foot-left{
width:
padding:
border-right: solid white
}.foot-right{
display: flex;
justify-content: space-around;
width:
}
.foot-right li{
list-style: none;
padding:
}
.foot-right li a{
text-decoration: none;
color: white;
}
.foot-right li a:hover{
color: red;
transition:
}
.about{
margin-top:
padding: 0
}
.testimonial_card{
margin:
}
.testimonials{
margin:
}
.logo h1{
font-size:}
/* Media Query */
@media screen and
.skills, .exp, .education{
flex-direction: column;
padding:
}
}
@media screen and
.projects{
flex-direction: column;
padding: 0
}
.expert, .project_details{
margin: 0 0
}
}
@media screen and
.about_image{
width:
}
.image img{
}
.about_image p{
width:
}
}
@media screen and
.image img{width:
}
}
@media screen and
.testimonial_card {
margin:
}
}
@media screen and
.title{
font-size:
}
.image img {
margin-left:
}
}
@media screen and
.image img {
margin-left:
}
}
@media screen and
.foot-left{
border: none;
}
.top_foot{
flex-direction: column;
}
.foot-left{
width:text-align: center;
}
}
@media screen and
.foot-right{
flex-direction: column;
text-align: center;
}
}
h1 {text-align: center;}
table, th, td {
border: solid blue;
border-radius:
border-style: ridge;
} th, td {
border-color:
}
Put all the required images in the image folder. The folder structure within
static would look as shown in FigureFigure 11.10: Folder structure of static
We will now turn our attention to the templates folder. This folder will have
all the dynamic HTML content. When a user launches the website and has not
yet logged into the website, they should see the following options:
Home
Profile
Extra Curriculars
Future Goals
Testimonials
Login
Register
The web page view is shown in Figure
Figure 11.11: Screenshot of menu from the home page for a visitor
A logged in user should see the following options on the web page:Home
Profile
Extra Curricular
Future Goals
Testimonials
Log out
Account
Update
The preceding options should have navigation links pointing to the following
views, which we will create in the next section:
Extra
FutureLog
Now, we have an idea of which folder will have specific views. So far, we
have only created views in core and added the home page.
The index.html file is the main page of a Flask application. In the index.html
file, the user will typically find a page with links to the other views or pages
of the app. It can also include text, graphics, and other content. The file can
be edited to customize the design of the main page of the app. Before we
create our index.html file, it is recommended to create a base.html file that
will have header and footer content common to all the main pages. Creating a
base.html template in Flask helps ensure a consistent look for your web app.
This is beneficial for maintaining the visual style of the web app, enabling
faster development when making changes to the design. Additionally, by
using you can easily add elements such as headers, footers, and navigation
menus that appear on every page within your web application.
The base.html file (under templates folder) will look like this:
Section First part of any HTML file is, of course, the part. We are not adding
the head section code here. You can refer to the full code for reference, but
feel free to design your own version.Section Now we are looking at the body section. First, the header content is
added to the HTML code. Jinja template language is used in the code to make
it more dynamic. Jinja is a Python-based templating engine used by Flask that
allows you to dynamically generate HTML code. The most common usage of
the variable code in an HTML file is to output values from Python code into
the rendered template. This can be done using double curly braces {{ For
example, if you have a variable name in your Flask route, you can output its
value in the HTML template as {{ name When Flask renders this template, it
will replace {{ name }} with the actual value of the name variable passed
from the route. Besides outputting variable values, Jinja provides features for
control structures like loops and conditionals, allowing you to dynamically
change the structure and content of the HTML based on the provided data
from Flask.
text-bg-dark"
flex-wrap align-items-center justify-content-center
align-items-center mb-2 mb-lg-0 text-white
col-12 col-lg-auto me-lg-auto mb-2 justify-content-end
url_for('core.index') }}" px-2
url_for('core.profile') }}" px-2 
url_for('core.activities') }}" px-2 Curriculars 
url_for('core.goals') }}" px-2 Goals 
url_for('core.alltestimonials') }}" px-2 
{% if current_user.is_authenticated %}
url_for('users.logout') }}" px-2 Out 
url_for('users.account') }}" px-2 url_for('testimonials.create_post') }}" px-2 
{% else %}
url_for('users.login') }}" px-2 In 
url_for('users.register') }}" px-2 
{% endif %}
bi-list text-whiteDigital Portfolio
{% block content %}
{% endblock %}
Section Adding the footer part is going to be common for all the
pages that we will create.
SACHIN KOHLI
a software engineer with a passion for creating cutting￾edge applications. I strive to create high-quality solutions
to ensure that users have the best experience
{% if current_user.is_authenticated %}
url_for('users.logout') }}">Log
url_for('users.account')
{% else %}
url_for('users.login') }}">Log
url_for('users.register')
{% endif %}SACHIN KOHLI Contact:
Section This involves adding the Hamburger Menu
code. The hamburger menu is a common design
element used in website and mobile app interfaces. It
consists of three horizontal lines stacked on top of
each other, resembling a hamburger, hence the name.
When clicked or tapped, the hamburger menu expands
to reveal a hidden navigation menu or additional
options, providing a space-saving and intuitive way to
access secondary content or features. It is often used
in responsive design to optimize the user experience
on smaller screens by consolidating menu items into a
single icon.
offcanvas-start"
url_for('core.index') }}" px-2
url_for('core.profile') }}" px-2 
url_for('core.activities') }}" px-2 Curriculars
url_for('core.goals') }}" px-2 Goals 
url_for('core.alltestimonials') }}" px-2 
{% if current_user.is_authenticated %}
url_for('users.logout') }}" px-2 Out 
url_for('users.account') }}" px-2 url_for('testimonials.create_post') }}"
px-2 
{% else %}
url_for('users.login') }}" px-2 In 
url_for('users.register') }}" px-2 
{% endif %}

Probabilistic Machine LearningAdaptive Computation and Machine Learning
Francis Bach, editor
A complete list of titles can be found online at https://mitpress.mit.edu/search-result-list/
?series=adaptive-computation-and-machine-learning-series.Probabilistic Machine Learning
Advanced Topics
Kevin P. Murphy
The MIT Press
Cambridge, Massachusetts
London, England© 2023 Kevin P. Murphy
This work is subject to a Creative Commons CC-BY-NC-ND license.
Subject to such license, all rights are reserved.
The MIT Press would like to thank the anonymous peer reviewers who provided comments on drafts of this
book. The generous work of academic experts is essential for establishing the authority and quality of our
publications. We acknowledge with gratitude the contributions of these otherwise uncredited readers.
Printed and bound in the United States of America.
Library of Congress Cataloging-in-Publication Data
Names: Murphy, Kevin P., author.
Title: Probabilistic machine learning : advanced topics / Kevin P. Murphy.
Description: Cambridge, Massachusetts : The MIT Press, [2023] | Series:
Adaptive computation and machine learning series | Includes
bibliographical references and index.
Identifiers: LCCN 2022045222 (print) | LCCN 2022045223 (ebook) | ISBN
9780262048439 (hardcover) | ISBN 9780262376006 (epub) | ISBN
9780262375993 (pdf)
Subjects: LCSH: Machine learning. | Probabilities.
Classification: LCC Q325.5 .M873 2023 (print) | LCC Q325.5 (ebook) | DDC
006.3/1015192–dc23/eng20230111
LC record available at https://lccn.loc.gov/2022045222
LC ebook record available at https://lccn.loc.gov/2022045223
10 9 8 7 6 5 4 3 2 1This book is dedicated to my wife Margaret,
who has been the love of my life for 20+ years.Brief Contents
1 Introduction 1
I Fundamentals 3
2 Probability 5
3 Statistics 63
4 Graphical models 143
5 Information theory 217
6 Optimization 255
II Inference 337
7 Inference algorithms: an overview 339
8 Gaussian filtering and smoothing 353
9 Message passing algorithms 395
10 Variational inference 433
11 Monte Carlo methods 477
12 Markov chain Monte Carlo 493
13 Sequential Monte Carlo 537
III Prediction 567
14 Predictive models: an overview 569
15 Generalized linear models 583
16 Deep neural networks 623
17 Bayesian neural networks 639
18 Gaussian processes 673
19 Beyond the iid assumption 727viii
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
IV Generation 763
20 Generative models: an overview 765
21 Variational autoencoders 781
22 Autoregressive models 811
23 Normalizing flows 819
24 Energy-based models 839
25 Diffusion models 857
26 Generative adversarial networks 883
V Discovery 915
27 Discovery methods: an overview 917
28 Latent factor models 919
29 State-space models 969
30 Graph learning 1033
31 Nonparametric Bayesian models 1037
32 Representation learning 1039
33 Interpretability 1063
VI Action 1093
34 Decision making under uncertainty 1095
35 Reinforcement learning 1135
36 Causality 1173
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2023Contents
Preface xxix
1 Introduction 1
I Fundamentals 3
2 Probability 5
2.1 Introduction 5
2.1.1 Probability space 5
2.1.2 Discrete random variables 5
2.1.3 Continuous random variables 6
2.1.4 Probability axioms 7
2.1.5 Conditional probability 7
2.1.6 Bayes’ rule 8
2.2 Some common probability distributions 8
2.2.1 Discrete distributions 9
2.2.2 Continuous distributions on R 10
2.2.3 Continuous distributions on R+ 13
2.2.4 Continuous distributions on [0, 1] 17
2.2.5 Multivariate continuous distributions 17
2.3 Gaussian joint distributions 22
2.3.1 The multivariate normal 22
2.3.2 Linear Gaussian systems 28
2.3.3 A general calculus for linear Gaussian systems 30
2.4 The exponential family 33
2.4.1 Definition 34
2.4.2 Examples 34
2.4.3 Log partition function is cumulant generating function 39
2.4.4 Canonical (natural) vs mean (moment) parameters 41
2.4.5 MLE for the exponential family 42
2.4.6 Exponential dispersion family 43
2.4.7 Maximum entropy derivation of the exponential family 43
2.5 Transformations of random variables 44
2.5.1 Invertible transformations (bijections) 44
2.5.2 Monte Carlo approximation 45
2.5.3 Probability integral transform 45
2.6 Markov chains 46
2.6.1 Parameterization 47
2.6.2 Application: language modeling 49x
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.6.3 Parameter estimation 49
2.6.4 Stationary distribution of a Markov chain 51
2.7 Divergence measures between probability distributions 55
2.7.1 f-divergence 55
2.7.2 Integral probability metrics 57
2.7.3 Maximum mean discrepancy (MMD) 58
2.7.4 Total variation distance 61
2.7.5 Density ratio estimation using binary classifiers 61
3 Statistics 63
3.1 Introduction 63
3.2 Bayesian statistics 63
3.2.1 Tossing coins 64
3.2.2 Modeling more complex data 70
3.2.3 Selecting the prior 71
3.2.4 Computational issues 71
3.2.5 Exchangeability and de Finetti’s theorem 71
3.3 Frequentist statistics 72
3.3.1 Sampling distributions 72
3.3.2 Bootstrap approximation of the sampling distribution 73
3.3.3 Asymptotic normality of the sampling distribution of the MLE 74
3.3.4 Fisher information matrix 75
3.3.5 Counterintuitive properties of frequentist statistics 79
3.3.6 Why isn’t everyone a Bayesian? 82
3.4 Conjugate priors 83
3.4.1 The binomial model 83
3.4.2 The multinomial model 83
3.4.3 The univariate Gaussian model 85
3.4.4 The multivariate Gaussian model 90
3.4.5 The exponential family model 96
3.4.6 Beyond conjugate priors 98
3.5 Noninformative priors 102
3.5.1 Maximum entropy priors 102
3.5.2 Jeffreys priors 103
3.5.3 Invariant priors 106
3.5.4 Reference priors 107
3.6 Hierarchical priors 107
3.6.1 A hierarchical binomial model 108
3.6.2 A hierarchical Gaussian model 110
3.6.3 Hierarchical conditional models 113
3.7 Empirical Bayes 114
3.7.1 EB for the hierarchical binomial model 114
3.7.2 EB for the hierarchical Gaussian model 115
3.7.3 EB for Markov models (n-gram smoothing) 116
3.7.4 EB for non-conjugate models 118
3.8 Model selection 118
3.8.1 Bayesian model selection 119
3.8.2 Bayes model averaging 121
3.8.3 Estimating the marginal likelihood 121
3.8.4 Connection between cross validation and marginal likelihood 122
3.8.5 Conditional marginal likelihood 123
3.8.6 Bayesian leave-one-out (LOO) estimate 124
3.8.7 Information criteria 125
3.9 Model checking 127
3.9.1 Posterior predictive checks 128
3.9.2 Bayesian p-values 130
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
CONTENTS
3.10 Hypothesis testing 131
3.10.1 Frequentist approach 131
3.10.2 Bayesian approach 131
3.10.3 Common statistical tests correspond to inference in linear models 136
3.11 Missing data 141
4 Graphical models 143
4.1 Introduction 143
4.2 Directed graphical models (Bayes nets) 143
4.2.1 Representing the joint distribution 143
4.2.2 Examples 144
4.2.3 Gaussian Bayes nets 148
4.2.4 Conditional independence properties 149
4.2.5 Generation (sampling) 154
4.2.6 Inference 155
4.2.7 Learning 155
4.2.8 Plate notation 161
4.3 Undirected graphical models (Markov random fields) 164
4.3.1 Representing the joint distribution 165
4.3.2 Fully visible MRFs (Ising, Potts, Hopfield, etc.) 166
4.3.3 MRFs with latent variables (Boltzmann machines, etc.) 172
4.3.4 Maximum entropy models 174
4.3.5 Gaussian MRFs 177
4.3.6 Conditional independence properties 179
4.3.7 Generation (sampling) 181
4.3.8 Inference 181
4.3.9 Learning 182
4.4 Conditional random fields (CRFs) 185
4.4.1 1d CRFs 186
4.4.2 2d CRFs 189
4.4.3 Parameter estimation 192
4.4.4 Other approaches to structured prediction 193
4.5 Comparing directed and undirected PGMs 193
4.5.1 CI properties 193
4.5.2 Converting between a directed and undirected model 195
4.5.3 Conditional directed vs undirected PGMs and the label bias problem 196
4.5.4 Combining directed and undirected graphs 197
4.5.5 Comparing directed and undirected Gaussian PGMs 199
4.6 PGM extensions 201
4.6.1 Factor graphs 201
4.6.2 Probabilistic circuits 204
4.6.3 Directed relational PGMs 205
4.6.4 Undirected relational PGMs 207
4.6.5 Open-universe probability models 210
4.6.6 Programs as probability models 210
4.7 Structural causal models 211
4.7.1 Example: causal impact of education on wealth 212
4.7.2 Structural equation models 213
4.7.3 Do operator and augmented DAGs 213
4.7.4 Counterfactuals 214
5 Information theory 217
5.1 KL divergence 217
5.1.1 Desiderata 218
5.1.2 The KL divergence uniquely satisfies the desiderata 219
5.1.3 Thinking about KL 222
5.1.4 Minimizing KL 223
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexii
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.1.5 Properties of KL 226
5.1.6 KL divergence and MLE 228
5.1.7 KL divergence and Bayesian inference 229
5.1.8 KL divergence and exponential families 230
5.1.9 Approximating KL divergence using the Fisher information matrix 231
5.1.10 Bregman divergence 231
5.2 Entropy 232
5.2.1 Definition 233
5.2.2 Differential entropy for continuous random variables 233
5.2.3 Typical sets 234
5.2.4 Cross entropy and perplexity 235
5.3 Mutual information 236
5.3.1 Definition 236
5.3.2 Interpretation 237
5.3.3 Data processing inequality 237
5.3.4 Sufficient statistics 238
5.3.5 Multivariate mutual information 239
5.3.6 Variational bounds on mutual information 242
5.3.7 Relevance networks 244
5.4 Data compression (source coding) 245
5.4.1 Lossless compression 245
5.4.2 Lossy compression and the rate-distortion tradeoff 246
5.4.3 Bits back coding 248
5.5 Error-correcting codes (channel coding) 249
5.6 The information bottleneck 250
5.6.1 Vanilla IB 250
5.6.2 Variational IB 251
5.6.3 Conditional entropy bottleneck 252
6 Optimization 255
6.1 Introduction 255
6.2 Automatic differentiation 255
6.2.1 Differentiation in functional form 255
6.2.2 Differentiating chains, circuits, and programs 260
6.3 Stochastic optimization 265
6.3.1 Stochastic gradient descent 265
6.3.2 SGD for optimizing a finite-sum objective 267
6.3.3 SGD for optimizing the parameters of a distribution 267
6.3.4 Score function estimator (REINFORCE) 268
6.3.5 Reparameterization trick 269
6.3.6 Gumbel softmax trick 271
6.3.7 Stochastic computation graphs 272
6.3.8 Straight-through estimator 273
6.4 Natural gradient descent 273
6.4.1 Defining the natural gradient 274
6.4.2 Interpretations of NGD 275
6.4.3 Benefits of NGD 276
6.4.4 Approximating the natural gradient 276
6.4.5 Natural gradients for the exponential family 278
6.5 Bound optimization (MM) algorithms 281
6.5.1 The general algorithm 281
6.5.2 Example: logistic regression 282
6.5.3 The EM algorithm 283
6.5.4 Example: EM for an MVN with missing data 285
6.5.5 Example: robust linear regression using Student likelihood 287
6.5.6 Extensions to EM 289
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
CONTENTS
6.6 Bayesian optimization 291
6.6.1 Sequential model-based optimization 292
6.6.2 Surrogate functions 292
6.6.3 Acquisition functions 294
6.6.4 Other issues 297
6.7 Derivative-free optimization 298
6.7.1 Local search 298
6.7.2 Simulated annealing 301
6.7.3 Evolutionary algorithms 301
6.7.4 Estimation of distribution (EDA) algorithms 304
6.7.5 Cross-entropy method 306
6.7.6 Evolutionary strategies 306
6.8 Optimal transport 307
6.8.1 Warm-up: matching optimally two families of points 308
6.8.2 From optimal matchings to Kantorovich and Monge formulations 308
6.8.3 Solving optimal transport 311
6.9 Submodular optimization 316
6.9.1 Intuition, examples, and background 316
6.9.2 Submodular basic definitions 318
6.9.3 Example submodular functions 320
6.9.4 Submodular optimization 322
6.9.5 Applications of submodularity in machine learning and AI 327
6.9.6 Sketching, coresets, distillation, and data subset and feature selection 327
6.9.7 Combinatorial information functions 331
6.9.8 Clustering, data partitioning, and parallel machine learning 332
6.9.9 Active and semi-supervised learning 332
6.9.10 Probabilistic modeling 333
6.9.11 Structured norms and loss functions 335
6.9.12 Conclusions 335
II Inference 337
7 Inference algorithms: an overview 339
7.1 Introduction 339
7.2 Common inference patterns 340
7.2.1 Global latents 340
7.2.2 Local latents 341
7.2.3 Global and local latents 341
7.3 Exact inference algorithms 342
7.4 Approximate inference algorithms 342
7.4.1 The MAP approximation and its problems 343
7.4.2 Grid approximation 344
7.4.3 Laplace (quadratic) approximation 345
7.4.4 Variational inference 346
7.4.5 Markov chain Monte Carlo (MCMC) 348
7.4.6 Sequential Monte Carlo 349
7.4.7 Challenging posteriors 350
7.5 Evaluating approximate inference algorithms 350
8 Gaussian filtering and smoothing 353
8.1 Introduction 353
8.1.1 Inferential goals 353
8.1.2 Bayesian filtering equations 355
8.1.3 Bayesian smoothing equations 356
8.1.4 The Gaussian ansatz 357
8.2 Inference for linear-Gaussian SSMs 357
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexiv
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.2.1 Examples 358
8.2.2 The Kalman filter 359
8.2.3 The Kalman (RTS) smoother 364
8.2.4 Information form filtering and smoothing 366
8.3 Inference based on local linearization 369
8.3.1 Taylor series expansion 369
8.3.2 The extended Kalman filter (EKF) 370
8.3.3 The extended Kalman smoother (EKS) 373
8.4 Inference based on the unscented transform 373
8.4.1 The unscented transform 375
8.4.2 The unscented Kalman filter (UKF) 376
8.4.3 The unscented Kalman smoother (UKS) 376
8.5 Other variants of the Kalman filter 377
8.5.1 General Gaussian filtering 377
8.5.2 Conditional moment Gaussian filtering 380
8.5.3 Iterated filters and smoothers 381
8.5.4 Ensemble Kalman filter 382
8.5.5 Robust Kalman filters 384
8.5.6 Dual EKF 384
8.5.7 Normalizing flow KFs 384
8.6 Assumed density filtering 385
8.6.1 Connection with Gaussian filtering 386
8.6.2 ADF for SLDS (Gaussian sum filter) 387
8.6.3 ADF for online logistic regression 388
8.6.4 ADF for online DNNs 391
8.7 Other inference methods for SSMs 391
8.7.1 Grid-based approximations 392
8.7.2 Expectation propagation 392
8.7.3 Variational inference 393
8.7.4 MCMC 393
8.7.5 Particle filtering 394
9 Message passing algorithms 395
9.1 Introduction 395
9.2 Belief propagation on chains 395
9.2.1 Hidden Markov Models 396
9.2.2 The forwards algorithm 397
9.2.3 The forwards-backwards algorithm 398
9.2.4 Forwards filtering backwards smoothing 401
9.2.5 Time and space complexity 402
9.2.6 The Viterbi algorithm 403
9.2.7 Forwards filtering backwards sampling 406
9.3 Belief propagation on trees 406
9.3.1 Directed vs undirected trees 406
9.3.2 Sum-product algorithm 408
9.3.3 Max-product algorithm 409
9.4 Loopy belief propagation 411
9.4.1 Loopy BP for pairwise undirected graphs 412
9.4.2 Loopy BP for factor graphs 412
9.4.3 Gaussian belief propagation 413
9.4.4 Convergence 415
9.4.5 Accuracy 417
9.4.6 Generalized belief propagation 418
9.4.7 Convex BP 418
9.4.8 Application: error correcting codes 418
9.4.9 Application: affinity propagation 420
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
CONTENTS
9.4.10 Emulating BP with graph neural nets 421
9.5 The variable elimination (VE) algorithm 422
9.5.1 Derivation of the algorithm 422
9.5.2 Computational complexity of VE 424
9.5.3 Picking a good elimination order 426
9.5.4 Computational complexity of exact inference 426
9.5.5 Drawbacks of VE 427
9.6 The junction tree algorithm (JTA) 428
9.7 Inference as optimization 429
9.7.1 Inference as backpropagation 429
9.7.2 Perturb and MAP 430
10 Variational inference 433
10.1 Introduction 433
10.1.1 The variational objective 433
10.1.2 Form of the variational posterior 435
10.1.3 Parameter estimation using variational EM 436
10.1.4 Stochastic VI 438
10.1.5 Amortized VI 438
10.1.6 Semi-amortized inference 439
10.2 Gradient-based VI 439
10.2.1 Reparameterized VI 440
10.2.2 Automatic differentiation VI 446
10.2.3 Blackbox variational inference 448
10.3 Coordinate ascent VI 449
10.3.1 Derivation of CAVI algorithm 450
10.3.2 Example: CAVI for the Ising model 452
10.3.3 Variational Bayes 453
10.3.4 Example: VB for a univariate Gaussian 454
10.3.5 Variational Bayes EM 457
10.3.6 Example: VBEM for a GMM 458
10.3.7 Variational message passing (VMP) 464
10.3.8 Autoconj 465
10.4 More accurate variational posteriors 465
10.4.1 Structured mean field 465
10.4.2 Hierarchical (auxiliary variable) posteriors 465
10.4.3 Normalizing flow posteriors 466
10.4.4 Implicit posteriors 466
10.4.5 Combining VI with MCMC inference 466
10.5 Tighter bounds 467
10.5.1 Multi-sample ELBO (IWAE bound) 467
10.5.2 The thermodynamic variational objective (TVO) 468
10.5.3 Minimizing the evidence upper bound 468
10.6 Wake-sleep algorithm 469
10.6.1 Wake phase 469
10.6.2 Sleep phase 470
10.6.3 Daydream phase 471
10.6.4 Summary of algorithm 471
10.7 Expectation propagation (EP) 472
10.7.1 Algorithm 472
10.7.2 Example 474
10.7.3 EP as generalized ADF 474
10.7.4 Optimization issues 475
10.7.5 Power EP and α-divergence 475
10.7.6 Stochastic EP 475
11 Monte Carlo methods 477
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexvi
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
11.1 Introduction 477
11.2 Monte Carlo integration 477
11.2.1 Example: estimating π by Monte Carlo integration 478
11.2.2 Accuracy of Monte Carlo integration 478
11.3 Generating random samples from simple distributions 480
11.3.1 Sampling using the inverse cdf 480
11.3.2 Sampling from a Gaussian (Box-Muller method) 481
11.4 Rejection sampling 481
11.4.1 Basic idea 482
11.4.2 Example 483
11.4.3 Adaptive rejection sampling 483
11.4.4 Rejection sampling in high dimensions 484
11.5 Importance sampling 484
11.5.1 Direct importance sampling 485
11.5.2 Self-normalized importance sampling 485
11.5.3 Choosing the proposal 486
11.5.4 Annealed importance sampling (AIS) 486
11.6 Controlling Monte Carlo variance 488
11.6.1 Common random numbers 488
11.6.2 Rao-Blackwellization 488
11.6.3 Control variates 489
11.6.4 Antithetic sampling 490
11.6.5 Quasi-Monte Carlo (QMC) 491
12 Markov chain Monte Carlo 493
12.1 Introduction 493
12.2 Metropolis-Hastings algorithm 494
12.2.1 Basic idea 494
12.2.2 Why MH works 495
12.2.3 Proposal distributions 496
12.2.4 Initialization 498
12.3 Gibbs sampling 499
12.3.1 Basic idea 499
12.3.2 Gibbs sampling is a special case of MH 499
12.3.3 Example: Gibbs sampling for Ising models 500
12.3.4 Example: Gibbs sampling for Potts models 502
12.3.5 Example: Gibbs sampling for GMMs 502
12.3.6 Metropolis within Gibbs 504
12.3.7 Blocked Gibbs sampling 504
12.3.8 Collapsed Gibbs sampling 505
12.4 Auxiliary variable MCMC 507
12.4.1 Slice sampling 507
12.4.2 Swendsen-Wang 509
12.5 Hamiltonian Monte Carlo (HMC) 510
12.5.1 Hamiltonian mechanics 511
12.5.2 Integrating Hamilton’s equations 511
12.5.3 The HMC algorithm 513
12.5.4 Tuning HMC 514
12.5.5 Riemann manifold HMC 515
12.5.6 Langevin Monte Carlo (MALA) 515
12.5.7 Connection between SGD and Langevin sampling 516
12.5.8 Applying HMC to constrained parameters 517
12.5.9 Speeding up HMC 518
12.6 MCMC convergence 518
12.6.1 Mixing rates of Markov chains 519
12.6.2 Practical convergence diagnostics 520
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
CONTENTS
12.6.3 Effective sample size 523
12.6.4 Improving speed of convergence 525
12.6.5 Non-centered parameterizations and Neal’s funnel 525
12.7 Stochastic gradient MCMC 526
12.7.1 Stochastic gradient Langevin dynamics (SGLD) 527
12.7.2 Preconditionining 527
12.7.3 Reducing the variance of the gradient estimate 528
12.7.4 SG-HMC 529
12.7.5 Underdamped Langevin dynamics 529
12.8 Reversible jump (transdimensional) MCMC 530
12.8.1 Basic idea 531
12.8.2 Example 531
12.8.3 Discussion 533
12.9 Annealing methods 533
12.9.1 Simulated annealing 533
12.9.2 Parallel tempering 536
13 Sequential Monte Carlo 537
13.1 Introduction 537
13.1.1 Problem statement 537
13.1.2 Particle filtering for state-space models 537
13.1.3 SMC samplers for static parameter estimation 539
13.2 Particle filtering 539
13.2.1 Importance sampling 539
13.2.2 Sequential importance sampling 541
13.2.3 Sequential importance sampling with resampling 542
13.2.4 Resampling methods 545
13.2.5 Adaptive resampling 547
13.3 Proposal distributions 547
13.3.1 Locally optimal proposal 548
13.3.2 Proposals based on the extended and unscented Kalman filter 549
13.3.3 Proposals based on the Laplace approximation 549
13.3.4 Proposals based on SMC (nested SMC) 551
13.4 Rao-Blackwellized particle filtering (RBPF) 551
13.4.1 Mixture of Kalman filters 551
13.4.2 Example: tracking a maneuvering object 553
13.4.3 Example: FastSLAM 554
13.5 Extensions of the particle filter 557
13.6 SMC samplers 557
13.6.1 Ingredients of an SMC sampler 558
13.6.2 Likelihood tempering (geometric path) 559
13.6.3 Data tempering 561
13.6.4 Sampling rare events and extrema 562
13.6.5 SMC-ABC and likelihood-free inference 563
13.6.6 SMC2 563
13.6.7 Variational filtering SMC 563
13.6.8 Variational smoothing SMC 564
III Prediction 567
14 Predictive models: an overview 569
14.1 Introduction 569
14.1.1 Types of model 569
14.1.2 Model fitting using ERM, MLE, and MAP 570
14.1.3 Model fitting using Bayes, VI, and generalized Bayes 571
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexviii
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
14.2 Evaluating predictive models 572
14.2.1 Proper scoring rules 572
14.2.2 Calibration 572
14.2.3 Beyond evaluating marginal probabilities 576
14.3 Conformal prediction 579
14.3.1 Conformalizing classification 581
14.3.2 Conformalizing regression 581
15 Generalized linear models 583
15.1 Introduction 583
15.1.1 Some popular GLMs 583
15.1.2 GLMs with noncanonical link functions 586
15.1.3 Maximum likelihood estimation 587
15.1.4 Bayesian inference 587
15.2 Linear regression 588
15.2.1 Ordinary least squares 588
15.2.2 Conjugate priors 589
15.2.3 Uninformative priors 591
15.2.4 Informative priors 593
15.2.5 Spike and slab prior 595
15.2.6 Laplace prior (Bayesian lasso) 596
15.2.7 Horseshoe prior 597
15.2.8 Automatic relevancy determination 598
15.2.9 Multivariate linear regression 600
15.3 Logistic regression 602
15.3.1 Binary logistic regression 602
15.3.2 Multinomial logistic regression 603
15.3.3 Dealing with class imbalance and the long tail 604
15.3.4 Parameter priors 604
15.3.5 Laplace approximation to the posterior 605
15.3.6 Approximating the posterior predictive distribution 607
15.3.7 MCMC inference 609
15.3.8 Other approximate inference methods 610
15.3.9 Case study: is Berkeley admissions biased against women? 611
15.4 Probit regression 613
15.4.1 Latent variable interpretation 613
15.4.2 Maximum likelihood estimation 614
15.4.3 Bayesian inference 616
15.4.4 Ordinal probit regression 616
15.4.5 Multinomial probit models 617
15.5 Multilevel (hierarchical) GLMs 617
15.5.1 Generalized linear mixed models (GLMMs) 618
15.5.2 Example: radon regression 618
16 Deep neural networks 623
16.1 Introduction 623
16.2 Building blocks of differentiable circuits 623
16.2.1 Linear layers 624
16.2.2 Nonlinearities 624
16.2.3 Convolutional layers 625
16.2.4 Residual (skip) connections 626
16.2.5 Normalization layers 627
16.2.6 Dropout layers 627
16.2.7 Attention layers 628
16.2.8 Recurrent layers 630
16.2.9 Multiplicative layers 631
16.2.10 Implicit layers 632
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2023123456789
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
CONTENTS
16.3 Canonical examples of neural networks 632
16.3.1 Multilayer perceptrons (MLPs) 632
16.3.2 Convolutional neural networks (CNNs) 633
16.3.3 Autoencoders 634
16.3.4 Recurrent neural networks (RNNs) 636
16.3.5 Transformers 636
16.3.6 Graph neural networks (GNNs) 637
17 Bayesian neural networks 639
17.1 Introduction 639
17.2 Priors for BNNs 639
17.2.1 Gaussian priors 640
17.2.2 Sparsity-promoting priors 642
17.2.3 Learning the prior 642
17.2.4 Priors in function space 642
17.2.5 Architectural priors 643
17.3 Posteriors for BNNs 643
17.3.1 Monte Carlo dropout 643
17.3.2 Laplace approximation 644
17.3.3 Variational inference 645
17.3.4 Expectation propagation 646
17.3.5 Last layer methods 646
17.3.6 SNGP 647
17.3.7 MCMC methods 647
17.3.8 Methods based on the SGD trajectory 648
17.3.9 Deep ensembles 649
17.3.10 Approximating the posterior predictive distribution 653
17.3.11 Tempered and cold posteriors 656
17.4 Generalization in Bayesian deep learning 657
17.4.1 Sharp vs flat minima 657
17.4.2 Mode connectivity and the loss landscape 658
17.4.3 Effective dimensionality of a model 658
17.4.4 The hypothesis space of DNNs 660
17.4.5 PAC-Bayes 660
17.4.6 Out-of-distribution generalization for BNNs 661
17.4.7 Model selection for BNNs 663
17.5 Online inference 663
17.5.1 Sequential Laplace for DNNs 664
17.5.2 Extended Kalman filtering for DNNs 665
17.5.3 Assumed density filtering for DNNs 667
17.5.4 Online variational inference for DNNs 668
17.6 Hierarchical Bayesian neural networks 669
17.6.1 Example: multimoons classification 670
18 Gaussian processes 673
18.1 Introduction 673
18.1.1 GPs: what and why? 673
18.2 Mercer kernels 675
18.2.1 Stationary kernels 676
18.2.2 Nonstationary kernels 681
18.2.3 Kernels for nonvectorial (structured) inputs 682
18.2.4 Making new kernels from old 682
18.2.5 Mercer’s theorem 683
18.2.6 Approximating kernels with random features 684
18.3 GPs with Gaussian likelihoods 685
18.3.1 Predictions using noise-free observations 685
18.3.2 Predictions using noisy observations 686
Author: Kevin
P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexx
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.3.3 Weight space vs function space 687
18.3.4 Semiparametric GPs 688
18.3.5 Marginal likelihood 689
18.3.6 Computational and numerical issues 689
18.3.7 Kernel ridge regression 690
18.4 GPs with non-Gaussian likelihoods 693
18.4.1 Binary classification 694
18.4.2 Multiclass classification 695
18.4.3 GPs for Poisson regression (Cox process) 696
18.4.4 Other likelihoods 696
18.5 Scaling GP inference to large datasets 697
18.5.1 Subset of data 697
18.5.2 Nyström approximation 698
18.5.3 Inducing point methods 699
18.5.4 Sparse variational methods 702
18.5.5 Exploiting parallelization and structure via kernel matrix multiplies 706
18.5.6 Converting a GP to an SSM 708
18.6 Learning the kernel 709
18.6.1 Empirical Bayes for the kernel parameters 709
18.6.2 Bayesian inference for the kernel parameters 712
18.6.3 Multiple kernel learning for additive kernels 713
18.6.4 Automatic search for compositional kernels 714
18.6.5 Spectral mixture kernel learning 717
18.6.6 Deep kernel learning 718
18.7 GPs and DNNs 720
18.7.1 Kernels derived from infinitely wide DNNs (NN-GP) 721
18.7.2 Neural tangent kernel (NTK) 723
18.7.3 Deep GPs 723
18.8 Gaussian processes for time series forecasting 724
18.8.1 Example: Mauna Loa 724
19 Beyond the iid assumption 727
19.1 Introduction 727
19.2 Distribution shift 727
19.2.1 Motivating examples 727
19.2.2 A causal view of distribution shift 729
19.2.3 The four main types of distribution shift 730
19.2.4 Selection bias 732
19.3 Detecting distribution shifts 732
19.3.1 Detecting shifts using two-sample testing 733
19.3.2 Detecting single out-of-distribution (OOD) inputs 733
19.3.3 Selective prediction 736
19.3.4 Open set and open world recognition 737
19.4 Robustness to distribution shifts 737
19.4.1 Data augmentation 738
19.4.2 Distributionally robust optimization 738
19.5 Adapting to distribution shifts 738
19.5.1 Supervised adaptation using transfer learning 738
19.5.2 Weighted ERM for covariate shift 740
19.5.3 Unsupervised domain adaptation for covariate shift 741
19.5.4 Unsupervised techniques for label shift 742
19.5.5 Test-time adaptation 742
19.6 Learning from multiple distributions 743
19.6.1 Multitask learning 743
19.6.2 Domain generalization 744
19.6.3 Invariant risk minimization 746
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
CONTENTS
19.6.4 Meta learning 747
19.7 Continual learning 750
19.7.1 Domain drift 750
19.7.2 Concept drift 751
19.7.3 Class incremental learning 752
19.7.4 Catastrophic forgetting 754
19.7.5 Online learning 755
19.8 Adversarial examples 757
19.8.1 Whitebox (gradient-based) attacks 758
19.8.2 Blackbox (gradient-free) attacks 759
19.8.3 Real world adversarial attacks 760
19.8.4 Defenses based on robust optimization 761
19.8.5 Why models have adversarial examples 761
IV Generation 763
20 Generative models: an overview 765
20.1 Introduction 765
20.2 Types of generative model 765
20.3 Goals of generative modeling 767
20.3.1 Generating data 767
20.3.2 Density estimation 769
20.3.3 Imputation 770
20.3.4 Structure discovery 771
20.3.5 Latent space interpolation 771
20.3.6 Latent space arithmetic 773
20.3.7 Generative design 774
20.3.8 Model-based reinforcement learning 774
20.3.9 Representation learning 774
20.3.10 Data compression 774
20.4 Evaluating generative models 774
20.4.1 Likelihood-based evaluation 775
20.4.2 Distances and divergences in feature space 776
20.4.3 Precision and recall metrics 777
20.4.4 Statistical tests 778
20.4.5 Challenges with using pretrained classifiers 779
20.4.6 Using model samples to train classifiers 779
20.4.7 Assessing overfitting 779
20.4.8 Human evaluation 780
21 Variational autoencoders 781
21.1 Introduction 781
21.2 VAE basics 781
21.2.1 Modeling assumptions 782
21.2.2 Model fitting 783
21.2.3 Comparison of VAEs and autoencoders 783
21.2.4 VAEs optimize in an augmented space 784
21.3 VAE generalizations 786
21.3.1 β-VAE 787
21.3.2 InfoVAE 789
21.3.3 Multimodal VAEs 790
21.3.4 Semisupervised VAEs 793
21.3.5 VAEs with sequential encoders/decoders 794
21.4 Avoiding posterior collapse 796
21.4.1 KL annealing 797
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexxii
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.4.2 Lower bounding the rate 798
21.4.3 Free bits 798
21.4.4 Adding skip connections 798
21.4.5 Improved variational inference 798
21.4.6 Alternative objectives 799
21.5 VAEs with hierarchical structure 799
21.5.1 Bottom-up vs top-down inference 800
21.5.2 Example: very deep VAE 801
21.5.3 Connection with autoregressive models 802
21.5.4 Variational pruning 804
21.5.5 Other optimization difficulties 804
21.6 Vector quantization VAE 805
21.6.1 Autoencoder with binary code 805
21.6.2 VQ-VAE model 805
21.6.3 Learning the prior 807
21.6.4 Hierarchical extension (VQ-VAE-2) 807
21.6.5 Discrete VAE 808
21.6.6 VQ-GAN 809
22 Autoregressive models 811
22.1 Introduction 811
22.2 Neural autoregressive density estimators (NADE) 812
22.3 Causal CNNs 812
22.3.1 1d causal CNN (convolutional Markov models) 813
22.3.2 2d causal CNN (PixelCNN) 813
22.4 Transformers 814
22.4.1 Text generation (GPT, etc.) 815
22.4.2 Image generation (DALL-E, etc.) 816
22.4.3 Other applications 818
23 Normalizing flows 819
23.1 Introduction 819
23.1.1 Preliminaries 819
23.1.2 How to train a flow model 821
23.2 Constructing flows 822
23.2.1 Affine flows 822
23.2.2 Elementwise flows 822
23.2.3 Coupling flows 825
23.2.4 Autoregressive flows 826
23.2.5 Residual flows 832
23.2.6 Continuous-time flows 834
23.3 Applications 836
23.3.1 Density estimation 836
23.3.2 Generative modeling 836
23.3.3 Inference 837
24 Energy-based models 839
24.1 Introduction 839
24.1.1 Example: products of experts (PoE) 840
24.1.2 Computational difficulties 840
24.2 Maximum likelihood training 841
24.2.1 Gradient-based MCMC methods 842
24.2.2 Contrastive divergence 842
24.3 Score matching (SM) 846
24.3.1 Basic score matching 846
24.3.2 Denoising score matching (DSM) 847
24.3.3 Sliced score matching (SSM) 848
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
CONTENTS
24.3.4 Connection to contrastive divergence 849
24.3.5 Score-based generative models 850
24.4 Noise contrastive estimation 850
24.4.1 Connection to score matching 852
24.5 Other methods 852
24.5.1 Minimizing Differences/Derivatives of KL Divergences 853
24.5.2 Minimizing the Stein discrepancy 853
24.5.3 Adversarial training 854
25 Diffusion models 857
25.1 Introduction 857
25.2 Denoising diffusion probabilistic models (DDPMs) 857
25.2.1 Encoder (forwards diffusion) 858
25.2.2 Decoder (reverse diffusion) 859
25.2.3 Model fitting 860
25.2.4 Learning the noise schedule 861
25.2.5 Example: image generation 863
25.3 Score-based generative models (SGMs) 864
25.3.1 Example 864
25.3.2 Adding noise at multiple scales 864
25.3.3 Equivalence to DDPM 866
25.4 Continuous time models using differential equations 867
25.4.1 Forwards diffusion SDE 867
25.4.2 Forwards diffusion ODE 868
25.4.3 Reverse diffusion SDE 869
25.4.4 Reverse diffusion ODE 870
25.4.5 Comparison of the SDE and ODE approach 871
25.4.6 Example 871
25.5 Speeding up diffusion models 871
25.5.1 DDIM sampler 872
25.5.2 Non-Gaussian decoder networks 872
25.5.3 Distillation 873
25.5.4 Latent space diffusion 874
25.6 Conditional generation 875
25.6.1 Conditional diffusion model 875
25.6.2 Classifier guidance 875
25.6.3 Classifier-free guidance 876
25.6.4 Generating high resolution images 876
25.7 Diffusion for discrete state spaces 877
25.7.1 Discrete Denoising Diffusion Probabilistic Models 877
25.7.2 Choice of Markov transition matrices for the forward processes 878
25.7.3 Parameterization of the reverse process 879
25.7.4 Noise schedules 880
25.7.5 Connections to other probabilistic models for discrete sequences 880
26 Generative adversarial networks 883
26.1 Introduction 883
26.2 Learning by comparison 884
26.2.1 Guiding principles 885
26.2.2 Density ratio estimation using binary classifiers 886
26.2.3 Bounds on f-divergences 888
26.2.4 Integral probability metrics 890
26.2.5 Moment matching 892
26.2.6 On density ratios and differences 892
26.3 Generative adversarial networks 894
26.3.1 From learning principles to loss functions 894
26.3.2 Gradient descent 895
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexxiv
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.3.3 Challenges with GAN training 897
26.3.4 Improving GAN optimization 898
26.3.5 Convergence of GAN training 898
26.4 Conditional GANs 902
26.5 Inference with GANs 903
26.6 Neural architectures in GANs 904
26.6.1 The importance of discriminator architectures 904
26.6.2 Architectural inductive biases 905
26.6.3 Attention in GANs 905
26.6.4 Progressive generation 906
26.6.5 Regularization 907
26.6.6 Scaling up GAN models 908
26.7 Applications 908
26.7.1 GANs for image generation 908
26.7.2 Video generation 911
26.7.3 Audio generation 912
26.7.4 Text generation 912
26.7.5 Imitation learning 913
26.7.6 Domain adaptation 914
26.7.7 Design, art and creativity 914
V Discovery 915
27 Discovery methods: an overview 917
27.1 Introduction 917
27.2 Overview of Part V 918
28 Latent factor models 919
28.1 Introduction 919
28.2 Mixture models 919
28.2.1 Gaussian mixture models (GMMs) 920
28.2.2 Bernoulli mixture models 922
28.2.3 Gaussian scale mixtures (GSMs) 922
28.2.4 Using GMMs as a prior for inverse imaging problems 924
28.2.5 Using mixture models for classification problems 927
28.3 Factor analysis 929
28.3.1 Factor analysis: the basics 929
28.3.2 Probabilistic PCA 934
28.3.3 Mixture of factor analyzers 936
28.3.4 Factor analysis models for paired data 943
28.3.5 Factor analysis with exponential family likelihoods 945
28.3.6 Factor analysis with DNN likelihoods (VAEs) 948
28.3.7 Factor analysis with GP likelihoods (GP-LVM) 948
28.4 LFMs with non-Gaussian priors 949
28.4.1 Non-negative matrix factorization (NMF) 949
28.4.2 Multinomial PCA 950
28.5 Topic models 953
28.5.1 Latent Dirichlet allocation (LDA) 953
28.5.2 Correlated topic model 957
28.5.3 Dynamic topic model 957
28.5.4 LDA-HMM 958
28.6 Independent components analysis (ICA) 962
28.6.1 Noiseless ICA model 962
28.6.2 The need for non-Gaussian priors 963
28.6.3 Maximum likelihood estimation 964
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
CONTENTS
28.6.4 Alternatives to MLE 965
28.6.5 Sparse coding 966
28.6.6 Nonlinear ICA 967
29 State-space models 969
29.1 Introduction 969
29.2 Hidden Markov models (HMMs) 970
29.2.1 Conditional independence properties 970
29.2.2 State transition model 970
29.2.3 Discrete likelihoods 971
29.2.4 Gaussian likelihoods 972
29.2.5 Autoregressive likelihoods 972
29.2.6 Neural network likelihoods 973
29.3 HMMs: applications 974
29.3.1 Time series segmentation 974
29.3.2 Protein sequence alignment 976
29.3.3 Spelling correction 978
29.4 HMMs: parameter learning 980
29.4.1 The Baum-Welch (EM) algorithm 980
29.4.2 Parameter estimation using SGD 983
29.4.3 Parameter estimation using spectral methods 984
29.4.4 Bayesian HMMs 985
29.5 HMMs: generalizations 987
29.5.1 Hidden semi-Markov model (HSMM) 987
29.5.2 Hierarchical HMMs 989
29.5.3 Factorial HMMs 991
29.5.4 Coupled HMMs 992
29.5.5 Dynamic Bayes nets (DBN) 992
29.5.6 Changepoint detection 993
29.6 Linear dynamical systems (LDSs) 996
29.6.1 Conditional independence properties 996
29.6.2 Parameterization 996
29.7 LDS: applications 997
29.7.1 Object tracking and state estimation 997
29.7.2 Online Bayesian linear regression (recursive least squares) 998
29.7.3 Adaptive filtering 1000
29.7.4 Time series forecasting 1000
29.8 LDS: parameter learning 1001
29.8.1 EM for LDS 1001
29.8.2 Subspace identification methods 1003
29.8.3 Ensuring stability of the dynamical system 1003
29.8.4 Bayesian LDS 1004
29.8.5 Online parameter learning for SSMs 1005
29.9 Switching linear dynamical systems (SLDSs) 1005
29.9.1 Parameterization 1005
29.9.2 Posterior inference 1005
29.9.3 Application: Multitarget tracking 1006
29.10 Nonlinear SSMs 1010
29.10.1 Example: object tracking and state estimation 1010
29.10.2 Posterior inference 1011
29.11 Non-Gaussian SSMs 1011
29.11.1 Example: spike train modeling 1011
29.11.2 Example: stochastic volatility models 1012
29.11.3 Posterior inference 1013
29.12 Structural time series models 1013
29.12.1 Introduction 1013
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexxvi
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.12.2 Structural building blocks 1014
29.12.3 Model fitting 1016
29.12.4 Forecasting 1017
29.12.5 Examples 1017
29.12.6 Causal impact of a time series intervention 1021
29.12.7 Prophet 1025
29.12.8 Neural forecasting methods 1025
29.13 Deep SSMs 1026
29.13.1 Deep Markov models 1027
29.13.2 Recurrent SSM 1028
29.13.3 Improving multistep predictions 1029
29.13.4 Variational RNNs 1030
30 Graph learning 1033
30.1 Introduction 1033
30.2 Latent variable models for graphs 1033
30.3 Graphical model structure learning 1033
31 Nonparametric Bayesian models 1037
31.1 Introduction 1037
32 Representation learning 1039
32.1 Introduction 1039
32.2 Evaluating and comparing learned representations 1039
32.2.1 Downstream performance 1040
32.2.2 Representational similarity 1042
32.3 Approaches for learning representations 1046
32.3.1 Supervised representation learning and transfer 1047
32.3.2 Generative representation learning 1049
32.3.3 Self-supervised representation learning 1051
32.3.4 Multiview representation learning 1054
32.4 Theory of representation learning 1059
32.4.1 Identifiability 1059
32.4.2 Information maximization 1060
33 Interpretability 1063
33.1 Introduction 1063
33.1.1 The role of interpretability: unknowns and under-specifications 1064
33.1.2 Terminology and framework 1065
33.2 Methods for interpretable machine learning 1068
33.2.1 Inherently interpretable models: the model is its explanation 1069
33.2.2 Semi-inherently interpretable models: example-based methods 1071
33.2.3 Post-hoc or joint training: the explanation gives a partial view of the model 1071
33.2.4 Transparency and visualization 1075
33.3 Properties: the abstraction between context and method 1076
33.3.1 Properties of explanations from interpretable machine learning 1076
33.3.2 Properties of explanations from cognitive science 1078
33.4 Evaluation of interpretable machine learning models 1079
33.4.1 Computational evaluation: does the method have desired properties? 1080
33.4.2 User study-based evaluation: does the method help a user perform a target task? 1084
33.5 Discussion: how to think about interpretable machine learning 1088
VI Action 1093
34 Decision making under uncertainty 1095
34.1 Statistical decision theory 1095
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
CONTENTS
34.1.1 Basics 1095
34.1.2 Frequentist decision theory 1095
34.1.3 Bayesian decision theory 1096
34.1.4 Frequentist optimality of the Bayesian approach 1097
34.1.5 Examples of one-shot decision making problems 1097
34.2 Decision (influence) diagrams 1101
34.2.1 Example: oil wildcatter 1102
34.2.2 Information arcs 1103
34.2.3 Value of information 1103
34.2.4 Computing the optimal policy 1104
34.3 A/B testing 1105
34.3.1 A Bayesian approach 1105
34.3.2 Example 1108
34.4 Contextual bandits 1109
34.4.1 Types of bandit 1110
34.4.2 Applications 1111
34.4.3 Exploration-exploitation tradeoff 1111
34.4.4 The optimal solution 1112
34.4.5 Upper confidence bounds (UCBs) 1113
34.4.6 Thompson sampling 1115
34.4.7 Regret 1116
34.5 Markov decision problems 1118
34.5.1 Basics 1118
34.5.2 Partially observed MDPs 1119
34.5.3 Episodes and returns 1119
34.5.4 Value functions 1121
34.5.5 Optimal value functions and policies 1121
34.6 Planning in an MDP 1122
34.6.1 Value iteration 1123
34.6.2 Policy iteration 1124
34.6.3 Linear programming 1125
34.7 Active learning 1126
34.7.1 Active learning scenarios 1126
34.7.2 Relationship to other forms of sequential decision making 1127
34.7.3 Acquisition strategies 1128
34.7.4 Batch active learning 1130
35 Reinforcement learning 1135
35.1 Introduction 1135
35.1.1 Overview of methods 1135
35.1.2 Value-based methods 1137
35.1.3 Policy search methods 1137
35.1.4 Model-based RL 1137
35.1.5 Exploration-exploitation tradeoff 1138
35.2 Value-based RL 1140
35.2.1 Monte Carlo RL 1140
35.2.2 Temporal difference (TD) learning 1140
35.2.3 TD learning with eligibility traces 1141
35.2.4 SARSA: on-policy TD control 1142
35.2.5 Q-learning: off-policy TD control 1143
35.2.6 Deep Q-network (DQN) 1144
35.3 Policy-based RL 1146
35.3.1 The policy gradient theorem 1147
35.3.2 REINFORCE 1148
35.3.3 Actor-critic methods 1148
35.3.4 Bound optimization methods 1150
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensexxviii
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.3.5 Deterministic policy gradient methods 1152
35.3.6 Gradient-free methods 1153
35.4 Model-based RL 1153
35.4.1 Model predictive control (MPC) 1153
35.4.2 Combining model-based and model-free 1155
35.4.3 MBRL using Gaussian processes 1156
35.4.4 MBRL using DNNs 1157
35.4.5 MBRL using latent-variable models 1158
35.4.6 Robustness to model errors 1160
35.5 Off-policy learning 1160
35.5.1 Basic techniques 1161
35.5.2 The curse of horizon 1164
35.5.3 The deadly triad 1165
35.6 Control as inference 1167
35.6.1 Maximum entropy reinforcement learning 1167
35.6.2 Other approaches 1169
35.6.3 Imitation learning 1170
36 Causality 1173
36.1 Introduction 1173
36.2 Causal formalism 1175
36.2.1 Structural causal models 1175
36.2.2 Causal DAGs 1176
36.2.3 Identification 1178
36.2.4 Counterfactuals and the causal hierarchy 1180
36.3 Randomized control trials 1182
36.4 Confounder adjustment 1183
36.4.1 Causal estimand, statistical estimand, and identification 1183
36.4.2 ATE estimation with observed confounders 1186
36.4.3 Uncertainty quantification 1191
36.4.4 Matching 1191
36.4.5 Practical considerations and procedures 1192
36.4.6 Summary and practical advice 1195
36.5 Instrumental variable strategies 1197
36.5.1 Additive unobserved confounding 1198
36.5.2 Instrument monotonicity and local average treatment effect 1200
36.5.3 Two stage least squares 1203
36.6 Difference in differences 1204
36.6.1 Estimation 1207
36.7 Credibility checks 1208
36.7.1 Placebo checks 1208
36.7.2 Sensitivity analysis to unobserved confounding 1209
36.8 The do-calculus 1217
36.8.1 The three rules 1217
36.8.2 Revisiting backdoor adjustment 1218
36.8.3 Frontdoor adjustment 1219
36.9 Further reading 1220
Index 1223
Bibliography 1241
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2023Preface
I am writing a longer [book] than usual because there is not enough time to write a short one.
(Blaise Pascal, paraphrased.)
This book is a sequel to [Mur22]. and provides a deeper dive into various topics in machine learning
(ML). The previous book mostly focused on techniques for learning functions of the form f : X → Y,
where f is some nonlinear model, such as a deep neural network, X is the set of possible inputs
(typically X = R
D), and Y = {1, . . . , C} represents the set of labels for classification problems or
Y = R for regression problems. Judea Pearl, a well known AI researcher, has called this kind of ML
a form of “glorified curve fitting” (quoted in [Har18]).
In this book, we expand the scope of ML to encompass more challenging problems. For example, we
consider training and testing under different distributions; we consider generation of high dimensional
outputs, such as images, text, and graphs, so the output space is, say, Y = R
256×256; we discuss
methods for discovering “insights” about data, based on latent variable models; and we discuss how
to use probabilistic models for causal inference and decision making under uncertainty.
We assume the reader has some prior exposure to ML and other relevant mathematical topics (e.g.,
probability, statistics, linear algebra, optimization). This background material can be found in the
prequel to this book, [Mur22], as well several other good books (e.g., [Lin+21b; DFO20]).
Python code (mostly in JAX) to reproduce nearly all of the figures can be found online. In
particular, if a figure caption says “Generated by gauss_plot_2d.ipynb”, then you can find the
corresponding Jupyter notebook at probml.github.io/notebooks#gauss_plot_2d.ipynb. Clicking on
the figure link in the pdf version of the book will take you to this list of notebooks. Clicking on
the notebook link will open it inside Google Colab, which will let you easily reproduce the figure
for yourself, and modify the underlying source code to gain a deeper understanding of the methods.
(Colab gives you access to a free GPU, which is useful for some of the more computationally heavy
demos.)
In addition to the online code, probml.github.io/supp contains some additional supplementary
online content which was excluded from the main book for space reasons. For exercises (and solutions)
related to the topics in this book, see [Gut22].
Contributing authors
This book is the result of a lot of effort from a lot of people. I would especially like to thank the
following people who wrote or cowrote various sections or chapters:xxx
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
• Alex Alemi (Google), who co-wrote Section 5.1 (KL divergence) (with Murphy).
• Jeff Bilmes (U. Washington), who wrote Section 6.9 (Submodular optimization).
• Peter Chang, who co-wrote Section 8.5.1 (General Gaussian filtering) (with Murphy).
• Marco Cuturi (Apple, work done at Google), who wrote Section 6.8 (Optimal transport).
• Alexander D’Amour (Google), who co-wrote Chapter 36 (Causality) (with Veitch).
• Finale Doshi-Velez (Harvard), who co-wrote Chapter 33 (Interpretability) (with Kim).
• Roy Frostig (Google), who wrote Section 6.2 (Automatic differentiation).
• Justin Gilmer (Google), who wrote Section 19.8 (Adversarial examples).
• Giles Harper-Donnelly, who wrote Section 8.2.4 (Information form filtering and smoothing).
• Been Kim (Google), who co-wrote Chapter 33 (Interpretability) (with Doshi-Velez).
• Durk Kingma (Google), who co-wrote Chapter 24 (Energy-based models) (with Song).
• Simon Kornblith (Google), who co-wrote Chapter 32 (Representation learning) (with Poole).
• Balaji Lakshminarayanan (Google), who co-wrote Chapter 23 (Normalizing flows) (with Papa￾makarios) and Chapter 26 (Generative adversarial networks) (with Mohamed and Rosca).
• Lihong Li (Amazon, work done at Google), who co-wrote Section 34.4 (Contextual bandits) and
Chapter 35 (Reinforcement learning) (with Murphy).
• Xinglong Li (UBC), who wrote Section 15.2.9 (Multivariate linear regression), Section 29.4.4.1
(Blocked Gibbs sampling for HMMs), Section 29.8.4.1 (Blocked Gibbs sampling for LDS), and
Supplementary Section 31.2.3.
• Shakir Mohamed (Deepmind), who co-wrote Chapter 26 (Generative adversarial networks) (with
Lakshminarayanan and Rosca).
• George Papamakarios (Deepmind), who cowrote Chapter 23 (Normalizing flows) (with Lakshmi￾narayanan).
• Zeel Patel (IIT Gandhinagar), who cowrote Section 34.7 (Active learning) (with Murphy).
• Ben Poole (Google), who co-wrote Chapter 32 (Representation learning) (with Kornblith).
• Mihaela Rosca (Deepmind/UCL), who co-wrote Chapter 26 (Generative adversarial networks).
• Vinayak Rao (Purdue), who wrote Chapter 31 (Nonparametric Bayesian models).
• Yang Song (Stanford), who co-wrote Chapter 24 (Energy-based models) (with Kingma).
• Victor Veitch (Google/U. Chicago), who co-wrote Chapter 36 (Causality) (with D’Amour).
• Andrew Wilson (NYU), who co-wrote Chapter 17 (Bayesian neural networks) and Chapter 18
(Gaussian processes) (with Murphy).
Other contributors
I would also like to thank the following people who helped in various other ways:
• Many people who helped make or improve the figures, including: Aman Atman, Vibhuti Bansal,
Shobhit Belwal, Aadesh Desai, Vishal Ghoniya, Anand Hegde, Ankita Kumari Jain, Madhav
Kanda, Aleyna Kara, Rohit Khoiwal, Taksh Panchal, Dhruv Patel, Prey Patel, Nitish Sharma,
Hetvi Shastri, Mahmoud Soliman, and Gautam Vashishtha. A special shout out to Zeel B Patel
and Karm Patel for their significant efforts in improving the figure quality.
• Participants in the Google Summer of Code (GSOC) for 2021, including Ming Liang Ang, Aleyna
Kara, Gerardo Duran-Martin, Srikar Reddy Jilugu, Drishti Patel, and co-mentor Mahmoud
Soliman.
• Participants in the Google Summer of Code (GSOC) for 2022, including Peter Chang, Giles
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Preface
Harper-Donnelly, Xinglong Li, Zeel B Patel, Karm Patel, Qingyao Sun, and co-mentors Nipun
Batra and Scott Linderman.
• Many other people who contributed code (see autogenerated list at https://github.com/probml/
pyprobml#acknowledgements).
• Many people who proofread parts of the book, including: Aalto Seminar students, Bill Behrman,
Kay Brodersen, Peter Chang, Krzysztof Choromanski, Adrien Corenflos, Tom Dietterich, Gerardo
Duran-Martin, Lehman Krunoslav, Ruiqi Gao, Amir Globerson, Giles Harper-Donnelly, Ravin
Kumar, Junpeng Lao, Stephen Mandt, Norm Matloff, Simon Prince, Rif Saurous, Erik Sudderth,
Donna Vakalis, Hal Varian, Chris Williams, Raymond Yeh, and others listed at https://github.
com/probml/pml2-book/issues?q=is:issue. A special shout out to John Fearns who proofread
almost all the math, and the MIT Press editor who ensured I use “Oxford commas” in all the
right places.
About the cover
The cover illustrates a variational autoencoder (Chapter 21) being used to map from a 2d Gaussian
to image space.
Kevin Patrick Murphy
Palo Alto, California
March 2023.
Changelog: see https://github.com/probml/pml2-book/issues?q=is%3Aissue+is%3Aclosed.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1 Introduction
“Intelligence is not just about pattern recognition and function approximation. It’s about
modeling the world”. — Josh Tenenbaum, NeurIPS 2021.
Much of current machine learning focuses on the task of mapping inputs to outputs (i.e., approximating
functions of the form f : X → Y), often using “deep learning” (see e.g., [LBH15; Sch14; Sej20;
BLH21]). Judea Pearl, a well known AI researcher, has called this “glorified curve fitting” (quoted
in [Har18]). This is a little unfair, since when X and/or Y are high-dimensional spaces — such
as images, sentences, graphs, or sequences of decisions/actions — then the term “curve fitting” is
rather misleading, since one-dimensional intuitions often do not work in higher-dimensional settings
(see e.g., [BPL21a]). Nevertheless, the quote gets at what many feel is lacking in current attempts
to “solve AI” using machine learning techniques, namely that they are too focused on prediction
of observable patterns, and not focused enough on “understanding” the underlying latent structure
behind these patterns.
Gaining a “deep understanding” of the structure behind the observed data is necessary for advancing
science, as well as for certain applications, such as healthcare (see e.g., [DD22]), where identifying
the root causes or mechanisms behind various diseases is the key to developing cures. In addition,
such “deep understanding” is necessary in order to develop robust and efficient systems. By “robust”
we mean methods that work well even if there are unexpected changes to the data distribution to
which the system is applied, which is an important concern in many areas, such as robotics (see e.g.,
[Roy+21]). By “efficient” we generally mean data or statistically efficient, i.e., methods that can learn
quickly from small amounts of data (cf., [Lu+21b]). This is important since data can be limited
in some domains, such as healthcare and robotics, even though it is abundant in other domains,
such as language and vision, due to the ability to scrape the internet. We are also interested in
computationally efficient methods, although this is a secondary concern as computing power continues
to grow. (We also note that this trend has been instrumental to much of the recent progress in AI,
as noted in [Sut19].)
To develop robust and efficient systems, this book adopts a model-based approach, in which we try
to learn parsimonious representations of the underlying “data generating process” (DGP) given
samples from one or more datasets (c.f., [Lak+17; Win+19; Sch20; Ben+21a; Cun22; MTS22]). This
is in fact similar to the scientific method, where we try to explain (features of) the observations by
developing theories or models. One way to formalize this process is in terms of Bayesian inference
applied to probabilistic models, as argued in [Jay03; Box80; GS13]. We discuss inference algorithms
in detail in Part II of the book.1 But before we get there, in Part I we cover some relevant background
1. Note that, in the deep learning community, the term “inference” means applying a function to some inputs to2
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
material that will be needed. (This part can be skipped by readers who are already familiar with
these basics.)
Once we have a set of inference methods in our toolbox (some of which may be as simple as
computing a maximum likelihood estimate using an optimization method, such as stochastic gradient
descent) we can turn our focus to discussing different kinds of models. The choice of model depends
on our task, the kind and amount of data we have, and our metric(s) of success. We will broadly
consider four main kinds of task: prediction (e.g., classification and regression), generation (e.g., of
images or text), discovery (of “meaningful structure” in data), and control (optimal decision making).
We give more details below.
In Part III, we discuss models for prediction. These models are conditional distributions of the
form p(y|x), where x ∈ X is some input (often high dimensional), and y ∈ Y is the desired output
(often low dimensional). In this part of the book, we assume there is one right answer that we want
to predict, although we may be uncertain about it.
In Part IV, we discuss models for generation. These models are distributions of the form p(x) or
p(x|c), where c are optional conditioning inputs, and where there may be multiple valid outputs.
For example, given a text prompt c, we may want to generate a diverse set of images x that “match”
the caption. Evaluating such models is harder than in the prediction setting, since it is less clear
what the desired output should be.
In Part V, we discuss latent variable models, which are joint models of the form p(z, x) = p(z)p(x|z),
where z is the hidden state and x are the observations that are assumed to be generated from z.
The goal is to compute p(z|x), in order to uncover some (hopefully meaningful/useful) underlying
state or patterns in the observed data. We also consider methods for trying to discover patterns
learned implicitly by predictive models of the form p(y|x), without relying on an explicit generative
model of the data.
Finally, in Part VI, we discuss models and algorithms which can be used to make decisions under
uncertainty. This naturally leads into the very important topic of causality, with which we close the
book.
In view of the broad scope of the book, we cannot go into detail on every topic. However, we
have attempted to cover all the basics. In some cases, we also provide a “deeper dive” into the
research frontier (as of 2022). We hope that by bringing all these topics together, you will find it
easier to make connections between all these seemingly disparate areas, and can thereby deepen your
understanding of the field of machine learning.
compute the output. This is unrelated to Bayesian inference, which is concerned with the much harder task of inverting
a function, and working backwards from observed outputs to possible hidden inputs (causes). The latter is more closely
related to what the deep learning community calls “training”.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2023Part I
Fundamentals2 Probability
2.1 Introduction
In this section, we formally define what we mean by probability, following the presentation of [Cha21,
Ch. 2]. Other good introductions to this topic can be found in e.g., [GS97; BT08; Bet18; DFO20].
2.1.1 Probability space
We define a probability space to be a triple (Ω, F, P), where Ω is the sample space, which is the
set of possible outcomes from an experiment); F is the event space, which is the set of all possible
subsets of Ω; and P is the probability measure, which is a mapping from an event E ⊆ Ω to a
number in [0, 1] (i.e., P : F → [0, 1]), which satisfies certain consistency requirements, which we
discuss in Section 2.1.4.
2.1.2 Discrete random variables
The simplest setting is where the outcomes of the experiment constitute a countable set. For example,
consider throwing a 3-sided die, where the faces are labeled “A”, “B”, and “C”. (We choose 3 sides
instead of 6 for brevity.) The sample space is Ω = {A, B, C}, which represents all the possible
outcomes of the “experiment”. The event space is the set of all possible subsets of the sample space,
so F = {∅, {A}, {B}, {C}, {A, B}, {A, C}, {B, C}, {A, B, C}}. An event is an element of the event
space. For example, the event E1 = {A, B} represents outcomes where the die shows face A or B,
and event E2 = {C} represents the outcome where the die shows face C.
Once we have defined the event space, we need to specify the probability measure, which provides
a way to compute the “size” or “weight” of each set in the event space. In the 3-sided die example,
suppose we define the probability of each outcome (atomic event) as P[{A}] = 2
6
, P[{B}] = 1
6
, and
P[{C}] = 3
6
. We can derive the probability of other events by adding up the measures for each
outcome, e.g., P[{A, B}] = 2
6 +
1
6 =
1
2
. We formalize this in Section 2.1.4.
To simplify notation, we will assign a number to each possible outcome in the event space. This
can be done by defining a random variable or rv, which is a function X : Ω → R that maps an
outcome ω ∈ Ω to a number X(ω) on the real line. For example, we can define the random variable
X for our 3-sided die using X(A) = 1, X(B) = 2, X(C) = 3. As another example, consider an
experiment where we flip a fair coin twice. The sample space is Ω = {ω1 = (H, H), ω2 = (H, T), ω3 =
(T, H), ω4 = (T, T)}, where H stands for head, and T for tail. Let X be the random variable that
represents the number of heads. Then we have X(ω1) = 2, X(ω2) = 1, X(ω3) = 1, and X(ω4) = 0.6
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We define the set of possible values of the random variable to be its state space, denoted
X(Ω) = X . We define the probability of any given state using
pX(a) = P[X = a] = P[X−1
(a)] (2.1)
where X−1
(a) = {ω ∈ Ω|X(ω) = a} is the pre-image of a. Here pX is called the probability mass
function or pmf for random variable X. In the example where we flip a fair coin twice, the pmf is
pX(0) = P[{(T, T)}] = 1
4
, pX(1) = P[{(T, H),(H, T)}] = 2
4
, and pX(2) = P[{(H, H)}] = 1
4
. The pmf
can be represented by a histogram, or some parametric function (see Section 2.2.1). We call pX the
probability distribution for rv X. We will often drop the X subscript from pX where it is clear
from context.
2.1.3 Continuous random variables
We can also consider experiments with continuous outcomes. In this case, we assume the sample
space is a subset of the reals, Ω ⊆ R, and we define each continuous random variable to be the
identify function, X(ω) = ω.
For example, consider measuring the duration of some event (in seconds). We define the sample
space to be Ω = {t : 0 ≤ t ≤ Tmax}. Since this is an uncountable set, we cannot define all possible
subsets by enumeration, unlike the discrete case. Instead, we need to define event space in terms of
a Borel sigma-field, also called a Borel sigma-algebra. We say that F is a σ-field if (1) ∅ ∈ F
and Ω ∈ F; (2) F is closed under complement, so if E ∈ F then Ec ∈ F; and (3) F is closed
under countable unions and intersections, meaning that ∪∞
i=1Ei ∈ F and ∩∞
i=1Ei ∈ F, provided
E1, E2, . . . ∈ F. Finally, we say that B is a Borel σ-field if it is a σ-field generated from semi-closed
intervals of the form (−∞, b] = {x : −∞ < x ≤ b}. By taking unions, intersections and complements
of these intervals, we can see that B contains the following sets:
(a, b), [a, b],(a, b], [a, b], {b}, −∞ ≤ a ≤ b ≤ ∞ (2.2)
In our duration example, we can further restrict the event space to only contain intervals whose
lower bound is 0 and whose upper bound is ≤ Tmax.
To define the probability measure, we assign a weighting function pX(x) ≥ 0 for each x ∈ Ω known
as a probability density function or pdf. See Section 2.2.2 for a list of common pdf’s. We can
then derive the probability of an event E = [a, b] using
P([a, b]) = Z
E
dP =
Z b
a
p(x)dx (2.3)
We can also define the cumulative distribution function or cdf for random variable X as follows:
PX(x) , P[X ≤ x] = Z x
−∞
pX(x
′
)dx′
(2.4)
From this we can compute the probability of an interval using
P([a, b]) = p(a ≤ X ≤ b) = PX(b) − PX(a) (2.5)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.1. INTRODUCTION
The term “probability distribution” could refer to the pdf pX or the cdf PX or even the probabiliy
measure P.
We can generalize the above definitions to multidimensional spaces, Ω ⊆ R
n, as well as more
complex sample spaces, such as functions.
2.1.4 Probability axioms
The probability law associated with the event space must follow the axioms of probability, also
called the Kolmogorov axioms, which are as follows:1
• Non-negativity: P[E] ≥ 0 for any E ⊆ Ω.
• Normalization: P[Ω] = 1.
• Additivity: for any countable sequence of pairwise disjoint sets {E1, E2, . . . , }, we have
P [∪
∞
i=1Ei
] = X∞
i=1
P[Ei
] (2.6)
In the finite case, where we just have two disjoint sets, E1 and E2, this becomes
P[E1 ∪ E2] = P[E1] + P[E2] (2.7)
This corresponds to the probability of event E1 or E2, assuming they are mutually exclusive
(disjoint sets).
From these axioms, we can derive the complement rule:
P[E
c
] = 1 − P[E] (2.8)
where Ec = Ω \ E is the complement of E. (This follows since P[Ω] = 1 = P[E ∪ Ec
] = P[E] + P[Ec
].)
We can also show that P[E] ≤ 1 (proof by contradiction), and P[∅] = 0 (which follows from first
corollary with E = Ω).
We can also show the following result, known as the addition rule:
P[E1 ∪ E2] = P[E1] + P[E2] − P[E1 ∩ E2] (2.9)
This holds for any pair of events, even if they are not disjoint.
2.1.5 Conditional probability
Consider two events E1 and E2. If P[E2] 6= 0, we define the conditional probability of E1 given
E2 as
P[E1|E2] ,
P[E1 ∩ E2]
P[E2]
(2.10)
From this, we can get the multiplication rule:
P[E1 ∩ E2] = P[E1|E2]P[E2] = P[E2|E1]P[E1] (2.11)
1. These laws can be shown to follow from a more basic set of assumptions about reasoning under uncertainty, a result
known as Cox’s theorem [Cox46; Cox61].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license8
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Conditional probability measures how likely an event E1 is given that event E2 has happened.
However, if the events are unrelated, the probability will not change. Formally, We say that E1 and
E2 are independent events if
P[E1 ∩ E2] = P[E1]P[E2] (2.12)
If both P[E1] > 0 and P[E2] > 0, this is equivalent to requiring that P[E1|E2] = P[E1] or equivalently,
P[E2|E1] = P[E2]. Similarly, we say that E1 and E2 are conditionally independent given E3 if
P[E1 ∩ E2|E3] = P[E1|E3]P[E2|E3] (2.13)
From the definition of conditional probability, we can derive the law of total probability, which
states the following: if {A1, . . . , An} is a partition of the sample space Ω, then for any event B ⊆ Ω,
we have
P[B] = Xn
i=1
P[B|Ai
]P[Ai
] (2.14)
2.1.6 Bayes’ rule
From the definition of conditional probability, we can derive Bayes’ rule, also called Bayes’
theorem, which says that, for any two events E1 and E2 such that P[E1] > 0 and P[E2] > 0, we
have
P[E1|E2] = P[E2|E1]P[E1]
P[E2]
(2.15)
For a discrete random variable X with K possible states, we can write Bayes’ rule as follows, using
the law of total probability:
p(X = k|E) = p(E|X = k)p(X = k)
p(E)
=
p(E|X = k)p(X = k)
PK
k′=1 p(E|X = k
′)p(X = k
′)
(2.16)
Here p(X = k) is the prior probability, p(E|X = k) is the likelihood, p(X = k|E) is the
posterior probability, and p(E) is a normalization constant, known as the marginal likelihood.
Similarly, for a continuous random variable X, we can write Bayes’ rule as follows:
p(X = x|E) = p(E|X = x)p(X = x)
p(E)
=
p(E|X = x)p(X = x)
R
p(E|X = x
′)p(X = x
′)dx′
(2.17)
2.2 Some common probability distributions
There are a wide variety of probability distributions that are used for various kinds of models. We
summarize some of the more commonly used ones in the sections below. See Supplementary Chapter 2
for more information, and https://ben18785.shinyapps.io/distribution-zoo/ for an interactive
visualization.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.2. SOME COMMON PROBABILITY DISTRIBUTIONS
2.2.1 Discrete distributions
In this section, we discuss some discrete distributions defined on subsets of the (non-negative) integers.
2.2.1.1 Bernoulli and binomial distributions
Let x ∈ {0, 1, . . . , N}. The binomial distribution is defined by
Bin(x|N, µ) ,

N
x

µ
x
(1 − µ)
N−x
(2.18)
where ￾N
k

,
N!
(N−k)!k!
is the number of ways to choose k items from N (this is known as the binomial
coefficient, and is pronounced “N choose k”).
If N = 1, so x ∈ {0, 1}, the binomial distribution reduces to the Bernoulli distribution:
Ber(x|µ) = (
1 − µ if x = 0
µ if x = 1
(2.19)
where µ = E [x] = p(x = 1) is the mean.
2.2.1.2 Categorical and multinomial distributions
If the variable is discrete-valued, x ∈ {1, . . . , K}, we can use the categorical distribution:
Cat(x|θ) ,
Y
K
k=1
θ
I(x=k)
k
(2.20)
Alternatively, we can represent the K-valued variable x with the one-hot binary vector x, which lets
us write
Cat(x|θ) ,
Y
K
k=1
θ
xk
k
(2.21)
If the k’th element of x counts the number of times the value k is seen in N =
PK
k=1 xk trials, then
we get the multinomial distribution:
M(x|N, θ) ,

N
x1 . . . xK
 Y
K
k=1
θ
xk
k
(2.22)
where the multinomial coefficient is defined as

N
k1 . . . km

,
N!
k1! . . . km!
(2.23)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens10
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.2.1.3 Poisson distribution
Suppose X ∈ {0, 1, 2, . . .}. We say that a random variable has a Poisson distribution with parameter
λ > 0, written X ∼ Poi(λ), if its pmf (probability mass function) is
Poi(x|λ) = e
−λ λ
x
x!
(2.24)
where λ is the mean (and variance) of x.
2.2.1.4 Negative binomial distribution
Suppose we have an “urn” with N balls, R of which are red and B of which are blue. Suppose we
perform sampling with replacement until we get n ≥ 1 balls. Let X be the number of these that
are blue. It can be shown that X ∼ Bin(n, p), where p = B/N is the fraction of blue balls; thus X
follows the binomial distribution, discussed in Section 2.2.1.1.
Now suppose we consider drawing a red ball a “failure”, and drawing a blue ball a “success”. Suppose
we keep drawing balls until we observe r failures. Let X be the resulting number of successes (blue
balls); it can be shown that X ∼ NegBinom(r, p), which is the negative binomial distribution
defined by
NegBinom(x|r, p) ,

x + r − 1
x

(1 − p)
r
p
x
(2.25)
for x ∈ {0, 1, 2, . . .}. (If r is real-valued, we replace ￾
x+r−1
x

with Γ(x+r)
x!Γ(r)
, exploiting the fact that
(x − 1)! = Γ(x).)
This distribution has the following moments:
E [x] = p r
1 − p
, V [x] = p r
(1 − p)
2
(2.26)
This two parameter family has more modeling flexibility than the Poisson distribution, since it can
represent the mean and variance separately. This is useful, e.g., for modeling “contagious” events,
which have positively correlated occurrences, causing a larger variance than if the occurrences were
independent. In fact, the Poisson distribution is a special case of the negative binomial, since it can
be shown that Poi(λ) = limr→∞ NegBinom(r, λ
1+λ
). Another special case is when r = 1; this is called
the geometric distribution.
2.2.2 Continuous distributions on R
In this section, we discuss some univariate distributions defined on the reals, p(x) for x ∈ R.
2.2.2.1 Gaussian (Normal)
The most widely used univariate distribution is the Gaussian distribution, also called the normal
distribution. (See [Mur22, Sec 2.6.4] for a discussion of these names.) The pdf (probability density
function) of the Gaussian is given by
N (x|µ, σ2
) ,
1
√
2πσ2
e
− 1
2σ2
(x−µ)
2
(2.27)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.2. SOME COMMON PROBABILITY DISTRIBUTIONS
−4 −2 0 2 4
x
0.0
0.2
0.4
0.6
pdf
Student
(ν = 1)
Gaussian
Student
(ν = 2)
Laplace
(a)
−4 −2 0 2 4
x
−7.5
−5.0
−2.5
0.0
log pdf
Gaussian
Student (ν = 1)
Student (ν = 2)
Laplace
(b)
Figure 2.1: (a) The pdf ’s for a N (0, 1), T1(0, 1) and Laplace(0, 1/
√
2). The mean is 0 and the variance is 1
for both the Gaussian and Laplace. The mean and variance of the Student distribution is undefined when ν = 1.
(b) Log of these pdf ’s. Note that the Student distribution is not log-concave for any parameter value, unlike
the Laplace distribution. Nevertheless, both are unimodal. Generated by student_laplace_pdf_plot.ipynb.
where √
2πσ2 is the normalization constant needed to ensure the density integrates to 1. The
parameter µ encodes the mean of the distribution, which is also equal to the mode. The parameter
σ
2
encodes the variance. Sometimes we talk about the precision of a Gaussian, by which we mean
the inverse variance: λ = 1/σ2
. A high precision means a narrow distribution (low variance) centered
on µ.
The cumulative distribution function or cdf of the Gaussian is defined as
Φ(x; µ, σ2
) ,
Z x
−∞
N (z|µ, σ2
)dz (2.28)
If µ = 0 and σ = 1 (known as the standard normal distribution), we just write Φ(x).
2.2.2.2 Half-normal
For some problems, we want a distribution over non-negative reals. One way to create such a
distribution is to define Y = |X|, where X ∼ N (0, σ2
). The induced distribution for Y is called the
half-normal distribution, which has the pdf
N+(y|σ) , 2N (y|0, σ2
) =
√
2
σ
√
π
exp 
−
y
2
2σ
2

y ≥ 0 (2.29)
This can be thought of as the N (0, σ2
) distribution “folded over” onto itself.
2.2.2.3 Student t-distribution
One problem with the Gaussian distribution is that it is sensitive to outliers, since the probability
decays exponentially fast with the (squared) distance from the center. A more robust distribution is
the Student t-distribution, which we shall call the Student distribution for short. Its pdf is as
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license12
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
follows:
Tν(x|µ, σ2
) =
1
Z
"
1 +
1
ν

x − µ
σ
2
#−(
ν+1
2
)
(2.30)
Z =
√
νπσ2Γ( ν
2
)
Γ( ν+1
2
)
=
√
νσB(
1
2
,
ν
2
) (2.31)
where µ is the mean, σ > 0 is the scale parameter (not the standard deviation), and ν > 0 is called
the degrees of freedom (although a better term would be the degree of normality [Kru13], since
large values of ν make the distribution act like a Gaussian). Here Γ(a) is the gamma function
defined by
Γ(a) ,
Z ∞
0
x
a−1
e
−x
dx (2.32)
and B(a, b) is the beta function, defined by
B(a, b) ,
Γ(a)Γ(b)
Γ(a + b)
(2.33)
2.2.2.4 Cauchy distribution
If ν = 1, the Student distribution is known as the Cauchy or Lorentz distribution. Its pdf is defined
by
C(x|µ, γ) = 1
Z
"
1 + 
x − µ
γ
2
#−1
(2.34)
where Z = γβ(
1
2
,
1
2
) = γπ. This distribution is notable for having such heavy tails that the integral
that defines the mean does not converge.
The half Cauchy distribution is a version of the Cauchy (with mean 0) that is “folded over” on
itself, so all its probability density is on the positive reals. Thus it has the form
C+(x|γ) ,
2
πγ "
1 + 
x
γ
2
#−1
(2.35)
2.2.2.5 Laplace distribution
Another distribution with heavy tails is the Laplace distribution, also known as the double sided
exponential distribution. This has the following pdf:
Laplace(x|µ, b) ,
1
2b
exp

−
|x − µ|
b

(2.36)
Here µ is a location parameter and b > 0 is a scale parameter. See Figure 2.1 for a plot.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.2. SOME COMMON PROBABILITY DISTRIBUTIONS
−4 −2 0 2 4
x
0.0
0.2
0.4
p(x)
Gaussian
Uniform
Laplace
(a)
−2.5 0.0 2.5
−4
−2
0
2
4
Gaussian
(b)
−5 0 5
−5
0
5
Laplace
(c)
−2 0 2
−2
−1
0
1
2
Uniform
(d)
Figure 2.2: Illustration of Gaussian (blue), sub-Gaussian (uniform, green), and super-Gaussian (Laplace,
red) distributions in 1d and 2d. Generated by sub_super_gauss_plot.ipynb.
2.2.2.6 Sub-Gaussian and super-Gaussian distributions
There are two main variants of the Gaussian distribution, known as super-Gaussian or leptokurtic
(“Lepto” is Greek for “narrow”) and sub-Gaussian or platykurtic (“Platy” is Greek for “broad”).
These distributions differ in terms of their kurtosis, which is a measure of how heavy or light their
tails are (i.e., how fast the density dies off to zero away from its mean). More precisely, the kurtosis
is defined as
kurt(z) ,
µ4
σ
4
=
E

(Z − µ)
4

(E [(Z − µ)
2])2
(2.37)
where σ is the standard deviation, and µ4 is the 4th central moment. (Thus µ1 = µ is the mean,
and µ2 = σ
2
is the variance.) For a standard Gaussian, the kurtosis is 3, so some authors define the
excess kurtosis as the kurtosis minus 3.
A super-Gaussian distribution (e.g., the Laplace) has positive excess kurtosis, and hence heavier
tails than the Gaussian. A sub-Gaussian distribution, such as the uniform, has negative excess
kurtosis, and hence lighter tails than the Gaussian. See Figure 2.2 for an illustration.
2.2.3 Continuous distributions on R
+
In this section, we discuss some univariate distributions defined on the positive reals, p(x) for x ∈ R
+.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license14
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 1 2 3 4 5 6 7
0.00
0.25
0.50
0.75
1.00
1.25
1.50
1.75
2.00
Gamma distributions
a=1.0,b=1.0
a=1.5,b=1.0
a=2.0,b=1.0
a=1.0,b=2.0
a=1.5,b=2.0
a=2.0,b=2.0
(a)
0.0 0.2 0.4 0.6 0.8 1.0
0
1
2
3
4
5
6
Beta distributions
a=0.1,b=0.1
a=0.1,b=1.0
a=1.0,b=1.0
a=2.0,b=2.0
a=2.0,b=8.0
(b)
Figure 2.3: (a) Some gamma distributions. If a ≤ 1, the mode is at 0; otherwise the mode is away from 0.
As we increase the rate b, we reduce the horizontal scale, thus squeezing everything leftwards and upwards.
Generated by gamma_dist_plot.ipynb. (b) Some beta distributions. If a < 1, we get a “spike” on the left,
and if b < 1, we get a “spike” on the right. If a = b = 1, the distribution is uniform. If a > 1 and b > 1, the
distribution is unimodal. Generated by beta_dist_plot.ipynb.
2.2.3.1 Gamma distribution
The gamma distribution is a flexible distribution for positive real valued rv’s, x > 0. It is defined
in terms of two parameters, called the shape a > 0 and the rate b > 0:
Ga(x|shape = a,rate = b) ,
b
a
Γ(a)
x
a−1
e
−xb (2.38)
Sometimes the distribution is parameterized in terms of the rate a and the scale s = 1/b:
Ga(x|shape = a,scale = s) ,
1
s
aΓ(a)
x
a−1
e
−x/s (2.39)
See Figure 2.3a for an illustration.
2.2.3.2 Exponential distribution
The exponential distribution is a special case of the gamma distribution and is defined by
Expon(x|λ) , Ga(x|shape = 1,rate = λ) (2.40)
This distribution describes the times between events in a Poisson process, i.e., a process in which
events occur continuously and independently at a constant average rate λ.
2.2.3.3 Chi-squared distribution
The chi-squared distribution is a special case of the gamma distribution and is defined by
χ
2
ν
(x) , Ga(x|shape =
ν
2
,rate =
1
2
) (2.41)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.2. SOME COMMON PROBABILITY DISTRIBUTIONS
where ν is called the degrees of freedom. This is the distribution of the sum of squared Gaussian
random variables. More precisely, if Zi ∼ N (0, 1), and S =
Pν
i=1 Z
2
i
, then S ∼ χ
2
ν
. Hence if
X ∼ N (0, σ2
) then X2 ∼ σ
2χ
2
1
. Since E

χ
2
1

= 1 and V

χ
2
1

= 2, we have
E

X2

= σ
2
, V

X2

= 2σ
4
(2.42)
2.2.3.4 Inverse gamma
The inverse gamma distribution, denoted Y ∼ IG(a, b), is the distribution of Y = 1/X assuming
X ∼ Ga(a, b). This pdf is defined by
IG(x|shape = a,scale = b) ,
b
a
Γ(a)
x
−(a+1)e
−b/x (2.43)
The mean only exists if a > 1. The variance only exists if a > 2.
The scaled inverse chi-squared distribution is a reparameterization of the inverse gamma
distribution:
χ
−2
(x|ν, σ2
) = IG(x|shape =
ν
2
,scale =
νσ2
2
) (2.44)
=
1
Γ(ν/2) 
νσ2
2
ν/2
x
− ν
2 −1
exp 
−
νσ
2
2x

(2.45)
The regular inverse chi-squared distribution, written χ
−2
ν
(x), is the special case where νσ2 = 1 (i.e.,
σ
2 = 1/ν). This corresponds to IG(x|shape = ν/2,scale =
1
2
).
2.2.3.5 Pareto distribution
The Pareto distribution has the following pdf:
Pareto(x|m, κ) = κmκ
1
x
(κ+1) I(x ≥ m) (2.46)
See Figure 2.4(a) for some plots. We see that x must be greater than the minimum value m, but
then the pdf rapidly decays after that. If we plot the distribution on a log-log scale, it forms the
straight line log p(x) = −a log x + log(c), where a = (κ + 1) and c = κmκ
: see Figure 2.4(b) for an
illustration.
When m = 0, the distribution has the form p(x) = κx−a
. This is known as a power law. If
a = 1, the distribution has the form p(x) ∝ 1/x; if we interpret x as a frequency, this is called a 1/f
function.
The Pareto distribution is useful for modeling the distribution of quantities that exhibit heavy
tails or long tails, in which most values are small, but there are a few very large values. Many forms
of data exhibit this property. ([ACL16] argue that this is because many datasets are generated by a
variety of latent factors, which, when mixed together, naturally result in heavy tailed distributions.)
We give some examples below.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license16
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0.0 0.1 0.2 0.3 0.4 0.5
x
0
10
20
p(x|m, k)
Pareto Distribution
m=0.1, k=1
m=0.1, k=2
m=0.2, k=1
m=0.2, k=2
(a)
10−1
100
log(x)
10−1
100
101
log p(x|m, k)
Log Pareto Distribution
(b)
Figure 2.4: (a) The Pareto pdf Pareto(x|k, m). (b) Same distribution on a log-log plot. Generated by
pareto_dist_plot.ipynb.
100
101
102
103
rank
100
101
102
103
frequency
word counts
linear prediction
Figure 2.5: A log-log plot of the frequency vs the rank for the words in H. G. Wells’ The Time Machine.
Generated by zipfs_law_plot.ipynb. Adapted from a figure from [Zha+20a, Sec 8.3].
Modeling wealth distributions
The Pareto distribution is named after the Italian economist and sociologist Vilfredo Pareto. He
created it in order to model the distribution of wealth across different countries. Indeed, in economics,
the parameter κ is called the Pareto index. If we set κ = 1.16, we recover the 80-20 rule, which
states that 80% of the wealth of a society is held by 20% of the population.2
Zipf ’s law
Zipf ’s law says that the most frequent word in a language (such as “the”) occurs approximately
twice as often as the second most frequent word (“of”), which occurs twice as often as the fourth
most frequent word, etc. This corresponds to a Pareto distribution of the form
p(x = r) ∝ κr−a
(2.47)
2. In fact, wealth distributions are even more skewed than this. For example, as of 2014, 80 billion￾aires now have as much wealth as 3.5 billion people! (Source: http://www.pbs.org/newshour/making-sense/
wealthiest-getting-wealthier-lobbying-lot.) Such extreme income inequality exists in many plutocratic countries,
including the USA (see e.g., [HP10]).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.2. SOME COMMON PROBABILITY DISTRIBUTIONS
where r is the rank of word x when sorted by frequency, and κ and a are constants. If we set a = 1,
we recover Zipf’s law.3 Thus Zipf’s law predicts that if we plot the log frequency of words vs their
log rank, we will get a straight line with slope −1. This is in fact true, as illustrated in Figure 2.5.
4
See [Ada00] for further discussion of Zipf’s law, and Section 2.6.2 for a discussion of language models.
2.2.4 Continuous distributions on [0, 1]
In this section, we discuss some univariate distributions defined on the [0, 1] interval.
2.2.4.1 Beta distribution
The beta distribution has support over the interval [0, 1] and is defined as follows:
Beta(x|a, b) = 1
B(a, b)
x
a−1
(1 − x)
b−1
(2.48)
where B(a, b) is the beta function. We require a, b > 0 to ensure the distribution is integrable (i.e.,
to ensure B(a, b) exists). If a = b = 1, we get the uniform distribution. If a and b are both less than
1, we get a bimodal distribution with “spikes” at 0 and 1; if a and b are both greater than 1, the
distribution is unimodal. See Figure 2.3b.
2.2.5 Multivariate continuous distributions
In this section, we summarize some other widely used multivariate continuous distributions.
2.2.5.1 Multivariate normal (Gaussian)
The multivariate normal (MVN), also called the multivariate Gaussian, is by far the most
widely used multivariate distribution. As such, the whole of Section 2.3 is dedicated to it.
2.2.5.2 Multivariate Student distribution
One problem with Gaussians is that they are sensitive to outliers. Fortunately, we can easily extend
the Student distribution, discussed in Main Section 2.2.2.3, to D dimensions. In particular, the pdf
of the multivariate Student distribution is given by
Tν(x|µ, Σ) = 1
Z

1 +
1
ν
(x − µ)
TΣ
−1
(x − µ)
−(
ν+D
2
)
(2.49)
Z =
Γ(ν/2)
Γ(ν/2 + D/2)
ν
D/2π
D/2
|Σ|−1/2
(2.50)
where Σ is called the scale matrix.
3. For example, p(x = 2) = κ2−1 = 2κ4−1 = 2p(x = 4).
4. We remove the first 10 words from the plot, since they don’t fit the prediction as well.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license18
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The Student has fatter tails than a Gaussian. The smaller ν is, the fatter the tails. As ν → ∞,
the distribution tends towards a Gaussian. The distribution has these properties:
mean = µ, mode = µ, cov =
ν
ν − 2
Σ (2.51)
The mean is only well defined (finite) if ν > 1. Similarly, the covariance is only well defined if ν > 2.
2.2.5.3 Circular normal (von Mises Fisher) distribution
Sometimes data lives on the unit sphere, rather than being any point in Euclidean space. For example,
any D dimensional vector that is ℓ2-normalized lives on the unit (D − 1) sphere embedded in R
D.
There is an extension of the Gaussian distribution that is suitable for such angular data, known as
the von Mises-Fisher distribution, or the circular normal distribution. It has the following pdf:
vMF(x|µ, κ) ,
1
Z
exp(κµ
Tx) (2.52)
Z =
(2π)
D/2
ID/2−1(κ)
κD/2−1
(2.53)
where µ is the mean (with ||µ|| = 1), κ ≥ 0 is the concentration or precision parameter (analogous
to 1/σ for a standard Gaussian), and Z is the normalization constant, with Ir(·) being the modified
Bessel function of the first kind and order r. The vMF is like a spherical multivariate Gaussian,
parameterized by cosine distance instead of Euclidean distance.
The vMF distribution can be used inside of a mixture model to cluster ℓ2-normalized vectors, as
an alternative to using a Gaussian mixture model [Ban+05]. If κ → 0, this reduces to the spherical
K-means algorithm. It can also be used inside of an admixture model (Main Section 28.4.2); this is
called the spherical topic model [Rei+10].
If D = 2, an alternative is to use the von Mises distribution on the unit circle, which has the form
vMF(x|µ, κ) = 1
Z
exp(κ cos(x − µ)) (2.54)
Z = 2πI0(κ) (2.55)
2.2.5.4 Matrix normal distribution (MN)
The matrix normal distribution is defined by the following probability density function over matrices
X ∈ R
n×p
:
MN (X|M, U, V) ,
|V|
n/2
2π
np/2|U|
p/2
exp 
−
1
2
tr 
(X − M)
TU−1
(X − M)V


(2.56)
where M ∈ R
n×p
is the mean value of X, U ∈ Sn×n
++ is the covariance among rows, and V ∈ Sp×p
++ is
the precision among columns. It can be seen that
vec(X) ∼ N (vec(M), V−1 ⊗ U). (2.57)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.2. SOME COMMON PROBABILITY DISTRIBUTIONS
Note that there is another version of the definition of the matrix normal distribution using the
column-covariance matrix V˜ = V−1
instead of V, which leads to the density
1
2π
np/2|U|
p/2|V˜ |
n/2
exp 
−
1
2
tr h
(X − M)
TU−1
(X − M)V˜ −1
i
. (2.58)
These two versions of definition are obviously equivalent, but we will see that the definition we adopt
in Equation (2.56) will lead to a neat update of the posterior distribution (just as the precision matrix
is more convenient to use than the covariance matrix in analyzing the posterior of the multivariate
normal distribution with a conjugate prior).
2.2.5.5 Wishart distribution
The Wishart distribution is the generalization of the gamma distribution to positive definite matrices.
Press [Pre05, p107] has said, “The Wishart distribution ranks next to the normal distribution in
order of importance and usefulness in multivariate statistics”. We will mostly use it to model our
uncertainty when estimating covariance matrices (see Section 3.4.4).
The pdf of the Wishart is defined as follows:
Wi(Σ|S, ν) ,
1
Z
|Σ|
(ν−D−1)/2
exp 
−
1
2
tr(ΣS
−1
)

(2.59)
Z , |S|
−ν/2
2
νD/2ΓD(ν/2) (2.60)
Here ν is called the “degrees of freedom” and S is the “scale matrix”. (We shall get more intuition for
these parameters shortly.) The normalization constant only exists (and hence the pdf is only well
defined) if ν > D − 1.
The distribution has these properties:
mean = νS, mode = (ν − D − 1)S (2.61)
Note that the mode only exists if ν > D + 1.
If D = 1, the Wishart reduces to the gamma distribution:
Wi(λ|s
−1
, ν) = Ga(λ|shape =
ν
2
,rate =
1
2s
) (2.62)
If s = 2, this reduces to the chi-squared distribution.
There is an interesting connection between the Wishart distribution and the Gaussian. In particular,
let xn ∼ N (0, Σ). One can show that the scatter matrix, S =
PN
n=1 xnx
T
n
, has a Wishart distribution:
S ∼ Wi(Σ, N).
2.2.5.6 Inverse Wishart distribution
If λ ∼ Ga(a, b), then that 1
λ ∼ IG(a, b). Similarly, if Σ
−1 ∼ Wi(S
−1
, ν) then Σ ∼ IW(S, ν), where
IW is the inverse Wishart, the multidimensional generalization of the inverse gamma. It is defined
as follows, for ν > D − 1 and S ≻ 0:
IW(Σ|S, ν) = 1
Z
|Σ|
−(ν+D+1)/2
exp 
−
1
2
tr(SΣ
−1
)

(2.63)
ZIW = |S|
−ν/2
2
νD/2ΓD(ν/2) (2.64)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license20
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
One can show that the distribution has these properties:
mean =
S
ν − D − 1
, mode =
S
ν + D + 1
(2.65)
If D = 1, this reduces to the inverse gamma:
IW(σ
2
|s
−1
, ν) = IG(σ
2
|ν/2, s/2) (2.66)
If s = 1, this reduces to the inverse chi-squared distribution.
2.2.5.7 Dirichlet distribution
A multivariate generalization of the beta distribution is the Dirichlet5 distribution, which has
support over the probability simplex, defined by
SK = {x : 0 ≤ xk ≤ 1,
X
K
k=1
xk = 1} (2.67)
The pdf is defined as follows:
Dir(x|α) ,
1
B(α)
Y
K
k=1
x
αk−1
k
I(x ∈ SK) (2.68)
where B(α) is the multivariate beta function,
B(α) ,
QK
k=1 Γ(αk)
Γ(PK
k=1 αk)
(2.69)
Figure 2.6 shows some plots of the Dirichlet when K = 3. We see that α0 =
P
k αk controls the
strength of the distribution (how peaked it is), and the αk control where the peak occurs. For example,
Dir(1, 1, 1) is a uniform distribution, Dir(2, 2, 2) is a broad distribution centered at (1/3, 1/3, 1/3),
and Dir(20, 20, 20) is a narrow distribution centered at (1/3, 1/3, 1/3). Dir(3, 3, 20) is an asymmetric
distribution that puts more density in one of the corners. If αk < 1 for all k, we get “spikes” at the
corners of the simplex. Samples from the distribution when αk < 1 are sparse, as shown in Figure 2.7.
For future reference, here are some useful properties of the Dirichlet distribution:
E [xk] = αk
α0
, mode [xk] = αk − 1
α0 − K
, V [xk] = αk(α0 − αk)
α
2
0
(α0 + 1) (2.70)
where α0 =
P
k αk.
Often we use a symmetric Dirichlet prior of the form αk = α/K. In this case, we have E [xk] = 1/K,
and V [xk] =
K−1
K2(α+1) . So we see that increasing α increases the precision (decreases the variance) of
the distribution.
5. Johann Dirichlet was a German mathematician, 1805–1859.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.2. SOME COMMON PROBABILITY DISTRIBUTIONS
1
2
3
(a) (b)
(c) (d)
Figure 2.6: (a) The Dirichlet distribution when K = 3 defines a distribution over the simplex, which can be
represented by the triangular surface. Points on this surface satisfy 0 ≤ θc ≤ 1 and P3
c=1 θc = 1. Generated
by dirichlet_3d_triangle_plot.ipynb. (b) Plot of the Dirichlet density for α = (20, 20, 20). (c) Plot of the
Dirichlet density for α = (3, 3, 20). (d) Plot of the Dirichlet density for α = (0.1, 0.1, 0.1). Generated by
dirichlet_3d_spiky_plot.ipynb.
The Dirichlet distribution is useful for distinguishing aleatoric (data) uncertainty from epistemic
uncertainty. To see this, consider a 3-sided die. If we know that each outcome is equally likely, we
can use a “peaky” symmetric Dirichlet, such as Dir(20, 20, 20), shown in Figure 2.6(b); this reflects
the fact that we are sure the outcomes will be unpredictable. By contrast, if we are not sure what
the outcomes will be like (e.g., it could be a biased die), then we can use a “flat” symmetric Dirichlet,
such as Dir(1, 1, 1), which can generate a wide range of possible outcome distributions. We can make
the Dirichlet distribution be conditional on inputs, resulting in what is called a prior network
[MG18], since it encodes p(π|x) (output is a distributon) rather than p(y|x) (output is a label).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license22
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
Samples from Dir (alpha=0.1)
(a)
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
1 2 3 4 5
0.0
0.5
1.0
Samples from Dir (alpha=1.0)
(b)
Figure 2.7: Samples from a 5-dimensional symmetric Dirichlet distribution for different parameter values. (a)
α = (0.1, . . . , 0.1). This results in very sparse distributions, with many 0s. (b) α = (1, . . . , 1). This results in
more uniform (and dense) distributions. Generated by dirichlet_samples_plot.ipynb.
2.3 Gaussian joint distributions
The most widely used joint probability distribution for continuous random variables is the multivari￾ate Gaussian or multivariate normal (MVN). The popularity is partly because this distribution
is mathematically convenient, but also because the Gaussian assumption is fairly reasonable in many
cases. Indeed, the Gaussian is the distribution with maximum entropy subject to having specified first
and second moments (Section 2.4.7). In view of its importance, this section discusses the Gaussian
distribution in detail.
2.3.1 The multivariate normal
In this section, we discuss the multivariate Gaussian or multivariate normal in detail.
2.3.1.1 Definition
The MVN density is defined by the following:
N (x|µ, Σ) ,
1
(2π)D/2|Σ|
1/2
exp 
−
1
2
(x − µ)
TΣ
−1
(x − µ)

(2.71)
where µ = E [x] ∈ R
D is the mean vector, and Σ = Cov [x] is the D × D covariance matrix. The
normalization constant Z = (2π)
D/2
|Σ|
1/2
just ensures that the pdf integrates to 1. The expression
inside the exponential (ignoring the factor of −0.5) is the squared Mahalanobis distance between
the data vector x and the mean vector µ, given by
dΣ(x, µ)
2 = (x − µ)
TΣ
−1
(x − µ) (2.72)
In 2d, the MVN is known as the bivariate Gaussian distribution. Its pdf can be represented as
x ∼ N (µ, Σ), where x ∈ R
2
, µ ∈ R
2 and
Σ =

σ
2
1 σ
2
12
σ
2
21 σ
2
2

=

σ
2
1 ρσ1σ2
ρσ1σ2 σ
2
2

(2.73)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.3. GAUSSIAN JOINT DISTRIBUTIONS
−5 0 5
(a)
−5.0
−2.5
0.0
2.5
5.0
Full
−5 0 5
(b)
Diagonal
−5 0 5
(c)
Spherical
0.00
0.02
0.04
0.06
0.08
0.10
0.12
0.14
0.16
p(y1, y2)
Figure 2.8: Visualization of a 2d Gaussian density in terms of level sets of constant probability density. (a) A
full covariance matrix has elliptical contours. (b) A diagonal covariance matrix is an axis aligned ellipse. (c)
A spherical covariance matrix has a circular shape. Generated by gauss_plot_2d.ipynb.
where the correlation coefficient is given by ρ ,
σ
2
12
σ1σ2
.
Figure 2.8 plots some MVN densities in 2d for three different kinds of covariance matrices. A full
covariance matrix has D(D + 1)/2 parameters, where we divide by 2 since Σ is symmetric. A
diagonal covariance matrix has D parameters, and has 0s in the off-diagonal terms. A spherical
covariance matrix, also called isotropic covariance matrix, has the form Σ = σ
2
ID, so it only
has one free parameter, namely σ
2
.
2.3.1.2 Gaussian shells
Multivariate Gaussians can behave rather counterintuitively in high dimensions. In particular, we
can ask: if we draw samples x ∼ N (0, ID), where D is the number of dimensions, where do we
expect most of the x to lie? Since the peak (mode) of the pdf is at the origin, it is natural to expect
most samples to be near the origin. However, in high dimensions, the typical set of a Gaussian is
a thin shell or annulus with a distance from origin given by r = σ
√
D and a thickness of O(σD 1
4 ).
The intuitive reason for this is as follows: although the density decays as e
−r
2/2
, meaning density
decreases from the origin, the volume of a sphere grows as r
D, meaning volume increases from the
origin, and since mass is density times volume, the majority of points end up in this annulus where
these two terms “balance out”. This is called the “Gaussian soap bubble” phenomenon, and is
illustrated in Figure 2.9.
6
To see why the typical set for a Gaussian is concentrated in a thin annulus at radius √
D, consider
the squared distance of a point x from the origin, d(x) = qPD
i=1 x
2
i
, where xi ∼ N (0, 1). The
expected squared distance is given by E

d
2

=
PD
i=1 E

x
2
i

= D, and the variance of the squared
distance is given by V

d
2

=
PD
i=1 V

x
2
i

= D. As D grows, the coefficient of variation (i.e., the SD
relative to the mean) goes to zero:
lim
D→∞
std 
d
2

E [d
2]
= lim
D→∞
√
D
D
= 0 (2.74)
6. For a more detailed explanation, see this blog post by Ferenc Huszar: https://www.inference.vc/
high-dimensional-gaussian-distributions-are-soap-bubble/.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license24
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 2.9: (a) Cartoon illustration of why the typical set of a Gaussian is not centered at the mode of the
distribution. (b) Illustration of the typical set of a Gaussian, which is concentrated in a thin annulus of
thickness σD1/4
and distance σD1/2
from the origin. We also show an image with the highest density (the
all gray image on the left). as well as some high probability samples (the speckle noise images on the right).
From Figure 1 of [Nal+19a]. Used with kind permission of Eric Nalisnick.
Thus the expected square distance concentrates around D, so the expected distance concentrates
around E [d(x)] =
√
D. See [Ver18] for a more rigorous proof, and Section 5.2.3 for a discussion of
typical sets.
To see what this means in the context of images, in Figure 2.9b, we show some grayscale images
that are sampled from a Gaussian of the form N (µ, σ2
I), where µ corresponds to the all-gray image.
However, it is extremely unlikely that randomly sampled images would be close to all-gray, as shown
in the figure.
2.3.1.3 Marginals and conditionals of an MVN
Let us partition our vector of random variables x into two parts, x1 and x2, so
µ =

µ1
µ2

, Σ =

Σ11 Σ12
Σ21 Σ22
(2.75)
The marginals of this distribution are given by the following (see Section 2.3.1.5 for the proof):
p(x1) = Z
N (x|µ, Σ)dx2 , N (x1|µ
m
1
, Σ
m
1
) = N (x1|µ1
, Σ11) (2.76)
p(x2) = Z
N (x|µ, Σ)dx1 , N (x2|µ
m
2
, Σ
m
2
) = N (x2|µ2
, Σ22) (2.77)
The conditional distributions can be shown to have the following form (see Section 2.3.1.5 for the
proof):
p(x1|x2) = N (x1|µ
c
1|2
, Σ
c
1|2
) = N (x1|µ1 + Σ12Σ
−1
22 (x2 − µ2
), Σ11 − Σ12Σ
−1
22 Σ21) (2.78)
p(x2|x1) = N (x2|µ
c
2|1
, Σ
c
2|1
) = N (x2|µ2 + Σ21Σ
−1
11 (x1 − µ1
), Σ22 − Σ21Σ
−1
11 Σ12) (2.79)
Note that the posterior mean of p(x1|x2) is a linear function of x2, but the posterior covariance is
independent of x2; this is a peculiar property of Gaussian distributions.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.3. GAUSSIAN JOINT DISTRIBUTIONS
2.3.1.4 Information (canonical) form
It is common to parameterize the MVN in terms of the mean vector µ and the covariance matrix Σ.
However, for reasons which are explained in Section 2.4.2.5, it is sometimes useful to represent the
Gaussian distribution using canonical parameters or natural parameters, defined as
Λ , Σ
−1
, η , Σ
−1µ (2.80)
The matrix Λ = Σ
−1
is known as the precision matrix, and the vector η is known as the
precision-weighted mean. We can convert back to the more familiar moment parameters using
µ = Λ
−1η, Σ = Λ
−1
(2.81)
Hence we can write the MVN in canonical form (also called information form) as follows:
Nc(x|η, Λ) , c exp 
x
Tη −
1
2
x
TΛx

(2.82)
c ,
exp(−
1
2
η
TΛ
−1η)
(2π)D/2
q
det(Λ
−1
)
(2.83)
where we use the notation Nc() to distinguish it from the standard parameterization N (). For more
information on moment and natural parameters, see Section 2.4.2.5.
It is also possible to derive the marginalization and conditioning formulas in information form (see
Section 2.3.1.6 for the derivation). For the marginals we have
p(x1) = Nc(x1|η
m
1
, Λ
m
1
) = Nc(x1|η1 − Λ12Λ
−1
22 η2
, Λ11 − Λ12Λ
−1
22 Λ21) (2.84)
p(x2) = Nc(x2|η
m
2
, Λ
m
2
) = Nc(x2|η2 − Λ21Λ
−1
11 η1
, Λ22 − Λ21Λ
−1
11 Λ12) (2.85)
For the conditionals we have
p(x1|x2) = Nc(x1|η
c
1|2
, Λ
c
1|2
) = Nc(x1|η1 − Λ12x2, Λ11) (2.86)
p(x2|x1) = Nc(x2|η
c
2|1
, Λ
c
2|1
) = Nc(x2|η2 − Λ21x1, Λ22) (2.87)
Thus we see that marginalization is easier in moment form, and conditioning is easier in information
form.
2.3.1.5 Derivation: moment form
In this section, we derive Equation (2.77) and Equation (2.78) for marginalizing and conditioning an
MVN in moment form.
Before we dive in, we need to introduce the following result, for the inverse of a partitioned
matrix of the form
M =

E F
G H
(2.88)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license26
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where we assume E and H are invertible. One can show (see e.g., [Mur22, Sec 7.3.2] for the proof)
that
M−1 =

(M/H)
−1 −(M/H)
−1FH−1
−H−1G(M/H)
−1 H−1 + H−1G(M/H)
−1FH−1

(2.89)
=

E−1 + E−1F(M/E)
−1GE−1 −E−1F(M/E)
−1
−(M/E)
−1GE−1
(M/E)
−1

(2.90)
where
M/H , E − FH−1G (2.91)
M/E , H − GE−1F (2.92)
We say that M/H is the Schur complement of M wrt H, and M/E is the Schur complement of
M wrt E.
From the above, we also have the following important result, known as the matrix inversion
lemma or the Sherman-Morrison-Woodbury formula:
(M/H)
−1 = (E − FH−1G)
−1 = E
−1 + E
−1F(H − GE−1F)
−1GE−1
(2.93)
Now we return to the derivation of the MVN conditioning equation. Let us factor the joint p(x1, x2)
as p(x2)p(x1|x2) as follows:
p(x1, x2) ∝ exp (
−
1
2

x1 − µ1
x2 − µ2
T 
Σ11 Σ12
Σ21 Σ22−1 
x1 − µ1
x2 − µ2
)
(2.94)
Using the equation for the inverse of a block structured matrix, the above exponent becomes
p(x1, x2) ∝ exp (
−
1
2

x1 − µ1
x2 − µ2
T 
I 0
−Σ
−1
22 Σ21 I
 (Σ/Σ22)
−1 0
0 Σ−1
22 
(2.95)
×

I −Σ12Σ
−1
22
0 I  x1 − µ1
x2 − µ2
 (2.96)
= exp 
−
1
2
(x1 − µ1 − Σ12Σ
−1
22 (x2 − µ2
))
T
(Σ/Σ22)
−1
(2.97)
(x1 − µ1 − Σ12Σ
−1
22 (x2 − µ2
))	
× exp 
−
1
2
(x2 − µ2
)
TΣ
−1
22 (x2 − µ2
)

(2.98)
This is of the form
exp(quadratic form in x1, x2) × exp(quadratic form in x2) (2.99)
Hence we have successfully factorized the joint as
p(x1, x2) = p(x1|x2)p(x2) (2.100)
= N (x1|µ1|2
, Σ1|2)N (x2|µ2
, Σ22) (2.101)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.3. GAUSSIAN JOINT DISTRIBUTIONS
where
µ1|2 = µ1 + Σ12Σ
−1
22 (x2 − µ2
) (2.102)
Σ1|2 = Σ/Σ22 , Σ11 − Σ12Σ
−1
22 Σ21 (2.103)
where Σ/Σ22 is as the Schur complement of Σ wrt Σ22.
2.3.1.6 Derivation: information form
In this section, we derive Equation (2.85) and Equation (2.86) for marginalizing and conditioning an
MVN in information form.
First we derive the conditional formula.7 Let us partition the information form parameters as
follows:
η =

η1
η2

, Λ =

Λ11 Λ12
Λ21 Λ22
(2.104)
We can now write the joint log probabilty of x1, x2 as
ln p(x1, x2) = −
1
2

x1
x2
T 
Λ11 Λ12
Λ21 Λ22 x1
x2

+

x1
x2
T 
η1
η2

+ const. (2.105)
= −
1
2
x
T
1Λ11x1 −
1
2
x
T
2Λ22x2 −
1
2
x
T
1Λ12x2 −
1
2
x
T
2Λ21x1
+ x
T
1η1 + x
T
2η2 + const.
(2.106)
where the constant term does not depend on x1 or x2.
To calculate the parameters of the conditional distribution p(x1|x2), we fix the value of x2 and
collect the terms which are quadratic in x1 for the conditional precision and then linear in x1 for the
conditional precision-weighted mean. The terms which are quadratic in x1 are just −
1
2
x
T
1Λ11x1, and
hence
Λ
c
1|2 = Λ11 (2.107)
The terms which are linear in x1 are
−
1
2
x
T
1Λ12x2 −
1
2
x
T
2Λ21x1 + x
T
1η1 = x
T
1
(η1 − Λ12x2) (2.108)
since Λ
T
21 = Λ12. Thus the conditional precision-weighted mean is
η
c
1|2 = η1 − Λ12x2. (2.109)
We will now derive the results for marginalizing in information form. The marginal, p(x2), can be
calculated by integrating the joint, p(x1, x2), with respect to x1:
p(x2) =Z
p(x1, x2)dx1 (2.110)
∝
Z
exp 
−
1
2
x
T
1Λ11x1 −
1
2
x
T
2Λ22x2 −
1
2
x
T
1Λ12x2 −
1
2
x
T
2Λ21x1 + x
T
1η1 + x
T
2η2

dx1,
(2.111)
7. This derivation is due to Giles Harper-Donnelly.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license28
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where the terms in the exponent have been decomposed into the partitioned structure in Equa￾tion (2.104) as in Equation (2.106). Next, collecting all the terms involving x1,
p(x2) ∝ exp 
−
1
2
x
T
2Λ22x2 + x
T
2η2
 Z
exp 
−
1
2
x
T
1Λ11x1 + x
T
1
(η1 − Λ12x2)

dx1, (2.112)
we can recognize the integrand as an exponential quadratic form. Therefore the integral is equal to
the normalizing constant of a Gaussian with precision, Λ11, and precision weighted mean, η1 −Λ12x2,
which is given by the reciprocal of Equation (2.83). Substituting this in to our equation we have,
p(x2) ∝ exp 
−
1
2
x
T
2Λ22x2 + x
T
2η2

exp 
1
2
(η1 − Λ12x2)
TΛ
−1
11 (η1 − Λ12x2)

(2.113)
∝ exp 
−
1
2
x
T
2Λ22x2 + x
T
2η2 +
1
2
x
T
2Λ21Λ
−1
11 Λ12x2 − x
T
2Λ21Λ
−1
11 η1

(2.114)
= exp 
−
1
2
x
T
2
(Λ22 − Λ21Λ
−1
11 Λ12)x2 + x
T
2
(η2 − Λ21Λ
−1
11 η1
)

, (2.115)
which we now recognise as an exponential quadratic form in x2. Extract the quadratic terms to get
the marginal precision,
Λ
m
22 = Λ22 − Λ21Λ
−1
11 Λ12, (2.116)
and the linear terms to get the marginal precision-weighted mean,
η
m
2 = η2 − Λ21Λ
−1
11 η1
. (2.117)
2.3.2 Linear Gaussian systems
Consider two random vectors y ∈ R
D and z ∈ R
L, which are jointly Gaussian with the following
joint distribution:
p(z) = N (z|
`µ,
`
Σ) (2.118)
p(y|z) = N (y|Wz + b, Ω) (2.119)
where W is a matrix of size D × L. This is an example of a linear Gaussian system.
2.3.2.1 Joint distribution
The corresponding joint distribution, p(z, y) = p(z)p(y|z), is itself a D + L dimensional Gaussian,
with mean and covariance given by the following (this result can be obtained by moment matching):
p(z, y) = N (z, y|µ˜, Σ˜ ) (2.120a)
µ˜ ,
 `µ
m

,
 `µ
W `µ +b

(2.120b)
Σ˜ ,
`
Σ CT
C S 
,
 `
Σ
`
Σ WT
W
`
Σ W `
Σ WT + Ω
!
(2.120c)
See Algorithm 8.1 on page 363 for some pseudocode to compute this joint distribution.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.3. GAUSSIAN JOINT DISTRIBUTIONS
2.3.2.2 Posterior distribution (Bayes’ rule for Gaussians)
Now we consider computing the posterior p(z|y) from a linear Gaussian system. Using Equation (2.78)
for conditioning a joint Gaussian, we find that the posterior is given by
p(z|y) = N (z|
aµ,
a
Σ) (2.121a)
aµ =
`µ +
`
Σ WT
(Ω + W
`
Σ WT
)
−1
(y − (W `µ +b)) (2.121b)
a
Σ =
`
Σ −
`
Σ WT
(Ω + W
`
Σ WT
)
−1W
`
Σ (2.121c)
This is known as Bayes’ rule for Gaussians. We see that if the prior p(z) is Gaussian, and the
likelihood p(y|z) is Gaussian, then the posterior p(z|y) is also Gaussian. We therefore say that the
Gaussian prior is a conjugate prior for the Gaussian likelihood, since the posterior distribution has
the same type as the prior. (In other words, Gaussians are closed under Bayesian updating.)
We can simplify these equations by defining S = W
`
Σ WT + Ω, C =
`
Σ WT, and m = W `µ +b,
as in Equation (2.120). We also define the Kalman gain matrix:
8
K = CS−1
(2.122)
From this, we get the posterior
aµ =
`µ +K(y − m) (2.123)
a
Σ =
`
Σ −KCT
(2.124)
Note that
KSKT = CS−1SS−TCT = CS−1CT = KCT
(2.125)
and hence we can also write the posterior covariance as
a
Σ =
`
Σ −KSKT
(2.126)
Using the matrix inversion lemma from Equation (2.93), we can also rewrite the posterior in the
following form [Bis06, p93], which takes O(L
3
) time instead of O(D3
) time:
a
Σ = (
`
Σ
−1
+WTΩ
−1W)
−1
(2.127)
aµ =
a
Σ [WTΩ
−1
(y − b)+ `
Σ
−1`µ] (2.128)
Finally, note that the corresponding normalization constant for the posterior is just the marginal
on y evaluated at the observed value:
p(y) = Z
N (z|
`µ,
`
Σ)N (y|Wz + b, Ω)dz
= N (y|W `µ +b, Ω + W
`
Σ WT
) = N (y|m, S) (2.129)
From this, we can easily compute the log marginal likelihood. We summarize all these equations in
Algorithm 8.1.
8. The name comes from the Kalman filter algorithm, which we discuss in Section 8.2.2.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license30
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−0.3 0.0 0.3 0.6 0.9 1.2
x (observed value)
−1.2
−0.9
−0.6
−0.3
0.0
0.3
y (observed value)
(a)
−0.4 0.0 0.4 0.8 1.2
x (observed value)
−1.6
−1.2
−0.8
−0.4
0.0
(b)
−0.8 −0.4 0.0 0.4 0.8 1.2
x (observed value)
−1.2
−0.8
−0.4
0.0
0.4
0.8
y1
y2
E[x|y1; y2]
(c)
Figure 2.10: We observe x = (0, −1) (red cross) and y = (1, 0) (green cross) and estimate E [z|x, y, θ] (black
cross). (a) Equally reliable sensors, so the posterior mean estimate is in between the two circles. (b) Sensor
2 is more reliable, so the estimate shifts more towards the green circle. (c) Sensor 1 is more reliable in
the vertical direction, Sensor 2 is more reliable in the horizontal direction. The estimate is an appropriate
combination of the two measurements. Generated by sensor_fusion_2d.ipynb.
2.3.2.3 Example: Sensor fusion with known measurement noise
Suppose we have an unknown quantity of interest, z ∼ N (µz
, Σz), from which we get two noisy
measurements, x ∼ N (z, Σx) and y ∼ N (z, Σy). Pictorially, we can represent this example as
x ← z → y. This is an example of a linear Gaussian system. Our goal is to combine the evidence
together, to compute p(z|x, y; θ). This is known as sensor fusion. (In this section, we assume
θ = (Σx, Σy) is known. See Supplementary Section 2.1.2 for the general case.)
We can combine x and y into a single vector v, so the model can be represented as z → v, where
p(v|z) = N (v|Wz, Σv), where W = [I; I] and Σv = [Σx, 0; 0, Σy] are block-structured matrices. We
can then apply Bayes’ rule for Gaussians (Section 2.3.2.2) to compute p(z|v).
Figure 2.10(a) gives a 2d example, where we set Σx = Σy = 0.01I2, so both sensors are equally
reliable. In this case, the posterior mean is halfway between the two observations, x and y. In
Figure 2.10(b), we set Σx = 0.05I2 and Σy = 0.01I2, so sensor 2 is more reliable than sensor 1. In
this case, the posterior mean is closer to y. In Figure 2.10(c), we set
Σx = 0.01 
10 1
1 1
, Σy = 0.01 
1 1
1 10
(2.130)
so sensor 1 is more reliable in the second component (vertical direction), and sensor 2 is more reliable
in the first component (horizontal direction). In this case, the posterior mean is vertically closer to x
and horizontally closer to y.
2.3.3 A general calculus for linear Gaussian systems
In this section, we discuss a general method for performing inference in linear Gaussian systems.
The key is to define joint distributions over the relevant variables in terms of a potential function,
represented in information form. We can then easily derive rules for marginalizing potentials,
multiplying and dividing potentials, and conditioning them on observations. Once we have defined
these operations, we can use them inside of the belief propagation algorithm (Section 9.3) or junction
tree algorithm (Supplementary Section 9.2) to compute quantities of interest. We give the details on
how to perform these operations below; our presentation is based on [Lau92; Mur02].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.3. GAUSSIAN JOINT DISTRIBUTIONS
2.3.3.1 Moment and canonical parameterization
We can represent a Gaussian distribution in moment form or in canonical (information) form. In
moment form we have
φ(x; p, µ, Σ) = p × exp 
−
1
2
(x − µ)
TΣ
−1
(x − µ)

(2.131)
where p = (2π)
−n/2
|Σ|
− 1
2 is the normalizing constant that ensures R
x
φ(x; p, µ, Σ) = 1. (n is the
dimensionality of x.) Expanding out the quadratic form and collecting terms we get the canonical
form:
φ(x; g, h, K) = exp 
g + x
Th −
1
2
x
TKx

= exp 
g +
X
i
hixi −
1
2
X
i
X
k
Kijxixj
!
(2.132)
where
K = Σ
−1
(2.133)
h = Σ
−1µ (2.134)
g = log p −
1
2
µ
TKµ (2.135)
K is often called the precision matrix.
Note that potentials need not be probability distributions, and need not be normalizable (integrate
to 1). We keep track of the constant terms (p or g) so we can compute the likelihood of the evidence.
2.3.3.2 Multiplication and division
We can define multiplication and division in the Gaussian case by using canonical forms, as follows.
To multiply φ1(x1, . . . , xk; g1, h1, K1) by φ2(xk+1, . . . , xn; g2, h2, K2), we extend them both to the
same domain x1, . . . , xn by adding zeros to the appropriate dimensions, and then computing
(g1, h1, K1) ∗ (g2, h2, K2) = (g1 + g2, h1 + h2, K1 + K2) (2.136)
Division is defined as follows:
(g1, h1, K1)/(g2, h2, K2) = (g1 − g2, h1 − h2, K1 − K2) (2.137)
2.3.3.3 Marginalization
Let φW be a potential over a set W of variables. We can compute the potential over a subset V ⊂ W
of variables by marginalizing, denoted φV =
P
W\V
φW . Let
x =

x1
x2

, h =

h1
h2

, K =

K11 K12
K21 K22
, (2.138)
with x1 having dimension n1 and x2 having dimension n2. It can be shown that
Z
x1
φ(x1, x2; g, h, K) = φ(x2; ˆg, hˆ, Kˆ ) (2.139)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license32
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where
gˆ = g +
1
2
￾
n1 log(2π) − log |K11| + h
T
1K−1
11 h1

(2.140)
hˆ = h2 − K21K−1
11 h1 (2.141)
Kˆ = K22 − K21K−1
11 K12 (2.142)
2.3.3.4 Conditioning on evidence
Consider a potential defined on (x, y). Suppose we observe the value y. The new potential is given
by the following reduced dimensionality object:
φ
∗
(x) = exp 
g +
￾
x
T y
T


hX
hY

−
1
2
￾
x
T y
T


KXX KXY
KY X KY Y  x
y
 (2.143)
= exp g + h
T
Y y −
1
2
y
T KY Y y

+ x
T
(hX − KXY y) −
1
2
x
T KXXx

(2.144)
This generalizes the corresponding equation in [Lau92] to the vector-valued case.
2.3.3.5 Converting a linear-Gaussian CPD to a canonical potential
Finally we discuss how to create the initial potentials, assuming we start with a directed Gaussian
graphical model. In particular, consider a node with a linear-Gaussian conditional probability
distribution (CPD):
p(x|u) = c exp 
−
1
2
￾
(x − µ − B
Tu)
T Σ
−1
(x − µ − B
Tu)


(2.145)
= exp 
−
1
2
￾
x u

Σ
−1 −Σ
−1BT
−BΣ−1 BΣ−1BT
 x
u

(2.146)
+
￾
x u


Σ
−1µ
−BΣ−1µ

−
1
2
µ
T Σ
−1µ + log c

(2.147)
where c = (2π)
−n/2
|Σ|
− 1
2 . Hence we set the canonical parameters to
g = −
1
2
µ
T Σ
−1µ −
n
2
log(2π) −
1
2
log |Σ| (2.148)
h =

Σ
−1µ
−BΣ−1µ

(2.149)
K =

Σ
−1 −Σ
−1BT
−BΣ−1 BΣ−1BT

=

I
−B

Σ
−1
￾
I −B

(2.150)
In the special case that x is a scalar, the corresponding result can be found in [Lau92]. In particular
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.4. THE EXPONENTIAL FAMILY
we have Σ
−1 = 1/σ2
, B = b and n = 1, so the above becomes
g =
−µ
2
2σ
2
−
1
2
log(2πσ2
) (2.151)
h =
µ
σ
2

1
−b

(2.152)
K =
1
σ

1 −b
T
−b bbT

. (2.153)
2.3.3.6 Example: Product of Gaussians
As an application of the above results, we can derive the (unnormalized) product of two Gaussians,
as follows (see also [Kaa12, Sec 8.1.8]):
N (x|µ1
, Σ1) × N (x|µ2
, Σ2) ∝ N (x|µ3
, Σ3) (2.154)
where
Σ3 = (Σ
−1
1 + Σ
−1
2
)
−1
(2.155)
µ3 = Σ3(Σ
−1
1 µ1 + Σ
−1
2 µ2
) (2.156)
We see that the posterior precision is a sum of the individual precisions, and the posterior mean
is a precision-weighted combination of the individual means. We can also rewrite the result in the
following way, which only requires one matrix inversion:
Σ3 = Σ1(Σ1 + Σ2)
−1Σ2 (2.157)
µ3 = Σ2(Σ1 + Σ2)
−1µ1 + Σ1(Σ1 + Σ2)
−1µ2
(2.158)
In the scalar case, this becomes
N (x|µ1, σ2
1
)N (x|µ2, σ2
2
) ∝ N 
x|
µ1σ
2
2 + µ2σ
2
1
σ
2
1 + σ
2
2
,
σ
2
1σ
2
2
σ
2
1 + σ
2
2

(2.159)
2.4 The exponential family
In this section, we define the exponential family, which includes many common probability
distributions. The exponential family plays a crucial role in statistics and machine learning, for
various reasons, including the following:
• The exponential family is the unique family of distributions that has maximum entropy (and
hence makes the least set of assumptions) subject to some user-chosen constraints, as discussed in
Section 2.4.7.
• The exponential family is at the core of GLMs, as discussed in Section 15.1.
• The exponential family is at the core of variational inference, as discussed in Chapter 10.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license34
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
• Under certain regularity conditions, the exponential family is the only family of distributions with
finite-sized sufficient statistics, as discussed in Section 2.4.5.
• All members of the exponential family have a conjugate prior [DY79], which simplifies Bayesian
inference of the parameters, as discussed in Section 3.4.
2.4.1 Definition
Consider a family of probability distributions parameterized by η ∈ R
K with fixed support over
X
D ⊆ R
D. We say that the distribution p(x|η) is in the exponential family if its density can be
written in the following way:
p(x|η) ,
1
Z(η)
h(x) exp[η
T
T (x)] = h(x) exp[η
T
T (x) − A(η)] (2.160)
where h(x) is a scaling constant (also known as the base measure, often 1), T (x) ∈ R
K are
the sufficient statistics, η are the natural parameters or canonical parameters, Z(η) is
a normalization constant known as the partition function, and A(η) = log Z(η) is the log
partition function. In Section 2.4.3, we show that A is a convex function over the convex set
Ω , {η ∈ R
K : A(η) < ∞}.
It is convenient if the natural parameters are independent of each other. Formally, we say that an
exponential family is minimal if there is no η ∈ R
K \ {0} such that η
TT (x) = 0. This last condition
can be violated in the case of multinomial distributions, because of the sum to one constraint on
the parameters; however, it is easy to reparameterize the distribution using K − 1 independent
parameters, as we show below.
Equation (2.160) can be generalized by defining η = f(φ), where φ is some other, possibly smaller,
set of parameters. In this case, the distribution has the form
p(x|φ) = h(x) exp[f(φ)
T
T (x) − A(f(φ))] (2.161)
If the mapping from φ to η is nonlinear, we call this a curved exponential family. If η = f(φ) = φ,
the model is said to be in canonical form. If, in addition, T (x) = x, we say this is a natural
exponential family or NEF. In this case, it can be written as
p(x|η) = h(x) exp[η
Tx − A(η)] (2.162)
We define the moment parameters as the mean of the sufficient statistics vector:
m = E [T (x)] (2.163)
We will see some examples below.
2.4.2 Examples
In this section, we consider some common examples of distributions in the exponential family. Each
corresponds to a different way of defining h(x) and T (x) (since Z and hence A are derived from
knowing h and T ).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.4. THE EXPONENTIAL FAMILY
2.4.2.1 Bernoulli distribution
The Bernoulli distribution can be written in exponential family form as follows:
Ber(x|µ) = µ
x
(1 − µ)
1−x
(2.164)
= exp[x log(µ) + (1 − x) log(1 − µ)] (2.165)
= exp[T (x)
Tη] (2.166)
where T (x) = [I(x = 1),I(x = 0)], η = [log(µ), log(1 − µ)], and µ is the mean parameter. However,
this is an over-complete representation since there is a linear dependendence between the features.
We can see this as follows:
1
T
T (x) = I(x = 0) + I(x = 1) = 1 (2.167)
If the representation is overcomplete, η is not uniquely identifiable. It is common to use a minimal
representation, which means there is a unique η associated with the distribution. In this case, we
can just define
Ber(x|µ) = exp 
x log 
µ
1 − µ

+ log(1 − µ)

(2.168)
We can put this into exponential family form by defining
η = log 
µ
1 − µ

(2.169)
T (x) = x (2.170)
A(η) = − log(1 − µ) = log(1 + e
η
) (2.171)
h(x) = 1 (2.172)
We can recover the mean parameter µ from the canonical parameter η using
µ = σ(η) = 1
1 + e−η
(2.173)
which we recognize as the logistic (sigmoid) function.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license36
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.4.2.2 Categorical distribution
We can represent the discrete distribution with K categories as follows (where xk = I(x = k)):
Cat(x|µ) = Y
K
k=1
µ
xk
k = exp "X
K
k=1
xk log µk
#
(2.174)
= exp "K
X−1
k=1
xk log µk +
 
1 −
K
X−1
k=1
xk
!
log(1 −
K
X−1
k=1
µk)
#
(2.175)
= exp "K
X−1
k=1
xk log 
µk
1 −
PK−1
j=1 µj
!
+ log(1 −
K
X−1
k=1
µk)
#
(2.176)
= exp "K
X−1
k=1
xk log 
µk
µK

+ log µK
#
(2.177)
where µK = 1 −
PK−1
k=1 µk. We can write this in exponential family form as follows:
Cat(x|η) = exp(η
T
T (x) − A(η)) (2.178)
η = [log µ1
µK
, . . . , log µK−1
µK
] (2.179)
A(η) = − log(µK) (2.180)
T (x) = [I(x = 1), . . . ,I(x = K − 1)] (2.181)
h(x) = 1 (2.182)
We can recover the mean parameters from the canonical parameters using
µk =
e
ηk
1 + PK−1
j=1 e
ηj
(2.183)
If we define ηK = 0, we can rewrite this as follows:
µk =
e
ηk
PK
j=1 e
ηj
(2.184)
for k = 1 : K. Hence µ = softmax(η), where softmax is the softmax or multinomial logit function in
Equation (15.136). From this, we find
µK = 1 −
PK−1
k=1 e
ηk
1 + PK−1
k=1 e
ηk
=
1
1 + PK−1
k=1 e
ηk
(2.185)
and hence
A(η) = − log(µK) = log X
K
k=1
e
ηk
!
(2.186)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.4. THE EXPONENTIAL FAMILY
2.4.2.3 Univariate Gaussian
The univariate Gaussian is usually written as follows:
N (x|µ, σ2
) = 1
(2πσ2)
1
2
exp[−
1
2σ
2
(x − µ)
2
] (2.187)
=
1
(2π)
1
2
exp[
µ
σ
2
x −
1
2σ
2
x
2 −
1
2σ
2
µ
2 − log σ] (2.188)
We can put this in exponential family form by defining
η =

µ/σ2
−
1
2σ2

(2.189)
T (x) = 
x
x
2

(2.190)
A(η) =
µ
2
2σ
2
+ log σ =
−η
2
1
4η2
−
1
2
log(−2η2) (2.191)
h(x) = 1
√
2π
(2.192)
The moment parameters are
m = [µ, µ2 + σ
2
] (2.193)
2.4.2.4 Univariate Gaussian with fixed variance
If we fix σ
2 = 1, we can write the Gaussian as a natural exponential family, by defining
η = µ (2.194)
T (x) = x (2.195)
A(µ) = µ
2
2σ
2
+ log σ =
µ
2
2
(2.196)
h(x) = 1
√
2π
exp[−
x
2
2
] = N (x|0, 1) (2.197)
Note that this in example, the base measure h(x) is not constant.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license38
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.4.2.5 Multivariate Gaussian
It is common to parameterize the multivariate normal (MVN) in terms of the mean vector µ and the
covariance matrix Σ. The corresponding pdf is given by
N (x|µ, Σ) = 1
(2π)D/2
p
det(Σ)
exp 
−
1
2
x
TΣ
−1x + x
TΣ
−1µ −
1
2
µ
TΣ
−1µ

(2.198)
= c exp 
x
TΣ
−1µ −
1
2
x
TΣ
−1x

(2.199)
c ,
exp(−
1
2µ
TΣ
−1µ)
(2π)D/2
p
det(Σ)
(2.200)
However, we can also represent the Gaussian using canonical parameters or natural parame￾ters, also called the information form:
Λ = Σ
−1
(2.201)
ξ = Σ
−1µ (2.202)
Nc(x|ξ, Λ) , c
′
exp 
x
T
ξ −
1
2
x
TΛx

(2.203)
c
′ =
exp(−
1
2
ξ
TΛ
−1
ξ)
(2π)D/2
q
det(Λ
−1
)
(2.204)
where we use the notation Nc() to distinguish it from the standard parameterization N (). Here Λ is
called the precision matrix and ξ is the precision-weighted mean vector.
We can convert this to exponential family notation as follows:
Nc(x|ξ, Λ) = (2π)
−D/2
| {z }
h(x)
exp 
1
2
log |Λ| − 1
2
ξ
TΛ
−1
ξ

| {z }
g(η)
exp 
−
1
2
x
TΛx + x
T
ξ

(2.205)
= h(x)g(η) exp 
−
1
2
x
TΛx + x
T
ξ

(2.206)
= h(x)g(η) exp

−
1
2
(
X
ij
xixjΛij ) + x
T
ξ

 (2.207)
= h(x)g(η) exp 
−
1
2
vec(Λ)
T
vec(xxT
) + x
T
ξ

(2.208)
= h(x) exp 
η
T
T (x) − A(η)

(2.209)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.4. THE EXPONENTIAL FAMILY
where
h(x) = (2π)
−D/2
(2.210)
η = [ξ; −
1
2
vec(Λ)] = [Σ
−1µ; −
1
2
vec(Σ
−1
)] (2.211)
T (x) = [x; vec(xxT
)] (2.212)
A(η) = − log g(η) = −
1
2
log |Λ| +
1
2
ξ
TΛ
−1
ξ (2.213)
From this, we see that the mean (moment) parameters are given by
m = E [T (x)] = [µ; µµT + Σ] (2.214)
(Note that the above is not a minimal representation, since Λ is a symmetric matrix. We can convert
to minimal form by working with the upper or lower half of each matrix.)
2.4.2.6 Non-examples
Not all distributions of interest belong to the exponential family. For example, the Student distribution
(Section 2.2.2.3) does not belong, since its pdf (Equation (2.30)) does not have the required form.
(However, there is a generalization, known as the φ-exponential family [Nau04; Tsa88] which does
include the Student distribution.)
As a more subtle example, consider the uniform distribution, Y ∼ Unif(θ1, θ2). The pdf has the
form
p(y|θ) = 1
θ2 − θ1
I(θ1 ≤ y ≤ θ2) (2.215)
It is tempting to think this is in the exponential family, with h(y) = 1, T (y) = 0, and Z(θ) = θ2 − θ1.
However, the support of this distribution (i.e., the set of values Y = {y : p(y) > 0}) depends on the
parameters θ, which violates an assumption of the exponential family.
2.4.3 Log partition function is cumulant generating function
The first and second cumulants of a distribution are its mean E [X] and variance V [X], whereas the
first and second moments are E [X] and E

X2

. We can also compute higher order cumulants (and
moments). An important property of the exponential family is that derivatives of the log partition
function can be used to generate all the cumulants of the sufficient statistics. In particular, the
first and second cumulants are given by
∇ηA(η) = E [T (x)] (2.216)
∇2
ηA(η) = Cov [T (x)] (2.217)
We prove this result below.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license40
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.4.3.1 Derivation of the mean
For simplicity, we focus on the 1d case. For the first derivative we have
dA
dη =
d
dη 
log Z
exp(ηT (x))h(x)dx
(2.218)
=
d
dη
R
exp(ηT (x))h(x)dx
R
exp(ηT (x))h(x)dx
(2.219)
=
R
T (x) exp(ηT (x))h(x)dx
exp(A(η)) (2.220)
=
Z
T (x) exp(ηT (x) − A(η))h(x)dx (2.221)
=
Z
T (x)p(x)dx = E [T (x)] (2.222)
For example, consider the Bernoulli distribution. We have A(η) = log(1 + e
η
), so the mean is given
by
dA
dη =
e
η
1 + e
η
=
1
1 + e−η
= σ(η) = µ (2.223)
2.4.3.2 Derivation of the variance
For simplicity, we focus on the 1d case. For the second derivative we have
d
2A
dη2
=
d
dη Z
T (x) exp(ηT (x) − A(η))h(x)dx (2.224)
=
Z
T (x) exp (ηT (x) − A(η)) h(x)(T (x) − A
′
(η))dx (2.225)
=
Z
T (x)p(x)(T (x) − A
′
(η))dx (2.226)
=
Z
T
2
(x)p(x)dx − A
′
(η)
Z
T (x)p(x)dx (2.227)
= E

T
2
(X)

− E [T (x)]2 = V [T (x)] (2.228)
where we used the fact that A′
(η) = dA
dη = E [T (x)]. For example, for the Bernoulli distribution we
have
d
2A
dη2
=
d
dη (1 + e
−η
)
−1 = (1 + e
−η
)
−2
e
−η
(2.229)
=
e
−η
1 + e−η
1
1 + e−η
=
1
e
η + 1
1
1 + e−η
= (1 − µ)µ (2.230)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.4. THE EXPONENTIAL FAMILY
2.4.3.3 Connection with the Fisher information matrix
In Section 3.3.4, we show that, under some regularity conditions, the Fisher information matrix
is given by
F(η) , Ep(x|η)

∇ log p(x|η)∇ log p(x|η)
T

= −Ep(x|η)

∇2
η
log p(x|η)

(2.231)
Hence for an exponential family model we have
F(η) = −Ep(x|η)

∇2
η
(η
T
T (x) − A(η))
= ∇2
ηA(η) = Cov [T (x)] (2.232)
Thus the Hessian of the log partition function is the same as the FIM, which is the same as the
covariance of the sufficient statistics. See Section 3.3.4.6 for details.
2.4.4 Canonical (natural) vs mean (moment) parameters
Let Ω be the set of normalizable natural parameters:
Ω , {η ∈ R
K : Z(η) < ∞} (2.233)
We say that an exponential family is regular if Ω is an open set. It can be shown that Ω is a convex
set, and A(η) is a convex function defined over this set.
In Section 2.4.3, we prove that the derivative of the log partition function is equal to the mean of
the sufficient statistics, i.e.,
m = E [T (x)] = ∇ηA(η) (2.234)
The set of valid moment parameters is given by
M = {m ∈ R
K : Ep [T (x)] = m} (2.235)
for some distribution p.
We have seen that we can convert from the natural parameters to the moment parameters using
m = ∇ηA(η) (2.236)
If the family is minimal, one can show that
η = ∇mA
∗
(m) (2.237)
where A∗
(m) is the convex conjugate of A:
A
∗
(m) , sup
η∈Ω
µ
Tη − A(η) (2.238)
Thus the pair of operators (∇A, ∇A∗
) lets us go back and forth between the natural parameters
η ∈ Ω and the mean parameters m ∈ M.
For future reference, note that the Bregman divergences (Section 5.1.10) associated with A and A∗
are as follows:
BA(λ1||λ2) = A(λ1) − A(λ2) − (λ1 − λ2)
T∇λA(λ2) (2.239)
BA∗ (µ1
||µ2
) = A(µ1
) − A(µ2
) − (µ1 − µ2
)
T∇µA(µ2
) (2.240)
(2.241)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license42
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.4.5 MLE for the exponential family
The likelihood of an exponential family model has the form
p(D|η) = "Y
N
n=1
h(xn)
#
exp 
η
T
[
X
N
n=1
T (xn)] − NA(η)
!
∝ exp 
η
T
T (D) − NA(η)

(2.242)
where T (D) are the sufficient statistics:
T (D) = [X
N
n=1
T1(xn), . . . ,X
N
n=1
TK(xn)] (2.243)
For example, for the Bernoulli model we have T (D) = [P
n
I(xn = 1)], and for the univariate
Gaussian, we have T (D) = [P
n
xn,
P
n
x
2
n
].
The Pitman-Koopman-Darmois theorem states that, under certain regularity conditions, the
exponential family is the only family of distributions with finite sufficient statistics. (Here, finite
means a size independent of the size of the dataset.) In other words, for an exponential family with
natural parameters η, we have
p(D|η) = p(T (D)|η) (2.244)
We now show how to use this result to compute the MLE. The log likelihood is given by
log p(D|η) = η
T
T (D) − NA(η) + const (2.245)
Since −A(η) is concave in η, and η
TT (D) is linear in η, we see that the log likelihood is concave, and
hence has a unique global maximum. To derive this maximum, we use the fact (shown in Section 2.4.3)
that the derivative of the log partition function yields the expected value of the sufficient statistic
vector:
∇η log p(D|η) = ∇ηη
T
T (D) − N∇ηA(η) = T (D) − NE [T (x)] (2.246)
For a single data case, this becomes
∇η log p(x|η) = T (x) − E [T (x)] (2.247)
Setting the gradient in Equation (2.246) to zero, we see that at the MLE, the empirical average of
the sufficient statistics must equal the model’s theoretical expected sufficient statistics, i.e., ηˆ must
satisfy
E [T (x)] = 1
N
X
N
n=1
T (xn) (2.248)
This is called moment matching. For example, in the Bernoulli distribution, we have T (x) =
I(X = 1), so the MLE satisfies
E [T (x)] = p(X = 1) = µ =
1
N
X
N
n=1
I(xn = 1) (2.249)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.4. THE EXPONENTIAL FAMILY
2.4.6 Exponential dispersion family
In this section, we consider a slight extension of the natural exponential family known as the
exponential dispersion family. This will be useful when we discuss GLMs in Section 15.1. For a
scalar variable, this has the form
p(x|η, σ2
) = h(x, σ2
) exp 
ηx − A(η)
σ
2

(2.250)
Here σ
2
is called the dispersion parameter. For fixed σ
2
, this is a natural exponential family.
2.4.7 Maximum entropy derivation of the exponential family
Suppose we want to find a distribution p(x) to describe some data, where all we know are the
expected values (Fk) of certain features or functions fk(x):
Z
dx p(x)fk(x) = Fk (2.251)
For example, f1 might compute x, f2 might compute x
2
, making F1 the empirical mean and F2 the
empirical second moment. Our prior belief in the distribution is q(x).
To formalize what we mean by “least number of assumptions”, we will search for the distribution
that is as close as possible to our prior q(x), in the sense of KL divergence (Section 5.1), while
satisfying our constraints.
If we use a uniform prior, q(x) ∝ 1, minimizing the KL divergence is equivalent to maximizing the
entropy (Section 5.2). The result is called a maximum entropy model.
To minimize KL subject to the constraints in Equation (2.251), and the constraint that p(x) ≥ 0
and P
x
p(x) = 1, we need to use Lagrange multipliers. The Lagrangian is given by
J(p, λ) = −
X
x
p(x) log p(x)
q(x)
+ λ0
 
1 −
X
x
p(x)
!
+
X
k
λk
 
Fk −
X
x
p(x)fk(x)
!
(2.252)
We can use the calculus of variations to take derivatives wrt the function p, but we will adopt a
simpler approach and treat p as a fixed length vector (since we are assuming that x is discrete).
Then we have
∂J
∂pc
= −1 − log p(x = c)
q(x = c)
− λ0 −
X
k
λkfk(x = c) (2.253)
Setting ∂J
∂pc
= 0 for each c yields
p(x) = q(x)
Z
exp 
−
X
k
λkfk(x)
!
(2.254)
where we have defined Z , e
1+λ0
. Using the sum-to-one constraint, we have
1 = X
x
p(x) = 1
Z
X
x
q(x) exp
 
−
X
k
λkfk(x)
!
(2.255)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license44
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 2.11: Illustration of injective and surjective functions.
Hence the normalization constant is given by
Z =
X
x
q(x) exp 
−
X
k
λkfk(x)
!
(2.256)
This has exactly the form of the exponential family, where f(x) is the vector of sufficient statistics,
−λ are the natural parameters, and q(x) is our base measure.
For example, if the features are f1(x) = x and f2(x) = x
2
, and we want to match the first and
second moments, we get the Gaussian disribution.
2.5 Transformations of random variables
Suppose x ∼ px(x) is some random variable, and y = f(x) is some deterministic transformation of
it. In this section, we discuss how to compute py(y).
2.5.1 Invertible transformations (bijections)
Let f be a bijection that maps R
n to R
n. (A bijection is a function that is injective, or one-to-one,
and surjective, as illustrated in Figure 2.11; this means that the function has a well-defined inverse.)
Suppose we want to compute the pdf of y = f(x). The change of variables formula tells us that
py(y) = px
￾
f
−1
(y)
 
 det 
Jf−1 (y)
 
 (2.257)
where Jf−1 (y) is the Jacobian of the inverse mapping f
−1
evaluated at y, and | det J| is the absolute
value of the determinant of J. In other words,
Jf−1 (y) =


∂x1
∂y1
· · ·
∂x1
∂yn
.
.
.
∂xn
∂y1
· · ·
∂xn
∂yn

 (2.258)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.5. TRANSFORMATIONS OF RANDOM VARIABLES
0 3 6 9 12
0.00
0.25
0.50
0.75
1.00
pX
pY
g
Figure 2.12: Example of the transformation of a density under a nonlinear transform. Note how the mode of
the transformed distribution is not the transform of the original mode. Adapted from Exercise 1.4 of [Bis06].
Generated by bayes_change_of_var.ipynb.
If the Jacobian matrix is triangular, the determinant reduces to a product of the terms on the main
diagonal:
det(J) = Yn
i=1
∂xi
∂yi
(2.259)
2.5.2 Monte Carlo approximation
Sometime it is difficult to compute the Jacobian. In this case, we can make a Monte Carlo
approximation, by drawing S samples x
s ∼ p(x), computing y
s = f(x
s
), and then constructing the
empirical pdf
pD(y) = 1
S
X
S
s=1
δ(y − y
s
) (2.260)
For example, let x ∼ N (6, 1) and y = f(x), where f(x) = 1
1+exp(−x+5) . We can approximate p(y)
using Monte Carlo, as shown in Figure 2.12.
2.5.3 Probability integral transform
Suppose that X is a random variable with cdf PX. Let Y (X) = PX(X) be a transformation of
X. We now show that Y has a uniform distribution, a result known as the probability integral
transform (PIT):
PY (y) = Pr(Y ≤ y) = Pr(PX(X) ≤ y) (2.261)
= Pr(X ≤ P
−1
X (y)) = PX(P
−1
X (y)) = y (2.262)
For example, in Figure 2.13, we show various distributions with pdf’s pX on the left column. We
sample from these, to get xn ∼ px. Next we compute the empirical cdf of Y = PX(X), by computing
yn = PX(xn) and then sorting the values; the results, shown in the middle column, show that this
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license46
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 10 20
x1
0
2
4
pdf(X)
0.0 0.5 1.0
y1
0.0
0.5
1.0
cdf(Y)
0.0 0.5 1.0
y1
0.0
0.5
1.0
pdf(Y)
0.0 0.5 1.0
x2
2
4
0.0 0.5 1.0
y2
0.0
0.5
1.0
0.0 0.5 1.0
y2
0.0
0.5
1.0
−2.5 0.0 2.5
x3
0.0
0.2
0.4
0.0 0.5 1.0
y3
0.0
0.5
1.0
0.0 0.5 1.0
y3
0.0
0.5
1.0
Figure 2.13: Illustration of the probability integral transform. Left column: 3 different pdf ’s for p(X) from
which we sample xn ∼ p(x). Middle column: empirical cdf of yn = PX(xn). Right column: empirical
pdf of p(yn) using a kernel density estimate. Adapted from Figure 11.17 of [MKL11]. Generated by
ecdf_sample.ipynb.
distribution is uniform. We can also approximate the pdf of Y by using kernel density estimation;
this is shown in the right column, and we see that it is (approximately) flat.
We can use the PIT to test if a set of samples come from a given distribution using the Kol￾mogorov–Smirnov test. To do this, we plot the empirical cdf of the samples and the theoretical
cdf of the distribution, and compute the maximum distance between these two curves, as illustrated
in Figure 2.14. Formally, the KS statistic is defined as
Dn = max
x
|Pn(x) − P(x)| (2.263)
where n is the sample size, Pn is the empirical cdf, and P is the theoretical cdf. The value Dn should
approach 0 (as n → ∞) if the samples are drawn from P.
Another application of the PIT is to generate samples from a distribution: if we have a way to
sample from a uniform distribution, un ∼ Unif(0, 1), we can convert this to samples from any other
distribution with cdf PX by setting xn = P
−1
X (un).
2.6 Markov chains
Suppose that xt captures all the relevant information about the state of the system. This means it is
a sufficient statistic for predicting the future given the past, i.e.,
p(xt+τ |xt, x1:t−1) = p(xt+τ |xt) (2.264)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.6. MARKOV CHAINS
Figure 2.14: Illustration of the Kolmogorov–Smirnov statistic. The red line is a model cdf, the blue line
is an empirical cdf, and the black arrow is the K–S statistic. From https: // en. wikipedia. org/ wiki/
Kolmogorov_ Smirnov_ test . Used with kind permission of Wikipedia author Bscan.
for any τ ≥ 0. This is called the Markov assumption. In this case, we can write the joint
distribution for any finite length sequence as follows:
p(x1:T ) = p(x1)p(x2|x1)p(x3|x2)p(x4|x3). . . = p(x1)
Y
T
t=2
p(xt|xt−1) (2.265)
This is called a Markov chain or Markov model. Below we cover some of the basics of this topic;
more details on the theory can be found in [Kun20].
2.6.1 Parameterization
In this section, we discuss how to represent a Markov model parametrically.
2.6.1.1 Markov transition kernels
The conditional distribution p(xt|xt−1) is called the transition function, transition kernel, or
Markov kernel. This is just a conditional distribution over the states at time t given the state at
time t − 1, and hence it satisfies the conditions p(xt|xt−1) ≥ 0 and R
x∈X dx p(xt = x|xt−1) = 1.
If we assume the transition function p(xt|x1:t−1) is independent of time, then the model is said
to be homogeneous, stationary, or time-invariant. This is an example of parameter tying,
since the same parameter is shared by multiple variables. This assumption allows us to model an
arbitrary number of variables using a fixed number of parameters. We will make the time-invariant
assumption throughout the rest of this section.
2.6.1.2 Markov transition matrices
In this section, we assume that the variables are discrete, so Xt ∈ {1, . . . , K}. This is called a
finite-state Markov chain. In this case, the conditional distribution p(Xt|Xt−1) can be written
as a K × K matrix A, known as the transition matrix, where Aij = p(Xt = j|Xt−1 = i) is the
probability of going from state i to state j. Each row of the matrix sums to one, P
j Aij = 1, so this
is called a stochastic matrix.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license48
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
1 2
α
β
1 − α 1 − β
(a)
1 2 3
A12 A23
A11 A22 A33
(b)
Figure 2.15: State transition diagrams for some simple Markov chains. Left: a 2-state chain. Right: a 3-state
left-to-right chain.
A stationary, finite-state Markov chain is equivalent to a stochastic automaton. It is common
to visualize such automata by drawing a directed graph, where nodes represent states and arrows
represent legal transitions, i.e., non-zero elements of A. This is known as a state transition
diagram. The weights associated with the arcs are the probabilities. For example, the following
2-state chain
A =

1 − α α
β 1 − β

(2.266)
is illustrated in Figure 2.15(a). The following 3-state chain
A =


A11 A12 0
0 A22 A23
0 0 1

 (2.267)
is illustrated in Figure 2.15(b). This is called a left-to-right transition matrix.
The Aij element of the transition matrix specifies the probability of getting from i to j in one step.
The n-step transition matrix A(n) is defined as
Aij (n) , p(Xt+n = j|Xt = i) (2.268)
which is the probability of getting from i to j in exactly n steps. Obviously A(1) = A. The
Chapman-Kolmogorov equations state that
Aij (m + n) = X
K
k=1
Aik(m)Akj (n) (2.269)
In words, the probability of getting from i to j in m + n steps is just the probability of getting from
i to k in m steps, and then from k to j in n steps, summed up over all k. We can write the above as
a matrix multiplication
A(m + n) = A(m)A(n) (2.270)
Hence
A(n) = A A(n − 1) = A A A(n − 2) = · · · = An
(2.271)
Thus we can simulate multiple steps of a Markov chain by “powering up” the transition matrix.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.6. MARKOV CHAINS
christians first inhabit wherein thou hast forgive if a man childless and of laying of core these
are the heavens shall reel to and fro to seek god they set their horses and children of israel
Figure 2.16: Example output from an 10-gram character-level Markov model trained on the King James Bible.
The prefix “christians” is given to the model. Generated by ngram_character_demo.ipynb.
2.6.1.3 Higher-order Markov models
The first-order Markov assumption is rather strong. Fortunately, we can easily generalize first-order
models to depend on the last n observations, thus creating a model of order (memory length) n:
p(x1:T ) = p(x1:n)
Y
T
t=n+1
p(xt|xt−n:t−1) (2.272)
This is called a Markov model of order n. If n = 1, this is called a bigram model, since we
need to represent pairs of characters, p(xt|xt−1). If n = 2, this is called a trigram model, since we
need to represent triples of characters, p(xt|xt−1, xt−2). In general, this is called an n-gram model.
Note, however, we can always convert a higher order Markov model to a first order one by defining
an augmented state space that contains the past n observations. For example, if n = 2, we define
x˜t = (xt−1, xt) and use
p(x˜1:T ) = p(x˜2)
Y
T
t=3
p(x˜t|x˜t−1) = p(x1, x2)
Y
T
t=3
p(xt|xt−1, xt−2) (2.273)
Therefore we will just focus on first-order models throughout the rest of this section.
2.6.2 Application: language modeling
One important application of Markov models is to create language models (LM), which are models
which can generate (or score) a sequence of words. When we use a finite-state Markov model with
a memory of length m = n − 1, it is called an n-gram model. For example, if m = 1, we get a
unigram model (no dependence on previous words); if m = 2, we get a bigram model (depends
on previous word); if m = 3, we get a trigram model (depends on previous two words); etc. See
Figure 2.16 for some generated text.
These days, most LMs are built using recurrent neural nets (see Section 16.3.4), which have
unbounded memory. However, simple n-gram models can still do quite well when trained with enough
data [Che17].
Language models have various applications, such as priors for spelling correction (see Section 29.3.3)
or automatic speech recognition. In addition, conditional language models can be used to generate
sequences given inputs, such as mapping one language to another, or an image to a sequence, etc.
2.6.3 Parameter estimation
In this section, we discuss how to estimate the parameters of a Markov model.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license50
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
e t a i n o s h r d l mu c f w g y p b v k x z j q
e
t
a
i
n
o
s
h
r
d
l
m
u
c
f
w
g
y
p
b
v
k
x
z
j
q
(a)
e t a i n o s h r d l mu c f w g y p b v k x z j q
e
t
a
i
n
o
s
h
r
d
l
m
u
c
f
w
g
y
p
b
v
k
x
z
j
q
(b)
Figure 2.17: (a) Hinton diagram showing character bigram counts as estimated from H. G. Wells’s book
The Time Machine. Characters are sorted in decreasing unigram frequency; the first one is a space character.
The most frequent bigram is ’e-’, where - represents space. (b) Same as (a) but each row is normalized across
the columns. Generated by bigram_hinton_diagram.ipynb.
2.6.3.1 Maximum likelihood estimation
The probability of any particular sequence of length T is given by
p(x1:T |θ) = π(x1)A(x1, x2). . . A(xT −1, xT ) (2.274)
=
Y
K
j=1
(πj )
I(x1=j) Y
T
t=2
Y
K
j=1
Y
K
k=1
(Ajk)
I(xt=k,xt−1=j)
(2.275)
Hence the log-likelihood of a set of sequences D = (x1, . . . , xN ), where xi = (xi1, . . . , xi,Ti
) is a
sequence of length Ti
, is given by
log p(D|θ) = X
N
i=1
log p(xi
|θ) = X
j
N
1
j
log πj +
X
j
X
k
Njk log Ajk (2.276)
where we define the following counts:
N
1
j ,
X
N
i=1
I(xi1 = j), Njk ,
X
N
i=1
T
Xi−1
t=1
I(xi,t = j, xi,t+1 = k), Nj =
X
k
Njk (2.277)
By adding Lagrange multipliers to enforce the sum to one constraints, one can show (see e.g., [Mur22,
Sec 4.2.4]) that the MLE is given by the normalized counts:
πˆj =
N1
P
j
j
′ N1
j
′
, Aˆ
jk =
Njk
Nj
(2.278)
We often replace N1
j
, which is how often symbol j is seen at the start of a sequence, by Nj , which is
how often symbol j is seen anywhere in a sequence. This lets us estimate parameters from a single
sequence.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.6. MARKOV CHAINS
The counts Nj are known as unigram statistics, and Njk are known as bigram statistics. For
example, Figure 2.17 shows some 2-gram counts for the characters {a, . . . , z, −} (where - represents
space) as estimated from H. G. Wells’s book The Time Machine.
2.6.3.2 Sparse data problem
When we try to fit n-gram models for large n, we quickly encounter problems with overfitting due
to data sparsity. To see that, note that many of the estimated counts Njk will be 0, since now j
indexes over discrete contexts of size Kn−1
, which will become increasingly rare. Even for bigram
models (n = 2), problems can arise if K is large. For example, if we have K ∼ 50, 000 words in our
vocabulary, then a bi-gram model will have about 2.5 billion free parameters, corresponding to all
possible word pairs. It is very unlikely we will see all of these in our training data. However, we do
not want to predict that a particular word string is totally impossible just because we happen not to
have seen it in our training text — that would be a severe form of overfitting.9
A “brute force” solution to this problem is to gather lots and lots of data. For example, Google
has fit n-gram models (for n = 1 : 5) based on one trillion words extracted from the web. Their data,
which is over 100GB when uncompressed, is publically available.10 Although such an approach can
be surprisingly successful (as discussed in [HNP09]), it is rather unsatisfying, since humans are able
to learn language from much less data (see e.g., [TX00]).
2.6.3.3 MAP estimation
A simple solution to the sparse data problem is to use MAP estimation with a uniform Dirichlet
prior, Aj: ∼ Dir(α1). In this case, the MAP estimate becomes
Aˆ
jk =
Njk + α
Nj + Kα
(2.279)
If α = 1, this is called add-one smoothing.
The main problem with add-one smoothing is that it assumes that all n-grams are equally likely,
which is not very realistic. We discuss a more sophisticated approach, based on hierarchical Bayes,
in Section 3.7.3.
2.6.4 Stationary distribution of a Markov chain
Suppose we continually draw consecutive samples from a Markov chain. In the case of a finite state
space, we can think of this as “hopping” from one state to another. We will tend to spend more
time in some states than others, depending on the transition graph. The long term distribution over
states is known as the stationary distribution of the chain. In this section, we discuss some of the
relevant theory. In Chapter 12, we discuss an important application, known as MCMC, which is a way
to generate samples from hard-to-normalize probability distributions. In Supplementary Section 2.2
9. A famous example of an improbable, but syntactically valid, English word string, due to Noam Chomsky [Cho57],
is “colourless green ideas sleep furiously”. We would not want our model to predict that this string is impossible. Even
ungrammatical constructs should be allowed by our model with a certain probability, since people frequently violate
grammatical rules, especially in spoken language.
10. See http://googleresearch.blogspot.com/2006/08/all-our-n-gram-are-belong-to-you.html for details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license52
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
1 2 3
1.0 0.5
0.5
1.0
(a)
1 2 3 4
0.9
0.9
0.5 0.5
0.1 0.1 1.0
(b)
Figure 2.18: Some Markov chains. (a) A 3-state aperiodic chain. (b) A reducible 4-state chain.
we consider Google’s PageRank algorithm for ranking web pages, which also leverages the concept of
stationary distributions.
2.6.4.1 What is a stationary distribution?
Let Aij = p(Xt = j|Xt−1 = i) be the one-step transition matrix, and let πt(j) = p(Xt = j) be the
probability of being in state j at time t.
If we have an initial distribution over states of π0, then at time 1 we have
π1(j) = X
i
π0(i)Aij (2.280)
or, in matrix notation, π1 = π0A, where we have followed the standard convention of assuming π is
a row vector, so we post-multiply by the transition matrix.
Now imagine iterating these equations. If we ever reach a stage where π = πA, then we say we
have reached the stationary distribution (also called the invariant distribution or equilibrium
distribution). Once we enter the stationary distribution, we will never leave.
For example, consider the chain in Figure 2.18(a). To find its stationary distribution, we write
￾
π1 π2 π3

=
￾
π1 π2 π3



1 − A12 − A13 A12 A13
A21 1 − A21 − A23 A23
A31 A32 1 − A31 − A32

 (2.281)
Hence π1(A12 + A13) = π2A21 + π3A31. In general, we have
πi
X
j6=i
Aij =
X
j6=i
πjAji (2.282)
In other words, the probability of being in state i times the net flow out of state i must equal the
probability of being in each other state j times the net flow from that state into i. These are called
the
P
global balance equations. We can then solve these equations, subject to the constraint that
j
πj = 1, to find the stationary distribution, as we discuss below.
2.6.4.2 Computing the stationary distribution
To find the stationary distribution, we can just solve the eigenvector equation ATv = v, and then
to set π = v
T, where v is an eigenvector with eigenvalue 1. (We can be sure such an eigenvector
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 201
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.6. MARKOV CHAINS
exists, since A is a row-stochastic matrix, so A1 = 1; also recall that the eigenvalues of A and AT
are the same.) Of course, since eigenvectors are unique only up to constants of proportionality, we
must normalize v at the end to ensure it sums to one.
Note, however, that the eigenvectors are only guaranteed to be real-valued if all entries in the
matrix are strictly positive, Aij > 0 (and hence Aij < 1, due to the sum-to-one constraint). A more
general approach, which can handle chains where some transition probabilities are 0 or 1 (such as
Figure 2.18(a)), is as follows. We have K constraints from π(I − A) = 0K×1 and 1 constraint from
π1K×1 = 1. Hence we have to solve πM = r, where M = [I − A, 1] is a K × (K + 1) matrix, and
r = [0, 0, . . . , 0, 1] is a 1 × (K + 1) vector. However, this is overconstrained, so we will drop the last
column of I − A in our definition of M, and drop the last 0 from r. For example, for a 3 state chain
we have to solve this linear system:
￾
π1 π2 π3



1 − A11 −A12 1
−A21 1 − A22 1
−A31 −A32 1

 =
￾
0 0 1
(2.283)
For the chain in Figure 2.18(a) we find π = [0.4, 0.4, 0.2]. We can easily verify this is correct, since
π = πA.
Unfortunately, not all chains have a stationary distribution, as we explain below.
2.6.4.3 When does a stationary distribution exist?
Consider the 4-state chain in Figure 2.18(b). If we start in state 4, we will stay there forever, since
4 is an absorbing state. Thus π = (0, 0, 0, 1) is one possible stationary distribution. However,
if we start in 1 or 2, we will oscillate between those two states forever. So π = (0.5, 0.5, 0, 0) is
another possible stationary distribution. If we start in state 3, we could end up in either of the above
stationary distributions with equal probability. The corresponding transition graph has two disjoint
connected components.
We see from this example that a necessary condition to have a unique stationary distribution is
that the state transition diagram be a singly connected component, i.e., we can get from any state to
any other state. Such chains are called irreducible.
Now consider the 2-state chain in Figure 2.15(a). This is irreducible provided α, β > 0. Suppose
α = β = 0.9. It is clear by symmetry that this chain will spend 50% of its time in each state. Thus
π = (0.5, 0.5). But now suppose α = β = 1. In this case, the chain will oscillate between the two
states, but the long-term distribution on states depends on where you start from. If we start in state
1, then on every odd time step (1,3,5,...) we will be in state 1; but if we start in state 2, then on
every odd time step we will be in state 2.
This example motivates the following definition. Let us say that a chain has a limiting distri￾bution if πj = limn→∞ An
ij exists and is independent of the starting state i, for all j. If this holds,
then the long-run distribution over states will be independent of the starting state:
p(Xt = j) = X
i
p(X0 = i)Aij (t) → πj as t → ∞ (2.284)
Let us now characterize when a limiting distribution exists. Define the period of state i to be
d(i) , gcd{t : Aii(t) > 0}, where gcd stands for greatest common divisor, i.e., the largest integer
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licen54
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
that divides all the members of the set. For example, in Figure 2.18(a), we have d(1) = d(2) =
gcd(2, 3, 4, 6, ...) = 1 and d(3) = gcd(3, 5, 6, ...) = 1. We say a state i is aperiodic if d(i) = 1. (A
sufficient condition to ensure this is if state i has a self-loop, but this is not a necessary condition.)
We say a chain is aperiodic if all its states are aperiodic. One can show the following important
result:
Theorem 2.6.1. Every irreducible (singly connected), aperiodic finite state Markov chain has a
limiting distribution, which is equal to π, its unique stationary distribution.
A special case of this result says that every regular finite state chain has a unique stationary
distribution, where a regular chain is one whose transition matrix satisfies An
ij > 0 for some integer
n and all i, j, i.e., it is possible to get from any state to any other state in n steps. Consequently, after
n steps, the chain could be in any state, no matter where it started. One can show that sufficient
conditions to ensure regularity are that the chain be irreducible (singly connected) and that every
state have a self-transition.
To handle the case of Markov chains whose state space is not finite (e.g, the countable set of all
integers, or all the uncountable set of all reals), we need to generalize some of the earlier definitions.
Since the details are rather technical, we just briefly state the main results without proof. See e.g.,
[GS92] for details.
For a stationary distribution to exist, we require irreducibility (singly connected) and aperiodicity,
as before. But we also require that each state is recurrent, which means that you will return to
that state with probability 1. As a simple example of a non-recurrent state (i.e., a transient state),
consider Figure 2.18(b): state 3 is transient because one immediately leaves it and either spins around
state 4 forever, or oscillates between states 1 and 2 forever. There is no way to return to state 3.
It is clear that any finite-state irreducible chain is recurrent, since you can always get back to where
you started from. But now consider an example with an infinite state space. Suppose we perform
a random walk on the integers, X = {. . . , −2, −1, 0, 1, 2, . . .}. Let Ai,i+1 = p be the probability of
moving right, and Ai,i−1 = 1 − p be the probability of moving left. Suppose we start at X1 = 0. If
p > 0.5, we will shoot off to +∞; we are not guaranteed to return. Similarly, if p < 0.5, we will shoot
off to −∞. So in both cases, the chain is not recurrent, even though it is irreducible. If p = 0.5, we
can return to the initial state with probability 1, so the chain is recurrent. However, the distribution
keeps spreading out over a larger and larger set of the integers, so the expected time to return is
infinite. This prevents the chain from having a stationary distribution.
More formally, we define a state to be non-null recurrent if the expected time to return to this
state is finite. We say that a state is ergodic if it is aperiodic, recurrent, and non-null. We say that
a chain is ergodic if all its states are ergodic. With these definitions, we can now state our main
theorem:
Theorem 2.6.2. Every irreducible, ergodic Markov chain has a limiting distribution, which is equal
to π, its unique stationary distribution.
This generalizes Theorem 2.6.1, since for irreducible finite-state chains, all states are recurrent and
non-null.
2.6.4.4 Detailed balance
Establishing ergodicity can be difficult. We now give an alternative condition that is easier to verify.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.7. DIVERGENCE MEASURES BETWEEN PROBABILITY DISTRIBUTIONS
We say that a Markov chain A is time reversible if there exists a distribution π such that
πiAij = πjAji (2.285)
These are called the detailed balance equations. This says that the flow from i to j must equal
the flow from j to i, weighted by the appropriate source probabilities.
We have the following important result.
Theorem 2.6.3. If a Markov chain with transition matrix A is regular and satisfies the detailed
balance equations wrt distribution π, then π is a stationary distribution of the chain.
Proof. To see this, note that
X
i
πiAij =
X
i
πjAji = πj
X
i
Aji = πj (2.286)
and hence π = Aπ.
Note that this condition is sufficient but not necessary (see Figure 2.18(a) for an example of a
chain with a stationary distribution which does not satisfy detailed balance).
2.7 Divergence measures between probability distributions
In this section, we discuss various ways to compare two probability distributions, P and Q, defined
on the same space. For example, suppose the distributions are defined in terms of samples, X =
{x1, . . . , xN } ∼ P and X
′ = {x˜1, . . . , x˜M} ∼ Q. Determining if the samples come from the same
distribution is known as a two-sample test (see Figure 2.19 for an illustration). This can be
computed by defining some suitable divergence metric D(P, Q) and comparing it to a threshold.
(We use the term “divergence” rather than distance since we will not require D to be symmetric.)
Alternatively, suppose P is an empirical distribution of data, and Q is the distribution induced
by a model. We can check how well the model approximates the data by comparing D(P, Q) to a
threshold; this is called a goodness-of-fit test.
There are two main ways to compute the divergence between a pair of distributions: in terms of
their difference, P − Q (see e.g., [Sug+13]) or in terms of their ratio, P/Q (see e.g., [SSK12]). We
briefly discuss both of these below. (Our presentation is based, in part, on [GSJ19].)
2.7.1 f-divergence
In this section, we compare distributions in terms of their density ratio r(x) = p(x)/q(x). In
particular, consider the f-divergence [Mor63; AS66; Csi67; LV06; CS04], which is defined as follows:
Df (p||q) = Z
q(x)f

p(x)
q(x)

dx (2.287)
where f : R+ → R is a convex function satisfying f(1) = 0. From Jensen’s inequality (Section 5.1.2.2),
it follows that Df (p||q) ≥ 0, and obviously Df (p||p) = 0, so Df is a valid divergence. Below we
discuss some important special cases of f-divergences. (Note that f-divergences are also called
φ-divergences.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license56
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 2.19: Samples from two distributions which are (a) different and (b) similar. From a figure from
[GSJ19]. Used with kind permission of Arthur Gretton.
p
q
(a) α = −∞
p
q
(b) α = 0
p
q
(c) α = 0.5
p
q
(d) α = 1
p
q
(e) α = ∞
Figure 2.20: The Gaussian q which minimizes α-divergence to p (a mixture of two Gaussians), for varying α.
From Figure 1 of [Min05]. Used with kind permission of Tom Minka.
2.7.1.1 KL divergence
Suppose we compute the f-divergence using f(r) = r log(r). In this case, we get a quantity called
the Kullback Leibler divergence, defined as follows:
DKL (p k q) = Z
p(x) log p(x)
q(x)
dx (2.288)
See Section 5.1 for more details.
2.7.1.2 Alpha divergence
If f(x) = 4
1−α2 (1 − x
1+α
2 ), the f-divergence becomes the alpha divergence [Ama09], which is as
follows:
DA
α (p||q) ,
4
1 − α2

1 −
Z
p(x)
(1+α)/2
q(x)
(1−α)/2
dx

(2.289)
where we assume α 6= ±1. Another common parameterization, and the one used by Minka in [Min05],
is as follows:
DM
α (p||q) = 1
α(1 − α)

1 −
Z
p(x)
α
q(x)
1−α
dx

(2.290)
This can be converted to Amari’s notation using DA
α′ = DM
α where α
′ = 2α − 1. (We will use the
Minka convention.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.7. DIVERGENCE MEASURES BETWEEN PROBABILITY DISTRIBUTIONS
We see from Figure 2.20 that as α → −∞, q prefers to match one mode of p, whereas when α → ∞,
q prefers to cover all of p. More precisely, one can show that as α → 0, the alpha divergence tends
towards DKL (q k p), and as α → 1, the alpha divergence tends towards DKL (p k q). Also, when
α = 0.5, the alpha divergence equals the Hellinger distance (Section 2.7.1.3).
2.7.1.3 Hellinger distance
The (squared) Hellinger distance is defined as follows:
D2
H(p||q) ,
1
2
Z 
p(x)
1
2 − q(x)
1
2
2
dx = 1 −
Z p
p(x)q(x)dx (2.291)
This is a valid distance metric, since it is symmetric, nonnegative, and satisfies the triangle inequality.
We see that this is equal (up to constant factors) to the f-divergence with f(r) = (√
r − 1)2
, since
Z
dx q(x)
 
p
1
2 (x)
q
1
2 (x)
− 1
!2
=
Z
dx q(x)
 
p
1
2 (x) − q
1
2 (x)
q
1
2 (x)
!2
=
Z
dx

p
1
2 (x) − q
1
2 (x)
2
(2.292)
2.7.1.4 Chi-squared distance
The chi-squared distance χ
2
is defined by
χ
2
(p, q) ,
1
2
Z
(q(x) − p(x))2
q(x)
dx (2.293)
This is equal (up to constant factors) to an f-divergence where f(r) = (r − 1)2
, since
Z
dx q(x)

p(x)
q(x)
− 1
2
=
Z
dx q(x)

p(x) − q(x)
q(x)
2
=
Z
dx
1
q(x)
(p(x) − q(x))2
(2.294)
2.7.2 Integral probability metrics
In this section, we compute the divergence between two distributions in terms of P − Q using an
integral probability metric or IPM [Sri+09]. This is defined as follows:
DF (P, Q) , sup
f∈F
|Ep(x)
[f(x)] − Eq(x′)
[f(x
′
)] | (2.295)
where F is some class of “smooth” functions. The function f that maximizes the difference between
these two expectations is called the witness function. See Figure 2.21 for an illustration.
There are several ways to define the function class F. One approach is to use an RKHS, defined in
terms of a positive definite kernel function; this gives rise to the method known as maximum mean
discrepancy or MMD. See Section 2.7.3 for details.
Another approach is to define F to be the set of functions that have bounded Lipschitz constant,
i.e., F = {||f||L ≤ 1}, where
||f||L = sup
x6=x′
|f(x) − f(x
′
)|
||x − x′
|| (2.296)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license58
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 2.21: A smooth witness function for comparing two distributions which are (a) different and (b)
similar. From a figure from [GSJ19]. Used with kind permission of Arthur Gretton.
The IPM in this case is equal to the Wasserstein-1 distance
W1(P, Q) , sup
||f||L≤1
|Ep(x)
[f(x)] − Eq(x′)
[f(x
′
)] | (2.297)
See Section 6.8.2.4 for details.
2.7.3 Maximum mean discrepancy (MMD)
In this section, we describe the maximum mean discrepancy or MMD method of [Gre+12],
which defines a discrepancy measure D(P, Q) using samples from the two distributions. The samples
are compared using positive definite kernels (Section 18.2), which can handle high-dimensional
inputs. This approach can be used to define two-sample tests, and to train implicit generative models
(Section 26.2.4).
2.7.3.1 MMD as an IPM
The MMD is an integral probability metric (Section 2.7.2) of the form
MMD(P, Q; F) = sup
f∈F:||f||≤1

Ep(x)
[f(x)] − Eq(x′)
[f(x
′
)]
(2.298)
where F is an RKHS (Section 18.3.7.1) defined by a positive definite kernel function K. We can
represent functions in this set as an infinite sum of basis functions
f(x) = hf, φ(x)iF =
X∞
l=1
flφl(x) (2.299)
We restrict the set of witness functions f to be those that are in the unit ball of this RKHS, so
||f||2
F =
P∞
l=1 f
2
l ≤ 1. By the linearity of expectation, we have
Ep(x)
[f(x)] = hf, Ep(x)
[φ(x)]iF = hf, µP iF (2.300)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.7. DIVERGENCE MEASURES BETWEEN PROBABILITY DISTRIBUTIONS
where µP is called the kernel mean embedding of distribution P [Mua+17]. Hence
MMD(P, Q; F) = sup
||f||≤1
hf, µP − µQiF =
µP − µQ
||µP − µQ|| (2.301)
since the unit vector f that maximizes the inner product is parallel to the difference in feature means.
To get some intuition, suppose φ(x) = [x, x2
]. In this case, the MMD computes the difference in
the first two moments of the two distributions. This may not be enough to distinguish all possible
distributions. However, using a Gaussian kernel is equivalent to comparing two infinitely large feature
vectors, as we show in Section 18.2.6, and hence we are effectively comparing all the moments of the
two distributions. Indeed, one can show that MMD=0 iff P = Q, provided we use a non-degenerate
kernel.
2.7.3.2 Computing the MMD using the kernel trick
In this section, we describe how to compute Equation (2.301) in practice, given two sets of samples,
X = {xn}
N
n=1 and X
′ = {x
′
m}M
m=1, where xn ∼ P and x
′
m ∼ Q. Let µP =
1
N
PN
n=1 φ(xn) and
µQ =
1
M
PM
m=1 φ(x
′
m) be empirical estimates of the kernel mean embeddings of the two distributions.
Then the squared MMD is given by
MMD2
(X , X
′
) , || 1
N
X
N
n=1
φ(xn) −
1
M
X
M
m=1
φ(x
′
m)||2
(2.302)
=
1
N2
X
N
n=1
X
N
n′=1
φ(xn)
Tφ(xn′ ) −
2
NM
X
N
n=1
X
M
m=1
φ(xn)
Tφ(x
′
m)
+
1
M2
X
M
m=1
X
M
m′=1
φ(x
′
m′ )
Tφ(x
′
m) (2.303)
Since Equation (2.303) only involves inner products of the feature vectors, we can use the kernel
trick (Section 18.2.5) to rewrite the above as follows:
MMD2
(X , X
′
) =
1
N2
X
N
n=1
X
N
n′=1
K(xn, xn′ ) −
2
NM
X
N
n=1
X
M
m=1
K(xn, x
′
m) + 1
M2
X
M
m=1
X
M
m′=1
K(x
′
m, x
′
m′ )
(2.304)
2.7.3.3 Linear time computation
The MMD takes O(N2
) time to compute, where N is the number of samples from each distribution.
In [Chw+15], they present a different test statistic called the unnormalized mean embedding or
UME, that can be computed in O(N) time.
The key idea is to notice that evaluating
witness2
(v) = (µQ(v) − µP (v))2
(2.305)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license60
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b) (c)
Figure 2.22: Effect of decreasing the bandwidth parameter σ on the witness function defined by a Gaussian
kernel. From a figure from [GSJ19]. Used with kind permission of Dougal Sutherland.
at a set of test locations v1, . . . , vJ is enough to detect a difference between P and Q. Hence we
define the (squared) UME as follows:
UME2
(P, Q) = 1
J
X
J
j=1

µP (vj ) − µQ(vj )
2
(2.306)
where µP (v) = Ep(x)
[K(x, v)] can be estimated empirically in O(N) time, and similarly for µQ(v).
A normalized version of UME, known as NME, is presented in [Jit+16]. By maximizing NME wrt
the locations vj , we can maximize the statistical power of the test, and find locations where P and
Q differ the most. This provides an interpretable two-sample test for high dimensional data.
2.7.3.4 Choosing the right kernel
The effectiveness of MMD (and UME) obviously crucially depends on the right choice of kernel. Even
for distiguishing 1d samples, the choice of kernel can be very important. For example, consider a
Gaussian kernel, Kσ(x, x
′
) = exp(−
1
2σ2 ||x − x
′
||2
). The effect of changing σ in terms of the ability
to distinguish two different sets of 1d samples is shown in Figure 2.22. Fortunately, the MMD is
differentiable wrt the kernel parameters, so we can choose the optimal σ
2
so as to maximize the power
of the test [Sut+17]. (See also [Fla+16] for a Bayesian approach, which maximizes the marginal
likelihood of a GP representation of the kernel mean embedding.)
For high-dimensional data such as images, it can be useful to use a pre-trained CNN model as a
way to compute low-dimensional features. For example, we can define K(x, x
′
) = Kσ(h(x), h(x
′
)),
where h is some hidden layer of a CNN. such as the “inception” model of [Sze+15a]. The resulting
MMD metric is known as the kernel inception distance [Biń+18]. This is similar to the Fréchet
inception distance [Heu+17a], but has nicer statistical properties, and is better correlated with
human perceptual judgement [Zho+19a].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2.7. DIVERGENCE MEASURES BETWEEN PROBABILITY DISTRIBUTIONS
Figure 2.23: Summary of the two main kinds of divergence measures between two probability distributions P
and Q. From a figure from [GSJ19]. Used with kind permission of Arthur Gretton.
2.7.4 Total variation distance
The total variation distance between two probability distributions is defined as follows:
DTV(p, q) ,
1
2
||p − q||1 =
1
2
Z
|p(x) − q(x)|dx (2.307)
This is equal to an f-divergence where f(r) = |r − 1|/2, since
1
2
Z
q(x)|
p(x)
q(x)
− 1|dx =
1
2
Z
q(x)|
p(x) − q(x)
q(x)
|dx =
1
2
Z
|p(x) − q(x)|dx (2.308)
One can also show that the TV distance is an integral probability measure. In fact, it is the only
divergence that is both an IPM and an f-divergence [Sri+09]. See Figure 2.23 for a visual summary.
2.7.5 Density ratio estimation using binary classifiers
In this section, we discuss a simple approach for comparing two distributions that turns out to be
equivalent to IPMs and f-divergences.
Consider a binary classification problem in which points from P have label y = 1 and points from
Q have label y = 0, i.e., P(x) = p(x|y = 1) and Q(x) = p(x|y = 0). Let p(y = 1) = π be the class
prior. By Bayes’ rule, the density ratio r(x) = P(x)/Q(x) is given by
P(x)
Q(x)
=
p(x|y = 1)
p(x|y = 0) =
p(y = 1|x)p(x)
p(y = 1) /
p(y = 0|x)p(x)
p(y = 0) (2.309)
=
p(y = 1|x)
p(y = 0|x)
1 − π
π
(2.310)
If we assume π = 0.5, then we can estimate the ratio r(x) by fitting a binary classifier or discriminator
h(x) = p(y = 1|x) and then computing r = h/(1 − h). This is called the density ratio estimation
or DRE trick.
We can optimize the classifer h by minimizing the risk (expected loss). For example, if we use
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license62
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
log-loss, we have
R(h) = Ep(x|y)p(y)
[−y log h(x) − (1 − y) log(1 − h(x))] (2.311)
= πEP (x)
[− log h(x)] + (1 − π)EQ(x)
[− log(1 − h(x))] (2.312)
We can also use other loss functions ℓ(y, h(x)) (see Section 26.2.2).
Let Rℓ
h∗ = infh∈F R(h) be the minimum risk achievable for loss function ℓ, where we minimize
over some function class F.
11 In [NWJ09], they show that for every f-divergence, there is a loss
function ℓ such that −Df (P, Q) = Rℓ
h∗ . For example (using the notation y˜ ∈ {−1, 1} instead of
y ∈ {0, 1}), total-variation distance corresponds to hinge loss, ℓ(y, h ˜ ) = max(0, 1 − yh˜ ); Hellinger
distance corresponds to exponential loss, ℓ(y, h ˜ ) = exp(−yh˜ ); and χ
2 divergence corresponds to
logistic loss, ℓ(˜y, h) = log(1 + exp(−yh˜ )).
We can also establish a connection between binary classifiers and IPMs [Sri+09]. In particular, let
ℓ(˜y, h) = −2˜yh, and p(˜y = 1) = p(˜y = −1) = 0.5. Then we have
Rh∗ = inf
h
Z
ℓ(˜y, h(x))p(x|y˜)p(˜y)dxdy˜ (2.313)
= inf
h
0.5
Z
ℓ(1, h(x))p(x|y˜ = 1)dx + 0.5
Z
ℓ(−1, h(x))p(x|y˜ = −1)dx (2.314)
= inf
h
Z
h(x)Q(x)dx −
Z
h(x)P(x)dx (2.315)
= sup
h
−
Z
h(x)Q(x)dx +
Z
h(x)P(x)dx (2.316)
which matches Equation (2.295). Thus the classifier plays the same role as the witness function.
11. If P is a fixed distribution, and we minimize the above objective wrt h, while also maximizing it wrt a model
Q(x), we recover a technique known as a generative adversarial network for fitting an implicit model to a distribution
of samples P (see Chapter 26 for details). However, in this section, we assume Q is known.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20233 Statistics
3.1 Introduction
Probability theory (which we discussed in Chapter 2) is concerned with modeling the distribution
over observed data outcomes D given known parameters θ by computing p(D|θ). By contrast,
statistics is concerned with the inverse problem, in which we want to infer the unknown parameters
θ given observations, i.e., we want to compute p(θ|D). Indeed, statistics was originally called
inverse probability theory. Nowadays, there are two main approaches to statistics, frequentist
statistics and Bayesian statistics, as we discuss below. (See also Section 34.1, where we compare
the frequentist and Bayesian approaches to decision theory.) Note, however, that most of this chapter
(and the entire book) focuses on the Bayesian approach, for reasons that will become clear.
3.2 Bayesian statistics
In the Bayesian approach to statistics, we treat the parameters θ as unknown, and the data D as fixed
and known. (This is the opposite of the frequentist approach, which we discuss in Section 3.3.) We
represent our uncertainty about the parameters, after (posterior to) seeing the data, by computing
the posterior distribution using Bayes’ rule:
p(θ|D) = p(θ)p(D|θ)
p(D)
=
p(θ)p(D|θ)
R
p(θ
′)p(D|θ
′)dθ
′
(3.1)
Here p(θ) is called the prior, and represents our beliefs about the parameters before seeing the data;
p(D|θ) is called the likelihood, and represents our beliefs about what data we expect to see for
each setting of the parameters; p(θ|D) is called the posterior, and represents our beliefs about the
parameters after seeing the data; and p(D) is called the marginal likelihood or evidence, and is
a normalization constant that we will use later.
The task of computing this posterior is called Bayesian inference, posterior inference, or just
inference. We will give many examples in the following sections of this chapter, and will discuss
algorithmic issues in Part II. For more details on Bayesian statistics, see e.g., [Ber97a; Hof09; Lam18;
Kru15; McE20] for introductory level material, [Gel+14a; MKL21; GHV20a] for intermediate level
material, and [BS94; Ber85b; Rob07] for more advanced theory.64
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.2.1 Tossing coins
It is common to explain the key ideas behind Bayesian inference by considering a coin tossing
experiment. We shall follow this tradition (although also see Supplementary Section 3.1 for an
alternative gentle introduction to Bayes using the example of Bayesian concept learning.)
Let θ ∈ [0, 1] be the chance that some coin comes up heads, an event we denote by Y = 1. Suppose
we toss a coin N times, and we record the outcomes as D = {yn ∈ {0, 1} : n = 1 : N}. We want to
compute p(θ|D), which represents our beliefs about the parameter after doing collecting the data. To
compute the posterior, we can use Bayes’ rule, as in Equation (3.1). We give the details below.
3.2.1.1 Likelihood
We assume the data are iid or independent and identically distributed. Thus the likelihood
has the form
p(D|θ) = Y
N
n=1
θ
yn (1 − θ)
1−yn = θ
N1
(1 − θ)
N0
(3.2)
where we have defined N1 =
PN
n=1 I(yn = 1) and N0 =
PN
n=1 I(yn = 0), representing the number of
heads and tails. These counts are called the sufficient statistics of the data, since this is all we
need to know about D to infer θ. The total count, N = N0 + N1, is called the sample size.
Note that we can also consider a Binomial likelihood model, in which we perform N trials and
observe the number of heads, y, rather than observing a sequence of coin tosses. Now the likelihood
has the following form:
p(D|θ) = Bin(y|N, θ) = 
N
y

θ
y
(1 − θ)
N−y
(3.3)
The scaling factor ￾N
y

is independent of θ, so we can ignore it. Thus this likelihood is proportional
to the Bernoulli likelihood in Equation (3.2), so our inferences about θ will be the same for both
models.
3.2.1.2 Prior
We also need to specify a prior. Let us assume we know nothing about the parameter, except that it
lies in the interval [0, 1]. We can represent this uninformative prior using a uniform distribution,
p(θ) = Unif(θ|0, 1) (3.4)
More generally, we will write the prior using a beta distribution (Section 2.2.4.1), for reasons that
will become clear shortly. That is, we assume
p(θ) = Beta(θ|
`α,
`
β) ∝ θ
`α−1
(1 − θ)
`β −1
(3.5)
Here `α and `
β are called hyper-parameters, since they are parameters of the prior which determine
our beliefs about the “main” parameter θ. If we set `α=
`
β= 1, we recover the uniform prior as a special
case.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.2. BAYESIAN STATISTICS
0.0 0.2 0.4 0.6 0.8 1.0
0.0
0.5
1.0
1.5
2.0
2.5
Prior/Posterior
N0:1, N1:4
prior Beta(1, 1)
likelihood Bernoulli
posterior Beta(5, 2)
0.00
0.02
0.04
0.06
0.08
Likelihood
(a)
0.0 0.2 0.4 0.6 0.8 1.0
0.0
0.5
1.0
1.5
2.0
2.5
Prior/Posterior
N0:1, N1:4
prior Beta(2, 2)
likelihood Bernoulli
posterior Beta(6, 3)
0.00
0.02
0.04
0.06
0.08
Likelihood
(b)
Figure 3.1: Updating a Beta prior with a Bernoulli likelihood with sufficient statistics N1 = 4, N0 = 1. (a)
Uniform Beta(1,1) prior. (a) Beta(2,2) prior. Generated by beta_binom_post_plot.ipynb.
We can think of these hyper-parameters as pseudocounts, which play a role analogous to the
empirical counts N1 and N0 derived from the real data. The strength of the prior is controlled by
`
N=
`α +
`
β; this is called the equivalent sample size, since it plays a role analogous to the observed
sample size, N = N1 + N0.
3.2.1.3 Posterior
We can compute the posterior by multiplying the likelihood by the prior:
p(θ|D) ∝ θ
N1
(1 − θ)
N0 θ
`α−1
(1 − θ)
`β −1 ∝ Beta(θ|
`α +N1,
`
β +N0) = Beta(θ|
aα,
a
β) (3.6)
where aα,
`α +N1 and a
β,
`
β +N0 are the parameters of the posterior. Since the posterior has the same
functional form as the prior, we say that it is a conjugate prior (see Section 3.4 for more details).
For example, suppose we observe N1 = 4 heads and N0 = 1 tails. If we use a uniform prior, we
get the posterior shown in Figure 3.1a. Not surprisingly, this has exactly the same shape as the
likelihood (but is scaled to integrate to 1 over the range [0, 1]).
Now suppose we use a prior that has a slight preference for values of θ near to 0.5, reflecting our
prior belief that it is more likely than not that the coin is fair. We will make this a weak prior by
setting `α=
`
β= 2. The effect of using this prior is illustrated in Figure 3.1b. We see the posterior
(blue line) is a “compromise” between the prior (red line) and the likelihood (black line).
3.2.1.4 Posterior mode (MAP estimate)
The most probable value of the parameter is given by the MAP estimate
ˆθmap = arg max
θ
p(θ|D) = arg max
θ
log p(θ|D) = arg max
θ
log p(θ) + log p(D|θ) (3.7)
Using calculus, one can show that this is given by
ˆθmap =
`α +N1 − 1
`α +N1 − 1+
`
β +N0 − 1
(3.8)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license66
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
If we use a uniform prior, p(θ) ∝ 1, the MAP estimate becomes the MLE, since log p(θ) = 0:
ˆθmle = arg max
θ
log p(D|θ) = N1
N1 + N0
=
N1
N
(3.9)
This is intuitive and easy to compute. However, the MLE can be very misleading in the small sample
setting. For example, suppose we toss the coins N times, but never see any heads, so N1 = 0. In
this case, we would estimate that ˆθ = 0, which means we would not predict any future observations
to be heads either. This is a very extreme estimate, that is likely due to insufficient data. We can
solve this problem using a MAP estimate with a stronger prior. For example, if we use a Beta(θ|2, 2)
prior, we get the estimate
ˆθmap =
N1 + 1
N1 + 1 + N0 + 1
=
N1 + 1
N + 2
(3.10)
This is called add-one smoothing.
3.2.1.5 Posterior mean
The posterior mode can be a poor summary of the posterior, since it corresponds to picking a single
point from the entire distribution. The posterior mean is a more robust estimate, since it is a
summary statistic derived by integrating over the distribution, θ =
R
θp(θ|D)dθ. In the case of a
beta posterior, p(θ|D) = Beta(θ|
aα,
a
β), the posterior mean is given by
θ , E [θ|D] =
aα
a
β +
aα
=
aα
a
N
(3.11)
where a
N=
a
β +
aα is the strength (equivalent sample size) of the posterior.
We will now show that the posterior mean is a convex combination of the prior mean, m =
`α /
`
N
and the MLE, ˆθmle =
N1
N
:
E [θ|D] =
`α +N1
`α +N1+
`
β +N0
=
`
N m + N1
N+
`
N
(3.12)
=
`
N
N+
`
N
m +
N
N+
`
N
N1
N
= λm + (1 − λ)
ˆθmle (3.13)
where λ =
`NaN
is the ratio of the prior to posterior equivalent sample size. We see that the weaker the
prior is, the smaller λ is, and hence the closer the posterior mean is to the MLE.
3.2.1.6 Posterior variance
To capture some notion of uncertainty in our estimate, a common approach is to compute the
standard error of our estimate, which is just the posterior standard deviation:
se(θ) = p
V [θ|D] (3.14)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.2. BAYESIAN STATISTICS
In the case of the Bernoulli model, we showed that the posterior is a beta distribution. The variance
of the beta posterior is given by
V [θ|D] =
aα
a
β
(
aα +
a
β)
2(
aα +
a
β +1)
=
(
`α +N1)(`
β +N0)
(
`α +N1+
`
β +N0)
2(
`α +N1+
`
β +N0 + 1)
(3.15)
If N ≫`α +
`
β, this simplifies to
V [θ|D] ≈
N1N0
(N1 + N0)
2(N1 + N0)
=
N1
N
N0
N
1
N
=
ˆθ(1 − ˆθ)
N
(3.16)
where ˆθ = N1/N is the MLE. Hence the standard error is given by
σ =
p
V [θ|D] ≈
s
ˆθ(1 − ˆθ)
N
(3.17)
We see that the uncertainty goes down at a rate of 1/
√
N. We also see that the uncertainty (variance)
is maximized when ˆθ = 0.5, and is minimized when ˆθ is close to 0 or 1. This makes sense, since it is
easier to be sure that a coin is biased than to be sure that it is fair.
3.2.1.7 Credible intervals
A posterior distribution is (usually) a high dimensional object that is hard to visualize and work
with. A common way to summarize such a distribution is to compute a point estimate, such as the
posterior mean or mode, and then to compute a credible interval, which quantifies the uncertainty
associated with that estimate. (A credible interval is not the same as a confidence interval, which is
a concept from frequentist statistics which we discuss in Section 3.3.5.1.)
More precisely, we define a 100(1 − α)% credible interval to be a (contiguous) region C = (ℓ, u)
(standing for lower and upper) which contains 1 − α of the posterior probability mass, i.e.,
Cα(D) = (ℓ, u) : P(ℓ ≤ θ ≤ u|D) = 1 − α (3.18)
There may be many intervals that satisfy Equation (3.18), so we usually choose one such that there
is (1−α)/2 mass in each tail; this is called a central interval. If the posterior has a known functional
form, we can compute the posterior central interval using ℓ = F
−1
(α/2) and u = F
−1
(1−α/2), where
F is the cdf of the posterior, and F
−1
is the inverse cdf. For example, if the posterior is Gaussian,
p(θ|D) = N (0, 1), and α = 0.05, then we have ℓ = Φ−1
(α/2) = −1.96, and u = Φ−1
(1 − α/2) = 1.96,
where Φ denotes the cdf of the Gaussian. This justifies the common practice of quoting a credible
interval in the form of µ ± 2σ, where µ represents the posterior mean, σ represents the posterior
standard deviation, and 2 is a good approximation to 1.96.
A problem with central intervals is that there might be points outside the central interval which
have higher probability than points that are inside, as illustrated in Figure 3.2(a). This motivates an
alternative quantity known as the highest posterior density or HPD region, which is the set of
points which have a probability above some threshold. More precisely we find the threshold p
∗ on
the pdf such that
1 − α =
Z
θ:p(θ|D)>p∗
p(θ|D)dθ (3.19)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license68
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 0.2 0.4 0.6 0.8 1
0
0.5
1
1.5
2
2.5
3
3.5
(a)
0 0.2 0.4 0.6 0.8 1
0
0.5
1
1.5
2
2.5
3
3.5
(b)
Figure 3.2: (a) Central interval and (b) HPD region for a Beta(3,9) posterior. The CI is (0.06, 0.52) and
the HPD is (0.04, 0.48). Adapted from Figure 3.6 of [Hof09]. Generated by betaHPD.ipynb.
and then define the HPD as
Cα(D) = {θ : p(θ|D) ≥ p
∗
} (3.20)
In 1d, the HPD region is sometimes called a highest density interval or HDI. For example,
Figure 3.2(b) shows the 95% HDI of a Beta(3, 9) distribution, which is (0.04, 0.48). We see that this
is narrower than the central interval, even though it still contains 95% of the mass; furthermore,
every point inside of it has higher density than every point outside of it.
3.2.1.8 Posterior predictive distribution
Suppose we want to predict future observations. The optimal Bayesian approach is to compute the
posterior predictive distribution, by marginalizing out all the unkown parameters:
p(y|D) = Z
p(y|θ)p(θ|D)dθ (3.21)
Sometimes computing this integral can be difficult (even if we already have access to the posterior).
A common approximation is to just “plug in” a point estimate of the parameters, θˆ = δ(D), where
δ() is some estimator such as a method to compute the MLE or MAP, which gives
p(y|D) ≈ p(y|θˆ) (3.22)
This is called a plugin approximation. This is equivalent to modeling the posterior with a
degenerate distribution centered at the point estimate
p(θ|D) ≈ δ(θ − θˆ) (3.23)
where δ is the Dirac delta function. This follows from the sifting property of delta functions:
p(y|D) = Z
p(y|θ)p(θ|D)dθ =
Z
p(y|θ)δ(θ − θˆ)dθ = p(y|θˆ) (3.24)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.2. BAYESIAN STATISTICS
Unfortunately, the plugin approximation can result in overfitting. For example, consider the coin
tossing example, and suppose we have seen N = 3 heads in a row. The MLE is ˆθ = 3/3 = 1. However,
if we use this estimate for prediction, we would predict that tails are impossible, and would be very
surprised if one ever showed up.1
Instead of the plugin approximation, we can marginalize over all parameter values to compute the
exact posterior predictive, as follows:
p(y = 1|D) = Z 1
0
p(y = 1|θ)p(θ|D)dθ (3.25)
=
Z 1
0
θ Beta(θ|
aα,
a
β)dθ = E [θ|D] =
aα
aα +
a
β
(3.26)
If we use a uniform prior, p(θ) = Beta(θ|1, 1), the predictive distribution becomes
p(y = 1|D) = N1 + 1
N1 + N0 + 2
(3.27)
This is known as Laplace’s rule of succession. Note that this is equivalent to plugging in the
add-one smoothing estimate from Equation (3.10); however, that relied on the rather unnatural
Beta(2,2) prior, whereas Laplace smoothing uses a uniform prior.
3.2.1.9 Marginal likelihood
The marginal likelihood or evidence for a model M is defined as
p(D|M) = Z
p(θ|M)p(D|θ,M)dθ (3.28)
When performing inference for the parameters of a specific model, we can ignore this term, since it is
constant wrt θ. However, this quantity plays a vital role when choosing between different models,
as we discuss in Section 3.8.1. It is also useful for estimating the hyperparameters from data (an
approach known as empirical Bayes), as we discuss in Section 3.7.
In general, computing the marginal likelihood can be hard. However, in the case of the beta￾Bernoulli model, the marginal likelihood is proportional to the ratio of the posterior normalizer to
the prior normalizer. To see this, recall that the posterior is given by p(θ|D) = Beta(θ|
aα,
a
β), where
aα=
`α +N1 and a
β=
`
β +N0. We know the normalization constant of the posterior is B(
aα,
a
β), where B
is the beta function. Hence
p(θ|D) = p(D|θ)p(θ)
p(D)
=
1
p(D)

θ
N1
(1 − θ)
N0


1
B(
`α,
`
β)
θ
`α−1
(1 − θ)
`β −1

(3.29)
=
1
p(D)
1
B(
`α,
`
β)
h
θ
`α+N1−1
(1 − θ)
`β +N0−1
i
=
1
B(
aα,
a
β)
h
θ
aα
(1 − θ)
aβ
i
(3.30)
So the marginal likelihood is given by the ratio of normalization constants for the posterior and prior:
p(D) = B(
aα,
a
β)
B(
`α,
`
β)
(3.31)
1. This is analogous to a black swan event, which refers to the discovery of black swans by Dutch explorers
when they first arrived in Australia in 1697, after only ever having seen white swans their entire lives (see https:
//en.wikipedia.org/wiki/Black_swan_theory for details).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license70
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−5 0 5
x
0
25
50
75
y
training data
prediction
(a)
−5 0 5
x
0
50
100
y
training data
prediction
(b)
Figure 3.3: Predictions made by a polynomial regression model fit to a small dataset. (a) Plugin approximation
to predictive density using the MLE. The curves shows the posterior mean, E [y|x], and the error bars show the
posterior standard deviation, std [y|x], around this mean. (b) Bayesian posterior predictive density, obtained
by integrating out the parameters. Generated by linreg_post_pred_plot.ipynb.
3.2.2 Modeling more complex data
In Section 3.2.1, we showed how the Bayesian approach can be applied to analyse a very simple
model, namely a Bernoulli distribution for representing binary events such as coin tosses. The same
basic ideas can be applied to more complex models. For example, in machine learning, we are often
very interested in predicting outcomes y given input features x. For this, we can use a conditional
probability distribution of the form p(y|x, θ), which can be a generalized linear model (Chapter 15),
or a neural network (Chapter 16), etc.
The main quantity of interest is the posterior predictive distribution, given by
p(y|x, D) = Z
p(y|x, θ)p(θ|D)dθ (3.32)
By integrating out, or marginalizing out, the unknown parameters, we reduce the chance of
overfitting, since we are effectively computing the weighted average of predictions from an infinite
number of models. This act of integrating over uncertainty is at the heart of the Bayesian approach
to machine learning. (Of course, the Bayesian approach requires a prior, but so too do methods that
rely on regularization, so the prior is not so much the distinguishing aspect.)
It is worth contrasting the Bayesian approach to the more common plugin approximation, in
which we compute a point estimate θˆ of the parameters (such as the MLE), and then plug them into
the model to make predictions using p(y|x, θˆ). As we explained in Section 3.2.1.8, this is equivalent
to approximate the posterior by a delta function, p(θ|D) ≈ δ(θ − θˆ), since
p(y|x, D) ≈
Z
p(y|x, θ)δ(θ − θˆ)dθ = p(y|x, θˆ) (3.33)
The plugin approximation is simple and widely used. However, it ignores uncertainty in the
parameter estimates, which can result in an underestimate of the predictive uncertainty. For example,
Figure 3.3a plots the plugin approximation p(y|x, θˆ) for a linear regression model p(y|x, θ) =
N (y|wˆ
T
mlex, σˆ
2
mle), where we plug in the MLEs for w and σ
2
. (See Section 15.2.1 for details on how
to compute these MLEs.) We see that the size of the predicted variance is a constant (namely σˆ
2
).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.2. BAYESIAN STATISTICS
The uncertainty captured by σ is called aleatoric uncertainty or intrinsic uncertainty, and
would persist even if we knew the true model and true parameters. However, since we don’t know
the parameters, we have an additional, and orthogonal, source of uncertainty, called epistemic
uncertainty (since it arises due to a lack of knowledge about the truth). In the Bayesian approach,
we take this into account, which can be useful for applications such as active learning (Section 34.7),
Bayesian optimization (Section 6.6), and risk-sensitive decision making (Section 34.1.3). The resulting
Bayesian posterior predictive distribution for this example is shown in Figure 3.3b. We see that now
the error bars get wider as we move away from the training data. For more details on Bayesian linear
regression, see Section 15.2.
We can use similiar Bayesian methods for more complex nonlinear models such as neural nets, as
we discuss in Section 17.1, as well as for unconditional generative models, as we discuss in Part IV.
3.2.3 Selecting the prior
A challenge with the Bayesian approach is that it requires the user to specify a prior, which may
be difficult in large models, such as neural networks. We discuss the topic of prior selection at
length later in this chapter. In particular, in Section 3.4, we discuss conjugate priors, which
are computationally convenient; in Section 3.5, we discuss uninformative priors, which often
correspond to a limit of a conjugate prior where we “know nothing”; in Section 3.6, we discuss
hierarchical priors, which are useful when we have multiple related datasets; and in Section 3.7,
we discuss empirical priors, which can be learned from the data.
3.2.4 Computational issues
Another challenge with the Bayesian approach is that it can be computationally expensive to compute
the posterior and/or posterior predictive. We give an overview of suitable approximate posterior
inference methods in Section 7.4, and discuss the topic at length in Part II. (See also [MFR20] for a
historical review of this topic.)
3.2.5 Exchangeability and de Finetti’s theorem
An interesting philosophical question is: where do priors come from, given that they refer to
parameters which are just abstract quantities in a model, and not directly observable. A fundamental
result, known as de Finetti’s theorem, explains how they are related to our beliefs about observable
outcomes.
To explain the result, we first need a definition. We say that a sequence of random variables
(x1, x2, . . .) is infinitely exchangeable if, for any n, the joint probability p(x1, . . . , xn) is invariant
to permutation of the indices. That is, for any permutation π, we have
p(x1, . . . , xn) = p(xπ1
, . . . , xπn
) (3.34)
Exchangeability is a more general concept compared to the more familiar concept of a sequence of
independent, identically distributed or iid variables. For example, suppose D = (x1, . . . , xn) is a
sequence of images, where each xi ∼ p
∗
is generated independently from the same “true distribution”
p
∗
. We see that this is an iid sequence. Now suppose x0 is a background image. The sequence
(x0 + x1, . . . , x0 + xn) is infinitely exchangeable but not iid, since all the variables share a hidden
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license72
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
common factor, namely the background x0. Thus the more examples we see, the better we will be
able to estimate the shared x0, and thus the better we can predict future elements.
More generally, we can view an exchangeable sequence as coming from a hidden common cause,
which we can treat as an unknown random variable θ. This is formalized by de Finetti’s theorem:
Theorem 3.2.1 (de Finetti’s theorem). A sequence of random variables (x1, x2, . . .) is infinitely
exchangeable iff, for all n, we have
p(x1, . . . , xn) = Z Yn
i=1
p(xi
|θ)p(θ)dθ (3.35)
where θ is some hidden common random variable (possibly infinite dimensional). That is, xi are iid
conditional on θ.
We often interpret θ as a parameter. The theorem tells us that, if our data is exchangeable, then
there must exist a parameter θ, and a likelihood p(xi
|θ), and a prior p(θ). Thus the Bayesian
approach follows automatically from exchangeability [O’N09]. (The approach can also be extended
to conditional probability models using a concept called partially exchangeable [Dia88a].)
3.3 Frequentist statistics
Bayesian statistics, which we discussed in Section 3.2, treats parameters of models just like any
other unknown random variable, and applies the rules of probability theory to infer them from data.
Attempts have been made to devise approaches to statistical inference that avoid treating parameters
like random variables, and which thus avoid the use of priors and Bayes rule. This alternative
approach is known as frequentist statistics, classical statistics or orthodox statistics.
The basic idea (formalized in Section 3.3.1) is to to represent uncertainty by calculating how a
quantity estimated from data (such as a parameter or a predicted label) would change if the data
were changed. It is this notion of variation across repeated trials that forms the basis for modeling
uncertainty used by the frequentist approach. By contrast, the Bayesian approach views probability in
terms of information rather than repeated trials. This allows the Bayesian to compute the probability
of one-off events, such as the probability that the polar ice cap will melt by 2030. In addition, the
Bayesian approach avoids certain paradoxes that plague the frequentist approach (see Section 3.3.5),
and which are a source of much confusion.
Despite the disadvantages of frequentist statistics, it is a widely used approach, and it has some
concepts (such as cross validation, model checking and conformal prediction) that are useful even
for Bayesians [Rub84]. Thus it is important to know some of the basic principles. We give a brief
summary below of these principles below. For more details, see other texbooks, such as [Was04;
Cox06; YS10; EH16].
3.3.1 Sampling distributions
In frequentist statistics, uncertainty is not represented by the posterior distribution of a random
variable, but instead by the sampling distribution of an estimator. (We define these two terms below.)
As explained in the section on decision theory in Section 34.1.2, an estimator is a decision
procedure that specifies what action to take given some observed data. In the context of parameter
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.3. FREQUENTIST STATISTICS
estimation, where the action space is to return a parameter vector, we will denote this by θˆ = δ(D).
For example, θˆ could be the maximum likelihood estimate, the MAP estimate, or the method of
moments estimate.
The sampling distribution of an estimator is the distribution of results we would see if we
applied the estimator multiple times to different datasets sampled from some distribution; in the
context of parameter estimation, it is the distribution of θˆ, viewed as a random variable that depends
on the random sample D. In more detail, imagine sampling S different data sets, each of size N,
from some true model p(x|θ
∗
) to generate
D˜ (s) = {xn ∼ p(xn|θ
∗
) : n = 1 : N} (3.36)
We denote this by D˜ (s) ∼ θ
∗
for brevity. Now apply the estimator to each D˜ (s)
to get a set of estimates,
{θˆ(D˜ (s)
)}. As we let S → ∞, the distribution induced by this set is the sampling distribution of the
estimator. More precisely, we have
p(δ(D˜ ) = θ|D ∼˜ θ
∗
) ≈
1
S
X
S
s=1
δ(θ − δ(D˜ (s)
)) (3.37)
We often approximate this by Monte Carlo, as we discuss in Section 3.3.2, although in some cases we
can compute approximate it analytically, as we discuss in Section 3.3.3.
3.3.2 Bootstrap approximation of the sampling distribution
In cases where the estimator is a complex function of the data, or when the sample size is small, it is
often useful to approximate its sampling distribution using a Monte Carlo technique known as the
bootstrap [ET93].
The idea is simple. If we knew the true parameters θ
∗
, we could generate many (say S) fake
datasets, each of size N, from the true distribution, using D˜ (s) = {xn ∼ p(xn|θ
∗
) : n = 1 : N}. We
could then compute our estimate from each sample, θˆs = δ(D˜ (s)
) and use the empirical distribution
of the resulting θˆs as our estimate of the sampling distribution, as in Equation (3.37). Since θ
∗
is
unknown, the idea of the parametric bootstrap is to generate each sampled dataset using θˆ = δ(D)
instead of θ
∗
, i.e., we use D˜ (s) = {xn ∼ p(xn|θˆ) : n = 1 : N} in Equation (3.37). This is a plug-in
approximation to the sampling distribution.
The above approach requires that we have a parametric generative model for the data, p(x|θ). An
alternative, called the non-parametric bootstrap, is to sample N data points from the original
dataset with replacement. This creates a new distribution D(s) which has the same size as the original.
However, the number of unique data points in a bootstrap sample is just 0.632 × N, on average.
(To see this, note that the probability an item is picked at least once is (1 − (1 − 1/N)
N ), which
approaches 1 − e
−1 ≈ 0.632 for large N.) Fortunately, various improved versions of the bootstrap
have been developed (see e.g., [ET93]).
Figure 3.4(a-b) shows an example where we compute the sampling distribution of the MLE for a
Bernoulli using the parametric bootstrap. (Results using the non-parametric bootstrap are essentially
the same.) When N = 10, we see that the sampling distribution is asymmetric, and therefore quite
far from Gaussian, but when N = 100, the distribution looks more Gaussian, as theory suggests (see
Section 3.3.3).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license74
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0.0 0.2 0.4 0.6 0.8 1.0
ˆθ
s
0
1000
2000
3000
Bootstrap: Number of data points = 10
MLE (ˆθ)
(a)
0.0 0.2 0.4 0.6 0.8 1.0
ˆθ
s
0
1000
2000
Bootstrap: Number of data points = 100
MLE (ˆθ)
(b)
0.0 0.2 0.4 0.6 0.8 1.0
θ
s
0
500
1000
1500
2000
Bayes: Number of data points = 10
MLE (ˆθ)
(c)
0.0 0.2 0.4 0.6 0.8 1.0
θ
s
0
1000
2000
3000
Bayes: Number of data points = 100
MLE (ˆθ)
(d)
Figure 3.4: Bootstrap (top row) vs Bayes (bottom row). The N data cases were generated from Ber(θ = 0.7).
Left column: N = 10. Right column: N = 100. (a-b) A bootstrap approximation to the sampling distribution
of the MLE for a Bernoulli distribution. We show the histogram derived from B = 10, 000 bootstrap samples.
(c-d) Histogram of 10,000 samples from the posterior distribution using a uniform prior. Generated by
bootstrap_demo_bernoulli.ipynb.
A natural question is: what is the connection between the parameter estimates θˆs = δ(D(s)
) com￾puted by the bootstrap and parameter values sampled from the posterior, θ
s ∼ p(·|D)? Conceptually
they are quite different. But in the common case that the estimator is MLE and the prior is not very
strong, they can be quite similar. For example, Figure 3.4(c-d) shows an example where we compute
the posterior using a uniform Beta(1,1) prior, and then sample from it. We see that the posterior
and the sampling distribution are quite similar. So one can think of the bootstrap distribution as a
“poor man’s” posterior [HTF01, p235].
However, perhaps surprisingly, bootstrap can be slower than posterior sampling. The reason is that
the bootstrap has to generate S sampled datasets, and then fit a model to each one. By contrast, in
posterior sampling, we only have to “fit” a model once given a single dataset. (Some methods for
speeding up the bootstrap when applied to massive data sets are discussed in [Kle+11].)
3.3.3 Asymptotic normality of the sampling distribution of the MLE
The most common estimator is the MLE. When the sample size becomes large, the sampling
distribution of the MLE for certain models becomes Gaussian. This is known as the asymptotic
normality of the sampling distribution. More formally, we have the following result:
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.3. FREQUENTIST STATISTICS
Theorem 3.3.1. Under various technical conditions, we have
√
N(θˆ − θ
∗
) → N (0, F(θ
∗
)
−1
) (3.38)
where F(θ
∗
) is the Fisher information matrix, defined in Equation (3.40), θ
∗ are the parameters
of the data generating process to which the estimator will be applied, and → means convergence in
distribution.
The Fisher information matrix equals the Hessian of the log likelihood, as we show in Section 3.3.4,
so F(θ
∗
) measures the amount of curvature of the log-likelihood surface at the true parameter value.
Thus we can intepret this theorem as follows: as the sample size goes to infinity, the sampling
distribution of the MLE will converge to a Gaussian centered on the true parameter, with a precision
equal to the Fisher information. Thus a problem with an informative (peaked) likelihood will ensure
that the parameters are “well determined” by the data, and hence there will be little variation in the
estimates θˆ around θ
∗ as this estimator is applied across different datasets D˜ .
3.3.4 Fisher information matrix
In this section, we discuss an important quantity called the Fisher information matrix, which is
related to the curvature of the log likelihood function. This plays a key role in frequentist statistics,
for characterizing the sampling distribution of the MLE, discussed in Section 3.3.3. However, it is also
used in Bayesian statistics (to derive Jeffreys’ uninformative priors, discussed in Section 3.5.2), as
well as in optimization (as part of the natural gradient descent, procedure, discussed in Section 6.4).
3.3.4.1 Definition
The score function is defined to be the gradient of the log likelihood:
s(θ) , ∇ log p(x|θ) (3.39)
The Fisher information matrix (FIM) is defined to be the covariance of the score function:
F(θ) , Ex∼p(x|θ)

∇ log p(x|θ)∇ log p(x|θ)
T

(3.40)
so the (i, j)’th entry has the form
Fij = Ex∼θ
 ∂
∂θi
log p(x|θ)
  ∂
∂θj
log p(x|θ)
 (3.41)
We give an interpretation of this quantity below.
3.3.4.2 Equivalence between the FIM and the Hessian of the NLL
In this section, we prove that the Fisher information matrix equals the expected Hessian of the
negative log likelihood (NLL)
NLL(θ) = − log p(D|θ) (3.42)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license76
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Since the Hessian measures the curvature of the likelihood, we see that the FIM tells us how well
the likelihood function can identify the best set of parameters. (If a likelihood function is flat, we
cannot infer anything about the parameters, but if it is a delta function at a single point, the best
parameter vector will be uniquely determined.) Thus the FIM is intimately related to the frequentist
notion of uncertainty of the MLE, which is captured by the variance we expect to see in the MLE if
we were to compute it on multiple different datasets drawn from our model.
More precisely, we have the following theorem.
Theorem 3.3.2. If log p(x|θ) is twice differentiable, and under certain regularity conditions, the
FIM is equal to the expected Hessian of the NLL, i.e.,
F(θ)ij , Ex∼θ
 ∂
∂θi
log p(x|θ)
  ∂
∂θj
log p(x|θ)
 = Ex∼θ

∂
2
∂θiθj
log p(x|θ)

(3.43)
Before we prove this result, we establish the following important lemma.
Lemma 3.3.1. The expected value of the score function is zero, i.e.,
Ep(x|θ)
[∇ log p(x|θ)] = 0 (3.44)
We prove this lemma in the scalar case. First, note that since R
p(x|θ)dx = 1, we have
∂
∂θ Z
p(x|θ)dx = 0 (3.45)
Combining this with the identity
∂
∂θ p(x|θ) = 
∂
∂θ log p(x|θ)

p(x|θ) (3.46)
we have
0 = Z
∂
∂θ p(x|θ)dx =
Z 
∂
∂θ log p(x|θ)

p(x|θ)dx = E [s(θ)] (3.47)
Now we return to the proof of our main theorem. For simplicity, we will focus on the scalar case,
following the presentation of [Ric95, p263].
Proof. Taking derivatives of Equation (3.47), we have
0 =
∂
∂θ Z 
∂
∂θ log p(x|θ)

p(x|θ)dx (3.48)
=
Z 
∂
2
∂θ2
log p(x|θ)

p(x|θ)dx +
Z 
∂
∂θ log p(x|θ)

∂
∂θ p(x|θ)dx (3.49)
=
Z 
∂
2
∂θ2
log p(x|θ)

p(x|θ)dx +
Z 
∂
∂θ log p(x|θ)
2
p(x|θ)dx (3.50)
and hence
−Ex∼θ

∂
2
∂θ2
log p(x|θ)

= Ex∼θ
"
∂
∂θ log p(x|θ)
2
#
(3.51)
as claimed.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.3. FREQUENTIST STATISTICS
Now consider the Hessian of the NLL given N iid samples D = {xn : n = 1 : N}:
Hij , −
∂
2
∂θiθj
log p(D|θ) = −
X
N
n=1
∂
2
∂θiθj
log p(xn|θ) (3.52)
From the above theorem, we have
Ep(D|θ)
[H(D)|θ] = NF(θ) (3.53)
This is useful when deriving the sampling distribution of the MLE, as discussed in Section 3.3.3.
3.3.4.3 Example: FIM for the binomial
Suppose x ∼ Bin(n, θ). The log likelihood for a single sample is
l(θ|x) = x log θ + (n − x) log(1 − θ) (3.54)
The score function is just the gradient of the log-likelihood:
s(θ|x) ,
d
dθ l(θ|x) = x
θ
−
n − x
1 − θ
(3.55)
The gradient of the score function is
s
′
(θ|x) = −
x
θ
2
−
n − x
(1 − θ)
2
(3.56)
Hence the Fisher information is given by
F(θ) = Ex∼θ [−s
′
(θ|x)] = nθ
θ
2
+
n − nθ
(1 − θ)
2
=
n
θ
+
n
1 − θ
=
n
θ(1 − θ)
(3.57)
3.3.4.4 Example: FIM for the univariate Gaussian
Consider a univariate Gaussian p(x|θ) = N (x|µ, v). We have
ℓ(θ) = log p(x|θ) = −
1
2v
(x − µ)
2 −
1
2
log(v) −
1
2
log(2π) (3.58)
The partial derivatives are given by
∂ℓ
∂µ = (x − µ)v
−1
,
∂
2
ℓ
∂µ2
= −v
−1
(3.59)
∂ℓ
∂v =
1
2
v
−2
(x − µ)
2 −
1
2
v
−1
,
∂ℓ
∂v2
= −v
−3
(x − µ)
2 +
1
2
v
−2
(3.60)
∂ℓ
∂µ∂v = −v
−2
(x − µ) (3.61)
and hence
F(θ) =

E

v
−1

E

v
−2
(x − µ)

E

v
−2
(x − µ)

E

v
−3
(x − µ)
2 −
1
2
v
−2


=
1
v
0
0
1
2v
2

(3.62)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license78
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.3.4.5 Example: FIM for logistic regression
Consider ℓ2-regularized binary logistic regression. The negative log joint has the following form:
E(w) = − log[p(y|X, w)p(w|λ)] = −wTXTy +
X
N
n=1
log(1 + e
wTxn ) + λ
2
wTw (3.63)
The derivative has the form
∇wE(w) = −XTy + XT
s + λw (3.64)
where sn = σ(wTxn). The FIM is given by
F(w) = Ep(y|X,w,λ)

∇2
E(w)

= XTΛX + λI (3.65)
where Λ is the N × N diagonal matrix with entries
Λnn = σ(wTxn)(1 − σ(wTxn)) (3.66)
3.3.4.6 FIM for the exponential family
In this section, we discuss how to derive the FIM for an exponential family distribution with natural
parameters η, which generalizes many of the previous examples. Recall from Equation (2.216) that
the gradient of the log partition function is the expected sufficient statistics
∇ηA(η) = E [T (x)] = m (3.67)
and from Equation (2.247) that the gradient of the log likelihood is the statistics minus their expected
value:
∇η log p(x|η) = T (x) − E [T (x)] (3.68)
Hence the FIM wrt the natural parameters Fη is given by
(Fη)ij = Ep(x|η)

∂ log p(x|η)
∂ηi
∂ log p(x|η)
∂ηj

(3.69)
= Ep(x|η)
[(T (x)i − mi)(T (x)j − mj )] (3.70)
= Cov [T (x)i
, T (x)j ] (3.71)
or, in short,
Fη = Cov [T (x)] (3.72)
Sometimes we need to compute the Fisher wrt the moment parameters m:
(Fm)ij = Ep(x|m)

∂ log p(x|η)
∂mi
∂ log p(x|η)
∂mj

(3.73)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.3. FREQUENTIST STATISTICS
From the chain rule we have
∂ log p(x)
∂α =
∂ log p(x)
∂β
∂β
∂α (3.74)
and hence
Fα =
∂β
∂α
T
Fβ
∂β
∂α
(3.75)
Using the log trick
∇Ep(x)
[f(x)] = Ep(x)
[f(x)∇ log p(x)] (3.76)
and Equation (3.68) we have
∂mi
∂ηj
=
∂E [T (x)i
]
∂ηj
= E

T (x)i
∂ log p(x|η)
∂ηj

= E [T (x)i(T (x)j − mj )] (3.77)
= E [T (x)iT (x)j ] − E [T (x)i
] mj = Cov [T (x)iT (x)j ] = (Fη)ij (3.78)
and hence
∂η
∂m
= F
−1
η
(3.79)
so
Fm =
∂η
∂m
T
Fη
∂η
∂m
= F
−1
η FηF
−1
η = F
−1
η = Cov [T (x)]−1
(3.80)
3.3.5 Counterintuitive properties of frequentist statistics
Although the frequentist approach to statistics is widely taught, it suffers from certain pathological
properties, resulting in its often being misunderstood and/or misused, as has been pointed out in
multiple articles (see e.g., [Bol02; Bri12; Cla21; Gel16; Hoe+14; Jay03; Kru10; Lav00; Lyu+20;
Min99; Mac03; WG17]). We give some examples below.
3.3.5.1 Confidence intervals
In frequentist statistics, we use the variability induced by the sampling distribution as a way to
estimate uncertainty of a parameter estimate. In particular, we define a 100(1 − α)% confidence
interval as any interval I(D˜ ) = (ℓ(D˜ ), u(D˜ )) derived from a hypothetical dataset D˜ such that
Pr(θ ∈ I(D˜ )|D ∼˜ θ) = 1 − α (3.81)
It is common to set α = 0.05, which yields a 95% CI. This means that, if we repeatedly sampled
data, and compute I(D˜ ) for each such dataset, then about 95% of such intervals will contain the true
parameter θ. We say that the CI has 95% coverage.
Note, however, that Equation (3.81) does not mean that for any particular dataset that θ ∈ I(D)
with 95% probability, which is what a Bayesian credible interval computes (Section 3.2.1.7), and
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license80
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
which is what most people are usually interested in. So we see that the concept of frequentist CI
and Bayesian CI are quite different: In the frequentist approach, θ is treated as an unknown fixed
constant, and the data is treated as random. In the Bayesian approach, we treat the data as fixed
(since it is known) and the parameter as random (since it is unknown).
This counter-intuitive definition of confidence intervals can lead to bizarre results. Consider the
following example from [Ber85a, p11]. Suppose we draw two integers D = (y1, y2) from
p(y|θ) =



0.5 if y = θ
0.5 if y = θ + 1
0 otherwise
(3.82)
If θ = 39, we would expect the following outcomes each with probability 0.25:
(39, 39),(39, 40),(40, 39),(40, 40) (3.83)
Let m = min(y1, y2) and define the following interval:
[ℓ(D), u(D)] = [m, m] (3.84)
For the above samples this yields
[39, 39], [39, 39], [39, 39], [40, 40] (3.85)
Hence Equation (3.84) is clearly a 75% CI, since 39 is contained in 3/4 of these intervals. However, if
we observe D = (39, 40) then p(θ = 39|D) = 1.0, so we know that θ must be 39, yet we only have 75%
“confidence” in this fact. We see that the CI will “cover” the true parameter 75% of the time, if we
compute multiple CIs from different randomly sampled datasets, but if we just have a single observed
dataset, and hence a single CI, then the frequentist “coverage” probability can be very misleading.
Several more interesting examples, along with Python code, can be found at [Van14]. See
also [Hoe+14; Mor+16; Lyu+20; Cha+19b], who show that many people, including professional
statisticians, misunderstand and misuse frequentist confidence intervals in practice, whereas Bayesian
credible intervals do not suffer from these problems.
3.3.5.2 p-values
The frequentist approach to hypothesis testing, known as null hypothesis significance testing
or NHST, is to define a decision procedure for deciding whether to accept or reject the null
hypothesis H0 based on whether some observed test statistic t(D) is likely or not under the
sampling distribution of the null model. We describe this procedure in more detail in Section 3.10.1.
Rather than accepting or rejecting the null hypothesis, we can compute a quantity related to how
likely the null hypothesis is to be true. In particular, we can compute a quantity called a p-value,
which is defined as
pval(t(D)) , Pr(t(D˜ ) ≥ t(D)|D ∼˜ H0) (3.86)
where D ∼˜ H0 is hypothetical future data. That is, the p-value is just the tail probability of observing
the value t(D) under the sampling distribution. (Note that the p-value does not explicitly depend
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.3. FREQUENTIST STATISTICS
on a model of the data, but most common test statistics implicitly define a model, as we discuss in
Section 3.10.3.)
A p-value is often interpreted as the likelihood of the data under the null hypothesis, so small
values are interpreted to mean that H0 is unlikely, and therefore that H1 is likely. The reasoning is
roughly as follows:
If H0 is true, then this test statistic would probably not occur. This statistic did occur.
Therefore H0 is probably false.
However, this is invalid reasoning. To see why, consider the following example (from [Coh94]):
If a person is an American, then he is probably not a member of Congress. This person is a
member of Congress. Therefore he is probably not an American.
This is obviously fallacious reasoning. By contrast, the following logical argument is valid reasoning:
If a person is a Martian, then he is not a member of Congress. This person is a member of
Congress. Therefore he is not a Martian.
The difference between these two cases is that the Martian example is using deduction, that is,
reasoning forward from logical definitions to their consequences. More precisely, this example uses a
rule from logic called modus tollens, in which we start out with a definition of the form P ⇒ Q;
when we observe ¬Q, we can conclude ¬P. By contrast, the American example concerns induction,
that is, reasoning backwards from observed evidence to probable (but not necessarily true) causes
using statistical regularities, not logical definitions.
To perform induction, we need to use probabilistic inference (as explained in detail in [Jay03]). In
particular, to compute the probability of the null hypothesis, we should use Bayes rule, as follows:
p(H0|D) = p(D|H0)p(H0)
p(D|H0)p(H0) + p(D|H1)p(H1)
(3.87)
If the prior is uniform, so p(H0) = p(H1) = 0.5, this can be rewritten in terms of the likelihood
ratio LR = p(D|H0)/p(D|H1) as follows:
p(H0|D) = LR
LR + 1
(3.88)
In the American Congress example, D is the observation that the person is a member of Congress.
The null hypothesis H0 is that the person is American, and the alternative hypothesis H1 is that the
person is not American. We assume that p(D|H0) is low, since most Americans are not members of
Congress. However, p(D|H1) is also low — in fact, in this example, it is 0, since only Americans can
be members of Congress. Hence LR = ∞, so p(H0|D) = 1.0, as intuition suggests.
Note, however, that NHST ignores p(D|H1) as well as the prior p(H0), so it gives the wrong results,
not just in this problem, but in many problems. Indeed, even most scientists misinterpret p-values.2
.
Consequently the journal The American Statistician published a whole special issue warning about
the use of p-values and NHST [WSL19], and several journals have even banned p-values [TM15;
AGM19].
2. See e.g., https://fivethirtyeight.com/features/not-even-scientists-can-easily-explain-p-values/.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license82
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.3.5.3 Discussion
The above problems stem from the fact that frequentist inference is not conditional on the actually
observed data, but instead is based on properties derived from the sampling distribution of the
estimator. However, conditional probability statements are what most people want. As Jim Berger
writes in [Ber85a]:
Users of statistics want to know the probability (after seeing the data) that a hypothesis is
true, or the probability that θ is in a given interval, and yet classical statistics does not allow
one to talk of such things. Instead, artificial concepts such as error probabilities and coverage
probabilites are introduced as substitutes. It is ironic that non-Bayesians often claim that the
Bayesians form a dogmatic unrealistic religion, when instead it is the non-Bayesian methods
that are often founded on elaborate and artificial structures. Unfortunately, those who become
used to these artificial structures come to view them as natural, and hence this line of argument
tends to have little effect on the established non-Bayesian. – Jim Berger, [Ber85a].
3.3.6 Why isn’t everyone a Bayesian?
I believe that it would be very difficult to persuade an intelligent person that current [frequentist]
statistical practice was sensible, but that there would be much less difficulty with an approach
via likelihood and Bayes’ theorem. — George Box, 1962 (quoted in [Jay76]).
In Section 3.3.5 we showed that inference based on frequentist principles can exhibit various forms
of counterintuitive behavior that can sometimes contradict common sense. Given these problems of
frequentist statistics, an obvious question to ask is: “Why isn’t everyone a Bayesian?” The statistician
Bradley Efron wrote a paper with exactly this title [Efr86]. His short paper is well worth reading for
anyone interested in this topic. Below we quote his opening section:
The title is a reasonable question to ask on at least two counts. First of all, everyone used to
be a Bayesian. Laplace wholeheartedly endorsed Bayes’s formulation of the inference problem,
and most 19th-century scientists followed suit. This included Gauss, whose statistical work is
usually presented in frequentist terms.
A second and more important point is the cogency of the Bayesian argument. Modern
statisticians, following the lead of Savage and de Finetti, have advanced powerful theoretical
arguments for preferring Bayesian inference. A byproduct of this work is a disturbing catalogue
of inconsistencies in the frequentist point of view.
Nevertheless, everyone is not a Bayesian. The current era (1986) is the first century in which
statistics has been widely used for scientific reporting, and in fact, 20th-century statistics is
mainly non-Bayesian. However, Lindley (1975) predicts a change for the 21st century.
Time will tell whether Lindley was right. However, the trends seem to be going in this direction.
Traditionally, computation has been a barrier to using Bayesian methods, but this is less of an issue
these days, due to faster computers and better algorithms, which we discuss in Part II.
Another, more fundamental, concern is that the Bayesian approach is only as correct as its modeling
assumptions. In particular, it is important to check sensitivity of the conclusions to the choice of prior
(and likelihood), using techniques such as Bayesian model checking (Section 3.9.1). In particular, as
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.4. CONJUGATE PRIORS
Donald Rubin wrote in his paper called “Bayesianly Justifiable and Relevant Frequency Calculations
for the Applied Statistician” [Rub84]:
The applied statistician should be Bayesian in principle and calibrated to the real world in
practice. [They] should attempt to use specifications that lead to approximately calibrated pro￾cedures under reasonable deviations from [their assumptions]. [They] should avoid models that
are contradicted by observed data in relevant ways — frequency calculations for hypothetical
replications can model a model’s adequacy and help to suggest more appropriate models.
A final issue is more practical. Most users of statistical methods are not experts in statistics,
but instead are experts in their own domain, such as psychology or social science. They often just
want a simple (and fast!) method for testing a hypothesis, and so they turn to standard “cookie
cutter” frequentist procedures, such as t-tests and χ
2
-tests. Fortunately there are simple Bayesian
alternatives to these tests, as we discuss in Section 3.10, which avoid the conceptual problems we
discussed in Section 3.3.5, and which can also be easily “upgraded” to use more complex (and realistic)
modeling assumptions when necessary. Furthermore, by using an empirical Bayes approach, it is
possible to derive automatic and robust Bayesian methods that have good frequentist properties but
which are also conditional on the data, thus providing the best of both worlds.
For a more detailed discussion of the pros and cons of the Bayesian approach, specifically in the
context of machine learning, see https://bit.ly/3Rbd4lo and https://bit.ly/3j8miSR.
3.4 Conjugate priors
In this section, we consider Bayesian inference for a class of models with a special form of prior,
known as a conjugate prior, which simplifies the computation of the posterior. Formally, we say
that a prior p(θ) ∈ F is a conjugate prior for a likelihood function p(D|θ) if the posterior is in
the same parameterized family as the prior, i.e., p(θ|D) ∈ F. In other words, F is closed under
Bayesian updating. If the family F corresponds to the exponential family (defined in Section 2.4),
then the computations can be performed in closed form. In more complex settings, we cannot perform
closed-form inference, but we can often leverage these results as tractable subroutines inside of a
larger computational pipeline.
3.4.1 The binomial model
One of the simplest examples of conjugate Bayesian analysis is the beta-binomial model. This is
covered in detail in Section 3.2.1.
3.4.2 The multinomial model
In this section, we generalize the results from Section 3.4.1 from binary variables (e.g., coins) to
K-ary variables (e.g., dice). Let y ∼ Cat(θ) be a discrete random variable drawn from a categorical
distribution. The likelihood has the form
p(D|θ) = Y
N
n=1
Cat(yn|θ) = Y
N
n=1
Y
C
c=1
θ
I(yn=c)
c =
Y
C
c=1
θ
Nc
c
(3.89)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license84
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where Nc =
P
n
I(yn = c). We can generalize this to the multinomial distribution by defining
y ∼ M(N, θ), where N is the number of trials, and yc = Nc is the number of times value c is
observed. The likelihood becomes
p(y|N, θ) = 
N
N1 . . . NC
Y
C
c=1
θ
Nc
c
(3.90)
This is the same as the categorical likelihood modulo a scaling factor. Going forwards, we will work
with the categorical model, for notational simplicity.
The conjugate prior for a categorical distribution is the Dirichlet distribution, which we discussed
in Section 2.2.5.7. We denote this by p(θ) = Dir(θ|
`α), where `α is the vector of prior pseudo-counts.
Often we use a symmetric Dirichlet prior of the form `αk=
`α /K. In this case, we have E [θk] = 1/K,
and V [θk] =
K−1
K2(`α+1) . Thus we see that increasing the prior sample size `α decreases the variance of
the prior, which is equivalent to using a stronger prior.
We can combine the multinomial likelihood and Dirichlet prior to compute the Dirichlet posterior,
as follows:
p(θ|D) ∝ p(D|θ)Dir(θ|
`α) ∝
"Y
k
θ
Nk
k
# "Y
k
θ
`αk−1
k
#
(3.91)
∝ Dir(θ|
`α1 +N1, . . . ,
`αK +NK) = Dir(θ|
aα) (3.92)
where aαk=
`αk +Nk are the parameters of the posterior. So we see that the posterior can be computed
by adding the empirical counts to the prior counts. In particular, the posterior mode is given by
ˆθk =
aαk −1
PK
k′=1
aαk −1
=
Nk+
`αk −1
PK
k′=1 Nk+
`αk −1
(3.93)
If we set αk = 1 we recover the MLE; if we set αk = 2, we recover the add-one smoothing estimate.
The marginal likelihood for the Dirichlet-categorical model is given by the following:
p(D) = B(N + α)
B(α)
(3.94)
where
B(α) =
QK
k=1 Γ(αk)
Γ(P
k αk)
(3.95)
Hence we can rewrite the above result in the following form, which is what is usually presented in
the literature:
p(D) = Γ(P
k αk)
Γ(N +
P
k αk)
Y
k
Γ(Nk + αk)
Γ(αk)
(3.96)
For more details on this model, see [Mur22, Sec 4.6.3].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.4. CONJUGATE PRIORS
3.4.3 The univariate Gaussian model
In this section, we derive the posterior p(µ, σ2
|D) for a univariate Gaussian. For simplicity, we consider
this in three steps: inferring just µ, inferring just σ
2
, and then inferring both. See Section 3.4.4 for
the multivariate case.
3.4.3.1 Posterior of µ given σ
2
If σ
2
is a known constant, the likelihood for µ has the form
p(D|µ) ∝ exp 
−
1
2σ
2
X
N
n=1
(yn − µ)
2
!
(3.97)
One can show that the conjugate prior is another Gaussian, N (µ| m` ,
`τ
2
). Applying Bayes’ rule for
Gaussians (Equation (2.121)), we find that the corresponding posterior is given by
p(µ|D, σ2
) = N (µ| ma ,
aτ
2
) (3.98)
aτ
2 =
1
N
σ2 +
1
`τ 2
=
σ
2 `τ
2
N
`τ
2 +σ
2
(3.99)
ma =
aτ
2

m`
`τ
2 +
Ny
σ
2

=
σ
2
N
`τ
2 +σ
2
m` +
N
`τ
2
N
`τ
2 +σ
2
y (3.100)
where y ,
1
N
PN
n=1 yn is the empirical mean.
This result is easier to understand if we work in terms of the precision parameters, which are
just inverse variances. Specifically, let λ = 1/σ2 be the observation precision, and `
λ= 1/
`τ
2 be the
precision of the prior. We can then rewrite the posterior as follows:
p(µ|D, λ) = N (µ| ma ,
a
λ
−1
) (3.101)
a
λ =
`
λ +Nλ (3.102)
ma =
Nλy+
`
λm`
a
λ
=
Nλ
Nλ+
`
λ
y +
`
λ
Nλ+
`
λ
m` (3.103)
These equations are quite intuitive: the posterior precision a
λ is the prior precision `
λ plus N units of
measurement precision λ. Also, the posterior mean ma is a convex combination of the empirical mean
y and the prior mean m` . This makes it clear that the posterior mean is a compromise between the
empirical mean and the prior. If the prior is weak relative to the signal strength (`
λ is small relative
to λ), we put more weight on the empirical mean. If the prior is strong relative to the signal strength
(
`
λ is large relative to λ), we put more weight on the prior. This is illustrated in Figure 3.5. Note
also that the posterior mean is written in terms of Nλx, so having N measurements each of precision
λ is like having one measurement with value x and precision Nλ.
To gain further insight into these equations, consider the posterior after seeing a single datapoint
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license86
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−5.0 −2.5 0.0 2.5 5.0
x
0.0
0.2
0.4
0.6
p(x)
Prior with variance of 1
prior
likelihood
posterior
(a)
−5.0 −2.5 0.0 2.5 5.0
x
0.0
0.2
0.4
0.6
p(x)
Prior with variance of 5
prior
likelihood
posterior
(b)
Figure 3.5: Inferring the mean of a univariate Gaussian with known σ
2
. (a) Using strong prior, p(µ) =
N (µ|0, 1). (b) Using weak prior, p(µ) = N (µ|0, 5). Generated by gauss_infer_1d.ipynb.
y (so N = 1). Then the posterior mean can be written in the following equivalent ways:
ma =
`
λ
a
λ
m` +
λ
a
λ
y (3.104)
=m` +
λ
a
λ
(y− m` ) (3.105)
= y −
`
λ
a
λ
(y− m` ) (3.106)
The first equation is a convex combination of the prior mean and the data. The second equation
is the prior mean adjusted towards the data y. The third equation is the data adjusted towards
the prior mean; this is called a shrinkage estimate. This is easier to see if we define the weight
w =
`
λ/
a
λ. Then we have
ma = y − w(y− m` ) = (1 − w)y + w m` (3.107)
Note that, for a Gaussian, the posterior mean and posterior mode are the same. Thus we can use
the above equations to perform MAP estimation.
3.4.3.2 Posterior of σ
2 given µ
If µ is a known constant, the likelihood for σ
2 has the form
p(D|σ
2
) ∝ (σ
2
)
−N/2
exp 
−
1
2σ
2
X
N
n=1
(yn − µ)
2
!
(3.108)
where we can no longer ignore the 1/(σ
2
) term in front. The standard conjugate prior is the inverse
gamma distribution (Section 2.2.3.4), given by
IG(σ
2
|
`a,
`
b) =
`
b
`a
Γ(`a)
(σ
2
)
−(`a+1) exp(−
`
b
σ
2
) (3.109)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.4. CONJUGATE PRIORS
0.0 2.5 5.0 7.5 10.0 12.5 15.0
σ
2
0.0
0.2
0.4
prior = IG(ν = 0), true σ
2 = 10
N = 2
N = 5
N = 50
N = 100
Figure 3.6: Sequential updating of the posterior for σ
2
starting from an uninformative prior. The data
was generated from a Gaussian with known mean µ = 5 and unknown variance σ
2 = 10. Generated by
gauss_seq_update_sigma_1d.ipynb
Multiplying the likelihood and the prior, we see that the posterior is also IG:
p(σ
2
|µ, D) = IG(σ
2
|
aa,
a
b) (3.110)
aa =
`a +N/2 (3.111)
a
b =
`
b +
1
2
X
N
n=1
(yn − µ)
2
(3.112)
See Figure 3.6 for an illustration.
One small annoyance with using the IG(
`a,
`
b) distribution is that the strength of the prior is
encoded in both `a and `
b. Therefore, in the Bayesian statistics literature it is common to use an
alternative parameterization of the IG distribution, known as the (scaled) inverse chi-squared
distribution:
χ
−2
(σ
2
|
`ν,
`τ
2
) = IG(σ
2
|
`ν
2
,
`ν
`τ
2
2
) ∝ (σ
2
)
−`ν /2−1
exp(−
`ν
`τ
2
2σ
2
) (3.113)
Here `ν (called the degrees of freedom or dof parameter) controls the strength of the prior, and `τ
2
encodes the prior mean. With this prior, the posterior becomes
p(σ
2
|D, µ) = χ
−2
(σ
2
|
aν,
aτ
2
) (3.114)
aν =
`ν +N (3.115)
aτ
2 =
`ν
`τ
2 +
PN
n=1(yn − µ)
2
aν
(3.116)
We see that the posterior dof aν is the prior dof `ν plus N, and the posterior sum of squares aν
aτ
2
is
the prior sum of squares `ν
`τ
2 plus the data sum of squares.
3.4.3.3 Posterior of µ and σ
2
: conjugate prior
Now suppose we want to infer both the mean and variance. The corresponding conjugate prior is the
normal inverse gamma:
NIG(µ, σ2
| m` ,
`κ,
`a,
`
b) , N (µ| m` , σ2
/
`κ) IG(σ
2
|
`a,
`
b) (3.117)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license88
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0.5
0.0
0.5
1.0
2
0.5
1.0
1.5
2.0
0.05
0.10
0.15
0.20
0.25
0.30
(a) NIχ2
(µ0 = 0, κ0 = 1, ν0 = 1, σ2
0 = 1)
0.5
0.0
0.5
1.0
2
0.5
1.0
1.5
2.0
0.0
0.2
0.4
0.6
(b) NIχ2
(µ0 = 0, κ0 = 5, ν0 = 1, σ2
0 = 1)
Figure 3.7: The NIχ2
(µ, σ2
|m, κ, ν, σ2
) distribution. m is the prior mean and κ is how strongly we believe
this; σ
2
is the prior variance and ν is how strongly we believe this. (a) m = 0, κ = 1, ν = 1, σ2 = 1. Notice
that the contour plot (underneath the surface) is shaped like a “squashed egg”. (b) We increase the strength of
our belief in the mean by setting κ = 5, so the distribution for µ around m = 0 becomes narrower. Generated
by nix_plots.ipynb.
However, it is common to use a reparameterization of this known as the normal inverse chi-squared
or NIX distribution [Gel+14a, p67], which is defined by
NIχ2
(µ, σ2
| m` ,
`κ,
`ν,
`τ
2
) , N (µ| m` , σ2
/
`κ) χ
−2
(σ
2
|
`ν,
`τ
2
) (3.118)
∝ (
1
σ
2
)
(`ν +3)/2
exp 
−
`ν
`τ
2 +
`κ (µ− m` )
2
2σ
2

(3.119)
See Figure 3.7 for some plots. Along the µ axis, the distribution is shaped like a Gaussian, and along
the σ
2 axis, the distribution is shaped like a χ
−2
; the contours of the joint density have a “squashed
egg” appearance. Interestingly, we see that the contours for µ are more peaked for small values of
σ
2
, which makes sense, since if the data is low variance, we will be able to estimate its mean more
reliably.
One can show (based on Section 3.4.4.3) that the posterior is given by
p(µ, σ2
|D) = NIχ2
(µ, σ2
| ma ,
aκ,
aν,
aτ
2
) (3.120)
ma =
`κm` +Nx
aκ
(3.121)
aκ =
`κ +N (3.122)
aν =
`ν +N (3.123)
aν
aτ
2 =
`ν
`τ
2 +
X
N
n=1
(yn − y)
2 +
N
`κ
`κ +N
(m` −y)
2
(3.124)
The interpretation of this is as follows. For µ, the posterior mean ma is a convex combination of
the prior mean m` and the MLE x; the strength of this posterior, aκ, is the prior strength `κ plus the
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.4. CONJUGATE PRIORS
number of datapoints N. For σ
2
, we work instead with the sum of squares: the posterior sum of
squares,
aν
aτ
2
, is the prior sum of squares `ν
`τ
2 plus the data sum of squares, PN
n=1(yn − y)
2
, plus
a term due to the discrepancy between the prior mean m` and the MLE y. The strength of this
posterior, aν, is the prior strength `ν plus the number of datapoints N;
The posterior marginal for σ
2
is just
p(σ
2
|D) = Z
p(µ, σ2
|D)dµ = χ
−2
(σ
2
|
aν,
aτ
2
) (3.125)
with the posterior mean given by E

σ
2
|D
=
aν
aν −2
aτ
2
.
The posterior marginal for µ has a Student distribution, which follows from the fact that the
Student distribution is a (scaled) mixture of Gaussians:
p(µ|D) = Z
p(µ, σ2
|D)dσ2 = T (µ| ma ,
aτ
2
/
aκ,
aν) (3.126)
with the posterior mean given by E [µ|D] =ma .
3.4.3.4 Posterior of µ and σ
2
: uninformative prior
If we “know nothing” about the parameters a priori, we can use an uniformative prior. We discuss how
to create such priors in Section 3.5. A common approach is to use a Jeffreys prior. In Section 3.5.2.3,
we show that the Jeffreys prior for a location and scale parameter has the form
p(µ, σ2
) ∝ p(µ)p(σ
2
) ∝ σ
−2
(3.127)
We can simulate this with a conjugate prior by using
p(µ, σ2
) = NIχ2
(µ, σ2
| m` = 0,
`κ= 0,
`ν= −1,
`τ
2= 0) (3.128)
With this prior, the posterior has the form
p(µ, σ2
|D) = NIχ2
(µ, σ2
| ma = y,
aκ= N, aν= N − 1,
aτ
2= s
2
) (3.129)
where
s
2 ,
1
N − 1
X
N
n=1
(yn − y)
2 =
N
N − 1
σˆ
2
mle (3.130)
s is known as the sample standard deviation. Hence the marginal posterior for the mean is given
by
p(µ|D) = T (µ|y,
s
2
N
, N − 1) = T (µ|y,
PN
n=1(yn − y)
2
N(N − 1) , N − 1) (3.131)
Thus the posterior variance of µ is
V [µ|D] =
aν
aν −2
aτ
2=
N − 1
N − 3
s
2
N
→
s
2
N
(3.132)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license90
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The square root of this is called the standard error of the mean:
se(µ) ,
p
V [µ|D] ≈
s
√
N
(3.133)
Thus we can approximate the 95% credible interval for µ using
I.95(µ|D) = y ± 2
s
√
N
(3.134)
3.4.4 The multivariate Gaussian model
In this section, we derive the posterior p(µ, Σ|D) for a multivariate Gaussian. For simplicity, we
consider this in three steps: inferring just µ, inferring just Σ, and then inferring both.
3.4.4.1 Posterior of µ given Σ
The likelihood has the form
p(D|µ) = N (y|µ,
1
N
Σ) (3.135)
For simplicity, we will use a conjugate prior, which in this case is a Gaussian. In particular,
if p(µ) = N (µ| m` ,
`
V) then we can derive a Gaussian posterior for µ based on the results in
Section 2.3.2.2 We get
p(µ|D, Σ) = N (µ| ma ,
a
V) (3.136)
a
V
−1
=
`
V
−1
+NΣ
−1
(3.137)
ma =
a
V (Σ
−1
(Ny)+ `
V
−1
m` ) (3.138)
Figure 3.8 gives a 2d example of these results.
3.4.4.2 Posterior of Σ given µ
We now discuss how to compute p(Σ|D, µ).
Likelihood
We can rewrite the likelihood as follows:
p(D|µ, Σ) ∝ |Σ|
− N
2 exp 
−
1
2
tr(SµΣ
−1
)

(3.139)
where
Sµ ,
X
N
n=1
(yn − µ)(yn − µ)
T
(3.140)
is the scatter matrix around µ.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.4. CONJUGATE PRIORS
0 1
y1
−1
0
1
y2
Data
(a)
−1 0 1
z1
−1
0
1
z2
Prior
0.00
0.53
1.06
1.59
(b)
−1 0 1
z1
−1
0
1
z2
Posterior after 10 points
0.00
6.04
12.09
18.13
(c)
Figure 3.8: Illustration of Bayesian inference for a 2d Gaussian random vector z. (a) The data is generated
from yn ∼ N (z, Σy), where z = [0.5, 0.5]T
and Σy = 0.1([2, 1; 1, 1]). We assume the sensor noise covariance
Σy is known but z is unknown. The black cross represents z. (b) The prior is p(z) = N (z|0, 0.1I2). (c) We
show the posterior after 10 datapoints have been observed. Generated by gauss_infer_2d.ipynb.
Prior
The conjugate prior is known as the inverse Wishart distribution, which is a distribution over
positive definite matrices, as we explained in Section 2.2.5.5. This has the following pdf:
IW(Σ|
`
Ψ,
`ν) ∝ |Σ|
−(`ν +D+1)/2
exp 
−
1
2
tr( `
Ψ Σ
−1
)

(3.141)
Here `ν> D − 1 is the degrees of freedom (dof), and `
Ψ is a symmetric pd matrix. We see that `
Ψ
plays the role of the prior scatter matrix, and N0 ,
`ν +D + 1 controls the strength of the prior, and
hence plays a role analogous to the sample size N.
Posterior
Multiplying the likelihood and prior we find that the posterior is also inverse Wishart:
p(Σ|D, µ) ∝ |Σ|
− N
2 exp 
−
1
2
tr(Σ
−1Sµ)

|Σ|
−(`ν +D+1)/2
exp 
−
1
2
tr(Σ
−1 `
Ψ)

(3.142)
= |Σ|
−
N+(`ν +D+1)
2 exp 
−
1
2
tr h
Σ
−1
(Sµ+
`
Ψ)
i
(3.143)
= IW(Σ|
a
Ψ,
aν) (3.144)
aν =
`ν +N (3.145)
a
Ψ =
`
Ψ +Sµ (3.146)
In words, this says that the posterior strength aν is the prior strength `ν plus the number of observations
N, and the posterior scatter matrix a
Ψ is the prior scatter matrix `
Ψ plus the data scatter matrix Sµ.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license92
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.4.4.3 Posterior of Σ and µ
In this section, we compute p(µ, Σ|D) using a conjugate prior.
Likelihood
The likelihood is given by
p(D|µ, Σ) ∝ |Σ|
− N
2 exp 
−
1
2
X
N
n=1
(yn − µ)
TΣ
−1
(yn − µ)
!
(3.147)
One can show that
X
N
n=1
(yn − µ)
TΣ
−1
(yn − µ) = tr(Σ
−1S) + N(y − µ)
TΣ
−1
(y − µ) (3.148)
where
S , Sy =
X
N
n=1
(yn − y)(yn − y)
T = YTCN Y (3.149)
is empirical scatter matrix, and CN is the centering matrix
CN , IN −
1
N
1N 1
T
N (3.150)
Hence we can rewrite the likelihood as follows:
p(D|µ, Σ) ∝ |Σ|
− N
2 exp 
−
N
2
(µ − y)
TΣ
−1
(µ − y)

exp 
−
1
2
tr(Σ
−1S)

(3.151)
We will use this form below.
Prior
The obvious prior to use is the following
p(µ, Σ) = N (µ| m` ,
`
V)IW(Σ|
`
Ψ,
`ν) (3.152)
where IW is the inverse Wishart distribution. Unfortunately, µ and Σ appear together in a non￾factorized way in the likelihood in Equation (3.151) (see the first exponent term), so the factored
prior in Equation (3.152) is not conjugate to the likelihood.3
The above prior is sometimes called conditionally conjugate, since both conditionals, p(µ|Σ) and
p(Σ|µ), are individually conjugate. To create a fully conjugate prior, we need to use a prior where µ
and Σ are dependent on each other. We will use a joint distribution of the form p(µ, Σ) = p(µ|Σ)p(Σ).
3. Using the language of directed graphical models, we see that µ and Σ become dependent when conditioned on D
due to explaining away. See Figure 3.9(a).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.4. CONJUGATE PRIORS
xi
µ Σ
m V Ψ ν
(a)
xi
µ Σ
m κ Ψ ν
(b)
Figure 3.9: Graphical models representing different kinds of assumptions about the parameter priors. (a) A
semi-conjugate prior for a Gaussian. (b) A conjugate prior for a Gaussian.
Looking at the form of the likelihood equation, Equation (3.151), we see that a natural conjugate
prior has the form of a normal-inverse-Wishart or NIW distribution, defined as follows:
NIW(µ, Σ| m` ,
`κ,
`ν,
`
Ψ) , N (µ| m` ,
1
`κ
Σ) × IW(Σ|
`
Ψ,
`ν) (3.153)
=
1
ZNIW
|Σ|
− 1
2 exp 
−
`κ
2
(µ− m` )
TΣ
−1
(µ− m` )

× |Σ|
−
`ν +D+1
2 exp 
−
1
2
tr(Σ
−1 `
Ψ)

(3.154)
where the normalization constant is given by
ZNIW , 2
`ν D/2ΓD(
`ν /2)(2π/ `κ)
D/2
|
`
Ψ |
−`ν /2
(3.155)
The parameters of the NIW can be interpreted as follows: m` is our prior mean for µ, and `κ is how
strongly we believe this prior; `
Ψ is (proportional to) our prior mean for Σ, and `ν is how strongly we
believe this prior.4
Posterior
To derive the posterior, let us first rewrite the scatter matrix as follows:
S = YTY −
1
N
(
X
N
n=1
yn)(X
N
n=1
yn)
T = YTY − Nyy
T
(3.156)
where YTY =
PN
n=1 yny
T
n
is the sum of squares matrix.
4. Note that our uncertainty in the mean is proportional to the covariance. In particular, if we believe that the variance
is large, then our uncertainty in µ must be large too. This makes sense intuitively, since if the data has large spread, it
will be hard to pin down its mean.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license94
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Now we can multiply the likelihood and the prior to give
p(µ, Σ|D) ∝ |Σ|
− N
2 exp 
−
N
2
(µ − y)
TΣ
−1
(µ − y)

exp 
−
1
2
tr(Σ
−1S)

(3.157)
× |Σ|
−
`ν +D+2
2 exp 
−
`κ
2
(µ− m` )
TΣ
−1
(µ− m` )

exp 
−
1
2
tr(Σ
−1 `
Ψ)

(3.158)
= |Σ|
−(N+`ν +D+2)/2
exp(−
1
2
tr(Σ
−1M)) (3.159)
where
M , N(µ − y)(µ − y)
T+
`κ (µ− m` )(µ− m` )
T + S+
`
Ψ (3.160)
= (`κ +N)µµ
T − µ(
`κm` +Ny)
T − (
`κm` +Ny)µ
T+
`κm` m` T +YTY+
`
Ψ (3.161)
We can simplify the M matrix using a trick called completing the square. Applying this to the
above, we have
(
`κ +N)µµT − µ(
`κm` +Ny)
T − (
`κm` +Ny)µ
T
(3.162)
= (`κ +N)

µ −
`κm` +Ny
`κ +N
 µ −
`κm` +Ny
`κ +N
T
(3.163)
−
(
`κm` +Ny)(`κm` +Ny)
T
`κ +N
(3.164)
=
aκ (µ− ma )(µ− ma )
T−
aκma ma T
(3.165)
Hence we can rewrite the posterior as follows:
p(µ, Σ|D) ∝ |Σ|
(aν +D+2)/2
exp 
−
1
2
tr h
Σ
−1

aκ (µ− ma )(µ− ma )
T+
a
Ψ
i
(3.166)
= NIW(µ, Σ| ma ,
aκ,
aν,
a
Ψ) (3.167)
where
ma =
`κm` +Ny
aκ
=
`κ
`κ +N
m` +
N
`κ +N
y (3.168)
aκ =
`κ +N (3.169)
aν =
`ν +N (3.170)
a
Ψ =
`
Ψ +S +
`κ N
`κ +N
(y− m` )(y− m` )
T
(3.171)
=
`
Ψ +YTY+
`κm` m` T −
aκma ma T
(3.172)
This result is actually quite intuitive: the posterior mean ma is a convex combination of the prior
mean and the MLE; the posterior scatter matrix a
Ψ is the prior scatter matrix `
Ψ plus the empirical
scatter matrix S plus an extra term due to the uncertainty in the mean (which creates its own virtual
scatter matrix); and the posterior confidence factors aκ and aν are both incremented by the size of the
data we condition on.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.4. CONJUGATE PRIORS
Posterior marginals
We have computed the joint posterior
p(µ, Σ|D) = N (µ|Σ, D)p(Σ|D) = N (µ| ma ,
1
aκ
Σ)IW(Σ|
a
Ψ,
aν) (3.173)
We now discuss how to compute the posterior marginals, p(Σ|D) and p(µ|D).
It is easy to see that the posterior marginal for Σ is
p(Σ|D) = Z
p(µ, Σ|D)dµ = IW(Σ|
a
Ψ,
aν) (3.174)
For the mean, one can show that
p(µ|D) = Z
p(µ, Σ|D)dΣ = T (µ|
aµ,
a
Ψ
aκ
aν
′
,
aν
′
) (3.175)
where aν
′,
aν −D + 1. Intuitively this result follows because p(µ|D) is an infinite mixture of Gaussians,
where each mixture component has a value of Σ drawn from the IW distribution; by mixing these
altogether, we induce a Student distribution, which has heavier tails than a single Gaussian.
Posterior mode
The maximum a posteriori (MAP) estimate of µ and Σ is the mode of the posterior NIW distribution
with density
p(µ, Σ|Y) = N (µ|
aµ,
aκ
−1 Σ)IW(Σ|
aν,
a
Ψ) (3.176)
To find the mode, we firstly notice that µ only appears in the conditional distribution N (µ|
aµ,
aκ
−1 Σ),
and the mode of this normal distribution equals its mean, i.e., µ =
aµ. Also notice that this holds for
any choice of Σ. So we can plug µ =
aµ in Equation (3.176) and derive the mode of Σ. Notice that
−2 ∗ log p(µ =
aµ, Σ|Y) = (aν +D + 2) log(|Σ|) + tr( a
Ψ Σ−1
) + c (3.177)
where c is a constant irrelevant to Σ. We then take the derivative over Σ:
∂ log p(µ =
aµ Σ|Y)
∂Σ
= (aν +D + 2)Σ
−1 − Σ
−1 a
Ψ Σ
−1
(3.178)
By setting the derivative to 0 and solving for Σ, we see that (
aν +D + 2)−1 a
Ψ is the matrix that
maximizes Equation (3.177). By checking that a
Ψ is a positive definite matrix, we conclude that a
Ψ is
the MAP estimate of the covariance matrix Σ.
In conclusion, the MAP estimate of {µ, Σ} are
µˆ =
`κ
`µ +Ny¯
`κ +N
(3.179)
Σˆ =
1
aν +D + 2
a
Ψ (3.180)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license96
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Posterior predictive
We now discuss how to predict future data by integrating out the parameters. If y ∼ N (µ, Σ), where
(µ, Σ|D) ∼ NIW(ma ,
aκ,
aν,
a
Ψ), then one can show that the posterior predictive distribution, for a
single observation vector, is as follows:
p(y|D) = Z
N (x|µ, Σ)NIW(µ, Σ| ma ,
aκ,
aν,
a
Ψ)dµdΣ (3.181)
= T (y| ma ,
a
Ψ (
aκ +1)
aκ
aν
′
,
aν
′
) (3.182)
where aν
′=
aν −D + 1.
3.4.5 The exponential family model
We have seen that exact Bayesian analysis is considerably simplified if the prior is conjugate to the
likelihood. Since the posterior must have the same form as the prior, and hence the same number of
parameters, the likelihood function must have fixed-sized sufficient statistics, so that we can write
p(D|θ) = p(s(D)|θ). This suggests that the only family of distributions for which conjugate priors
exist is the exponential family, a result proved in [DY79].5
In the sections below, we show how to
perform conjugate analysis for a generic exponential family model.
3.4.5.1 Likelihood
Recall that the likelihood of the exponential family is given by
p(D|η) = h(D) exp(η
T
s(D) − NA(η)) (3.183)
where s(D) = PN
n=1 s(xn) and h(D) ,
QN
n=1 h(xn).
3.4.5.2 Prior
Let us write the prior in a form that mirrors the likelihood:
p(η|
`τ ,
`ν) = 1
Z(
`τ ,
`ν)
exp(
`τ
T
η−
`ν A(η)) (3.184)
where `ν is the strength of the prior, and `τ /
`ν is the prior mean, and Z(
`τ ,
`ν) is a normalizing factor.
The parameters `τ can be derived from virtual samples representing our prior beliefs.
5. There are some exceptions. For example, the uniform distribution Unif(x|0, θ) has finite sufficient statistics
(N, m = maxi xi), as discussed in Section 2.4.2.6; hence this distribution has a conjugate prior, namely the Pareto
distribution (Section 2.2.3.5), p(θ) = Pareto(θ|θ0, κ), yielding the posterior p(θ|x) = Pareto(max(θ0, m), κ + N).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.4. CONJUGATE PRIORS
3.4.5.3 Posterior
The posterior is given by
p(η|D) = p(D|η)p(η)
p(D)
(3.185)
=
h(D)
Z(
`τ ,
`ν)p(D)
exp ￾
(
`τ +s(D))Tη − (
`ν +N)A(η)

(3.186)
=
1
Z(
aτ ,
aν)
exp 
aτ
T
η−
aν A(η)

(3.187)
where
aτ =
`τ +s(D) (3.188)
aν =
`ν +N (3.189)
Z(
aτ ,
aν) = Z(
`τ ,
`ν)
h(D)
p(D) (3.190)
We see that this has the same form as the prior, but where we update the sufficient statistics and the
sample size.
The posterior mean is given by a convex combination of the prior mean and the empirical mean
(which is the MLE):
E [η|D] =
aτ
aν
=
`τ +s(D)
`ν +N
=
`ν
`ν +N
`τ
`ν
+
N
`ν +N
s(D)
N
(3.191)
= λE [η] + (1 − λ)ηˆmle (3.192)
where λ =
`ν
`ν +N
.
3.4.5.4 Marginal likelihood
From Equation (3.190) we see that the marginal likelihood is given by
p(D) = Z(
aτ ,
aν)h(D)
Z(
`τ ,
`ν)
(3.193)
See Section 3.2.1.9 for a detailed example in the case of the beta-Bernoulli model.
3.4.5.5 Posterior predictive density
We now derive the predictive density for future observables D′ = (x˜1, . . . , x˜N′ ) given past data
D = (x1, . . . , xN ):
p(D
′
|D) = Z
p(D
′
|η)p(η|D)dη (3.194)
=
Z
h(D
′
) exp(η
T
s(D
′
) − N
′A(η)) 1
Z(
aτ ,
aν)
exp(η
T aτ −
aν A(η))dη (3.195)
= h(D
′
)
Z(
`τ +s(D) + s(D′
),
`ν +N + N′
)
Z(
`τ +s(D),
`ν +N)
(3.196)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens98
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.4.5.6 Example: Bernoulli distribution
As a simple example, let us revisit the Beta-Bernoulli model in our new notation.
The likelihood is given by
p(D|θ) = (1 − θ)
N exp 
log( θ
1 − θ
)
X
i
xn
!
(3.197)
Hence the conjugate prior is given by
p(θ|ν0, τ0) ∝ (1 − θ)
ν0 exp 
log( θ
1 − θ
)τ0

(3.198)
= θ
τ0
(1 − θ)
ν0−τ0
(3.199)
If we define α = τ0 + 1 and β = ν0 − τ0 + 1, we see that this is a beta distribution.
We can derive the posterior as follows, where s =
P
i
I(xi = 1) is the sufficient statistic:
p(θ|D) ∝ θ
τ0+s
(1 − θ)
ν0−τ0+n−s
(3.200)
= θ
τn (1 − θ)
νn−τn (3.201)
We can derive the posterior predictive distribution as follows. Assume p(θ) = Beta(θ|α, β), and
let s = s(D) be the number of heads in the past data. We can predict the probability of a given
sequence of future heads, D′ = (x˜1, . . . , x˜m), with sufficient statistic s
′ =
Pm
n=1 I(˜xi = 1), as follows:
p(D
′
|D) = Z 1
0
p(D
′
|θ|Beta(θ|αn, βn)dθ (3.202)
=
Γ(αn + βn)
Γ(αn)Γ(βn)
Z 1
0
θ
αn+t
′−1
(1 − θ)
βn+m−t
′−1
dθ (3.203)
=
Γ(αn + βn)
Γ(αn)Γ(βn)
Γ(αn+m)Γ(βn+m)
Γ(αn+m + βn+m)
(3.204)
where
αn+m = αn + s
′ = α + s + s
′
(3.205)
βn+m = βn + (m − s
′
) = β + (n − s) + (m − s
′
) (3.206)
3.4.6 Beyond conjugate priors
We have seen various examples of conjugate priors, all of which have come from the exponential
family (see Section 2.4). These priors have the advantages of being easy to interpret (in terms of
sufficient statistics from a virtual prior dataset), and being easy to compute with. However, for most
models, there is no prior in the exponential family that is conjugate to the likelihood. Furthermore,
even where there is a conjugate prior, the assumption of conjugacy may be too limiting. Therefore
in the sections below, we briefly discuss various other kinds of priors. (We defer the question of
posterior inference with these priors until Section 7.1, where we discuss algorithmic issues, since we
can no longer use closed-form solutions when the prior is not conjugate.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.4. CONJUGATE PRIORS
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
mixture of Beta distributions
prior
posterior
Figure 3.10: A mixture of two Beta distributions. Generated by mixbetademo.ipynb.
3.4.6.1 Mixtures of conjugate priors
In this section, we show how we can create a mixture of conjugate priors for increased modeling
flexibility. Fortunately, the resulting mixture prior is still conjugate.
As an example, suppose we want to predict the outcome of a coin toss at a casino, and we believe
that the coin may be fair, but it may also be biased towards heads. This prior cannot be represented
by a beta distribution. Fortunately, it can be represented as a mixture of beta distributions. For
example, we might use
p(θ) = 0.5 Beta(θ|20, 20) + 0.5 Beta(θ|30, 10) (3.207)
If θ comes from the first distribution, the coin is fair, but if it comes from the second, it is biased
towards heads.
We can represent a mixture by introducing a latent indicator variable h, where h = k means that
θ comes from mixture component k. The prior has the form
p(θ) = X
k
p(h = k)p(θ|h = k) (3.208)
where each p(θ|h = k) is conjugate, and p(h = k) are called the (prior) mixing weights. One can
show that the posterior can also be written as a mixture of conjugate distributions as follows:
p(θ|D) = X
k
p(h = k|D)p(θ|D, h = k) (3.209)
where p(h = k|D) are the posterior mixing weights given by
p(h = k|D) = p(h = k)p(D|h = k)
P
k′ p(h = k
′)p(D|h = k
′)
(3.210)
Here the quantity p(D|h = k) is the marginal likelihood for mixture component k (see Section 3.2.1.9).
Returning to our example above, if we have the prior in Equation (3.207), and we observe N1 = 20
heads and N0 = 10 tails, then, using Equation (3.31), the posterior becomes
p(θ|D) = 0.346 Beta(θ|40, 30) + 0.654 Beta(θ|50, 20) (3.211)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license100
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
See Figure 3.10 for an illustration.
We can compute the posterior probability that the coin is biased towards heads as follows:
Pr(θ > 0.5|D) = X
k
Pr(θ > 0.5|D, h = k)p(h = k|D) = 0.9604 (3.212)
If we just used a single Beta(20,20) prior, we would get a slightly smaller value of Pr(θ > 0.5|D) =
0.8858. So if we were “suspicious” initially that the casino might be using a biased coin, our fears
would be confirmed more quickly than if we had to be convinced starting with an open mind.
3.4.6.2 Robust (heavy-tailed) priors
The assessment of the influence of the prior on the posterior is called sensitivity analysis, or
robustness analysis. There are many ways to create robust priors. (see e.g., [IR00]). Here we
consider a simple approach, namely the use of a heavy-tailed distribution.
To motivate this, let us consider an example from [Ber85a, p7]. Suppose x ∼ N (θ, 1). We observe
that x = 5 and we want to estimate θ. The MLE is of course ˆθ = 5, which seems reasonable. The
posterior mean under a uniform prior is also θ = 5. But now suppose we know that the prior median
is 0, and that there is 25% probability that θ lies in any of the intervals (−∞, −1), (−1, 0), (0, 1),
(1, ∞). Let us also assume the prior is smooth and unimodal.
One can show that a Gaussian prior of the form N (θ|0, 2.192
) satisfies these prior constraints. But
in this case the posterior mean is given by 3.43, which doesn’t seem very satisfactory. An alternative
distribution that captures the same prior information is the Cauchy prior T1(θ|0, 1). With this prior,
we find (using numerical method integration: see robust_prior_demo.ipynb for the code) that the
posterior mean is about 4.6, which seems much more reasonable. In general, priors with heavy tails
tend to give results which are more sensitive to the data, which is usually what we desire.
Heavy-tailed priors are usually not conjugate. However, we can often approximate a heavy-tailed
prior by using a (possibly infinite) mixture of conjugate priors. For example, in Section 28.2.3, we
show that the Student distribution (of which the Cauchy is a special case) can be written as an
infinite mixture of Gaussians, where the mixing weights come from a gamma distribution. This is an
example of a hierarchical prior; see Section 3.6 for details.
3.4.6.3 Priors for scalar variances
In this section, we discuss some commonly used priors for variance parameters. Such priors play
an important role in determining how much regularization a model exhibits. For example, consider
a linear regression model, p(y|x, w, σ2
) = N (y|wTx, σ2
). Suppose we use a Gaussian prior on the
weights, p(w) = N (w|0, τ 2
I). The value of τ
2
(relative to σ
2
) plays a role similar to the strength
of an ℓ2-regularization term in ridge regression. In the Bayesian setting, we need to ensure we use
sensible priors for the variance parameters, τ
2 and σ
2
. This becomes even more important when we
discuss hierarchical models, in Section 3.6.
We start by considering the simple problem of inferting a variance parameter σ
2
from a Gaussian
likelihood with known mean, as in Section 3.4.3.2. The uninformative prior is p(σ
2
) = IG(σ
2
|0, 0),
which is improper, meaning it does not integrate to 1. This is fine as long as the posterior is proper.
This will be the case if the prior is on the variance of the noise of N ≥ 2 observable variables.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.4. CONJUGATE PRIORS
Unfortunately the posterior is not proper, even if N → ∞, if we use this prior for the variance of the
(non observable) weights in a regression model [Gel06; PS12], as we discuss in Section 3.6.
One solution to this is to use a weakly informative proper prior such as IG(ǫ, ǫ) for small ǫ.
However, this turns out to not work very well, for reasons that are explained in [Gel06; PS12]. Instead,
it is recommended to use other priors, such as uniform, exponential, half-normal, half-Student-t, or
half-Cauchy; all of these are bounded below by 0, and just require 1 or 2 hyperparameters. (The
term “half” refers to the fact that the distribution is “folded over” onto itself on the positive side of
the real axis.)
3.4.6.4 Priors for covariance matrices
The conjugate prior for a covariance matrix is the inverse Wishart (Section 2.2.5.6). However, it can
be hard to set the parameters for this in an uninformative way. One approach, discussed in [HW13],
is to use a scale mixture of inverse Wisharts, where the scaling parameters have inverse gamma
distributions. It is possible to choose shape and scale parameters to ensure that all the correlation
parameters have uniform (−1, 1) marginals, and all the standard deviations have half-Student
distributions.
Unfortunately, the Wishart distribution has heavy tails, which can lead to poor performance
when used in a sampling algorithm.6 A more common approach, following Equation (3.213), is to
represent the D × D covariance matrix Σ in terms of a product of the marginal standard deviations,
σ = (σ1, . . . , σD), and the D × D correlation matrix R, as follows:
Σ = diag(σ) R diag(σ) (3.213)
For example, if D = 2 ,we have
Σ =

σ1 0
0 σ2
 1 ρ
ρ 1
 σ1 0
0 σ2

=

σ
2
1 ρσ1σ2
ρσ1σ2 σ
2
2

(3.214)
We can put a factored prior on the standard deviations, following the recommendations of Sec￾tion 3.4.6.3. For example,
p(σ) = Y
D
d=1
Expon(σd|1) (3.215)
For the correlation matrix, it is common to use as a prior the LKJ distribution, named after the
authors of [LKJ09]. This has the form
LKJ(R|η) ∝ |R|
η−1
(3.216)
so it only has one free parameter. When η = 1, it is a uniform prior; when η = 2, it is a “weakly
regularizing” prior, that encourages small correlations (close to 0). See Figure 3.11 for a plot.
In practice, it is more common to define R in terms of its Cholesky decomposition, R = LLT,
where L is an unconstrained lower triangular matrix. We then represent the prior using
LKJchol(L|η) ∝ |L|
−η−1
(3.217)
6. See comments from Michael Betancourt at https://github.com/pymc-devs/pymc/issues/538.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license102
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−1 0 1
Correlation
0.0
0.5
1.0
Density
LKJ 1D Correlation Coef.
η = 1
η = 2
η = 4
Figure 3.11: Distribution on the correlation coefficient ρ induced by a 2d LKJ distribution with varying
parameter. Adapted from Figure 14.3 of [McE20]. Generated by lkj_1d.ipynb.
3.5 Noninformative priors
When we have little or no domain specific knowledge, it is desirable to use an uninformative,
noninformative, or objective priors, to “let the data speak for itself”. Unfortunately, there is no
unique way to define such priors, and they all encode some kind of knowledge. It is therefore better
to use the term diffuse prior, minimally informative prior, or default prior.
In the sections below, we briefly mention some common approaches for creating default priors. For
further details, see e.g., [KW96] and the Stan website.7
3.5.1 Maximum entropy priors
A natural way to define an uninformative prior is to use one that has maximum entropy, since
it makes the least commitments to any particular value in the state space (see Section 5.2 for a
discussion of entropy). This is a formalization of Laplace’s principle of insufficient reason, in
which he argued that if there is no reason to prefer one prior over another, we should pick a “flat”
one.
For example, in the case of a Bernoulli distribution with rate θ ∈ [0, 1], the maximum entropy
prior is the uniform distribution, p(θ) = Beta(θ|1, 1), which makes intuitive sense.
However, in some cases we know something about our random variable θ, and we would like our
prior to match these constraints, but otherwise be maximally entropic. More precisely, suppose
we want to find a distribution p(θ) with maximum entropy, subject to the constraints that the
expected values of certain features or functions fk(θ) match some known quantities Fk. This is called
a maxent prior. In Section 2.4.7, we show that such distributions must belong to the exponential
family (Section 2.4).
For example, suppose θ ∈ {1, 2, . . . , 10}, and let pc = p(θ = c) be the corresponding prior. Suppose
we know that the prior mean is 1.5. We can encode this using the following constraint
E [f1(θ)] = E [θ] = X
c
c pc = 1.5 (3.218)
7. https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.5. NONINFORMATIVE PRIORS
2 4 6 8 10
0.0
0.2
0.4
0.6
p( )
unconstrained
mean of 1.5
p(3,4)=0.8
Figure 3.12: Illustration of 3 different maximum entropy priors. Adapted from Figure 1.10 of [MKL11].
Generated by maxent_priors.ipynb.
In addition, we have the constraint P
c
pc = 1. Thus we need to solve the following optimization
problem:
min
p
H(p) s.t.
X
c
c pc = 1.5,
X
c
pc = 1.0 (3.219)
This gives the decaying exponential curve in Figure 3.12. Now suppose we know that θ is either 3 or
4 with probability 0.8. We can encode this using
E [f1(θ)] = E [I(θ ∈ {3, 4})] = Pr(θ ∈ {3, 4}) = 0.8 (3.220)
This gives the inverted U-curve in Figure 3.12. We note that this distribution is flat in as many
places as possible.
3.5.2 Jeffreys priors
Let θ be a random variable with prior pθ(θ), and let φ = f(θ) be some invertible transformation of
θ. We want to choose a prior that is invariant to this function f, so that the posterior does not
depend on how we parameterize the model.
For example, consider a Bernoulli distribution with rate parameter θ. Suppose Alice uses a binomial
likelihood with data D, and computes p(θ|D). Now suppose Bob uses the same likelihood and data,
but parameterizes the model in terms of the odds parameter, φ =
θ
1−θ
. He converts Alice’s prior to
p(φ) using the change of variables formula, and them computes p(φ|D). If he then converts back to
the θ parameterization, he should get the same result as Alice.
We can achieve this goal that provided we use a Jeffreys prior, named after Harold Jeffreys.8
In
1d, the Jeffreys prior is given by p(θ) ∝
p
F(θ), where F is the Fisher information (Section 3.3.4).
8. Harold Jeffreys, 1891–1989, was an English mathematician, statistician, geophysicist, and astronomer. He is not to
be confused with Richard Jeffrey, a philosopher who advocated the subjective interpretation of probability [Jef04].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license104
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
In multiple dimensions, the Jeffreys prior has the form p(θ) ∝
p
det F(θ), where F is the Fisher
information matrix (Section 3.3.4).
To see why the Jeffreys prior is invariant to parameterization, consider the 1d case. Suppose
pθ(θ) ∝
p
F(θ). Using the change of variables, we can derive the corresponding prior for φ as follows:
pφ(φ) = pθ(θ)




dθ
dφ




(3.221)
∝
s
F(θ)

dθ
dφ2
=
vuutE
"
d log p(x|θ)
dθ 2
# 
dθ
dφ2
(3.222)
=
vuutE
"
d log p(x|θ)
dθ
dθ
dφ2
#
=
vuutE
"
d log p(x|φ)
dφ 2
#
(3.223)
=
p
F(φ) (3.224)
Thus the prior distribution is the same whether we use the θ parameterization or the φ parameteriza￾tion.
We give some examples of Jeffreys priors below.
3.5.2.1 Jeffreys prior for binomial distribution
Let us derive the Jeffreys prior for the binomial distribution using the rate parameterization θ. From
Equation (3.57), we have
p(θ) ∝ θ
− 1
2 (1 − θ)
− 1
2 =
1
p
θ(1 − θ)
∝ Beta(θ|
1
2
,
1
2
) (3.225)
Now consider the odds parameterization, φ = θ/(1 − θ), so θ =
φ
φ+1 . The likelihood becomes
p(x|φ) ∝

φ
φ + 1x 
1 −
φ
φ + 1n−x
= φ
x
(φ + 1)−x
(φ + 1)−n+x = φ
x
(φ + 1)−n
(3.226)
Thus the log likelihood is
ℓ = x log φ − n log φ + 1 (3.227)
The first and second derivatives are
dℓ
dφ =
x
φ
−
n
φ + 1
(3.228)
d
2
ℓ
dφ2
= −
x
φ2
+
n
(φ + 1)2
(3.229)
Since E [x] = nθ = n
φ
φ+1 , the Fisher information matrix is given by
F(φ) = −E

d
2
ℓ
dφ2

n
φ(φ + 1) −
n
(φ + 1)2
(3.230)
=
n(φ + 1) − nφ
φ(φ + 1)2
=
n
φ(φ + 1)2
(3.231)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.5. NONINFORMATIVE PRIORS
0
5
10
Jeffreys' prior for Alice Jeffreys' prior for Bob
0.0 0.2 0.4 0.6 0.8 1.0
0.00
0.01
0.02
0.03
Jeffreys' posterior for Alice
0 2 4 6 8 10
p( x)
d
d
p( x)
d
d
Jeffreys' posterior for Bob
Figure 3.13: Illustration of Jeffreys prior for Alice (who uses the rate θ) and Bob (who uses the odds
φ = θ/(1 − θ)). Adapted from Figure 1.9 of [MKL11]. Generated by jeffreys_prior_binomial.ipynb.
Hence
pφ(φ) ∝ φ
−0.5
(1 + φ)
−1
(3.232)
See Figure 3.13 for an illustration.
3.5.2.2 Jeffreys prior for multinomial distribution
For a categorical random variable with K states, one can show that the Jeffreys prior is given by
p(θ) ∝ Dir(θ|
1
2
, . . . ,
1
2
) (3.233)
Note that this is different from the more obvious choices of Dir( 1
K
, . . . ,
1
K
) or Dir(1, . . . , 1).
3.5.2.3 Jeffreys prior for the mean and variance of a univariate Gaussian
Consider a 1d Gaussian x ∼ N (µ, σ2
) with both parameters unknown, so θ = (µ, σ). From
Equation (3.62), the Fisher information matrix is
F(θ) = 
1/σ2 0
0 2/σ2

(3.234)
so p
det(F(θ)) =
q
2
σ4 . However, the standard Jeffreys uninformative prior for the Gaussian is
defined as the product of independent uninformative priors (see [KW96]), i.e.,
p(µ, σ2
) ∝ p(µ)p(σ
2
) ∝ 1/σ2
(3.235)
It turns out that we can emulate this prior with a conjugate NIX prior:
p(µ, σ2
) = NIχ2
(µ, σ2
|µ0 = 0,
`κ= 0,
`ν= −1,
`σ
2= 0) (3.236)
This lets us easily reuse the results for conjugate analysis of the Gaussian in Section 3.4.3.3, as we
showed in Section 3.4.3.4.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license106
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.5.3 Invariant priors
If we have “objective” prior knowledge about a problem in the form of invariances, we may be able to
encode this into a prior, as we show below.
3.5.3.1 Translation-invariant priors
A location-scale family is a family of probability distributions parameterized by a location µ and
scale σ. If x is an rv in this family, then y = a + bx is also an rv in the same family.
When inferring the location parameter µ, it is intuitively reasonable to want to use a translation￾invariant prior, which satisfies the property that the probability mass assigned to any interval,
[A, B] is the same as that assigned to any other shifted interval of the same width, such as [A−c, B−c].
That is,
Z B−c
A−c
p(µ)dµ =
Z B
A
p(µ)dµ (3.237)
This can be achieved using
p(µ) ∝ 1 (3.238)
since
Z B−c
A−c
1dµ = (B − c) − (A − c) = (B − A) = Z B
A
1dµ (3.239)
This is the same as the Jeffreys prior for a Gaussian with unknown mean µ and fixed variance.
This follows since F(µ) = 1/σ2 ∝ 1, from Equation (3.62), and hence p(µ) ∝ 1.
3.5.3.2 Scale-invariant prior
When inferring the scale parameter σ, we may want to use a scale-invariant prior, which satisfies
the property that the probability mass assigned to any interval [A, B] is the same as that assigned to
any other interval [A/c, B/c], where c > 0. That is,
Z B/c
A/c
p(σ)dσ =
Z B
A
p(σ)dσ (3.240)
This can be achieved by using
p(σ) ∝ 1/σ (3.241)
since then
Z B/c
A/c
1
σ
dσ = [log σ]
B/c
A/c = log(B/c) − log(A/c) = log(B) − log(A) = Z B
A
1
σ
dσ (3.242)
This is the same as the Jeffreys prior for a Gaussian with fixed mean µ and unknown scale σ. This
follows since F(σ) = 2/σ2
, from Equation (3.62), and hence p(σ) ∝ 1/σ.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.6. HIERARCHICAL PRIORS
3.5.3.3 Learning invariant priors
Whenever we have knowledge of some kind of invariance we want our model to satisfy, we can use this
to encode a corresponding prior. Sometimes this is done analytically (see e.g., [Rob07, Ch.9]). When
this is intractable, it may be possible to learn invariant priors by solving a variational optimization
problem (see e.g., [NS18]).
3.5.4 Reference priors
One way to define a noninformative prior is as a distribution which is maximally far from all possible
posteriors, when averaged over datasets. This is the basic idea behind a reference prior [Ber05;
BBS09]. More precisely, we say that p(θ) is a reference prior if it maximizes the expected KL
divergence between posterior and prior:
p
∗
(θ) = argmax
p(θ)
Z
D
p(D)DKL (p(θ|D) k p(θ)) dD (3.243)
where p(D) = R
p(D|θ)p(θ)dθ. This is the same as maximizing the mutual information I(θ, D).
We can eliminate the integral over datasets by noting that
Z
p(D)
Z
p(θ|D) log p(θ|D)
p(θ)
=
Z
p(θ)
Z
p(D|θ) log
p(D|θ)
p(D)
= Eθ [DKL (p(D|θ) k p(D))] (3.244)
where we used the fact that p(θ|D)
p(θ) =
p(D|θ)
p(D)
.
One can show that, in 1d, the corresponding prior is equivalent to the Jeffreys prior. In higher
dimensions, we can compute the reference prior for one parameter at a time, using the chain rule.
However, this can become computationally intractable. See [NS17] for a tractable approximation
based on variational inference (Section 10.1).
3.6 Hierarchical priors
Bayesian models require specifying a prior p(θ) for the parameters. The parameters of the prior are
called hyperparameters, and will be denoted by ξ. If these are unknown, we can put a prior on
them; this defines a hierarchical Bayesian model, or multi-level model, which can visualize
like this: ξ → θ → D. We assume the prior on the hyper-parameters is fixed (e.g., we may use some
kind of minimally informative prior), so the joint distribution has the form
p(ξ, θ, D) = p(ξ)p(θ|ξ)p(D|θ) (3.245)
The hope is that we can learn the hyperparameters by treating the parameters themselves as
datapoints.
A common setting in which such an approach makes sense is when we have J > 1 related datasets,
Dj , each with their own parameters θj . Inferring p(θj |Dj ) independently for each group j can give
poor results if Dj is a small dataset (e.g., if condition j corresponds to a rare combination of features,
or a sparsely population region). We could of course pool all the data to compute a single model,
p(θ|D), but that would not let us model the subpopulations. A hierarchical Bayesian model lets us
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license108
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
borrow statistical strength from groups with lots of data (and hence well-informed posteriors
p(θj |D)) in order to help groups with little data (and hence highly uncertain posteriors p(θj |D)).
The idea is that well-informed groups j will have a good estimate of θj , from which we can infer
ξ, which can be used to help estimate θk for groups k with less data. (Information is shared via
the hidden common parent node ξ in the graphical model, as shown in Figure 3.14.) We give some
examples of this below.
After fitting such models, we can compute two kinds of posterior predictive distributions. If we
want to predict observations for an existing group j, we need to use
p(yj |D) = Z
p(yj |θj )p(θj |D)dθj (3.246)
However, if we want to predict observations for a new group ∗ that has not yet been measured, but
which is comparable to (or exchangeable with) the existing groups 1 : J, we need to use
p(y∗|D) = Z
p(y∗|θ∗)p(θ∗|ξ)p(ξ|D)dθ∗dξ (3.247)
We give some examples below. (More information can be found in e.g., [GH07; Gel+14a].)
3.6.1 A hierarchical binomial model
Suppose we want to estimate the prevalence of some disease amongst different group of individuals,
either people or animals. Let Nj be the size of the j’th group, and let yj be the number of positive
cases for group j = 1 : J. We assume yj ∼ Bin(Nj , θj ), and we want to estimate the rates θj . Since
some groups may have small population sizes, we may get unreliable results if we estimate each θj
separately; for example we may observe yj = 0 resulting in ˆθj = 0, even though the true infection
rate is higher.
One solution is to assume all the θj are the same; this is called parameter tying. The resulting
pooled MLE is just ˆθpooled =
P
j P
yj
j Nj
. But the assumption that all the groups have the same rate is a
rather strong one. A compromise approach is to assume that the θj are similar, but that there may
be group-specific variations. This can be modeled by assuming the θj are drawn from some common
distribution, say θj ∼ Beta(a, b). The full joint distribution can be written as
p(D, θ, ξ) = p(ξ)p(θ|ξ)p(D|θ) = p(ξ)


Y
J
j=1
Beta(θj |ξ)




Y
J
j=1
Bin(yj |Nj , θj )

 (3.248)
where ξ = (a, b). In Figure 3.14 we represent these assumptions using a directed graphical model
(see Section 4.2.8 for an explanation of such diagrams).
It remains to specify the prior p(ξ). Following [Gel+14a, p110], we use
p(a, b) ∝ (a + b)
−5/2
(3.249)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.6. HIERARCHICAL PRIORS
N1 NJ
y1 · · · yJ
θ1 θJ
a b
(a)
J
yj
θj Nj
a b
(b)
Figure 3.14: PGM for a hierarchical binomial model. (a) “Unrolled” model. (b) Same model, using plate
notation.
0
8
16
Number of
positives
0
25
50
Group
sizes
0.0
0.2
0.4
θMLE
Pooled θMLE
0 10 20 30 40 50 60 70
Type of rat tumor
0.0
0.2
0.4
Posterior
mean (θ)
Population mean (θ)
(a)
0.0 0.1 0.2 0.3 0.4
θ
70
68
66
64
62
60
58
56
54
52
50
48
46
44
42
40
38
36
34
32
30
28
26
24
22
20
18
16
14
12
10
8
6
4
2
0
95% of HDI
(b)
Figure 3.15: Data and inferences for the hierarchical binomial model fit using HMC. Generated by hierarchi￾cal_binom_rats.ipynb.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license110
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.6.1.1 Posterior inference
We can perform approximate posterior inference in this model using a variety of methods. In
Section 3.7.1 we discuss an optimization based approach, but here we discuss one of the most popular
methods in Bayesian statistics, known as HMC or Hamiltonian Monte Carlo. This is described in
Section 12.5, but in short it is a form of MCMC (Markov chain Monte Carlo) that exploits information
from the gradient of the log joint to guide the sampling process. This algorithm generates samples
in an unconstrained parameter space, so we need to define the log joint over all the parameters
ω = (θ˜,
˜ξ) ∈ R
D as follows:
log p(D, ω) = log p(D|θ) + log p(θ|ξ) + log p(ξ) (3.250)
+
X
J
j=1
log |Jac(σ)(˜θj )| +
X
2
i=1
log |Jac(σ+)(˜ξi)| (3.251)
where θj = σ(
˜θj ) is the sigmoid transform, and ξi = σ+(
˜ξi) is the softplus transform. (We need
to add the Jacobian terms to account for these deterministic transformations.) We can then use
automatic differentation to compute ∇ω log p(D, ω), which we pass to the HMC algorithm. This
algorithm returns a set of (correlated) samples from the posterior, (
˜ξ
s
, θ˜s
) ∼ p(ω|D), which we can
back transform to (ξ
s
, θ
s
). We can then estimate the posterior over quantities of interest by using a
Monte Carlo approximation to p(f(θ)|D) for suitable f (e.g., to compute the posterior mean rate for
group j, we set f(θ) = θj ).
3.6.1.2 Example: the rats dataset
In this section, we apply this model to analyze the number of rats that develop a certain kind of tumor
during a particular clinical trial (see [Gel+14a, p102] for details). We show the raw data in rows 1–2
of Figure 3.15a. In row 3, we show the MLE ˆθj for each group. We see that some groups have ˆθj = 0,
which is much less than the pooled MLE ˆθpooled (red line). In row 4, we show the posterior mean
E[θj |D] estimated from all the data, as well as the population mean E[θ|D] = E[a/(a + b)|D] shown
in the red lines. We see that groups that have low counts have their estimates increased towards
the population mean, and groups that have large counts have their estimates decreased towards
the population mean. In other words, the groups regularize each other; this phenomenon is called
shrinkage. The amount of shrinkage is controlled by the prior on (a, b), which is inferred from the
data.
In Figure 3.15b, we show the 95% credible intervals for each parameter, as well as the overall
population mean. (This is known as a forest plot.) We can use this to decide if any group is
significantly different than any specified target value (e.g., the overall average).
3.6.2 A hierarchical Gaussian model
In this section, we consider a variation of the model in Section 3.6.1, where this time we have
real-valued data instead of binary count data. More specificially we assume yij ∼ N (θj , σ2
), where
θj is the unknown mean for group j, and σ
2
is the observation variance (assumed to be shared across
groups and fixed, for simplicity). Note that having Nj observations yij each with variance σ
2
is like
having one measurement yj ,
1
Nj
PNj
i=1 yij with variance σ
2
j , σ
2/Nj . This lets us simplify notation
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.6. HIERARCHICAL PRIORS
−20 0 20 40
0
1
2
3
4
5
6
7
θ
(a)
−10 −5 0 5 10 15 20
[7]
[6]
[5]
[4]
[3]
[2]
[1]
theta[0]
95% Credible Interval
(b)
Figure 3.16: Eight schools dataset. (a) Raw data. Each row plots yj ± σj . Vertical line is the pooled
estimate. (b) Posterior 95% credible intervals for θj . Vertical line is posterior mean E [µ|D]. Generated by
schools8.ipynb.
0 5 10 15 20 25
0.00051 9.9
95% HPD
mean=3.6
τ
Figure 3.17: Marginal posterior density p(τ |D) for the 8-schools dataset. Generated by schools8.ipynb.
and use one observation per group, with likelihood yj ∼ N (θ, σ2
j
), where we assume the σj ’s are
known.
We use a hierarchical model by assuming each group’s parameters come from a common distribution,
θj ∼ N (µ, τ 2
). The model becomes
p(µ, τ 2
, θ1:J |D) ∝ p(µ)p(τ
2
)
Y
J
j=1
N (θj |µ, τ 2
)N (yj |θj , σ2
j
) (3.252)
where p(µ)p(τ
2
) is some kind of prior over the hyper-parameters. See Figure 3.19a for the graphical
model.
3.6.2.1 Example: the eight schools dataset
Let us now apply this model to some data. We will consider the eight schools dataset from [Gel+14a,
Sec 5.5]. The goal is to estimate the effects on a new coaching program on SAT scores. Let ynj be
the observed improvement in score for student n in school j compared to a baseline. Since each
school has multiple students, we summarize its data using the empirical mean y·j =
1
Nj
PNj
n=1 ynj
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license112
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
and standard deviation σj . See Figure 3.16a for an illustration of the data. We also show the pooled
MLE for θ, which is a precision weighted average of the data:
y.. =
PJ
j=1
1
σ
2
j
y.j
PJ
j=1
1
σ
2
j
(3.253)
We see that school 0 has an unusually large improvement (28 points) compared to the overall mean,
suggesting that the estimating θ0 just based on D0 might be unreliable. However, we can easily apply
our hierarchical model. We will use HMC to do approximate inference. (See Section 3.7.2 for a faster
approximate method.)
After computing the (approximate) posterior, we can compute the marginal posteriors p(θj |D)
for each school. These distributions are shown in Figure 3.16b. Once again, we see shrinkage
towards the global mean µ = E [µ|D], which is close to the pooled estimate y..
. In fact, if we fix the
hyper-parameters to their posterior mean values, and use the approximation
p(µ, τ 2
|D) = δ(µ − µ)δ(τ
2 − τ
2
) (3.254)
then we can use the results from Section 3.4.3.1 to compute the marginal posteriors
p(θj |D) ≈ p(θj |Dj , µ, τ
2
) (3.255)
In particular, we can show that the posterior mean E [θj |D] is in between the MLE ˆθj = yj and the
global mean µ = E [µ|D]:
E

θj |D, µ, τ
2

= wjµ + (1 − wj )
ˆθj (3.256)
where the amount of shrinkage towards the global mean is given by
wj =
σ
2
j
σ
2
j + τ
2
(3.257)
Thus we see that there is more shrinkage for groups with smaller measurement precision (e.g., due to
smaller sample size), which makes intuitive sense. There is also more shrinkage if τ
2
is smaller; of
course τ
2
is unknown, but we can compute a posterior for it, as shown in Figure 3.17.
3.6.2.2 Non-centered parameterization
It turns out that posterior inference in this model is difficult for many algorithms because of the
tight dependence between the variance hyperparameter τ
2 and the group means θj , as illustrated by
the funnel shape in Figure 3.18. In particular, consider making local moves through parameter
space. The algorithm can only “visit” the place where τ
2
is small (corresponding to strong shrinkage
to the prior) if all the θj are close to the prior mean µ. It may be hard to move into the area where
τ
2
is small unless all groups simultaneously move their θj estimates closer to µ.
A standard solution to this problem is to rewrite the model using the following non-centered
parameterization:
θj = µ + τηj (3.258)
ηj ∼ N (0, 1) (3.259)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.6. HIERARCHICAL PRIORS
−10 10 30 50
θ0
−7.5
−5.0
−2.5
0.0
2.5
log(τ )
Centered
−10 10 30 50
θ0
log(τ )
NonCentered
Figure 3.18: Posterior p(θ0, log(τ )|D) for the eight schools model using (a) centered parameterization and (b)
non-centered parameterization. Generated by schools8.ipynb.
J
yj
θj σj
µ τ
(a)
J
yj
θj
ηj
σj
µ τ
(b)
Figure 3.19: A hierarchical Gaussian Bayesian model. (a) Centered parameterization. (b) Non-centered
parameterization.
See Figure 3.19b for the corresponding graphical model. By writing θj as a deterministic function of
its parents plus a local noise term, we have reduced the dependence between θj and τ and hence the
other θk variables, which can improve the computational efficiency of inference algorithms, as we
discuss in Section 12.6.5. This kind of reparameterization is widely used in hierarchical Bayesian
models.
3.6.3 Hierarchical conditional models
In Section 15.5, we discuss hierarchical Bayesian GLM models, which learn conditional distributions
p(y|x, θj ) for each group j, using a prior of the form p(θj |ξ). In Section 17.6, we discuss hierarchical
Bayesian neural networks, which generalize this idea to nonlinear predictors.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license114
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.7 Empirical Bayes
In Section 3.6, we discussed hierarchical Bayes as a way to infer parameters from data. Unfortunately,
posterior inference in such models can be computationally challenging. In this section, we discuss
a computationally convenient approximation, in which we first compute a point estimate of the
hyperparameters, ˆξ, and then compute the conditional posterior, p(θ|
ˆξ, D), rather than the joint
posterior, p(θ, ξ|D).
To estimate the hyper-parameters, we can maximize the marginal likelihood:
ˆξmml(D) = argmax
ξ
p(D|ξ) = argmax
ξ
Z
p(D|θ)p(θ|ξ)dθ (3.260)
This technique is known as type II maximum likelihood, since we are optimizing the hyper￾parameters, rather than the parameters. (In the context of neural networks, this is sometimes called
the evidence procedure [Mac92a; WS93; Mac99].) Once we have estimated ˆξ, we compute the
posterior p(θ|
ˆξ, D) in the usual way.
Since we are estimating the prior parameters from data, this approach is empirical Bayes (EB)
[CL96]. This violates the principle that the prior should be chosen independently of the data.
However, we can view it as a computationally cheap approximation to inference in the full hierarchical
Bayesian model, just as we viewed MAP estimation as an approximation to inference in the one level
model θ → D. In fact, we can construct a hierarchy in which the more integrals one performs, the
“more Bayesian” one becomes, as shown below.
Method Definition
Maximum likelihood θˆ = argmaxθ p(D|θ)
MAP estimation θˆ = argmaxθ p(D|θ)p(θ|ξ)
ML-II (empirical Bayes) ˆξ = argmaxξ
R
p(D|θ)p(θ|ξ)dθ
MAP-II ˆξ = argmaxξ
R
p(D|θ)p(θ|ξ)p(ξ)dθ
Full Bayes p(θ, ξ|D) ∝ p(D|θ)p(θ|ξ)p(ξ)
Note that ML-II is less likely to overfit than “regular” maximum likelihood, because there are
typically fewer hyper-parameters ξ than there are parameters θ. We give some simple examples
below, and will see more applications later in the book.
3.7.1 EB for the hierarchical binomial model
In this section, we revisit the hierarchical binomial model from Section 3.6.1, but we use empirical
Bayes instead of full Bayesian inference. We can analytically integrate out the θj ’s, and write down
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.7. EMPIRICAL BAYES
0
8
16
Number of
postives
0
25
50
Group
size
0.00
0.25
0.50
MLE
pooled MLE
0 10 20 30 40 50 60 70
Type of rat tumor
0.00
0.25
0.50
Posterior
mean
hparam
(a)
0.0 0.1 0.2 0.3 0.4
θ
0
10
20
30
40
50
60
70
95% confidence interval
(b)
Figure 3.20: Data and inferences for the hierarchical binomial model fit using empirical Bayes. Generated by
eb_binom.ipynb.
the marginal likelihood directly: The resulting expression is
p(D|ξ) = Y
j
Z
Bin(yj |Nj , θj )Beta(θj |a, b)dθj (3.261)
∝
Y
j
B(a + yj , b + Nj − yj )
B(a, b)
(3.262)
=
Y
j
Γ(a + b)
Γ(a)Γ(b)
Γ(a + yj )Γ(b + Nj − yj )
Γ(a + b + Nj )
(3.263)
Various ways of maximizing this marginal likelihood wrt a and b are discussed in [Min00c].
Having estimated the hyper-parameters a and b, we can plug them in to compute the posterior
p(θj |a, ˆ
ˆb, D) for each group, using conjugate analysis in the usual way. We show the results in
Figure 3.20; they are very similar to the full Bayesian analysis shown in Figure 3.15, but the EB
method is much faster.
3.7.2 EB for the hierarchical Gaussian model
In this section, we revisit the hierarchical Gaussian model from Section 3.6.2.1. However, we fit the
model using empirical Bayes.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license116
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
For simplicity, we will assume that σ
2
j = σ
2
is the same for all groups. When the variances are
equal, we can derive the EB estimate in closed form, as we now show. We have
p(yj |µ, τ 2
, σ2
) = Z
N (yj |θj , σ2
)N (θj |µ, τ 2
)dθj = N (yj |µ, τ 2 + σ
2
) (3.264)
Hence the marginal likelihood is
p(D|µ, τ 2
, σ2
) = Y
J
j=1
N (yj |µ, τ 2 + σ
2
) (3.265)
Thus we can estimate the hyper-parameters using the usual MLEs for a Gaussian. For µ, we have
µˆ =
1
J
X
J
j=1
yj = y (3.266)
which is the overall mean. For τ
2
, we can use moment matching, which is equivalent to the MLE for
a Gaussian. This means we equate the model variance to the empirical variance:
τˆ
2 + σ
2 =
1
J
X
J
j=1
(yj − y)
2 , v (3.267)
so τˆ
2 = v −σ
2
. Since we know τ
2 must be positive, it is common to use the following revised estimate:
τˆ
2 = max{0, v − σ
2
} = (v − σ
2
)+ (3.268)
Given this, the posterior mean becomes
ˆθj = λµ + (1 − λ)yj = µ + (1 − λ)(yj − µ) (3.269)
where λj = λ = σ
2/(σ
2 + τ
2
).
Unfortunately, we cannot use the above method on the 8-schools dataset in Section 3.6.2.1, since it
uses unequal σj . However, we can still use the EM algorithm or other optimization based methods.
3.7.3 EB for Markov models (n-gram smoothing)
The main problem with add-one smoothing, discussed in Section 2.6.3.3, is that it assumes that
all n-grams are equally likely, which is not very realistic. A more sophisticated approach, called
deleted interpolation [CG96], defines the transition matrix as a convex combination of the bigram
frequencies fjk = Njk/Nj and the unigram frequencies fk = Nk/N:
Ajk = (1 − λ)fjk + λfk = (1 − λ)
Njk
Nj
+ λ
Nk
N
(3.270)
The term λ is usually set by cross validation. There is also a closely related technique called backoff
smoothing; the idea is that if fjk is too small, we “back off” to a more reliable estimate, namely fk.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.7. EMPIRICAL BAYES
A ⍺ m
x1 x2 x3 x4
Figure 3.21: A Markov chain in which we put a different Dirichlet prior on every row of the transition matrix
A, but the hyperparameters of the Dirichlet are shared.
We now show that this heuristic can be interpreted as an empirical Bayes approximation to a
hierarchical Bayesian model for the parameter vectors corresponding to each row of the transition
matrix A. Our presentation follows [MP95].
First, let us use an independent Dirichlet prior on each row of the transition matrix:
Aj ∼ Dir(α0m1, . . . , α0mK) = Dir(α0m) = Dir(α) (3.271)
where Aj is row j of the transition matrix, m is the prior mean (satisfying P
k mk = 1) and α0 is the
prior strength (see Figure 3.21). In terms of the earlier notation, we have θj = Aj and ξ = (α,m).
The posterior is given by Aj ∼ Dir(α+Nj ), where Nj = (Nj1, . . . , NjK) is the vector that records
the number of times we have transitioned out of state j to each of the other states. The posterior
predictive density is
p(Xt+1 = k|Xt = j, D) = Njk + αjmk
Nj + α0
=
fjkNj + αjmk
Nj + α0
(3.272)
= (1 − λj )fjk + λjmk (3.273)
where
λj =
αj
Nj + α0
(3.274)
This is very similar to Equation (3.270) but not identical. The main difference is that the Bayesian
model uses a context-dependent weight λj to combine mk with the empirical frequency fjk, rather
than a fixed weight λ. This is like adaptive deleted interpolation. Furthermore, rather than backing
off to the empirical marginal frequencies fk, we back off to the model parameter mk.
The only remaining question is: what values should we use for α and m? Let’s use empirical Bayes.
Since we assume each row of the transition matrix is a priori independent given α, the marginal
likelihood for our Markov model is given by
p(D|α) = Y
j
B(Nj + α)
B(α)
(3.275)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license118
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where Nj = (Nj1, . . . , NjK) are the counts for leaving state j and B(α) is the generalized beta
function.
We can fit this using the methods discussed in [Min00c]. However, we can also use the following
approximation [MP95, p12]:
mk ∝ |{j : Njk > 0}| (3.276)
This says that the prior probability of word k is given by the number of different contexts in which
it occurs, rather than the number of times it occurs. To justify the reasonableness of this result,
MacKay and Peto [MP95] give the following example.
Imagine, you see, that the language, you see, has, you see, a
frequently occuring couplet ’you see’, you see, in which the second
word of the couplet, see, follows the first word, you, with very high
probability, you see. Then the marginal statistics, you see, are going
to become hugely dominated, you see, by the words you and see, with
equal frequency, you see.
If we use the standard smoothing formula, Equation (3.270), then P(you|novel) and P(see|novel),
for some novel context word not seen before, would turn out to be the same, since the marginal
frequencies of ’you’ and ’see’ are the same (11 times each). However, this seems unreasonable. ’You’
appears in many contexts, so P(you|novel) should be high, but ’see’ only follows ’you’, so P(see|novel)
should be low. If we use the Bayesian formula Equation (3.273), we will get this effect for free, since
we back off to mk not fk, and mk will be large for ’you’ and small for ’see’ by Equation (3.276).
Although elegant, this Bayesian model does not beat the state-of-the-art language model, known
as interpolated Kneser-Ney [KN95; CG98]. By using ideas from nonparametric Bayes, one
can create a language model that outperforms such heuristics, as discussed in [Teh06; Woo+09].
However, one can get even better results using recurrent neural nets (Section 16.3.4); the key to their
success is that they don’t treat each symbol “atomically”, but instead learn a distributed embedding
representation, which encodes the assumption that some symbols are more similar to each other than
others.
3.7.4 EB for non-conjugate models
For more complex models, we cannot compute the EB estimate exactly. However, we can use the
variational EM method to compute an approximate EB estimate, as we explain in Section 10.1.3.2.
3.8 Model selection
All models are wrong, but some are useful. — George Box [BD87, p424].9
In this section, we assume we have a set of different models M, each of which may fit the data to
different degrees, and each of which may make different assumptions. We discuss how to pick the
best model from this set. or to average over all of them.
We assume the “true” model is in the set M; this is known as the M-complete assumption [BS94].
Of course, in reality, none of the models may be adequate; this is known as the M-open scenario
9. George Box is a retired statistics professor at the University of Wisconsin.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.8. MODEL SELECTION
[BS94; CI13]. We can check how well a model fits (or fails to fit) the data using the procedures in
Section 3.9. If none of the models are a good fit, we need to expand our hypothesis space.
3.8.1 Bayesian model selection
The natural way to pick the best model is to pick the most probable model according to Bayes’ rule:
mˆ = argmax
m∈M
p(m|D) (3.277)
where
p(m|D) = p(D|m)p(m)
P
m∈M p(D|m)p(m)
(3.278)
is the posterior over models. This is called Bayesian model selection. If the prior over models is
uniform, p(m) = 1/|M|, then the MAP model is given by
mˆ = argmax
m∈M
p(D|m) (3.279)
The quantity p(D|m) is given by
p(D|m) = Z
p(D|θ, m)p(θ|m)dθ (3.280)
This is known as the marginal likelihood, or the evidence for model m. (See Section 3.8.3 for
details on how to compute this quantity.) If the model assigns high prior predictive density to the
observed data, then we deem it a good model. If, however, the model has too much flexibility, then
some prior settings will not match the data; this probability mass will be “wasted”, lowering the
expected likelihood. This implicit regularization effect is called the Bayesian Occam’s razor. See
Figure 3.22 for an illustration.
3.8.1.1 Example: is the coin fair?
As an example, suppose we observe some coin tosses, and want to decide if the data was generated by
a fair coin, θ = 0.5, or a potentially biased coin, where θ could be any value in [0, 1]. Let us denote
the first model by M0 and the second model by M1. The marginal likelihood under M0 is simply
p(D|M0) = 
1
2
N
(3.281)
where N is the number of coin tosses. From Equation (3.31), the marginal likelihood under M1,
using a Beta prior, is
p(D|M1) = Z
p(D|θ)p(θ)dθ =
B(α1 + N1, α0 + N0)
B(α1, α0)
(3.282)
We plot log p(D|M1) vs the number of heads N1 in Figure 3.23(a), assuming N = 5 and a uniform
prior, α1 = α0 = 1. (The shape of the curve is not very sensitive to α1 and α0, as long as the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license120
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
p(D)
M1
M2
M3
D0 D
Figure 3.22: A schematic illustration of the Bayesian Occam’s razor. The broad (green) curve corresponds to
a complex model, the narrow (blue) curve to a simple model, and the middle (red) curve is just right. Adapted
from Figure 3.13 of [Bis06]. See also [MG05, Figure 2] for a similar plot produced on real data.
0 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 5
−1.8
−1.6
−1.4
−1.2
−1
−0.8
−0.6
−0.4
log10 p(D|M1)
(a)
0 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 5
−2.5
−2.45
−2.4
−2.35
−2.3
−2.25
−2.2
−2.15
−2.1
−2.05
−2
BIC approximation to log10 p(D|M1)
(b)
Figure 3.23: (a) Log marginal likelihood vs number of heads for the coin tossing example. (b)
BIC approximation. (The vertical scale is arbitrary, since we are holding N fixed.) Generated by
coins_model_sel_demo.ipynb.
prior is symmetric, so α0 = α1.) If we observe 2 or 3 heads, the unbiased coin hypothesis M0
is more likely than M1, since M0 is a simpler model (it has no free parameters) — it would be
a suspicious coincidence if the coin were biased but happened to produce almost exactly 50/50
heads/tails. However, as the counts become more extreme, we favor the biased coin hypothesis.
In Figure 3.23(b), we show a similar result, where we approximate the log marginal likelihood with
the BIC score (see Section 3.8.7.2).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.8. MODEL SELECTION
3.8.2 Bayes model averaging
If our goal is to perform predictions, we are better off averaging over all models, rather than predicting
using just one single model. That is, we should compute the posterior predictive distribution
using
p(y|D) = X
m∈M
p(y|m)p(m|D) (3.283)
This is called Bayes model averaging [Hoe+99]. This is similar to the machine learning technique
of ensembling, in which we take a weighted combination of predictors. However, it is not the same,
as pointed out in [Min00b], since the weights in an ensemble do not need to sum to 1. In particular,
in BMA, if there is a single best model, call it m∗
, then in the large sample limit, p(m|D) will become
a degenerate distribution with all its weight on m∗
, and the other members of M will be ignored.
This does not happen with an ensemble.
3.8.3 Estimating the marginal likelihood
To perform Bayesian model selection or averaging, we need to be able to compute the marginal
likelihood in Equation (3.280), also called the evidence. Below we give a brief summary of some
suitable methods. For more details, see e.g., [FW12].
3.8.3.1 Analytic solution for conjugate models
If we use a conjugate prior, we can compute the marginal likelihood analytically, as we discussed in
Section 3.4.5.4. We give a worked example in Section 3.8.1.1.
3.8.3.2 Harmonic mean estimator
A particularly simple estimator, known as the harmonic mean estimator, was proposed in [NR94].
It is defined as follows:
p(D) ≈
 
1
S
X
S
s=1
1
p(D|θs)
!−1
(3.284)
where θs ∼ p(θ) are samples from the prior. This follows from the following identity:
E

1
p(D|θ)

=
Z
1
p(D|θ)
p(θ|D)dθ (3.285)
=
Z
1
p(D|θ)
p(D|θ)p(θ)
p(D)
dθ (3.286)
=
1
p(D)
Z
p(θ)dθ =
1
p(D)
(3.287)
(We have assumed the prior is proper, so it integrates to 1.)
Unfortunately, the number of samples needed to get a good estimate is generally very large, since
most samples from the prior will have low likelihood, making this approach useless in practice. Indeed,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license122
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 3.24: Schematic of 5-fold cross validation.
Radford Neal made a blog post in which he described this method as “The Worst Monte Carlo
Method Ever”.10)
3.8.3.3 Other Monte Carlo methods
The marginal likelihood can be more reliably estimated using annealed importance sampling, as
discussed in Section 11.5.4.1. An extension of this, known as sequential Monte Carlo sampling, as
discussed in Section 13.2.3.3. Another method that is well suited to estimate the normalization
constant is known as nested sampling [Ski06; Buc21].
3.8.3.4 Variational Bayes
An efficient way to compute an approximation to the evidence is to use variational Bayes, which
we discuss in Section 10.3.3. This computes a tractable approximation to the posterior, q(θ|D), by
optimizing the evidence lower bound or ELBO, log q(D|θ), which can be used to approximate the
evidence.
3.8.4 Connection between cross validation and marginal likelihood
A standard approach to model evaluation is to estimate its predictive performance (in terms of log
likelihood) on a validation set, which is distinct from the training set which is used to fit the model
If we don’t have such a separate validation set, we can make one by partitioning the training set into
K subsets or “folds”, and then training on K − 1 and testing on the K’th; we repeat this K times,
as shown in Figure 3.24. This is known as cross validation.
If we set K = N, the method is known as leave-one-out cross validation or LOO-CV, since
we train on N − 1 points and test on the remaining one, and we do this N times. More precisely, we
have
LLOO(m) ,
X
N
n=1
log p(Dn|θˆ(D−n), m) (3.288)
10. https://bit.ly/3t7id0k.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.8. MODEL SELECTION
where θˆ−n is the parameter estimate computing when we omit Dn from the training set. (We discuss
fast approxmations to this in Section 3.8.6.)
Interestingly, the LOO-CV version of log likelihood is closely related to the log marginal likelihood.
To see this, let us write the log marginal likelihood (LML) in sequential form as follows:
LML(m) , log p(D|m) = log Y
N
n=1
p(Dn|D1:n−1, m) = X
N
n=1
log p(Dn|D1:n−1, m) (3.289)
where
p(Dn|D1:n−1, m) = Z
p(Dn|θ)p(θ|D1:n−1, m)dθ (3.290)
Note that we evaluate the posterior on the first n − 1 datapoints and use this to predict the n’th;
this is called prequential analysis [DV99].
Suppose we use a point estimate for the parameters at time n, rather than the full posterior. We
can then use a plugin approximation to the n’th predictive distribution:
p(Dn|D1:n−1, m) ≈
Z
p(Dn|θ)δ(θ − θˆm(D1:n−1))dθ = p(Dn|θˆm(D1:n−1)) (3.291)
Then Equation (3.289) simplifies to
log p(D|m) ≈
X
N
n=1
log p(Dn|θˆ(D1:n−1), m) (3.292)
This is very similar to Equation (3.288), except it is evaluated sequentially. A complex model will
overfit the “early” examples and will then predict the remaining ones poorly, and thus will get low
marginal likelihood as well as a low cross-validation score. See [FH20] for further discussion.
3.8.5 Conditional marginal likelihood
The marginal likelihood answers the question “what is the likelihood of generating the training data
from my prior?”. This can be suitable for hypothesis testing between different fixed priors, but is
less useful for selecting models based on their posteriors. In the latter case, we are more interested
in the question “what is the probability that the posterior could generate withheld points from the
data distribution?”, which is related to the generalization performance of the (fitted) model. In
fact [Lot+22] showed that the marginal likelihood can sometimes be negatively correlated with the
generalization performance, because the first few terms in the LML decomposition may be large and
negative for a model that has a poor prior but which otherwise adapts quickly to the data (by virtue
of the prior being weak).
A better approach is to use the conditional log marginal likelihood, which is defined as follows
[Lot+22]:
CLML(m) = X
N
n=K
log p(Dn|D1:n−1, m) (3.293)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license124
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where K ∈ {1, . . . , N} is a parameter of the algorithm. This evaluates the LML of the last N − K
datapoints, under the posterior given by the first K datapoints. We can reduce the dependence on
the ordering of the datapoints by averaging over orders; if we set K = N − 1 and average over all
orders, we get the LOO estimate.
The CLML is much more predictive of generalization performance than the LML, and is much
less sensitive to prior hyperparameters. Furthermore, it is easier to calculuate, since we can use a
straightforward Monte Carlo estimate of the integral, where we sample from the posterior p(θ|D<n);
this does not suffer from the same problems as the harmonic mean estimator in Section 3.8.3.2 which
samples from the prior.
3.8.6 Bayesian leave-one-out (LOO) estimate
In this section we discuss a computationally efficient method, based on importance sampling, to
approximate the leave-one-out (LOO) estimate without having to fit the model N times. We focus
on conditional (supervised) models, so p(D|θ) = p(y|x, θ).
Suppose we have computed the posterior given the full dataset for model m. We can use this
to evaluate the resulting predictive distribution p(yn|xn, D, m) for each datapoint n in the dataset.
This gives the log-pointwise predictive-density or LPPD score:
LPPD(m) ,
X
N
n=1
log p(yn|xn, D, m) = X
N
n=1
log Z
p(yn|xn, θ, m)p(θ|D, m)dθ (3.294)
We can approximate LPPD with Monte Carlo:
LPPD(m) ≈
X
N
n=1
log 
1
S
X
S
s=1
p(yn|xn, θs, m)
!
(3.295)
where θs ∼ p(θ|D, m) is a posterior sample.
The trouble with LPPD is that it predicts the n’th datapoint yn using all the data, including yn.
What we would like to compute is the expected LPPD (ELPD) on future data, (x∗, y∗):
ELPD(m) , Ex∗,y∗
log p(y∗|x∗, D, m) (3.296)
Of course, the future data is unknown, but we can use a LOO approximation:
ELPDLOO(m) ,
X
N
n=1
log p(yn|xn, D−n, m) = X
N
n=1
log Z
p(yn|xn, θ, m)p(θ|D−n, m)dθ (3.297)
This is a Bayesian version of Equation (3.288). We can approximate this integral using Monte Carlo:
ELPDLOO(m) ≈
X
N
n=1
log 
1
S
X
S
s=1
p(yn|xn, θs,−n, m)
!
(3.298)
where θs,−n ∼ p(θ|D−n, m).
The above procedure requires computing N different posteriors, leaving one datapoint out at a
time, which is slow. A faster alternative is to compute p(θ|D, m) once, and then use importance
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.8. MODEL SELECTION
sampling (Section 11.5) to approximate the above integral. More precisely, let f(θ) = p(θ|D−n, m) be
the target distribution of interest, and let g(θ) = p(θ|D, m) be the proposal. Define the importance
weight for each sample s when leaving out example n to be
ws,−n =
f(θs)
g(θs)
=
p(θs|D−n)
p(θs|D)
=
p(D−n|θs)p(θs)
p(D−n)
p(D)
p(D|θs)p(θs)
(3.299)
∝
p(D−n|θs)
p(D|θs)
=
p(D−n|θs)
p(D−n|θ)p(Dn|θs)
=
1
p(Dn|θs)
(3.300)
We then normalize the weights to get
wˆs,−n =
ws,−n PS
s
′=1 ws
′
,−n
(3.301)
and use them to get the estimate
ELPDIS-LOO(m) = X
N
n=1
log X
S
s=1
wˆs,−np(yn|xn, θs, m)
!
(3.302)
Unfortunately, the importance weights may have high variance, where some weights are much
larger than others. To reduce this effect, we fit a Pareto distribution (Section 2.2.3.5) to each set
of weights for each sample, and use this to smooth the weights. This technique is called Pareto
smoothed importance sampling or PSIS [Veh+15; VGG17]. The Pareto distribution has the
form
p(r|u, σ, k) = σ
−1
(1 + k(r − u)σ
−1
)
−1/k−1
(3.303)
where u is the location, σ is the scale, and k is the shape. The parameter values kn (for each datapoint
n) can be used to assess how well this approximation works. If we find kn > 0.5 for any given point,
it is likely an outlier, and the resulting LOO estimate is likely to be quite poor. See [Siv+20] for
further discussion, and [Kel21] for a general tutorial on PSIS-LOO-CV.
3.8.7 Information criteria
An alternative approach to cross validation is to score models using the negative log likelihood (or
LPPD) on the training set plus a complexity penalty term:
L(m) = − log p(D|θˆ, m) + C(m) (3.304)
This is called an information criterion. Different methods use different complexity terms C(m),
as we discuss below. See e.g., [GHV14] for further details.
A note on notation: it is conventional, when working with information criteria, to scale the NLL
by −2 to get the deviance:
deviance(m) = −2 log p(D|θˆ, m) (3.305)
This makes the math “prettier” for certain Gaussian models.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license126
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.8.7.1 Minimum description length (MDL)
We can think about the problem of scoring different models in terms of information theory (Chapter 5).
The goal is for the sender to communicate the data to the receiver. First the sender needs to specify
which model m to use; this takes C(m) = − log p(m) bits (see Section 5.2). Then the receiver can
fit the model, by computing θˆm, and can thus approximately reconstruct the data. To perfectly
reconstruct the data, the sender needs to send the residual errors that cannot be explained by the
model; this takes
−L(m) = − log p(D|θˆ, m) = −
X
n
log p(yn|xn, θˆ, m) (3.306)
bits. (We are ignoring the cost of sending the input features xn, if present.) The total cost is
LMDL(m) = − log p(D|θˆ, m) + C(m) (3.307)
Choosing the model which minimizes this cost is known as the minimum description length or
MDL principle. See e.g., [HY01] for details.
3.8.7.2 The Bayesian information criterion (BIC)
The Bayesian information criterion or BIC [Sch78] is similar to the MDL, and has the form
LBIC(m) = −2 log p(D|θˆ, m) + Dm log N (3.308)
where Dm is the degrees of freedom of model m.
We can derive the BIC score as a simple approximation to the log marginal likelihood. In particular,
suppose we make a Gaussian approximation to the posterior, as discussed in Section 7.4.3. Then we
get (from Equation (7.28)) the following:
log p(D|m) ≈ log p(D|θˆmap) + log p(θˆmap) −
1
2
log |H| (3.309)
where H is the Hessian of the negative log joint log p(D, θ) evaluated at the MAP estimate θˆmap. We
see that Equation (3.309) is the log likelihood plus some penalty terms. If we have a uniform prior,
p(θ) ∝ 1, we can drop the prior term, and replace the MAP estimate with the MLE, θˆ, yielding
log p(D|m) ≈ log p(D|θˆ) −
1
2
log |H| (3.310)
We now focus on approximating the log |H| term, which is sometimes called the Occam factor,
since it is a measure of model complexity (volume of the posterior distribution). We have H = PN
i=1 Hi
, where Hi = ∇∇ log p(Di
|θ). Let us approximate each Hi by a fixed matrix Hˆ . Then we
have
log |H| = log |NHˆ | = log(N
D|Hˆ |) = D log N + log |Hˆ | (3.311)
where D = dim(θ) and we have assumed H is full rank. We can drop the log |Hˆ | term, since it is
independent of N, and thus will get overwhelmed by the likelihood. Putting all the pieces together,
we get the BIC score that we want to maximize:
JBIC(m) = log p(D|θˆ, m) −
Dm
2
log N (3.312)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.9. MODEL CHECKING
We can also define the BIC loss, that we want to minimize, by multiplying by −2:
LBIC(m) = −2 log p(D|θˆ, m) + Dm log N (3.313)
3.8.7.3 Akaike information criterion
The Akaike information criterion [Aka74] is closely related to BIC. It has the form
LAIC(m) = −2 log p(D|θˆ, m) + 2Dm (3.314)
This penalizes complex models less heavily than BIC, since the regularization term is independent of
N. This estimator can be derived from a frequentist perspective.
3.8.7.4 Widely applicable information criterion (WAIC)
The main problem with MDL, BIC, and AIC is that it can be hard to compute the degrees of a
freedom of a model, needed to define the complexity term, since most parameters are highly correlated
and not uniquely identifiable from the likelihood. In particular, if the mapping from parameters to
the likelihood is not one-to-one, then the model known as a singular statistical model, since the
corresponding Fisher information matrix (Section 3.3.4), and hence the Hessian H above, may be
singular (have determinant 0). An alternative criterion that works even in the singular case is known
as the widely applicable information criterion (WAIC), also known as the Watanabe–Akaike
information criterion [Wat10; Wat13].
WAIC is like other information criteria, except it is more Bayesian. First it replaces the log
likelihood L(m), which uses a point estimate of the parameters, with the LPPD, which marginalizes
them out. (see Equation (3.295)). For the complexity term, WAIC uses the variance of the predictive
distribution:
C(m) = X
N
n=1
Vθ|D,m[log p(yn|xn, θ, m)] ≈
X
N
n=1
V{log p(yn|xn, θs, m) : s = 1 : S} (3.315)
The intuition for this is as follows: if, for a given datapoint n, the different posterior samples θs
make very different predictions, then the model is uncertain, and likely too flexible. The complexity
term essentially counts how often this occurs. The final WAIC loss is
LWAIC(m) = −2LPPD(m) + 2C(m) (3.316)
Interestingly, it can be shown that the PSIS LOO estimate in Section 3.8.6 is asymptotically equivalent
to WAIC [VGG17].
3.9 Model checking
Bayesian inference and decision making is optimal, but only if the modeling assumptions are correct.
In this section, we discuss some ways to assess if a model is reasonable. From a Bayesian perspective,
this can seem a bit odd, since if we knew there was a better model, why don’t we just use that? Here
we assume that we do not have a specific alternative model in mind (so we are not performing model
selection, unlike Section 3.8.1). Instead we are just trying to see if the data we observe is “typical” of
what we might expect if our model were correct. This is called model checking.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license128
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.9.1 Posterior predictive checks
Suppose we are trying to estimate the probability of heads for a coin, θ ∈ [0, 1]. We have two
candidate models or hypotheses, M1 which corresponds to θ = 0.99 and M2 which corresponds to
θ = 0.01. Suppose we flip the coin 40 times and it comes up heads 30 times. Obviously we have
p(M = M1|D) ≫ p(M = M2|D). However model M1 is still a very bad model for the data. (This
example is from [Kru15, p331].)
To evaluate how good a candidate model M is, after seeing some data D, we can imagine using the
model to generate synthetic future datasets, by drawing from the posterior predictive distribution:
D˜ s ∼ p(D| ˜ M, D) = {y
s
1:N ∼ p(·|M, θ
s
), θ
s ∼ p(θ|D, M)} (3.317)
These represent “plausible hallucinations” of the model. To assess the quality of our model, we can
compute how “typical” our observed data D is compared to the model’s hallucinations. To perform
this comparison, we create one or more scalar test statistics, test(D˜ s
), and compare them to the
test statistics on the actual data, test(D). These statistics should measure features of interest (since
it will not, in general, be possible to capture every aspect of the data with a given model). If there is
a large difference between the distribution of test(D˜ s
) across different s and the value of test(D), it
suggests the model is not a good one. This approach called a posterior predictive check [Rub84].
3.9.1.1 Example: 1d Gaussian
To make things clearer, let us consider an example from [Gel+04]. In 1882, Newcomb measured the
speed of light using a certain method and obtained N = 66 measurements, shown in Figure 3.25(a).
There are clearly two outliers in the left tails, suggesting that the distribution is not Gaussian. Let
us nonetheless fit a Gaussian to it. For simplicity, we will just compute the MLE, and use a plug-in
approximation to the posterior predictive density:
p(˜y|D) ≈ N (˜y|µ, ˆ σˆ
2
), µˆ =
1
N
X
N
n=1
yn, σˆ
2 =
1
N
X
N
n=1
(yn − µˆ)
2
(3.318)
Let D˜ s be the s’th dataset of size N = 66 sampled from this distribution, for s = 1 : 1000. The
histogram of D˜ s
for some of these samples is shown in Figure 3.25(b). It is clear that none of the
samples contain the large negative examples that were seen in the real data. This suggests the model
cannot capture the long tails present in the data. (We are assuming that these extreme values are
scientifically interesting, and something we want the model to capture.)
A more formal way to test fit is to define a test statistic. Since we are interested in small values,
let us use
test(D) = min{y : y ∈ D} (3.319)
The empirical distribution of test(D˜ s
) for s = 1 : 1000 is shown in Figure 3.25(c). For the real data,
test(D) = −44, but the test statistics of the generated data, test(D˜ ), are much larger. Indeed, we see
that −44 is in the left tail of the predictive distribution, p(test(D˜ )|D).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.9. MODEL CHECKING
−40 −20 0 20 40
0
10
20
Newcombs Speed of Light Data
(a)
0
5
10
15
0
5
10
15
0 25 50
0
5
10
15
0 25 50 0 25 50
Posterior Samples
(b)
−40 −30 −20 −10 0 10
0
100
200
300
Posterior of min(x), true min=-44
(c)
60 80 100 120 140 160 180
0
100
200
Posterior of var(x), true var=113.71
(d)
Figure 3.25: (a) Histogram of Newcomb’s data. (b) Histograms of data sampled from Gaussian model.
(c) Histogram of test statistic on data sampled from the model, which represents p(test(D˜ s
)|D), where
test(D) = min{y ∈ D}. The vertical line is the test statistic on the true data, test(D). (d) Same as (c) except
test(D) = V{y ∈ D}. Generated by newcomb_plugin_demo.ipynb.
3.9.1.2 Example: linear regression
When fitting conditional models, p(y|x), we will have a different prediction for each input x. We can
compare the predictive distribution p(y|xn) to the observed yn to detect places where the model
does poorly.
As an example of this, we consider the “waffle divorce” dataset from [McE20, Sec 5.1]. This contains
the divorce rate Dn, marriage rate Mn, and age An at first marriage for 50 different US states. We use
a linear regression model to predict the divorce rate, p(y = d|x = (a, m)) = N (d|α + βaa + βmm, σ2
),
using vague priors for the parameters. (In this example, we use a Laplace approximation to
the posterior, discussed in Section 7.4.3.) We then compute the posterior predictive distribution
p(y|xn, D), which is a 1d Gaussian, and plot this vs each observed outcome yn.
The result is shown in Figure 3.26. We see several outliers, some of which have been annotated.
In particular, we see that both Idaho (ID) and Utah (UT) have a much lower divorce rate than
predicted. This is because both of these states have an unusually large proportion of Mormons.
Of course, we expect errors in our predictive models. However, ideally the predictive error bars
for the inputs where the model is wrong would be larger, rather than the model confidently making
errors. In this case, the overconfidence arises from our incorrect use of a linear model.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license130
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2 1 0 1 2
Observed divorce
2
1
0
1
Predicted divorce
ID
ME
RI
UT
Figure 3.26: Posterior predictive distribution for divorce rate vs actual divorce rate for 50 US states. Both
axes are standardized (i.e., z-scores). A few outliers are annotated. Adapted from Figure 5.5 of [McE20].
Generated by linreg_divorce_ppc.ipynb.
3.9.2 Bayesian p-values
If some test statistic of the observed data, test(D), occurs in the left or right tail of the predictive
distribution, then it is very unlikely under the model. We can quantify this using a Bayesian
p-value, also called a posterior predictive p-value:
pB = Pr(test(D˜ ) ≥ test(D)|M, D) (3.320)
where M represents the model we are using, and D˜ is a hypothetical future dataset. In contrast, a
classical or frequentist p-value is defined as
pC = Pr(test(D˜ ) ≥ test(D)|M) (3.321)
where M represents the null hypothesis. The key difference is that the Bayesian compares what was
observed to what one would expect after conditioning the model on the data, whereas the frequentist
compares what was observed to the sampling distribution of the null hypothesis, which is independent
of the data.
We can approximate the Bayesian p-value using Monte Carlo integration, as follows:
pB =
Z
I

test(D˜ ) > test(D)

p(D| ˜ θ)p(θ|D)dθ ≈
1
S
X
S
s=1
I

test(D˜ s
) > test(D)

(3.322)
Any extreme value for pB (i.e., a value near 0 or 1) means that the observed data is unlikely under
the model, as assessed via test statistic test. However, if test(D) is a sufficient statistic of the model,
it is likely to be well estimated, and the p-value will be near 0.5. For example, in the speed of light
example, if we define our test statistic to be the variance of the data, test(D) = V{y : y ∈ D}, we get
a p-value of 0.48. (See Figure 3.25(d).) This shows that the Gaussian model is capable of representing
the variance in the data, even though it is not capable of representing the support (range) of the
data.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.10. HYPOTHESIS TESTING
The above example illustrates the very important point that we should not try to assess whether
the data comes from a given model (for which the answer is nearly always that it does not), but
rather, we should just try to assess whether the model captures the features we care about. See
[Gel+04, ch.6] for a more extensive discussion of this topic.
3.10 Hypothesis testing
Suppose we have collected some coin tossing data, and we want to know if there if the coin is fair or
not. Or, more interestingly, we have collected some clinical trial data, and want to know if there is a
non-zero effect of the treatment on the outcome (e.g., different survival rates for the treatment and
control groups). These kinds of problems can be solved using hypothesis testing. In the sections
below, we summarize several common approaches to hypothesis testing.
3.10.1 Frequentist approach
In this section, we summarize the approach to hypothesis testing that is used in classical or frequentist
statistics, which is known as null hypothesis significance testing or NHST. The basic idea is
to define a binary decision rule of the form δ(D) = I(t(D) ≥ t
∗
), where t(D) is some scalar test
statistic derived from the data, and t
∗
is some critical value. If the test statistic exceeds the
critical value, we reject the null hypothesis.
There is a large “zoo” of possible test statistics one can use (e.g., [Ken93] lists over 100 different
tests), but a simple example is a t-statistic, defined as
t(D) = x − µ
σ/ˆ
√
N
(3.323)
where where x is the empirical mean of D, σˆ is the empirical standard deviation, N is the sample size,
and µ is the population mean, corresponding to the mean value of the null hypothesis (often 0).
To compute the critical value t
∗
, we pick a significance level α, often 0.05, which controls the
type I error rate of the decision procedure (i.e., the probability of accidentally rejecting the null
hypothesis when it is true). We then find the value t
∗ whose tail probability, under the sampling
distribution of the test statistic given the null hypothesis, matches the significance level:
p(t(D˜ ) ≥ t
∗
|H0) = α (3.324)
This construction guarantees that p(δ(D˜ ) = 1|H0) = α.
Rather than comparing t(D) to t
∗
, a more common (but equivalent) approach is to compute the
p-value of t(D), which is defined in Equation (3.86). We can then reject the null hypothesis is p < α.
Unfortunately, despite its widespread use, p-values and NHST have many problems, some of which
are discussed in Section 3.3.5.2. We shall therefore avoid using this approach in this book.
3.10.2 Bayesian approach
In this section, we discucss the Bayesian approach to hypothesis testing. There are in fact two
approaches, one based on model comparison using Bayes factors (Section 3.10.2.1), and one based on
parameter estimation (Section 3.10.2.3).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license132
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Bayes factor BF(1, 0) Interpretation
BF < 1
100 Decisive evidence for M0
BF < 1
10 Strong evidence for M0
1
10 < BF <
1
3 Moderate evidence for M0
1
3 < BF < 1 Weak evidence for M0
1 < BF < 3 Weak evidence for M1
3 < BF < 10 Moderate evidence for M1
BF > 10 Strong evidence for M1
BF > 100 Decisive evidence for M1
Table 3.1: Jeffreys scale of evidence for interpreting Bayes factors.
3.10.2.1 Model comparison approach
Bayesian hypothesis testing is a special case of Bayesian model selection (discussed in Sec￾tion 3.8.1) when we just have two models, commonly called the null hypothesis, M0, and the
alternative hypothesis, M1. Let us define the Bayes factor as the ratio of marginal likelihoods:
B1,0 ,
p(D|M1)
p(D|M0)
=
p(M1|D)
p(M0|D)
/
p(M1)
p(M0)
(3.325)
(This is like a likelihood ratio, except we integrate out the parameters, which allows us to compare
models of different complexity.) If B1,0 > 1 then we prefer model 1, otherwise we prefer model 0 (see
Table 3.1).
We give a worked example of how to compute Bayes factors for a binomial test in Section 3.8.1.1.
For examples of computing Bayes factors for more complex tests, see e.g. [Etz+18; Ly+20].
3.10.2.2 Improper priors cause problems for Bayes factors
Problems can arise when we use improper priors (i.e., priors that do not integrate to 1) for Bayesian
model selection, even though such priors may be acceptable for other purposes, such as parameter
inference. For example, consider testing the hypotheses M0 : θ ∈ Θ0 vs M1 : θ ∈ Θ1. The posterior
probability of M0 is given by
p(M0|D) = p(M0)L0
p(M0)L0 + p(M1)L1
(3.326)
where Li = p(D|Mi) = R
Θi
p(D|θ)p(θ|Mi)dθ is the marginal likelihood for model i.
Suppose (for simplicity) that p(M0) = p(M1) = 0.5, and we use a uniform but improper prior over
the model parameters, p(θ|M0) ∝ c0 and p(θ|M1) ∝ c1. Define ℓi =
R
Θi
p(D|θ)dθ, so Li = ciℓi
. Then
p(M0|D) = c0ℓ0
c0ℓ0 + c1ℓ1
=
ℓ0
ℓ0 + (c1/c0)ℓ1
(3.327)
Thus the posterior (and hence Bayes factor) depends on the arbitrary constants c0 and c1. This is
known as the marginalization paradox. For this reason, we should avoid using improper priors
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.10. HYPOTHESIS TESTING
when performing Bayesian model selection. (However, if the same improper prior is used for common
parameters that are shared between the two hypotheses, then the paradox does not arise.)
More generally, since the marginal likelihood is the likelihood averaged wrt the prior, results can be
quite sensitive to the form of prior that is used. (See also Section 3.8.5, where we discuss conditional
marginal likelihood.)
3.10.2.3 Parameter estimation approach
There are several drawbacks of the Bayesian hypothesis testing approach in Section 3.10.2.1, such as
computational difficulty of computing the marginal likelihood (see Section 3.8.3), and the sensitivity
to the prior (see Section 3.10.2.2). An alternative approach is to estimate the parameters of the model
in the usual way, and then to see how much posterior probability is assigned to the parameter value
corresponding to the null hypothesis. For example, to “test” if a coin is fair, we can first compute
the posterior p(θ|D), and then we can evaluate the plausibility of the null hypothesis by computing
p(0.5 − ǫ < θ < 0.5 + ǫ|D), where (0.5 − ǫ, 0.5 + ǫ) is called the region of practical equivalence or
ROPE [Kru15; KL17c]. This is not only computationally simpler, but is also allows us to quantify the
effect size (i.e., the expected deviation of θ from the null value of 0.5), rather than merely accepting
or rejecting a hypothesis. This approach is therefore called Bayesian estimation. We give some
examples below, following https://www.sumsar.net/blog/2014/01/bayesian-first-aid/. (See
also Section 3.10.3 for ways to perform more general tests usings GLMs.)
3.10.2.4 One sample test of a proportion (Binomial test)
Suppose we perform N coin tosses and observe y heads, where the frequency of heads is θ. We want
to test the null hypothesis that θ = 0.5. In frequentist statistics, we can use a binomial test. We
now present a Bayesian alternative.
First we compute the posterior, p(θ|D) ∝ p(θ)Bin(x|θ, N). To do this, we need to specify a prior. We
will use a noninformative prior. Following Section 3.5.2.1, the Jeffreys prior is p(θ) ∝ Beta(θ|
1
2
,
1
2
), but
[Lee04] argues that the uniform or flat prior, p(θ) ∝ Beta(θ|1, 1), is the least informative when we know
that both heads and tails are possible. The posterior then becomes p(θ|D) = Beta(θ|y + 1, N − y + 1).
From this, we can compute the credible interval I = (ℓ, u) using ℓ = P
−1
(α/2) and u = P
−1
(1−α/2),
where P is the cdf of the posterior. We can also easily compute the probability that the frequency
exceeds the null value using
p(θ > 0.5|D) = Z 1
0.5
p(θ|D)dθ (3.328)
We can compute this quantity using numerical integration or analytically [Coo05].
3.10.2.5 Two sample test of relative proportions (χ
2
test)
Now consider the setting where we have J groups, and in each group j we observe yj successes in Nj
trials. We denote the success rate by θj , and we are interested in testing the hypothesis that θj is the
same for all the groups. In frequentist statistics, we can use a χ
2
test. Here we present a Bayesian
alternative.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license134
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We will use an extension of Section 3.10.2.4, namely yj ∼ Bin(θj , Nj ), where θj ∼ Beta(1, 1), for
j = 1 : J. To simplify notation, assume we J = 2 groups. The posterior is given by
p(θ1, θ2|D) = Beta(θ1|y1 + 1, N1 − y1 + 1)Beta(θ2|y2 + 1, N2 − y2 + 1) (3.329)
We can then compute the posterior of the group difference, δ = θ1 − θ2, using
p(δ|D) = Z 1
0
Z 1
0
I(δ = θ1 − θ2) p(θ1|D1)p(θ2|D2) (3.330)
=
Z 1
0
Beta(θ1|y1 + 1, N1 − y1 + 1)Beta(θ1 − δ|y2 + 1, N2 − y2 + 1)dθ1 (3.331)
We can then use p(δ > 0|D) to decide if the relative proportions between the two groups are
significantly different or not.
3.10.2.6 One sample test of a mean (t-test)
Consider a dataset where we have N real-valued observations yn which we assume come from a
Gaussian, yn ∼ N (µ, σ2
). We would like to test the hypothesis that µ = 0. In frequentist statistics,
the standard approach to this is to use a t-test, which is based on the sampling distribution of the
standardized estimated mean. Here we develop a Bayesian alternative.
If we use a noninformative prior (which is a limiting case of the conjugate Gaussian-gamma prior),
then the posterior for p(µ|D), after marginalizing out σ
2
, is the same as the sampling distribution
of the MLE, µˆ, as we show in Section 15.2.3.2. In particular, both have a Student t distribution.
Consequently, the Bayesian credible interval will be the same as the frequentist confidence interval in
this simple setting.
However, a flat or noninformative prior for p(µ) ∝ 1 and p(σ) ∝ 1 can give poor results, since we
usually do not expect arbitrarily large values. According to [GHV20a], it is generally better to use
weakly informative priors, whose hyperparameters can be derived from statistics of the data. For
example, for the mean, we can use p(µ) = N (µ = 0, σ = 2.5sd(Y )) (assuming the data is centered),
and for the standard deviation, we can use p(σ) = Half-Student-t(µ = 0, σ = sd(y), ν = 4).
11 These
priors are no longer conjugate, but we can easily perform approximate posterior inference using
MCMC or other algorithms discussed in Part II. We call this approach BTT, for “Bayesian t-test”.
[Kru13] proposes to use a Student likelihood yn ∼ T (µ, σ, ν) instead of a Gaussian likelihood, since
it is more robust to outliers. He calls the method BEST method (“Bayesian Estimation Supersedes
the t-test”), but we call it robust BTT. In addition to a different likelihood, robust BTT uses
a different weakly informative prior, namely µ ∼ N (µ = Mµ, σ = Sµ), σ ∈ Unif(σlow, σhigh), and
ν − 1 ∼ Expon(1/29).
12
11. This default prior is used by the Python bambi library [Cap+22], as well as the R rstanarm library (see
https://mc-stan.org/rstanarm/articles/priors.html).
12. The prior for ν is an exponential distribution with mean 29 shifted 1 to the right, which keeps ν away from zero.
According to [Kru13], “This prior was selected because it balances nearly normal distributions (ν > 30) with heavy
tailed distributions (ν < 30)”. To avoid contamination from outliers, the prior for µ uses Mµ = M, where M is the
trimmed mean, and Sµ = 103D, where D is the mean absolute deviation . The prior for σ uses σlow = D/1000 and
σhigh = D × 1000.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.10. HYPOTHESIS TESTING
a b
Group
0
2
4
6
8
10
12
Val
(a)
1.00 1.25 1.50 1.75 2.00 2.25 2.50
1.2 2.2
95% HDI
mean=1.7
Group
(b)
Figure 3.27: Illustration of Bayesian two-sample t-test. (a) Some synthetic data from two groups. (b)
Posterior distribution of the difference, p(µ2 − µ1|D). Generated by ttest_bambi.ipynb.
3.10.2.7 Paired sample test of relative means (paired t-test)
Now suppose we have paired data from two groups, D = {(y1n, y2n) : n = 1 : N}, where we assume
yjn ∼ N (µj , σ2
). We are interested in testing whether µ1 = µ2. A simpler alternative is to define
yn = y2n−y1n, which we model using yn ∼ N (µ, σ2
). We can then test whether µ = 0 using the t-test;
this is called a paired sample t-test. In the Bayesian setting, we can just pass {yn = y2n − y1n}
to the BTT procedure of Section 3.10.2.6.
3.10.2.8 Two sample test of relative means (two sample t-test)
In this section, we consider the setting in which we have two datasets, D1 = {y1n ∼ N (µ1, σ2
1
) : n =
1 : N1} and D2 = {y2n ∼ N (µ2, σ2
2
) : n = 1 : N2}, and we want to test the null hypothesis that
µ1 = µ2. If we assume σ
2
1 = σ
2
2
, we can use a two-sample t-test, also called an independent
t-test or unpaired t-test. If we allow the variance of the observations to vary by group, then we
can use Welch’s t-test.
In the Bayesian setting, we can tackle this by generalizing the BTT model of Section 3.10.2.6 to
two groups by defining yjn ∼ N (µj , σ2
j
), for j = 1, 2. (We can also use a robust likelihood.) Once we
have specified the model, we can perform posterior inference in the usual way, and compute quantities
such as p(µ1 − µ2 > 0|D). See Figure 3.27 for an example.
3.10.2.9 Testing a correlation coefficient
In this section, we consider the setting in which we have some data D = {(xn, yn) : n = 1 : N},
where (x, y) be may be correlated with a Pearson correlation coefficient of ρ. We are interested
in testing the null hypothesis that ρ = 0.
In the Bayesian setting, we can do this by generalizing the two-sample BTT approach of Sec￾tion 3.10.2.8. Specifically, we assume
(xn, yn) ∼ N (µ, Σ) (3.332)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license136
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Y X P/N Name Model Exact
R - P One-sample t-test y ∼ N (µ, σ2
) X
R - N Wilcoxon signed-ranked SR(y) ∼ N (µ, σ2
) N > 14
(R, R) - P Paired-sample t-test y2 − y1 ∼ N (µ, σ2
) X
(R, R) - N Wilcoxon matched pairs SR(y2 − y1) ∼ N (µ, σ2
) X
R R P Pearson correlation y ∼ N (β0 + β1x, σ2
) X
R R N Spearman correlation R(y) ∼ N (β0 + β1R(x), σ2
) N > 10
R {0, 1} P Two-sample t-test y ∼ N (β0 + β1x, σ2
) X
R {0, 1} P Welch’s t-test y ∼ N (β0 + β1x, σ2
x
) X
R {0, 1} N Mann-Whitney U SR(y) ∼ N (β0 + β1x, σ2
x
) N > 11
R [J] P One-way ANOVA y ∼ N (faov(x; β), σ2
) X
R [J] N Kruskal-Wallis R(y) ∼ N (faov(x; β), σ2
) N > 11
R [J] × [K] N Two-way ANOVA y ∼ N (faov2(x1, x2; β), σ2
) X
Table 3.2: Many common statistical tests are equivalent to performing inference for the parameters of simple
linear models. Here P/N represents parametric vs nonparametric test; we approximate the latter by using the
rank function R(y) or the signed rank function SR(y). The last column, labeled “exact”, specifies the sample
size for which this approximation becomes accurate enough to be indistinguishable from the exact result. When
the input variable is categorical, x1 ∈ [J], where [J] = {1, . . . , J}, we define the mean of the output using the
analysis of variance function faov(x1, β). When we have two categorical inputs, x1 ∈ [J] and x2 ∈ [K], we
use faov2(x1, x2; β). Adapted from the crib sheet at https: // lindeloev. github. io/ tests-as-linear/ .
where µ = [µ1, µ2], and
Σ =

σ
2
1 ρσ1σ2
ρσaσ2 σ
2
2

(3.333)
We use the same (data-driven) priors for µj and σj , and use a uniform prior for the correlation,
p(ρ) = Unif(−1, 1), following [BMM00]. Once we have specified the model, we can perform posterior
inference in the usual way, and compute quantities such as p(ρ > 0|D).
3.10.3 Common statistical tests correspond to inference in linear models
We have now seen many different tests, and it may be unclear what test to use when. Fortunately,
[Lin19] points out that many of the most common tests can be represented exactly (or approximately)
in terms of inference (either Bayesian or frequentist) about the parameters of a generalized linear
model or GLM (see Chapter 15 for details on GLMs). This approach is easier to understand and
more flexible, as discussed at length in e.g., [Kru15; GHV20b]. We summarize some of these results
in Table 3.2 and the discussion below.
3.10.3.1 Approximating nonparametric tests using the rank transform
It is common to use “nonparametric tests”, which generalize standard tests to settings where the
data do not necessarily follow a Gaussian or Student distribution. A simple way to approximate such
tests is to replace the original data with its order statistics, and then to apply a standard parametric
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.10. HYPOTHESIS TESTING
−4 −2 0 2 4
−4
−2
0
2
4
(-3.2, -0.5)
(1.7, 1.8)
(1.3, 2.6)
(-1.6, -0.5) (-0.8, -0.7) (-0.1, -0.9)
(3.7, 2.3)
(-1.0, -0.7)
(-1.0, 0.0)(0.8, 0.1) (0.2, 0.5)
(-1.8, -2.8)
(-0.3, -0.2)
(-2.3, -3.1)
(-2.0, -2.1)
(3.6, 4.5)
(-0.1, 0.5)
(1.0, -0.8)
(3.2, 4.7)
(-2.6, -2.1)
(-0.5, -1.5)
(0.3, 2.2)
(-0.7, -0.3)(1.1, 0.0)
(-0.1, 1.4)
(-0.1, -0.4) (0.8, -0.6)
(-3.5, -4.8)
(-2.4, -2.8)
(-0.0, -0.8)
Pearson
β0 (Intercept)
β1 (Slope)
0 10 20 30
0
10
20
30
(2, 14)
(27, 25)
(26, 28)
(8, 15)
(11, 12)
(16, 8)
(30, 27)
(10, 11)
(23, 21) (9, 20)
(20, 23)
(7, 3)
(14, 18)
(5, 2)
(6, 5)
(29, 29)
(17, 22)
(24, 10)
(28, 30)
(3, 6) (13, 7)
(21, 26)
(12, 17)
(25, 19)
(18, 24)
(15, 16)
(22, 13)
(1, 1)
(4, 4)
(19, 9)
Spearman
β0 (Intercept)
β1 (Slope)
Figure 3.28: Illustration of 1d linear regression applied to some data (left) and its rank-transformed version
(right). Generated by linreg_rank_stats.ipynb.
test, as proposed in [CI81]. This gives a good approximation to the standard nonparametric tests for
sample sizes of N ≥ 10.
Concretely, we can compute a rank transform, in which the data points (assumed to be scalar)
are sorted, and then replaced by their integer value in the ordering. For example, the rank transform
of D = (3.6, 3.4, −5.0, 8.2) is R(D) = (3, 2, 1, 4). Alternatively we may use the signed ranked, which
first sorts the values according to their absolute size, and then attaches the corresponding sign. For
example, the signed rank transform of D = (3.6, 3.4, −5.0, 8.2) is SR(D) = (2, 1, −3, 4).
We can now easily fit a parametric model, such as a GLM, to the rank-transformed data, as
illustrated in Figure 3.28. (In [Doo+17], they propose a Bayesian interpretation of this, where the
order statistics are viewed as observations of an underyling latent continuous quantity, on which
inference is performed.) We will use this trick in the sections below.
3.10.3.2 Metric-predicted variable on one or two groups (t-test)
Suppose we have some data D = {yn ∼ N (µ, σ2
) : n = 1 : N}, and we are interested in testing the
null hypothesis that µ = 0. We can model this as a linear regression model with a constant input
(bias term), and no covariates: p(yn|θ) = N (yn|β0, σ2
), where β0 = µ. We can now perform inference
on β0 in the usual way for GLMs, and then perform hypothesis testing. This is equivalent to the
one sample t-test discussed in Section 3.10.2.6. For a nonparametric version, we can transform
the data using the signed rank transform, thus fitting SR(yn) ∼ N (µ, σ2
). The results are very close
to the Wilcoxon signed-ranked test.
Now suppose we have paired data from two groups, D = {(y1n, y2n) : n = 1 : N}, where we assume
yjn ∼ N (µj , σ2
). We are interested in testing whether µ1 = µ2. A simpler alternative is to define
yn = y2n − y1n, which we model using yn ∼ N (µ, σ2
). We can then test whether µ = 0 using the
paired sample t-test, discussed in Section 3.10.2.6. Alternatively we can do inference on SR(yn),
to get the Wilcoxon matched pairs test.
To handle the setting in which we have unpaired data from two groups, we can represent the
data as D = {(xn, yn) : n = 1 : N}, where xn ∈ {0, 1} represents whether the input belongs
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license138
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0.0 0.5 1.0 1.5 2.0 2.5 3.0
−4
−2
0
2
4
β0 (group 1 mean)
β2, β3, ... (slopes/differences to β0)
β0 + β2, β0 + β3... (group 2, 3 ... means)
Figure 3.29: Illustration of one-way ANOVA with 4 groups. We are interested in testing whether the red lines
have a slope of 0, meaning that all the groups have the same mean. Generated by anova.ipynb.
to group 0 or group 1. We assume the data comes from the following linear regression model:
p(yn|xn) ∼ N (β0 + β1xn, σ2
). We can now perform inference on β in the usual way for GLMs,
and then perform hypothesis testing. This is equivalent to the two-sample t-test discussed in
Section 3.10.2.8. In the nonparametric setting, we can replace y with its signed ranked transform and
use the model SR(y) ∼ N (β0 + β1x, σ2
). This is approximately the same as the Mann-Whitney
U test.
3.10.3.3 Metric-predicted variable with metric predictors (correlation test)
In this section, we assume the data has the form D = {(xn, yn) : n = 1 : N}, where xn ∈ R and
yn ∈ R are correlated with Pearson correlation coefficient of ρ. We are interested in testing the
hypothesis that ρ = 0.
We can use a “bespoke” Bayesian approach as in Section 3.10.2.9. Alternatively, we can model this
using simple linear regression, by writing yn ∼ N (β0 + β1x, σ2
). If we scale the output Y so it has a
standard deviation of 1, then we find that β1 = ρ, as shown in [Mur22, Sec 11.2.3.3]. Thus we can
use p(β1|D) to make inferences about ρ.
In the nonparametric setting, we compute the rank transform of x and y and then proceed as
above. The Spearman rank correlation coefficient is the Pearson correlation coefficient on the
rank-transformed data. While Pearson’s correlation is useful for assessing the strength of linear
relationships, Spearman’s correlation can be used to assess general monotonic relationships, whether
linear or not.
If we have multiple metric predictors (i.e., xn ∈ R
D), we can use multiple linear regression instead
of simple linear regression. We can then derive the posterior of the partial correlation coefficient from
the posterior of the regression weights.
3.10.3.4 Metric-predicted variable with one nominal predictor (one-way ANOVA)
In this section, we consider the setting in which we have some data D = {(xn, yn) : n = 1 : N},
where xn ∈ {1, . . . , J} represents which group the input belongs. (Such a discrete categorical variable
is often called a factor.) We assume the data comes from the following linear regression model:
p(yn|xn = j) ∼ N (µj , σ2
). We are interested in testing the hypothesis that all the µj are the same.
This is traditionally performed using a one-way ANOVA test, where ANOVA stands for “analysis
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.10. HYPOTHESIS TESTING
of variance”. To derive a nonparametric test, we can first apply a rank transformation to y. This is
similar to the Kruskal-Wallis test.
ANOVA assumes that the data are normally distributed, with a common (shared) variance, so
that the sampling distribution of the F-statistic can be derived. We can write the corresponding
model as a linear regression model, by using a dummy encoding of xn, where xn[j] = I(xn = j). To
avoid overparameterization (which can make the posterior unidentifiable), we drop the first level
(this is known as reduced rank encoding). We can then write the model as
p(yn|xn; θ) ∼ N (faov(xn, β), σ2
) (3.334)
where we define the predicted mean using the ANOVA formula:
faov(x, β) = β0 + β2x[2] + · · · + βJ x[J] (3.335)
We see that β0 is the overall mean, and also corresponds to the value that will be used for level 1 of
the factor (i.e., if xn = 1). The other βj terms represents deviations away from level 1. The null
hpothesis corresponds to the assumption that βj = 0 for all j = 2 : J.
A more symmetric formulation of the model is to write
faov(x; β) = β0 + β1x[1] + β2x[2] + · · · + βJ x[J] (3.336)
where β0 is the grand mean, and where we impose the constraint that PJ
j=1 βj = 0. In this case
we can interpret each βj as the amount that group j deviates from the shared baseline β0. To satisfy
this constraint, we can write the predicted mean as
faov(x, β˜) = β˜
0 +
X
J
j=1
β˜
jx[j] = (β˜
0 + β)
| {z }
β0
+
X
J
j=1
(β˜
j − β)
| {z }
βj
x[j] (3.337)
where β˜
j are the unconstrained parameters, and β =
1
J
PJ
j=1 β˜
j . This construction satisfies the
constraint, since
X
J
j=1
βj =
X
J
j=1
β˜
j −
X
J
j=1
β = Jβ − Jβ = 0 (3.338)
In traditional ANOVA, we assume that the data are normally distributed, with a common (shared)
variance. In a Bayesian setting, we are free to relax these assumptions. For example, we can use a
different likelihood (e.g., Student) and we can allow each group to have its own variance, σ
2
j
, which
can be reliably estimated using a hierarchical Bayesian model (see Section 3.6).
3.10.3.5 Metric-predicted variable with multiple nominal predictors (multi-way ANOVA)
In this section, we consider the setting in which we have G nominal predictors as input. To simplify
notation, we assume we just have G = 2 groups. We assume the mean of y is given by
faov2(x) = µ +
X
j
αjx1,[j] +
X
k
βkx2,[k] +
X
jk
γjkx1,[j]x2,[k] (3.339)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license140
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
LH RH
Male 9 43 N1 = 52
Female 4 44 N2 = 48
Totals 13 87 100
Table 3.3: A 2 × 2 contingency table from http: // en. wikipedia. org/ wiki/ Contingency_ table .
where we impose the following sum-to-zero contraints
X
j
αj =
X
k
βk =
X
j
γjk =
X
k
γjk = 0 (3.340)
We are interested in testing whether γ = 0, meaning there is no interaction effect. This is traditionally
done using a two-way ANOVA test. However, we can also use a Bayesian approach and just
compute p(θ|D).
3.10.3.6 Count predicted variable with nominal predictors (χ
2
test)
Consider a situation in which we observed two nominal values for each item measured. For example,
the gender of a person (male or female) and whether they are left handed or right handed (LH or RH).
If we count the number of outcomes of each type, we can represent the data as a R ×C contingency
table. See Table 3.3 for an example. We may be interested in testing the null hypothesis that
there is no interaction effect between the two groups and the outcome (i.e., the two variables are
independent). In frequentist statistics, this is often tackled using a χ
2
-test, which uses the sampling
distribution of the χ
2
test statistic, defined as
χ
2 =
X
R
r=1
X
C
c=1
(Or,c − Er,c)
2
Er,c
(3.341)
where r indexes the rows, and c the columns, Or,c is the observed count in cell (r, c), and Erc = N pr.p.c
is the expected count, where pr. = Oc./N and p.c = O.r/N are the empirical marginal frequencies.
In the Bayesian approach, we can just modify the two-way ANOVA of Section 3.10.3.5, and replace
the Gaussian distribution with a Poisson distribution. We also need to pass the predicted natural
parameter through an exponential link, since a Poisson distribution requires that the rate parameter
is non-negative. Thus the model becomes
p(y|x = (r, c), θ) = Poi(y|λr,c) (3.342)
λrc = exp(β0 + βr + βc + βr,c) (3.343)
We can now perform posterior inference in the usual way.
3.10.3.7 Non-metric predicted variables
If the output variable is categorical, yn ∈ {1, . . . , C}, we can use logistic regression instead of linear
regression (see e.g., Section 15.3.9). If the output is ordinal, we can use ordinal regression. If the
output is a count variable, we can use Poisson regression. And so on. For more details on GLMs, see
Chapter 15.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
3.11. MISSING DATA
θ
Xn
Yn Rn
(a)
θ
Xn
Yn Rn
(b)
θ
Xn
Yn Rn
(c)
Figure 3.30: Graphical models to represent different patterns of missing data for conditional (discriminative)
models. (a) Missing completely at random. (b) Missing at random. (c) Missing not at random. The
semi-shaded yn node is observed if rn = 1 and is hidden otherwise. Adapted from Figure 2 of [SG02].
3.11 Missing data
Sometimes we may have missing data, in which parts of the data vector Xn ∈ R
D may be unknown.
(If we have a supervised problem, we append the labels to the feature vector.) We let Xn,mis represent
the missing parts, and Xn,obs represent the observed parts. Since the reasons that data are missing
may be informative (e.g., declining to answer a survey question such as “Do you have disease X?”
may be an indication that the subject does in fact have it), we need to model the missing data
mechanism. To do this, we introduce a random variable Rn, to represent which parts of Xn are
“revealed” (observed) or not. Specifically, we set Rn,obs = 1 for those indices (components) for which
Xn is observed, and set Rn,mis = 0 for the other indices.
There are different kinds of assumptions we can make about the missing data mechanism, as
discussed in [Rub76; LR87]. The strongest assumption is to assume the data is missing completely
at random or MCAR. This means that p(Rn|Xn) = p(Rn), so the missingness does not depend
on the hidden or observed features. A more realistic assumption is known as missing at random
or MAR. This means that p(Rn|Xn) = p(Rn|Xn,obs), so the missingness does not depend on the
hidden features, but may depend on the visible features. If neither of these assumptions hold, we say
the data is missing not at random or MNAR.
Now consider the case of conditional, or discriminative models, in which we model the outcome yn
given observed inputs xn using a model of the form p(yn|xn, θ). Since we are conditioning on xn,
we assume it is always observed. However, the output labels may or may not be observed, depending
on the value of rn. For example, in semi-supervised learning, we have a combination of labeled
data, DL = {(xn, yn)}, and unlabeled data, DU = {(xn)} [CSZ06].
The 3 missing data scenarios for the discriminative setting are shown in Figure 3.30, using graphical
model notation (see [MPT13] for details). In the MCAR and MAR cases, we see that we can just
ignore the unlabeled data with missing outputs, since the unknown model parameters θ are unaffected
by yn if it is a hidden leaf node. However, in the MNAR case, we see that θ depends on yn, even it
is hidden, since the value of yn is assumed to affect the probability of rn, which is always observed.
In such cases, to fit the model, we need to impute the missing values, by using methods such as EM
(see Section 6.5.3).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license142
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Now consider the case where we use a joint or generative model of the form p(x, y) = p(y)p(x|y),
instead of a discriminative model of the form p(y|x).
13 In this case, the unlabeled data can be useful
for learning even in the MCAR and MAR scenarios, since θ now depends on both x and y. In
particular, information about p(x) can be informative about p(y|x). See e.g., [CSZ06] for details.
13. In [Sch+12a], they call a model of the form p(y|x) a “causal classifier”, since the features cause the labels, and a
model of the form p(x|y) an “anti-causal classifier”, since the features are caused by the labels.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20234 Graphical models
4.1 Introduction
I basically know of two principles for treating complicated systems in simple ways: the first is
the principle of modularity and the second is the principle of abstraction. I am an apologist
for computational probability in machine learning because I believe that probability theory
implements these two principles in deep and intriguing ways — namely through factorization
and through averaging. Exploiting these two mechanisms as fully as possible seems to me to
be the way forward in machine learning. — Michael Jordan, 1997 (quoted in [Fre98]).
Probabilistic graphical models (PGMs) provide a convenient formalism for defining joint distri￾butions on sets of random variables. In such graphs, the nodes represent random variables, and the
(lack of) edges represent conditional independence (CI) assumptions between these variables. A
better name for these models would be “independence diagrams”, but the term “graphical models” is
now entrenched.
There are several kinds of graphical model, depending on whether the graph is directed, undirected,
or some combination of directed and undirected, as we discuss in the sections below. More details on
graphical models can be found in e.g., [KF09a].
4.2 Directed graphical models (Bayes nets)
In this section, we discuss directed probabilistic graphical models, or DPGM, which are based
on directed acyclic graphs or DAGs (graphs that do not have any directed cycles). PGMs
based on a DAG are often called Bayesian networks or Bayes nets for short; however, there is
nothing inherently “Bayesian” about Bayesian networks: they are just a way of defining probability
distributions. They are also sometimes called belief networks. The term “belief” here refers to
subjective probability. However, the probabilities used in these models are no more (and no less)
subjective than in any other kind of probabilistic model.
4.2.1 Representing the joint distribution
The key property of a DAG is that the nodes can be ordered such that parents come before children.
This is called a topological ordering. Given such an order, we define the ordered Markov
property to be the assumption that a node is conditionally independent of all its predecessors in144
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
x1 x2 x3
···
(a)
x1 x2 x3
···
(b)
Figure 4.1: Illustration of first and second order Markov models.
the ordering given its parents, i.e.,
xi ⊥ xpred(i)\pa(i)
|xpa(i) (4.1)
where pa(i) are the parents of node i, and pred(i) are the predecessors of node i in the ordering.
Consequently, we can represent the joint distribution as follows (assuming we use node ordering
1 : NG):
p(x1:NG ) = p(x1)p(x2|x1)p(x3|x1, x2). . . p(xNG |x1, . . . , xNG−1) = Y
NG
i=1
p(xi
|xpa(i)) (4.2)
where p(xi
|xpa(i)) is the conditional probability distribution or CPD for node i. (The parame￾ters of this distribution are omitted from the notation for brevity.)
The key advantage of the representation used in Equation (4.2) is that the number of parameters
used to specify the joint distribution is substantially less, by virtue of the conditional independence
assumptions that we have encoded in the graph, than an unstructured joint distribution. To see this,
suppose all the variables are discrete and have K states each. Then an unstructured joint distribution
needs O(KNG ) parameters to specify the probability of every configuration. By contrast, with a
DAG in which each node has at most NP parents, we only need O(NGKNP +1) parameters, which
can be exponentially fewer if the DAG is sparse.
We give some examples of DPGM’s in Section 4.2.2, and in Section 4.2.4, we discuss how to read
off other conditional independence properties from the graph.
4.2.2 Examples
In this section, we give several examples of models that can be usefully represented as DPGM’s.
4.2.2.1 Markov chains
We can represent the conditional independence assumptions of a first-order Markov model using the
chain-structured DPGM shown in Figure 4.1(a). Consider a variable at a single time step t, which
we call the “present”. From the diagram, we see that information cannot flow from the past, x1:t−1,
to the future, xt+1:T , except via the present, xt. (We formalize this in Section 4.2.4.) This means
that the xt is a sufficient statistic for the past, so the model is first-order Markov. This implies that
the corresponding joint distribution can be written as follows:
p(x1:T ) = p(x1)p(x2|x1)p(x3|x2)· · · p(xT |xT −1) = p(x1)
Y
T
t=2
p(xt|x1:t−1) (4.3)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.2. DIRECTED GRAPHICAL MODELS (BAYES NETS)
For discrete random variables, we can represent corresponding CPDs, p(xt = k|xt−1 = j), as a
2d table, known as a conditional probability table or CPT, p(xt = k|xt−1 = j) = θjk, where
0 ≤ θjk ≤ 1 and PK
k=1 θjk = 1 (i.e., each row sums to 1).
The first-order Markov assumption is quite restrictive. If we want to allow for dependencies two
steps into the past, we can create a Markov model of order 2. This is shown in Figure 4.1(b). The
corresponding joint distribution has the form
p(x1:T ) = p(x1, x2)p(x3|x1, x2)p(x4|x2, x3)· · · p(xT |xT −2, xT −1) = p(x1, x2)
Y
T
t=3
p(xt|xt−2:t−1) (4.4)
As we increase the order of the Markov model, we need to add more edges. In the limit, the DAG
becomes fully connected (subject to being acyclic), as shown in Figure 22.1. However, in this case,
there are no useful conditional independencies, so the graphical model has no value.
4.2.2.2 The “student” network
Figure 4.2 shows a model for capturing the inter dependencies between 5 discrete random variables
related to a hypothetical student taking a class: D = difficulty of class (easy, hard), I = intelligence
(low, high), G = grade (A, B, C), S = SAT score (bad, good), L = letter of recommendation (bad,
good). (This is a simplification of the “student network” from [KF09a, p.281].) The chain rule
tells us that we can represent the joint as follows:
p(D, I, G, L, S) = p(L|S, G, D, I) × p(S|G, D, I) × p(G|D, I) × p(D|I) × p(I) (4.5)
where we have ordered the nodes topologically as I, D, G, S, L. Note that L is conditionally
independent of all the other nodes earlier in this ordering given its parent G, so we can replace
p(L|S, G, D, I) by p(L|G). We can simplify the other terms in a similar way to get
p(D, I, G, L, S) = p(L|G) × p(S|I) × p(G|D, I) × p(D) × p(I) (4.6)
The ability to simplify a joint distribution in a product of small local pieces is the key idea behind
graphical models.
In addition to the graph structure, we need to specify the conditional probability distributions
(CPDs) at each node. For discrete random variables, we can represent the CPD as a table, which
means we have a separate row (i.e., a separate categorical distribution) for each conditioning case,
i.e., for each combination of parent values. We can represent the i’th CPT as follows:
θijk , p(xi = k|xpa(i) = j) (4.7)
The matrix θi,:,:
is a row stochastic matrix, that satisfies the properties 0 ≤ θijk ≤ 1 and
PKi
k=1 θijk = 1 for each row j. Here i indexes nodes, i ∈ [NG]; k indexes node states, k ∈ [Ki
],
where Ki
is the number of states for node i; and j indexes joint parent states, j ∈ [Ji
], where
Ji =
Q
p∈pa(i) Kp.
The CPTs for the student network are shown next to each node in Figure 4.2. For example, we see
that if the class is hard (D = 1) and the student has low intelligence (I = 0), the distribution over
grades A, B, and C we expect is p(G|D = 1, I = 0) = [0.05, 0.25, 0.7]; but if the student is intelligent,
we get p(G|D = 1, I = 1) = [0.5, 0.3, 0.2].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license146
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
 Diff 
Easy Hard
0.60 0.40
 Grade 
A B C
Low, Easy 0.30 0.40 0.30
Low, Hard 0.05 0.25 0.70
High, Easy 0.90 0.08 0.02
High, Hard 0.50 0.30 0.20
 Intel 
Low High
0.70 0.30
 SAT 
Bad Good
Low 0.95 0.05
High 0.20 0.80
 Letter 
Bad Good
A 0.10 0.90
B 0.40 0.60
C 0.99 0.01
Figure 4.2: The (simplified) student network. “Diff ” is the difficulty of the class. “Intel” is the intelligence
of the student. “Grade” is the grade of the student in this class. “SAT” is the score of the student on the
SAT exam. “Letter” is whether the teacher writes a good or bad letter of recommendation. The circles
(nodes) represent random variables, the edges represent direct probabilistic dependencies. The tables inside
each node represent the conditional probability distribution of the node given its parents. Generated by
student_pgm.ipynb.
The number of parameters in a CPT is O(Kp+1), where K is the number of states per node, and
p is the number of parents. Later we will consider more parsimonious representations, with fewer
learnable parameters. (We discuss parameter learning in Section 4.2.7.)
Once we have specified the model, we can use it to answer probabilistic queries, as we discuss in
Section 4.2.6. As an example, suppose we observe that the student gets a grade of C. The posterior
probability that the student is intelligent is just p(I = High|G = C) = 0.08, as shown in Figure 4.8.
However, now suppose we also observe that the student gets a good SAT score. Now the posterior
probability that the student is intelligent has jumped to p(I = High|G = C, S = Good) = 0.58, since
we can explain the C grade by inferring it was a difficult class (indeed, we find p(D = Hard|G =
C, S = Good) = 0.76). This negative mutual interaction between multiple causes of some observations
is called the explaining away effect, also known as Berkson’s paradox (see Section 4.2.4.2 for
details).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.2. DIRECTED GRAPHICAL MODELS (BAYES NETS)
(a) (b)
Figure 4.3: (a) Hierarchical latent variable model with 2 layers. (b) Same as (a) but with autoregressive
connections within each layer. The observed x variables are the shaded leaf nodes at the bottom. The unshaded
nodes are the hidden z variables.
4.2.2.3 Sigmoid belief nets
In this section, we consider a deep generative model of the form shown in Figure 4.3a. This
corresponds to the following joint distribution:
p(x, z) = p(z2)p(z1|z2)p(x|z1) = Y
K2
k=1
p(z2,k)
Y
K1
k=1
p(z1,k|z2)
Y
D
d=1
p(xd|z1) (4.8)
where x denotes the visible leaf nodes, and zℓ denotes the hidden internal nodes. (We assume there
are Kℓ hidden nodes at level ℓ, and D visible leaf nodes.)
Now consider the special case where all the latent variables are binary, and all the latent CPDs are
logistic regression models. That is,
p(zℓ|zℓ+1, θ) = Y
Kℓ
k=1
Ber(zℓ,k|σ(wT
ℓ,kzℓ+1)) (4.9)
where σ(u) = 1/(1 + e
−u
) is the sigmoid (logistic) function. The result is called a sigmoid belief
net [Nea92].
At the bottom layer, p(x|z1, θ), we use whatever observation model is appropriate for the type of
data we are dealing with. For example, for real valued data, we might use
p(x|z1, θ) = Y
D
d=1
N (xd|wT
1,d,µz1, exp(wT
1,d,σz1)) (4.10)
where w1,d,µ are the weights that control the mean of the d’th output, and w1,d,σ are the weights
that control the variance of the d’th output.
We can also add directed connections between the hidden variables within a layer, as shown in
Figure 4.3b. This is called a deep autoregressive network or DARN model [Gre+14], which
combines ideas from latent variable modeling and autoregressive modeling.
We discuss other forms of hierarchical generative models in Chapter 21.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license148
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.2.3 Gaussian Bayes nets
Consider a DPGM where all the variables are real-valued, and all the CPDs have the following form,
known as a linear Gaussian CPD:
p(xi
|xpa(i)) = N (xi
|µi + wT
i xpa(i)
, σ2
i
) (4.11)
As we show below, multiplying all these CPDs together results in a large joint Gaussian distribution
of the form p(x) = N (x|µ, Σ), where x ∈ R
NG . This is called a directed Gaussian graphical
model or a Gaussian Bayes net.
We now explain how to derive µ and Σ, following [SK89, App. B]. For convenience, we rewrite
the CPDs in the following form:
xi = µi +
X
j∈pa(i)
wi,j (xj − µj ) + σizi (4.12)
where zi ∼ N (0, 1), σi
is the conditional standard deviation of xi given its parents, wi,j is the strength
of the j → i edge, and µi
is the local mean.1
It is easy to see that the global mean is just the concatenation of the local means, µ = (µ1, . . . , µNG ).
We now derive the global covariance, Σ. Let S , diag(σ) be a diagonal matrix containing the
standard deviations. We can rewrite Equation (4.12) in matrix-vector form as follows:
(x − µ) = W(x − µ) + Sz (4.13)
where W is the matrix of regression weights. Now let e be a vector of noise terms: e , Sz. We can
rearrange this to get e = (I − W)(x − µ). Since W is lower triangular (because wj,i = 0 if j < i in
the topological ordering), we have that I − W is lower triangular with 1s on the diagonal. Hence


e1
e2
.
.
.
eNG


=


1
−w2,1 1
−w3,2 −w3,1 1
.
.
.
.
.
.
−wNG,1 −wNG,2 . . . −wNG,NG−1 1




x1 − µ1
x2 − µ2
.
.
.
xNG − µNG


(4.14)
Since I − W is always invertible, we can write
x − µ = (I − W)
−1e , Ue = USz (4.15)
where we defined U = (I − W)
−1
. Hence the covariance is given by
Σ = Cov [x] = Cov [x − µ] = Cov [USz] = US Cov [z] SUT = US2UT
(4.16)
since Cov [z] = I.
1. If we do not subtract off the parent’s mean (i.e., if we use xi = µi +
P
j∈pa(i) wi,jxj + σizi), the derivation of Σ is
much messier, as can be seen by looking at [Bis06, p370].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.2. DIRECTED GRAPHICAL MODELS (BAYES NETS)
4.2.4 Conditional independence properties
We write xA ⊥G xB|xC if A is conditionally independent of B given C in the graph G. (We discuss
how to determine whether such a CI property is implied by a given graph in the sections below.) Let
I(G) be the set of all such CI statements encoded by the graph, and I(p) be the set of all such CI
statements that hold true in some distribution p. We say that G is an I-map (independence map)
for p, or that p is Markov wrt G, iff I(G) ⊆ I(p). In other words, the graph is an I-map if it does
not make any assertions of CI that are not true of the distribution. This allows us to use the graph
as a safe proxy for p when reasoning about p’s CI properties. This is helpful for designing algorithms
that work for large classes of distributions, regardless of their specific numerical parameters. Note
that the fully connected graph is an I-map of all distributions, since it makes no CI assertions at all,
as we show below. We therefore say G is a minimal I-map of p if G is an I-map of p, and if there
is no G′ ⊆ G which is an I-map of p.
We now turn to the question of how to derive I(G), i.e., which CI properties are entailed by a
DAG.
4.2.4.1 Global Markov properties (d-separation)
We say an undirected path P is d-separated by a set of nodes C (containing the evidence) iff at
least one of the following conditions hold:
1. P contains a chain or pipe, s → m → t or s ← m ← t, where m ∈ C
2. P contains a tent or fork, s ւmց t, where m ∈ C
3. P contains a collider or v-structure, s ցmւ t, where m is not in C and neither is any
descendant of m.
Next, we say that a set of nodes A is d-separated from a different set of nodes B given a third
observed set C iff each undirected path from every node a ∈ A to every node b ∈ B is d-separated by
C. Finally, we define the CI properties of a DAG as follows:
XA ⊥G XB|XC ⇐⇒ A is d-separated from B given C (4.17)
This is called the (directed) global Markov property.
The Bayes ball algorithm [Sha98] is a simple way to see if A is d-separated from B given C,
based on the above definition. The idea is this. We “shade” all nodes in C, indicating that they are
observed. We then place “balls” at each node in A, let them “bounce around” according to some
rules, and then ask if any of the balls reach any of the nodes in B. The three main rules are shown
in Figure 4.4. Notice that balls can travel opposite to edge directions. We see that a ball can pass
through a chain, but not if it is shaded in the middle. Similarly, a ball can pass through a fork, but
not if it is shaded in the middle. However, a ball cannot pass through a v-structure, unless it is
shaded in the middle.
We can justify the 3 rules of Bayes ball as follows. First consider a chain structure X → Y → Z,
which encodes
p(x, y, z) = p(x)p(y|x)p(z|y) (4.18)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license150
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
X Y Z X Y Z
X Z
Y
X
Y
Z
X Z
Y
X Z
Y
(a)
(b)
(c) (d)
(e) (f)
Figure 4.4: Bayes ball rules. A shaded node is one we condition on. If there is an arrow hitting a bar, it
means the ball cannot pass through; otherwise the ball can pass through.
(a)
(b)
(c)
X Y X Y
X Z
Y
Y’
Figure 4.5: (a-b) Bayes ball boundary conditions. (c) Example of why we need boundary conditions. Y
′
is an
observed child of Y , rendering Y “effectively observed”, so the ball bounces back up on its way from X to Z.
When we condition on y, are x and z independent? We have
p(x, z|y) = p(x, y,)
p(y)
=
p(x)p(y|x)p(z|y)
p(y)
=
p(x, y)p(z|y)
p(y)
= p(x|y)p(z|y) (4.19)
and therefore X ⊥ Z | Y . So observing the middle node of chain breaks it in two (as in a Markov
chain).
Now consider the tent structure X ← Y → Z. The joint is
p(x, y, z) = p(y)p(x|y)p(z|y) (4.20)
When we condition on y, are x and z independent? We have
p(x, z|y) = p(x, y, z)
p(y)
=
p(y)p(x|y)p(z|y)
p(y)
= p(x|y)p(z|y) (4.21)
and therefore X ⊥ Z | Y . So observing a root node separates its children (as in a naive Bayes
classifier: see Section 4.2.8.2).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.2. DIRECTED GRAPHICAL MODELS (BAYES NETS)
X Y Z
D I
D I S
D S
D S I
D S L, I
D S G, I
D S G, L, I
D L G
D L G, S
D L G, I
D L I, G, S
Table 4.1: Conditional independence relationships implied by the student DAG (Figure 4.2). Each line has
the form X ⊥ Y |Z. Generated by student_pgm.ipynb.
Finally consider a v-structure X → Y ← Z. The joint is
p(x, y, z) = p(x)p(z)p(y|x, z) (4.22)
When we condition on y, are x and z independent? We have
p(x, z|y) = p(x)p(z)p(y|x, z)
p(y)
(4.23)
so X 6⊥ Z|Y . However, in the unconditional distribution, we have
p(x, z) = p(x)p(z) (4.24)
so we see that X and Z are marginally independent. So we see that conditioning on a common
child at the bottom of a v-structure makes its parents become dependent. This important effect is
called explaining away, inter-causal reasoning, or Berkson’s paradox (see Section 4.2.4.2 for
a discussion).
Finally, Bayes ball also needs the “boundary conditions” shown in Figure 4.5(a-b). These rules
say that a ball hitting a hidden leaf stops, but a ball hitting an observed leaf “bounces back”. To
understand where this rule comes from, consider Figure 4.5(c). Suppose Y
′
is a (possibly noisy) copy
of Y . If we observe Y
′
, we effectively observe Y as well, so the parents X and Z have to compete to
explain this. So if we send a ball down X → Y → Y
′
, it should “bounce back” up along Y
′ → Y → Z,
in order to pass information between the parents. However, if Y and all its children are hidden, the
ball does not bounce back.
As an example of the CI statements encoded by a DAG, Table 4.1 shows some properties that
follow from the student network in Figure 4.2.
4.2.4.2 Explaining away (Berkson’s paradox)
In this section, we give some examples of the explaining away phenomenon, also called Berkson’s
paradox.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license152
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−7.5 −5.0 −2.5 0.0 2.5 5.0 7.5
value
0
200
400
600
800
1000
1200
number of samples
x
y
z
(a)
−10 −8 −6 −4 −2 0
x
0
2
4
6
8
10
y
(b)
−6 −4 −2 0 2 4 6 8
value
0
10
20
30
40
50
60
70
number of samples
x
y
z
(c)
−10 −8 −6 −4 −2 0
x
0
2
4
6
8
10
y
(d)
Figure 4.6: Samples from a jointly Gaussian DPGM, p(x, y, z) = N (x| − 5, 1)N (y|5, 1)N (z|x + y, 1). (a)
Unconditional marginal distributions, p(x), p(y), p(z). (b) Unconditional joint distribution, p(x, y). (c)
Conditional marginal distribution, p(x|z > 2.5), p(y|z > 2.5), p(z|z > 2.5). (d) Conditional joint distribution,
p(x, y|z > 2.5). Adapted from [Clo20]. Generated by berksons_gaussian.ipynb.
As a simple example (from [PM18b, p198]), consider tossing two coins 100 times. Suppose you
only record the outcome of the experiment if at least one coin shows up heads. You should expect
to record about 75 entries. You will see that every time coin 1 is recorded as tails, coin 2 will be
recorded as heads. If we ignore the way in which the data was collected, we might infer from the
fact that coins 1 and 2 are correlated that there is a hidden common cause. However, the correct
explanation is that the correlation is due to conditioning on a hidden common effect (namely the
decision of whether to record the outcome or not, so we can censor tail-tail events). This is called
selection bias.
As another example of this, consider a Gaussian DPGM of the form
p(x, y, z) = N (x| − 5, 1)N (y|5, 1)N (z|x + y, 1) (4.25)
The graph structure is X → Z ← Y , where Z is the child node. Some samples from the unconditional
joint distribution p(x, y, z) are shown in Figure 4.6(a); we see that X and Y are uncorrelated. Now
suppose we only select samples where z > 2.5. Some samples from the conditional joint distribution
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.2. DIRECTED GRAPHICAL MODELS (BAYES NETS)
p(x, y|z > 2.5) are shown in Figure 4.6(d); we see that now X and Y are correlated. This could cause
us to erroneously conclude that there is a causal relationship, but in fact the dependency is caused
by selection bias.
4.2.4.3 Markov blankets
The smallest set of nodes that renders a node i conditionally independent of all the other nodes in
the graph is called i’s Markov blanket; we will denote this by mb(i). Below we show that the
Markov blanket of a node in a DPGM is equal to the parents, the children, and the co-parents, i.e.,
other nodes who are also parents of its children:
mb(i) , ch(i) ∪ pa(i) ∪ copa(i) (4.26)
See Figure 4.7 for an illustration.
To see why this is true, let us partition all the nodes into the target node Xi
, its parents U, its
children Y , its coparents Z, and the other variables O. Let X−i be all the nodes except Xi
. Then
we have
p(Xi
|X−i) = p(Xi
, X−i)
P
x
p(Xi = x, X−i)
(4.27)
=
p(Xi
, U, Y, Z, O)
P
x
p(Xi = x, U, Y, Z, O)
(4.28)
=
p(Xi
|U)[Q
j
p(Yj |Xi
, Zj )]P(U, Z, O)
P
x
p(Xi = x|U)[Q
j
p(Yj |Xi = x, Zj )]P(U, Z, O)
(4.29)
=
p(Xi
|U)[Q
j
p(Yj |Xi
, Zj )]
P
x
p(Xi = x|U)[Q
j
p(Yj |Xi = x, Zj )] (4.30)
∝ p(Xi
|pa(Xi)) Y
Yj∈ch(Xi)
p(Yj |pa(Yj ))) (4.31)
where ch(Xi) are the children of Xi and pa(Yj ) are the parents of Yj . We see that the terms that do
not involve Xi cancel out from the numerator and denominator, so we are left with a product of
terms that include Xi
in their “scope”. Hence the full conditional for node i becomes
p(xi
|x−i) = p(xi
|xmb(i)) ∝ p(xi
|xpa(i))
Y
k∈ch(i)
p(xk|xpa(k)) (4.32)
We will see applications of this in Gibbs sampling (Equation (12.19)), and mean field variational
inference (Equation (10.87)).
4.2.4.4 Other Markov properties
From the d-separation criterion, one can conclude that
i ⊥ nd(i) \ pa(i)|pa(i) (4.33)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license154
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 4.7: Illustration of the Markov blanket of a node in a directed graphical model. The target node Xi is
shown in gray, its parents U1:m are shown in green, its children Y1:n are shown in blue, and its coparents
Z1:n,1:j are shown in red. Xi is conditionally independent of all the other variables in the model given these
variables. Adapted from Figure 13.4b of [RN19].
where the non-descendants of a node nd(i) are all the nodes except for its descendants, nd(i) =
{1, . . . , NG} \ {i ∪ desc(i)}. Equation (4.33) is called the (directed) local Markov property. For
example, in Figure 4.23(a), we have nd(3) = {1, 2, 4}, and pa(3) = 1, so 3 ⊥ 2, 4|1.
A special case of this property is when we only look at predecessors of a node according to some
topological ordering. We have
i ⊥ pred(i) \ pa(i)|pa(i) (4.34)
which follows since pred(i) ⊆ nd(i). This is called the ordered Markov property, which justifies
Equation (4.2). For example, in Figure 4.23(a), if we use the ordering 1, 2, . . . , 7. we find pred(3) =
{1, 2} and pa(3) = 1, so 3 ⊥ 2|1.
We have now described three Markov properties for DAGs: the directed global Markov property
G in Equation (4.17), the directed local Markov property L in Equation (4.33), and the ordered
Markov property O in Equation (4.34), It is obvious that G =⇒ L =⇒ O. What is less obvious,
but nevertheless true, is that O =⇒ L =⇒ G (see e.g., [KF09a] for the proof). Hence all these
properties are equivalent.
Furthermore, any distribution p that is Markov wrt a graph can be factorized as in Equation (4.2);
this is called the factorization property F. It is obvious that O =⇒ F, but one can show that
the converse also holds (see e.g., [KF09a] for the proof).
4.2.5 Generation (sampling)
It is easy to generate prior samples from a DPGM: we simply visit the nodes in topological order,
parents before children, and then sample a value for each node given the value of its parents. This
will generate independent samples from the joint, (x1, . . . , xNG ) ∼ p(x|θ). This is called ancestral
sampling.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.2. DIRECTED GRAPHICAL MODELS (BAYES NETS)
4.2.6 Inference
In the context of PGMs, the term “inference” refers to the task of computing the posterior over a
set of query nodes Q given the observed values for a set of visible nodes V , while marginalizing
over the irrelevant nuisance variables, R = {1, . . . , NG} \ {Q, V }:
pθ(Q|V ) = pθ(Q, V )
pθ(V )
=
P
R pθ(Q, V, R)
pθ(V )
(4.35)
(If the variables are continuous, we should replace sums with integrals.) If Q is a single node, then
pθ(Q|V ) is called the posterior marginal for node Q.
As an example, suppose V = x is a sequence of observed sound waves, Q = z is the corresponding
set of unknown spoken words, and R = r are random “non-semantic” factors associated with the
signal, such as prosody or background noise. Our goal is to compute the posterior over the words
given the sounds, while being invariant to the irrelevant factors:
pθ(z|x) = X
r
pθ(z, r|x) = X
r
pθ(z, r, x)
pθ(x)
=
X
r
pθ(z, r, x)
P
z′
,r′ pθ(z
′
, r
′
, x)
(4.36)
As a simplification, we can “lump” the random factors R into the query set Q to define the complete
set of hidden variables H = Q ∪ R. In this case, the tasks simpifies to
pθ(h|x) = pθ(h, x)
pθ(x)
=
pθ(h, x)
P
h′ pθ(h′
, x)
(4.37)
The computational complexity of the inference task depends on the CI properties of the graph, as
we discuss in Chapter 9. In general it is NP-hard (see Section 9.5.4), but for certain graph structures
(such as chains, trees, and other sparse graphs), it can be solved efficiently (in polynomial) time
using dynamic programming (see Chapter 9). For cases where it is intractable, we can use standard
methods for approximate Bayesian inference, which we review in Chapter 7.
4.2.6.1 Example: inference in the student network
As an example of inference in PGMs, consider the student network from Section 4.2.2.2. Suppose we
observe that the student gets a grade of C. The posterior marginals are shown in Figure 4.8a. We see
that the low grade could be explained by the class being hard (since p(D = Hard|G = C) = 0.63),
but is more likely explained by the student having low intelligence (since p(I = High|G = C) = 0.08).
However, now suppose we also observe that the student gets a good SAT score. The new posterior
marginals are shown in Figure 4.8b. Now the posterior probability that the student is intelligent has
jumped to p(I = High|G = C, SAT = Good) = 0.58, since otherwise it would be difficult to explain
the good SAT score. Once we believe the student has high intelligence, we have to explain the C
grade by assuming the class is hard, and indeed we find that the probability that the class is hard
has increased to p(D = Hard|G = C) = 0.76. (This negative mutual interaction between multiple
causes of some observations is called the explaining away effect, and is discussed in Section 4.2.4.2.)
4.2.7 Learning
So far, we have assumed that the structure G and parameters θ of the PGM are known. However, it
is possible to learn both of these from data. For details on how to learn G from data, see Section 30.3.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license156
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
 Diff 
Easy Hard
0.37 0.63
 Grade 
A B C
0.0 0.0 1.0
 Letter 
Bad Good
0.99 0.01
 Intel 
Low High
0.92 0.08
 SAT 
Bad Good
0.89 0.11
(a)
 Diff 
Easy Hard
0.24 0.76
 Grade 
A B C
0.0 0.0 1.0
 Letter 
Bad Good
0.99 0.01
 Intel 
Low High
0.42 0.58
 SAT 
Bad Good
0.0 1.0
(b)
Figure 4.8: Illustration of belief updating in the “Student” PGM. The histograms show the marginal distribution
of each node. Nodes with shaded titles are clamped to an observed value. (a) Posterior after conditioning on
Grade=C. (b) Posterior after also conditioning on SAT=Good. Generated by student_pgm.ipynb.
θy
y1 yN
· · ·
x1 xN
θx
Figure 4.9: A DPGM representing the joint distribution p(y1:N , x1:N , θy, θx). Here θx and θy are global
parameter nodes that are shared across the examples, whereas xn and yn are local variables.
Here we focus on parameter learning, i.e., computing the posterior p(θ|D, G). (Henceforth we will
drop the conditioning on G, since we assume the graph structure is fixed.)
We can compute the parameter posterior p(θ|D) by treating θ as “just another hidden variable”,
and then performing inference. However, in the machine learning community, it is more common to
just compute a point estimate of the parameters, such as the posterior mode, θˆ = argmax p(θ|D).
This approximation is often reasonable, since the parameters depend on all the data, rather than
just a single datapoint, and are therefore less uncertain than other hidden variables.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.2. DIRECTED GRAPHICAL MODELS (BAYES NETS)
4.2.7.1 Learning from complete data
Figure 4.9 represents a graphical model for a typical supervised learning problem. We have N local
variables, xn and yn, and 2 global variables, corresponding to the parameters, which are shared
across data samples. The local variables are observed (in the training set), so they are represented
by solid (shaded) nodes. The global variables are not observed, and hence are represented by empty
(unshaded) nodes. (The model represents a generative classifier, so the edge is from yn to xn; if we
are fitting a discriminative classifier, the edge would be from xn to yn, and there would be no θy
prior node.)
From the CI properties of Figure 4.9, it follows that the joint distribution factorizes into a product
of terms, one per node:
p(θ, D) = p(θx)p(θy)
"Y
N
n=1
p(yn|θy)p(xn|yn, θx)
#
(4.38)
=
"
p(θy)
Y
N
n=1
p(yn|θy)
# "p(θx)
Y
N
n=1
p(xn|yn, θx)
#
(4.39)
= [p(θy)p(Dy|θy)] [p(θx)p(Dx|θx)] (4.40)
where Dy = {yn}
N
n=1 is the data that is sufficient for estimating θy and Dx = {xn, yn}
N
n=1 is the
data that is sufficient for θx.
From Equation (4.40), we see that the prior, likelihood, and posterior all decompose or factorize
according to the graph structure. Thus we can compute the posterior for each parameter independently.
In general, we have
p(θ, D) = Y
NG
i=1
p(θi)p(Di
|θi) (4.41)
Hence the likelihood and prior factorizes, and thus so does the posterior. If we just want to compute
the MLE, we can compute
θˆ = argmax
θ
Y
NG
i=1
p(Di
|θi) (4.42)
We can solve this for each node independently, as we illustrate in Section 4.2.7.2.
4.2.7.2 Example: computing the MLE for CPTs
In this section, we illustrate how to compute the MLE for tabular CPDs. The likelihood is given by
the following product of multinomials:
p(D|θ) = Y
N
n=1
Y
NG
i=1
p(xni|xn,pa(i)
, θi) (4.43)
=
Y
N
n=1
Y
NG
i=1
Y
Ji
j=1
Y
Ki
k=1
θ
I(xni=k,xn,pa(i)=j)
ijk (4.44)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license158
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
I D G S L
0 0 2 0 0
0 1 2 0 0
0 0 1 1 1
1 1 1 1 0
1 0 0 1 1
0 0 0 0 1
1 1 2 1 1
Table 4.2: Some fully observed training data for the student network.
I D Ni,j,k ˆθi,j,k θi,j,k
0 0 [1, 1, 1] [
1
3
,
1
3
,
1
3
] [ 2
6
,
2
6
,
2
6
]
0 1 [0, 0, 1] [
0
1
,
0
1
,
1
1
] [ 1
4
,
1
4
,
2
4
]
1 0 [1, 0, 0] [
1
1
,
0
1
,
0
1
] [ 2
4
,
1
4
,
1
4
]
1 1 [0, 1, 1] [0,
1
2
,
1
2
] [ 1
5
,
2
5
,
2
5
]
Table 4.3: Sufficient statistics Nijk and corresponding MLE ˆθijk and posterior mean θijk (with Dirichlet
(1,1,1) prior) for node i = G in the student network. Each row corresponds to a different joint configuration
of its parent nodes, coresponding to state j. The index k refers to the 3 possible values of the child node G.
where
θijk , p(xi = k|xpa(i) = j) (4.45)
Let us define the sufficient statistics for node i to be Nijk, which is the number of times that node i
is in state k while its parents are in joint state j:
Nijk ,
X
N
n=1
I
￾
xn,i = k, xn,pa(i) = j

(4.46)
The MLE for a multinomial is given by the normalized empirical frequencies:
ˆθijk = P
Nijk
k′ Nijk′
(4.47)
For example, consider the student network from Section 4.2.2.2. In Table 4.2, we show some sample
training data. For example, the last line in the tabel encodes a student who is smart (I = 1), who
takes a hard class (D = 1), gets a C (G = 2), but who does well on the SAT (S = 1) and gets a good
letter of recommendation (L = 1).
In Table 4.3, we list the sufficient statistics Nijk and the MLE ˆθijk for node i = G, with parents
(I, D). A similar process can be used for the other nodes. Thus we see that fitting a DPGM with
tabular CPDs reduces to a simple counting problem.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.2. DIRECTED GRAPHICAL MODELS (BAYES NETS)
θz
z1 zN
· · ·
x1 xN
θx
Figure 4.10: A DPGM representing the joint distribution p(z1:N , x1:N , θz, θx). The local variables zn are
hidden, whereas xn are observed. This is typical for learning unsupervised latent variable models.
However, we notice there are a lot of zeros in the sufficient statistics, due to the small sample size,
resulting in extreme estimates for some of the probabilities ˆθijk. We discuss a (Bayesian) solution to
this in Section 4.2.7.3.
4.2.7.3 Example: computing the posterior for CPTs
In Section 4.2.7.2 we discussed how to compute the MLE for the CPTs in a discrete Bayes net. We
also observed that this can suffer from the zero-count problem. In this section, we show how a
Bayesian approach can solve this problem.
Let us put a separate Dirichlet prior on each row of each CPT, i.e., θij ∼ Dir(αij ). Then
we can compute the posterior by simply adding the pseudocounts to the empirical counts to get
θij |D ∼ Dir(Nij + αij ), where Nij = {Nijk : k = 1 : Ki}, and Nijk is the number of times that node
i is in state k while its parents are in state j. Hence the posterior mean estimate is given by
θijk = P
Nijk + αijk
k′ (Nijk′ + αijk′ )
(4.48)
The MAP estimate has the same form, except we use αijk − 1 instead of αijk.
In Table 4.3, we illustrate this approach applied to the G node in the student network, where we
use a uniform Dirichlet prior, αijk = 1.
4.2.7.4 Learning from incomplete data
In Section 4.2.7.1, we explained that when we have complete data, the likelihood (and posterior)
factorizes over CPDs, so we can estimate each CPD independently. Unfortunately, this is no longer
the case when we have incomplete or missing data. To see this, consider Figure 4.10. The likelihood
of the observed data can be written as follows:
p(D|θ) = X
z1:N
"Y
N
n=1
p(zn|θz)p(xn|zn, θx)
#
(4.49)
=
Y
N
n=1
X
zn
p(zn|θz)p(xn|zn, θx) (4.50)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license160
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Thus the log likelihood is given by
ℓ(θ) = X
n
logX
zn
p(zn|θz)p(xn|zn, θx) (4.51)
The log function does not distribute over the P
zn
operation, so the objective does not decompose
over nodes.2 Consequently, we can no longer compute the MLE or the posterior by solving separate
problems per node.
To solve this, we will resort to optimization methods. (We focus on the MLE case, and leave
discussion of Bayesian inference for latent variable models to Part II.) In the sections below, we
discuss how to use EM and SGD to find a local optimum of the (non convex) log likelihood objective.
4.2.7.5 Using EM to fit CPTs in the incomplete data case
A popular method for estimating the parameters of a DPGM in the presence of missing data is to
the use the expectation maximization (EM) algorithm, as proposed in [Lau95]. We describe EM
in detail in Section 6.5.3, but the basic idea is to alternate between inferring the latent variables
zn (the E or expectation step), and estimating the parameters given this completed dataset (the
M or maximization step). Rather than returning the full posterior p(zn|xn, θ
(t)
) in the E step, we
instead return the expected sufficient statistics (ESS), which takes much less space. In the M step,
we maximize the expected value of the log likelihood of the fully observed data using these ESS.
As an example, suppose all the CPDs are tabular, as in the example in Section 4.2.7.2. The
log-likelihood of the complete data is given by
log p(D|θ) = X
NG
i=1
X
Ji
j=1
X
Ki
k=1
Nijk log θijk (4.52)
and hence the expected complete data log-likelihood has the form
E [log p(D|θ)] = X
i
X
j
X
k
Nijk log θijk (4.53)
where
Nijk =
X
N
n=1
E

I
￾
xni = k, xn,pa(i) = j
 =
X
N
n=1
p(xni = k, xn,pa(i) = j|Dn, θ
old) (4.54)
where Dn are all the visible variables in case n, and θ
old are the parameters from the previous iteration.
The quantity p(xni, xn,pa(i)
|Dn, θ
old) is known as a family marginal, and can be computed using
any GM inference algorithm. The Nijk are the expected sufficient statistics (ESS), and constitute
the output of the E step.
2. We can also see this from the graphical model: θx is no longer independent of θz, because there is a path that
connects them via the hidden nodes zn. (See Section 4.2.4 for an explanation of how to “read off” such CI properties
from a DPGM.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.2. DIRECTED GRAPHICAL MODELS (BAYES NETS)
Given these ESS, the M step has the simple form
ˆθijk =
Nijk
P
k′ Nijk′
(4.55)
We can modify this to perform MAP estimation with a Dirichlet prior by simply adding pseudocounts
to the expected counts.
The famous Baum-Welch algorithm is a special case of the above equations which arises when the
DPGM is an HMM (see Section 29.4.1 for details).
4.2.7.6 Using SGD to fit CPTs in the incomplete data case
The EM algorithm is a batch algorithm. To scale up to large datasets, it is more common to use
stochastic gradient descent or SGD (see e.g., [BC94; Bin+97]). To apply this, we need to compute
the marginal likelihood of the observed data for each example:
p(xn|θ) = X
zn
p(zn|θz)p(xn|zn, θx) (4.56)
where θ = (θz, θx).) (We say that we have “collapsed” the model by marginalizing out zn.) We can
then compute the log likelihood using
ℓ(θ) = log p(D|θ) = log Y
N
n=1
p(xn|θ=
X
N
n=1
log p(xn|θ) (4.57)
The gradient of this objective can be computed as follows:
∇θℓ(θ) = X
n
∇θ log p(xn|θ) (4.58)
=
X
n
1
p(xn|θ)
∇θp(xn|θ) (4.59)
=
X
n
1
p(xn|θ)
∇θ
"X
zn
p(zn, xn|θ)
#
(4.60)
=
X
n
X
zn
p(zn, xn|θ)
p(xn|θ)
∇θ log p(zn, xn|θ) (4.61)
=
X
n
X
zn
p(zn|xn, θ)∇θ log p(zn, xn|θ) (4.62)
We can now apply a minibatch approximation to this in the usual way.
4.2.8 Plate notation
To make the parameters of a PGM explicit, we can add them as nodes to the graph, and treat them
as hidden variables to be inferred. Figure 4.11(a) shows a simple example, in which we have N iid
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license162
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
θ
x1
. . .
xN
N
θ
xn
Figure 4.11: Left: datapoints xn are conditionally independent given θ. Right: Same model, using plate
notation. This represents the same model as the one on the left, except the repeated xn nodes are inside a
box, known as a plate; the number in the lower right hand corner, N, specifies the number of repetitions of
the xn node.
random variables, xn, all drawn from the same distribution with common parameter θ. We denote
this by
xn ∼ p(x|θ) (4.63)
The corresponding joint distribution over the parameters and data D = {x1, . . . , xN } has the form
p(D, θ) = p(θ)p(D|θ) (4.64)
where p(θ) is the prior distribution for the parameters, and p(D|θ) is the likelihood. By virtue of the
iid assumption, the likelihood can be rewritten as follows:
p(D|θ) = Y
N
n=1
p(xn|θ) (4.65)
Notice that the order of the data vectors is not important for defining this model, i.e., we can permute
the leaves of the DPGM. When this property holds, we say that the data is exchangeable.
In Figure 4.11(a), we see that the x nodes are repeated N times. (The shaded nodes represent
observed values, whereas the unshaded (hollow) nodes represent latent variables or parameters.) To
avoid visual clutter, it is common to use a form of syntactic sugar called plates. This is a notational
convention in which we draw a little box around the repeated variables, with the understanding that
nodes within the box will get repeated when the model is unrolled. We often write the number of
copies or repetitions in the bottom right corner of the box. This is illustrated in Figure 4.11(b).
4.2.8.1 Example: factor analysis
In Section 28.3.1, we discuss the factor analysis model, which has the form
p(z) = N (z|µ0
, Σ0) (4.66)
p(x|z) = N (x|Wz + µ, Ψ) (4.67)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.2. DIRECTED GRAPHICAL MODELS (BAYES NETS)
(a)
µ
Ψ
xn N
zn
W
µ0 Σ0
(b)
Figure 4.12: (a) Factor analysis model illustrated as a DPGM. We show the components of z (top row) and x
(bottom row) as individual scalar nodes. (b) Equivalent model, where z and x are collapsed to vector-valued
nodes, and parameters are added, using plate notation.
Y
X1 X2
· · · XD
(a)
D
C
N
θdc
xnd
yn
π
(b)
Figure 4.13: (a) Naive Bayes classifier as a DPGM. (b) Model augmented with plate notation.
where W is a D×L matrix, known as the factor loading matrix, and Ψ is a diagonal D×D covariance
matrix.
Note that z and x are both vectors. We can explicitly represent their components as scalar nodes
as in Figure 4.12a. Here the directed edges correspond to non-zero entries in the W matrix.
We can also explicitly show the parameters of the model, using plate notation, as shown in
Figure 4.12b.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license164
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Y = 1
X
X1
2 X3
X4
(a)
Y = 2
X
X1
2 X3
X4
(b)
Figure 4.14: Tree-augmented naive Bayes classifier for D = 4 features. The tree topology can change depending
on the value of y, as illustrated.
4.2.8.2 Example: naive Bayes classifier
In some models, we have doubly indexed variables. For example, consider a naive Bayes classifier.
This is a simple generative classifier, defined as follows:
p(x, y|θ) = p(y|π)
Y
D
d=1
p(xd|y, θd) (4.68)
The fact that the features x1:D are considered conditionally independent given the class label y is
where the term “naive” comes from. Nevertheless, this model often works surprisingly well, and is
extremely easy to fit.
We can represent the conditional independence assumption as shown in Figure 4.13a. We can
represent the repetition over the dimension d with a plate. When we turn to infering the parameters
θ = (π, θ1:D,1:C ), we also need to represent the repetition over data cases n. This is shown in
Figure 4.13b. Note that the parameter θdc depends on d and c, whereas the feature xnd depends on
n and d. This is shown using nested plates to represent the shared d index.
4.2.8.3 Example: relaxing the naive Bayes assumption
We see from Figure 4.13a that the observed features are conditionally independent given the class
label. We can of course allow for dependencies between the features, as illustrated in Figure 4.14.
(We omit parameter nodes for simplicity.) If we enforce that the edges between the features forms a
tree the model is known as a tree-augmented naive Bayes classifier [FGG97], or TAN model.
(Trees are a restricted form of graphical model that have various computational advantages that we
discuss later.) Note that the topology of the tree can change depending on the value of the class node
y; in this case, the model is known as a Bayesian multi net, and can be thought of as a supervised
mixture of trees.
4.3 Undirected graphical models (Markov random fields)
Directed graphical models (Section 4.2) are very useful. However, for some domains, being forced to
choose a direction for the edges, as required by a DAG, is rather awkward. For example, consider
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.3. UNDIRECTED GRAPHICAL MODELS (MARKOV RANDOM FIELDS)
X1 X2 X3 X4 X5
X6 X7 X8 X9 X10
X11 X12 X13 X14 X15
X16 X17 X18 X19 X20
(a)
X1 X2 X3 X4 X5
X6 X7 X8 X9 X10
X11 X12 X13 X14 X15
X16 X17 X18 X19 X20
(b)
Figure 4.15: (a) A 2d lattice represented as a DAG. The dotted red node X8 is independent of all other nodes
(black) given its Markov blanket, which include its parents (blue), children (green) and co-parents (orange).
(b) The same model represented as a UPGM. The red node X8 is independent of the other black nodes given
its neighbors (blue nodes).
modeling an image. It is reasonable to assume that the intensity values of neighboring pixels are
correlated. We can model this using a DAG with a 2d lattice topology as shown in Figure 4.15(a).
This is known as a Markov mesh [AHK65]. However, its conditional independence properties are
rather unnatural.
An alternative is to use an undirected probabilistic graphical model (UPGM), also called a
Markov random field (MRF) or Markov network. These do not require us to specify edge
orientations, and are much more natural for some problems such as image analysis and spatial
statistics. For example, an undirected 2d lattice is shown in Figure 4.15(b); now the Markov blanket
of each node is just its nearest neighbors, as we show in Section 4.3.6.
Roughly speaking, the main advantages of UPGMs over DPGMs are: (1) they are symmetric and
therefore more “natural” for certain domains, such as spatial or relational data; and (2) discriminative
UPGMs (aka conditional random fields, or CRFs), which define conditional densities of the form
p(y|x), work better than discriminative DGMs, for reasons we explain in Section 4.5.3. The main
disadvantages of UPGMs compared to DPGMs are: (1) the parameters are less interpretable and
less modular, for reasons we explain in Section 4.3.1; and (2) it is more computationally expensive to
estimate the parameters, for reasons we explain in Section 4.3.9.1.
4.3.1 Representing the joint distribution
Since there is no topological ordering associated with an undirected graph, we can’t use the chain
rule to represent p(x1:NG ). So instead of associating CPDs with each node, we associate potential
functions or factors with each maximal clique in the graph.3 We will denote the potential
function for clique c by ψc(xc; θc), where θc are its parameters. A potential function can be any
non-negative function of its arguments (we give some examples below). We can use these functions
to define the joint distribution as we explain in Section 4.3.1.1.
3. A clique is a set of nodes that are all neighbors of each other. A maximal clique is a clique which cannot be
made any larger without losing the clique property.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license166
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.3.1.1 Hammersley-Clifford theorem
Suppose a joint distribution p satisfies the CI properties implied by the undirected graph G. (We
discuss how to derive these properties in Section 4.3.6.) Then the Hammersley-Clifford theorem
tells us that p can be written as follows:
p(x|θ) = 1
Z(θ)
Y
c∈C
ψc(xc; θc) (4.69)
where C is the set of all the (maximal) cliques of the graph G, and Z(θ) is the partition function
given by
Z(θ) ,
X
x
Y
c∈C
ψc(xc; θc) (4.70)
Note that the partition function is what ensures the overall distribution sums to 1.4
The Hammersley-Clifford theorem was never published, but a proof can be found in [KF09a].
(Note that the theorem only holds for positive distributions, i.e., ones where p(x|θ) ≥ 0 for all
configurations x, which rules out some models with hard constraints.)
4.3.1.2 Gibbs distribution
The distribution in Equation (4.69) can be rewritten as follows:
p(x|θ) = 1
Z(θ)
exp(−E(x; θ)) (4.71)
where E(x) > 0 is the energy of state x, defined by
E(x; θ) = X
c
E(xc; θc) (4.72)
where xc are the variables in clique c. We can see the equivalence by defining the clique potentials as
ψc(xc; θc) = exp(−E(xc; θc)) (4.73)
We see that low energy is associated with high probability states.
Equation (4.71) is known as the Gibbs distribution. This kind of probability model is also called
an energy-based model. These are commonly used in physics and biochemistry. They are also
used in ML to define generative models, as we discuss in Chapter 24. (See also Section 4.4, where
we discuss conditional random fields (CRFs), which are models of the form p(y|x, θ), where the
potential functions are conditioned on input features x.)
4.3.2 Fully visible MRFs (Ising, Potts, Hopfield, etc.)
In this section, we discuss some UPGMs for 2d grids, that are used in statistical physics and computer
vision. We then discuss extensions to other graph structures, which are useful for biological modeling
and pattern completion.
4. The partition function is denoted by Z because of the German word Zustandssumme, which means “sum over states”.
This reflects the fact that a lot of pioneering working on MRFs was done by German (and Austrian) physicists, such as
Boltzmann.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.3. UNDIRECTED GRAPHICAL MODELS (MARKOV RANDOM FIELDS)
4.3.2.1 Ising models
Consider the 2d lattice in Figure 4.15(b). We can represent the joint distribution as follows:
p(x|θ) = 1
Z(θ)
Y
i∼j
ψij (xi
, xj ; θ) (4.74)
where i ∼ j means i and j are neighbors in the graph. This is called a 2d lattice model.
An Ising model is a special case of the above, where the variables xi are binary. Such models
are often used to represent magnetic materials. In particular, each node represents an atom, which
can have a magnetic dipole, or spin, which is in one of two states, +1 and −1. In some magnetic
systems, neighboring spins like to be similar; in other systems, they like to be dissimilar. We can
capture this interaction by defining the clique potentials as follows:
ψij (xi
, xj ; θ) = (
e
Jij if xi = xj
e
−Jij if xi 6= xj
(4.75)
where Jij is the coupling strength between nodes i and j. This is known as the Ising model. If
two nodes are not connected in the graph, we set Jij = 0. We assume that the weight matrix is
symmetric, so Jij = Jji. Often we also assume all edges have the same strength, so Jij = J for each
(i, j) edge. Thus
ψij (xi
, xj ; J) = (
e
J
if xi = xj
e
−J
if xi 6= xj
(4.76)
It is more common to define the Ising model as an energy-based model, as follows:
p(x|θ) = 1
Z(J)
exp(−E(x; J)) (4.77)
E(x; J) = −J
X
i∼j
xixj (4.78)
where E(x; J) is the energy, and where we exploited the fact that xixj = −1 if xi 6= xj , and xixj = +1
if xi = xj . The magnitude of J controls the degree of coupling strength between neighboring sites,
which depends on the (inverse) temperature of the system (colder = more tightly coupled = larger
magnitude J).
If all the edge weights are positive, J > 0, then neighboring spins are likely to be in the same
state, since if xi = xj , the energy term gets a contribution of −J < 0, and lower energy corresponds
to higher probability. In the machine learning literature, this is called an associative Markov
network. In the physics literature, this is called a ferromagnetic model. If the weights are
sufficiently strong, the corresponding probability distribution will have two modes, corresponding to
the two checkerboard patterns in Figure 4.16a. These are called the ground states of the system.
If all of the weights are negative, J < 0, then the spins want to be different from their neighbors (see
Figure 4.16b). This is called an antiferromagnetic system, and results in a frustrated system,
since it is not possible for all neighbors to be different from each other in a 2d lattice. Thus the
corresponding probability distribution will have multiple modes, corresponding to different “solutions”
to the problem.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license168
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 4.16: (a) The two ground states for a small ferromagnetic Ising model where J = 1. (b) Two different
states for a small Ising model which have the same energy. Left: J = 1, so neighboring pixels have similar
values. Right: J = −1, so neighboring pixels have different values. From Figures 31.7 and 31.8 of [Mac03].
0 50 100
x1
0
50
100
x2
J = 0.2
(a)
0 50 100
x1
0
50
100
x2
J = 0.4
(b)
0 50 100
x1
0
50
100
x2
J = 10
(c)
Figure 4.17: Samples from an associative Ising model with varying J > 0. Generated by
gibbs_demo_ising.ipynb.
Figure 4.17 shows some samples from the Ising model for varying J > 0. (The samples were
created using the Gibbs sampling method discussed in Section 12.3.3.) As the temperature reduces,
the distribution becomes less entropic, and the “clumpiness” of the samples increases. One can show
that, as the lattice size goes to infinity, there is a critical temperature Jc below which many large
clusters occur, and above which many small clusters occur. In the case of an isotropic square lattice
model, one can show [Geo88] that
Jc =
1
2
log(1 + √
2) ≈ 0.44 (4.79)
This rapid change in global behavior as we vary a parameter of the system is called a phase
transition. This can be used to explain how natural systems, such as water, can suddenly go from
solid to liquid, or from liquid to gas, when the temperature changes slightly. See e.g., [Mac03, ch 31]
for further details on the statistical mechanics of Ising models.
In addition to pairwise terms, it is standard to add unary terms, ψi(xi). In statistical physics,
this is called an external field. The resulting model is as follows:
p(x|θ) = 1
Z(θ)
Y
i
ψi(xi
; θ)
Y
i∼j
ψij (xi
, xj ; θ) (4.80)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.3. UNDIRECTED GRAPHICAL MODELS (MARKOV RANDOM FIELDS)
0 10 20 30 40 50 60
0
10
20
30
40
50
60
J= 1.4
(a)
0 10 20 30 40 50 60
0
10
20
30
40
50
60
J= 1.43
(b)
0 10 20 30 40 50 60
0
10
20
30
40
50
60
J= 1.46
(c)
Figure 4.18: Visualizing a sample from a 10-state Potts model of size 128 × 128. The critical value is
Jc = log(1 + √
10) = 1.426. for different association strengths: (a) J = 1.40, (b) J = 1.43, (c) J = 1.46.
Generated by gibbs_demo_potts.ipynb.
The ψi terms can be thought of as a local bias term that is independent of the contributions of the
neighboring nodes. For binary nodes, we can define this as follows:
ψi(xi) = (
e
α if xi = +1
e
−α if xi = −1
(4.81)
If we write this as an energy-based model, we have
E(x|θ) = −α
X
i
xi − J
X
i∼j
xixj (4.82)
4.3.2.2 Potts models
In Section 4.3.2.1, we discussed the Ising model, which is a simple 2d MRF for defining distributions
over binary variables. It is easy to generalize the Ising model to multiple discrete states, xi ∈
{1, 2, . . . , K}. If we use the same potential function for every edge, we can write
ψij (xi = k, xj = k
′
) = e
Jij (k,k′
)
(4.83)
where Jij (k, k′
) is the energy if one node has state k and its neighbor has state k
′
. A common special
case is
ψij (xi = k, xj = k
′
) = (
e
J
if k = k
′
e
0
if k 6= k
′
(4.84)
This is called the Potts model. The Potts model reduces to the Ising model if we define Jpotts =
2Jising.
If J > 0, then neighboring nodes are encouraged to have the same label; this is an example of
an associative Markov model. Some samples from this model are shown in Figure 4.18. The phase
transition for a 2d Potts model occurs at the following value (see [MS96]):
Jc = log(1 + √
K) (4.85)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license170
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We can extend this model to have local evidence for each node. If we write this as an energy-based
model, we have
E(x|θ) = −
X
i
X
K
k=1
αkI(xi = k) − J
X
i∼j
I(xi = xj ) (4.86)
4.3.2.3 Potts models for protein structure prediction
One interesting application of Potts models arises in the area of protein structure prediction.
The goal is to predict the 3d shape of a protein from its 1d sequence of amino acids. A common
approach to this is known as direct coupling analysis (DCA). We give a brief summary below; for
details, see [Mor+11].
First we compute a multiple sequence alignment (MSA) from a set of related amino acid
sequences from the same protein family; this can be done using HMMs, as explained in Section 29.3.2.
The MSA can be represented by an N × T matrix X, where N is the number of sequences, T is the
length of each sequence, and Xni ∈ {1, . . . , V } is the identity of the letter at location i in sequence n.
For protein sequences, V = 21, representing the 20 amino acids plus the gap character.
Once we have the MSA matrix X, we fit the Potts model using maximum likelihood estimation, or
some approximation, such as pseudolikelihood [Eke+13]; see Section 4.3.9 for details.5 After fitting
the model, we select the edges with the highest Jij coefficients, where i, j ∈ {1, . . . , T} are locations
or residues in the protein. Since these locations are highly coupled, they are likely to be in physical
contact, since interacting residues must coevolve to avoid destroying the function of the protein (see
e.g., [LHF17] for a review). This graph is called a contact map.
Once the contact map is established, it can be used as input to a 3d structural prediction algorithm,
such as [Xu18] or the alphafold system [Eva+18], which won the 2018 CASP competition. Such
methods use neural networks to learn functions of the form p(d(i, j)|{c(i, j)}), where d(i, j) is the 3d
distance between residues i and j, and c(i, j) is the contact map.
4.3.2.4 Hopfield networks
A Hopfield network [Hop82] is a fully connected Ising model (Section 4.3.2.1) with a symmetric
weight matrix, W = WT. The corresponding energy function has the form
E(x) = −
1
2
x
TWx (4.87)
where xi ∈ {−1, +1}.
The main application of Hopfield networks is as an associative memory or content addressable
memory. The idea is this: suppose we train on a set of fully observed bit vectors, corresponding to
patterns we want to memorize. (We discuss how to do this below). Then, at test time, we present
a partial pattern to the network. We would like to estimate the missing variables; this is called
pattern completion. That is, we want to compute
x
∗ = argmin
x
E(x) (4.88)
5. To encourage the model to learn sparse connectivity, we can also compute a MAP estimate with a sparsity promoting
prior, as discussed in [IM17].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.3. UNDIRECTED GRAPHICAL MODELS (MARKOV RANDOM FIELDS)
0 50 100
0
20
40
60
80
100
120
140
0 50 100
0
20
40
60
80
100
120
140
0 50 100
0
20
40
60
80
100
120
140
hopfield_training
0 50 100
0
20
40
60
80
100
120
140
0 50 100
0
20
40
60
80
100
120
140
0 50 100
0
20
40
60
80
100
120
140
hopfield_occluded
0 50 100
0
20
40
60
80
100
120
140
0 50 100
0
20
40
60
80
100
120
140
0 50 100
0
20
40
60
80
100
120
140
hopfield_recall
Figure 4.19: Examples of how an associative memory can reconstruct images. These are binary images of
size 150 × 150 pixels. Top: training images. Middle row: partially visible test images. Bottom row: final state
estimate. Adapted from Figure 2.1 of [HKP91]. Generated by hopfield_demo.ipynb.
We can solve this optimization problem using iterative conditional modes (ICM), in which we
set each hidden variable to its most likely state given its neighbors. Picking the most probable state
amounts to using the rule
x
t+1 = sgn(Wx
t
) (4.89)
This can be seen as a deterministic version of Gibbs sampling (see Section 12.3.3).
We illustrate this process in Figure 4.19. In the top row, we show some training examples. In the
middle row, we show a corrupted input, corresponding to the initial state x
0
. In the bottom row, we
show the final state after 30 iterations of ICM. The overall process can be thought of as retrieving a
complete example from memory based on a piece of the example.
To learn the weights W, we could use the maximum likelihood estimate method described in
Section 4.3.9.1. (See also [HSDK12].) However, a simpler heuristic method, proposed in [Hop82], is
to use the following outer product method:
W =
 
1
N
X
N
n=1
xnx
T
n
!
− I (4.90)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license172
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a)
x1 x2 x3 x4
z1 z2 z3
(b)
Figure 4.20: (a) A general Boltzmann machine, with an arbitrary graph structure. The shaded (visible) nodes
are partitioned into input and output, although the model is actually symmetric and defines a joint distribution
on all the nodes. (b) A restricted Boltzmann machine with a bipartite structure. Note the lack of intra-layer
connections.
This normalizes the output product matrix by N, and then sets the diagonal to 0. This ensures the
energy is low for patterns that match any of the examples in the training set. This is the technique we
used in Figure 4.19. Note, however, that this method not only stores the original patterms but also
their inverses, and other linear combinations. Consequently there is a limit to how many examples
the model can store before they start to “collide” in the memory. Hopfield proved that, for random
patterns, the network capacity is ∼ 0.14N.
4.3.3 MRFs with latent variables (Boltzmann machines, etc.)
In this section, we discuss MRFs which contain latent variables, as a way to represent high dimensional
joint distributions in discrete spaces.
4.3.3.1 Vanilla Boltzmann machines
MRFs in which all the variables are visible are limited in their expressive power, since the only way to
model correlation between the variables is by directly adding an edge. An alternative approach is to
introduce latent variables. A Boltzmann machine [AHS85] is like an Ising model (Section 4.3.2.1)
with latent variables. In addition, the graph structure can be arbitrary (not just a lattice), and the
binary states are xi ∈ {0, 1} instead of xi ∈ {−1, +1}. We usually partition the nodes into hidden
nodes z and visible nodes x, as shown in Figure 4.20(a).
4.3.3.2 Restricted Boltzmann machines (RBMs)
Unfortunately, exact inference (and hence learning) in Boltzmann machines is intractable, and even
approximate inference (e.g., Gibbs sampling, Section 12.3) can be slow. However, suppose we restrict
the architecture so that the nodes are arranged in two layers, and so that there are no connections
between nodes within the same layer (see Figure 4.20(b)). This model is known as a restricted
Boltzmann machine (RBM) [HT01; HS06a], or a harmonium [Smo86]. The RBM supports
efficient approximate inference, since the hidden nodes are conditionally independent given the visible
nodes, i.e., p(z|x) = QK
k=1 p(zk|x). Note this is in contrast to a directed two-layer models, where the
explaining away effect causes the latent variables to become “entangled” in the posterior even if they
are independent in the prior.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.3. UNDIRECTED GRAPHICAL MODELS (MARKOV RANDOM FIELDS)
Initial Parameters Epoch 1 Parameters Epoch 5 Parameters
Figure 4.21: Some reconstructed images generated by a binary RBM fit to MNIST. Generated by
rbm_contrastive_divergence.ipynb.
Visible Hidden Name Reference
Binary Binary Binary RBM [HS06a]
Gaussian Binary Gaussian RBM [WS05]
Categorical Binary Categorical RBM [SMH07]
Multiple categorical Binary Replicated softmax/undirected LDA [SH10]
Gaussian Gaussian Undirected PCA [MM01]
Binary Gaussian Undirected binary PCA [WS05]
Table 4.4: Summary of different kinds of RBM.
Typically the hidden and visible nodes in an RBM are binary, so the energy terms have the form
wdkxdzk. If zk = 1, then the k’th hidden unit adds a term of the form wT
kx to the energy; this can
be thought of as a “soft constraint”. If zk = 0, the hidden unit is not active, and does not have
an opinion about this data example. By turning on different combinations of constraints, we can
create complex distributions on the visible data. This is an example of a product of experts
(Section 24.1.1), since p(x|z) = Q
k:zk=1 exp(wT
kx).
This can be thought of as a mixture model with an exponential number of hidden components,
corresponding to 2
H settings of z. That is, z is a distributed representation, whereas a standard
mixture model uses a localist representation, where z ∈ {1, K}, and each setting of z corresponds
to a complete prototype or exemplar wk to which x is compared, giving rise to a model of the form
p(x|z = k) ∝ exp(wT
kx).
Many different kinds of RBMs have been defined, which use different pairwise potential functions.
See Table 4.4 for a summary. (Figure 4.21 gives an example of some images generated from an
RBM fit to the binarized MNIST dataset.) All of these are special cases of the exponential family
harmonium [WRZH04]. See Supplementary Section 4.3 for more details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license174
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 4.22: (a) Deep Boltzmann machine. (b) Deep belief network. The top two layers define the prior
in terms on an RBM. The remaining layers are a directed graphical model that “decodes” the prior into
observable data.
4.3.3.3 Deep Boltzmann machines
We can make a “deep” version of an RBM by stacking multiple layers; this is called a deep Boltzmann
machine [SH09]. For example, the two layer model in Figure 4.22(a) has the form
p(x, z1, z2|θ) = 1
Z(W1,W2)
exp ￾
x
TW1z1 + z
T
1W2z2

(4.91)
where x are the visible nodes at the bottom, and we have dropped bias terms for brevity.
4.3.3.4 Deep belief networks (DBNs)
We can use an RBM as a prior over a latent distributed code, and then use a DPGM “decoder” to
convert this into the observed data, as shown in Figure 4.22(b). The corresponding joint distribution
has the form
p(x, z1, z2|θ) = p(x|z1,W1)
1
Z(W2)
exp ￾
z
T
1W2z2

(4.92)
In other words, it is an RBM on top of a DPGM. This combination has been called a deep belief
network (DBN) [HOT06a]. However, this name is confusing, since it is not actually a belief net.
We will therefore call it a deep Boltzmann network (which conveniently has the same DBN
abbreviation).
DBNs can be trained in a simple greedy fashion, and support fast bottom-up inference (see
[HOT06a] for details). DBNs played an important role in the history of deep learning, since they
were one of the first deep models that could be successfully trained. However, they are no longer
widely used, since the advent of better ways to train fully supervised deep neural networks (such as
using ReLU units and the Adam optimizer), and the advent of efficient ways to train deep DPGMs,
such as the VAE (Section 21.2).
4.3.4 Maximum entropy models
In Section 2.4.7, we show that the exponential family is the distribution with maximum entropy,
subject to the constraints that the expected value of the features (sufficient statistics) φ(x) match
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 201
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.3. UNDIRECTED GRAPHICAL MODELS (MARKOV RANDOM FIELDS)
the empirical expectations. Thus the model has the form
p(x|θ) = 1
Z(θ)
exp ￾
θ
Tφ(x)

(4.93)
If the features φ(x) decompose according to a graph structure, we get a kind of MRF known as a
maximum entropy model. We give some examples below.
4.3.4.1 Log-linear models
Suppose the potential functions have the following log-linear form:
ψc(xc; θc) = exp(θ
T
c φ(xc)) (4.94)
where φ(xc) is a feature vector derived from the variables in clique c. Then the overall model is
given by
p(x|θ) = 1
Z(θ)
exp X
c
θ
T
c φ(xc)
!
(4.95)
For example, in a Gaussian graphical model (GGM), we have
φ([xi
, xj ]) = [xi
, xj , xixj ] (4.96)
for xi ∈ R. And in an Ising model, we have
φ([xi
, xj ]) = [xi
, xj , xixj ] (4.97)
for xi ∈ {−1, +1}. Thus both of these are maxent models. However, there are two key differences:
first, in a GGM, the variables are real-valued, not binary; second, in a GGM, the partition function
Z(θ) can be computed in O(D3
) time, whereas in a Boltzmann machine, computing the partition
function can take O(2D) time (see Section 9.5.4 for details).
If the features φ are structured in a hierarchical way (capturing first order interactions, and second
order interactions, etc.), and all the variables x are categorical, the resulting model is known in
statistics as a log-linear model. However, in the ML community, the term “log-linear model” is
often used to describe any model of the form Equation (4.95).
4.3.4.2 Feature induction for a maxent spelling model
In some applications, we assume the features φ(x) are known. However, it is possible to learn the
features in a maxent model in an unsupervised way; this is known as feature induction.
A common approach to feature induction, first proposed in [DDL97; ZWM97], is to start with a
base set of features, and then to continually create new feature combinations out of old ones, greedily
adding the best ones to the model.
As an example of this approach, [DDL97] describe how to build models to represent English
spelling. This can be formalized as a probability distribution over variable length strings, p(x|θ),
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens176
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where xt is a letter in the English alphabet. Initially the model has no features, which represents the
uniform distribution. The algorithm starts by choosing to add the feature
φ1(x) = X
i
I(xi ∈ {a, . . . , z}) (4.98)
which checks if any letter is lowercase or not. After the feature is added, the parameters are (re)-fit
by maximum likelihood (a computationally difficult problem, which we discuss in Section 4.3.9.1).
For this feature, it turns out that ˆθ1 = 1.944, which means that a word with a lowercase letter in any
position is about e
1.944 ≈ 7 times more likely than the same word without a lowercase letter in that
position. Some samples from this model, generated using (annealed) Gibbs sampling (described in
Section 12.3), are shown below.6
m, r, xevo, ijjiir, b, to, jz, gsr, wq, vf, x, ga, msmGh, pcp, d, oziVlal, hzagh, yzop, io,
advzmxnv, ijv_bolft, x, emx, kayerf, mlj, rawzyb, jp, ag, ctdnnnbg, wgdw, t, kguv, cy,
spxcq, uzflbbf, dxtkkn, cxwx, jpd, ztzh, lv, zhpkvnu, l^, r, qee, nynrx, atze4n, ik, se, w,
lrh, hp+, yrqyka’h, zcngotcnx, igcump, zjcjs, lqpWiqu, cefmfhc, o, lb, fdcY, tzby, yopxmvk,
by, fz„ t, govyccm, ijyiduwfzo, 6xr, duh, ejv, pk, pjw, l, fl, w
The second feature added by the algorithm checks if two adjacent characters are lowercase:
φ2(x) = X
i∼j
I(xi ∈ {a, . . . , z}, xj ∈ {a, . . . , z}) (4.99)
Now the model has the form
p(x) = 1
Z
exp(θ1φ1(x) + θ2φ2(x)) (4.100)
Continuing in this way, the algorithm adds features for the strings s> and ing>, where > represents
the end of word, and for various regular expressions such as [0-9], etc. Some samples from the
model with 1000 features, generated using (annealed) Gibbs sampling, are shown below.
was, reaser, in, there, to, will, „ was, by, homes, thing, be, reloverated, ther, which,
conists, at, fores, anditing, with, Mr., proveral, the, „ ***, on’t, prolling, prothere, „
mento, at, yaou, 1, chestraing, for, have, to, intrally, of, qut, ., best, compers, ***,
cluseliment, uster, of, is, deveral, this, thise, of, offect, inatever, thifer,
constranded, stater, vill, in, thase, in, youse, menttering, and, ., of, in, verate, of,
to
If we define a feature for every possible combination of letters, we can represent any probability
distribution. However, this will overfit. The power of the maxent approach is that we can choose
which features matter for the domain.
An alternative approach is to introduce latent variables, that implicitly model correlations amongst
the visible nodes, rather than explicitly having to learn feature functions. See Section 4.3.3 for an
example of such a model.
6. We thank John Lafferty for sharing this example.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.3. UNDIRECTED GRAPHICAL MODELS (MARKOV RANDOM FIELDS)
4.3.5 Gaussian MRFs
In Section 4.2.3, we showed how to represent a multivariate Gaussian using a DPGM. In this section,
we show how to represent a multivariate Gaussian using a UPGM. (For further details on GMRFs,
see e.g., [RH05].)
4.3.5.1 Standard GMRFs
A Gaussian graphical model (or GGM), also called a Gaussian MRF, is a pairwise MRF of
the following form:
p(x) = 1
Z(θ)
Y
i∼j
ψij (xi
, xj )
Y
i
ψi(xi) (4.101)
ψij (xi
, xj ) = exp(−
1
2
xiΛijxj ) (4.102)
ψi(xi) = exp(−
1
2
Λiix
2
i + ηixi) (4.103)
Z(θ) = (2π)
D/2
|Λ|
− 1
2 (4.104)
The ψij are edge potentials (pairwise terms), and each the ψi are node potentials or unary
terms. (We could absorb the unary terms into the pairwise terms, but we have kept them separate
for clarity.)
The joint distribution can be rewritten in a more familiar form as follows:
p(x) ∝ exp[η
Tx −
1
2
x
TΛx] (4.105)
This is called the information form of a Gaussian; Λ = Σ
−1
and η = Λµ are called the canonical
parameters.
If Λij = 0 , there is no pairwise term connecting xi and xj , and hence xi ⊥ xj |x−ij , where x−ij
are all the nodes except for xi and xj . Hence the zero entries in Λ are called structural zeros.
This means we can use ℓ1 regularization on the weights to learn a sparse graph, a method known as
graphical lasso (see Supplementary Section 30.4.2).
Note that the covariance matrix Σ = Λ
−1
can be dense even if the precision matrix Λ is sparse.
For example, consider an AR(1) process with correlation parameter ρ.
7 The precision matrix (for a
graph with T = 7 nodes) looks like this:
Λ =
1
τ
2


1 −ρ
−ρ 1 + ρ
2 −ρ
−ρ 1 + ρ
2 −ρ
−ρ 1 + ρ
2 −ρ
−ρ 1 + ρ
2 −ρ
−ρ 1 + ρ
2 −ρ
−ρ 1


(4.106)
7. This example is from https://dansblog.netlify.app/posts/2022-03-22-a-linear-mixed-effects-model/.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license178
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
But the covariance matrix is fully dense:
Λ
−1 = τ
2


ρ ρ2 ρ
3 ρ
4 ρ
5 ρ
6 ρ
7
ρ
2 ρ ρ2 ρ
3 ρ
4 ρ
5 ρ
6
ρ
3 ρ
2 ρ ρ
2 ρ
3 ρ
4 ρ
5
ρ
4 ρ
3 ρ
2 ρ ρ2 ρ
3 ρ
4
ρ
5 ρ
4 ρ
3 ρ
2 ρ ρ2 ρ
3
ρ
6 ρ
5 ρ
4 ρ
3 ρ
2 ρ ρ2
ρ
7 ρ
6 ρ
5 ρ
4 ρ
3 ρ
2 ρ


(4.107)
This follows because, in a chain structured UPGM, every pair of nodes is marginally correlated, even
if they may be conditionally independent given a separator.
4.3.5.2 Nonlinear Gaussian MRFs
In this section, we consider a generalization of GGMs to handle the case of nonlinear models. Suppose
the joint is given by a product of local factors, or clique potentials, ψc, each of which is defined on a
set or clique variables xc as follows:
p(x) = 1
Z
Y
c
ψc(xc) (4.108)
ψc(xc) = exp(−Ec(xc)) (4.109)
Ec(xc) = 1
2
(fc(xc) − dc)
TΣ
−1
c
(fc(xc) − dc) (4.110)
where dc is an optional local evidence term for the c’th clique, and fc is some measurement function.
Suppose the measurent function fc is linear, i.e.,
fc(x) = Jcx + bc (4.111)
In this case, the energy for clique c becomes
Ec(xc) = 1
2
x
T
c J
T
cΣ
−1
c Jc
| {z }
Λc
xc + x
T
c J
T
cΣ
−1
c
(bc − dc)
| {z }
−ηc
+
1
2
(bc − dc)Σ
−1
c
(bc − dc)
| {z }
kc
(4.112)
=
1
2
x
T
cΛcxc − η
T
cxc + kc (4.113)
which is a standard Gaussian factor. If fc is nonlinear, it is common to linearize the model around
the current estimate x
0
c
to get
fc(xc) ≈ fc(x
0
c
) + Jc(xc − x
0
c
) = Jcxc + (fc(x
0
c
) − Jcx
0
c
)
| {z }
bc
(4.114)
where Jc is the Jacobian of fc(xc) wrt xc. This gives us a “temporary” Gaussian factor that we can
use for inference. This process can be iterated for improved accuracy.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.3. UNDIRECTED GRAPHICAL MODELS (MARKOV RANDOM FIELDS)
1
2
3
5
4
6
7
(a)
1
2
3
5
4
6
7
(b)
Figure 4.23: (a) A DPGM. (b) Its moralized version, represented as a UPGM.
4.3.6 Conditional independence properties
In this section, we explain how UPGMs encode conditional independence assumptions.
4.3.6.1 Basic results
UPGMs define CI relationships via simple graph separation as follows: given 3 sets of nodes A, B,
and C, we say XA ⊥G XB|XC iff C separates A from B in the graph G. This means that, when we
remove all the nodes in C, if there are no paths connecting any node in A to any node in B, then
the CI property holds. This is called the global Markov property for UPGMs. For example, in
Figure 4.23(b), we have that {X1, X2} ⊥ {X6, X7}|{X3, X4, X5}.
The smallest set of nodes that renders a node t conditionally independent of all the other nodes in
the graph is called t’s Markov blanket; we will denote this by mb(t). Formally, the Markov blanket
satisfies the following property:
t ⊥ V \ cl(t)|mb(t) (4.115)
where cl(t) , mb(t) ∪ {t} is the closure of node t, and V = {1, . . . , NG} is the set of all nodes.
One can show that, in a UPGM, a node’s Markov blanket is its set of immediate neighbors. This
is called the undirected local Markov property. For example, in Figure 4.23(b), we have
mb(X5) = {X2, X3, X4, X6, X7}.
From the local Markov property, we can easily see that two nodes are conditionally independent
given the rest if there is no direct edge between them. This is called the pairwise Markov property.
In symbols, this is written as
s ⊥ t|V \ {s, t} ⇐⇒ Gst = 0 (4.116)
where Gst = 0 means there is no edge between s and t (so there is a 0 in the adjaceny matrix).
Using the three Markov properties we have discussed, we can derive the following CI properties
(amongst others) from the UPGM in Figure 4.23(b): X1 ⊥ X7|rest (pairwise); X1 ⊥ rest|X2, X3
(local); X1, X2 ⊥ X6, X7|X3, X4, X5 (global).
It is obvious that global Markov implies local Markov which implies pairwise Markov. What is less
obvious is that pairwise implies global, and hence that all these Markov properties are the same,
as illustrated in Figure 4.24 (see e.g., [KF09a, p119] for a proof).8 The importance of this result is
that it is usually easier to empirically assess pairwise conditional independence; such pairwise CI
statements can be used to construct a graph from which global CI statements can be extracted.
8. This assumes p(x) > 0 for all x, i.e., that p is a positive density. The restriction to positive densities arises because
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license180
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
GLP
p(x) > 0
Figure 4.24: Relationship between Markov properties of UPGMs.
1
2
3
5
4
(a)
1
2
3
5
4
(b)
Figure 4.25: (a) The ancestral graph induced by the DAG in Figure 4.23(a) wrt U = {X2, X4, X5}. (b) The
moralized version of (a).
4.3.6.2 An undirected alternative to d-separation
We have seen that determinining CI relationships in UPGMs is much easier than in DPGMs, because
we do not have to worry about the directionality of the edges. That is, we can use simple graph
separation, instead of d-separation.
In this section, we show how to convert a DPGM to a UPGM, so that we can infer CI relationships
for the DPGM using simple graph separation. It is tempting to simply convert the DPGM to a
UPGM by dropping the orientation of the edges, but this is clearly incorrect, since a v-structure
A → B ← C has quite different CI properties than the corresponding undirected chain A − B − C
(e.g., the latter graph incorrectly states that A ⊥ C|B). To avoid such incorrect CI statements,
we can add edges between the “unmarried” parents A and C, and then drop the arrows from the
edges, forming (in this case) a fully connected undirected graph. This process is called moralization.
Figure 4.23 gives a larger example of moralization: we interconnect 2 and 3, since they have a
common child 5, and we interconnect 4, 5, and 6, since they have a common child 7.
Unfortunately, moralization loses some CI information, and therefore we cannot use the moralized
UPGM to determine CI properties of the DPGM. For example, in Figure 4.23(a), using d-separation,
we see that X4 ⊥ X5|X2. Adding a moralization arc X4 −X5 would lose this fact (see Figure 4.23(b)).
However, notice that the 4-5 moralization edge, due to the common child 7, is not needed if we do not
observe 7 or any of its descendants. This suggests the following approach to determining if A ⊥ B|C.
First we form the ancestral graph of DAG G with respect to U = A ∪ B ∪ C. This means we
remove all nodes from G that are not in U or are not ancestors of U. We then moralize this ancestral
deterministic constraints can result in independencies present in the distribution that are not explicitly represented in
the graph. See e.g., [KF09a, p120] for some examples. Distributions with non-graphical CI properties are said to be
unfaithful to the graph, so I(p) 6= I(G).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.3. UNDIRECTED GRAPHICAL MODELS (MARKOV RANDOM FIELDS)
x3 x4
z3 z4
x1
x2
z1 z2
Figure 4.26: A grid-structured MRF with hidden nodes zi and local evidence nodes xi. The prior p(z) is an
undirected Ising model, and the likelihood p(x|z) = Q
i
p(xi|zi) is a directed fully factored model.
graph, and apply the simple graph separation rules for UPGMs. For example, in Figure 4.25(a), we
show the ancestral graph for Figure 4.23(a) using U = {X2, X4, X5}. In Figure 4.25(b), we show the
moralized version of this graph. It is clear that we now correctly conclude that X4 ⊥ X5|X2.
4.3.7 Generation (sampling)
Unlike with DPGMs, it can be quite slow to sample from an UPGM, even from the unconditional
prior, because there is no ordering of the variables. Furthermore, we cannot easily compute the
probability of any configuration unless we know the value of Z. Consequently it is common to use
MCMC methods for generating from an UPGM (see Chapter 12).
In the special case of UPGMs with low treewidth and discrete or Gaussian potentials, it is
possible to use the junction tree algorithm to draw samples using dynamic programming (see
Supplementary Section 9.2.3).
4.3.8 Inference
We discuss inference in graphical models in detail in Chapter 9. In this section, we just give an
example.
Suppose we have an image composed of binary pixels, zi
, but we only observe noisy versions of the
pixels, xi
. We assume the joint model has the form
p(x, z) = p(z)p(x|z) =


1
Z
X
i∼j
ψij (zi
, zj )


Y
i
p(xi
|zi) (4.117)
where p(z) is an Ising model prior, and p(xi
|zi) = N (xi
|zi
, σ2
), for zi ∈ {−1, +1}. This model uses a
UPGM as a prior, and has directed edges for the likelihood, as shown in Figure 4.26; such a hybrid
undirected-directed model is called a chain graph (even though it is not chain-structured).
The inference task is to compute the posterior marginals p(zi
|x), or the posterior MAP estimate,
argmaxz p(z|x). The exact computation is intractable for large grids (for reasons explained in
Section 9.5.4), so we must use approximate methods. There are many algorithms that we can use,
including mean field variational inference (Section 10.3.2), Gibbs sampling (Section 12.3.3), loopy
belief propagation (Section 9.4), etc. In Figure 4.27, we show the results of variational inference.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license182
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
sample 1, meanfieldH
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
(a)
mean after 15 sweeps of meanfieldH
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
(b)
Figure 4.27: Example of image denoising using mean field variational inference. We use an Ising prior with
Wij = 1 and a Gaussian noise model with σ = 2. (a) Noisy image. (b) Result of inference. Generated by
ising_image_denoise_demo.ipynb.
4.3.9 Learning
In this section, we discuss how to estimate the parameters for an MRF. As we will see, computing
the MLE can be computationally expensive, even in the fully observed case, because of the need to
deal with the partition function Z(θ). And computing the posterior over the parameters, p(θ|D),
is even harder, because of the additional normalizing constant p(D) — this case has been called
doubly intractable [MGM06]. Consequently we will focus on point estimation methods such as
MLE and MAP. (For one approach to Bayesian parameter inference in an MRF, based on persistent
variational inference, see [IM17].)
4.3.9.1 Learning from complete data
We will start by assuming there are no hidden variables or missing data during training (this is
known as the complete data setting). For simplicity of presentation, we restrict our discusssion to
the case of MRFs with log-linear potential functions. (See Section 24.2 for the general nonlinear case,
where we discuss MLE for energy-based models.)
In particular, we assume the distribution has the following form:
p(x|θ) = 1
Z(θ)
exp X
c
θ
T
c φc
(x)
!
(4.118)
where c indexes the cliques. The (averaged) log-likelihood of the full dataset becomes
ℓ(θ) ,
1
N
X
n
log p(xn|θ) =
1
N
X
n
"X
c
θ
T
c φc
(xn) − log Z(θ)
#
(4.119)
Its gradient is given by
∂ℓ
∂θc
=
1
N
X
n

φc
(xn) −
∂
∂θc
log Z(θ)

(4.120)
We know from Section 2.4.3 that the derivative of the log partition function wrt θc is the expectation
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.3. UNDIRECTED GRAPHICAL MODELS (MARKOV RANDOM FIELDS)
of the c’th feature vector under the model, i.e.,
∂ log Z(θ)
∂θc
= E [φc
(x)|θ] = X
x
p(x|θ)φc
(x) (4.121)
Hence the gradient of the log likelihood is
∂ℓ
∂θc
=
1
N
X
n
[φc
(xn)] − E [φc
(x)] (4.122)
When the expected value of the features according to the data is equal to the expected value of
the features according to the model, the gradient will be zero, so we get
EpD [φc
(x)] = Ep(x|θ)
[φc
(x)] (4.123)
This is called moment matching. Evaluating the EpD [φc
(x)] term is called the clamped phase
or positive phase, since x is set to the observed values xn; evaluating the Ep(x|θ)
[φc
(x)] term is
called the unclamped phase or negative phase, since x is free to vary, and is generated by the
model.
In the case of MRFs with tabular potentials (i.e., one feature per entry in the clique table), we
can use an algorithm called iterative proportional fitting or IPF [Fie70; BFH75; JP95] to solve
these equations in an iterative fashion.9 But in general, we must use gradient methods to perform
parameter estimation.
4.3.9.2 Computational issues
The biggest computational bottleneck in fitting MRFs and CRFs using MLE is the cost of computing
the derivative of the log partition function, log Z(θ), which is needed to compute the derivative of
the log likelihood, as we saw in Section 4.3.9.1. To see why this is slow to compute, note that
∇θ log Z(θ) = ∇θZ(θ)
Z(θ)
=
1
Z(θ)
∇θ
Z
p˜(x; θ)dx =
1
Z(θ)
Z
∇θp˜(x; θ)dx (4.124)
=
1
Z(θ)
Z
p˜(x; θ)∇θ log ˜p(x; θ)dx =
Z
p˜(x; θ)
Z(θ)
∇θ log ˜p(x; θ)dx (4.125)
= Ex∼p(x;θ)
[∇θ log ˜p(x; θ)] (4.126)
where in Equation (4.125) we used the fact that ∇θ log ˜p(x; θ) = 1
p˜(x;θ)∇θp˜(x; θ) (this is known as
the log-derivative trick). Thus we see that we need to draw samples from the model at each step
of SGD training, just to estimate the gradient.
In Section 24.2.1, we discuss various efficient sampling methods. However, it is also possible to
use alternative estimators which do not use the principle of maximum likelihood. For example, in
Section 24.2.2 we discuss the technique of contrastive divergence. And in Section 4.3.9.3, we discuss
the technique of pseudolikelihood. (See also [Sto17] for a review of many methods for parameter
estimation in MRFs.)
9. In the case of decomposable graphs, IPF converges in a single iteration. Intuitively, this is because a decomposable
graph can be converted to a DAG without any loss of information, as explained in Section 4.5, and we know that we
can compute the MLE for tabular CPDs in closed form, just by normalizing the counts.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license184
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 4.28: (a) A small 2d lattice. (b) The representation used by pseudo likelihood. Solid nodes are observed
neighbors. Adapted from Figure 2.2 of [Car03].
4.3.9.3 Maximum pseudolikelihood estimation
When fitting fully visible MRFs (or CRFs), a simple alternative to maximizing the likelihood is to
maximize the pseudo likelihood [Bes75], defined as follows:
ℓP L(θ) ,
1
N
X
N
n=1
X
D
d=1
log p(xnd|xn,−d, θ) (4.127)
That is, we optimize the product of the full conditionals, also known as the composite likelihood
[Lin88a; DL10; VRF11]. Compare this to the objective for maximum likelihood:
ℓML(θ) = 1
N
X
N
n=1
log p(xn|θ) (4.128)
In the case of Gaussian MRFs, PL is equivalent to ML [Bes75], although this is not true in general.
Nevertheless, it is a consistent estimator in the large sample limit [LJ08].
The PL approach is illustrated in Figure 4.28 for a 2d grid. We learn to predict each node, given all
of its neighbors. This objective is generally fast to compute since each full conditional p(xd|x−d, θ)
only requires summing over the states of a single node, xd, in order to compute the local normalization
constant. The PL approach is similar to fitting each full conditional separately, except that, in PL,
the parameters are tied between adjacent nodes.
Experiments in [PW05; HT09] suggest that PL works as well as exact ML for fully observed Ising
models, but is much faster. In [Eke+13], they use PL to fitt Potts models to (aligned) protein
sequence data. However, when fitting RBMs, [Mar+10] found that PL is worse than some of the
stochastic ML methods we discuss in Section 24.2.
Another more subtle problem is that each node assumes that its neighbors have known values
during training. If node j ∈ nbr(i) is a perfect predictor for node i (where nbr(i) is the set of
neighbors), then j will learn to rely completely on node i, even at the expense of ignoring other
potentially useful information, such as its local evidence, say yi
. At test time, the neighboring nodes
will not be observed, and performance will suffer.10
10. Geoff Hinton has an analogy for this problem. Suppose we want to learn to denoise images of symmetric shapes,
such as Greek vases. Each hidden pixel xi depends on its spatial neighbors, as well the noisy observation yi. Since its
symmetric counterpart xj will perfectly predict xi, the model will ignore yi and just rely on xj , even though xj will
not be available at test time.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.4. CONDITIONAL RANDOM FIELDS (CRFS)
4.3.9.4 Learning from incomplete data
In this section, we consider parameter estimation for MRFs (and CRFs) with hidden variables. Such
incomplete data can arise for several reasons. For example, we may want to learn a model of
the form p(z)p(x|z) which lets us infer a “clean” image z from a noisy or corrupted version x. If
we only observe x, the model is called a hidden Gibbs random field. See Section 10.3.2 for an
example. As another example, we may have a CRF in which the hidden variables are used to encode
an unknown alignment between the inputs and outputs [Qua+07], or to model missing parts of the
input [SRS10].
We now discuss how to compute the MLE in such cases. For notational simplicity, we focus on
unconditional models (MRFs, not CRFs), and we assume all the potentials are log-linear. In this
case, the model has the following form:
p(x, z|θ) = exp(θ
Tφ(x, z))
Z(θ)
=
p˜(x, z|θ)
Z(θ)
(4.129)
Z(θ) = X
x,z
exp(θ
Tφ(x, z)) (4.130)
where p˜(x, z|θ) is the unnormalized distribution. We have dropped the sum over cliques c for brevity.
The log likelihood is now given by
ℓ(θ) = 1
N
X
N
n=1
log X
zn
p(xn, zn|θ)
!
(4.131)
=
1
N
X
N
n=1
log 
1
Z(θ)
X
zn
p˜(xn, zn|θ)
!
(4.132)
=
1
N
X
N
n=1 "
logX
zn
p˜(xn, zn|θ)
#
− log Z(θ) (4.133)
Note that
logX
zn
p˜(xn, zn|θ) = logX
zn
exp(θ
Tφ(xn, zn)) , log Z(θ, xn) (4.134)
where Z(θ, xn) is the same as the partition function for the whole model, except that x is fixed at
xn. Thus the log likelihood is a difference of two partition functions, one where x is clamped to xn
and z is unclamped, and one where both x and z are unclamped. The gradient of these log partition
functions corresponds to the expected features, where (in the clamped case) we condition on x = xn.
Hence
∂ℓ
∂θ
=
1
N
X
n

Ez∼p(z|xn,θ)
[φ(xn, z)]
− E(z,x)∼p(z,x|θ)
[φ(x, z)] (4.135)
4.4 Conditional random fields (CRFs)
A conditional random field or CRF [LMP01] is a Markov random field defined on a set of related
label nodes y, whose joint probability is predicted conditional on a fixed set of input nodes x. More
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license186
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
xt−1 xt xt+1
yt−1
yt
yt+1
Figure 4.29: A 1d conditional random field (CRF) for sequence labeling.
precisely, it corresponds to a model of the following form:
p(y|x, θ) = 1
Z(x, θ)
Y
c
ψc(yc; x, θ) (4.136)
(Note how the partition function now depends on the inputs x as well as the parameters θ.) Now
suppose the potential functions are log-linear and have the form
ψc(yc; x, θ) = exp(θ
T
c φc
(x, yc)) (4.137)
This is a conditional version of the maxent models we discussed in Section 4.3.4. Of course, we can
also use nonlinear potential functions, such as DNNs.
CRFs are useful because they capture dependencies amongst the output labels. They can therefore
be used for structured prediction, where the output y ∈ Y that we want to predict given the
input x lives in some structured space, such as a sequence of labels, or labels associated with nodes
on a graph. In such problems, there are often constraints on the set of valid values of the output y.
For example, if we want to perform sentence parsing, the output should satisfy the rules of grammar
(e.g., noun phrase must precede verb phrase). See Section 4.4.1 for details on the application of CRFs
to NLP. In some cases, the “constraints” are “soft”, rather than “hard”. For example, if we want to
associate a label with each pixel in an image (a task called semantic segmentation), we might want
to “encourage” the label at one location to be the same as its neighbors, unless the visual input
strongly suggests a change in semantic content at this location (e.g., at the edge of an object). See
Section 4.4.2 for details on the applications of CRFs to computer vision tasks.
4.4.1 1d CRFs
In this section, we focus on 1d CRFs defined on chain-structured graphical models. The graphical
model is shown in Figure 4.29. This defines a joint distribution over sequences, y1:T , given a set of
inputs, x1:T , as follows:
p(y1:T |x, θ) = 1
Z(x, θ)
Y
T
t=1
ψ(yt, xt; θ)
Y
T
t=2
ψ(yt−1, yt; θ) (4.138)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.4. CONDITIONAL RANDOM FIELDS (CRFS)
(b)
 British Airways rose after announcing its withdrawal from the UAL deal
ADJ N V IN V PRP N IN DT N N
B I O O O B I O I
POS
B I NP
Begin noun phrase
Within noun phrase
Not a noun phrase
Noun
Adjective
B
I
O
N
ADJ
Verb
Preposition
Possesive pronoun
Determiner (e.g., a, an, the)
V
IN
PRP
DT
KEY
Figure 4.30: A CRF for joint part of speech tagging and noun phrase segmentation. From Figure 4.E.1 of
[KF09a]. Used with kind permission of Daphne Koller.
where ψ(yt, xt; θ) are the node potentials and ψ(yt, yt+1; θ) are the edge potentials. (We have assumed
that the edge potentials are independent of the input x, but this assumption is not required.)
Note that one could also consider an alternative way to define this conditional distribution, by
using a discriminative directed Markov chain:
p(y1:T |x, θ) = p(y1|x1; θ)
Y
T
t=2
p(yt|yt−1, xt; θ) (4.139)
This is called a maximum entropy Markov model [MFP00]. However, it suffers from a subtle
flaw compared to the CRF. In particular, in the directed model, each conditional p(yt|yt−1, xt; θ), is
locally normalized, whereas in the CRF, the model is globally normalized due to the Z(x, θ)
term. The latter allows information to propagate through the entire sequence, as we discuss in more
detail in Section 4.5.3.
CRFs were widely used in the natural language processing (NLP) community in the 1980s–2010s
(see e.g., [Smi11]), although recently they have been mostly replaced by RNNs and transformers (see
e.g., [Gol17]). Fortunately, we can get the best of both worlds by combining CRFs with DNNs, which
allows us to combine data driven techniques with prior knowledge about constraints on the label
space. We give some examples below.
4.4.1.1 Noun phrase chunking
A common task in NLP is information extraction, in which we try to parse a sentence into noun
phrases (NP), such as names and addresses of people or businesses, as well as verb phrases, which
describe who is doing what to whom (e.g., “British Airways rose”). In order to tackle this task, we
can assign a part of speech tag to each word, where the tags correspond to Noun, Verb, Adjective,
etc. In addition, to extract the span of each noun phrase, we can annotate words as being at the
beginning (B) or inside (I) of a noun phrase, or outside (O) of one. See Figure 4.30 for an example.
The connections between adjacent labels can encode constraints such as the fact that B (begin)
must precede I (inside). For example, the sequences OBIIO and OBIOBIO are valid (corresponding to
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license188
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
 Mrs. Green spoke today in New York
(a)
Green chairs the finance committee
B-PER I-PER OTH OTH OTH B-LOC I-LOC B-PER OTH OTH OTH OTH
KEY
Begin person name
Within person name
Begin location name
B-PER
I-PER
B-LOC
Within location name
Not an entitiy
I-LOC
OTH
Figure 4.31: A skip-chain CRF for named entity recognition. From Figure 4.E.1 of [KF09a]. Used with kind
permission of Daphne Koller.
one NP of 3 words, and two adjacent NPs of 2 words), but OIBIO is not. This prior information can
be encoded by defining ψ(y
BIO
t−1 = ∗, yBIO
t = B, xt; θ) to be 0 for any value of * except O. We can
encode similar grammatical rules for the POS tags.
Given this model, we can compute the MAP sequence of labels, and thereby extract the spans
that are labeled as noun phrases. This is called noun phrase chunking.
4.4.1.2 Named entity recognition
In this section we consider the task of named entity extraction, in which we not only tag the
noun phrases, but also classify them into different types. A simple approach to this is to extend
the BIO notation to {B-Per, I-Per, B-Loc, I-Loc, B-Org, I-Org, Other}. However, sometimes it is
ambiguous whether a word is a person, location, or something else. Proper nouns are particularly
difficult to deal with because they belong to an open class, that is, there is an unbounded number
of possible names, unlike the set of nouns and verbs, which is large but essentially fixed. For example,
“British Airways” is an organization, but “British Virgin Islands” is a location.
We can get better performance by considering long-range correlations between words. For example,
we might add a link between all occurrences of the same word, and force the word to have the same
tag in each occurence. (The same technique can also be helpful for resolving the identity of pronouns.)
This is known as a skip-chain CRF. See Figure 4.31 for an illustration, where we show that the
word “Green” is interpeted as a person in both occurrences within the same sentence.
We see that the graph structure itself changes depending on the input, which is an additional
advantage of CRFs over generative models. Unfortunately, inference in this model is generally
more expensive than in a simple chain with local connections because of the larger treewdith (see
Section 9.5.2).
4.4.1.3 Natural language parsing
A generalization of chain-structured models for language is to use probabilistic grammars. In
particular, a probabilistic context free grammar or PCFG in Chomsky normal form is a set of
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.4. CONDITIONAL RANDOM FIELDS (CRFS)
Figure 4.32: Illustration of a simple parse tree based on a context free grammar in Chomsky normal form.
The feature vector Ψ(x, y) counts the number of times each production rule was used, and is used to define the
energy of a particular tree structure, E(y|x) = −wTΨ(x, y). The probability distribution over trees is given
by p(y|x) ∝ exp(−E(y|x)). From Figure 5.2 of [AHT07]. Used with kind permission of Yasemin Altun.
x3 x4
y3 y4
x1
x2
y1 y2
Figure 4.33: A grid-structured CRF with label nodes yi and local evidence nodes xi.
re-write or production rules of the form σ → σ
′σ
′′ or σ → x, where σ, σ′
, σ′′ ∈ Σ are non-terminals
(analogous to parts of speech), and x ∈ X are terminals, i.e., words. Each such rule has an associated
probability. The resulting model defines a probability distribution over sequences of words. We can
compute the probability of observing a particular sequence x = x1 . . . xT by summing over all trees
that generate it. This can be done in O(T
3
) time using the inside-outside algorithm; see e.g.,
[JM08; MS99; Eis16] for details.
PCFGs are generative models. It is possible to make discriminative versions which encode
the probability of a labeled tree, y, given a sequence of words, x, by using a CRF of the form
p(y|x) ∝ exp(wTΨ(x, y)). For example, we might define Ψ(x, y) to count the number of times each
production rule was used (which is analogous to the number of state transitions in a chain-structured
model), as illustrated in Figure 4.32. We can also use a deep neural net to define the features, as in
the neural CRF parser method of [DK15b].
4.4.2 2d CRFs
It is also possible to apply CRFs to image processing problems, which are usually defined on 2d
grids, as illustrated in Figure 4.33. (Compare this to the generative model in Figure 4.26.) This
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license190
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Deep 
Convolutional 
Neural 
Network
Input
Aeroplane
Coarse Score map
Final Output Fully Connected CRF Bi-linear Interpolation
Figure 4.34: A fully connected CRF is added to the output of a CNN, in order to increase the sharpness of
the segmentation boundaries. From Figure 3 of [Che+15]. Used with kind permission of Jay Chen.
corresponds to the following conditional model:
p(y|x) = 1
Z(x)


X
i∼j
ψij (yi
, yj )


Y
i
p(yi
|xi) (4.140)
In the sections below, we discuss some applications of this and other CRF models in computer vision.
4.4.2.1 Semantic segmentation
The task of semantic segmentation is to assign a label to every pixel in an image. We can easily
solve this problem using a CNN with one softmax output node per pixel. However, this may fail to
capture long-range dependencies, since convolution is a local operation.
One way to get better results is to feed the output of the CNN into a CRF. Since the CNN already
uses convolution, its outputs will usually already be locally smooth, so the benefits from using a CRF
with a local grid structure may be quite small. However, we can somtimes get better results if we
use a fully connected CRF, which has connections between all the pixels. This can capture long
range connections which the grid-structured CRF cannot. See Figure 4.34 for an illustration, and
[Che+17a] for details.
Unfortunately, exact inference in a fully connected CRF is intractable, but in the case of Gaussian
potentials, it is possible to devise an efficient mean field algorithm, as described in [KK11]. Interest￾ingly, [Zhe+15] showed how the mean field update equations can be implemented using a recurrent
neural network (see Section 16.3.4), allowing end-to-end training. Alternatively, if we are willing
to use a finite number of iterations, we can just “unroll” the computation graph and treat it as a
fixed-sized feedforward circuit. The result is a graph-structured neural network, where the topology
of the GNN is derived from the graphical model (cf., Section 9.4.10). The advantage of this compared
to standard CRF methods is that we can train this entire model end-to-end using standard gradient
descent methods; we no longer have to worry about the partition function (see Section 4.4.3), or
the lack of convergence that can arise when combining approximate inference with standard CRF
learning.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.4. CONDITIONAL RANDOM FIELDS (CRFS)
Figure 4.35: Pictorial structures model for a face and body. Each body part corresponds to a node in the
CRF whose state space represents the location of that part. The edges (springs) represent pairwise spatial
constraints. The local evidence nodes are not shown. Adapted from a figure by Pedro Felzenszwalb.
4.4.2.2 Deformable parts models
Consider the problem of object detection, i.e., finding the location(s) of an object of a given class
(e.g., a person or a car) in an image. One way to tackle this is to train a binary classifier that takes
as input an image patch and specifies if the patch contains the object or not. We can then apply this
to every image patch, and return the locations where the classifier has high confidence detections;
this is known as a sliding window detector, and works quite well for rigid objects such as cars
or frontal faces. Such an approach can be made efficient by using convolutional neural networks
(CNNs); see Section 16.3.2 for details.
However, such methods can work poorly when there is occlusion, or when the shape is deformable,
such as a person’s or animal’s body, because there is too much variation in the overall appearance.
A natural strategy to deal with such problems is break the object into parts, and then to detect
each part separately. But we still need to enforce spatial coherence of the parts. This can be done
using a pairwise CRF, where node yi specifies the location of part i in the image (assuming it is
present), and where we connect adjacent parts by a potential function that encourages them to be
close together. For example, we can use a pairwise potential of the form ψ(yi
, yj |x) = exp(−d(yi
, yj )),
where yi ∈ {1, . . . , K} is the location of part i (a discretization of the 2d image plane), and d(yi
, yi)
is the distance between parts i and j. (We can make this “distance” also depend on the inputs x if
we want, for example we may relax the distance penalty if we detect an edge.) In addition we will
have a local evidence term of the form p(yi
|x), which can be any kind of discriminative classifier,
such as a CNN, which predicts the distribution over locations for part i given the image x. The
overall model has the form
p(y|x) = 1
Z(x)
"Y
i
p(yi
|f(x)i)
# 

Y
(i,j)∈E
ψ(yi
, yj |x)

 (4.141)
where E is the set of edges in the CRF, and f(x)i
is the i’th output of the CNN.
We can think of this CRF as a series of parts connected by springs, where the energy of the system
increases if the parts are moved too far from their expected relative distance. This is illustrated in
Figure 4.35. The resulting model is known as a pictorial structure [FE73], or deformable parts
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license192
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
model [Fel+10]. Furthermore, since this is a conditional model, we can make the spring strengths
be image dependent.
We can find the globally optimal joint configuration y
∗ = argmaxy p(y|x, θ) using brute force
enumeration in O(KT
) time, where T is the number of nodes and K is the number of states (locations)
per node. While T is often small, (e.g., just 10 body parts in Figure 4.35), K is often very large,
since there are millions of possible locations in an image. By using tree-structured graphs, exact
inference can be done in O(TK2
) time, as we explain in Section 9.3.2. Furthermore, by exploiting
the fact that the discrete states are ordinal, inference time can be further reduced to O(TK), as
explained in [Fel+10].
Note that by “augmenting” standard deep neural network libaries with a dynamic programming
inference “module”, we can represent DPMs as a kind of CNN, as shown in [Gir+15]. The key
property is that we can backpropagate gradients through the inference algorithm.
4.4.3 Parameter estimation
In this section, we discuss how to perform maximum likelihood estimation for CRFs. This is a small
extension of the MRF case in Section 4.3.9.1.
4.4.3.1 Log-linear potentials
In this section we assume the log potential functions are linear in the parameters, i.e.,
ψc(yc; x, θ) = exp(θ
T
c φc
(x, yc)) (4.142)
Hence the log likelihood becomes
ℓ(θ) ,
1
N
X
n
log p(yn|xn, θ) =
1
N
X
n
"X
c
θ
T
c φc
(ync, xn) − log Z(xn; θ)
#
(4.143)
where
Z(xn; θ) =
X
y
exp(θ
Tφ(y, xn)) (4.144)
is the partition function for example n.
We know from Section 2.4.3 that the derivative of the log partition function yields the expected
sufficient statistics, so the gradient of the log likelihood can be written as follows:
∂ℓ
∂θc
=
1
N
X
n

φc
(ync, xn) −
∂
∂θc
log Z(xn; θ)

(4.145)
=
1
N
X
n

φc
(ync, xn) − Ep(y|xn,θ)
[φc
(y, xn)]
(4.146)
Since the objective is convex, we can use a variety of solvers to find the MLE, such as the
stochastic meta descent method of [Vis+06], which is a variant of SGD where the stepsize is adapted
automatically.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.5. COMPARING DIRECTED AND UNDIRECTED PGMS
4.4.3.2 General case
In the general case, a CRF can be written as follows:
p(y|x; θ) = exp(f(x, y; θ))
Z(x; θ)
=
exp(f(x, y; θ))
P
y′ exp(f(x, y′
; θ)) (4.147)
where f(x, y; θ) is a scoring (negative energy) function, where high scores correspond to probable
configurations. The gradient of the log likelihood is
∇θℓ(θ) = 1
N
X
N
n=1
∇θf(xn, yn; θ) − ∇θ log Z(xn; θ) (4.148)
Computing derivatives of the log partition function is tractable provided we can compute the
corresponding expectations, as we discuss in Section 4.3.9.2. Note, however, that we need to compute
these derivatives for every training example, which is slower than the MRF case, where the log
partition function is a constant independent of the observed data (but dependent on the model
parameters).
4.4.4 Other approaches to structured prediction
Many other approaches to structured prediction have been proposed, going beyond CRFs. For
example, max margin Markov networks [TGK03], and the closely relayed structural support
vector machine [Tso+05], can be seen as non-probabilistic alternatives to CRFs. More recently,
[BYM17] proposed structured prediction energy networks, which are a form of energy based
model (Chapter 24), where we predict using an optimization procedure, yˆ(x) = argmin E(x, y).
In addition, it is common to use graph neural networks (Section 16.3.6) and sequence-to-sequence
models such as transformers (Section 16.3.5) for this task.
4.5 Comparing directed and undirected PGMs
In this section, we compare DPGMs and UPGMs in terms of their modeling power, we discuss how
to convert from one to the other, and we and present a unified representation.
4.5.1 CI properties
Which model has more “expressive power”, a DPGM or a UPGM? To formalize the question, recall
from Section 4.2.4 that G is an I-map of a distribution p if I(G) ⊆ I(p), meaning that all the CI
statements encoded by the graph G are true of the distribution p. Now define G to be perfect map
of p if I(G) = I(p), in other words, the graph can represent all (and only) the CI properties of the
distribution. It turns out that DPGMs and UPGMs are perfect maps for different sets of distributions
(see Figure 4.36). In this sense, neither is more powerful than the other as a representation language.
As an example of some CI relationships that can be perfectly modeled by a DPGM but not a
UPGM, consider a v-structure A → C ← B. This asserts that A ⊥ B, and A 6⊥ B|C. If we drop
the arrows, we get A − C − B, which asserts A ⊥ B|C and A 6⊥ B, which is not consistent with
the independence statements encoded by the DPGM. In fact, there is no UPGM that can precisely
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license194
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Probabilistic Models
Graphical Models
Directed Chordal Undirected
Figure 4.36: DPGMs and UPGMs can perfectly represent different sets of distributions. Some distributions
can be perfectly represented by either DPGM’s or UPGMs; the corresponding graph must be chordal.
C
(a) (b) (c)
A
D B D B
A
C
D B
A
C
Figure 4.37: A UPGM and two failed attempts to represent it as a DPGM. From Figure 3.10 of [KF09a].
Used with kind permission of Daphne Koller.
represent all and only the two CI statements encoded by a v-structure. In general, CI properties in
UPGMs are monotonic, in the following sense: if A ⊥ B|C, then A ⊥ B|(C ∪ D). But in DPGMs,
CI properties can be non-monotonic, since conditioning on extra variables can eliminate conditional
independencies due to explaining away.
As an example of some CI relationships that can be perfectly modeled by a UPGM but not a
DPGM, consider the 4-cycle shown in Figure 4.37(a). One attempt to model this with a DPGM is
shown in Figure 4.37(b). This correctly asserts that A ⊥ C|B, D. However, it incorrectly asserts
that B ⊥ D|A. Figure 4.37(c) is another incorrect DPGM: it correctly encodes A ⊥ C|B, D, but
incorrectly encodes B ⊥ D. In fact there is no DPGM that can precisely represent all and only the
CI statements encoded by this UPGM.
Some distributions can be perfectly modeled by either a DPGM or a UPGM; the resulting graphs
are called decomposable or chordal. Roughly speaking, this means the following: if we collapse
together all the variables in each maximal clique, to make “mega-variables”, the resulting graph will
be a tree. Of course, if the graph is already a tree (which includes chains as a special case), it will
already be chordal.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.5. COMPARING DIRECTED AND UNDIRECTED PGMS
Coherence
Difficulty
Grade
Intelligence
SAT
Letter
Happy
Job
(a)
Coherence
Difficulty
Grade
Intelligence
SAT
Letter
Happy
Job
(b)
Figure 4.38: Left: the full student DPGM. Right: the equivalent UPGM. We add moralization arcs D-I, G-J,
and L-S. Adapted from Figure 9.8 of [KF09a].
4.5.2 Converting between a directed and undirected model
Although DPGMs and UPGMs are not in general equivalent, if we are willing to allow the graph to
encode fewer CI properties than may strictly hold, then we can safely convert one to the other, as we
explain below.
4.5.2.1 Converting a DPGM to a UPGM
We can easily convert a DPGM to a UPGM as follows. First, any “unmarried” parents that share a
child must get “married”, by adding an edge between them; this process is known as moralization.
Then we can drop the arrows, resulting in an undirected graph. The reason we need to do this is to
ensure that the CI properties of the UGM match those of the DGM, as explained in Section 4.3.6.2.
It also ensures there is a clique that can “store” the CPDs of each family.
Let us consider an example from [KF09a]. We will use the (full version of the student network
shown in Figure 4.38(a). The corresponding joint has the following form:
P(C, D, I, G, S, L, J, H) (4.149)
= P(C)P(D|C)P(I)P(G|I, D)P(S|I)P(L|G)P(J|L, S)P(H|G, J) (4.150)
Next, we define a potential or factor for every CPD, yielding
p(C, D, I, G, S, L, J, H) = ψC (C)ψD(D, C)ψI (I)ψG(G, I, D) (4.151)
ψS(S, I)ψL(L, G)ψJ (J, L, S)ψH(H, G, J) (4.152)
All the potentials are locally normalized, since they are CPDs, and hence there is no need
for a global normalization constant, so Z = 1. The corresponding undirected graph is shown in
Figure 4.38(b). We see that we have added D-I, G-J, and L-S moralization edges.11
11. We will see this example again in Section 9.5, where we use it to illustrate the variable elimination inference
algorithm.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license196
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
D
A
B
C
(a)
D E
A
C
B
(b)
Figure 4.39: (a) An undirected graphical model. (b) A directed equivalent, obtained by adding a dummy
observed child node.
xt−1 xt xt+1
yt−1
yt
yt+1
(a)
xt−1 xt xt+1
yt−1
yt
yt+1
(b)
Figure 4.40: Two discriminative models for sequential data. (a) An undirected model (CRF). (b) A directed
model (MEMM).
4.5.2.2 Converting a UPGM to a DPGM
To convert a UPGM to a DPGM, we proceed as follows. For each potential function ψc(xc; θc), we
create a “dummy node”, call it Yc, which is “clamped” to a special observed state, call it y
∗
c
. We
then define p(Yc = y
∗
c
|xc) = ψc(xc; θc). This “local evidence” CPD encodes the same factor as in the
DGM. The overall joint has the form pundir(x) ∝ pdir(x, y
∗
).
As an example, consider the UPGM in Figure 4.39(a), which defines the joint p(A, B, C, D) =
ψ(A, B, C, D)/Z. We can represent this as a DPGM by adding a dummy E node, which is a child
of all the other nodes. We set E = 1 and define the CPD p(E = 1|A, B, C, D) ∝ ψ(A, B, C, D). By
conditioning on this observed child, all the parents become dependent, as in the UGM.
4.5.3 Conditional directed vs undirected PGMs and the label bias problem
Directed and undirected models behave somewhat differently in the conditional (discriminative)
setting. As an example of this, let us compare the 1d undirected CRF in Figure 4.40a with the
directed Markov chain in Figure 4.40b. (This latter model is called a maximum entropy Markov model
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.5. COMPARING DIRECTED AND UNDIRECTED PGMS
y3 y4
x3 x4
y1
y2
x1 x2
Figure 4.41: A grid-structured MRF with hidden nodes xi and local evidence nodes yi. The prior p(x) is an
undirected Ising model, and the likelihood p(y|x) = Q
i
p(yi|xi) is a directed fully factored model.
(MEMM), which is a reference to the connection with maxent models discussed in Section 4.3.4.)
The MEMM suffers from a subtle problem compared to the CRF known (rather obscurely) as the
label bias problem [LMP01]. The problem is that local features at time t do not influence states
prior to time t. That is, yt−1 ⊥ xt|yt, thus blocking information flow backwards in time.
To understand what this means in practice, consider the part of speech tagging task which we
discussed in Section 4.4.1.1. Suppose we see the word “banks”; this could be a verb (as in “he banks
at Chase”), or a noun (as in “the river banks were overflowing”). Locally the part of speech tag for
the word is ambiguous. However, suppose that later in the sentence, we see the word “fishing”; this
gives us enough context to infer that the sense of “banks” is “river banks” and not “financial banks”.
However, in an MEMM the “fishing” evidence will not flow backwards, so we will not be able to infer
the correct label for “banks”. The CRF does not have this problem.
The label bias problem in MEMMs occurs because directed models are locally normalized,
meaning each CPD sums to 1. By contrast, MRFs and CRFs are globally normalized, which
means that local factors do not need to sum to 1, since the partition function Z, which sums over all
joint configurations, will ensure the model defines a valid distribution.
However, this solution comes at a price: in a CRF, we do not get a valid probability distribution over
y1:T until we have seen the whole sentence, since only then can we normalize over all configurations.
Consequently, CRFs are not as useful as directed probabilistic graphical models (DPGM) for online
or real-time inference. Furthermore, the fact that Z is a function of all the parameters makes CRFs
less modular and much slower to train than DPGM’s, as we discuss in Section 4.4.3.
4.5.4 Combining directed and undirected graphs
We can also define graphical models that contain directed and undirected edges. We discuss a few
examples below.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license198
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
A
C
F
D
G
E
B
I
H
Figure 4.42: A partially directed acyclic graph (PDAG). The chain components are {A}, {B}, {C, D, E},
{F, G}, {H}, and {I}. Adapted from Figure 4.15 of [KF09a].
4.5.4.1 Chain graphs
A chain graph is a PGM which may have both directed and undirected edges, but without any
directed cycles. A simple example is shown in Figure 4.41, which defines the following joint model:
p(x1:D, y1:D) = p(x1:D)p(y1:D|x1:D) =


1
Z
Y
i∼j
ψij (xi
, xj )


"Y
D
i=1
p(yi
|xi)
#
(4.153)
In this example, the prior p(x) is specified by a UPGM, and the likelihood p(y|x) is specified as a
fully factorized DPGM.
More generally, a chain graph can be defined in terms of a partially directed acyclic graph
(PDAG). This is a graph which can be decomposed into a directed graph of chain components,
where the nodes within each chain component are connected with each other only with undirected
edges. See Figure 4.42 for an example.
We can use a PDAG to define a joint distribution using Q
i
p(Ci
|pa(Ci)), where each Ci
is a chain
component, and each CPD is a conditional random field. For example, referring to Figure 4.42, we
have
p(A, B, ..., I) = p(A)p(B)p(C, D, E|A, B)p(F, G|C, D)p(H)p(I|C, E, H) (4.154)
p(C, D, E|A, B) = 1
Z(A, B)
φ(A, C)φ(B, E)φ(C, D)φ(D, E) (4.155)
p(F, G|C, D) = 1
Z(C, D)
φ(F, C)φ(G, D)φ(F, G) (4.156)
For more details, see e.g., [KF09a, Sec 4.6.2].
4.5.4.2 Acyclic directed mixed graphs
One can show [Pea09b, p51] that every latent variable DPGM can be rewritten in a way such that
every latent variable is a root node with exactly two observed children. This is called the projection
of the latent variable PGM, and is observationally indistinguishable from the original model.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.5. COMPARING DIRECTED AND UNDIRECTED PGMS
Y4
Y1
Y2 Y3
H2
H1
(a)
Y4
Y1
Y2 Y3
(b)
Y4
Y1
Y2 Y3
(c)
Figure 4.43: (a) A DAG with two hidden variables (shaded). (b) The corresponding ADMG. The bidirected
edges reflect correlation due to the hidden variable. (c) A Markov equivalent ADMG. From Figure 3 of [SG09].
Used with kind permission of Ricardo Silva.
Each such latent variable root node induces a dependence between its two children. We can
represent this with a directed arc. The resulting graph is called an acyclic directed mixed graph
or ADMG. See Figure 4.43 for an example. (A mixed graph is one with undirected, unidirected,
and bidirected edges.)
One can determine CI properties of ADMGs using a technique called m-separation [Ric03].
This is equivalent to d-separation in a graph where every bidirected edge Yi ↔ Yj is replaced by
Yi ← Xij → Yj , where Xij is a hidden variable for that edge.
The most common example of ADMGs is when everything is linear-Gaussian. This is known as a
structural equation model and is discussed in Section 4.7.2.
4.5.5 Comparing directed and undirected Gaussian PGMs
In this section, we compare directed and undirected Gaussian graphical models. In Section 4.2.3,
we saw that directed GGMs correspond to sparse regression matrices. In Section 4.3.5, we saw that
undirected GGMs correspond to sparse precision matrices.
The advantage of the DAG formulation is that we can make the regression weights W, and hence Σ,
be conditional on covariate information [Pou04], without worrying about positive definite constraints.
The disadavantage of the DAG formulation is its dependence on the order, although in certain
domains, such as time series, there is already a natural ordering of the variables.
It is actually possible to combine both directed and undirected representations, resulting in a
model known as a (Gaussian) chain graph. For example, consider a discrete-time, second-order
Markov chain in which the observations are continuous, xt ∈ R
D. The transition function can be
represented as a (vector-valued) linear-Gaussian CPD:
p(xt|xt−1, xt−2, θ) = N (xt|A1xt−1 + A2xt−2, Σ) (4.157)
This is called a vector autoregressive or VAR process of order 2. Such models are widely used in
econometrics for time series forecasting.
The time series aspect is most naturally modeled using a DPGM. However, if Σ
−1
is sparse, then
the correlation amongst the components within a time slice is most naturally modeled using a UPGM.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license200
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 4.44: A VAR(2) process represented as a dynamic chain graph. From [DE00]. Used with kind
permission of Rainer Dahlhaus.
For example, suppose we have
A1 =


3
5
0
1
5
0 0
0
3
5
0 −
1
5
0
2
5
1
3
3
5
0 0
0 0 0 −
1
2
1
5
0 0 1
5
0
2
5


, A2 =


0 0 −
1
5
0 0
0 0 0 0 0
0 0 0 0 0
0 0 1
5
0
1
3
0 0 0 0 −
1
5


(4.158)
and
Σ =


1
1
2
1
3
0 0
1
2
1 −
1
3
0 0
1
3 −
1
3
1 0 0
0 0 0 1 0
0 0 0 0 1


, Σ
−1 =


2.13 −1.47 −1.2 0 0
−1.47 2.13 1.2 0 0
−1.2 1.2 1.8 0 0
0 0 0 1 0
0 0 0 0 1


(4.159)
The resulting graphical model is illustrated in Figure 4.44. Zeros in the transition matrices A1 and
A2 correspond to absent directed arcs from xt−1 and xt−2 into xt. Zeros in the precision matrix
Σ
−1
correspond to absent undirected arcs between nodes in xt.
4.5.5.1 Covariance graphs
Sometimes we have a sparse covariance matrix rather than a sparse precision matrix. This can
be represented using a bi-directed graph, where each edge has arrows in both directions, as in
Figure 4.45(a). Here nodes that are not connected are unconditionally independent. For example
in Figure 4.45(a) we see that Y1 ⊥ Y3. In the Gaussian case, this means Σ1,3 = Σ3,1 = 0. (A
graph representing a sparse covariance matrix is called a covariance graph, see e.g., [Pen13]). By
contrast, if this were an undirected model, we would have that Y1 ⊥ Y3|Y2, and Λ1,3 = Λ3,1 = 0,
where Λ = Σ
−1
.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.6. PGM EXTENSIONS
Y1 Y2 Y3
(a)
Y1 Y2 Y3
Z1 Z2
(b)
Figure 4.45: (a) A bi-directed graph. (b) The equivalent DAG. Here the z nodes are latent confounders.
Adapted from Figures 5.12–5.13 of [Cho11].
A bidirected graph can be converted to a DAG with latent variables, where each bidirected edge is
replaced with a hidden variable representing a hidden common cause, or confounder, as illustrated
in Figure 4.45(b). The relevant CI properties can then be determined using d-separation.
4.6 PGM extensions
In this section, we discuss some extensions of the basic PGM framework.
4.6.1 Factor graphs
A factor graph [KFL01; Loe04] is a graphical representation that unifies directed and undirected
models. They come in two main “flavors”. The original version uses a bipartite graph, where we have
nodes for random variables and nodes for factors, as we discuss in Section 4.6.1.1. An alternative
form, known as a Forney factor graphs [For01] just has nodes for factors, and the variables are
associated with edges, as we explain in Section 4.6.1.2.
4.6.1.1 Bipartite factor graphs
A factor graph is an undirected bipartite graph with two kinds of nodes. Round nodes represent
variables, square nodes represent factors, and there is an edge from each variable to every factor
that mentions it. For example, consider the MRF in Figure 4.46(a). If we assume one potential per
maximal clique, we get the factor graph in Figure 4.46(b), which represents the function
f(x1, x2, x3, x4) = f124(x1, x2, x4)f234(x2, x3, x4) (4.160)
We can represent this in a topologically equivalent way as in Figure 4.46(c).
One advantage of factor graphs over UPGM diagrams is that they are more fine-grained. For
example, suppose we associate one potential per edge, rather than per clique. In this case, we get
the factor graph in Figure 4.46(d), which represents the function
f(x1, x2, x3, x4) = f14(x1, x4)f12(x1, x2)f34(x3, x4)f23(x2, x3)f24(x2, x4) (4.161)
We can also convert a DPGM to a factor graph: just create one factor per CPD, and connect
that factor to all the variables that use that CPD. For example, Figure 4.47 represents the following
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license202
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
x1
x2
x3
x4
(a)
x1 x2 x3 x4
f124 f234
(b)
x3
f234
x4 x2
f124
x1
(c)
x3
f34
x4 f24 x2
f23
f14 f12
x1
(d)
Figure 4.46: (a) A simple UPGM. (b) A factor graph representation assuming one potential per maximal
clique. (c) Same as (b), but graph is visualized differently. (d) A factor graph representation assuming one
potential per edge.
x4 x5
x3
x1 x2
(a)
x4
p(x4|x3)
x3
p(x5|x3)
x5
p(x3|x1, x2)
x1 x2
p(x1) p(x2)
(b)
Figure 4.47: (a) A simple DPGM. (b) Its corresponding factor graph.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.6. PGM EXTENSIONS
X1 X2 X3
X4
X5
fa fb fc
fd
(a)
X1 X2 X3
X4
X5
fPrior
flik
(b)
Figure 4.48: A Forney factor graph. (a) Directed version. (b) Hierarchical version.
factorization:
f(x1, x2, x3, x4, x5) = f1(x1)f2(x2)f123(x1, x2, x3)f34(x3, x4)f35(x3, x5) (4.162)
where we define f123(x1, x2, x3) = p(x3|x1, x2), etc. If each node has at most one parent (and hence
the graph is a chain or simple tree), then there will be one factor per edge (root nodes can have their
prior CPDs absorbed into their children’s factors). Such models are equivalent to pairwise MRFs.
4.6.1.2 Forney factor graphs
A Forney factor graph (FFG), also called a normal factor graph, is a graph in which nodes
represent factors, and edges represent variables [For01; Loe04; Loe+07; CLV19]. This is more similar
to standard neural network diagrams, and electrical engineering diagrams, where signals (represented
as electronic pulses, or tensors, or probability distributions) propagate along wires and are modified
by functions represented as nodes.
For example, consider the following factorized function:
f(x1, . . . , x5) = fa(x1)fb(x1, x2)fc(x2, x3, x4)fd(x4, x5) (4.163)
We can visualize this as an FFG as in Figure 4.48a. The edge labeled x3 is called a half-edge, since
it is only connected to one node; this is because x3 only participates in one factor. (Similarly for x5.)
The directionality associated with the edges is a useful mnemonic device if there is a natural order in
which the variables are generated. In addition, associating directions with each edge allows us to
uniquely name “messages” that are sent along each edge, which will prove useful when we discuss
inference algorithms in Section 9.3.
In addition to being more similar to neural network diagrams, FFGs have the advantage over
bipartite FGs in that they support hierarchical (compositional) construction, in which complex
dependency structure between variables can be represented as a blackbox, with the input/output
interface being represented by edges corresponding to the variables exposed by the blackbox. See
Figure 4.48b for an example, which represents the function
f(x1, . . . , x5) = fprior(x1, x2, x3, x4)flik(x4, x5) (4.164)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license204
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 4.49: An FFG with an equality constraint node (left) and its corresponding simplified form (right).
The factor fprior represents a (potentially complex) joint distribution p(x1, x2, x3, x4), and the factor
flik represents the likelihood term p(x5|x4). Such models are widely used to build error-correcting
codes (see Section 9.4.8).
To allow for variables to participate in more than 2 factors, equality constraint nodes are introduced,
as illustrated in Figure 4.49(a). Formally, this is a factor defined as follows:
f=(x, x1, x2) = δ(x − x1)δ(x − x2) (4.165)
where δ(u) is a Dirac delta if u is continuous, and a Kronecker delta if u is discrete. The effect of
this factor is to ensure all the variables connected to the factor have the same value; intuitively, this
factor acts like a “wire splitter”. Thus the function represented in Figure 4.49(a) is equivalent to the
following:
f(x, y1, y2) = fx(x)fy|x(y1, x)fy|x(y2, x) (4.166)
This simplified form is represented in Figure 4.49(b), where we reuse the x variable across multiple
edges. We have chosen the edge orientations to reflect our interpretation of the factors fy|x(y, x) as
likelihood terms, p(y|x). We have also chosen to reuse the same fy|x factor for both y variables; this
is an example of parameter tying.
4.6.2 Probabilistic circuits
A probabilistic circuit is a kind of graphical model that supports efficient exact inference. It
includes arithmetic circuits [Dar03; Dar09], sum-product networks (SPNs) [PD11; SCPD22].
and other kinds of model.
Here we briefly describe SPNs. An SPN is a probabilistic model, based on a directed tree-structured
graph, in which terminal nodes represent univariate probability distributions and non-terminal nodes
represent convex combinations (weighted sums) and products of probability functions. SPNs are
similar to deep mixture models, in which we combine together dimensions. SPNs leverage context￾specific independence to reduce the complexity of exact inference to time that is proportional to the
number of links in the graph, as opposed to the treewidth of the graph (see Section 9.5.2).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.6. PGM EXTENSIONS
SPNs are particularly useful for tasks such as missing data imputation of tabular data (see e.g.,
[Cla20; Ver+19]). A recent extension of SPNs, known as einsum networks, is proposed in [Peh+20]
(see Section 9.7.1 for details on the connection between einstein summation and PGM inference).
4.6.3 Directed relational PGMs
A Bayesian network defines a joint probability distribution over a fixed number of random variables.
By using plate notation (Section 4.2.8), we can define models with certain kinds of repetitive structure,
and tied parameters, but many models are not expressible in this way. For example, it is not possible
to represent even a simple HMM using plate notation (see Figure 29.12). Various notational extensions
of plates have been proposed to handle repeated structure (see e.g., [HMK04; Die10]) but have not
been widely adopted. The problem becomes worse when we have more complex domains, involving
multiple objects which interact via multiple relationships.12 Such models are called relational
probability models or RPMs. In this section, we focus on directed RPMs; see Section 4.6.4 for
the undirected case.
As in first order logic, RPMs have constant symbols (representing objects), function symbols
(mapping one set of constants to another), and predicate symbols (representing relations between
objects). We will assume that each function has a type signature. To illustrate this, consider an
example from [RN19, Sec 15.1], which concerns online book reviews on sites such as Amazon. Suppose
there are two types of objects, Book and Customer, and the following functions and predicates:
Honest : Customer → {True, False} (4.167)
Kindess : Customer → {1, 2, 3, 4, 5} (4.168)
Quality : Book → {1, 2, 3, 4, 5} (4.169)
Recommendation : Customer × Book → {1, 2, 3, 4, 5} (4.170)
The constant symbols refer to specific objects. To keep things simple, we assume there are two
books, B1 and B2, and two customers, C1 and C2. The basic random variables are obtained
by instantiating each function with each possible combination of objects to create a set of ground
terms. In this example, these variables are H(C1), Q(B1), R(C1, B2), etc. (We use the abbreviations
H, K, Q and R for the functions Honest, Kindness, Quality, and Recommendation.13 )
We now need to specify the (conditional) distribution over these random variables. We define these
distributions in terms of the generic indexed form of the variables, rather than the specific ground
form. For example, we may use the following priors for the root nodes (variables with no parents):
H(c) ∼ Cat(0.99, 0.01) (4.171)
K(c) ∼ Cat(0.1, 0.1, 0.2, 0.3, 0.3) (4.172)
Q(b) ∼ Cat(0.05, 0.2, 0.4, 0.2, 0.15) (4.173)
For the recommendation nodes, we need to define a conditional distribution of the form
R(c, b) ∼ RecCPD(H(c), K(c), Q(b)) (4.174)
12. See e.g., this blog post from Rob Zinkov: https://www.zinkov.com/posts/2013-07-28-stop-using-plates.
13. A unary function of an object that returns a basic type, such as Boolean or an integer, is often called an attribute
of that object.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license206
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Q(Bj ) R(Ci
, Bj )
H(Ci)
K(Ci)
(a)
Q(B1)
Q(B2)
R(C1, B1)
H(C1)
R(C1, B2)
K(C1)
R(C2, B1)
H(C2)
R2(C2, B2)
K(C2)
(b)
Figure 4.50: RPM for the book review domain. (a) Template for a generic customer Ci and book Bj pair. R
is rating, Q is quality, H is honesty, and K is kindness. (b) Unrolled model for 2 books and 2 customers.
where RecCPD is the conditional probability distribution (CPD) for the recommendation node. If
represented as a conditional probability table (CPT), this has 2 × 5 × 5 = 50 rows, each with 5
entries. This table can encode our assumptions about what kind of ratings a book receives based on
the quality of the book, but also properties of the reviewer, such as their honest and kindness. (More
sophisticated models of human raters in the context of crowd-sourced data collection can be found in
e.g., [LRC19].)
We can convert the above formulae into a graphical model “template”, as shown in Figure 4.50a.
Given a set of objects, we can “unroll” the template to create a “ground network”, as shown in
Figure 4.50b. There are C × B + 2C + B random variables, with a corresonding joint state space
(set of possible worlds) of size 2
C 5
C+B+BC , which can get quite large. However, if we are only
interested in answering specific queries, we can dynamically unroll small pieces of the network that
are relevant to that query [GC90; Bre92].
Let us assume that only a subset of the R(c, b) entries are observed, and we would like to
predict the missing entries of this matrix. This is essentially a simplified recommender system.
(Unfortunately it ignores key aspects of the problem, such as the content/topic of the books, and
the interests/preferences of the customers.) We can use standard probabilistic inference methods for
graphical models (which we discuss in Chapter 9) to solve this problem.
Things get more interesting when we don’t know which objects are being referred to. For example,
customer C1 might write a review of a book called “Probabilistic Machine Learning”, but do they
mean edition 1 (B1) or edition 2 (B2)? To handle this kind of relational uncertainty, we can add
all possible referents as parents to each relation. This is illustrated in Figure 4.51, where now Q(B1)
and Q(B2) are both parents of R(C1, B1). This is necessary because their review score might either
depend on Q(B1) or Q(B2), depending on which edition they are writing about. To disambiguate
this, we create a new variable, L(Ci), which specifies which version number of each book customer i
is referring to. The new CPD for the recommendation node, p(R(c, b)|H(c), K(c), Q(1 : B), L(c)),
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.6. PGM EXTENSIONS
Q(B1)
Q(B2)
R(C1, B1)
H(C1)
R(C1, B2)
K(C1)
L(C1)
R(C2, B1)
H(C2)
R2(C2, B2)
K(C2)
L(C2)
Figure 4.51: An extension of the book review RPM to handle identity uncertainty about which book a given
customer is actually reviewing. The R(c, b) node now depends on all books, since we don’t know which one is
being referred to. We can select one of these parents based on the mapping specified by the user’s library, L(c).
has the form
R(c, b) ∼ RecCPT(H(c), K(c), Q(b
′
)) where b
′ = L(c) (4.175)
This CPD acts like a multiplexer, where the L(c) node specifies which of the parents Q(1 : B) to
actually use.
Although the above problem may seem contrived, identity uncertainty is a widespread problem
in many areas, such as citation analysis, credit card histories, and object tracking (see Section 4.6.5).
In particular, the problem of entity resolution or record linkage — which refers to the task of
mapping particular strings (such as names) to particular objects (such as people) — is a whole
field of research (see e.g., https://en.wikipedia.org/wiki/Record_linkage for an overview and
[SHF15] for a Bayesian approach).
4.6.4 Undirected relational PGMs
We can create relational UGMs in a manner which is analogous to relational DGMs (Section 4.6.3).
This is particularly useful in the discriminative setting, for the same reasons that undirected CRFs
are preferable to conditional DGMs (see Section 4.4).
4.6.4.1 Collective classification
As an example of a relational UGM, suppose we are interested in the problem of classifying web
pages of a university into types (e.g., student, professor, admin, etc.) Obviously we can do this based
on the contents of the page (e.g., words, pictures, layout, etc.) However, we might also suppose
there is information in the hyper-link structure itself. For example, it might be likely for students to
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license208
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Fr(A,A) Fr(B,B) Fr(B,A) Fr(A,B) Sm(A) Sm(B) Ca(A) Ca(B)
1 1 0 1 1 1 1 1
1 1 0 1 1 0 0 0
1 1 0 1 1 1 0 1
Table 4.5: Some possible joint instantiations of the 8 variables in the smoking example.
cite professors, and professors to cite other professors, but there may be no links between admin
pages and students/professors. When faced with a web page whose label is ambiguous, we can bias
our estimate based on the estimated labels of its neighbors, as in a CRF. This process is known
as collective classification (see e.g., [Sen+08]). To specify the CRF structure for a web-graph of
arbitrary size and shape, we just specify a template graph and potential functions, and then unroll
the template appropriately to match the topology of the web, making use of parameter tying.
4.6.4.2 Markov logic networks
One particularly popular way of specifying relational UGMs is to use first-order logic rather than
a graphical description of the template. The result is known as a Markov logic network [RD06;
Dom+06; DL09].
For example, consider the sentences “Smoking causes cancer” and “If two people are friends, and
one smokes, then so does the other”. We can write these sentences in first-order logic as follows:
∀x.Sm(x) =⇒ Ca(x) (4.176)
∀x.∀y.F r(x, y) ∧ Sm(x) =⇒ Sm(y) (4.177)
where Sm and Ca are predicates, and F r is a relation.
It is convenient to write all formulas in conjunctive normal form (CNF), also known as clausal
form. In this case, we get
¬Sm(x) ∨ Ca(x) (4.178)
¬F r(x, y) ∨ ¬Sm(x) ∨ Sm(y) (4.179)
The first clause can be read as “Either x does not smoke or he has cancer”, which is logically equivalent
to Equation (4.176). (Note that in a clause, any unbound variable, such as x, is assumed to be
universally quantified.)
Suppose there are just two objects (people) in the world, Anna and Bob, which we will denote by
constant symbols A and B. We can then create 8 binary random variables Sm(x), Ca(x), and
F r(x, y) for x, y ∈ {A, B}. This defines 2
8 possible worlds, some of which are shown in Table 4.5.
14
Our goal is to define a probability distribution over these joint assignments. We can do this by
creating a UGM with these variables, and adding a potential function to capture each logical rule or
14. Note that we have not encoded the fact that F r is a symmetric relation, so F r(A, B) and F r(B, A) might have
different values. Similarly, we have the “degenerate” nodes F r(A) and F r(B), since we did not enforce x =6 y in
Equation (4.177). (If we add such constraints, then the model compiler, which generates the ground network, should
avoid creating redundant nodes.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.6. PGM EXTENSIONS
Friends(A,A) Smokes(A) Smokes(B) Friends(B,B)
Friends(A,B)
Friends(B,A)
Cancer(A) Cancer(B)
Figure 4.52: An example of a ground Markov logic network represented as a pairwise MRF for 2 people.
Adapted from Figure 2.1 from [DL09]. Used with kind permission of Pedro Domingos.
constraint. For example, we can encode the rule ¬Sm(x) ∨ Ca(x) by creating a potential function
Ψ(Sm(x), Ca(x)), where we define
Ψ(Sm(x), Ca(x)) = (
1 if ¬Sm(x) ∨ Ca(x) = T
0 if ¬Sm(x) ∨ Ca(x) = F
(4.180)
The result is the UGM in Figure 4.52.
The above approach will assign non-zero probability to all logically valid worlds. However, logical
rules may not always be true. For example, smoking does not always cause cancer. We can relax the
hard constraints by using non-zero potential functions. In particular, we can associate a weight with
each rule, and thus get potentials such as
Ψ(Sm(x), Ca(x)) = (
e
w if ¬Sm(x) ∨ Ca(x) = T
e
0
if ¬Sm(x) ∨ Ca(x) = F
(4.181)
where the value of w > 0 controls strongly we want to enforce the corresponding rule.
The overall joint distribution has the form
p(x) = 1
Z(w)
exp(
X
i
wini(x)) (4.182)
where ni(x) is the number of instances of clause i which evaluate to true in assignment x.
Given a grounded MLN model, we can then perform inference using standard methods. Of course,
the ground models are often extremely large, so more efficient inference methods, which avoid creating
the full ground model (known as lifted inference), must be used. See [DL09; KNP11] for details.
One way to gain tractability is to relax the discrete problem to a continuous one. This is the
basic idea behind hinge-loss MRFs [Bac+15b], which support exact inference using scalable convex
optimization. There is a template language for this model family known as probabilistic soft logic,
which has a similar “flavor” to MLN, although it is not quite as expressive.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license210
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Recently MLNs have been combined with DL in various ways. For example, [Zha+20f] uses graph
neural networks for inference. And [WP18] uses MLNs for evidence fusion, where the noisy predictions
come from DNNs trained using weak supervision.
Finally, it is worth noting one subtlety which arises with undirected models, namely that the size
of the unrolled model, which depends on the number of objects in the universe, can affect the results
of inference, even if we have no data about the new objects. For example, consider an undirected
chain of length T, with T hidden nodes zt and T observed nodes yt; call this model M1. Now suppose
we double the length of the chain to 2T, without adding more evidence; call this model M2. We find
that p(zt|y1:T , M1) 6= p(zt|y1:T , M2), for t = 1 : T, even though we have not added new information,
due to the different partition functions. This does not happen with a directed chain, because the
newly added nodes can be marginalized out without affecting the original nodes, since the model is
locally normalized and therefore modular. See [JBB09; Poo+12] for further discussion.
4.6.5 Open-universe probability models
In Section 4.6.3, we discussed relational probability models, as well as the topic of identity uncertainty.
However, we also implicitly made a closed world assumption, namely that the set of all objects is
fixed and specified ahead of time. In many real world problems, this is an unrealistic assumption.
For example, in Section 29.9.3.5, we discuss the problem of tracking an unknown number of objects
over time. As another example, consider the problem of enforcing the UN Comprehensive Nuclear
Test Ban Treaty (CTBT). This requires monitoring seismic events, and determinining if they were
caused by nature or man-made explosions. Thus the number of objects of each type, as well as their
source, is uncertain [ARS13],
As another (more peaceful) example, suppose we want to perform citation matching, in which
we want to know whether to cite an arxiv version of a paper or the version on some conference
website. Are these the same object? It is often hard to tell, since the titles and author might be the
same, yet the content may have been updated. It is often necessary to use subtle cues, such as the
date stored in the meta-data, to infer if the two “textual measurements” refer to the same underlying
object (paper) or not [Pas+02].
In problems such as these, the number of objects of each type, as well as their relationships, is
uncertain. This requires the use of open-universe probability models or OUPM, which can
generate new objects as well as their properties [Rus15; MR10; LB19]. The first formal language
for OUPMs was BLOG [Mil+05], which stands for “Bayesian LOGic”. This used a general purpose,
but slow, MCMC inference scheme to sample over possible worlds of variable size and shape.
[Las08; LLC20] describes another open-universe modeling language called multi-entity Bayesian
networks.
Very recently, Facebook has released the Bean Machine library, available at https://beanmachine.
org/, which supports more efficient inference in OUPMs. Details can be found in [Teh+20], as well
as their blog post.15
4.6.6 Programs as probability models
OUPMs, discussed in Section 4.6.5, let us define probability models over complex dynamic state
spaces of unbounded and variable size. The set of possible worlds correspond to objects and their
15. See https://tinyurl.com/2svy5tmh.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.7. STRUCTURAL CAUSAL MODELS
attributes and relationships. Another approach is to use a probabilistic programming language
or PPL, in which we define the set of possible words as the set of execution traces generated by
the program when it is endowed with a random choice mechanism. (This is a procedural approach
to the problem, whereas OUPMs are a declarative approach.)
The difference between a probabilistic programming language and a standard one was described in
[Gor+14] as follows: “Probabilistic programs are usual functional or imperative programs with two
added constructs: (1) the ability to draw values at random from distributions, and (2) the abiliy to
condition values of variables in a program via observation”. The former is a way to define p(z, y),
and the latter is the same as standard Bayesian conditioning p(z|y).
Some recent examples of PPLs include Gen [CT+19], Pyro [Bin+19] and Turing [GXG18].
Inference in such models is often based on SMC, which we discuss in Chapter 13. For more details
on PPLs, see e.g. [Mee+18].
4.7 Structural causal models
While probabilities encode our beliefs about a static world, causality tells us whether and how
probabilities change when the world changes, be it by intervention or by act of imagination. —
Judea Pearl [PM18b].
In this section, we discuss how we can use directed graphical model notation to represent causal
models. We discuss causality in greater detail in Chapter 36, but we introduce some basic ideas and
notation here, since it is foundational material that we will need in other parts of the book.
The core idea behind causal models is to create a mechanistic model of the world in which we
can reason about the effects of local changes. The canonical example is an electronic circuit: we
can predict the effects of any action, such as “knocking out” a particular transistor, or changing the
resistance level of a wire, by modifying the circuit locally, and then “re-running” it from the same
initial conditions.
We can generalize this idea to create a structural causal models or SCM [PGJ16], also called
functional causal model [Sch19]. An SCM is a triple M = (U, V, F), where U = {Ui
: i = 1 : N}
is a set of unexplained or exogenous “noise” variables, which are passed as input to the model,
V = {Vi
: i = 1 : N} is a set of endogeneous variables that are part of the model itself, and
F = {fi
: i = 1 : N} is a set of deterministic functions of the form Vi = fi(Vpai
, Ui), where pai are the
parents of variable i, and Ui ∈ U are the external inputs. We assume the equations can be structured
in a recursive way, so the dependency graph of nodes given their parents is a DAG. Finally, we
assume our model is causally sufficient, which means that V and U are all of the causally relevant
factors (although they may not all be observed). This is called the “causal Markov assumption”.
Of course, a model typically cannot represent all the variables that might influence observations or
decisions. After all, models are abstractions of reality. The variables that we choose not to model
explicitly in a functional way can be lumped into the unmodeled exogenous terms. To represent
our ignorance about these terms, we can use a distribution p(U) over their values. By “pushing”
this external noise through the deterministic part of the model, we induce a distribution over the
endogeneous variables, p(V), as in a probabilistic graphical model. However, SCMs make stronger
assumptions than PGMs.
We usually assume p(U) is factorized (i.e., the Ui are independent); this is called a Markovian
SCM. If the exogeneous noise terms are not independent, it would break the assumption that
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license212
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
X
Z
Y
(a)
X
Z
Y
Ux Uz Uy
Wxy
Wxz Wzy
(b)
Figure 4.53: (a) PGM for modeling relationship between salary, education and debt. (b) Corresponding SCM.
outcomes can be determined locally using deterministic functions. If there are believed to be
dependencies between some of the Ui
, we can add extra hidden parents to represent this; this is often
depicted as a bidirected or undirected edge connecting the Ui
, and is known as a semi-Markovian
SCM.
4.7.1 Example: causal impact of education on wealth
We now give a simple example of an SCM, based on [PM18b, p276]. Suppose we are interested in
the causal effect of education on wealth. Let X represent the level of education of a person (on
some numeric scale, say 0 = high school, 1 = college, 2 = graduate school), and Y represent their
wealth (at some moment in time). In some cases we might expect that increasing X would increase Y
(although it of course depends on the nature of the degree, the nature of the job, etc). Thus we add
an edge from X to Y . However, getting more education can cost a lot of money (in certain countries),
which is a potentially confounding factor on wealth. Let Z be the debt incurred by a person based
on their education. We add an edge from X to Z to reflect the fact that larger X means larger Z (in
general), and we add an edge from Z to Y to reflect that larger Z means lower Y (in general).
We can represent our structural assumptions graphically as shown in Figure 4.53b(a). The
corresponding SCM has the form:
X = fX(Ux) (4.183)
Z = fZ(X, Uz) (4.184)
Y = fY (X, Z, Uy) (4.185)
for some set of functions fx, fy, fz, and some prior distribution p(Ux, Uy, Uz). We can also explicitly
represent the exogeneous noise terms as shown in Figure 4.53b(b); this makes clear our assumption
that the noise terms are a priori independent. (We return to this point later.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.7. STRUCTURAL CAUSAL MODELS
X
Z
Y
(a)
X
Z
Y
Az
(b)
Figure 4.54: An SCM in which we intervene on Z. (a) Hard intervention, in which we clamp Z and thus cut
its incoming edges (shown as dotted). (b) Soft intervention, in which we change Z’s mechanism. The square
node is an “action” node, using the influence diagram notation from Section 34.2.
4.7.2 Structural equation models
A structural equation model [Bol89; BP13], also known as a path diagram, is a special case of
a structural causal model in which all the functional relationships are linear, and the prior on the
noise terms is Gaussian. SEMs are widely used in economics and social science, due to the fact that
they have a causal interpretation, yet they are computationally tractable.
For example, let us make an SEM version of our education example. We have
X = Ux (4.186)
Z = cz + wxzX + Uz (4.187)
Y = cy + wxyX + wzyZ + Uy (4.188)
If we assume p(Ux) = N (Ux|0, σ2
x
), p(Uz) = N (Ux|0, σ2
z
), and p(Uy) = N (Ux|0, σ2
y
), then the model
can be converted to the following Gaussian DGM:
p(X) = N (X|µx, σ2
x
) (4.189)
p(Z|X) = N (Z|cz + wxzX, σ2
z
) (4.190)
p(Y |X, Z) = N (Y |cy + wxyX + wzyZ, σ2
y
) (4.191)
We can relax the linearity assumption, to allow arbitrarily flexible functions, and relax the Gaussian
assumption, to allow any noise distribution. The resulting “nonparametric SEMs” are equivalent to
structural causal models. (For a more detailed comparison between SEMs and SCMs, see [Pea12;
BP13; Shi00b].)
4.7.3 Do operator and augmented DAGs
One of the main advantages of SCMs is that they let us predict the effect of interventions, which
are actions that change one or more local mechanisms. A simple intervention is to force a variable to
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license214
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
have a given value, e.g., we can force a gene to be “on” or “off”. This is called a perfect intervention
and is written as do(Xi = xi), where we have introduced new notation for the “do” operator (as
in the verb “to do”). This notation means we actively clamp variable Xi to value xi (as opposed to
just observing that it has this value). Since the value of Xi
is now independent of its usual parents,
we should “cut” the incoming edges to node Xi
in the graph. This is called the “graph surgery”
operation.
In Figure 4.54a we illustrate this for our education SCM, where we force Z to have a given value.
For example, we may set Z = 0, by paying off everyone’s student debt. Note that p(X|do(Z = z)) 6=
p(X|Z = z), since the intervention changes the model. For example, if we see someone with a debt of
0, we may infer that they probably did not get higher education, i.e., p(X ≥ 1|Z = 0) is small; but if
we pay off everyone’s college loans, then observing someone with no debt in this modified world should
not change our beliefs about whether they got higher education, i.e., p(X ≥ 1|do(Z = 0)) = p(X ≥ 1).
In more realistic scenarios, we may not be able to set a variable to a specific value, but we may
be able to change it from its current value in some way. For example, we may be able to reduce
everyone’s debt by some fixed amount, say ∆ = −10, 000. Thus we replace Z = fZ(X, Uz) with
Z = f
′
z
(Z, Uz), where f
′
z
(Z, Uz) = fz(Z, Uz) + ∆. This is called an additive intervention.
To model this kind of scenario, we can add create an augmented DAG, in which every variable is
augmented with an additional parent node, representing whether or not the variable’s mechanism is
changed in some way [Daw02; Daw15; CPD17]. These extra variables are represented by square nodes,
and correspond to decision variables or actions, as in the influence diagram formalism (Section 34.2).
The same formalism is used in MDPs for reinforcement learning (see Section 34.5).
We give an example of this in Figure 4.54b, where we add the Az ∈ {0, 1} node to specify whether
we use the debt reduction policy or not. The modified mechanism for Z becomes
Z = f
′
Z(X, Ux, Az) = (
fZ(X, Ux) if Az = 0
fZ(X, Ux) + ∆ if Az = 1
(4.192)
With this new definition, conditioning on the effects of an action can be performed using standard
probabilistic inference. That is, p(Q|do(Az = a), E = e) = p(Q|Az = a, E = e), where Q is the query
(e.g., the event X ≥ 1) and E are the (possibly empty) evidence variables. This is because the Az
node has no parents, so it has no incoming edges to cut when we clamp it.
Although the augmented DAG allows us to use standard notation (no explicit do operators) and
inference machinery, the use of “surgical” interventions, which delete incoming edges to a node that
is set to a value, results in a simpler graph, which can simplify many calculations, particularly in the
non-parametric setting (see [Pea09b, p361] for a discussion). It is therefore a useful abstraction, even
if it is less general than the augmented DAG approach.
4.7.4 Counterfactuals
So far we have been focused on predicting the effects of causes, so we can choose the optimal action
(e.g., if I have a headache, I have to decide should I take an aspirin or not). This can be tackled
using standard techniques from Bayesian decision theory, as we have seen (see [Daw00; Daw15; LR19;
Roh21; DM22] for more details).
Now suppose we are interested in the causes of effects. For example, suppose I took the aspirin
and my headache did go away. I might be interested in the counterfactual question “if I had not
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4.7. STRUCTURAL CAUSAL MODELS
Level Activity Questions Examples
1:Association.
p(Y |a)
Seeing How would seeing A
change my belief in Y ?
Someone took aspirin, how
likely is it their headache will
be cured?
2:Intervention.
p(Y |do(a))
Doing What if I do A? If I take aspirin, will my
headache be cured?
3:Counterfactuals.
p(Y
a
|do(a
′
), y′
)
Imagining Was it A that caused
Y ?
Would my headache be cured
had I not taken aspirin?
Table 4.6: Pearl’s causal hierarchy. Adapted from Table 1 of [Pea19].
Y
0
1
U1
Y
1
1
Y1
A1 = 0
θ
Y
0
2
U2
Y
1
2
Y2
A2 = 1
. . .
Figure 4.55: Illustration of the potential outcomes framework as a SCM. The nodes with dashed edges are
unobserved. In this example, for unit 1, we select action A1 = 0 and observe Y1 = Y
0
1 = y1, whereas for unit
2, we select action A2 = 1 and observe Y2 = Y
1
2 = y2.
taken the aspirin, would my headache have gone away anyway?”. This kind of reasoning is crucial for
legal reasoning (see e.g., [DMM17]), as well as for tasks like explainability and fairness.
Counterfactual reasoning requires strictly more assumptions than reasoning about interventions
(see e.g., [DM22]). Indeed, Judea Pearl has proposed what he calls the causal hierarchy [Pea09b;
PGJ16; PM18b], which has three levels of analysis, each more powerful than the last, but each
making stronger assumptions. See Table 4.6 for a summary.
In counterfactual reasoning, we want to answer questions of the type p(Y
a
′
|do(a), y), which is read
as: “what is the probability distribution over outcomes Y if I were to do a
′
, given that I have already
done a and observed outcome y”. (We can also condition on any other evidencee that was observed,
such as covariates x.) The quantity Y
a
′
is often called a potential outcome [Rub74], since it is
the outcome that would occur in a hypothetical world in which you did a
′
instead of a. (Note that
p(Y
a
′
= y) is equivalent to p(Y = y|do(a
′
)), and is an interventional prediction, not a counterfactual
one.)
The assumptions behind the potential outcomes framework can be clearly expressed using a
structural causal model. We illustrate this in Figure 4.55 for a simple case where there are two
possible actions. We see that we have a set of “units”, such as individual patients, indexed by
subscripts. Each unit is associated with a hidden exogeneous random noise source, Ui
, that captures
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license216
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
everything that is unique about that unit. This noise gets deterministically mapped to two potential
outcomes, Y
0
i
and Y
1
i
, depending on which action is taken. For any given unit, we only get to observe
one of the outcomes, namely the one corresponding to the action that was actually chosen. In
Figure 4.55, unit 1 chooses action A1 = 0, so we get to see Y
0
1 = y1, whereas unit 2 chooses action
A2 = 1, so we get to see Y
1
2 = y2. The fact that we cannot simultaneously see both outcomes for the
same unit is called the “fundamental problem of causal inference” [Hol86].
We will assume the noise sources are independent, which is known as the “stable unit treatment
value assumption” or SUTVA. (This would not be true if the treatment on person j could somehow
affect the outcome of person i, e.g., due to spreading disease or information between i and j.) We
also assume that the determinsistic mechanisms that map noise to outcomes are the same across
all units (represented by the shared parameter vector θ in Figure 4.55). We need to make one final
assumption, namely that the exogeneous noise is not affected by our actions. (This is a formalization
of the assumption known as “all else being equal”, or (in legal terms) “ceteris paribus”.)
With the above assumptions, we can predict what the outcome for an individual unit would have
been in the alternative universe where we picked the other action. The procedure is as follows. First
we perform abduction using SCM G, to infer p(Ui
|Ai = a, Yi = yi), which is the posterior over
the latent factors for unit i given the observed evidence in the actual world. Second we perform
intervention, in which we modify the causal mechanisms of G by replacing Ai = a with Ai = a
′
to
get Ga′ . Third we perform prediction, in which we propagate the distribution of the latent factors,
p(Ui
|Ai = a, Yi = yi), through the modified SCM Ga′ to get p(Y
a
′
i
|Ai = a, Yi = yi).
In Figure 4.55, we see that we have two copies of every possible outcome variable, to represent
the set of possible worlds. Of course, we only get to see one such world, based on the actions that
we actually took. More generally, a model in which we “clone” all the deterministic variables, with
the noise being held constant between the two branches of the graph for the same unit, is called a
twin network [Pea09b]. We will see a more practical example in Section 29.12.6, where we discuss
assessing the counterfactual causal impact of an intervention in a time series. (See also [RR11; RR13],
who propose a related formalism known as single world intervention graph or SWIG.)
We see from the above that the potential outcomes framework is mathematically equivalent to
structural causal models, but does not use graphical model notation. This has led to heated debate
between the founders of the two schools of thought.16. The SCM approach is more popular in
computer science (see e.g., [PJS17; Sch19; Sch+21b]), and the PO approach is more popular in
economics (see e.g., [AP09; Imb19]). Modern textbooks on causality usually use both formalisms
(see e.g., [HR20a; Nea20]).
16. The potential outcomes framework is based on the work of Donald Rubin, and others, and is therefore sometimes
called the Rubin causal model (see e.g., https://en.wikipedia.org/wiki/Rubin_causal_model). The structural
causal models framework is based on the work of Judea Pearl and others. See e.g., http://causality.cs.ucla.edu/
blog/index.php/2012/12/03/judea-pearl-on-potential-outcomes/ for a discussion of the two.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20235 Information theory
Machine learning is fundamentally about information processing. But what is information anyway,
and how do we measure it? Ultimately we need a way to quantify the magnitude of an update from
one set of beliefs to another. It turns out that with a relatively short list of desiderata there is a
unique answer: the Kullback-Leibler (KL) divergence (see Section 5.1). We’ll study the properties of
the KL divergence and two special cases: entropy (Section 5.2), and mutual information (Section 5.3).
that are useful enough to merit independent study. We then go on to briefly discuss two main
applications of information theory. The first application is data compression or source coding,
which is the problem of removing redundancy from data so it can be represented more compactly,
either in a lossless way (e.g., ZIP files) or a lossy way (e.g., MP3 files). See Section 5.4 for details.
The second application is error correction or channel coding, which means encoding data in
such a way that it is robust to errors when sent over a noisy channel, such as a telephone line or a
satellite link. See Section 5.5 for details.
It turns out that methods for data compression and error correction both rely on having an accurate
probabilistic model of the data. For compression, a probabilistic model is needed so the sender can
assign shorter codewords to data vectors which occur most often, and hence save space. For error
correction, a probabilistic model is needed so the receiver can infer the most likely source message by
combining the received noisy message with a prior over possible messages.
It is clear that probabilistic machine learning is useful for information theory. However, information
theory is also useful for machine learning. Indeed, we have seen that Bayesian machine learning is
about representing and reducing our uncertainty, and so is fundamentally about information. In
Section 5.6.2, we explore this direction in more detail, where we discuss the information bottleneck.
For more information on information theory, see e.g., [Mac03; CT06].
5.1 KL divergence
This section is written with Alex Alemi.
To discuss information theory, we need some way to measure or quantify information itself. Let’s say
we start with some distribution describing our degrees of belief about a random variable, call it q(x).
We then want to update our degrees of belief to some new distribution p(x), perhaps because we’ve
taken some new measurements or merely thought about the problem a bit longer. What we seek is a
mathematical way to quantify the magnitude of this update, which we’ll denote I[pkq]. What sort
of criteria would be reasonable for such a measure? We discuss this issue below, and then define a
quantity that satisfies these criteria.218
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.1.1 Desiderata
For simplicity, imagine we are describing a distribution over N possible events. In this case, the
probability distribution q(x) consists of N non-negative real numbers that add up to 1. To be even
more concrete, imagine we are describing the random variable representing the suit of the next card
we’ll draw from a deck: S ∈ {♣, ♠, ♥, ♦}. Imagine we initially believe the distributions over suits to
be uniform: q = [ 1
4
,
1
4
,
1
4
,
1
4
]. If our friend told us they removed all of the red cards we could update
to: q
′ = [ 1
2
,
1
2
, 0, 0]. Alternatively, we might believe some diamonds changed into clubs and want to
update to q
′′ = [ 3
8
,
2
8
,
2
8
,
1
8
]. Is there a good way to quantify how much we’ve updated our beliefs?
Which is a larger update: q → q
′ or q → q
′′?
It seems desireable that any useful such measure would satisfy the following properties:
1. continuous in its arguments: If we slightly perturb either our starting or ending distribution,
it should similarly have a small effect on the magnitude of the update. For example: I[pk
1
4 +
ǫ, 1
4
,
1
4
,
1
4 − ǫ] should be close to I[pkq] for small ǫ, where q = [ 1
4
,
1
4
,
1
4
,
1
4
].
2. non-negative: I[pkq] ≥ 0 for all p(x) and q(x). The magnitude of our updates are non-negative.
3. permutation invariant: The magnitude of the update should not depend on the order we choose for
the elements of x. For example, it shouldn’t matter if I list my probabilities for the suits of cards
in the order ♣, ♠, ♥, ♦ or ♣, ♦, ♥, ♠, if I keep the order consistent across all of the distributions,
I should get the same answer. For example: I[a, b, c, dke, f, g, h] = I[a, d, c, bke, h, g, f].
4. monotonic for uniform distributions: While it’s hard to say how large the updates in our beliefs
are in general, there are some special cases for which we have a strong intuition. If our beliefs
update from a uniform distribution on N elements to one that is uniform in N′
elements, the
information gain should be an increasing function of N and a decreasing function of N′
. For
instance changing from a uniform distribution on all four suits [
1
4
,
1
4
,
1
4
,
1
4
] (so N = 4) to only one
suit, such as all clubs, [1, 0, 0, 0] where N′ = 1, is a larger update than if I only updated to the
card being black, [
1
2
,
1
2
, 0, 0] where N′ = 2.
5. satisfy a natural chain rule: So far we’ve been describing our beliefs in what will happen on the next
card draw as a single random variable representing the suit of the next card (S ∈ {♣, ♠, ♥, ♦}).
We could equivalently describe the same physical process in two steps. First we consider the
random variable representing the color of the card (C ∈ {, }), which could be either black
( = {♣, ♠}) or red ( = {♥, ♦}). Then, if we draw a red card we describe our belief that it is ♥
versus ♦. If it was instead black we would assign beliefs to it being ♣ versus ♠. We can convert
any distribution over the four suits into this conditional factorization, for example:
p(S) = 
3
8
,
2
8
,
2
8
,
1
8

(5.1)
becomes
p(C) =

5
8
,
3
8

p({♣, ♠}|C = ) =

3
5
,
2
5

p({♥, ♦}|C = ) =

2
3
,
1
3

. (5.2)
In the same way we could decompose our uniform distribution q. Obviously, for our measure of
information to be of use the magnitude of the update needs to be the same regardless of how we
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.1. KL DIVERGENCE
choose to describe what is ultimately the same physical process. What we need is some way to
relate what would be four different invocations of our information function:
IS ≡ I [p(S)kq(S)] (5.3)
IC ≡ I [p(C)kq(C)] (5.4)
I ≡ I [p({♣, ♠}|C = )kq({♣, ♠}|C = )] (5.5)
I ≡ I [p({♥, ♦}|C = )kq({♥, ♦}|C = )] . (5.6)
Clearly IS should be some function of {IC , I, I}. Our last desideratum is that the way we
measure the magnitude of our updates will have IS be a linear combination of IC , I, I. In
particular, we will require that they combine as a weighted linear combinations, with weights set
by the probability that we would find ourselves in that branch according to the distribution p:
IS = IC + p(C = )I + p(C = )I = IC +
5
8
I +
3
8
I (5.7)
Stating this requirement more generally: If we partition x into two pieces [xL, xR], so that we
can write p(x) = p(xL)p(xR|xL) and similarly for q, the magnitude of the update should be
I[p(x)kq(x)] = I[p(xL)kq(xL)] + Ep(xL)
[I[p(xR|xL)kq(xR|xL)]] . (5.8)
Notice that this requirement breaks the symmetry between our two distributions: The right hand
side asks us to take the expected conditional information gain with respect to the marginal, but
we need to decide which of two marginals to take the expectation with respect to.
5.1.2 The KL divergence uniquely satisfies the desiderata
We will now define a quantity that is the only measure (up to a multiplicative constant) that satisfies
the above desiderata. The Kullback-Leibler divergence or KL divergence, also known as the
information gain or relative entropy, is defined as follows:
DKL (p k q) ,
X
K
k=1
pk log pk
qk
. (5.9)
This naturally extends to continuous distributions:
DKL (p k q) ,
Z
dx p(x) log p(x)
q(x)
. (5.10)
Next we will verify that this definition satisfies all of our desiderata. (The proof that it is the unique
measure which captures these properties can be found in, e.g., [Hob69; Rén61].)
5.1.2.1 Continuity of KL
One of our desiderata was that our measure of information gain should be continuous. The KL
divergence is manifestly continuous in its arguments except potentially when pk or qk is zero. In the
first case, notice that the limit as p → 0 is well behaved:
limp→0
p log p
q
= 0. (5.11)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license220
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Taking this as the definition of the value of the integrand when p = 0 will make it continuous there.
Notice that we do have a problem however if q = 0 in some place that p = 0 6 . Our information
gain requires that our original distribution of beliefs q has some support everywhere the updated
distribution does. Intuitively it would require an infinite amount of information for us to update our
beliefs in some outcome to change from being exactly 0 to some positive value.
5.1.2.2 Non-negativity of KL divergence
In this section, we prove that the KL divergence as defined is always non-negative. We will make use
of Jensen’s inequality, which states that for any convex function f, we have that
f
 Xn
i=1
λixi
!
≤
Xn
i=1
λif(xi) (5.12)
where λi ≥ 0 and Pn
i=1 λi = 1. This can be proved by induction, where the base case with n = 2
follows by definition of convexity.
Theorem 5.1.1. (Information inequality) DKL (p k q) ≥ 0 with equality iff p = q.
Proof. We now prove the theorem, following [CT06, p28]. As we noted in the previous section, the
KL divergence requires special consideration when p(x) or q(x) = 0, the same is true here. Let
A = {x : p(x) > 0} be the support of p(x). Using the convexity of the log function and Jensen’s
inequality, we have that
−DKL (p k q) = −
X
x∈A
p(x) log p(x)
q(x)
=
X
x∈A
p(x) log q(x)
p(x)
(5.13)
≤ log X
x∈A
p(x)
q(x)
p(x)
= log X
x∈A
q(x) (5.14)
≤ log X
x∈X
q(x) = log 1 = 0 (5.15)
Since log(x) is a strictly concave function (− log(x) is convex), we have equality in Equation (5.14) iff
p(x) = cq(x) for some c that tracks the fraction of the whole space X contained in A. We have equality
in Equation (5.15) iff P
x∈A q(x) = P
x∈X q(x) = 1, which implies c = 1. Hence DKL (p k q) = 0 iff
p(x) = q(x) for all x.
The non-negativity of KL divergence often feels as though it’s one of the most useful results in
information theory. It is a good result to keep in your back pocket. Anytime you can rearrange an
expression in terms of KL divergence terms, since those are guaranteed to be non-negative, dropping
them immediately generates a bound.
5.1.2.3 KL divergence is invariant to reparameterizations
We wanted our measure of information to be invariant to permutations of the labels. The discrete
form is manifestly permutation invariant as summations are. The KL divergence actually satisfies a
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.1. KL DIVERGENCE
much stronger property of reparameterization invariance. Namely, we can transform our random
variable through an arbitrary invertible map and it won’t change the value of the KL divergence.
If we transform our random variable from x to some y = f(x) we know that p(x) dx = p(y) dy and
q(x) dx = q(y) dy. Hence the KL divergence remains the same for both random variables:
DKL (p(x) k q(x)) = Z
dx p(x) log p(x)
q(x)
=
Z
dy p(y) log


p(y)



dy
dx



q(y)



dy
dx




 = DKL (p(y) k q(y)). (5.16)
Because of this reparameterization invariance we can rest assured that when we measure the KL
divergence between two distributions we are measuring something about the distributions and not the
way we choose to represent the space in which they are defined. We are therefore free to transform
our data into a convenient basis of our choosing, such as a Fourier bases for images, without affecting
the result.
5.1.2.4 Montonicity for uniform distributions
Consider updating a probability distribution from a uniform distribution on N elements to a uniform
distribution on N′
elements. The KL divergence is:
DKL (p k q) = X
k
1
N′
log
1
N′
1
N
= log N
N′
, (5.17)
or the log of the ratio of the elements before and after the update. This satisfies our monotonocity
requirement.
We can interpret this result as follows: Consider finding an element of a sorted array by means of
bisection. A well designed yes/no question can cut the search space in half. Measured in bits, the
KL divergence tells us how many well designed yes/no questions are required on average to move
from q to p.
5.1.2.5 Chain rule for KL divergence
Here we show that the KL divergence satisfies a natural chain rule:
DKL (p(x, y) k q(x, y)) = Z
dx dy p(x, y) log p(x, y)
q(x, y)
(5.18)
=
Z
dx dy p(x, y)

log p(x)
q(x)
+ log p(y|x)
q(y|x)

(5.19)
= DKL (p(x) k q(x)) + Ep(x)
[DKL (p(y|x) k q(y|x))] . (5.20)
We can rest assured that we can decompose our distributions into their conditionals and the KL
divergences will just add.
As a notational convenience, the conditional KL divergence is defined to be the expected value
of the KL divergence between two conditional distributions:
DKL (p(y|x) k q(y|x)) ,
Z
dx p(x)
Z
dy p(y|x) log p(y|x)
q(y|x)
. (5.21)
This allows us to drop many expectation symbols.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license222
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.1.3 Thinking about KL
In this section, we discuss some qualitative properties of the KL divergence.
5.1.3.1 Units of KL
Above we said that the desiderata we listed determined the KL divergence up to a multiplicative
constant. Because the KL divergence is logarithmic, and logarithms in different bases are the same
up to a multiplicative constant, our choice of the base of the logarithm when we compute the KL
divergence is a choice akin to choosing which units to measure the information in.
If the KL divergence is measured with the base-2 logarithm, it is said to have units of bits, short
for “binary digits”. If measured using the natural logarithm as we normally do for mathematical
convenience, it is said to be measured in nats for “natural units”.
To convert between the systems, we use log2 y =
log y
log 2 . Hence
1 bit = log 2 nats ∼ 0.693 nats (5.22)
1 nat =
1
log 2 bits ∼ 1.44 bits. (5.23)
5.1.3.2 Asymmetry of the KL divergence
The KL divergence is not symmetric in its two arguments. While many find this asymmetry confusing
at first, we can see that the asymmetry stems from our requirement that we have a natural chain
rule. When we decompose the distribution into its conditional, we need to take an expectation with
respect to the variables being conditioned on. In the KL divergence we take this expectation with
respect to the first argument p(x). This breaks the symmetry between the two distributions.
At a more intuitive level, we can see that the information required to move from q to p is in general
different than the information required to move from p to q. For example, consider the KL divergence
between two Bernoulli distributions, the first with the probability of success given by 0.443 and the
second with 0.975:
DKL = 0.975 log 0.975
0.443
+ 0.025 log 0.025
0.557
= 0.692 nats ∼ 1.0 bits. (5.24)
So it takes 1 bit of information to update from a [0.443, 0.557] distribution to a [0.975, 0.025] Bernoulli
distribution. What about the reverse?
DKL = 0.443 log 0.443
0.975
+ 0.557 log 0.557
0.025
= 1.38 nats ∼ 2.0 bits, (5.25)
so it takes two bits, or twice as much information to move the other way. Thus we see that starting
with a distribution that is nearly even and moving to one that is nearly certain takes about 1 bit of
information, or one well designed yes/no question. To instead move us from near certainty in an
outcome to something that is akin to the flip of a coin requires more persuasion.
5.1.3.3 KL as expected weight of evidence
Imagine you have two different hypotheses you wish to select between, which we’ll label P and Q.
You collect some data D. Bayes’ rule tells us how to update our beliefs in the hypotheses being
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.1. KL DIVERGENCE
correct:
Pr(P|D) =
Pr(D|P)
Pr(D)
Pr(P). (5.26)
Normally this requires being able to evaluate the marginal likelihood Pr(D), which is difficult. If we
instead consider the ratio of the probabilities for the two hypotheses:
Pr(P|D)
Pr(Q|D)
=
Pr(D|P)
Pr(D|Q)
Pr(P)
Pr(Q)
, (5.27)
the marginal likelihood drops out. Taking the logarithm of both sides, and identifying the probability
of the data under the model as the likelihood we find:
log Pr(P|D)
Pr(Q|D)
= log p(D)
q(D)
+ log Pr(P)
Pr(Q)
. (5.28)
The posterior log probability ratio for one hypothesis over the other is just our prior log probability
ratio plus a term that I. J. Good called the weight of evidence [Goo85] D for hypothesis P over
Q:
w[P/Q; D] , log p(D)
q(D)
. (5.29)
With this interpretation, the KL divergence is the expected weight of evidence for P over Q given
by each observation, provided P were correct. Thus we see that data will (on average) add rather
than subtract evidence towards the correct hypothesis, since KL divergence is always non-negative in
expectation (see Section 5.1.2.2).
5.1.4 Minimizing KL
In this section, we discuss ways to minimize DKL (p k q) or DKL (q k p) wrt an approximate distribution
q, given a true distribution p.
5.1.4.1 Forwards vs reverse KL
The asymmetry of KL means that finding a q that is close to p by minimizing DKL (p k q) (also
called the inclusive KL or forwards KL) gives different behavior than minimizing DKL (q k p)
(also called the exclusive KL or reverse KL). For example, consider the bimodal distribution p
shown in blue in Figure 5.1, which we approximate with a unimodal Gaussian q.
To prevent DKL (p k q) from becoming infinite, we must have q > 0 whenever p > 0 (i.e., q
must have support everywhere p does), so q tends to cover both modes as it must be nonvanishing
everywhere p is; this is called mode-covering or zero-avoiding behavior (orange curve). By
contrast, to prevent DKL (q k p) from becoming infinite, we must have q = 0 whenever p = 0, which
creates mode-seeking or zero-forcing behavior (green curve).
For an animated visualization (written by Ari Seff) of the difference between these two objectives,
see https://twitter.com/ari_seff/status/1303741288911638530.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license224
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−5 0 5 10 15 20
x
0.0
0.2
P(x)
p
min
q
KL[p; q]
min
q
KL[q; p]
Figure 5.1: Demonstration of the mode-covering or mode-seeking behavior of KL divergence. The original
distribution p (shown in blue) is bimodal. When we minimize DKL (p k q), then q covers the modes of p
(orange). When we minimize DKL (q k p), then q ignores some of the modes of p (green). Generated by
minimize_kl_divergence.ipynb.
−1 −0.8 −0.6 −0.4 −0.2 0 0.2 0.4 0.6 0.8 1
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
(a)
−1 −0.8 −0.6 −0.4 −0.2 0 0.2 0.4 0.6 0.8 1
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
(b)
Figure 5.2: Illustrating forwards vs reverse KL on a symmetric Gaussian. The blue curves are the con￾tours of the true distribution p. The red curves are the contours of a factorized approximation q. (a)
Minimizing DKL (p k q). (b) Minimizing DKL (q k p). Adapted from Figure 10.2 of [Bis06]. Generated by
kl_pq_gauss.ipynb.
5.1.4.2 Moment projection (mode covering)
Suppose we compute q by minimizing the forwards KL:
q = argmin
q
DKL (p k q) (5.30)
This is called M-projection, or moment projection since the optimal q matches the moments of
p, as we show below. The process of computing q is therefore called moment matching.
To see why the optimal q must match the moments of p, let us assume that q is an exponential
family distribution of the form
q(x) = h(x) exp[η
T
T (x) − log Z(η)] (5.31)
where T (x) is the vector of sufficient statistics, and η are the natural parameters. The first order
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.1. KL DIVERGENCE
optimality conditions are as follows:
∂ηiDKL (p k q) = −∂ηi
Z
x
p(x) log q(x) (5.32)
= −∂ηi
Z
x
p(x) log ￾
h(x) exp[η
T
T (x) − log Z(η)]
(5.33)
= −∂ηi
Z
x
p(x)
￾
η
T
T (x) − log Z(η)

(5.34)
= −
Z
x
p(x)Ti(x) + Eq(x)
[Ti(x)] (5.35)
= −Ep(x)
[Ti(x)] + Eq(x)
[Ti(x)] = 0 (5.36)
where in the penultimate line we used the fact that the derivative of the log partition function
yields the expected sufficient statistics, as shown in Equation (2.216). Hence the expected sufficient
statistics (moments of the distribution) must match.
As an example, suppose the true target distribution p is a correlated 2d Gaussian, p(x) =
N (x|µ, Σ) = N (x|µ, Λ
−1
), where
µ =

µ1
µ2

, Σ =

Σ11 Σ12
Σ
T
12 Σ22
Λ =

Λ11 Λ12
Λ
T
12 Λ22
(5.37)
We will approximate this with a distribution q which is a product of two 1d Gaussians, i.e., a Gaussian
with a diagonal covariance matrix:
q(x|m, V) = N (x1|m1, v1)N (x2|m2, v2) (5.38)
If we perform moment matching, the optimal q must therefore have the following form:
q(x) = N (x1|µ1, Σ11)N (x2|µ2, Σ22) (5.39)
In Figure 5.2(a), we show the resulting distribution. We see that q covers (includes) p, but its support
is too broad (under-confidence).
5.1.4.3 Information projection (mode seeking)
Now suppose we compute q by minimizing the reverse KL:
q = argmin
q
DKL (q k p) (5.40)
This is called I-projection, or information projection. This optimization problem is often easier
to compute, since the objective requires taking expectations wrt q, which we can choose to be a
tractable family.
As an example, consider again the case where the true distribution is a full covariance Gaussian,
p(x) = N (x|µ, Λ
−1
), and let the approximation be a diagonal Gaussian, q(x) = N (x|m, diag(v)).
Then one can show (see Supplementary Section 5.1.2) that the optimal variational parameters are
m = µ and vi = Λ
−1
ii . We illustrate this in 2d in Figure 5.2(b). We see that the posterior variance
is too narrow, i.e, the approximate posterior is overconfident. Note, however, that minimizing the
reverse KL does not always result in an overly compact approximation, as explained in [Tur+08].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licen226
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.1.5 Properties of KL
Below are some other useful properties of the KL divergence.
5.1.5.1 Compression lemma
An important general purpose result for the KL divergence is the compression lemma:
Theorem 5.1.2. For any distributions P and Q with a well-defined KL divergence, and for any
scalar function φ defined on the domain of the distributions we have that:
EP [φ] ≤ log EQ

e
φ

+ DKL (P k Q). (5.41)
Proof. We know that the KL divergence between any two distributions is non-negative. Consider a
distribution of the form:
g(x) = q(x)
Z
e
φ(x)
. (5.42)
where the partition function is given by:
Z =
Z
dx q(x)e
φ(x)
. (5.43)
Taking the KL divergence between p(x) and g(x) and rearranging gives the bound:
DKL (P k G) = DKL (P k Q) − EP [φ(x)] + log(Z) ≥ 0. (5.44)
One way to view the compression lemma is that it provides what is termed the Donsker-Varadhan
variational representation of the KL divergence:
DKL (P k Q) = sup
φ
EP [φ(x)] − log EQ
h
e
φ(x)
i
. (5.45)
In the space of all possible functions φ defined on the same domain as the distributions, assuming all
of the values above are finite, the KL divergence is the supremum achieved. For any fixed function
φ(x), the right hand side provides a lower bound on the true KL divergence.
Another use of the compression lemma is that it provides a way to estimate the expectation of
some function with respect to an unknown distribution P. In this spirit, the compression lemma
can be used to power a set of what are known as PAC-Bayes bounds of losses with respect to the
true distribution in terms of measured losses with respect to a finite training set. See for example
Section 17.4.5 or Banerjee [Ban06].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.1. KL DIVERGENCE
5.1.5.2 Data processing inequality for KL
We now show that any processing we do on samples from two different distributions makes their
samples approach one another. This is called the data processing inequality, since it shows that
we cannot increase the information gain from q to p by processing our data and then measuring it.
Theorem 5.1.3. Consider two different distributions p(x) and q(x) combined with a probabilistic
channel t(y|x). If p(y) is the distribution that results from sending samples from p(x) through the
channel t(y|x) and similarly for q(y) we have that:
DKL (p(x) k q(x)) ≥ DKL (p(y) k q(y)) (5.46)
Proof. The proof uses Jensen’s inequality from Section 5.1.2.2 again. Call p(x, y) = p(x)t(y|x) and
q(x, y) = q(x)t(y|x).
DKL (p(x) k q(x)) = Z
dx p(x) log p(x)
q(x)
(5.47)
=
Z
dx Z
dy p(x)t(y|x) log p(x)t(y|x)
q(x)t(y|x)
(5.48)
=
Z
dx Z
dy p(x, y) log p(x, y)
q(x, y)
(5.49)
= −
Z
dy p(y)
Z
dx p(x|y) log q(x, y)
p(x, y)
(5.50)
≥ − Z
dy p(y) log Z
dx p(x|y)
q(x, y)
p(x, y)

(5.51)
= −
Z
dy p(y) log 
q(y)
p(y)
Z
dx q(x|y)

(5.52)
=
Z
dy p(y) log p(y)
q(y)
= DKL (p(y) k q(y)) (5.53)
One way to interpret this result is that any processing done to random samples makes it harder to
tell two distributions apart.
As a special form of processing, we can simply marginalize out a subset of random variables.
Corollary 5.1.1. (Monotonicity of KL divergence)
DKL (p(x, y) k q(x, y)) ≥ DKL (p(x) k q(x)) (5.54)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license228
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Proof. The proof is essentially the same as the one above.
DKL (p(x, y) k q(x, y)) = Z
dx Z
dy p(x, y) log p(x, y)
q(x, y)
(5.55)
= −
Z
dy p(y)
Z
dx p(x|y) log 
q(y)
p(y)
q(x|y)
p(x|y)

(5.56)
≥ − Z
dy p(y) log 
q(y)
p(y)
Z
dx q(x|y)

(5.57)
=
Z
dy p(y) log p(y)
q(y)
= DKL (p(y) k q(y)) (5.58)
(5.59)
One intuitive interpretation of this result is that if you only partially observe random variables, it
is harder to distinguish between two candidate distributions than if you observed all of them.
5.1.6 KL divergence and MLE
Suppose we want to find the distribution q that is as close as possible to p, as measured by KL
divergence:
q
∗ = arg min
q
DKL (p k q) = arg min
q
Z
p(x) log p(x)dx −
Z
p(x) log q(x)dx (5.60)
Now suppose p is the empirical distribution, which puts a probability atom on the observed training
data and zero mass everywhere else:
pD(x) = 1
N
X
N
n=1
δ(x − xn) (5.61)
Using the sifting property of delta functions we get
DKL (pD k q) = −
Z
pD(x) log q(x)dx + C (5.62)
= −
Z
"
1
N
X
n
δ(x − xn)
#
log q(x)dx + C (5.63)
= −
1
N
X
n
log q(xn) + C (5.64)
where C =
R
pD(x)log pD(x) is a constant independent of q.
We can rewrite the above as follows
DKL (pD k q) = Hce(pD, q) − H(pD) (5.65)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.1. KL DIVERGENCE
where
Hce(p, q) , −
X
k
pk log qk (5.66)
is known as the cross entropy. The quantity Hce(pD, q) is the average negative log likelihood
of q evaluated on the training set. Thus we see that minimizing KL divergence to the empirical
distribution is equivalent to maximizing likelihood.
This perspective points out the flaw with likelihood-based training, namely that it puts too
much weight on the training set. In most applications, we do not really believe that the empirical
distribution is a good representation of the true distribution, since it just puts “spikes” on a finite
set of points, and zero density everywhere else. Even if the dataset is large (say 1M images), the
universe from which the data is sampled is usually even larger (e.g., the set of “all natural images”
is much larger than 1M). Thus we need to somehow smooth the empirical distribution by sharing
probability mass between “similar” inputs.
5.1.7 KL divergence and Bayesian inference
Bayesian inference itself can be motivated as the solution to a particular minimization problem of
KL.
Consider a prior set of beliefs described by a joint distribution q(θ, D) = q(θ)q(D|θ), involving
some prior q(θ) and some likelihood q(D|θ). If we happen to observe some particular dataset D0,
how should we update our beliefs? We could search for the joint distribution that is as close as
possible to our prior beliefs but that respects the constraint that we now know the value of the data:
p(θ, D) = argmin DKL (p(θ, D) k q(θ, D)) such that p(D) = δ(D − D0). (5.67)
where δ(D −D0) is a degenerate distribution that puts all its mass on the dataset D that is identically
equal to D0. Writing the KL out in its chain rule form:
DKL (p(θ, D) k q(θ, D)) = DKL (p(D) k q(D)) + DKL (p(θ|D) k q(θ|D)), (5.68)
makes clear that the solution is given by the joint distribution:
p(θ, D) = p(D)p(θ|D) = δ(D − D0)q(θ|D). (5.69)
Our updated beliefs have a marginal over the θ
p(θ) = Z
dD p(θ, D) = Z
dD δ(D − D0)q(θ|D) = q(θ|D = D0), (5.70)
which is just the usual Bayesian posterior from our prior beliefs evaluated at the data we observed.
By contrast, the usual statement of Bayes’ rule is just a trivial observation about the chain rule of
probabilities:
q(θ, D) = q(D)q(θ|D) = q(θ)q(D|θ) =⇒ q(θ|D) = q(D|θ)
q(D)
q(θ). (5.71)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license230
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Notice that this relates the conditional distribution q(θ|D) in terms of q(D|θ), q(θ) and q(D), but
that these are all different ways to write the same distribution. Bayes’ rule does not tell us how we
ought to update our beliefs in light of evidence, for that we need some other principle [Cat+11].
One of the nice things about this interpretation of Bayesian inference is that it naturally generalizes
to other forms of constraints rather than assuming we have observed the data exactly.
If there was some additional measurement error that was well understood, we ought to instead of
pegging out updated beliefs to be a delta function on the observed data, simply peg it to be the well
understood distribution p(D). For example, we might not know the precise value the data takes, but
believe after measuring things that it is a Gaussian distribution with a certain mean and standard
deviation.
Because of the chain rule of KL, this has no effect on our updated conditional distribution over
parameters, which remains the Bayesian posterior: p(θ|D) = q(θ|D). However, this does change our
marginal beliefs about the parameters, which are now:
p(θ) = Z
dD p(D)q(θ|D). (5.72)
This generalization of Bayes’ rule is sometimes called Jeffrey’s conditionalization rule [Cat08].
5.1.8 KL divergence and exponential families
The KL divergence between two exponential family distributions from the same family has a nice
closed form, as we explain below.
Consider p(x) with natural parameter η, base measure h(x) and sufficient statistics T (x):
p(x) = h(x) exp[η
T
T (x) − A(η)] (5.73)
where
A(η) = log Z
h(x) exp(η
T
T (x))dx (5.74)
is the log partition function, a convex function of η.
The KL divergence between two exponential family distributions from the same family is as follows:
DKL (p(x|η1
) k p(x|η2
)) = Eη1

(η1 − η2
)
T
T (x) − A(η1
) + A(η2
)

(5.75)
= (η1 − η2
)
Tµ1 − A(η1
) + A(η2
) (5.76)
where µj , Eηj
[T (x)].
5.1.8.1 Example: KL divergence between two Gaussians
An important example is the KL divergence between two multivariate Gaussian distributions, which
is given by
DKL (N (x|µ1
, Σ1) k N (x|µ2
, Σ2))
=
1
2

tr(Σ
−1
2 Σ1) + (µ2 − µ1
)
TΣ
−1
2
(µ2 − µ1
) − D + log 
det(Σ2)
det(Σ1)
 (5.77)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.1. KL DIVERGENCE
In the scalar case, this becomes
DKL (N (x|µ1, σ1) k N (x|µ2, σ2)) = log σ2
σ1
+
σ
2
1 + (µ1 − µ2)
2
2σ
2
2
−
1
2
(5.78)
5.1.9 Approximating KL divergence using the Fisher information matrix
Let pθ(x) and pθ′ (x) be two distributions, where θ
′ = θ + δ. We can measure how close the second
distribution is to the first in terms their predictive distribution (as opposed to comparing θ and θ
′
in
parameter space) as follows:
DKL (pθ k pθ′ ) = Epθ(x)
[log pθ(x) − log pθ′ (x)] (5.79)
Let us approximate this with a second order Taylor series expansion:
DKL (pθ k pθ′ ) ≈ −δ
TE [∇ log pθ(x)] −
1
2
δ
TE

∇2
log pθ(x)

δ (5.80)
Since the expected score function is zero (from Equation (3.44)), the first term vanishes, so we have
DKL (pθ k pθ′ ) ≈
1
2
δ
TF(θ)δ (5.81)
where F is the FIM
F = −E

∇2
log pθ(x)

= E

(∇ log pθ(x))(∇ log pθ(x))T

(5.82)
Thus we have shown that the KL divergence is approximately equal to the (squared) Mahalanobis
distance using the Fisher information matrix as the metric. This result is the basis of the natural
gradient method discussed in Section 6.4.
5.1.10 Bregman divergence
Let f : Ω → R be a continuously differentiable, strictly convex function defined on a closed convex
set Ω. We define the Bregman divergence associated with f as follows [Bre67]:
Bf (w||v) = f(w) − f(v) − (w − v)
T∇f(v) (5.83)
To understand this, let
ˆfv(w) = f(v) + (w − v)
T∇f(v) (5.84)
be a first order Taylor series approximation to f centered at v. Then the Bregman divergence is the
difference from this linear approximation:
Bf (w||v) = f(w) − ˆfv(w) (5.85)
See Figure 5.3a for an illustration. Since f is convex, we have Bf (w||v) ≥ 0, since ˆfv is a linear
lower bound on f.
Below we mention some important special cases of Bregman divergences.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license232
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
x
f(x)
v w
f
f(v)
f(w)
f(v) + (w − v) · ▽f(v)
Df (wkv)
w − v
(a) (b)
Figure 5.3: (a) Illustration of Bregman divergence. (b) A locally linear approximation to a non-convex
function.
• If f(w) = ||w||2
, then Bf (w||v) = ||w − v||2
is the squared Euclidean distance.
• If f(w) = wTQw, then Bf (w||v) is the squared Mahalanobis distance.
• If w are the natural parameters of an exponential family distribution, and f(w) = log Z(w) is
the log normalizer, then the Bregman divergence is the same as the Kullback-Leibler divergence,
as we show in Section 5.1.10.1.
5.1.10.1 KL is a Bregman divergence
Recall that the log partition function A(η) is a convex function. We can therefore use it to define
the Bregman divergence (Section 5.1.10) between the two distributions, p and q, as follows:
Bf (ηq
||ηp
) = A(ηq
) − A(ηp
) − (ηq − ηp
)
T∇ηpA(ηp
) (5.86)
= A(ηq
) − A(ηp
) − (ηq − ηp
)
TEp [T (x)] (5.87)
= DKL (p k q) (5.88)
where we exploited the fact that the gradient of the log partition function computes the expected
sufficient statistics as shown in Section 2.4.3.
In fact, the KL divergence is the only divergence that is both a Bregman divergence and an
f-divergence (Section 2.7.1) [Ama09].
5.2 Entropy
In this section, we discuss the entropy of a distribution p, which is just a shifted and scaled version
of the KL divergence between the probability distribution and the uniform distribution, as we will
see.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.2. ENTROPY
0.0 0.5 1.0
p(X = 1)
0.0
0.5
1.0
H(X)
Figure 5.4: Entropy of a Bernoulli random variable as a function of θ. The maximum entropy is log2 2 = 1.
Generated by bernoulli_entropy_fig.ipynb.
5.2.1 Definition
The entropy of a discrete random variable X with distribution p over K states is defined by
H (X) , −
X
K
k=1
p(X = k) log p(X = k) = −EX [log p(X)] (5.89)
We can use logarithms to any base, but we commonly use log base 2, in which case the units are
called bits, or log base e, in which case the units are called nats, as we explained in Section 5.1.3.1.
The entropy is equivalent to a constant minus the KL divergence from the uniform distribution:
H (X) = log K − DKL (p(X) k u(X)) (5.90)
DKL (p(X) k u(X)) = X
K
k=1
p(X = k) log p(X = k)
1
K
(5.91)
= log K +
X
K
k=1
p(X = k) log p(X = k) (5.92)
If p is uniform, the KL is zero, and we see that the entropy achieves its maximal value of log K.
For the special case of binary random variables, X ∈ {0, 1}, we can write p(X = 1) = θ and
p(X = 0) = 1 − θ. Hence the entropy becomes
H (X) = −[p(X = 1) log p(X = 1) + p(X = 0) log p(X = 0)] (5.93)
= −[θ log θ + (1 − θ) log(1 − θ)] (5.94)
This is called the binary entropy function, and is also written H (θ). We plot this in Figure 5.4.
We see that the maximum value of 1 bit occurs when the distribution is uniform, θ = 0.5. A fair coin
requires a single yes/no question to determine its state.
5.2.2 Differential entropy for continuous random variables
If X is a continuous random variable with pdf p(x), we define the differential entropy as
h(X) , −
Z
X
dx p(x) log p(x) (5.95)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
assuming this integral exists.
For example, one can show that the entropy of a d-dimensional Gaussian is
h(N (µ, Σ)) = 1
2
log |2πeΣ| =
1
2
log[(2πe)
d
|Σ|] = d
2
+
d
2
log(2π) + 1
2
log |Σ| (5.96)
In the 1d case, this becomes
h(N (µ, σ2
)) = 1
2
log 
2πeσ2

(5.97)
Note that, unlike the discrete case, differential entropy can be negative. This is because pdf’s can
be bigger than 1. For example, suppose X ∼ U(0, a). Then
h(X) = −
Z a
0
dx 1
a
log 1
a
= log a (5.98)
If we set a = 1/8, we have h(X) = log2
(1/8) = −3 bits.
One way to understand differential entropy is to realize that all real-valued quantities can only be
represented to finite precision. It can be shown [CT91, p228] that the entropy of an n-bit quantization
of a continuous random variable X is approximately h(X) + n. For example, suppose X ∼ U(0,
1
8
).
Then in a binary representation of X, the first 3 bits to the right of the binary point must be 0 (since
the number is ≤ 1/8). So to describe X to n bits of accuracy only requires n − 3 bits, which agrees
with h(X) = −3 calculated above.
The continuous entropy also lacks the reparameterization independence of KL divergence (Sec￾tion 5.1.2.3). In particular, if we transform our random variable y = f(x), the entropy transforms.
To see this, note that the change of variables tells us that
p(y) dy = p(x) dx =⇒ p(y) = p(x)




dy
dx




−1
, (5.99)
Thus the continuous entropy transforms as follows:
h(X) = −
Z
dx p(x) log p(x) = h(Y ) −
Z
dy p(y) log




dy
dx




. (5.100)
We pick up a factor in the continuous entropy of the log of the determinant of the Jacobian of the
transformation. This changes the value for the continuous entropy even for simply rescaling the
random variable such as when we change units. For example in Figure 5.5 we show the distribution
of adult human heights (it is bimodal because while both male and female heights are normally
distributed, they differ noticeably). The continous entropy of this distribution depends on the
units it is measured in. If measured in feet, the continuous entropy is 0.43 bits. Intuitively this is
because human heights mostly span less than a foot. If measured in centimeters it is instead 5.4 bits.
There are 30.48 centimeters in a foot, log2 30.48 = 4.9 explaining the difference. If we measured the
continuous entropy of the same distribution measured in meters we would obtain −1.3 bits!
5.2.3 Typical sets
The typical set of a probability distribution is the set whose elements have an information content
that is close to that of the expected information content from random samples from the distribution.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.2. ENTROPY
4.5 5.0 5.5 6.0 6.5 7.0
Height (ft)
140 160 180 200 220
Height (cm)
Density
Figure 5.5: Distribution of adult heights. The continuous entropy of the distribution depends on its units
of measurement. If heights are measured in feet, this distribution has a continuous entropy of 0.43 bits.
If measured in centimeters it’s 5.4 bits. If measured in meters it’s −1.3 bits. Data taken from https:
// ourworldindata. org/ human-height .
More precisely, for a distribution p(x) with support x ∈ X , the ǫ-typical set AN
ǫ ∈ X N for p(x) is
the set of all length N sequences such that
H(p(x)) − ǫ ≤ −
1
N
log p(x1, . . . , xN ) ≤ H(p(x)) + ǫ (5.101)
If we assume p(x1, . . . , xN ) = QN
n=1 p(xn), then we can interpret the term in the middle as the
N-sample empirical estimate of the entropy. The asymptotic equipartition property or AEP
states that this will converge (in probability) to the true entropy as N → ∞ [CT06]. Thus the typical
set has probability close to 1, and is thus a compact summary of what we can expect to be generated
by p(x).
5.2.4 Cross entropy and perplexity
A standard way to measure how close a model q is to a true distribution p is in terms of the KL
divergence (Section 5.1), given by
DKL (p k q) = X
x
p(x) log p(x)
q(x)
= Hce (p, q) − H (p) (5.102)
where Hce (p, q) is the cross entropy
Hce (p, q) = −
X
x
p(x) log q(x) (5.103)
and H (p) = Hce (p, p) is the entropy, which is a constant independent of the model.
In language modeling, it is common to report an alternative performance measure known as the
perplexity. This is defined as
perplexity(p, q) , 2
Hce(p,q)
(5.104)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license236
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We can compute an empirical approximation to the cross entropy as follows. Suppose we approxi￾mate the true distribution with an empirical distribution based on data sampled from p:
pD(x|D) = 1
N
X
N
n=1
I(x = xn) (5.105)
In this case, the cross entropy is given by
H = −
1
N
X
N
n=1
log p(xn) = −
1
N
log Y
N
n=1
p(xn) (5.106)
The corresponding perplexity is given by
perplexity(pD, p) = 2− 1
N log(
QN
n=1 p(xn)) = 2log(QN
n=1 p(xn))− 1
N
(5.107)
= (Y
N
n=1
p(xn))−1/N =
N
vuutY
N
n=1
1
p(xn)
(5.108)
In the case of language models, we usually condition on previous words when predicting the next
word. For example, in a bigram model, we use a second order Markov model of the form p(xn|xn−1).
We define the branching factor of a language model as the number of possible words that can
follow any given word. For example, suppose the model predicts that each word is equally likely,
regardless of context, so p(xn|xn−1) = 1/K, where K is the number of words in the vocabulary. Then
the perplexity is ((1/K)
N )
−1/N = K. If some symbols are more likely than others, and the model
correctly reflects this, its perplexity will be lower than K. However, we have H (p
∗
) ≤ Hce (p
∗
, p), so
we can never reduce the perplexity below 2
− H(p
∗
)
.
5.3 Mutual information
The KL divergence gave us a way to measure how similar two distributions were. How should we
measure how dependent two random variables are? One thing we could do is turn the question of
measuring the dependence of two random variables into a question about the similarity of their
distributions. This gives rise to the notion of mutual information (MI) between two random
variables, which we define below.
5.3.1 Definition
The mutual information between rv’s X and Y is defined as follows:
I(X; Y ) , DKL (p(x, y) k p(x)p(y)) = X
y∈Y
X
x∈X
p(x, y) log p(x, y)
p(x) p(y)
(5.109)
(We write I(X; Y ) instead of I(X, Y ), in case X and/or Y represent sets of variables; for example, we
can write I(X; Y, Z) to represent the MI between X and (Y, Z).) For continuous random variables,
we just replace sums with integrals.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.3. MUTUAL INFORMATION
It is easy to see that MI is always non-negative, even for continuous random variables, since
I(X; Y ) = DKL (p(x, y) k p(x)p(y)) ≥ 0 (5.110)
We achieve the bound of 0 iff p(x, y) = p(x)p(y).
5.3.2 Interpretation
Knowing that the mutual information is a KL divergence between the joint and factored marginal
distributions tells us that the MI measures the information gain if we update from a model that
treats the two variables as independent p(x)p(y) to one that models their true joint density p(x, y).
To gain further insight into the meaning of MI, it helps to re-express it in terms of joint and
conditional entropies, as follows:
I(X; Y ) = H (X) − H (X|Y ) = H (Y ) − H (Y |X) (5.111)
Thus we can interpret the MI between X and Y as the reduction in uncertainty about X after
observing Y , or, by symmetry, the reduction in uncertainty about Y after observing X. Incidentally,
this result gives an alternative proof that conditioning, on average, reduces entropy. In particular, we
have 0 ≤ I(X; Y ) = H (X) − H (X|Y ), and hence H (X|Y ) ≤ H (X).
We can also obtain a different interpretation. One can show that
I(X; Y ) = H (X, Y ) − H (X|Y ) − H (Y |X) (5.112)
Finally, one can show that
I(X; Y ) = H (X) + H (Y ) − H (X, Y ) (5.113)
See Figure 5.6 for a summary of these equations in terms of an information diagram. (Formally,
this is a signed measure mapping set expressions to their information-theoretic counterparts [Yeu91a].)
5.3.3 Data processing inequality
Suppose we have an unknown variable X, and we observe a noisy function of it, call it Y . If we
process the noisy observations in some way to create a new variable Z, it should be intuitively obvious
that we cannot increase the amount of information we have about the unknown quantity, X. This is
known as the data processing inequality. We now state this more formally, and then prove it.
Theorem 5.3.1. Suppose X → Y → Z forms a Markov chain, so that X ⊥ Z|Y . Then I(X; Y ) ≥
I(X;Z).
Proof. By the chain rule for mutual information we can expand the mutual information in two
different ways:
I(X; Y, Z) = I(X;Z) + I(X; Y |Z) (5.114)
= I(X; Y ) + I(X;Z|Y ) (5.115)
Since X ⊥ Z|Y , we have I(X;Z|Y ) = 0, so
I(X;Z) + I(X; Y |Z) = I(X; Y ) (5.116)
Since I(X; Y |Z) ≥ 0, we have I(X; Y ) ≥ I(X;Z). Similarly one can prove that I(Y ;Z) ≥ I(X;Z).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license238
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 5.6: The marginal entropy, joint entropy, conditional entropy, and mutual information represented as
information diagrams. Used with kind permission of Katie Everett.
5.3.4 Sufficient statistics
An important consequence of the DPI is the following. Suppose we have the chain θ → X → s(X).
Then
I(θ; s(X)) ≤ I(θ; X) (5.117)
If this holds with equality, then we say that s(X) is a sufficient statistic of the data X for the
purposes of inferring θ. In this case, we can equivalently write θ → s(X) → X, since we can
reconstruct the data from knowing s(X) just as accurately as from knowing θ.
An example of a sufficient statistic is the data itself, s(X) = X, but this is not very useful, since it
doesn’t summarize the data at all. Hence we define a minimal sufficient statistic s(X) as one
which is sufficient, and which contains no extra information about θ; thus s(X) maximally compresses
the data X without losing information which is relevant to predicting θ. More formally, we say s is a
minimal sufficient statistic for X if s(X) = f(s
′
(X)) for some function f and all sufficient statistics
s
′
(X). We can summarize the situation as follows:
θ → s(X) → s
′
(X) → X (5.118)
Here s
′
(X) takes s(X) and adds redundant information to it, thus creating a one-to-many mapping.
P
For example, a minimal sufficient statistic for a set of N Bernoulli trials is simply N and N1 =
n
I(Xn = 1), i.e., the number of successes. In other words, we don’t need to keep track of the
entire sequence of heads and tails and their ordering, we only need to keep track of the total number
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.3. MUTUAL INFORMATION
of heads and tails. Similarly, for inferring the mean of a Gaussian distribution with known variance
we only need to know the empirical mean and number of samples.
Earlier in Section 5.1.8 we motivated the exponential family of distributions as being the ones that
are minimal in the sense that they contain no other information than constraints on some statistics of
the data. It makes sense then that the statistics used to generate exponential family distributions are
sufficient. It also hints at the more remarkable fact of the Pitman-Koopman-Darmois theorem,
which says that for any distribution whose domain is fixed, it is only the exponential family that
admits sufficient statistics with bounded dimensionality as the number of samples increases [Dia88b].
5.3.5 Multivariate mutual information
There are several ways to generalize the idea of mutual information to a set of random variables as
we discuss below.
5.3.5.1 Total correlation
The simplest way to define multivariate MI is to use the total correlation [Wat60] or multi￾information [SV98], defined as
TC({X1, . . . , XD}) , DKL 
p(x) k
Y
d
p(xd)
!
(5.119)
=
X
x
p(x) log p(x)
QD
d=1 p(xd)
=
X
d
H (xd) − H (x) (5.120)
For example, for 3 variables, this becomes
TC(X, Y, Z) = H (X) + H (Y ) + H (Z) − H (X, Y, Z) (5.121)
where H (X, Y, Z) is the joint entropy
H (X, Y, Z) = −
X
x
X
y
X
z
p(x, y, z) log p(x, y, z) (5.122)
One can show that the multi-information is always non-negative, and is zero iff p(x) = Q
d
p(xd).
However, this means the quantity is non-zero even if only a pair of variables interact. For example, if
p(X, Y, Z) = p(X, Y )p(Z), then the total correlation will be non-zero, even though there is no 3 way
interaction. This motivates the alternative definition in Section 5.3.5.2.
5.3.5.2 Interaction information (co-information)
The conditional mutual information can be used to give an inductive definition of the multivariate
mutual information (MMI) as follows:
I(X1; · · · ; XD) = I(X1; · · · ; XD−1) − I(X1; · · · ; XD−1|XD) (5.123)
This is called the multiple mutual information [Yeu91b], or the co-information [Bel03]. This
definition is equivalent, up to a sign change, to the interaction information [McG54; Han80; JB03;
Bro09].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license240
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 5.7: Illustration of multivariate mutual information between three random variables. From https:
// en. wikipedia. org/ wiki/ Mutual_ information . Used with kind permission of Wikipedia author PAR.
For 3 variables, the MMI is given by
I(X; Y ;Z) = I(X; Y ) − I(X; Y |Z) (5.124)
= I(X;Z) − I(X;Z|Y ) (5.125)
= I(Y ;Z) − I(Y ;Z|X) (5.126)
This can be interpreted as the change in mutual information between two pairs of variables when
conditioning on the third. Note that this quantity is symmetric in its arguments.
By the definition of conditional mutual information, we have
I(X;Z|Y ) = I(Z; X, Y ) − I(Y ;Z) (5.127)
Hence we can rewrite Equation (5.125) as follows:
I(X; Y ;Z) = I(X;Z) + I(Y ;Z) − I(X, Y ;Z) (5.128)
This tells us that the MMI is the difference between how much we learn about Z given X and Y
individually vs jointly (see also Section 5.3.5.3).
The 3-way MMI is illustrated in the information diagram in Figure 5.7. The way to interpret such
diagrams when we have multiple variables is as follows: the area of a shaded area that includes circles
A, B, C, . . . and excludes circles F, G, H, . . . represents I(A; B; C; . . . |F, G, H, . . .); if B = C = ∅, this
is just H(A|F, G, H, . . .); if F = G = H = ∅, this is just I(A; B; C, . . .).
5.3.5.3 Synergy and redundancy
The MMI is I(X; Y ;Z) = I(X;Z) + I(Y ;Z) − I(X, Y ;Z). We see that this can be positive, zero,
or negative. If some of the information about Z that is provided by X is also provided by Y , then
there is some redundancy between X and Y (wrt Z). In this case, I(X;Z) + I(Y ;Z) > I(X, Y ;Z),
so (from Equation (5.128)) we see that the MMI will be positive. If, by contrast, we learn more
about Z when we see X and Y together, we say there is some synergy between them. In this case,
I(X;Z) + I(Y ;Z) < I(X, Y ;Z), so the MMI will be negative.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.3. MUTUAL INFORMATION
5.3.5.4 MMI and causality
The sign of the MMI can be used to distinguish between different kinds of directed graphical models,
which can sometimes be interpreted causally (see Chapter 36 for a general discussion of causality).
For example, consider a model of the form X ← Z → Y , where Z is a “cause” of X and Y . For
example, suppose X represents the event it is raining, Y represents the event that the sky is dark,
and Z represents the event that the sky is cloudy. Conditioning on the common cause Z renders
the children X and Y independent, since if I know it is cloudy, noticing that the sky is dark does
not change my beliefs about whether it will rain or not. Consequently I(X; Y |Z) ≤ I(X; Y ), so
I(X; Y ;Z) ≥ 0.
Now consider the case where Z is a common effect, X → Z ← Y . In this case, conditioning on
Z makes X and Y dependent, due to the explaining away phenomenon (see Section 4.2.4.2). For
example, if X and Y are independent random bits, and Z is the XOR of X and Y , then observing
Z = 1 means that p(X 6= Y |Z = 1) = 1, so X and Y are now dependent (information-theoretically,
not causally), even though they were a priori independent. Consequently I(X; Y |Z) ≥ I(X; Y ), so
I(X; Y ;Z) ≤ 0.
Finally, consider a Markov chain, X → Y → Z. We have I(X;Z|Y ) ≤ I(X;Z) and so the MMI
must be positive.
5.3.5.5 MMI and entropy
We can also write the MMI in terms of entropies. Specifically, we know that
I(X; Y ) = H (X) + H (Y ) − H (X, Y ) (5.129)
and
I(X; Y |Z) = H (X, Z) + H (Y, Z) − H (Z) − H (X, Y, Z) (5.130)
Hence we can rewrite Equation (5.124) as follows:
I(X; Y ;Z) = [H (X) + H (Y ) + H (Z)] − [H (X, Y ) + H (X, Z) + H (Y, Z)] + H (X, Y, Z) (5.131)
Contrast this to Equation (5.121).
More generally, we have
I(X1, . . . , XD) = −
X
T ⊆{1,...,D}
(−1)|T | H (T ) (5.132)
For sets of size 1, 2, and 3 this expands as follows:
I1 = H1 (5.133)
I12 = H1 + H2 − H12 (5.134)
I123 = H1 + H2 + H3 − H12 − H13 − H23 + H123 (5.135)
We can use the Möbius inversion formula to derive the following dual relationship:
H (S) = −
X
T ⊆S
(−1)|T | I(T ) (5.136)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license242
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
for sets of variables S.
Using the chain rule for entropy, we can also derive the following expression for the 3-way MMI:
I(X; Y ;Z) = H (Z) − H (Z|X) − H (Z|Y ) + H (Z|X, Y ) (5.137)
5.3.6 Variational bounds on mutual information
In this section, we discuss methods for computing upper and lower bounds on MI that use variational
approximations to the intractable distributions. This can be useful for representation learning
(Chapter 32). This approach was first suggested in [BA03]. For a more detailed overview of
variational bounds on mutual information, see Poole et al. [Poo+19b].
5.3.6.1 Upper bound
Suppose that the joint p(x, y) is intractable to evaluate, but that we can sample from p(x) and
evaluate the conditional distribution p(y|x). Furthermore, suppose we approximate p(y) by q(y).
Then we can compute an upper bound on the MI as follows:
I(x; y) = Ep(x,y)

log p(y|x)q(y)
p(y)q(y)

(5.138)
= Ep(x,y)

log p(y|x)
q(y)

− DKL (p(y) k q(y)) (5.139)
≤ Ep(x)

Ep(y|x)

log p(y|x)
q(y)
 (5.140)
= Ep(x)
[DKL (p(y|x) k q(y))] (5.141)
This bound is tight if q(y) = p(y).
What’s happening here is that I(Y ; X) = H (Y ) − H (Y |X) and we’ve assumed we know p(y|x)
and so can estimate H (Y |X) well. While we don’t know H (Y ), we can upper bound it using some
model q(y). Our model can never do better than p(y) itself (the non-negativity of KL), so our
entropy estimate errs too large, and hence our MI estimate will be an upper bound.
5.3.6.2 BA lower bound
Suppose that the joint p(x, y) is intractable to evaluate, but that we can evaluate p(x). Furthermore,
suppose we approximate p(x|y) by q(x|y). Then we can derive the following variational lower bound
on the mutual information:
I(x; y) = Ep(x,y)

log p(x|y)
p(x)

(5.142)
= Ep(x,y)

log q(x|y)
p(x)

+ Ep(y)
[DKL (p(x|y) k q(x|y))] (5.143)
≥ Ep(x,y)

log q(x|y)
p(x)

= Ep(x,y)
[log q(x|y)] + h(x) (5.144)
where h(x) is the differential entropy of x. This is called the BA lower bound, after the authors
Barber and Agakov [BA03].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.3. MUTUAL INFORMATION
5.3.6.3 NWJ lower bound
The BA lower bound requires a tractable normalized distribution q(x|y) that we can evaluate
pointwise. If we reparameterize this distribution in a clever way, we can generate a lower bound that
does not require a normalized distribution. Let’s write:
q(x|y) = p(x)e
f(x,y)
Z(y)
(5.145)
with Z(y) = Ep(x)

e
f(x,y)

the normalization constant or partition function. Plugging this into the
BA lower bound above we obtain:
Ep(x,y)

log p(x)e
f(x,y)
p(x)Z(y)

= Ep(x,y)
[f(x, y)] − Ep(y)
[log Z(y)] (5.146)
= Ep(x,y)
[f(x, y)] − Ep(y)
h
log Ep(x)
h
e
f(x,y)
ii (5.147)
, IDV (X; Y ). (5.148)
This is the Donsker-Varadhan lower bound [DV75].
We can construct a more tractable version of this by using the fact that the log function can be
upper bounded by a straight line using
log x ≤
x
a
+ log a − 1 (5.149)
If we set a = e, we get
I(X; Y ) ≥ Ep(x,y)
[f(x, y)] − e
−1Ep(y)Z(y) , INW J (X; Y ) (5.150)
This is called the NWJ lower bound (after the authors of Nguyen, Wainwright, and Jordan
[NWJ10a]), or the f-GAN KL [NCT16a], or the MINE-f score [Bel+18].
5.3.6.4 InfoNCE lower bound
If we instead explore a multi-sample extension to the DV bound above, we can generate the following
lower bound (see [Poo+19b] for the derivation):
INCE = E
"
1
K
X
K
i=1
log e
f(xi,yi)
1
K
PK
j=1 e
f(xi,yj )
#
(5.151)
= log K − E


1
K
X
K
i=1
log

1 +X
K
j6=i
e
f(xi,yj )−f(xi,yi)



 (5.152)
where the expectation is over paired samples from the joint p(X, Y ). The quantity in Equation (5.152)
is called the InfoNCE estimate, and was proposed in [OLV18a; Hen+19a]. (NCE stands for “noise
contrastive estimation”, and is discussed in Section 24.4.)
The intuition here is that mutual information is a divergence between the joint p(x, y) and the
product of the marginals, p(x)p(y). In other words, mutual information is a measurement of how
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license244
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
words
documents
10 20 30 40 50 60 70 80 90 100
100
200
300
400
500
600
700
800
900
1000
Figure 5.8: Subset of size 16242 x 100 of the 20-newsgroups data. We only show 1000 rows, for clarity. Each
row is a document (represented as a bag-of-words bit vector), each column is a word. The red lines separate
the 4 classes, which are (in descending order) comp, rec, sci, talk (these are the titles of USENET groups).
We can see that there are subsets of words whose presence or absence is indicative of the class. The data is
available from http: // cs. nyu. edu/ ~roweis/ data. html . Generated by newsgroups_visualize.ipynb.
Figure 5.9: Part of a relevance network constructed from the 20-newsgroup data. data shown in Figure 5.8.
We show edges whose mutual information is greater than or equal to 20% of the maximum pairwise MI.
For clarity, the graph has been cropped, so we only show a subset of the nodes and edges. Generated by
relevance_network_newsgroup_demo.ipynb.
distinct sampling pairs jointly is from sampling xs and ys independently. The InfoNCE bound in
Equation (5.152) provides a lower bound on the true mutual information by attempting to train a
model to distinguish between these two situations.
Although this is a valid lower bound, we may need to use a large batch size K to estimate the
MI if the MI is large, since INCE ≤ log K. (Recently [SE20a] proposed to use a multi-label classifier,
rather than a multi-class classifier, to overcome this limitation.)
5.3.7 Relevance networks
If we have a set of related variables, we can compute a relevance network, in which we add an i−j
edge if the pairwise mutual information I(Xi
; Xj ) is above some threshold. In the Gaussian case,
I(Xi
; Xj ) = −
1
2
log(1 − ρ
2
ij ), where ρij is the correlation coefficient, and the resulting graph is called
a covariance graph (Section 4.5.5.1). However, we can also apply it to discrete random variables.
Relevance networks are quite popular in systems biology [Mar+06], where they are used to visualize
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.4. DATA COMPRESSION (SOURCE CODING)
the interaction between genes. But they can also be applied to other kinds of datasets. For example,
Figure 5.9 visualizes the MI between words in the 20-newsgroup dataset shown in Figure 5.8. The
results seem intuitively reasonable.
However, relevance networks suffer from a major problem: the graphs are usually very dense, since
most variables are dependent on most other variables, even after thresholding the MIs. For example,
suppose X1 directly influences X2 which directly influences X3 (e.g., these form components of a
signalling cascade, X1 − X2 − X3). Then X1 has non-zero MI with X3 (and vice versa), so there
will be a 1 − 3 edge as well as the 1 − 2 and 2 − 3 edges; thus the graph may be fully connected,
depending on the threshold.
A solution to this is to learn a probablistic graphical model, which represents conditional in￾dependence, rather than dependence. In the chain example, there will not be a 1 − 3 edge, since
X1 ⊥ X3|X2. Consequently graphical models are usually much sparser than relevance networks. See
Chapter 30 for details.
5.4 Data compression (source coding)
Data compression, also known as source coding, is at the heart of information theory. It is also
related to probabilistic machine learning. The reason for this is as follows: if we can model the
probability of different kinds of data samples, then we can assign short code words to the most
frequently occuring ones, reserving longer encodings for the less frequent ones. This is similar to
the situation in natural language, where common words (such as “a”, “the”, “and”) are generally
much shorter than rare words. Thus the ability to compress data requires an ability to discover
the underlying patterns, and their relative frequencies, in the data. This has led Marcus Hutter
to propose that compression be used as an objective way to measure performance towards general
purpose AI. More precisely, he is offering 50,000 Euros to anyone who can compress the first 100MB
of (English) Wikipedia better than some baseline. This is known as the Hutter prize.
1
In this section, we give a brief summary of some of the key ideas in data compression. For details,
see e.g., [Mac03; CT06; YMT22].
5.4.1 Lossless compression
Discrete data, such as natural language, can always be compressed in such a way that we can uniquely
recover the original data. This is called lossless compression.
Claude Shannon proved that the expected number of bits needed to losslessly encode some data
coming from distribution p is at least H (p). This is known as the source coding theorem. Achieving
this lower bound requires coming up with good probability models, as well as good ways to design
codes based on those models. Because of the non-negativity of the KL divergence, Hce(p, q) ≥ H(p),
so if we use any model q other than the true model p to compress the data, it will take some excess
bits. The number of excess bits is exactly DKL (p k q).
Common techniques for realizing lossless codes include Huffman coding, arithmetic coding, and
asymmetric numeral systems [Dud13]. The input to these algorithms is a probability distribution
over strings (which is where ML comes in). This distribution is often represented using a latent
variable model (see e.g., [TBB19; KAH19]).
1. For details, see http://prize.hutter1.net.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license246
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.4.2 Lossy compression and the rate-distortion tradeoff
To encode real-valued signals, such as images and sound, as a digital signal, we first have to quantize
the signal into a sequence of symbols. A simple way to do this is to use vector quantization. We can
then compress this discrete sequence of symbols using lossless coding methods. However, when we
uncompress, we lose some information. Hence this approach is called lossy compression.
In this section, we quantify this tradeoff between the size of the representation (number of symbols
we use), and the resulting error. We will use the terminology of the variational information bottleneck
discussed in Section 5.6.2 (except here we are in the unsupervised setting). In particular, we assume
we have a stochastic encoder p(z|x), a stochastic decoder d(x|z) and a prior marginal m(z).
We define the distortion of an encoder-decoder pair (as in Section 5.6.2) as follows:
D = −
Z
dx p(x)
Z
dz e(z|x) log d(x|z) (5.153)
If the decoder is a deterministic model plus Gaussian noise, d(x|z) = N (x|fd(z), σ2
), and the encoder
is deterministic, e(z|x) = δ(z − fe(x)), then this becomes
D =
1
σ
2
Ep(x)

||fd(fe(x)) − x||2

(5.154)
This is just the expected reconstruction error that occurs if we (deterministically) encode and
then decode the data using fe and fd.
We define the rate of our model as follows:
R =
Z
dx p(x)
Z
dz e(z|x) log e(z|x)
m(z)
(5.155)
= Ep(x)
[DKL (e(z|x) k m(z))] (5.156)
=
Z
dx
Z
dz p(x, z) log p(x, z)
p(x)m(z)
≥ I(x, z) (5.157)
This is just the average KL between our encoding distribution and the marginal. If we use m(z) to
design an optimal code, then the rate is the excess number of bits we need to pay to encode our data
using m(z) rather than the true aggregate posterior p(z) = R
dx p(x)e(z|x).
There is a fundamental tradeoff between the rate and distortion. To see why, note that a trivial
encoding scheme would set e(z|x) = δ(z − x), which simply uses x as its own best representation.
This would incur 0 distortion (and hence maximize the likelihood), but it would incur a high rate,
since each e(z|x) distribution would be unique, and far from m(z). In other words, there would be
no compression. Conversely, if e(z|x) = δ(z − 0), the encoder would ignore the input. In this case,
the rate would be 0, but the distortion would be high.
We can characterize the tradeoff more precisely using the variational lower and upper bounds on
the mutual information from Section 5.3.6. From that section, we know that
H − D ≤ I(x; z) ≤ R (5.158)
where H is the (differential) entropy
H = −
Z
dx p(x) log p(x) (5.159)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.4. DATA COMPRESSION (SOURCE CODING)
Figure 5.10: Illustration of the rate-distortion tradeoff. See text for details. From Figure 1 of [Ale+18]. Used
with kind permission of Alex Alemi.
For discrete data, all probabilities are bounded above by 1, and hence H ≥ 0 and D ≥ 0. In addition,
the rate is always non-negative, R ≥ 0, since it is the average of a KL divergence. (This is true for
either discrete or continuous encodings z.) Consequently, we can plot the set of achievable values of
R and D as shown in Figure 5.10. This is known as a rate distortion curve.
The bottom horizontal line corresponds to the zero distortion setting, D = 0, in which we can
perfectly encode and decode our data. This can be achieved by using the trivial encoder where
e(z|x) = δ(z − x). Shannon’s source coding theorem tells us that the minimum number of bits we
need to use to encode data in this setting is the entropy of the data, so R ≥ H when D = 0. If we
use a suboptimal marginal distribution m(z) for coding, we will increase the rate without affecting
the distortion.
The left vertical line corresponds to the zero rate setting, R = 0, in which the latent code is
independent of z. In this case, the decoder d(x|z) is independent of z. However, we can still learn a
joint probability model p(x) which does not use latent variables, e.g., this could be an autoregressive
model. The minimal distortion such a model could achieve is again the entropy of the data, D ≥ H.
The black diagonal line illustrates solutions that satisfy D = H − R, where the upper and lower
bounds are tight. In practice, we cannot achieve points on the diagonal, since that requires the
bounds to be tight, and therefore assumes our models e(z|x) and d(x|z) are perfect. This is called
the “non-parametric limit”. In the finite data setting, we will always incur additional error, so the
RD plot will trace a curve which is shifted up, as shown in Figure 5.10.
We can generate different solutions along this curve by minimizing the following objective:
J = D + βR =
Z
dx p(x)
Z
dz e(z|x)

− log d(x|z) + β log e(z|x)
m(z)

(5.160)
If we set β = 1, and define q(z|x) = e(z|x), p(x|z) = d(x|z), and p(z) = m(z), this exactly matches
the VAE objective in Section 21.2. To see this, note that the ELBO from Section 10.1.1.2 can be
written as
Ł = −(D + R) = Ep(x)

Ee(z|x)
[log d(x|z)] − Ee(z|x)

log e(z|x)
m(z)
 (5.161)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license248
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
which we recognize as the expected reconstruction error minus the KL term DKL (e(z|x) k m(z)).
If we allow β 6= 1, we recover the β-VAE objective discussed in Section 21.3.1. Note, however, that
the β-VAE model cannot distinguish between different solutions on the diagonal line, all of which have
β = 1. This is because all such models have the same marginal likelihood (and hence same ELBO),
although they differ radically in terms of whether they learn an interesting latent representation or
not. Thus likelihood is not a sufficient metric for comparing the quality of unsupervised representation
learning methods, as discussed in Section 21.3.1.
For further discussion on the inherent conflict between rate, distortion, and perception, see [BM19].
For techniques for evaluating rate distortion curves for models see [HCG20].
5.4.3 Bits back coding
In the previous section we penalized the rate of our code using the average KL divergence, Ep(x)
[R(x)],
where
R(x) ,
Z
dz p(z|x) log p(z|x)
m(z)
= Hce(p(z|x), m(z)) − H(p(z|x)). (5.162)
The first term is the cross entropy, which is the expected number of bits we need to encode x; the
second term is the entropy, which is the minimum number of bits. Thus we are penalizing the excess
number of bits required to communicate the code to a receiver. How come we don’t have to “pay for”
the actual (total) number of bits we use, which is the cross entropy?
The reason is that we could in principle get the bits needed by the optimal code given back to
us; this is called bits back coding [HC93; FH97]. The argument goes as follows. Imagine Alice is
trying to (losslessly) communicate some data, such as an image x, to Bob. Before they went their
separate ways, both Alice and Bob decided to share their encoder p(z|x), marginal m(z) and decoder
distributions d(x|z). To communicate an image, Alice will use a two part code. First, she will
sample a code z ∼ p(z|x) from her encoder, and communicate that to Bob over a channel designed
to efficiently encode samples from the marginal m(z); this costs − log2 m(z) bits. Next Alice will
use her decoder d(x|z) to compute the residual error, and losslessly send that to Bob at the cost of
− log2 d(x|z) bits. The expected total number of bits required here is what we naively expected:
Ep(z|x)
[− log2 d(x|z) − log2 m(z)] = D + Hce(p(z|x), m(z)). (5.163)
We see that this is the distortion plus cross entropy, not distortion plus rate. So how do we get the
bits back, to convert the cross entropy to a rate term?
The trick is that Bob actually receives more information than we suspected. Bob can use the code
z and the residual error to perfectly reconstruct x. However, Bob also knows what specific code Alice
sent, z, as well as what encoder she used, p(z|x). When Alice drew the sample code z ∼ p(z|x), she
had to use some kind of entropy source in order to generate the random sample. Suppose she did it
by picking words sequentially from a compressed copy of Moby Dick, in order to generate a stream
of random bits. On Bob’s end, he can reverse engineer all of the sampling bits, and thus recover the
compressed copy of Moby Dick! Thus Alice can use the extra randomness in the choice of z to share
more information.
While in the original formulation the bits back argument was largely theoretical, offering a thought
experiment for why we should penalize our models with the KL instead of the cross entropy, recently
several practical real world algorithms have been developed that actually achieve the bits back goal.
These include [HPHL19; AT20; TBB19; YBM20; HLA19; FHHL20].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.5. ERROR-CORRECTING CODES (CHANNEL CODING)
x1 x2 x3
y1 y2 y3
(a)
000
001
010
011
100
101
110
111
0.00
0.05
0.10
0.15
0.20
0.25
0.30
p(x|y=1,0,0)
(b)
Figure 5.11: (a) A simple error-correcting code DPGM. xi are the sent bits, yi are the received bits. x3 is an
even parity check bit computed from x1 and x2. (b) Posterior over codewords given that y = (1, 0, 0); the
probability of a bit flip is 0.2. Generated by error_correcting_code_demo.ipynb.
5.5 Error-correcting codes (channel coding)
The idea behind error correcting codes is to add redundancy to a signal x (which is the result of
encoding the original data), such that when it is sent over to the receiver via a noisy transmission
line (such as a cell phone connection), the receiver can recover from any corruptions that might occur
to the signal. This is called channel coding.
In more detail, let x ∈ {0, 1}
m be the source message, where m is called the block length. Let
y be the result of sending x over a noisy channel. This is a corrupted version of the message.
For example, each message bit may get flipped independently with probability α, in which case
p(y|x) = Qm
i=1 p(yi
|xi), where p(yi
|xi = 0) = [1 − α, α] and p(yi
|xi = 1) = [α, 1 − α]. Alternatively,
we may add Gaussian noise, so p(yi
|xi = b) = N (yi
|µb, σ2
). The receiver’s goal is to infer the true
message from the noisy observations, i.e., to compute argmaxx p(x|y).
A common way to increase the chance of being able to recover the original signal is to add parity
check bits to it before sending it. These are deterministic functions of the original signal, which
specify if the sum of the input bits is odd or even. This provides a form of redundancy, so that if
one bit is corrupted, we can still infer its value, assuming the other bits are not flipped. (This is
reasonable since we assume the bits are corrupted independently at random, so it is less likely that
multiple bits are flipped than just one bit.)
For example, suppose we have two original message bits, and we add one parity bit. This can
be modeled using a directed graphical model as shown in Figure 5.11(a). This graph encodes the
following joint probability distribution:
p(x, y) = p(x1)p(x2)p(x3|x1, x2)
Y
3
i=1
p(yi
|xi) (5.164)
The priors p(x1) and p(x2) are uniform. The conditional term p(x3|x1, x2) is deterministic, and
computes the parity of (x1, x2). In particular, we have p(x3 = 1|x1, x2) = 1 if the total number of 1s
in the block x1:2 is odd. The likelihood terms p(yi
|xi) represent a bit flipping noisy channel model,
with noise level α = 0.2.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license250
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Suppose we observe y = (1, 0, 0). We know that this cannot be what the sender sent, since this
violates the parity constraint (if x1 = 1 then we know x3 = 1). Instead, the 3 posterior modes for x
are 000 (first bit was flipped), 110 (second bit was flipped), and 101 (third bit was flipped). The
only other configuration with non-zero support in the posterior is 011, which corresponds to the
much less likely hypothesis that three bits were flipped (see Figure 5.11(b)). All other hypotheses
(001, 010, and 100) are inconsistent with the deterministic method used to create codewords. (See
Section 9.3.3.2 for further discussion of this point.)
In practice, we use more complex coding schemes that are more efficient, in the sense that they
add less redundant bits to the message, but still guarantee that errors can be corrected. For details,
see Section 9.4.8.
5.6 The information bottleneck
In this section, we discuss discriminative models p(y|x) that use a stochastic bottleneck between the
input x and the output y to prevent overfitting, and improve robustness and calibration.
5.6.1 Vanilla IB
We say that z is a representation of x if z is a (possibly stochastic) function of x, and hence can
be described by the conditional p(z|x). We say that a representation z of x is sufficient for task y
if y ⊥ x|z, or equivalently, if I(z; y) = I(x; y), i.e., H (y|z) = H (y|x). We say that a representation
is a minimal sufficient statistic if z is sufficient and there is no other z with smaller I(z; x) value.
Thus we would like to find a representation z that maximizes I(z; y) while minimizing I(z; x). That
is, we would like to optimize the following objective:
min β I(z; x) − I(z; y) (5.165)
where β ≥ 0, and we optimize wrt the distributions p(z|x) and p(y|z). This is called the information
bottleneck principle [TPB99]. This generalizes the concept of minimal sufficient statistic to take
into account that there is a tradeoff between sufficiency and minimality, which is captured by the
Lagrange multiplier β > 0.
This principle is illustrated in Figure 5.12. We assume Z is a function of X, but is independent
of Y , i.e., we assume the graphical model Z ← X ↔ Y . This corresponds to the following joint
distribution:
p(x, y, z) = p(z|x)p(y|x)p(x) (5.166)
Thus Z can capture any amount of information about X that it wants, but cannot contain information
that is unique to Y , as illustrated in Figure 5.12a. The optimal representation only captures
information about X that is useful for Y ; to prevent us “wasting capacity” and fitting irrelevant
details of the input, Z should also minimize information about X, as shown in Figure 5.12b.
If all the random variables are discrete, and z = e(x) is a deterministic function of x, then the
algorithm of [TPB99] can be used to minimize the IB objective in Section 5.6. The objective can
also be solved analytically if all variables are jointly Gaussian [Che+05] (the resulting method can be
viewed as a form of supervised PCA). But in general, it is intractable to solve this problem exactly.
We discuss a tractable approximation in Section 5.6.2. (More details can be found in e.g., [SZ22].)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.6. THE INFORMATION BOTTLENECK
(a) (b)
Figure 5.12: Information diagrams for information bottleneck. (a) Z can contain any amount of information
about X (whether it useful for predicting Y or not), but it cannot contain information about Y that is not
shared with X. (b) The optimal representation for Z maximizes I(Z, Y ) and minimizes I(Z, X). Used with
kind permission of Katie Everett.
5.6.2 Variational IB
In this section, we derive a variational upper bound on Equation (5.165), leveraging ideas from
Section 5.3.6. This is called the variational IB or VIB method [Ale+16]. The key trick will be to
use the non-negativity of the KL divergence to write
Z
dx p(x) log p(x) ≥
Z
dx p(x) log q(x) (5.167)
for any distribution q. (Note that both p and q may be conditioned on other variables.)
To explain the method in more detail, let us define the following notation. Let e(z|x) = p(z|x)
represent the encoder, b(z|y) ≈ p(z|y) represent the backwards encoder, d(y|z) ≈ p(y|z) represent
the classifier (decoder), and m(z) ≈ p(z) represent the marginal. (Note that we get to choose
p(z|x), but the other distributions are derived by approximations of the corresponding marginals
and conditionals of the exact joint p(x, y, z).) Also, let h·i represent expectations wrt the relevant
terms from the p(x, y, z) joint.
With this notation, we can derive a lower bound on I(z; y) as follows:
I(z; y) = Z
dydz p(y, z) log p(y, z)
p(y)p(z)
(5.168)
=
Z
dydz p(y, z) log p(y|z) −
Z
dydz p(y, z) log p(y) (5.169)
=
Z
dydz p(z)p(y|z) log p(y|z) − const (5.170)
≥
Z
dydz p(y, z) log d(y|z) (5.171)
= hlog d(y|z)i (5.172)
where we exploited the fact that H (p(y)) is a constant that is independent of our representation.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license252
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Note that we can approximate the expections by sampling from
p(y, z) = Z
dx p(x)p(y|x)p(z|x) = Z
dx p(x, y)e(z|x) (5.173)
This is just the empirical distribution “pushed through” the encoder.
Similarly, we can derive an upper bound on I(z; x) as follows:
I(z; x) = Z
dzdx p(x, z) log p(z, x)
p(x)p(z)
(5.174)
=
Z
dzdx p(x, z) log p(z|x) −
Z
dz p(z) log p(z) (5.175)
≤
Z
dzdx p(x, z) log p(z|x) −
Z
dz p(z) log m(z) (5.176)
=
Z
dzdx p(x, z) log e(z|x)
m(z)
(5.177)
= hlog e(z|x)i − hlog m(z)i (5.178)
Note that we can approximate the expectations by sampling from p(x, z) = p(x)p(z|x).
Putting it altogether, we get the following upper bound on the IB objective:
β I(x; z) − I(z; y) ≤ β (hlog e(z|x)i − hlog m(z)i) − hlog d(y|z)i (5.179)
Thus the VIB objective is
LVIB = β
￾
EpD(x)e(z|x)
[log e(z|x) − log m(z)]
− EpD(x)e(z|x)d(y|z)
[log d(y|z)] (5.180)
= −EpD(x)e(z|x)d(y|z)
[log d(y|z)] + βEpD(x)
[DKL (e(z|x) k m(z))] (5.181)
We can now take stochastic gradients of this objective and minimize it (wrt the parameters of the
encoder, decoder, and marginal) using SGD. (We assume the distributions are reparameterizable,
as discussed in Section 6.3.5.) For the encoder e(z|x), we often use a conditional Gaussian, and
for the decoder d(y|z), we often use a softmax classifier. For the marginal, m(z), we should use
a flexible model, such as a mixture of Gaussians, since it needs to approximate the aggregated
posterior p(z) = R
dzp(x)e(z|x), which is a mixture of N Gaussians (assuming p(x) is an empirical
distribution with N samples, and e(z|x) is a Gaussian).
We illustrate this in Figure 5.13, where we fit the an MLP model to MNIST. We use a 2d bottleneck
layer before passing to the softmax. In panel a, we show the embedding learned by a determinisic
encoder. We see that each image gets mapped to a point, and there is little overlap between classes,
or between instances. In panels b-c, we show the embedding learned by a stochastic encoder. Each
image gets mapped to a Gaussian distribution, we show the mean and the covariance separately. The
classes are still well separated, but individual instances of a class are no longer distinguishable, since
such information is not relevant for prediction purposes.
5.6.3 Conditional entropy bottleneck
The IB tries to maximize I(Z; Y ) while minimizing I(Z; X). We can write this objective as
min I(x; z) − λ I(y; z) (5.182)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.6. THE INFORMATION BOTTLENECK
−5 0 5
−5
0
5
(a)
−2 0 2
−1
0
1
(b)
−1 0 1
−1
0
1
(c)
Figure 5.13: 2d embeddings of MNIST digits created by an MLP classifier. (a) Deterministic model. (b-c)
VIB model, means and covariances. Generated by vib_demo.ipynb. Used with kind permission of Alex Alemi.
Figure 5.14: Conditional entropy bottleneck (CEB) chooses a representation Z that maximizes I(Z, Y ) and
minimizes I(X, Z|Y ). Used with kind permission of Katie Everett.
for λ ≥ 0. However, we see from the information diagram in Figure 5.12b that I(Z; X) contains some
information that is relevant to Y . A sensible alternative objective is to minimizes the residual mutual
information, I(X;Z|Y ). This gives rise to the following objective:
min I(x; z|y) − λ
′
I(y; z) (5.183)
for λ
′ ≥ 0. This is known as the conditional entropy bottleck or CEB [Fis20]. See Figure 5.14
for an illustration.
Since I(x; z|y) = I(x; z)−I(y; z), we see that the CEB is equivalent to standard IB with λ
′ = λ+ 1.
However, it is easier to upper bound I(x; z|y) than I(x; z), since we are conditioning on y, which
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license254
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
provides information about z. In particular, by leveraging p(z|x, y) = p(z|x) we have
I(x; z|y) = I(x; z) − I(y; z) (5.184)
= H(z) − H(z|x) − [H(z) − H(z|y)] (5.185)
= − H(z|x) + H(z|y) (5.186)
=
Z
dzdx p(x, z) log p(z|x) −
Z
dzdy p(z, y) log p(z|y) (5.187)
≤
Z
dzdx p(x, z) log e(z|x) −
Z
dzdy p(z, y) log b(z|y) (5.188)
= hlog e(z|x)i − hlog b(z|y)i (5.189)
Putting it altogether, we get the final CEB objective:
min β (hlog e(z|x)i − hlog b(z|y)i) − hlog d(y|z)i (5.190)
Note that it is generally easier to learn the conditional backwards encoder b(z|y) than the
unconditional marginal m(z). Also, we know that the tightest upper bound occurs when I(x; z|y) =
I(x; z) − I(y; z) = 0. The corresponding value of β corresponds to an optimal representation. By
contrast, it is not clear how to measure distance from optimality when using IB.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20236 Optimization
6.1 Introduction
In this chapter, we consider solving optimization problems of various forms. Abstractly these can
all be written as
θ
∗ ∈ argmin
θ∈Θ
L(θ) (6.1)
where L : Θ → R is the objective or loss function, and Θ is the parameter space we are optimizing
over. However, this abstraction hides many details, such as whether the problem is constrained
or unconstrained, discrete or continuous, convex or non-convex, etc. In the prequel to this book,
[Mur22], we discussed some simple optimization algorithms for some common problems that arise in
machine learning. In this chapter, we discuss some more advanced methods. For more details on
optimization, please consult some of the many excellent textbooks, such as [KW19b; BV04; NW06;
Ber15; Ber16] as well as various review articles, such as [BCN18; Sun+19b; PPS18; Pey20].
6.2 Automatic differentiation
This section is written by Roy Frostig.
This section is concerned with computing (partial) derivatives of complicated functions in an automatic
manner. By “complicated” we mean those expressed as a composition of an arbitrary number of more
basic operations, such as in deep neural networks. This task is known as automatic differentiation
(AD), or autodiff. AD is an essential component in optimization and deep learning, and is also
used in several other fields across science and engineering. See e.g., Baydin et al. [Bay+15] for a
review focused on machine learning and Griewank and Walther [GW08] for a classical textbook.
6.2.1 Differentiation in functional form
Before covering automatic differentiation, it is useful to review the mathematics of differentiation.
We will use a particular functional notation for partial derivatives, rather than the typical one used
throughout much of this book. We will refer to the latter as the named variable notation for the
moment. Named variable notation relies on associating function arguments with names. For instance,
given a function f : R
2 → R, the partial derivative of f with respect to its first scalar argument, at a256
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
point a = (a1, a2), might be written:
∂f
∂x1




x=a
(6.2)
This notation is not entirely self-contained. It refers to a name x = (x1, x2), implicit or inferred from
context, suggesting the argument of f. An alternative expression is:
∂
∂a1
f(a1, a2) (6.3)
where now a1 serves both as an argument name (or a symbol in an expression) and as a particular
evaluation point. Tracking names can become an increasingly complicated endeavor as we compose
many functions together, each possibly taking several arguments.
A functional notation instead defines derivatives as operators on functions. If a function has
multiple arguments, they are identified by position rather than by name, alleviating the need for
auxiliary variable definitions. Some of the following definitions draw on those in Spivak’s Calculus
on Manifolds [Spi71] and in Sussman and Wisdom’s Functional Differential Geometry [SW13], and
generally appear more regularly in accounts of differential calculus and geometry. These texts are
recommended for a more formal treatment, and a more mathematically general view, of the material
briefly covered in this section.
Beside notation, we will rely on some basic multivariable calculus concepts. This includes the
notion of (partial) derivatives, the differential or Jacobian of a function at a point, its role as a linear
approximation local to the point, and various properties of linear maps, matrices, and transposition.
We will focus on a finite-dimensional setting and write {e1, . . . , en} for the standard basis in R
n.
Linear and multilinear functions. We use F : R
n ⊸ R
m to denote a function F : R
n → R
m
that is linear, and by F[x] its application to x ∈ R
n. Recall that such a linear map corresponds
to a matrix in R
m×n whose columns are F[e1], . . . , F[en]; both interpretations will prove useful.
Conveniently, function composition and matrix multiplication expressions look similar: to compose
two linear maps F and G we can write F ◦ G or, barely abusing notation, consider the matrix F G.
Every linear map F : R
n ⊸ R
m has a transpose F : R
m ⊸ R
n, which is another linear map identified
with transposing the corresponding matrix.
Repeatedly using the linear arrow symbol, we can denote by:
T : R
n ⊸ · · · ⊸ R
n
| {z }
k times
⊸ R
m (6.4)
a multilinear, or more specifically k-linear, map:
T : R
n × · · · × R
n
| {z }
k times
→ R
m (6.5)
which corresponds to an array (or tensor) in R
m×n×···×n. We denote by T[x1, . . . , xk] ∈ R
m the
application of such a k-linear map to vectors x1, . . . , xk ∈ R
n.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.2. AUTOMATIC DIFFERENTIATION
The derivative operator. For an open set U ⊂ R
n and a differentiable function f : U → R
m,
denote its derivative function:
∂f : U → (R
n ⊸ R
m) (6.6)
or equivalently ∂f : U → R
m×n. This function maps a point x ∈ U to the Jacobian of all partial
derivatives evaluated at x. The symbol ∂ itself denotes the derivative operator, a function mapping
functions to their derivative functions. When m = 1, the map ∂f(x) recovers the standard gradient
∇f(x) at any x ∈ U, by considering the matrix view of the former. Indeed, the nabla symbol ∇
is sometimes described as an operator as well, such that ∇f is a function. When n = m = 1, the
Jacobian is scalar-valued, and ∂f is the familiar derivative f
′
.
In the expression ∂f(x)[v], we will sometimes refer to the argument x as the linearization point
for the Jacobian, and to v as the perturbation. We call the map:
(x, v) 7→ ∂f(x)[v] (6.7)
over linearization points x ∈ U and input perturbations v ∈ R
n the Jacobian-vector product
(JVP). We similarly call its transpose:
(x,u) 7→ ∂f(x)
T
[u] (6.8)
over linearization points x ∈ U and output perturbations u ∈ R
m the vector-Jacobian product
(VJP).
Thinking about maps instead of matrices can help us define higher-order derivatives recursively, as
we proceed to do below. It separately suggests how the action of a Jacobian is commonly written
in code. When we consider writing ∂f(x) in a program for a fixed x, we often implement it as
a function that carries out multiplication by the Jacobian matrix, i.e., v 7→ ∂f(x)[v], instead of
explicitly representing it as a matrix of numbers in memory. Going a step further, for that matter,
we often implement ∂f as an entire JVP at once, i.e., over any linearization point x and perturbation
v. As a toy example with scalars, consider the cosine:
(x, v) 7→ ∂ cos(x)v = −v sin(x) (6.9)
If we express this at once in code, we can, say, avoid computing sin(x) whenever v = 0.
1
Higher-order derivatives. Suppose the function f above remains arbitrarily differentiable over
its domain U ⊂ R
n. To take another derivative, we write:
∂
2
f : U → (R
n ⊸ R
n ⊸ R
m) (6.10)
where ∂
2f(x) is a bilinear map representing all second-order partial derivatives. In named variable
notation, one might write ∂f(x)
∂xi∂xj
to refer to ∂
2f(x)[ei
, ej ], for example.
1. This example ignores that such an optimization might be done (best) by a compiler. Then again, for more complex
examples, implementing (x, v) 7→ ∂f(x)[v] as a single subroutine can help guide compiler optimizations all the same.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license258
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The second derivative function ∂
2f can be treated coherently as the outcome of applying the
derivative operator twice. That is, it makes sense to say that ∂
2 = ∂ ◦ ∂. This observation extends
recursively to cover arbitrary higher-order derivatives. For k ≥ 1:
∂
k
f : U → (R
n ⊸ . . . ⊸ R
n
| {z }
k times
⊸ R
m) (6.11)
is such that ∂
kf(x) is a k-linear map.
With m = 1, the map ∂
2f(x) corresponds to the Hessian matrix at any x ∈ U. Although Jacobians
and Hessians suffice to make sense of many machine learning techniques, arbitrary higher-order
derivatives are not hard to come by either (e.g., [Kel+20]). As an example, they appear when writing
down something as basic as a function’s Taylor series approximation, which we can express with our
derivative operator as:
f(x + v) ≈ f(x) + ∂f(x)[v] + 1
2!∂
2
f(x)[v, v] + · · · +
1
k!
∂
k
f(x)[v, . . . , v] (6.12)
Multiple inputs. Now consider a function of two arguments:
g : U × V → R
m . (6.13)
where U ⊂ R
n1 and V ⊂ R
n2
. For our purposes, a product domain like U × V mainly serves to
suggest a convenient partitioning of a function’s input components. It is isomorphic to a subset of
R
n1+n2
, corresponding to a single-input function. The latter tells us how the derivative functions of
g ought to look, based on previous definitions, and we will swap between the two views with little
warning. Multiple inputs tend to arise in the context of computational circuits and programs: many
functions in code are written to accept multiple arguments, and many basic operations (such as +)
do the same.
With multiple inputs, we can denote by ∂ig the derivative function with respect to the i’th
argument:
∂1g : R
n1 × R
n2 → (R
n1 ⊸ R
m), and (6.14)
∂2g : R
n1 × R
n2 → (R
n2 ⊸ R
m). (6.15)
Under the matrix view, the function ∂1g maps a pair of points x ∈ R
n1 and y ∈ R
n2 to the matrix
of all partial derivatives of g with respect to its first argument, evaluated at (x, y). We take ∂g with
no subscript to simply mean the concatenation of ∂1g and ∂2g:
∂g : R
n1 × R
n2 → (R
n1 × R
n2 ⊸ R
m) (6.16)
where, for every linearization point (x, y) ∈ U × V and perturbations x˙ ∈ R
n1
, y˙ ∈ R
n2
:
∂g(x, y)[x˙ , y˙ ] = ∂1g(x, y)[x˙ ] + ∂2g(x, y)[y˙ ] . (6.17)
Alternatively, taking the matrix view:
∂g(x, y) = ￾
∂1g(x, y) ∂2g(x, y)

. (6.18)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.2. AUTOMATIC DIFFERENTIATION
This convention will simplify our chain rule statement below. When n1 = n2 = m = 1, both
sub-matrices are scalar, and ∂g1(x, y) recovers the partial derivative that might otherwise be written
in named variable notation as:
∂
∂xg(x, y). (6.19)
However, the expression ∂g1 bears a meaning on its own (as a function) whereas the expression ∂g
∂x
may be ambiguous without further context. Again composing operators lets us write higher-order
derivatives. For instance, ∂2∂1g(x, y) ∈ R
m×n1×n2
, and if m = 1, the Hessian of g at (x, y) is:

∂1∂1g(x, y) ∂1∂2g(x, y)
∂2∂1g(x, y) ∂2∂2g(x, y)

. (6.20)
Composition and fan-out. If f = g ◦ h for some h : R
n → R
p and g : R
p → R
m, then the chain
rule of calculus observes that:
∂f(x) = ∂g(h(x)) ◦ ∂h(x) for all x ∈ R
n
(6.21)
How does this interact with our notation for multi-argument functions? For one, it can lead us to
consider expressions with fan-out, where several sub-expressions are functions of the same input.
For instance, assume two functions a : R
n → R
m1 and b : R
n → R
m2
, and that:
f(x) = g(a(x), b(x)) (6.22)
for some function g. Abbreviating h(x) = (a(x), b(x)) so that f(x) = g(h(x)), Equations (6.16)
and (6.21) tell us that:
∂f(x) = ∂g(h(x)) ◦ ∂h(x) (6.23)
= ∂1g(a(x), b(x)) ◦ ∂a(x) + ∂2g(a(x), b(x)) ◦ ∂b(x) (6.24)
Note that + is meant pointwise here. It also follows from the above that if instead:
f(x, y) = g(a(x), b(y)) (6.25)
in other words, if we write multiple arguments but exhibit no fan-out, then:
∂1f(x, y) = ∂1g(a(x), b(y)) ◦ ∂a(x), and (6.26)
∂2f(x, y) = ∂2g(a(x), b(y)) ◦ ∂b(y) (6.27)
Composition and fan-out rules for derivatives are what let us break down a complex derivative
calculation into simpler ones. This is what automatic differentiation techniques rely on when
processing the sort of elaborate numerical computations that turn up in modern machine learning
and numerical programming.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license260
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.2.2 Differentiating chains, circuits, and programs
The purpose of automatic differentiation is to compute derivatives of arbitrary functions provided as
input. Given a function f : U ⊂ R
n → R
m and a linearization point x ∈ U, AD computes either:
• the JVP ∂f(x)[v] for an input perturbation v ∈ R
n, or
• the VJP ∂f(x)
T[u] for an output perturbation u ∈ R
m.
In other words, JVPs and VJPs capture the two essential tasks of AD.2
Deciding what functions f to handle as input, and how to represent them, is perhaps the most
load-bearing aspect of this setup. Over what language of functions should we operate? By a language,
we mean some formal way of describing functions by composing a set of basic primitive operations. For
primitives, we can think of various differentiable array operations (elementwise arithmetic, reductions,
contractions, indexing and slicing, concatenation, etc.), but we will largely consider primitives and
their derivatives as a given, and focus on how elaborately we can compose them. AD becomes
increasingly challenging with increasingly expressive languages. Considering this, we introduce it in
stages.
6.2.2.1 Chain compositions and the chain rule
To start, take only functions that are chain compositions of basic operations. Chains are a
convenient class of function representations because derivatives decompose along the same structure
according to the aptly-named chain rule.
As a toy example, consider f : R
n → R
m composed of three operations in sequence:
f = c ◦ b ◦ a (6.28)
By the chain rule, its derivatives are given by
∂f(x) = ∂c(b(a(x))) ◦ ∂b(a(x)) ◦ ∂a(x) (6.29)
Now consider the JVP against an input perturbation v ∈ R
n:
∂f(x)[v] = ∂c(b(a(x))) [∂b(a(x)) [∂a(x)[v]]] (6.30)
This expression’s bracketing highlights a right-to-left evaluation order that corresponds to forward￾mode automatic differentiation. Namely, to carry out this JVP, it makes sense to compute
prefixes of the original chain:
x, a(x), b(a(x)) (6.31)
alongside the partial JVPs, because each is then immediately used as a subsequent linearization
point, respectively:
∂a(x), ∂b(a(x)), ∂c(b(a(x))) (6.32)
Extending this idea to arbitrary chain compositions gives Algorithm 6.1.
2. Materalizing the Jacobian as a numerical array, as is commonly required in an optimization context, is a special
case of computing a JVP or VJP against the standard basis vectors in Rn or Rm respectively.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.2. AUTOMATIC DIFFERENTIATION
Algorithm 6.1: Forward-mode automatic differentiation (JVP) on chains
1 input: f : R
n → R
m as a chain composition f = fT ◦ · · · ◦ f1
2 input: linearization point x ∈ R
n and input perturbation v ∈ R
n
3 x0, v0 := x, v
4 for t := 1, . . . , T do
5 xt := ft(xt−1)
6 vt := ∂ft(xt−1)[vt−1]
7 output: xT , equal to f(x)
8 output: vT , equal to ∂f(x)[v]
By contrast, we can transpose Equation (6.29) to consider a VJP against an output perturbation
u ∈ R
m:
∂f(x)
T
[u] = ∂a(x)
T

∂b(a(x))T

∂c(b(a(x)))T
[u]
 (6.33)
Transposition reverses the Jacobian maps relative to their order in Equation (6.29), and now the
bracketed evaluation corresponds to reverse-mode automatic differentiation. To carry out this
VJP, we can compute the original chain prefixes x, a(x), and b(a(x)) first, and then read them in
reverse as successive linearization points:
∂c(b(a(x)))T
, ∂b(a(x))T
, ∂a(x)
T
(6.34)
Extending this idea to arbitrary chain compositions gives Algorithm 6.2.
Algorithm 6.2: Reverse-mode automatic differentiation (VJP) on chains
1 input: f : R
n → R
m as a chain composition f = fT ◦ · · · ◦ f1
2 input: linearization point x ∈ R
n and output perturbation u ∈ R
m
3 x0 := x
4 for t := 1, . . . , T do
5 xt := ft(xt−1)
6 uT := u
7 for t := T, . . . , 1 do
8 ut−1 := ∂ft(xt−1)
T[ut]
9 output: xT , equal to f(x)
10 output: u0, equal to ∂f(x)
T[u]
Although chain compositions impose a very specific structure, they already capture some deep
neural network models, such as multi-layer perceptrons (provided matrix multiplication is a primitive
operation), as covered in this book’s prequel [Mur22, Ch.13].
Reverse-mode AD is faster than forward-mode when the output is scalar valued (as often arises
in deep learning, where the output is a loss function). However, reverse-mode AD stores all chain
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license262
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
x
a
b
c
f
(a)
x
a x1 x2
b
c
f{b,c}
(b)
Figure 6.1: A circuit for a function f over three primitives, and its decomposition into two circuits without
fan-out. Input nodes are drawn in green.
prefixes before its backwards traversal, so it consumes more memory than forward-mode. There
are ways to combat this memory requirement in special-case scenarios, such as when the chained
operations are each reversible [MDA15; Gom+17; KKL20]. One can also trade off memory for
computation by discarding some prefixes and re-computing them as needed.
6.2.2.2 From chains to circuits
When primitives can accept multiple inputs, we can naturally extend chains to circuits — directed
acyclic graphs over primitive operations, sometimes also called computation graphs. To set up for
this section, we will distinguish between (1) input nodes of a circuit, which symbolize a function’s
arguments, and (2) primitive nodes, each of which is labeled by a primitive operation. We assume
that input nodes have no incoming edges and (without loss of generality) exactly one outgoing edge
each, and that the graph has exactly one sink node. The overall function of the circuit is composition
of operations from the input nodes to the sink, where the output of each operation is input to others
according to its outgoing edges.
What made AD work in Section 6.2.2.1 is the fact that derivatives decompose along chains thanks
to the aptly-named chain rule. When moving from chains to directed acyclic graphs, do we need
some sort of “graph rule” in order to decompose our calculation along the circuit’s structure? Circuits
introduce two new features: fan-in and fan-out. In graphical terms, fan-in simply refers to multiple
edges incoming to a node, and fan-out refers to multiple edges outgoing.
What do these mean in functional terms? Fan-in happens when a primitive operation accepts
multiple arguments. We observed in Section 6.2.1 that multiple arguments can be treated as one, and
how the chain rule then applies. Fan-out requires slightly more care, specifically for reverse-mode
differentiation.
The gist of an answer can be illustrated with a small example. Consider the circuit in Figure 6.1a.
The operation a precedes b and c topologically, with an outgoing edge to each of both. We can cut a
away from {b, c} to produce two new circuits, shown in Figure 6.1b. The first corresponds to a and
the second corresponds to the remaining computation, given by:
f{b,c}(x1, x2) = c(x1, b(x2)). (6.35)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.2. AUTOMATIC DIFFERENTIATION
We can recover the complete function f from a and f{b,c} with the help of a function dup given by:
dup(x) = (x, x) ≡

I
I

x (6.36)
so that f can be written as a chain composition:
f = f{b,c} ◦ dup ◦ a . (6.37)
The circuit for f{b,c} contains no fan-out, and composition rules such as Equation (6.25) tell us its
derivatives in terms of b, c, and their derivatives, all via the chain rule. Meanwhile, the chain rule
applied to Equation (6.37) says that:
∂f(x) = ∂f{b,c}(dup(a(x))) ◦ ∂ dup(a(x)) ◦ ∂a(x) (6.38)
= ∂f{b,c}(a(x), a(x)) ◦

I
I

◦ ∂a(x). (6.39)
The above expression suggests calculating a JVP of f by right-to-left evaluation. It is similar to
the JVP calculation suggested by Equation (6.30), but with a duplication operation ￾
I I
T
in the
middle that arises from the Jacobian of dup.
Transposing the derivative of f at x:
∂f(x)
T = ∂a(x)
T
◦
￾
I I
◦ ∂f{b,c}(a(x), a(x))T
. (6.40)
Considering right-to-left evaluation, this too is similar to the VJP calculation suggested by Equa￾tion (6.33), but with a summation operation ￾
I I
in the middle that arises from the transposed
Jacobian of dup. The lesson of using dup in this small example is that, more generally, in order to
handle fan-out in reverse mode AD, we can process operations in topological order — first forward
and then in reverse — and then sum partial VJPs along multiple outgoing edges.
Algorithm 6.3: Foward-mode circuit differentiation (JVP)
1 input: f : R
n → R
m composing f1, . . . , fT in topological order, where f1 is identity
2 input: linearization point x ∈ R
n and perturbation v ∈ R
n
3 x1, v1 := x, v
4 for t := 2, . . . , T do
5 let [q1, . . . , qr] = Pa(t)
6 xt := ft(xq1
, . . . , xqr
)
7 vt := Pr
i=1 ∂ift(xq1
, . . . , xqr
)[vqi
]
8 output: xT , equal to f(x)
9 output: vT , equal to ∂f(x)[v]
Algorithms 6.3 and 6.4 give a complete description of forward- and reverse-mode differentiation
on circuits. For brevity they assume a single argument to the entire circuit function. Nodes are
indexed 1, . . . , T. The first is the input node, and the remaining T − 1 are labeled by their operation
f2, . . . , fT . We take f1 to be the identity. For each t, if ft takes k arguments, let Pa(t) be the ordered
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND lice264
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Algorithm 6.4: Reverse-mode circuit differentiation (VJP)
1 input: f : R
n → R
m composing f1, . . . , fT in topological order, where f1, fT are identity
2 input: linearization point x ∈ R
n and perturbation u ∈ R
m
3 x1 := x
4 for t := 2, . . . , T do
5 let [q1, . . . , qr] = Pa(t)
6 xt := ft(xq1
, . . . , xqr
)
7 u(T −1)→T := u
8 for t := T − 1, . . . , 2 do
9 let [q1, . . . , qr] = Pa(t)
10 u
′
t
:= P
c∈Ch(t) ut→c
11 uqi→t := ∂ift(xq1
, . . . , xqr
)
Tu
′
t
for i = 1, . . . , r
12 output: xT , equal to f(x)
13 output: u1→2, equal to ∂f(x)
Tu
list of k indices of its parent nodes (possibly containing duplicates, due to fan-out), and let Ch(t) be
the indices of its children (again possibly duplicate). Algorithm 6.4 takes a few more conventions:
that fT is the identity, that node T has T − 1 as its only parent, and that the child of node 1 is node
2.
Fan-out is a feature of graphs, but arguably not an essential feature of functions. One can always
remove all fan-out from a circuit representation by duplicating nodes. Our interest in fan-out is
precisely to avoid this, allowing for an efficient representation and, in turn, efficient memory use in
Algorithms 6.3 and 6.4.
Reverse-mode AD on circuits has appeared under various names and formulations over the years.
The algorithm is precisely the backpropagation algorithm in neural networks, a term introduced
in the 1980s [RHW86b; RHW86a], and has separately come up in the context of control theory
and sensitivity, as summarized in historical notes by Goodfellow, Bengio, and Courville [GBC16,
Section 6.6].
6.2.2.3 From circuits to programs
Graphs are useful for introducing AD algorithms, and they might align well enough with neural
network applications. But computer scientists have spent decades formalizing and studying various
“languages for expressing functions compositionally”. Simply put, this is what programming languages
are for! Can we automatically differentiate numerical functions expressed in, say, Python, Haskell,
or some variant of the lambda calculus? These offer a far more widespread — and intuitively more
expressive — way to describe an input function.3
In the previous sections, our approach to AD became more complex as we allowed for more
complex graph structure. Something similar happens when we introduce grammatical constructs in a
3. In Python, what the language calls a “function” does not always describe a pure function of the arguments listed
in its syntactic definition; its behavior may rely on side effects or global state, as allowed by the language. Here, we
specifically mean a Python function that is pure and functional. JAX’s documentation details this restriction [Bra+18].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.3. STOCHASTIC OPTIMIZATION
programming language. How do we adapt AD to handle a language with loops, conditionals, and
recursive calls? What about parallel programming constructs? We have partial answers to questions
like these today, although they invite a deeper dive into language details such as type systems and
implementation concerns [Yu+18; Inn20; Pas+21b].
One example language construct that we already know how to handle, due to Section 6.2.2.2,
is a standard let expression. In languages with a means of name or variable binding, multiple
appearances of the same variable are analogous to fan-out in a circuit. Figure 6.1a corresponds to a
function f that we could write in a functional language as:
f(x) =
let ax = a(x)
in c(ax, b(ax))
in which ax indeed appears twice after it is bound.
Understanding the interaction between language capacity and automatic differentiability is an
ongoing topic of computer science research [PS08a; AP19; Vyt+19; BMP19; MP21]. In the meantime,
functional languages have proven quite effective in recent AD systems, both widely-used and experi￾mental. Systems such as JAX, Dex, and others are designed around pure functional programming
models, and internally rely on functional program representations for differentiation [Mac+15; BPS16;
Sha+19; FJL18; Bra+18; Mac+19; Dex; Fro+21; Pas+21a].
6.3 Stochastic optimization
In this section, we consider optimization of stochastic objectives of the form
L(θ) = Eqθ(z)
h
L˜(θ, z)
i
(6.41)
where θ are the parameters we are optimizing, and z is a random variable, such as an external noise.
6.3.1 Stochastic gradient descent
Suppose we have a way of computing an unbiased estimate gt of the gradient of the objective function,
i.e.,
E [gt] = ∇θL(θ)|θt
(6.42)
Then we can use this inside of a gradient descent procedure:
θt+1 = θt − ηtgt (6.43)
where ηt is the learning rate or step size. This is called stochastic gradient descent or SGD.
6.3.1.1 Choosing the step size
When using SGD, we need to be careful in how we choose the learning rate in order to achieve
convergence. Rather than choosing a single constant learning rate, we can use a learning rate
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license266
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 20 40 60 80 100
0.75
0.80
0.85
0.90
0.95
1.00
piecewise constant
(a)
0 20 40 60 80 100
0.0
0.2
0.4
0.6
0.8
1.0
exponential decay
(b)
0 20 40 60 80 100
0.2
0.4
0.6
0.8
1.0
polynomial decay
(c)
Figure 6.2: Illustration of some common learning rate schedules. (a) Piecewise constant. (b) Exponential
decay. (c) Polynomial decay. Generated by learning_rate_plot.ipynb.
schedule, in which we adjust the step size over time. Theoretically, a sufficient condition for SGD
to achieve convergence is if the learning rate schedule satisfies the Robbins-Monro conditions:
ηt → 0,
P∞
t=1 η
2
P t
∞
t=1 ηt
→ 0 (6.44)
Some common examples of learning rate schedules are listed below:
ηt = ηi
if ti ≤ t ≤ ti+1 piecewise constant (6.45)
ηt = η0e
−λt exponential decay (6.46)
ηt = η0(βt + 1)−α polynomial decay (6.47)
In the piecewise constant schedule, ti are a set of time points at which we adjust the learning rate
to a specified value. For example, we may set ηi = η0γ
i
, which reduces the initial learning rate by
a factor of γ for each threshold (or milestone) that we pass. Figure 6.2a illustrates this for η0 = 1
and γ = 0.9. This is called step decay. Sometimes the threshold times are computed adaptively,
by estimating when the train or validation loss has plateaued; this is called reduce-on-plateau.
Exponential decay is typically too fast, as illustrated in Figure 6.2b. A common choice is polynomial
decay, with α = 0.5 and β = 1, as illustrated in Figure 6.2c; this corresponds to a square-root
schedule, ηt = η0 √
1
t+1 . For more details, see [Mur22, Sec 8.4.3].
6.3.1.2 Variance reduction
SGD can be slow to converge because it relies on a stochastic estimate of the gradient. Various
methods have been proposed for reducing the variance of the parameter estimates generated at each
step, which can speedup convergence. For more details, see [Mur22, Sec 8.4.5].
6.3.1.3 Preconditioned SGD
In many cases, the gradient magnitudes can be very different along each dimension, corresponding
to the loss surface being steep along some directions and shallow along others, similar to a valley
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.3. STOCHASTIC OPTIMIZATION
floor. In such cases, one can get faster convergence by scaling the gradient vector by a conditioning
matrix Ct as follows:
θt+1 = θt − ηtCtgt (6.48)
This is called preconditioned SGD. For more details, see [Mur22, Sec 8.4.6].
6.3.2 SGD for optimizing a finite-sum objective
In the simplest case, the distribution used to compute the expectation, qθ(z), does not depend on the
parameters being optimized, θ. In this case, we can push gradients inside the expectation operator,
and then use Monte Carlo sampling for z to approximate the gradient:
∇θL(θ) = ∇θEq(z)
h
L˜(θ, z)
i
= Eq(z)
h
∇θL˜(θ, z)
i
≈
1
S
X
S
s=1
∇θL˜(θ, zs) (6.49)
For example, consider the problem of empirical risk minimization or ERM, which requires
minimizing
L(θ) = 1
N
X
N
n=1
L˜(θ, zn) = 1
N
X
N
n=1
ℓ(yn, f(xn; θ)) (6.50)
where zn = (xn, yn) is the n’th labeled example, and f is a prediction function. This kind of
objective is called a finite sum objective. We can write this as an expected loss wrt the empirical
distrbution pD(x, y):
L(θ) = EpD(z)
h
L˜(θ, z)
i
(6.51)
Since the expectation depends on the data, and not on the parameters, we can approximate the
gradient by using a minibatch of B = |B| datapoints from the full dataset D at each iteration:
gt = ∇L(θt) = 1
B
X
n∈B
∇ℓ(yn, f(xn; θ)) (6.52)
These noisy gradients can then be passed to SGD. When the dataset is large, this method is much
faster than full batch gradient descent, since it does not require evaluating the loss on all N examples
before updating the model [BB08; BB11].
6.3.3 SGD for optimizing the parameters of a distribution
Now suppose the stochasticity depends on the parameters we are optimizing. For example, z could
be an action sampled from a stochastic policy qθ, as in RL (Section 35.3.2), or z could be a latent
variable sampled from an inference network qθ, as in stochastic variational inference (see Section 10.2).
In this case, the gradient is given by
∇θEqθ(z)
h
L˜(θ, z)
i
= ∇θ
Z
L˜(θ, z)qθ(z)dz (6.53)
=
Z h
∇θL˜(θ, z)
i
qθ(z)dz +
Z
L˜(θ, z) [∇θqθ(z)] dz (6.54)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license268
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The first term can be approximated by Monte Carlo sampling:
Z h
∇θL˜(θ, z)
i
qθ(z)dz ≈
1
S
X
S
s=1
∇θL˜(θ, zs) (6.55)
where zs ∼ qθ. Note that if L˜() is independent of θ, this term vanishes.
Now consider the second term, that takes the gradients of the distribution itself:
I ,
Z
L˜(θ, z) [∇θqθ(z)] dz (6.56)
We can no longer use vanilla Monte Carlo sampling to approximate this integral. However, there are
various other ways to approximate this (see [Moh+20] for an extensive review). We briefly describe
the two main methods in Section 6.3.4 and Section 6.3.5.
6.3.4 Score function estimator (REINFORCE)
The simplest way to approximate Equation (6.56) is to exploit the log derivative trick, which is
the following identity:
∇θqθ(z) = qθ(z)∇θ log qθ(z) (6.57)
With this, we can rewrite Equation (6.56) as follows:
I =
Z
L˜(θ, z)[qθ(z)∇θ log qθ(z)]dz = Eqθ(z)
h
L˜(θ, z)∇θ log qθ(z)
i
(6.58)
This is called the score function estimator or SFE [Fu15]. (The term “score function” refers to
the gradient of a log probability distribution, as explained in Section 3.3.4.1.) It is also called the
likelihood ratio gradient estimator, or the REINFORCE estimator (the reason for this latter
name is explained in Section 35.3.2). We can now easily approximate this with Monte Carlo:
I ≈
1
S
X
S
s=1
L˜(θ, zs)∇θ log qθ(zs) (6.59)
where zs ∼ qθ. We only require that the sampling distribution is differentiable, not the objective
L˜(θ, z) itself. This allows the method to be used for blackbox stochastic optimization problems,
such as variational optimization (Supplementary Section 6.4.3), black-box variational inference
(Section 10.2.3), reinforcement learning (Section 35.3.2), etc.
6.3.4.1 Control variates
The score function estimate can have high variance. One way to reduce this is to use control
variates, in which we replace L˜(θ, z) with
L
ˆ˜(θ, z) = L˜(θ, z) − c (b(θ, z) − E [b(θ, z)]) (6.60)
where b(θ, z) is a baseline function that is correlated with L˜(θ, z), and c > 0 is a coefficient. Since
E
h
L
ˆ˜(θ, z)
i
= E
h
L˜(θ, z)
i
, we can use L
ˆ˜ to compute unbiased gradient estimates of L˜. The advantage
is that this new estimate can result in lower variance, as we show in Section 11.6.3.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.3. STOCHASTIC OPTIMIZATION
6.3.4.2 Rao-Blackwellization
Suppose qθ(z) is a discrete distribution. In this case, our objective becomes L(θ) = P
z L˜(θ, z)qθ(z).
We can now easily compute gradients using ∇θL(θ) = P
z L˜(θ, z)∇θqθ(z). Of course, if z can take
on exponentially many values (e.g., we are optimizing over the space of strings), this expression
is intractable. However, suppose we can partition this sum into two sets, a small set S1 of high
probability values and a large set S2 of all other values. Then we can enumerate over S1 and use the
score function estimator for S2:
∇θL(θ) = X
z∈S1
L˜(θ, z)∇θqθ(z) + Eqθ(z|z∈S2)
h
L˜(θ, z)∇θ log qθ(z)
i
(6.61)
To compute the second expectation, we can use rejection sampling applied to samples from qθ(z).
This procedure is a form of Rao-Blackwellization as shown in [Liu+19b], and reduces the variance
compared to standard SFE (see Section 11.6.2 for details on Rao-Blackwellization).
6.3.5 Reparameterization trick
The score function estimator can have high variance, even when using a control variate. In this
section, we derive a lower variance estimator, which can be applied if L˜(θ, z) is differentiable wrt z.
We additionally require that we can compute a sample from qθ(z) by first sampling ǫ from some
noise distribution q0 which is independent of θ, and then transforming to z using a deterministic and
differentiable function z = g(θ, ǫ). For example, instead of sampling z ∼ N (µ, σ2
), we can sample
ǫ ∼ N (0, 1) and compute
z = g(θ, ǫ) = µ + σǫ (6.62)
where θ = (µ, σ). This allows us to rewrite our stochastic objective as follows:
L(θ) = Eqθ(z)
h
L˜(θ, z)
i
= Eq0(ǫ)
h
L˜(θ, g(θ, ǫ))i
(6.63)
Since q0(ǫ) is independent of θ, we can push the gradient operator inside the expectation, which we
can approximate with Monte Carlo:
∇θL(θ) = Eq0(ǫ)
h
∇θL˜(θ, g(θ, ǫ))i
≈
1
S
X
S
s=1
∇θL˜(θ, g(θ, ǫs)) (6.64)
where ǫs ∼ q0. This is called the reparameterization gradient or the pathwise derivative
[Gla03; Fu15; KW14; RMW14a; TLG14; JO18; FMM18], and is widely used in variational inference
(Section 10.2.1). For a review of such methods, see [Moh+20].
Note that the tensorflow probability library (which also has a JAX interface) supports reparam￾eterizable distributions. Therefore you can just write code in a straightforward way, as shown in
?? 6.1.
Listing 6.1: Derivative of a stochastic function
def expected_loss ( params ):
zs = dist . sample (N , key )
return jnp . mean ( loss ( params , zs ))
g = jax . grad ( expected_loss )( params )
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license270
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.3.5.1 Example
As a simple example, suppose we define some arbitrary function, such as L˜(z) = z
2 − 3z, and then
define its expected value as L(θ) = EN(z|µ,v)
h
L˜(z)
i
, where θ = (µ, v) and v = σ
2
. Suppose we want
to compute
∇θL(θ) = [ ∂
∂µE
h
L˜(z)
i
,
∂
∂vE
h
L˜(z)
i
] (6.65)
Since the Gaussian distribution is reparameterizable, we can sample z ∼ N (z|µ, v), and then use
automatic differentiation to compute each of these gradient terms, and then average.
However, in the special case of Gaussian distributions, we can also compute the gradient vector
directly. In particular, in Section 6.4.5.1 we present Bonnet’s theorem, which states that
∂
∂µE
h
L˜(z)
i
= E

∂
∂zL˜(z)

(6.66)
Similarly, Price’s theorem states that
∂
∂vE
h
L˜(z)
i
= 0.5E

∂
2
∂z2
L˜(z)

(6.67)
In gradient_expected_value_gaussian.ipynb we show that these two methods are numerically
equivalent, as theory suggests.
6.3.5.2 Total derivative
To compute the gradient term inside the expectation in Equation (6.64) we need to use the total
derivative, since the function L˜ depends on θ directly and via the noise sample z. Recall that, for
a function of the form L˜(θ1, . . . , θdψ
, z1(θ), . . . , zdz
(θ)), the total derivative wrt θi
is given by the
chain rule as follows:
∂L˜
∂θi
TD
=
∂L˜
∂θi
+
X
j
∂L˜
∂zj
∂zj
∂θi
(6.68)
and hence
∇θL˜(θ, z)
TD = ∇zL˜(θ, z)J + ∇θL˜(θ, z) (6.69)
where J =
∂z
T
∂θ
is the dz × dψ Jacobian matrix of the noise transformation:
J =


∂z1
∂θ1
· · ·
∂z1
∂θdψ
.
.
.
.
.
.
.
.
.
∂zdz
∂θdψ
· · ·
∂zdz
∂θdψ


(6.70)
We leverage this decomposition in Section 6.3.5.3, where we derive a lower variance gradient estimator
in the special case of variational inference.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.3. STOCHASTIC OPTIMIZATION
6.3.5.3 “Sticking the landing” estimator
In this section we consider the special case which arises in variational inference (Section 10.2). The
ELBO objective (for a single latent sample z) has the form
L˜(θ, z) = log p(z, x) − log q(z|θ) (6.71)
where θ are the parameters of the variational posterior. The gradient becomes
∇θL˜(θ, z) = ∇θ [log p(z, x) − log q(z|θ)] (6.72)
= ∇z [log p(z, x) − log q(z|θ)] J
| {z }
path derivative
− ∇θ log q(z|θ)
| {z }
score function
(6.73)
The first term is the indirect effect of θ on the objective via the generated samples z. The second
term is the direct effect of θ on the objective. The second term is zero in expectation since it is the
score function (see Equation (3.44)), but it may be non-zero for a finite number of samples, even if
q(z|θ) = p(z|x) is the true posterior. In [RWD17], they propose to drop the second term to create
a lower variance estimator. This can be achieved by using log q(z|θ
′
), where θ
′
is a “disconnected”
copy of θ that does not affect the gradient. In pseudocode, this looks like the following:
ǫ ∼ q0(ǫ) (6.74)
z = g(ǫ, θ) (6.75)
θ
′ = stop-gradient(θ) (6.76)
g = ∇θ [log p(z, x) − log q(z|θ
′
)] (6.77)
They call this the sticking the landing or STL estimator.4 Note that the STL estimator is
not always better than the “standard” estimator, without the stop gradient term. In [GD20], they
propose to use a weighted combination of estimators, where the weights are optimized so as to reduce
variance for a fixed amount of compute.
6.3.6 Gumbel softmax trick
When working with discrete variables, we cannot use the reparameterization trick. However, we can
often relax the discrete variables to continuous ones in a way which allows the trick to be used, as we
explain below.
Consider a one-hot vector d with K bits, so dk ∈ {0, 1} and PK
k=1 dk = 1. This can be used
to represent a K-ary categorical variable d. Let P(d) = Cat(d|π), where πk = P(dk = 1), so
0 ≤ πk ≤ 1. Alternatively we can parameterize the distribution in terms of (α1, . . . , αk), where
πk = αk/(
PK
k′=1 αk′ ). We will denote this by d ∼ Cat(d|α).
We can sample a one-hot vector d from this distribution by computing
d = onehot(argmax
k
[ǫk + log αk]) (6.78)
4. The expression “to stick a landing” means to land firmly on one’s feet after performing a gymnastics move. In the
current context, the analogy is this: if the variational posterior is optimal, then we want our objective to be 0, and not
to “wobble” with Monte Carlo noise.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license272
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
expectation
a) Categorical
category
sample
b)
τ = 0.1 τ = 0.5 τ = 1.0 τ = 10.0
Figure 6.3: Illustration of the Gumbel-softmax (concrete) distribution with K = 7 states at different tempera￾tures τ . The top row shows E [z], and the bottom row shows samples z ∼ GumbelSoftmax(α, τ ). The left
column shows a discrete (categorical) distribution, which always produces one-hot samples. From Figure 1 of
[JGP17]. Used with kind permission of Ben Poole.
where ǫk ∼ Gumbel(0, 1) is sampled from the Gumbel distribution [Gum54]. We can draw such
samples by first sampling uk ∼ Unif(0, 1) and then computing ǫk = − log(− log(uk)). This is
called the Gumbel-max trick [MTM14], and gives us a reparameterizable representation for the
categorical distribution.
Unfortunately, the derivative of the argmax is 0 everywhere except at the boundary of transitions
from one label to another, where the derivative is undefined. However, suppose we replace the argmax
with a softmax, and replace the discrete one-hot vector d with a continuous relaxation x ∈ ∆K−1
,
where ∆K−1 = {x ∈ R
K : xk ∈ [0, 1],
PK
k=1 xk = 1} is the K-dimensional simplex. Then we can
write
xk =
exp((log αk + ǫk)/τ )
PK
k′=1 exp((log αk′ + ǫk′ )/τ )
(6.79)
where τ > 0 is a temperature parameter. This is called the Gumbel-softmax distribution [JGP17]
or the concrete distribution [MMT17]. This smoothly approaches the discrete distribution as
τ → 0, as illustrated in Figure 6.3.
We can now replace f(d) with f(x), which allows us to take reparameterized gradients wrt x.
6.3.7 Stochastic computation graphs
We can represent an arbitrary function containing both deterministic and stochastic components
as a stochastic computation graph. We can then generalize the AD algorithm (Section 6.2) to
leverage score function estimation (Section 6.3.4) and reparameterization (Section 6.3.5) to compute
Monte Carlo gradients for complex nested functions. For details, see [Sch+15a; Gaj+19].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.4. NATURAL GRADIENT DESCENT
Figure 6.4: Illustration of straight-through estimator when applied to a binary threshold function in the
middle of an MLP. From https: // www. hassanaskary. com/ python/ pytorch/ deep% 20learning/ 2020/
09/ 19/ intuitive-explanation-of-straight-through-estimators. html . Used with kind permission of
Hassan Askary.
6.3.8 Straight-through estimator
In this section, we discuss how to approximate the gradient of a quantized version of a signal. For
example, suppose we have the following thresholding function, that binarizes its output:
f(x) = (
1 if x > 0
0 if x ≤ 0
(6.80)
This does not have a well-defined gradient. However, we can use the straight-through estimator
proposed in [Ben13] as an approximation. The basic idea is to replace g(x) = f
′
(x), where f
′
(x) is
the derivative of f wrt input, with g(x) = x when computing the backwards pass. See Figure 6.4 for
a visualization, and [Yin+19b] for an analysis of why this is a valid approximation.
In practice, we sometimes replace g(x) = x with the hard tanh function, defined by
HardTanh(x) =



x if −1 ≤ x ≤ 1
1 if x > 1
−1 if x < −1
(6.81)
This ensures the gradients that are backpropagated don’t get too large. See Section 21.6 for an
application of this approach to discrete autoencoders.
6.4 Natural gradient descent
In this section, we discuss natural gradient descent (NGD) [Ama98], which is a second order
method for optimizing the parameters of (conditional) probability distributions pθ(y|x). The key
idea is to compute parameter updates by measuring distances between the induced distributions,
rather than comparing parameter values directly.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license274
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 6.5: Changing the mean of a Gaussian by a fixed amount (from solid to dotted curve) can have more
impact when the (shared) variance is small (as in a) compared to when the variance is large (as in b). Hence
the impact (in terms of prediction accuracy) of a change to µ depends on where the optimizer is in (µ, σ)
space. From Figure 3 of [Hon+10], reproduced from [Val00]. Used with kind permission of Antti Honkela.
For example, consider comparing two Gaussians, pθ = p(y|µ, σ) and pθ′ = p(y|µ
′
, σ′
). The (squared)
Euclidean distance between the parameter vectors decomposes as ||θ − θ
′
||2 = (µ − µ
′
)
2 + (σ − σ
′
)
2
.
However, the predictive distribution has the form exp(−
1
2σ2 (y − µ)
2
), so changes in µ need to be
measured relative to σ. This is illustrated in Figure 6.5(a-b), which shows two univariate Gaussian
distributions (dotted and solid lines) whose means differ by δ. In Figure 6.5(a), they share the same
small variance σ
2
, whereas in Figure 6.5(b), they share the same large variance. It is clear that
the value of δ matters much more (in terms of the effect on the distribution) when the variance is
small. Thus we see that the two parameters interact with each other, which the Euclidean distance
cannot capture. This problem gets much worse when we consider more complex models, such as deep
neural networks. By modeling such correlations, NGD can converge much faster than other gradient
methods.
6.4.1 Defining the natural gradient
The key to NGD is to measure the notion of distance between two probability distributions in terms
of the KL divergence. As we show in Section 5.1.9, this can be appproximated in terms of the Fisher
information matrix (FIM). In particular, for any given input x, we have
DKL (pθ(y|x) k pθ+δ(y|x)) ≈
1
2
δ
TFxδ (6.82)
where Fx is the FIM
Fx(θ) = −Epθ(y|x)

∇2
log pθ(y|x)

= Epθ(y|x)

(∇ log pθ(y|x))(∇ log pθ(y|x))T

(6.83)
We can compute the average KL between the current and updated distributions using 1
2
δ
TFδ, where
F is the averaged FIM:
F(θ) = EpD(x)
[Fx(θ)] (6.84)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.4. NATURAL GRADIENT DESCENT
NGD uses the inverse FIM as a preconditioning matrix, i.e., we perform updates of the following
form:
θt+1 = θt − ηtF(θt)
−1
gt (6.85)
The term
F
−1
gt = F
−1∇L(θt) , ∇L˜ (θt) (6.86)
is called the natural gradient.
6.4.2 Interpretations of NGD
6.4.2.1 NGD as a trust region method
In Supplementary Section 6.1.3.1 we show that we can interpret standard gradient descent as
optimizing a linear approximation to the objective subject to a penalty on the ℓ2 norm of the change
in parameters, i.e., if θt+1 = θt + δ, then we optimize
Mt(δ) = L(θt) + g
T
t δ + η||δ||2
2
(6.87)
Now let us replace the squared distance with the squared FIM-based distance, ||δ||2
F = δ
TFδ. This
is equivalent to squared Euclidean distance in the whitened coordinate system φ = F
1
2 θ, since
||φt+1 − φt
||2
2 = ||F
1
2 (θt + δ) − F
1
2 θt||2
2 = ||F
1
2 δ||2
2 = ||δ||
2
F (6.88)
The new objective becomes
Mt(δ) = L(θt) + g
T
t δ + ηδ
TFδ (6.89)
Solving ∇δMt(δ) = 0 gives the update
δt = −ηF
−1
gt (6.90)
This is the same as the natural gradient direction. Thus we can view NGD as a trust region method,
where we use a first-order approximation to the objective, and use FIM-distance in the constraint.
In the above derivation, we assumed F was a constant matrix. Im most problems, it will change at
each point in space, since we are optimizing in a curved space known as a Riemannian manifold.
For certain models, we can compute the FIM efficiently, allowing us to capture curvature information,
even though we use a first-order approximation to the objective.
6.4.2.2 NGD as a Gauss-Newton method
If p(y|x, θ) is an exponential family distribution with natural parameters computed by η = f(x, θ),
then one can show [Hes00; PB14] that NGD is identical to the generalized Gauss-Newton (GGN)
method (Section 17.3.2). Furthermore, in the online setting, these methods are equivalent to
performing sequential Bayesian inference using the extended Kalman filter, as shown in [Oll18].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license276
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.4.3 Benefits of NGD
The use of the FIM as a preconditioning matrix, rather than the Hessian, has two advantages. First,
F is always positive definite, whereas H can have negative eigenvalues at saddle points, which are
prevalent in high dimensional spaces. Second, it is easy to approximate F online from minibatches,
since it is an expectation (wrt the empirical distribution) of outer products of gradient vectors. This
is in contrast to Hessian-based methods [Byr+16; Liu+18a], which are much more sensitive to noise
introduced by the minibatch approximation.
In addition, the connection with trust region optimization makes it clear that NGD updates
parameters in a way that matter most for prediction, which allows the method to take larger steps in
uninformative regions of parameter space, which can help avoid getting stuck on plateaus. This can
also help with issues that arise when the parameters are highly correlated.
For example, consider a 2d Gaussian with an unusual, highly coupled parameterization, proposed
in [SD12]:
p(x; θ) = 1
2π
exp "
−
1
2

x1 −

3θ1 +
1
3
θ2
2
−
1
2

x2 −

1
3
θ1
2
#
(6.91)
The objective is the cross entropy loss:
L(θ) = −Ep∗(x)
[log p(x; θ)] (6.92)
The gradient of this objective is given by
∇θL(θ)

= Ep∗(x)

3(x1 − [3θ1 +
1
3
θ2]) + 1
3
(x2 − [
1
3
θ1])
Ep∗(x)

1
3
(x1 − [3θ1 +
1
3
θ2])

(6.93)
Suppose that p
∗
(x) = p(x; [0, 0]). Then the Fisher matrix is a constant matrix, given by
F =

3
2 +
1
3
2 1
1
1
3
2

(6.94)
Figure 6.6 compares steepest descent in θ space with the natural gradient method, which is
equivalent to steepest descent in φ space. Both methods start at θ = (1, −1). The global optimum is
at θ = (0, 0). We see that the NG method (blue dots) converges much faster to this optimum and
takes the shortest path, whereas steepest descent takes a very circuitous route. We also see that
the gradient field in the whitened parameter space is more “spherical”, which makes descent much
simpler and faster.
Finally, note that since NGD is invariant to how we parameterize the distribution, we will get the
same results even for a standard parameterization of the Gaussian. This is particularly useful if our
probability model is more complex, such as a DNN (see e.g., [SSE18]).
6.4.4 Approximating the natural gradient
The main drawback of NGD is the computational cost of computing (the inverse of) the Fisher
information matrix (FIM). To speed this up, several methods make assumptions about the form
of F, so it can be inverted efficiently. For example, [LeC+98] uses a diagonal approximation for
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.4. NATURAL GRADIENT DESCENT
(a) (b)
(c) (d)
Figure 6.6: Illustration of the benefits of natural gradient vs steepest descent on a 2d problem. (a) Trajectories
of the two methods in parameter space (red = steepest descent, blue = NG). They both start in the bottom
right, at (1, −1). (b) Objective vs number of iterations. (c) Gradient field in the θ parameter space. (d)
Gradient field in the whitened φ = F
1
2 θ parameter space used by NG. Generated by nat_grad_demo.ipynb.
neural net training; [RMB08] uses a low-rank plus block diagonal approximation; and [GS15] assumes
the covariance of the gradients can be modeled by a directed Gaussian graphical model with low
treewidth (i.e., the Cholesky factorization of F is sparse).
[MG15] propose the KFAC method, which stands for “Kronecker factored approximate curvature”;
this approximates the FIM of a DNN as a block diagonal matrix, where each block is a Kronecker
product of two small matrices. This method has shown good results on supervised learning of
neural nets [GM16; BGM17; Geo+18; Osa+19b] as well as reinforcement learning of neural policy
networks [Wu+17]. The KFAC approximation can be justified using the mean field analysis of
[AKO18]. In addition, [ZMG19] prove that KFAC will converge to the global optimum of a DNN if
it is overparameterized (i.e., acts like an interpolator).
A simpler approach is to approximate the FIM by replacing the model’s distribution with the em￾pirical distribution. In particular, define pD(x, y) = 1
N
PN
n=1 δxn
(x)δyn
(y), pD(x) = 1
N
PN
n=1 δxn
(x)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license278
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
and pθ(x, y) = pD(x)p(y|x, θ). Then we can compute the empirical Fisher [Mar16] as follows:
F = Epθ(x,y)

∇ log p(y|x, θ)∇ log p(y|x, θ)
T

(6.95)
≈ EpD(x,y)

∇ log p(y|x, θ)∇ log p(y|x, θ)
T

(6.96)
=
1
|D|
X
(x,y)∈D
∇ log p(y|x, θ)∇ log p(y|x, θ)
T
(6.97)
This approximation is widely used, since it is simple to compute. In particular, we can compute a
diagonal approximation using the squared gradient vector. (This is similar to AdaGrad, but only
uses the current gradient instead of a moving average of gradients; the latter is a better approach
when performing stochastic optimization.)
Unfortunately, the empirical Fisher does not work as well as the true Fisher [KBH19; Tho+19].
To see why, note that when we reach a flat part of parameter space where the gradient vector goes
to zero, the empirical Fisher will become singular, and hence the algorithm will get stuck on this
plateau. However, the true Fisher takes expectations over the outputs, i.e., it marginalizes out y.
This will allow it to detect small changes in the output if we change the parameters. This is why the
natural gradient method can “escape” plateaus better than standard gradient methods.
An alternative strategy is to use exact computation of F, but solve for F
−1g approximately
using truncated conjugate gradient (CG) methods, where each CG step uses efficient methods for
Hessian-vector products [Pea94]. This is called Hessian free optimization [Mar10a]. However,
this approach can be slow, since it may take many CG iterations to compute a single parameter
update.
6.4.5 Natural gradients for the exponential family
In this section, we asssume L is an expected loss of the following form:
L(µ) = Eqµ(z)
h
L˜(z)
i
(6.98)
where qµ(z) is an exponential family distribution with moment parameters µ. This is the basis
of variational optimization (discussed in Supplementary Section 6.4.3) and natural evolutionary
strategies (discussed in Section 6.7.6).
It turns out the gradient wrt the moment parameters is the same as the natural gradient wrt the
natural parameters λ. This follows from the chain rule:
d
dλ
L(λ) = dµ
dλ
d
dµ
L(µ) = F(λ)∇µL(µ) (6.99)
where L(µ) = L(λ(µ)), and where we used Equation (2.232) to write
F(λ) = ∇λµ(λ) = ∇2
λA(λ) (6.100)
Hence
∇˜
λL(λ) = F(λ)
−1∇λL(λ) = ∇µL(µ) (6.101)
It remains to compute the (regular) gradient wrt the moment parameters. The details on how to
do this will depend on the form of the q and the form of L(λ). We discuss some approaches to this
problem below.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.4. NATURAL GRADIENT DESCENT
6.4.5.1 Analytic computation for the Gaussian case
In this section, we assume that q(z) = N (z|m, V). We now show how to compute the relevant
gradients analytically.
Following Section 2.4.2.5, the natural parameters of q are
λ
(1) = V−1m, λ
(2) = −
1
2
V−1
(6.102)
and the moment parameters are
µ
(1) = m, µ
(2) = V + mmT
(6.103)
For simplicity, we derive the result for the scalar case. Let m = µ
(1) and v = µ
(2) − (µ
(1))
2
. By using
the chain rule, the gradient wrt the moment parameters are
∂L
∂µ(1) =
∂L
∂m
∂m
∂µ(1) +
∂L
∂v
∂v
∂µ(1) =
∂L
∂m − 2
∂L
∂v m (6.104)
∂L
∂µ(2) =
∂L
∂m
∂m
∂µ(2) +
∂L
∂v
∂v
∂µ(2) =
∂L
∂v (6.105)
It remains to compute the derivatives wrt m and v. If z ∼ N (m, V), then from Bonnet’s
theorem [Bon64] we have
∂
∂mi
E
h
L˜(z)
i
= E

∂
∂θi
L˜(z)

(6.106)
And from Price’s theorem [Pri58] we have
∂
∂Vij
E
h
L˜(z)
i
= cijE

∂
2
∂θiθj
L˜(z)

(6.107)
where cij =
1
2
if i = j and cij = 1 otherwise. (See gradient_expected_value_gaussian.ipynb for a
“proof by example” of these claims.)
In the multivariate case, the result is as follows [OA09; KR21a]:
∇µ(1)Eq(z)
h
L˜(z)
i
= ∇mEq(z)
h
L˜(z)
i
− 2∇VEq(z)
h
L˜(z)
i
m (6.108)
= Eq(z)
h
∇zL˜(z)
i
− Eq(z)
h
∇2
zL˜(z)
i
m (6.109)
∇µ(2)Eq(z)
h
L˜(z)
i
= ∇VEq(z)
h
L˜(z)
i
(6.110)
=
1
2
Eq(z)
h
∇2
zL˜(z)
i
(6.111)
Thus we see that the natural gradients rely on both the gradient and Hessian of the loss function
L˜(z). We will see applications of this result in Supplementary Section 6.4.2.2.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license280
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.4.5.2 Stochastic approximation for the general case
In general, it can be hard to analytically compute the natural gradient. However, we can compute a
Monte Carlo approximation. To see this, let us assume L is an expected loss of the following form:
L(µ) = Eqµ(z)
h
L˜(z)
i
(6.112)
From Equation (6.101) the natural gradient is given by
∇µL(µ) = F(λ)
−1∇λL(λ) (6.113)
For exponential family distributions, both of these terms on the RHS can be written as expectations,
and hence can be approximated by Monte Carlo, as noted by [KL17a]. To see this, note that
F(λ) = ∇λµ(λ) = ∇λEqλ(z)
[T (z)] (6.114)
∇λL(λ) = ∇λEqλ(z)
h
L˜(z)
i
(6.115)
If q is reparameterizable, we can apply the reparameterization trick (Section 6.3.5) to push the
gradient inside the expectation operator. This lets us sample z from q, compute the gradients, and
average; we can then pass the resulting stochastic gradients to SGD.
6.4.5.3 Natural gradient of the entropy function
In this section, we discuss how to compute the natural gradient of the entropy of an exponential
family distribution, which is useful when performing variational inference (Chapter 10). The natural
gradient is given by
∇˜
λ H(λ) = −∇µEqµ(z)
[log q(z)] (6.116)
where, from Equation (2.160), we have
log q(z) = log h(z) + T (z)
Tλ − A(λ) (6.117)
Since E [T (z)] = µ, we have
∇µEqµ(z)
[log q(z)] = ∇µEq(z)
[log h(z)] + ∇µµ
Tλ(µ) − ∇µA(λ) (6.118)
where h(z) is the base measure. Since λ is a function of µ, we have
∇µµ
Tλ = λ + (∇µλ)
Tµ = λ + (F
−1
λ ∇λλ)
Tµ = λ + F
−1
λ µ (6.119)
and since µ = ∇λA(λ) we have
∇µA(λ) = F
−1
λ ∇λA(λ) = F
−1
λ µ (6.120)
Hence
−∇µEqµ(z)
[log q(z)] = −∇µEq(z)
[log h(z)] − λ (6.121)
If we assume that h(z) = const, as is often the case, we get
∇˜
λ H(λ) = −λ (6.122)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.5. BOUND OPTIMIZATION (MM) ALGORITHMS
Q(θ,θ
t
)
Q(θ,θ
t+1)
l(θ)
θ
t
θ
t+1 θ
t+2
Figure 6.7: Illustration of a bound optimization algorithm. Adapted from Figure 9.14 of [Bis06]. Generated
by em_log_likelihood_max.ipynb.
6.5 Bound optimization (MM) algorithms
In this section, we consider a class of algorithms known as bound optimization or MM algorithms.
In the context of minimization, MM stands for majorize-minimize. In the context of maximization,
MM stands for minorize-maximize. There are many examples of MM algorithms, such as EM
(Section 6.5.3), proximal gradient methods (Section 4.1), the mean shift algorithm for clustering
[FH75; Che95; FT05], etc. For more details, see e.g., [HL04; Mai15; SBP17; Nad+19],
6.5.1 The general algorithm
In this section, we assume our goal is to maximize some function ℓ(θ) wrt its parameters θ. The
basic approach in MM algorithms is to construct a surrogate function Q(θ, θ
t
) which is a tight
lowerbound to ℓ(θ) such that Q(θ, θ
t
) ≤ ℓ(θ) and Q(θ
t
, θ
t
) = ℓ(θ
t
). If these conditions are met, we
say that Q minorizes ℓ. We then perform the following update at each step:
θ
t+1 = argmax
θ
Q(θ, θ
t
) (6.123)
This guarantees us monotonic increases in the original objective:
ℓ(θ
t+1) ≥ Q(θ
t+1
, θ
t
) ≥ Q(θ
t
, θ
t
) = ℓ(θ
t
) (6.124)
where the first inequality follows since Q(θ
t
, θ
′
) is a lower bound on ℓ(θ
t
) for any θ
′
; the second
inequality follows from Equation (6.123); and the final equality follows the tightness property. As a
consequence of this result, if you do not observe monotonic increase of the objective, you must have
an error in your math and/or code. This is a surprisingly powerful debugging tool.
This process is sketched in Figure 6.7. The dashed red curve is the original function (e.g., the
log-likelihood of the observed data). The solid blue curve is the lower bound, evaluated at θ
t
; this
touches the objective function at θ
t
. We then set θ
t+1 to the maximum of the lower bound (blue
curve), and fit a new bound at that point (dotted green curve). The maximum of this new bound
becomes θ
t+2, etc.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license282
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.5.2 Example: logistic regression
If ℓ(θ) is a concave function we want to maximize, then one way to obtain a valid lower bound is to
use a bound on its Hessian, i.e., to find a negative definite matrix B such that H(θ) ≻ B. In this
case, one can show (see [BCN18, App. B]) that
ℓ(θ) ≥ ℓ(θ
t
) + (θ − θ
t
)
T
g(θ
t
) +
1
2
(θ − θ
t
)
TB(θ − θ
t
) (6.125)
where g(θ
t
) = ∇ℓ(θ
t
). Therefore the following function is a valid lower bound:
Q(θ, θ
t
) = θ
T
(g(θ
t
) − Bθ
t
) + 1
2
θ
TBθ (6.126)
The corresponding update becomes
θ
t+1 = θ
t − B
−1
g(θ
t
) (6.127)
This is similar to a Newton update, except we use B, which is a fixed matrix, rather than H(θ
t
),
which changes at each iteration. This can give us some of the advantages of second order methods at
lower computational cost.
For example, let us fit a multi-class logistic regression model using MM. (We follow the presentation
of [Kri+05], who also consider the more interesting case of sparse logistic regression.) The probability
that example n belongs to class c ∈ {1, . . . , C} is given by
p(yn = c|xn, w) = exp(wT
cxn)
PC
i=1 exp(wT
i xn)
(6.128)
Because of the normalization condition PC
c=1 p(yn = c|xn, w) = 1, we can set wC = 0. (For example,
in binary logistic regression, where C = 2, we only learn a single weight vector.) Therefore the
parameters θ correspond to a weight matrix w of size D(C − 1), where xn ∈ R
D.
If we let pn(w) = [p(yn = 1|xn, w), . . . , p(yn = C−1|xn, w)] and yn = [I(yn = 1), . . . ,I(yn = C − 1)],
we can write the log-likelihood as follows:
ℓ(w) = X
N
n=1 "
C
X−1
c=1
yncwT
cxn − logX
C
c=1
exp(wT
cxn)
#
(6.129)
The gradient is given by the following:
g(w) = X
N
n=1
(yn − pn(w)) ⊗ xn (6.130)
where ⊗ denotes Kronecker product (which, in this case, is just outer product of the two vectors).
The Hessian is given by the following:
H(w) = −
X
N
n=1
(diag(pn(w)) − pn(w)pn(w)
T
) ⊗(xnx
T
n
) (6.131)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.5. BOUND OPTIMIZATION (MM) ALGORITHMS
We can construct a lower bound on the Hessian, as shown in [Boh92]:
H(w) ≻ −
1
2
[I − 11T
/C] ⊗(
X
N
n=1
xnx
T
n
) , B (6.132)
where I is a (C − 1)-dimensional identity matrix, and 1 is a (C − 1)-dimensional vector of all 1s. In
the binary case, this becomes
H(w) ≻ −
1
2
(1 −
1
2
)(X
N
n=1
x
T
nxn) = −
1
4
XTX (6.133)
This follows since pn ≤ 0.5 so −(pn − p
2
n
) ≥ −0.25.
We can use this lower bound to construct an MM algorithm to find the MLE. The update becomes
wt+1 = wt − B
−1
g(wt
) (6.134)
For example, let us consider the binary case, so g
t = ∇ℓ(wt
) = XT(y −µ
t
), where µ
t = [pn(wt
),(1−
pn(wt
))]N
n=1. The update becomes
wt+1 = wt − 4(XTX)
−1
g
t
(6.135)
The above is faster (per step) than the IRLS (iteratively reweighted least squares) algorithm (i.e.,
Newton’s method), which is the standard method for fitting GLMs. To see this, note that the Newton
update has the form
wt+1 = wt − H−1
g(wt
) = wt − (XTS
tX)
−1
g
t
(6.136)
where S
t = diag(µ
t ⊙(1 − µ
t
)). We see that Equation (6.135) is faster to compute, since we can
precompute the constant matrix (XTX)
−1
.
6.5.3 The EM algorithm
In this section, we discuss the expectation maximization (EM) algorithm [DLR77; MK07], which
is an algorithm designed to compute the MLE or MAP parameter estimate for probability models
that have missing data and/or hidden variables. It is a special case of an MM algorithm.
The basic idea behind EM is to alternate between estimating the hidden variables (or missing
values) during the E step (expectation step), and then using the fully observed data to compute the
MLE during the M step (maximization step). Of course, we need to iterate this process, since the
expected values depend on the parameters, but the parameters depend on the expected values.
In Section 6.5.3.1, we show that EM is a bound optimization algorithm, which implies that this
iterative procedure will converge to a local maximum of the log likelihood. The speed of convergence
depends on the amount of missing data, which affects the tightness of the bound [XJ96; MD97;
SRG03; KKS20].
We now describe the EM algorithm for a generic model. We let yn be the visible data for example
n, and zn be the hidden data.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license284
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.5.3.1 Lower bound
The goal of EM is to maximize the log likelihood of the observed data:
ℓ(θ) = X
N
n=1
log p(yn|θ) = X
N
n=1
log "X
zn
p(yn, zn|θ)
#
(6.137)
where yn are the visible variables and zn are the hidden variables. Unfortunately this is hard to
optimize, since the log cannot be pushed inside the sum.
EM gets around this problem as follows. First, consider a set of arbitrary distributions qn(zn) over
each hidden variable zn. The observed data log likelihood can be written as follows:
ℓ(θ) = X
N
n=1
log "X
zn
qn(zn)
p(yn, zn|θ)
qn(zn)
#
(6.138)
Using Jensen’s inequality, we can push the log (which is a concave function) inside the expectation
to get the following lower bound on the log likelihood:
ℓ(θ) ≥
X
n
X
zn
qn(zn) log p(yn, zn|θ)
qn(zn)
(6.139)
=
X
n
Eqn
[log p(yn, zn|θ)] + H(qn)
| {z }
Ł(θ,qn|yn)
(6.140)
=
X
n
Ł(θ, qn|yn) , Ł(θ, {qn}|D) (6.141)
where H(q) is the entropy of probability distribution q, and Ł(θ, {qn}|D) is called the evidence
lower bound or ELBO, since it is a lower bound on the log marginal likelihood, log p(y1:N |θ), also
called the evidence. Optimizing this bound is the basis of variational inference, as we discuss in
Section 10.1.
6.5.3.2 E step
We see that the lower bound is a sum of N terms, each of which has the following form:
Ł(θ, qn|yn) = X
zn
qn(zn) log p(yn, zn|θ)
qn(zn)
(6.142)
=
X
zn
qn(zn) log p(zn|yn, θ)p(yn|θ)
qn(zn)
(6.143)
=
X
zn
qn(zn) log p(zn|yn, θ)
qn(zn)
+
X
zn
qn(zn) log p(yn|θ) (6.144)
= −DKL (qn(zn) k p(zn|yn, θ)) + log p(yn|θ) (6.145)
where DKL (q k p) ,
P
z
q(z)log q(z)
p(z)
is the Kullback-Leibler divergence (or KL divergence for short)
between probability distributions q and p. We discuss this in more detail in Section 5.1, but the key
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.5. BOUND OPTIMIZATION (MM) ALGORITHMS
property we need here is that DKL (q k p) ≥ 0 and DKL (q k p) = 0 iff q = p. Hence we can maximize
the lower bound Ł(θ, {qn}|D) wrt {qn} by setting each one to q
∗
n = p(zn|yn, θ). This is called the E
step. This ensures the ELBO is a tight lower bound:
Ł(θ, {q
∗
n}|D) = X
n
log p(yn|θ) = ℓ(θ|D) (6.146)
To see how this connects to bound optimization, let us define
Q(θ, θ
t
) = Ł(θ, {p(zn|yn; θ
t
)}) (6.147)
Then we have Q(θ, θ
t
) ≤ ℓ(θ) and Q(θ
t
, θ
t
) = ℓ(θ
t
), as required.
However, if we cannot compute the posteriors p(zn|yn; θ
t
) exactly, we can still use an approximate
distribution q(zn|yn; θ
t
); this will yield a non-tight lower-bound on the log-likelihood. This generalized
version of EM is known as variational EM [NH98b]. See Section 6.5.6.1 for details.
6.5.3.3 M step
In the M step, we need to maximize Ł(θ, {q
t
n}) wrt θ, where the q
t
n are the distributions computed
in the E step at iteration t. Since the entropy terms H(qn) are constant wrt θ, we can drop them in
the M step. We are left with
ℓ
t
(θ) = X
n
Eq
t
n(zn)
[log p(yn, zn|θ)] (6.148)
This is called the expected complete data log likelihood. If the joint probability is in the
exponential family (Section 2.4), we can rewrite this as
ℓ
t
(θ) = X
n
E

T (yn, zn)
Tθ − A(θ)

=
X
n
(E [T (yn, zn)]
T
θ − A(θ)) (6.149)
where E [T (yn, zn)] are called the expected sufficient statistics.
In the M step, we maximize the expected complete data log likelihood to get
θ
t+1 = arg max
θ
X
n
Eq
t
n
[log p(yn, zn|θ)] (6.150)
In the case of the exponential family, the maximization can be solved in closed-form by matching the
moments of the expected sufficient statistics (Section 2.4.5).
We see from the above that the E step does not in fact need to return the full set of posterior
distributions
P
{q(zn)}, but can instead just return the sum of the expected sufficient statistics,
n Eq(zn)
[T (yn, zn)].
A common application of EM is for fitting mixture models; we discuss this in the prequel to this
book, [Mur22]. Below we give a different example.
6.5.4 Example: EM for an MVN with missing data
It is easy to compute the MLE for a multivariate normal when we have a fully observed data matrix:
we just compute the sample mean and covariance. In this section, we consider the case where we have
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license286
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
missing data or partially observed data. For example, we can think of the entries of Y as being
answers to a survey; some of these answers may be unknown. There are many kinds of missing data,
as we discuss in Section 3.11. In this section, we make the missing at random (MAR) assumption,
for simplicity. Under the MAR assumption, the log likelihood of the visible data has the form
log p(X|θ) = X
n
log p(xn|θ) = X
n
log Z
p(xn, zn|θ)dzn

(6.151)
where xn are the visible variables in case n, zn are the hidden variables, and yn = (zn, xn) are all
the variables. Unfortunately, this objective is hard to maximize. since we cannot push the log inside
the expectation. Fortunately, we can easily apply EM, as we explain below.
6.5.4.1 E step
Suppose we have the parameters θ
t−1
from the previous iteration. Then we can compute the expected
complete data log likelihood at iteration t as follows:
Q(θ, θ
t−1
) = E
"X
N
n=1
log N (yn|µ, Σ)|D, θ
t−1
#
(6.152)
= −
N
2
log |2πΣ| − 1
2
X
n
E

(yn − µ)
TΣ
−1
(yn − µ)

(6.153)
= −
N
2
log |2πΣ| − 1
2
tr(Σ
−1X
n
E

(yn − µ)(yn − µ)
T

(6.154)
= −
N
2
log |Σ| − ND
2
log(2π) −
1
2
tr(Σ
−1E [S(µ)]) (6.155)
where
E [S(µ)] ,
X
n

E

yny
T
n

+ µµT − 2µE [yn]
T

(6.156)
(We drop the conditioning of the expectation on D and θ
t−1
for brevity.) We see that we need to
compute P
n E [yn] and P
n E

yny
T
n

; these are the expected sufficient statistics.
To compute these quantities, we use the results from Section 2.3.1.3. We have
p(zn|xn, θ) = N (zn|mn, Vn) (6.157)
mn , µh + ΣhvΣ
−1
vv
(xn − µv
) (6.158)
Vn , Σhh − ΣhvΣ
−1
vv Σvh (6.159)
where we partition µ and Σ into blocks based on the hidden and visible indices h and v. Hence the
expected sufficient statistics are
E [yn] = (E [zn] ; xn) = (mn; xn) (6.160)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.5. BOUND OPTIMIZATION (MM) ALGORITHMS
To compute E

yny
T
n

, we use the result that Cov [y] = E

yyT

− E [y] E

y
T

. Hence
E

yny
T
n

= E
zn
xn

￾
z
T
n x
T
n


=

E

znz
T
n

E [zn] x
T
n
xnE [zn]
T
xnx
T
n

(6.161)
E

znz
T
n

= E [zn] E [zn]
T + Vn (6.162)
6.5.4.2 M step
By solving ∇Q(θ, θ
(t−1)) = 0, we can show that the M step is equivalent to plugging these ESS into
the usual MLE equations to get
µ
t =
1
N
X
n
E [yn] (6.163)
Σ
t =
1
N
X
n
E

yny
T
n

− µ
t
(µ
t
)
T
(6.164)
Thus we see that EM is not equivalent to simply replacing variables by their expectations and
applying the standard MLE formula; that would ignore the posterior variance and would result in an
incorrect estimate. Instead we must compute the expectation of the sufficient statistics, and plug
that into the usual equation for the MLE.
6.5.4.3 Initialization
To get the algorithm started, we can compute the MLE based on those rows of the data matrix that
are fully observed. If there are no such rows, we can just estimate the diagonal terms of Σ using the
observed marginal statistics. We are then ready to start EM.
6.5.4.4 Example
As an example of this procedure in action, let us consider an imputation problem, where we have
N = 100 10-dimensional data cases, which we assume to come from a Gaussian. We generate
synthetic data where 50% of the observations are missing at random. First we fit the parameters
using EM. Call the resulting parameters θˆ. We can now use our model for predictions by computing
E
h
zn|xn, θˆ
i
. Figure 6.8 indicates that the results obtained using the learned parameters are almost
as good as with the true parameters. Not surprisingly, performance improves with more data, or as
the fraction of missing data is reduced.
6.5.5 Example: robust linear regression using Student likelihood
In this section, we discuss how to use EM to fit a linear regression model that uses the Student
distribution for its likelihood, instead of the more common Gaussian distribution, in order to achieve
robustness, as first proposed in [Zel76]. More precisely, the likelihood is given by
p(y|x, w, σ2
, ν) = T (y|wTx, σ2
, ν) (6.165)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens288
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2 0 2
Truth
1
0
1
Imputed
R^2 = 0.411
2 1 0 1 2
Truth
0
2
Imputed
R^2 = 0.443
4 2 0 2
Truth
2
0
2
Imputed
R^2 = 0.597
1 0 1 2
Truth
0
1
2
Imputed
R^2 = 0.390
Imputation with true parameters
(a)
2 0 2
Truth
1
0
1
Imputed
R^2 = 0.247
2 1 0 1 2
Truth
2
0
2
Imputed
R^2 = 0.438
4 2 0 2
Truth
2
0
Imputed
R^2 = 0.238
1 0 1 2
Truth
0
1
Imputed
R^2 = 0.263
Imputation with EM estimated parameters
(b)
Figure 6.8: Illustration of data imputation using a multivariate Gaussian. (a) Scatter plot of true values vs
imputed values using true parameters. (b) Same as (a), but using parameters estimated with EM. We just
show the first four variables, for brevity. Generated by gauss_imputation_em_demo.ipynb.
At first blush it may not be apparent how to do this, since there is no missing data, and there
are no hidden variables. However, it turns out that we can introduce “artificial” hidden variables to
make the problem easier to solve; this is a common trick. The key insight is that we can represent
the Student distribution as a Gaussian scale mixture, as we discuss in Section 28.2.3.1.
We can apply the GSM version of the Student distribution to our problem by associating a latent
scale zn ∈ R+ with each example. The complete data log likelihood is therefore given by
log p(y, z|X, w, σ2
, ν) = X
n
−
1
2
log(2πznσ
2
) −
1
2znσ
2
(yi − wT xi)
2
(6.166)
+ (ν
2
− 1) log(zn) − zn
ν
2
+ const (6.167)
Ignoring terms not involving w, and taking expectations, we have
Q(θ, θ
t
) = −
X
n
λn
2σ
2
(yn − wT xn)
2
(6.168)
where λ
t
n , E [1/zn|yn, xn, wt
]. We recognize this as a weighted least squares objective, with weight
λ
t
n per datapoint.
We now discuss how to compute these weights. Using the results from Section 2.2.3.4, one can
show that
p(zn|yn, xn, θ) = IG(ν + 1
2
,
ν + δn
2
) (6.169)
where δn =
(yn−x
T xn)
2
σ2 is the standardized residual. Hence
λn = E [1/zn] = ν
t + 1
ν
t + δ
t
n
(6.170)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.5. BOUND OPTIMIZATION (MM) ALGORITHMS
0 1 2 3 4
training time
0.6
0.8
1.0
true log-likelihood
lower bound
(a)
0 1 2 3 4
training time
0.6
0.8
1.0
true log-likelihood
lower bound
(b)
Figure 6.9: Illustration of possible behaviors of variational EM. (a) The lower bound increases at each
iteration, and so does the likelihood. (b) The lower bound increases but the likelihood decreases. In this case,
the algorithm is closing the gap between the approximate and true posterior. This can have a regularizing
effect. Adapted from Figure 6 of [SJJ96]. Generated by var_em_bound.ipynb.
So if the residual δ
t
n
is large, the point will be given low weight λ
t
n
, which makes intuitive sense, since
it is probably an outlier.
6.5.6 Extensions to EM
There are many variations and extensions of the EM algorithm, as discussed in [MK97]. We summarize
a few of these below.
6.5.6.1 Variational EM
Suppose in the E step we pick q
∗
n = argminqn∈Q DKL (qn k p(zn|xn, θ)). Because we are optimizing
over the space of functions, this is called variational inference (see Section 10.1 for details). If the
family of distributions Q is rich enough to contain the true posterior, qn = p(zn|xn, θ), then we can
make the KL be zero. But in general, we might choose a more restrictive class for computational
reasons. For example, we might use qn(zn) = N (zn|µn, diag(σn)) even if the true posterior is
correlated.
The use of a restricted posterior family Q inside the E step of EM is called variational EM
[NH98a]. Unlike regular EM, variational EM is not guaranteed to increase the actual log likelihood
itself (see Figure 6.9), but it does monotonically increase the variational lower bound. We can control
the tightness of this lower bound by varying the variational family Q; in the limit in which qn = pn,
corresponding to exact inference, we recover the same behavior as regular EM. See Section 10.1.3 for
further discussion.
6.5.6.2 Hard EM
Suppose we use a degenerate posterior approximation in the context of variational EM, corresponding
to a point estimate, q(z|xn) = δzˆn
(z), where zˆn = argmaxz p(z|xn). This is equivalent to hard
EM, where we ignore uncertainty about zn in the E step.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license290
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The problem with this degenerate approach is that it is very prone to overfitting, since the number
of latent variables is proportional to the number of datacases [WCS08].
6.5.6.3 Monte Carlo EM
Another approach to handling an intractable E step is to use a Monte Carlo approximation to the
expected sufficient statistics. That is, we draw samples from the posterior, z
s
n ∼ p(zn|xn, θ
t
); then
we compute the sufficient statistics for each completed vector, (xn, z
s
n
); and finally we average the
results. This is called Monte Carlo EM or MCEM [WT90; Nea12].
One way to draw samples is to use MCMC (see Chapter 12). However, if we have to wait for
MCMC to converge inside each E step, the method becomes very slow. An alternative is to use
stochastic approximation, and only perform “brief” sampling in the E step, followed by a partial
parameter update. This is called stochastic approximation EM [DLM99] and tends to work
better than MCEM.
6.5.6.4 Generalized EM
Sometimes we can perform the E step exactly, but we cannot perform the M step exactly. However,
we can still monotonically increase the log likelihood by performing a “partial” M step, in which we
merely increase the expected complete data log likelihood, rather than maximizing it. For example,
we might follow a few gradient steps. This is called the generalized EM or GEM algorithm [MK07].
(This is an unfortunate term, since there are many ways to generalize EM, but it is the standard
terminology.) For example, [Lan95a] proposes to perform one Newton-Raphson step:
θt+1 = θt − ηtH−1
t gt (6.171)
where 0 < ηt ≤ 1 is the step size, and
gt =
∂
∂θ
Q(θ, θt)|θ=θt
(6.172)
Ht =
∂
2
∂θ∂θ
T
Q(θ, θt)|θ=θt
(6.173)
If ηt = 1, [Lan95a] calls this the gradient EM algorithm. However, it is possible to use a larger
step size to speed up the algorithm, as in the quasi-Newton EM algorithm of [Lan95b]. This
method also replaces the Hessian in Equation (6.173), which may not be negative definite (for non
exponential family models), with a BFGS approximation. This ensures the overall algorithm is an
ascent algorithm. Note, however, when the M step cannot be computed in closed form, EM loses
some of its appeal over directly optimizing the marginal likelihood with a gradient based solver.
6.5.6.5 ECM algorithm
The ECM algorithm stands for “expectation conditional maximization”, and refers to optimizing the
parameters in the M step sequentially, if they turn out to be dependent. The ECME algorithm,
which stands for “ECM either” [LR95], is a variant of ECM in which we maximize the expected
complete data log likelihood (the Q function) as usual, or the observed data log likelihood, during
one or more of the conditional maximization steps. The latter can be much faster, since it ignores
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.6. BAYESIAN OPTIMIZATION
the results of the E step, and directly optimizes the objective of interest. A standard example of
this is when fitting the Student distribution. For fixed ν, we can update Σ as usual, but then to
update ν, we replace the standard update of the form ν
t+1 = arg maxν Q((µ
t+1
, Σ
t+1, ν), θ
t
) with
ν
t+1 = arg maxν log p(D|µ
t+1
, Σ
t+1, ν). See [MK97] for more information.
6.5.6.6 Online EM
When dealing with large or streaming datasets, it is important to be able to learn online, as we
discussed in Section 19.7.5. There are two main approaches to online EM in the literature. The
first approach, known as incremental EM [NH98a], optimizes the lower bound Q(θ, q1, . . . , qN )
one qn at a time; however, this requires storing the expected sufficient statistics for each data case.
The second approach, known as stepwise EM [SI00; LK09; CM09], is based on stochastic gradient
descent. This optimizes a local upper bound on ℓn(θ) = log p(xn|θ) at each step. (See [Mai13;
Mai15] for a more general discussion of stochastic and incremental bound optimization algorithms.)
6.6 Bayesian optimization
In this section, we discuss Bayesian optimization or BayesOpt, which is a model-based approach
to black-box optimization, designed for the case where the objective function f : X → R is expensive
to evaluate (e.g., if it requires running a simulation, or training and testing a particular neural net
architecture).
Since the true function f is expensive to evaluate, we want to make as few function calls (i.e., make as
few queries x to the oracle f) as possible. This suggests that we should build a surrogate function
(also called a response surface model) based on the data collected so far, Dn = {(xi
, yi) : i = 1 : n},
which we can use to decide which point to query next. There is an inherent tradeoff between picking
the point x where we think f(x) is large (we follow the convention in the literature and assume
we are trying to maximize f), and picking points where we are uncertain about f(x) but where
observing the function value might help us improve the surrogate model. This is another instance of
the exploration-exploitation dilemma.
In the special case where the domain we are optimizing over is finite, so X = {1, . . . , A}, the
BayesOpt problem becomes similar to the best arm identification problem in the bandit literature
(Section 34.4). An important difference is that in bandits, we care about the cost of every action we
take, whereas in optimization, we usually only care about the cost of the final solution we find. In
other words, in bandits, we want to minimize cumulative regret, whereas in optimization we want to
minimize simple or final regret.
Another related topic is active learning. Here the goal is to identify the whole function f with
as few queries as possible, whereas in BayesOpt, the goal is just to identify the maximum of the
function.
Bayesian optimization is a large topic, and we only give a brief overview below. For more details,
see e.g., [Sha+16; Fra18; Gar23]. (See also https://distill.pub/2020/bayesian-optimization/
for an interactive tutorial.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license292
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.6.1 Sequential model-based optimization
BayesOpt is an instance of a strategy known as sequential model-based optimization (SMBO)
[HHLB11]. In this approach, we alternate between querying the function at a point, and updating
our estimate of the surrogate based on the new data. More precisely, at each iteration n, we have
a labeled dataset Dn = {(xi
, yi) : i = 1 : n}, which records points xi that we have queried, and
the corresponding function values, yi = f(xi) + ǫi
, where ǫi
is an optional noise term. We use
this dataset to estimate a probability distribution over the true function f; we will denote this by
p(f|Dn). We then choose the next point to query xn+1 using an acquisition function α(x; Dn),
which computes the expected utility of querying x. (We discuss acquisition functions in Section 6.6.3).
After we observe yn+1 = f(xn+1) + ǫn+1, we update our beliefs about the function, and repeat. See
Algorithm 6.5 for some pseudocode.
Algorithm 6.5: Bayesian optimization
1 Collect initial dataset D0 = {(xi
, yi)} from random queries xi or a space-filling design
2 Initialize model by computing p(f|D0)
3 for n = 1, 2, . . . until convergence do
4 Choose next query point xn+1 = argmaxx∈X α(x; Dn)
5 Measure function value, yn+1 = f(xn+1) + ǫn
6 Augment dataset, Dn+1 = {Dn,(xn+1, yn+1)}
7 Update model by computing p(f|Dn+1)
This method is illustrated in Figure 6.10. The goal is to find the global optimum of the solid black
curve. In the first row, we show the 2 previously queried points, x1 and x2, and their corresponding
function values. y1 = f(x1) and y2 = f(x2). Our uncertainty about the value of f at those locations
is 0 (if we assume no observation noise), as illustrated by the posterior credible interval (shaded
blue are) becoming “pinched”. Consequently the acquisition function (shown in green at the bottom)
also has value 0 at those previously queried points. The red triangle represents the maximum of the
acquisition function, which becomes our next query, x3. In the second row, we show the result of
observing y3 = f(x3); this further reduces our uncertainty about the shape of the function. In the
third row, we show the result of observing y4 = f(x4). This process repeats until we run out of time,
or until we are confident there are no better unexplored points to query.
The two main “ingredients” that we need to provide to a BayesOpt algorithm are (1) a way to
represent and update the posterior surrogate p(f|Dn), and (2) a way to define and optimize the
acquisition function α(x; Dn). We discuss both of these topics below.
6.6.2 Surrogate functions
In this section, we discuss ways to represent and update the posterior over functions, p(f|Dn).
6.6.2.1 Gaussian processes
In BayesOpt, it is very common to use a Gaussian process or GP for our surrogate. GPs are
explained in detail in Chapter 18, but the basic idea is that they represent p(f(x)|Dn) as a Gaussian,
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.6. BAYESIAN OPTIMIZATION
Figure 6.10: Illustration of sequential Bayesian optimization over three iterations. The rows correspond to a
training set of size t = 2, 3, 4. The dotted black line is the true, but unknown, function f(x). The solid black
line is the posterior mean, µ(x). The shaded blue intervals are the 95% credible interval derived from µ(x)
and σ(x). The solid black dots correspond to points whose function value has already been computed, i.e.,
xn for which f(xn) is known. The green curve at the bottom is the acquisition function. The red dot is the
proposed next point to query, which is the maximum of the acquisition function. From Figure 1 of [Sha+16].
Used with kind permission of Nando de Freitas.
p(f(x)|Dn) = N (f|µn(x), σ2
n
(x)), where µn(x) and σn(x) are functions that can be derived from
the training data Dn = {(xi
, yi) : i = 1 : n} using a simple closed-form equation. The GP requires
specifying a kernel function Kθ(x, x
′
), which measures similarities between input points x, x
′
. The
intuition is that if two inputs are similar, so Kθ(x, x
′
) is large, then the corresponding function values
are also likely to be similar, so f(x) and f(x
′
) should be positively correlated. This allows us to
interpolate the function between the labeled training points; in some cases, it also lets us extrapolate
beyond them.
GPs work well when we have little training data, and they support closed form Bayesian updating.
However, exact updating takes O(N3
) for N samples, which becomes too slow if we perform many
function evaluations. There are various methods (Section 18.5.3) for reducing this to O(NM2
) time,
where M is a parameter we choose, but this sacrifices some of the accuracy.
In addition, the performance of GPs depends heavily on having a good kernel. We can estimate the
kernel parameters θ by maximizing the marginal likelihood, as discussed in Section 18.6.1. However,
since the sample size is small (by assumption), we can often get better performance by marginalizing
out θ using approximate Bayesian inference methods, as discussed in Section 18.6.2. See e.g., [WF16]
for further details.
6.6.2.2 Bayesian neural networks
A natural alternative to GPs is to use a parametric model. If we use linear regression, we can
efficiently perform exact Bayesian inference, as shown in Section 15.2. If we use a nonlinear model,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license294
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
such as a DNN, we need to use approximate inference methods. We discuss Bayesian neural networks
in detail in Chapter 17. For their application to BayesOpt, see e.g., [Spr+16; PPR22; Kim+22].
6.6.2.3 Other models
We are free to use other forms of regression model. [HHLB11] use an ensemble of random forests;
such models can easily handle conditional parameter spaces, as we discuss in Section 6.6.4.2, although
bootstrapping (which is needed to get uncertainty estimates) can be slow.
6.6.3 Acquisition functions
In BayesOpt, we use an acquisition function (also called a merit function) to evaluate the
expected utility of each possible point we could query: α(x|Dn) = Ep(y|x,Dn)
[U(x, y; Dn)], where
y = f(x) is the unknown value of the function at point x, and U() is a utility function. Different
utility functions give rise to different acquisition functions, as we discuss below. We usually choose
functions so that the utility of picking a point that has already been queried is small (or 0, in the
case of noise-free observations), in order to encourage exploration.
6.6.3.1 Probability of improvement
Let us define Mn = maxn
i=1 yi to be the best value observed so far (known as the incumbent).
(If the observations are noisy, using the highest mean value maxi Ep(f|Dn)
[f(xi)] is a reasonable
alternative [WF16].) Then we define the utility of some new point x using U(x, y; Dn) = I(y > Mn).
This gives reward iff the new value is better than the incumbent. The corresponding acquisition
function is then given by the expected utility, αP I (x; Dn) = p(f(x) > Mn|Dn). This is known as the
probability of improvement [Kus64]. If p(f|Dn) is a GP, then this quantity can be computed in
closed form, as follows:
αP I (x; Dn) = p(f(x) > Mn|Dn) = Φ(γn(x, Mn)) (6.174)
where Φ is the cdf of the N (0, 1) distribution and
γn(x, τ ) = µn(x) − τ
σn(x)
(6.175)
6.6.3.2 Expected improvement
The problem with PI is that all improvements are considered equally good, so the method tends
to exploit quite aggressively [Jon01]. A common alternative takes into account the amount of
improvement by defining U(x, y; Dn) = (y − Mn)I(y > Mn) and
αEI (x; Dn) = EDn
[U(x, y)] = EDn
[(f(x) − Mn)I(f(x) > Mn)] (6.176)
This acquisition function is known as the expected improvement (EI) criterion [Moc+96]. In the
case of a GP surrogate, this has the following closed form expression:
αEI (x; Dn) = (µn(x) − Mn)Φ(γ) + σn(x)φ(γ) = σn(x)[γnΦ(γ) + φ(γ)] (6.177)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.6. BAYESIAN OPTIMIZATION
Figure 6.11: The first row shows the objective function, (the Branin function defined on R
2
), and its posterior
mean and variance using a GP estimate. White dots are the observed data points. The second row shows
3 different acquisition functions (probability of improvement, expected improvement, and upper confidence
bound); the white triangles are the maxima of the corresponding acquisition functions. From Figure 6 of
[BCF10]. Used with kind permission of Nando de Freitas.
where φ() is the pdf of the N (0, 1) distribution, Φ is the cdf, and γ = γn(x, Mn). The first
term encourages exploitation (evaluating points with high mean) and the second term encourages
exploration (evaluating points with high variance). This is illustrated in Figure 6.10.
If we cannot compute the predictive variance analytically, but can draw posterior samples, then
we can compute a Monte Carlo approximation to the EI, as proposed in [Kim+22]:
αEI (x; Dn) ≈
1
S
X
S
s=1
max(µ
s
n
(x) − Mn, 0) (6.178)
6.6.3.3 Upper confidence bound (UCB)
An alternative approach is to compute an upper confidence bound or UCB on the function, at
some confidence level βn, and then to define the acquisition function as follows: αUCB(x; Dn) =
µn(x) + βnσn(x). This is the same as in the contextual bandit setting, discussed in Section 34.4.5,
except we are optimizing over x ∈ X , rather than a finite set of arms a ∈ {1, . . . , A}. If we use a GP
for our surrogate, the method is known as GP-UCB [Sri+10].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license296
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.6.3.4 Thompson sampling
We discuss Thompson sampling in Section 34.4.6 in the context of multiarmed bandits, where
the state space is finite, X = {1, . . . , A}, and the acquisition function α(a; Dn) corresponds to the
probability that arm a is the best arm. We can generalize this to real-valued input spaces X using
α(x; Dn) = Ep(θ|Dn)

I

x = argmax
x′
fθ(x
′
)
 (6.179)
We can compute a single sample approximation to this integral by sampling θ˜ ∼ p(θ|Dn). We can
then pick the optimal action as follows:
xn+1 = argmax
x
α(x; Dn) = argmax
x
I

x = argmax
x′
fθ˜(x
′
)

= argmax
x
fθ˜(x) (6.180)
In other words, we greedily maximize the sampled surrogate.
For continuous spaces, Thompson sampling is harder to apply than in the bandit case, since we
can’t directly compute the best “arm” xn+1 from the sampled function. Furthermore, when using
GPs, there are some subtle technical difficulties with sampling a function, as opposed to sampling
the parameters of a parametric surrogate model (see [HLHG14] for discussion).
6.6.3.5 Entropy search
Since our goal in BayesOpt is to find x
∗ = argmaxx f(x), it makes sense to try to directly minimize
our uncertainty about the location of x
∗
, which we denote by p∗(x|Dn). We will therefore define the
utility as follows:
U(x, y; Dn) = H (x
∗
|Dn) − H (x
∗
|Dn ∪ {(x, y)}) (6.181)
where H (x
∗
|Dn) = H (p∗(x|Dn)) is the entropy of the posterior distribution over the location of the
optimum. This is known as the information gain criterion; the difference from the objective used in
active learning is that here we want to gain information about x
∗
rather than about f for all x. The
corresponding acquisition function is given by
αES(x; Dn) = Ep(y|x,Dn)
[U(x, y; Dn)] = H (x
∗
|Dn) − Ep(y|x,Dn)
[H (x
∗
|Dn ∪ {(x, y)})] (6.182)
This is known as entropy search [HS12].
Unfortunately, computing H (x
∗
|Dn) is hard, since it requires a probability model over the input
space. Fortunately, we can leverage the symmetry of mutual information to rewrite the acquisition
function in Equation (6.182) as follows:
αP ES(x; Dn) = H (y|Dn, x) − Ex∗|Dn
[H (y|Dn, x, x
∗
)] (6.183)
where we can approximate the expectation from p(x
∗
|Dn) using Thompson sampling. Now we just
have to model uncertainty about the output space y. This is known as predictive entropy search
[HLHG14].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.6. BAYESIAN OPTIMIZATION
6.6.3.6 Knowledge gradient
So far the acquisition functions we have considered are all greedy, in that they only look one step
ahead. The knowledge gradient acquisition function, proposed in [FPD09], looks two steps ahead
by considering the improvement we might expect to get if we query x, update our posterior, and
then exploit our knowledge by maximizing wrt our new beliefs. More precisely, let us define the best
value we can find if we query one more point:
Vn+1(x, y) = max
x′
Ep(f|x,y,Dn)
[f(x
′
)] (6.184)
Vn+1(x) = Ep(y|x,Dn)
[Vn+1(x, y)] (6.185)
We define the KG acquisition function as follows:
αKG(x; Dn) = EDn
[(Vn+1(x) − Mn)I(Vn+1(x) > Mn)] (6.186)
Compare this to the EI function in Equation (6.176).) Thus we pick the point xn+1 such that
observing f(xn+1) will give us knowledge which we can then exploit, rather than directly trying to
find a better point with better f value.
6.6.3.7 Optimizing the acquisition function
The acquisition function α(x) is often multimodal (see e.g., Figure 6.11), since it will be 0 at all the
previously queried points (assuming noise-free observations). Consequently maximizing this function
can be a hard subproblem in itself [WHD18; Rub+20].
In the continuous setting, it is common to use multirestart BFGS or grid search. We can also use
the cross-entropy method (Section 6.7.5), using mixtures of Gaussians [BK10] or VAEs [Fau+18] as
the generative model over x. In the discrete, combinatorial setting (e.g., when optimizing biological
sequences), [Bel+19] use regularized evolution, (Section 6.7.3), and [Ang+20] use proximial policy
optimization (Section 35.3.4). Many other combinations are possible.
6.6.4 Other issues
There are many other issues that need to be tackled when using Bayesian optimization, a few of
which we briefly mention below.
6.6.4.1 Parallel (batch) queries
In some cases, we want to query the objective function at multiple points in parallel; this is known as
batched Bayesian optimization. Now we need to optimize over a set of possible queries, which is
computationally even more difficult than the regular case. See [WHD18; DBB20] for some recent
papers on this topic.
6.6.4.2 Conditional parameters
BayesOpt is often applied to hyper-parameter optimization. In many applications, some hyperparam￾eters are only well-defined if other ones take on specific values. For example, suppose we are trying
to automatically tune a classifier, as in the Auto-Sklearn system [Feu+15], or the Auto-WEKA
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license298
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
system [Kot+17]. If the method chooses to use a neural network, it also needs to specify the number
of layers, and number of hidden units per layer; but if it chooses to use a decision tree, it instead
should specify different hyperparameters, such as the maximum tree depth.
We can formalize such problems by defining the search space in terms of a tree or DAG (directed
acyclic graph), where different subsets of the parameters are defined at each leaf. Applying GPs to
this setting requires non-standard kernels, such as those discussed in [Swe+13; Jen+17]. Alternatively,
we can use other forms of Bayesian regression, such as ensembles of random forests [HHLB11], which
can easily handle conditional parameter spaces.
6.6.4.3 Multifidelity surrogates
In some cases, we can construct surrogate functions with different levels of accuracy, each of which
may take variable amounts of time to compute. In particular, let f(x, s) be an approximation to
the true function at x with fidelity s. The goal is to solve maxx f(x, 0) by observing f(x, s) at a
sequence of (xi
, si) values, such that the total cost Pn
i=1 c(si) is below some budget. For example, in
the context of hyperparameter selection, s may control how long we run the parameter optimizer for,
or how large the validation set is.
In addition to choosing what fidelity to use for an experiment, we may choose to terminate
expensive trials (queries) early, if the results of their cheaper proxies suggest they will not be worth
running to completion (see e.g., [Str19; Li+17c; FKH17]). Alternatively, we may choose to resume
an earlier aborted run, to collect more data on it, as in the freeze-thaw algorithm [SSA14].
6.6.4.4 Constraints
If we want to maximize a function subject to known constraints, we can simply build the constraints
into the acquisition function. But if the constraints are unknown, we need to estimate the support
of the feasible set in addition to estimating the function. In [GSA14], they propose the weighted
EI criterion, given by αwEI (x; Dn) = αEI (x; Dn)h(x; Dn), where h(x; Dn) is a GP with a Bernoulli
observation model that specifies if x is feasible or not. Of course, other methods are possible. For
example, [HL+16b] propose a method based on predictive entropy search.
6.7 Derivative-free optimization
Derivative-free optimization or DFO refers to a class of techniques for optimizing functions
without using derivatives. This is useful for blackbox function optimization as well as discrete
optimization. If the function is expensive to evaliate, we can use Bayesian optimization (Section 6.6).
If the function is cheap to evaluate, we can use stochastic local search methods or evolutionary search
methods, as we discuss below.
6.7.1 Local search
In this section, we discuss heuristic optimization algorithms that try to find the global maximum
in a discrete, unstructured search space. These algorithms replace the local gradient based update,
which has the form θt+1 = θt + ηtdt, with the following discrete analog:
xt+1 = argmax
x∈nbr(xt)
L(x) (6.187)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.7. DERIVATIVE-FREE OPTIMIZATION
where nbr(xt) ⊆ X is the set of neighbors of xt. This is called hill climbing, steepest ascent,
or greedy search.
If the “neighborhood” of a point contains the entire space, Equation (6.187) will return the global
optimum in one step, but usually such a global neighborhood is too large to search exhaustively.
Consequently we usually define local neighborhoods. For example, consider the 8-queens problem.
Here the goal is to place queens on an 8 × 8 chessboard so that they don’t attack each other (see
Figure 6.14). The state space has the form X = 648
, since we have to specify the location of each
queen on the grid. However, due to the constraints, there are only 8
8 ≈ 17M feasible states. We
define the neighbors of a state to be all possible states generated by moving a single queen to another
square in the same column, so each node has 8 × 7 = 56 neighbors. According to [RN10, p.123], if we
start at a randomly generated 8-queens state, steepest ascent gets stuck at a local maximum 86% of
the time, so it only solves 14% of problem instances. However, it is fast, taking an average of 4 steps
when it succeeds and 3 when it gets stuck.
In the sections below, we discuss slightly smarter algorithms that are less likely to get stuck in
local maxima.
6.7.1.1 Stochastic local search
Hill climbing is greedy, since it picks the best point in its local neighborhood, by solving Equa￾tion (6.187) exactly. One way to reduce the chance of getting stuck in local maxima is to approximately
maximize this objective at each step. For example, we can define a probability distribution over the
uphill neighbors, proportional to how much they improve, and then sample one at random. This is
called stochastic hill climbing. If we gradually decrease the entropy of this probability distribution
(so we become greedier over time), we get a method called simulated annealing, which we discuss in
Section 12.9.1.
Another simple technique is to use greedy hill climbing, but then whenever we reach a local
maximum, we start again from a different random starting point. This is called random restart
hill climbing. To see the benefit of this, consider again the 8-queens problem. If each hill-climbing
search has a probability of p ≈ 0.14 of success, then we expect to need R = 1/p ≈ 7 restarts until we
find a valid solution. The expected number of total steps can be computed as follows. Let N1 = 4
be the average number of steps for successful trials, and N0 = 3 be the average number of steps for
failures. Then the total number of steps on average is N1 + (R − 1)N0 = 4 + 6 × 3 = 22. Since each
step is quick, the overall method is very fast. For example, it can solve an n-queens problem with
n =1M in under a minute.
Of course, solving the n-queens problem is not the most useful task in practice. However, it is
typical of several real-world boolean satisfiability problems, which arise in problems ranging
from AI planning to model checking (see e.g., [SLM92]). In such problems, simple stochastic local
search (SLS) algorithms of the kind we have discussed work surprisingly well (see e.g., [HS05]).
6.7.1.2 Tabu search
Hill climbing will stop as soon as it reaches a local maximum or a plateau. Obviously one can perform
a random restart, but this would ignore all the information that had been gained up to this point. A
more intelligent alternative is called tabu search [GL97]. This is like hill climbing, except it allows
moves that decrease (or at least do not increase) the scoring function, provided the move is to a new
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license300
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Algorithm 6.6: Tabu search.
1 t := 0 // counts iterations
2 c := 0 // counts number of steps with no progress
3 Initialize x0
4 x
∗
:= x0 // current best incumbent
5 while c < cmax do
6 xt+1 = argmaxx∈nbr(xt)\{xt−τ ,...,xt−1} f(x)
7 if f(xt+1) > f(x
∗
) then
8 x
∗
:= xt+1
9 c := 0
10 else
11 c := c + 1
12 t := t + 1
13 return x
∗
state that has not been seen before. We can enforce this by keeping a tabu list which tracks the
τ most recently visited states. This forces the algorithm to explore new states, and increases the
chances of escaping from local maxima. We continue to do this for up to cmax steps (known as the
“tabu tenure”). The pseudocode can be found in Algorithm 6.6. (If we set cmax = 1, we get greedy
hill climbing.)
For example, consider what happens when tabu search reaches a hill top, xt. At the next step, it
will move to one of the neighbors of the peak, xt+1 ∈ nbr(xt), which will have a lower score. At the
next step, it will move to the neighbor of the previous step, xt+2 ∈ nbr(xt+1); the tabu list prevents
it cycling back to xt (the peak), so it will be forced to pick a neighboring point at the same height or
lower. It continues in this way, “circling” the peak, possibly being forced downhill to a lower level-set
(an inverse basin flooding operation), until it finds a ridge that leads to a new peak, or until it
exceeds a maximum number of non-improving moves.
According to [RN10, p.123], tabu search increases the percentage of 8-queens problems that can
be solved from 14% to 94%, although this variant takes an average of 21 steps for each successful
instance and 64 steps for each failed instance.
6.7.1.3 Random search
A surprisingly effective strategy in problems where we know nothing about the objective is to use
random search. In this approach, each iterate xt+1 is chosen uniformly at random from X . This
should always be tried as a baseline.
In [BB12], they applied this technique to the problem of hyper-parameter optimization for some
ML models, where the objective is performance on a validation set. In their examples, the search
space is continuous, Θ = [0, 1]D. It is easy to sample from this at random. The standard alternative
approach is to quantize the space into a fixed set of values, and then to evaluate them all; this is
known as grid search. (Of course, this is only feasible if the number of dimensions D is small.)
They found that random search outperformed grid search. The intuitive reason for this is that many
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.7. DERIVATIVE-FREE OPTIMIZATION
Figure 6.12: Illustration of grid search (left) vs random search (right). From Figure 1 of [BB12]. Used with
kind permission of James Bergstra.
hyper-parameters do not make much difference to the objective function, as illustrated in Figure 6.12.
Consequently it is a waste of time to place a fine grid along such unimportant dimensions.
RS has also been used to optimize the parameters of MDP policies, where the objective has
the form f(x) = Eτ∼πx
[R(τ )] is the expected reward of trajectories generated by using a policy
with parameters x. For policies with few free parameters, RS can outperform more sophisticated
reinforcement learning methods described in Chapter 35, as shown in [MGR18]. In cases where
the policy has a large number of parameters, it is sometimes possible to project them to a lower
dimensional random subspace, and perform optimization (either grid search or random search) in
this subspace [Li+18a].
6.7.2 Simulated annealing
Simulated annealing [KJV83; LA87] is a stochastic local search algorithm (Section 6.7.1.1) that
attempts to find the global minimum of a black-box function E(x), where E() is known as the energy
function. The method works by converting the energy to an (unnormalized) probability distribution
over states by defining p(x) = exp(−E(x)), and then using a variant of the Metropolis-Hastings
algorithm to sample from a set of probability distributions, designed so that at the final step, the
method samples from one of the modes of the distribution, i.e., it finds one of the most likely states,
or lowest energy states. This approach can be used for both discrete and continuous optimization.
See Section 12.9.1 for more details.
6.7.3 Evolutionary algorithms
Stochastic local search (SLS) maintains a single “best guess” at each step, xt. If we run this for
T steps, and restart K times, the total cost is TK. A natural alternative is to maintain a set or
population of K good candidates, St, which we try to improve at each step. This is called an
evolutionary algorithm (EA). If we run this for T steps, it also takes TK time; however, it can
often get better results than multi-restart SLS, since the search procedure explores more of the space
in parallel, and information from different members of the population can be shared. Many versions
of EA are possible, as we discuss below.
Since EA algorithms draw inspiration from the biological process of evolution, they also borrow
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license302
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a)
Initial Population
(b)
Fitness Function
(c)
Selection
(d)
Crossover
(e)
Mutation
24
23
20
11
29%
31%
26%
14%
32752411
24748552
32752411
24415124
32748552
24752411
32752124
24415411
32252124
24752411
32748152
24415417
24748552
32752411
24415124
32543213
Figure 6.13: Illustration of a genetic algorithm applied to the 8-queens problem. (a) Initial population of 4
strings. (b) We rank the members of the population by fitness, and then compute their probability of mating.
Here the integer numbers represent the number of nonattacking pairs of queens, so the global maximum has a
value of 28. We pick an individual θ with probability p(θ) = L(θ)/Z, where Z =
P
θ∈P L(θ) sums the total
fitness of the population. For example, we pick the first individual with probability 24/78 = 0.31, the second
with probability 23/78 = 0.29, etc. In this example, we pick the first individual once, the second twice, the
third one once, and the last one does not get to breed. (c) A split point on the “chromosome” of each parent is
chosen at random. (d) The two parents swap their chromosome halves. (e) We can optionally apply pointwise
mutation. From Figure 4.6 of [RN10]. Used with kind permission of Peter Norvig.
a lot of its terminology. The fitness of a member of the population is the value of the objective
function (possibly normalized across population members). The members of the population at step
t + 1 are called the offspring. These can be created by randomly choosing a parent from St and
applying a random mutation to it. This is like asexual reproduction. Alternatively we can create
an offspring by choosing two parents from St, and then combining them in some way to make a child,
as in sexual reproduction; combining the parents is called recombination. (It is often followed by
mutation.)
The procedure by which parents are chosen is called the selection function. In truncation
selection, each parent is chosen from the fittest K members of the population (known as the elite
set). In tournament selection, each parent is the fittest out of K randomly chosen members. In
fitness proportionate selection, also called roulette wheel selection, each parent is chosen
with probability proportional to its fitness relative to the others. We can also “kill off” the oldest
members of the population, and then select parents based on their fitness; this is called regularized
evolution [Rea+19]).
In addition to the selection rule for parents, we need to specify the recombination and mutation
rules. There are many possible choices for these heuristics. We briefly mention a few of them below.
• In a genetic algorithm (GA) [Gol89; Hol92], we use mutation and a particular recombination
method based on crossover. To implement crossover, we assume each individual is represented
as a vector of integers or binary numbers, by analogy to chromosomes. We pick a split point
along the chromosome for each of the two chosen parents, and then swap the strings, as illustrated
in Figure 6.13.
• In genetic programming [Koz92], we use a tree-structured representation of individuals, instead
of a bit string. This representation ensures that all crossovers result in valid children, as illustrated
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.7. DERIVATIVE-FREE OPTIMIZATION
+ =
Figure 6.14: The 8-queens states corresponding to the first two parents in Figure 6.13(c) and their first child
in Figure 6.13(d). We see that the encoding 32752411 means that the first queen is in row 3 (counting from
the bottom left), the second queen is in row 2, etc. The shaded columns are lost in the crossover, but the
unshaded columns are kept. From Figure 4.7 of [RN10]. Used with kind permission of Peter Norvig.
+
sin
x
∧
2 +
x y
(a)
+
sin
x
✓
+
∧ y
x 2
(b)
+
sin
x
∧
2 ∧
x 2
(c)
+
sin
x
✓
+
+ y
x y
(d)
Figure 6.15: Illustration of crossover operator in a genetic program. (a-b) the two parents, representing
sin(x) + (x + y)
2
and sin(x) + p
x2 + y. The red circles denote the two crossover points. (c-d) the two
children, representing sin(x) + (x
2
)
2
and sin(x) + √
x + y + y. Adapted from Figure 9.2 of [Mit97]
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license304
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
in Figure 6.15. Genetic programming can be useful for finding good programs as well as other
structured objects, such as neural networks. In evolutionary programming, the structure of
the tree is fixed and only the numerical parameters are evolved.
• In surrogate assisted EA, a surrogate function ˆf(s) is used instead of the true objective function
f(s) in order to speed up the evaluation of members of the population (see [Jin11] for a survey).
This is similar to the use of response surface models in Bayesian optimization (Section 6.6), except
it does not deal with the explore-exploit tradeoff.
• In a memetic algorithm [MC03], we combine mutation and recombination with standard local
search.
Evolutionary algorithms have been applied to a large number of applications, including training
neural networks (this combination is known as neuroevolution [Sta+19]). An efficient JAX-based
library for (neuro)-evolution can be found at https://github.com/google/evojax.
6.7.4 Estimation of distribution (EDA) algorithms
EA methods maintain a population of good candidate solutions, which can be thought of as an
implicit (nonparametric) density model over states with high fitness. [BC95] proposed to “remove
the genetics from GAs”, by explicitly learning a probabilistic model over the configuration space that
puts its mass on high scoring solutions. That is, the population becomes the set of parameters of a
generative model, θt.
One way to learn such as model is as follows. We start by creating a sample of K′ > K candidate
solutions from the current model, St = {xk ∼ p(x|θt)}. We then rank the samples using the fitness
function, and then pick the most promising subset S
∗
t of size K using a selection operator (this is
known as truncation selection). Finally, we fit a new probabilistic model p(x|θt+1) to S
∗
t using
maximum likelihood estimation. This is called the estimation of distribution or EDA algorithm
(see e.g., [LL02; PSCP06; Hau+11; PHL12; Hu+12; San17; Bal17]).
Note that EDA is equivalent to minimizing the cross entropy between the empirical distribution
defined by S
∗
t and the model distribution p(x|θt+1). Thus EDA is related to the cross entropy
method, as described in Section 6.7.5, although CEM usually assumes the special case where
p(x|θ) = N (x|µ, Σ). EDA is also closely related to the EM algorithm, as discussed in [Bro+20a].
As a simple example, suppose the configuration space is bit strings of length D, and the fitness
function is f(x) = PD
d=1 xd, where xd ∈ {0, 1} (this is called the one-max function in the EA
literature). A simple probabilistic model for this is a fully factored model of the form p(x|θ) =
QD
d=1 Ber(xd|θd). Using this model inside of DBO results in a method called univariate marginal
distribution algorithm or UMDA.
We can estimate the parameters of the Bernoulli model by setting θd to the fraction of samples
in S
∗
t
that have bit d turned on. Alternatively, we can incrementally adjust the parameters. The
population-based incremental learning (PBIL) algorithm [BC95] applies this idea to the factored
Bernoulli model, resulting in the following update:
ˆθd,t+1 = (1 − ηt)
ˆθd,t + ηtθd,t (6.188)
where θd,t =
1
Nt
PK
k=1 I(xk,d = 1) is the MLE estimated from the K = |S∗
t
| samples generated in the
current iteration, and ηt is a learning rate.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.7. DERIVATIVE-FREE OPTIMIZATION
X1 X2 X3 … Xn eval
1 4 5 2 … 3 13.25
2 5 3 1 … 6 32.45
… … … … … … …
K’ 1 5 4 … 2 34.12
X1 X2 X3 … Xn eval
1 3 3 4 … 5 32.78
2 2 5 1 … 4 33.45
… … … … … … …
K’ 4 2 1 … 2 37.26
X1 X2 X3 … Xn
1 4 1 5 … 3
2 2 3 1 … 6
… … … … … …
K 3 4 6 … 5
S
S
Selection of K<K' individuals
Selection of K<K’ 
individuals
Induction of the 
probability model
Sampling from
xn-1
xn
x1 x2
x3
. . . . . . . . . . . . . . . . . . . . 
pt
(x) = p (x|S )
*
t-1
p (x) 
t
t
S
t-1
t-1
*
Figure 6.16: Illustration of the BOA algorithm (EDA applied to a generative model structured as a Bayes
net). Adapted from Figure 3 of [PHL12].
It is straightforward to use more expressive probability models that capture dependencies between
the parameters (these are known as building blocks in the EA literature). For example, in the case
of real-valued parameters, we can use a multivariate Gaussian, p(x) = N (x|µ, Σ). The resulting
method is called the estimation of multivariate normal algorithm or EMNA, [LL02]. (See
also Section 6.7.5.)
For discrete random variables, it is natural to use probabilistic graphical models (Chapter 4) to
capture dependencies between the variables. [BD97] learn a tree-structured graphical model using
the Chow-Liu algorithm (Supplementary Section 30.2.1); [BJV97] is a special case of this where the
graph is a tree. We can also learn more general graphical model structures (see e.g., [LL02]). We
typically use a Bayes net (Section 4.2), since we can use ancestral sampling (Section 4.2.5) to easily
generate samples; the resulting method is therefore called the Bayesian optimization algorithm
(BOA) [PGCP00].5 The hierarchical BOA (hBOA) algorithm [Pel05] extends this by using decision
trees and decision graphs to represent the local CPTs in the Bayes net (as in [CHM97]), rather than
using tables. In general, learning the structure of the probability model for use in EDA is called
linkage learning, by analogy to how genes can be linked together if they can be co-inherited as a
building block.
We can also use deep generative models to represent the distribution over good candidates. For
example, [CSF16] use denoising autoencoders and NADE models (Section 22.2), [Bal17] uses a
DNN regressor which is then inverted using gradient descent on the inputs, [PRG17] uses RBMs
5. This should not be confused with the Bayesian optimization methods we discuss in Section 6.6, that use response
surface modeling to model p(f(x)) rather than p(x
∗).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license306
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(Section 4.3.3.2), [GSM18] uses VAEs (Section 21.2), etc. Such models might take more data to
fit (and therefore more function calls), but can potentially model the probability landscape more
faithfully. (Whether that translates to better optimization performance is not clear, however.)
6.7.5 Cross-entropy method
The cross-entropy method [Rub97; RK04; Boe+05] is a special case of EDA (Section 6.7.4) in
which the population is represented by a multivariate Gaussian. In particular, we set µt+1 and Σt+1
to the empirical mean and covariance of S
∗
t+1, which are the top K samples. This is closely related
to the SMC algorithm for sampling rare events discussed in Section 13.6.4.
The CEM is sometimes used for model-based RL (Section 35.4), since it is simple and can find
reasonably good optima of multimodal objectives. It is also sometimes used inside of Bayesian
optimization (Section 6.6), to optimize the multi-modal acquisition function (see [BK10]).
6.7.5.1 Differentiable CEM
The differentiable CEM method of [AY19] replaces the top K operator with a soft, differentiable
approximation, which allows the optimizer to be used as part of an end-to-end differentiable pipeline.
For example, we can use this to create a differentiable model predictive control (MPC) algorithm
(Section 35.4.1), as described in Section 35.4.5.2.
The basic idea is as follows. Let St = {xt,i ∼ p(x|θt) : i = 1 : K′} represent the current
population, with fitness values vt,i = f(xt,i). Let v
∗
t,K be the K’th smallest value. In CEM, we
compute the set of top K samples, S
∗
t = {i : vt,i ≥ v
∗
t,K}, and then update the model based on these:
θt+1 = argmaxθ
P
i∈St
pt(i)log p(xt,i|θ), where pt(i) = I(i ∈ S∗
t
) /|S∗
t
|. In the differentiable version,
we replace the sparse distribution pt with the “soft” dense distribution qt = Π(pt; τ, K), where
Π(p; τ, K) = argmin
0≤q≤1
−p
T
q − τ H(q) s.t. 1
T
q = K (6.189)
projects the distribution p onto the polytope of distributions which sum to K. (Here H(q) =
−
P
i
qi
log(qi) + (1 − qi)log(1 − qi) is the entropy, and τ > 0 is a temperature parameter.) This
projection operator (and hence the whole DCEM algorithm) can be backpropagated through using
implicit differentiation [AKZK19].
6.7.6 Evolutionary strategies
Evolution strategies [Wie+14] are a form of distribution-based optimization in which the distribu￾tion over the population is represented by a Gaussian, p(x|θt) (see e.g., [Sal+17b]). Unlike CEM,
the parameters are updated using gradient ascent applied to the expected value of the objective,
rather than using MLE on a set of elite samples. More precisely, consider the smoothed objective
L(θ) = Ep(x|θ)
[f(x)]. We can use the REINFORCE estimator (Section 6.3.4) to compute the
gradient of this objective as follows:
∇θL(θ) = Ep(x|θ)
[f(x)∇θ log p(x|θ)] (6.190)
This can be approximated by drawing Monte Carlo samples. We discuss how to compute this gradient
below.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.8. OPTIMAL TRANSPORT
Figure 6.17: Illustration of the CMA-ES method applied to a simple 2d function. The dots represent
members of the population, and the dashed orange ellipse represents the multivariate Gaussian. From
https: // en. wikipedia. org/ wiki/ CMA-ES . Used with kind permission of Wikipedia author Sentewolf.
6.7.6.1 Natural evolutionary strategies
If the probability model is in the exponential family, we can compute the natural gradient (Section 6.4),
rather than the “vanilla” gradient, which can result in faster convergence. Such methods are called
natural evolution strategies [Wie+14].
6.7.6.2 CMA-ES
The CMA-ES method of [Han16], which stands for “covariance matrix adaptation evolution strategy”
is a kind of NES. It is very similar to CEM except it updates the parameters in a special way. In
particular, instead of computing the new mean and covariance using unweighted MLE on the elite
set, we attach weights to the elite samples based on their rank. We then set the new mean to the
weighted MLE of the elite set.
The update equations for the covariance are more complex. In particular, “evolutionary paths” are
also used to accumulate the search directions across successive generations, and these are used to
update the covariance. It can be shown that the resulting updates approximate the natural gradient
of L(θ) without explicitly modeling the Fisher information matrix [Oll+17].
Figure 6.17 illustrates the method in action.
6.8 Optimal transport
This section is written by Marco Cuturi.
In this section, we focus on optimal transport theory, a set of tools that have been proposed,
starting with work by [Mon81], to compare two probability distributions. We start from a simple
example involving only matchings, and work from there towards various extensions.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license308
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.8.1 Warm-up: matching optimally two families of points
Consider two families (x1, . . . , xn) and (y1, . . . , yn), each consisting in n > 1 distinct points taken
from a set X . A matching between these two families is a bijective mapping that assigns to each
point xi another point yj . Such an assignment can be encoded by pairing indices (i, j) ∈ {1, . . . , n}
2
such that they define a permutation σ in the symmetric group Sn. With that convention and given a
permuation σ, xi would be assigned to yσi
, the σi
’th element in the second family.
Matchings costs. When matching a family with another, it is natural to consider the cost
incurred when pairing any point xi with another point yj , for all possible pairs (i, j) ∈ {1, . . . , n}
2
.
For instance, xi might contain information on the current location of a taxi driver i, and yj that
of a user j who has just requested a taxi; in that case, Cij ∈ R may quantify the cost (in terms of
time, fuel or distance) required for taxi driver i to reach user j. Alternatively, xi could represent a
vector of skills held by a job seeker i and yj a vector quantifying desirable skills associated with a
job posting j; in that case Cij could quantify the number of hours required for worker i to carry out
job j. We will assume without loss of generality that the values Cij are obtained by evaluating a
cost function c : X × X → R on the pair (xi
, yj ), namely Cij = c(xi
, yj ). In many applications of
optimal transport, such cost functions have a geometric interpretation and are typically distance
functions on X as in Fig. 6.18, in which X = R
2
, or as will be later discussed in Section 6.8.2.4.
Least-cost matchings. Equipped with a cost function c, the optimal matching (or assignment)
problem is that of finding a permutation that reaches the smallest total cost, as defined by the
function
min
σ
E(σ) = Xn
i=1
c(xi
, yσj
). (6.191)
The optimal matching problem is arguably one of the simplest combinatorial optimization problems,
tackled as early as the 19th century [JB65]. Although a naive enumeration of all permutations would
require evaluating objective E a total of n! times, the Hungarian algorithm [Kuh55] was shown to
provide the optimal solution in polynomial time [Mun57], and later refined to require in the worst
case O(n
3
) operations.
6.8.2 From optimal matchings to Kantorovich and Monge formulations
The optimal matching problem is relevant to many applications, but it suffers from a few limitations.
One could argue that most of the optimal transport literature arises from the necessity to overcome
these limitations and extend (6.191) to more general settings. An obvious issue arises when the
number of points available in both familites is not the same. The second limitation arises when
considering a continuous setting, namely when trying to match (or morph) two probability densities,
rather than families of atoms (discrete measures).
6.8.2.1 Mass splitting
Suppose again that all points xi and yj describe skills, respectively held by a worker i and needed for
a task j to be fulfilled in a factory. Since finding a matching is equivalent to finding a permutation in
{1, . . . , n}, problem (6.191) cannot handle cases in which the number of workers is larger (or smaller)
than the number of tasks. More problematically, the assumption that every single task is indivisible,
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.8. OPTIMAL TRANSPORT
P
?
σ
?
y1
y2
y3
y4
y5
x5
x4
x3
x2
x1
σ
b4δy4
a1δx1
a2δx2
a3δx3
a4δx4
a5δx5
a6δx6
b1δy1
b2δy2
b3δy3
T
?
(x)
x
µ
ν
T
?
]µ = ν
Figure 6.18: Left: Matching a family of 5 points to another is equivalent to considering a permutation in
{1, . . . , n}. When to each pair (xi, yj ) ∈ R
2
is associated a cost equal to the distance kxi − yjk, the optimal
matching problem involves finding a permutation σ that minimizes kxi − yσi k for i in {1, 2, 3, 4, 5}. Middle:
The Kantorovich formulation of optimal transport generalizes optimal matchings, and arises when comparing
discrete measures, that is, families of weighted points that do not necessarily share the same size but do
share the same total mass. The relevant variable is a matrix P of size n × m, which must satisfy row-sum
and column-sum constraints, and which minimizes its dot product with matrix Cij . Right: another direct
extension of the matching problem lies when, intuitively, the number n of points that is described is such that
the considered measures become continuous densities. In that setting, and unlike the Kantorovich setting, the
goal is to seek a map T : X → X which, to any point x in the support of the input measure µ is associated
a point y = T(x) in the support of ν. The push-forward constraint T♯µ = ν ensures that ν is recovered by
applying map T to all points in the support of µ; the optimal map T
⋆
is that which minimizes the distance
between x and T(x), averaged over µ.
or that workers are only able to dedicate themselves to a single task, is hardly realistic. Indeed,
certain tasks may require more (or less) dedication than that provided by a single worker, whereas
some workers may only be able to work part-time, or, on the contrary, be willing to put in extra
hours. The rigid machinery of permutations falls short of handling such cases, since permutations
are by definition one-to-one associations. The Kantorovich formulation allows for mass-splitting,
the idea that the effort provided by a worker or needed to complete a given task can be split. In
practice, to each of the n workers is associated, in addition to xi
, a positive number ai > 0. That
number represents the amount of time worker i is able to provide. Similarly, we introduce numbers
bj > 0 describing the amount of time needed to carry out each of the m tasks (n and m do not
necessarily coincide). Worker i is therefore described as a pair (ai
, xi), mathematically equivalent
to a weighted Dirac measure aiδxi
. The overall workforce available to the factory is described as a
discrete measure P
i
aiδxi
, whereas its tasks are described in P
j bj δyj
. If one assumes further that
the factory has a balanced workload, namely that P
i
ai =
P
j bj , then the Kantorovich [Kan42]
formulation of optimal transport is:
OTC (a, b) , min
P ∈Rn×m
+ ,P 1n=a,P T 1m=b
hP, Ci ,
X
i,j
PijCij . (6.192)
The interpretation behind such matrices is simple: each coefficient Pij describes an allocation of
time for worker i to spend on task j. The i’th row-sum must be equal to the total ai for the time
constraint of worker i to be satisfied, whereas the j’th column-sum must be equal to bj , reflecting
that the time needed to complete task j has been budgeted.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license310
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.8.2.2 Monge formulation and optimal push forward maps
By introducing mass-splitting, the Kantorovich formulation of optimal transport allows for a far more
general comparison between discrete measures of different sizes and weights (middle plot of Fig. 6.18).
Naturally, this flexibility comes with a downside: one can no longer associate to each point xi another
point yj to which it is uniquely associated, as was the case with the classical matching problem.
Interestingly, this property can be recovered in the limit where the measures become densities. Indeed,
the Monge [Mon81] formulation of optimal transport allows us to recover precisely that property,
on the condition (loosely speaking) that measure µ admits a density. In that setting, the analogous
mathematical object guaranteeing that µ is mapped onto ν is that of push forward maps morphing
µ to ν, namely maps T such that for any measurable set A ⊂ X , µ(T
−1
(A)) = ν(A). When T is
differentiable, and µ, ν have densities p and q wrt the Lebesgue measure in R
d
, this statement is
equivalent, thanks to the change of variables formula, to ensuring almost everywhere that:
q(T(x)) = p(x)|JT (x)| , (6.193)
where |JT (x)| stands for the determinant of the Jacobian matrix of T evaluated at x.
Writing T♯µ = ν when T does satisfy these conditions, the Monge [Mon81] problem consists in
finding the best map T that minimizes the average cost between x and its displacement T(x),
inf
T:T♯µ=ν
Z
X
c(x, T(x)) µ(dx). (6.194)
T is therefore a map that pushes µ forwards to ν globally, but which results, on average, in the smallest
average cost. While very intuitive, the Monge problem turns out to be extremely difficult to solve in
practice, since it is non-convex. Indeed, one can easily check that the constraint {T♯µ = ν} is not
convex, since one can easily find counter-examples for which T♯µ = ν and T
′
♯
ν yet (
1
2
T +
1
2
T
′
)♯µ =6 ν.
Luckily, Kantorovich’s approach also works for continuous measures, and yields a comparatively
much simpler linear program.
6.8.2.3 Kantorovich formulation
The Kantovorich problem (6.192) can also be extended to a continuous setting: Instead of optimizing
over a subset of matrices in R
n×m, consider Π(µ, ν), the subset of joint probability distributions
P(X × X ) with marginals µ and ν, namely
Π(µ, ν) , {π ∈ P(X
2
) : ∀A ⊂ X , π(A × X ) = µ(A) and π(X × A) = ν(A)}. (6.195)
Note that Π(µ, ν) is not empty since it always contains the product measure µ ⊗ ν. With this
definition, the continuous formulation of (6.192) can be obtained as
OTc(µ, ν) , inf
π∈Π(µ,ν)
Z
X 2
c dπ . (6.196)
Notice that (6.196) subsumes directly (6.192), since one can check that they coincide when µ, ν are
discrete measures, with respective probability weights a, b and locations (x1, . . . , xn) and (y1, . . . , ym).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.8. OPTIMAL TRANSPORT
6.8.2.4 Wasserstein distances
When c is equal to a metric d exponentiated by an integer, the optimal value of the Kantorovich
problem is called the Wasserstein distance between µ and ν:
Wp(µ, ν) ,

inf
π∈Π(µ,ν)
Z
X 2
d(x, y)
p dπ(x, y)
1/p
. (6.197)
While the symmetry and the fact that Wp(µ, ν) = 0 ⇒ µ = ν are relatively easy to prove provided d
is a metric, proving the triangle inequality is slightly more challenging, and builds on a result known
as the gluing lemma ([Vil08, p.23]). The p’th power of Wp(µ, ν) is often abbreviated as Wp
p
(µ, ν).
6.8.3 Solving optimal transport
6.8.3.1 Duality and cost concavity
Both (6.192) and (6.196) are linear programs: their constraints and objective functions only involve
summations. In that sense they admit a dual formulation (here, again, (6.199) subsumes (6.198)):
max
f∈R
n,g∈Rm
f⊕g≤C
f
T a + g
T b (6.198)
sup
f⊕g≤c
Z
X
f dµ +
Z
X
g dν (6.199)
where the sign ⊕ denotes tensor addition for vectors, f ⊕ g = [fi + gj ]ij , or functions, f ⊕ g : x, y 7→
f(x) + g(y). In other words, the dual problem looks for a pair of vectors (or functions) that attain
the highest possible expectation when summed against a and b (or integrated against µ, ν), pending
the constraint that they do not differ too much across points x, y, as measured by c.
The dual problems in (6.192) and (6.196) have two variables. Focusing on the continuous formula￾tion, a closer inspection shows that it is possible, given a function f for the first measure, to compute
the best possible candidate for function g. That function g should be as large as possible, yet satisfy
the constraint that g(y) ≤ c(x, y) − f(x) for all x, y, making
∀y ∈ X , f(y) , inf
x
c(x, y) − f(x), (6.200)
the optimal choice. f is called the c-transform of f. Naturally, one may choose to start instead from
g, to define an alternative c-transform:
∀x ∈ X , ge(x) , inf
y
c(x, y) − g(y). (6.201)
Since these transformations can only improve solutions, one may even think of applying alternatively
these transformations to an arbitrary f, to define f,
e
f and so on. One can show, however, that this
has little interest, since
e
f = f . (6.202)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license312
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
This remark allows, nonetheless, to narrow down the set of candidate functions to those that have
already undergone such transformations. This reasoning yields the so-called set of c-concave functions,
Fc , {f |∃g : X → R, f = ge}, which can be shown, equivalently, to be the set of functions f such
that f =
e
f. One can therefore focus our attention to c-concave functions to solve (6.199) using a
so-called semi-dual formulation,
sup
f∈Fc
Z
X
f dµ +
Z
X
f dν. (6.203)
Going from (6.199) to (6.203), we have removed a dual variable g and narrowed down the feasible set
to Fc, at the cost of introducing the highly non-linear transform f. This reformulation is, however,
very useful, in the sense that it allows us to restrict our attention to c-concave functions, notably for
two important classes of cost functions c: distances and squared-Euclidean norms.
6.8.3.2 Kantorovich-Rubinstein duality and Lipschitz potentials
A striking result illustrating the interest of c-concavity is provided when c is a metric d, namely when
p = 1 in (6.197). In that case, one can prove (exploiting notably the triangle inequality of the d)
that a d-concave function f is 1-Lipschitz (one has |f(x) − f(y)| ≤ d(x, y) for any x, y) and such
that f = −f. This result translates therefore in the following identity:
W1(µ, ν) = sup
f∈1-Lipschitz Z
X
f (dµ − dν). (6.204)
This result has numerous practical applications. This supremum over 1-Lipschitz functions can be
efficiently approximated using wavelet coefficients of densities in low dimensions [SJ08], or heuristically
in more general cases by training neural networks parameterized to be 1-Lipschitz [ACB17] using
ReLU activation functions, and bounds on the entries of the weight matrices.
6.8.3.3 Monge maps as gradients of convex functions: the Brenier theorem
Another application of c-concavity lies in the case c(x, y) = 1
2
kx − y|k2
, which corresponds, up to the
factor 1
2
, to the squared W2 distance used between densities in an Euclidean space. The remarkable
result, shown first by [Bre91], is that the Monge map solving (6.194) between two measures for
that cost (taken for granted µ is regular enough, here assumed to have a density wrt the Lebesgue
measure) exists and is necessarily the gradient of a convex function. In loose terms, one can show
that
T
⋆ = arg min
T:T♯µ=ν
Z
X
1
2
kx − T(x)k
2
2 µ(dx). (6.205)
exists, and is the gradient of a convex function u : R
d → R, namely T
⋆ = ∇u. Conversely, for any
convex function u, the optimal transport map between µ and the displacement ∇u#µ is necessarily
equal to ∇u.
We provide a sketch of the proof: one can always exploit, for any reasonable cost function c
(e.g., lower bounded and lower semi continuous), primal-dual relationships: Consider an optimal
coupling P
⋆
for (6.196), as well as an optimal c-concave dual function f
⋆
for (6.203). This implies
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.8. OPTIMAL TRANSPORT
in particular that (f
⋆
, g⋆ = f
⋆) is optimal for (6.199). Complementary slackness conditions for this
pair of linear programs imply that if x0, y0 is in the support of P
⋆
, then necessarily (and sufficiently)
f
⋆
(x0) + f
⋆(y0) = c(x0, y0). Suppose therefore that x0, y0 is indeed in the support of P
⋆
. From the
equality f
⋆
(x0) + f
⋆(y0) = c(x0, y0) one can trivially obtain that f
⋆(y0) = c(x0, y0) − f
⋆
(x0). Yet,
recall also that, by definition, f
⋆(y0) = infx c(x, y0) − f
⋆
(x). Therefore, x0 has the special property
that it minimizes x → c(x, y0) − f
⋆
(x). If, at this point, one recalls that c is assumed in this section
to be c(x, y) = 1
2
kx − y|k2
, one has therefore that x0 verifies
x0 ∈ argmin
x
1
2
kx − y0k
2 − f
⋆
(x). (6.206)
Assuming f
⋆
is differentiable, which one can prove by c-concavity, this yields the identity
y0 − x0 − ∇f
⋆
(x0) = 0 ⇒ y0 = x0 − ∇f
⋆
(x0) = ∇
￾
1
2
k · k2 − f
⋆

(x0). (6.207)
Therefore, if (x0, y0) is in the support of P
⋆
, y0 is uniquely determined, which proves P
⋆
is in fact a
Monge map “disguised” as a coupling, namely
P
⋆ =
￾
Id, ∇
￾
1
2
k · k2 − f
⋆

♯
µ . (6.208)
The end of the proof can be worked out as follows: For any function h : X → R, one can show, using
the definitions of c-transforms and the Legendre transform, that 1
2
k · k2 − h is convex if and only if h
is c-concave. An intermediate step in that proof relies on showing that 1
2
k · k2 − h is equal to the
Legendre transform of 1
2
k · k2 − h. The function 1
2
k · k2 − f
⋆ above is therefore convex, by c-concavity
of f
⋆
, and the optimal transport map is itself the gradient of a convex function.
Knowing that an optimal transport map for the squared-Euclidean cost is necessarily the gradient
of a convex function can prove very useful to solve (6.203). Indeed, this knowledge can be leveraged to
restrict estimation to relevant families of functions, namely gradients of input-convex neural networks
[AXK17], as proposed in [Mak+20] or [Kor+20], as well as arbitrary convex functions with desirable
smoothness and strong-convexity constants [PdC20].
6.8.3.4 Closed forms for univariate and Gaussian distributions
Many metrics between probability distributions have closed form expressions for simple cases. The
Wasserstein distance is no exception, and can be computed in close form in two important scenarios.
When distributions are univariate and the cost c(x, y) is either a convex function of the difference
x − y, or when ∂c/∂x∂y < 0 a.e., then the Wasserstein distance is essentially a comparison between
the quantile functions of µ and ν. Recall that for a measure ρ, its quantile function Qρ is a function
that takes values in [0, 1] and is valued in the support of ρ, and corresponds to the (generalized)
inverse map of Fρ, the cumulative distribution function (cdf) of ρ. With these notations, one has
that
OTc(µ, ν) = Z
[0,1]
c (Qµ(u), Qν(u)) du (6.209)
In particular, when c is x, y 7→ |x − y| then OTc(µ, ν) corresponds to the Kolmogorov-Smirnov
statistic, namely the area between the cdf of µ and that of ν. If c is x, y 7→ (x − y)
2
, we recover
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND lice314
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
simply the squared-Euclidean norm between the quantile functions of µ and ν. Note finally that the
Monge map is also available in closed form, and is equal to Qν ◦ Fµ.
The second closed form applies to so-called elliptically contoured distributions, chiefly among
them Gaussian multivariate distributions[Gel90]. For two Gaussians N (m1, Σ1) and N (m2, Σ2) their
2-Wasserstein distance decomposes as
W2
2
(N (m1, Σ1), N (m2, Σ2) = km1 − m2k
2 + B
2
(Σ1, Σ2) (6.210)
where the Bures metric B reads:
B
2
(Σ1, Σ2) = tr

Σ1 + Σ2 − 2

Σ
1
2
1 Σ2Σ
1
2
1

1
2

 . (6.211)
Notice in particular that these quantities are well-defined even when the covariance matrices are
not invertible, and that they collapse to the distance between means as both covariances become 0.
When the first covariance matrix is invertible, one has that the optimal Monge map is given by
T , x 7→ A(x − m1) + m2, where A , Σ
−
1
2
1

Σ
1
2
1 Σ2Σ
1
2
1

1
2
Σ
−
1
2
1
(6.212)
It is easy to show that T
⋆
is indeed optimal: The fact that T♯N (m1, Σ1) = N (m2, Σ2) follows from
the knowledge that the affine push-forward of a Gaussian is another Gaussian. Here T is designed
to push precisely the first Gaussian onto the second (and A designed to recover random variables
with variance Σ2 when starting from random variables with variance Σ1). The optimality of T can
be recovered by simply noticing that is the gradient of a convex quadratic form, since A is positive
definite, and closing this proof using the Brenier theorem above.
6.8.3.5 Exact evaluation using linear program solvers
We have hinted, using duality and c-concavity, that methods based on stochastic optimization over
1-Lipschitz or convex neural networks can be employed to estimate Wasserstein distances when c is
the Euclidean distance or its square. These approaches are, however, non-convex and can only reach
local optima. Apart from these two cases, and the closed forms provided above, the only reliable
approach to compute Wasserstein distances appears when both µ and ν are discrete measures: in
that case, one can instantiate and solve the discrete (6.192) problem, or its dual (6.198) formulation.
The primal problem is a canonical example of network flow problems, and can be solved with the
network-simplex method in O(nm(n + m)log(n + m)) complexity [AMO88], or, alternatively, with
the comparable auction algorithm [BC89]. These approaches suffer from computational limitations:
their cubic cost is intractable for large scale scenarios; their combinatorial flavor makes it harder to
solve to parallelize simultaneously the computation of multiple optimal transport problems with a
common cost matrix C.
An altogether different issue, arising from statistics, should further discourage users from using
these LP formulations, notably in high-dimensional settings. Indeed, the bottleneck practitioners will
most likely encounter when using (6.192) is that, in most scenarios, their goal will be to approximate
the distance between two continuous measures µ, ν using only i.i.d samples contained in empirical
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.8. OPTIMAL TRANSPORT
measures µˆn, νˆn. Using (6.192) to approximate the corresponding (6.196) is doomed to fail, as various
results [FG15] have shown in relevant settings (notably for measures in R
q
) that the sample complexity
of the estimator provided by (6.192) to approximate (6.196) is of order 1/n1/q. In other words, the
gap between W2(µ, ν) and W2(µˆn, νˆn) is large in expectation, and decreases extremely slowly as n
increases in high dimensions. Thus solving (6.196) exactly between these samples is mostly time
wasted on overfitting. To address this curse of dimensionality, it is therefore extremely important in
practice to approach (6.196) using a more careful strategy, one that involves regularizations that can
leverage prior assumptions on µ and ν. While all approaches outlined above using neural networks
can be interpreted under this light, we focus in the following on a specific approach that results in a
convex problem that is relatively simple to implement, embarassingly parallel, and with quadratic
complexity.
6.8.3.6 Obtaining smoothness using entropic regularization
A computational approach to speedup the resolution of (6.192) was proposed in [Cut13], building
on earlier contributions [Wil69; KY94] and a filiation to the Schrödinger bridge problem in the
special case where c = d
2
[Léo14]. The idea rests upon regularizing the transportation cost by the
Kullback-Leibler divergence of the coupling to the product measure of µ, ν,
Wc,γ(µ, ν) , inf
π∈Π(µ,ν)
Z
X 2
d(x, y)
p dπ(x, y) + γDKL(πkµ ⊗ ν). (6.213)
When instantiated on discrete measures, this problem is equivalent to the following γ-strongly convex
problem on the set of transportation matrices (which should be compared to (6.192))
OTC,γ(a, b) = min
P ∈Rn×m
+ ,P 1m=a,P T 1n=b
hP, Ci ,
X
i,j
PijCij − γH(P) + γ (H(a) + H(b)) , (6.214)
which is itself equivalent to the following dual problem (which should be compared to (6.198))
OTC,γ(a, b) = max
f∈Rn,g∈Rm
f
T a + g
T b − γ(e
f/γ)
T Keg/γ) + γ (1 + H(a) + H(b)) (6.215)
and K , e
−C/γ is the elementwise exponential of −C/γ. This regularization has several benefits.
Primal-dual relationships show an explicit link between the (unique) solution P
⋆
γ and a pair of optimal
dual variables (f
⋆
, g
⋆
) as
P
⋆
γ = diag(e
f/γ)Kdiag(e
g/γ) (6.216)
Problem (6.215) can be solved using a fairly simple strategy that has proved very sturdy in practice:
a simple block-coordinate ascent (optimizing alternatively the objective in f and then g), resulting in
the famous Sinkhorn algorithm [Sin67], here expressed with log-sum-exp updates, starting from an
arbitrary initialization for g, to carry out these two updates sequentially, until they converge:
f ← γ log a − γ log Keg/γ g ← γ log b − γ log KT
e
f/γ (6.217)
The convergence of this algorithm has been amply studied (see [CK21] and references therein).
Convergence is naturally slower as γ decreases, reflecting the hardness of approaching LP solutions,
as studied in [AWR17]. This regularization also has statistical benefits since, as argued in [Gen+19],
the sample complexity of the regularized Wasserstein distance improves to a O(1/
√
n) regime, with,
however, a constant in 1/γq/2
that deteriorates as dimension grows.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license316
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.9 Submodular optimization
This section is written by Jeff Bilmes.
This section provides a brief overview of submodularity in machine learning.6 Submodularity has
an extremely simple definition. However, the “simplest things are often the most complicated to
understand fully” [Sam74], and while submodularity has been studied extensively over the years, it
continues to yield new and surprising insights and properties, some of which are extremely relevant
to data science, machine learning, and artificial intelligence. A submodular function operates on
subsets of some finite ground set, V . Finding a guaranteed good subset of V would ordinarily
require an amount of computation exponential in the size of V . Submodular functions, however,
have certain properties that make optimization either tractable or approximable where otherwise
neither would be possible. The properties are quite natural, however, so submodular functions
are both flexible and widely applicable to real problems. Submodularity involves an intuitive
and natural diminishing returns property, stating that adding an element to a smaller set helps
more than adding it to a larger set. Like convexity, submodularity allows one to efficiently find
provably optimal or near-optimal solutions. In contrast to convexity, however, where little regarding
maximization is guaranteed, submodular functions can be both minimized and (approximately)
maximized. Submodular maximization and minimization, however, require very different algorithmic
solutions and have quite different applications. It is sometimes said that submodular functions are
a discrete form of convexity. This is not quite true, as submodular functions are like both convex
and concave functions, but also have properties that are similar simultaneously to both convex
and concave functions at the same time, but then some properties of submodularity are neither
like convexity nor like concavity. Convexity and concavity, for example, can be conveyed even as
univariate functions. This is impossible for submodularity, as submodular functions are defined based
only on the response of the function to changes amongst different variables in a multidimensional
discrete space.
6.9.1 Intuition, examples, and background
Let us define a set function f : 2V → R as one that assigns a value to every subset of V . The
notation 2
V
is the power set of V , and has size 2
|V | which means that f lives in space R
2
n — i.e.,
since there are 2
n possible subsets of V , f can return 2
n distinct values. We use the notation X + v
as shorthand for X ∪ {v}. Also, the value of an element in a given context is so widely used a
concept, we have a special notation for it — the incremental value gain of v in the context if X is
defined as f(v|X) = f(X + v) − f(X). Thus, while f(v) is the value of element v, f(v|X) is the
value of element v if you already have X. We also define the gain of set X in the context of Y as
f(X|Y ) = f(X ∪ Y ) − f(Y ).
6.9.1.1 Coffee, lemon, milk, and tea
As a simple example, we will explore the manner in which the value of everyday items may interact
and combine, namely coffee, lemon, milk, and tea. Consider the value relationships amongst the four
6. A greatly extended version of the material in this section may be found at [Bil22].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.9. SUBMODULAR OPTIMIZATION
∅
{c,l,m} {c,m,t} {c,l,t} {l,m,t}
{c,l,m,t}
{c} {l} {m} {t}
{c,l} {c,m} {c,t} {l,m} {l,t} {m,t}
3
0
1 1 2
4 5 4 2 5 5
6 8 7 7
9
∅
{c} 3
{t} 2
{c,t} 4
0
∅ 0 {t} 2
{c}
3 {c,t}
4
{l} 1 {l,t} 5
4 {c,l} {c,l,t} 7
{c,l,m,t}
{l}
{m}
{c,m}
{c,t}
{l,t}
{m,t}
1
1
5
5
5
4
9
0 ∅
{t} 2
{c}
3
{c,l,t} 7
{c,l} 4
{c,m,t}
8
{l,m}
2
6 {c,l,m}
{l,m,t}
7
Figure 6.19: The value relationships between coffee c, lemon l, milk m, and tea t. On the left, we first
see a simple square showing the relationships between coffee and tea and see that they are substitutive (or
submodular). In this, and all of the shapes, the vertex label set is indicated in curly braces and the value at
that vertex is a blue integer in a box. We next see a three-dimensional cube that adds lemon to the coffee and
tea set. We see that tea and lemon are complementary (supermodular), but coffee and lemon are additive
(modular, or independent). We next see a four-dimensional hypercube (tesseract) showing all of the value
relationships described in the text. The four-dimensional hypercube is also shown as a lattice (on the right)
showing the same relationships as well as two (red and green, also shown in the tesseract) of the eight
three-dimensional cubes contained within.
items coffee (c), lemon (l), milk (m), and tea (t) as shown in Figure 6.19.
7 Suppose you just woke up,
and there is a function f : 2V → R that provides the average valuation for any subset of the items in
V where V = {c, l, m,t}. You can think of this function as giving the average price a typical person
would be willing to pay for any subset of items. Since nothing should cost nothing, we would expect
that f(∅) = 0. Clearly, one needs either coffee or tea in the morning, so f(c) > 0 and f(t) > 0, and
coffee is usually more expensive than tea, so that f(c) > f(t) pound for pound. Also more items cost
more, so that, for example, 0 < f(c) < f(c, m) < f(c, m,t) < f(c, l, m,t). Thus, the function f is
strictly monotone, or f(X) < f(Y ) whenever X ⊂ Y .
The next thing we note is that coffee and tea may substitute for each other — they both have
the same effect, waking you up. They are mutually redundant, and they decrease each other’s
value since once you have had a cup of coffee, a cup of tea is less necessary and less desirable. Thus,
f(c,t) < f(c) + f(t), which is known as a subadditive relationship, the whole is less than the sum
of the parts. On the other hand, some items complement each other. For example, milk and coffee
are better combined together than when both are considered in isolation, or f(m, c) > f(m) + f(c),
a superadditive relationship, the whole is more than the sum of the parts. A few of the items
do not affect each other’s price. For example, lemon and milk cost the same together as apart, so
f(l, m) = f(l) + f(m), an additive or modular relationship — such a relationship is perhaps midway
between a subadditive and a superadditive relationship and can be seen as a form of independence.
Things become more interesting when we consider three or more items together. For example,
once you have tea, lemon becomes less valuable when you acquire milk since there might be those
7. We use different character fonts c, l, m, and t for the ingestibles than we use for other constructs. For example,
below we use m for modular functions.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license318
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
that prefer milk to lemon in their tea. Similarly, milk becomes less valuable once you have acquired
lemon since there are those who prefer lemon in their tea to milk. So, once you have tea, lemon and
milk are substitutive, you would never use both as the lemon would only curdle the milk. These
are submodular relationships, f(l|m,t) < f(l|t) and f(m|l,t) < f(m|t) each of which implies that
f(l,t) + f(m,t) > f(l, m,t) + f(t). The value of lemon (respectively milk) with tea decreases in the
larger context of having milk (respectively lemon) with tea, typical of submodular relationships.
Not all of the items are in a submodular relationship, as sometimes the presence of an item can
increase the value of another item. For example, once you have milk, then tea becomes still more
valuable when you also acquire lemon, since tea with the choice of either lemon or milk is more
valuable than tea with the option only of milk. Similarly, once you have milk, lemon becomes more
valuable when you acquire tea, since lemon with milk alone is not nearly as valuable as lemon with
tea, even if milk is at hand. This means that f(t|l, m) > f(t|m) and f(l|t, m) > f(l|m) implying
f(l, m) + f(m,t) < f(l, m,t) + f(m). These are known as supermodular relationships, where the value
increases as the context increases.
We have asked for a set of relationships amongst various subsets of the four items V = {c, l, m,t},
Is there a function that offers a value to each X ⊆ V that satisfies all of the above relationships?
Figure 6.19 in fact shows such a function. On the left, we see a two-dimensional square whose vertices
indicate the values over subsets of {c,t} and we can quickly verify that the sum of the blue boxes on
north-west (corresponding to f({c})) and south-east corners (corresponding to f({t})) is greater than
the sum of the north-east and south-west corners, expressing the required submodular relationship.
Next on the right is a three-dimensional cube that adds the relationship with lemon. Now we have
six squares, and we see that the values at each of the vertices all satisfy the above requirements —
we verify this by considering the valuations at the four corners of every one of the six faces of the
cube. Since |V | = 4, we need a four-dimensional hypercube to show all values, and this may be
shown in two ways. It is first shown as a tesseract, a well-known three-dimensional projection of a
four-dimensional hypercube. In the figure, all vertices are labeled both with subsets of V as well as
the function value f(X) as the blue number in a box. The figure on the right shows a lattice version
of the four-dimensional hypercube, where corresponding three-dimensional cubes are shown in green
and red.
We thus see that a set function is defined for all subsets of a ground set, and that they correspond
to valuations at all vertices of the hypercube. For the particular function over valuations of subsets
of coffee, lemon, milk, and tea, we have seen submodular, supermodular, and modular relationships
all in one function. Therefore, the overall function f defined in Figure 6.19 is neither submodular,
supermodular, nor modular. For combinatorial auctions, there is often a desire to have a diversity
of such manners of relationships [LLN06] — representation of these relationships can be handled
by a difference of submodular functions [NB05; IB12] or a sum of a submodular and supermodular
function [BB18] (further described below). In machine learning, however, most of the time we are
interested in functions that are submodular (or modular, or supermodular) everywhere.
6.9.2 Submodular basic definitions
For a function to be submodular, it must satisfy the submodular relationship for all subsets. We
arrive at the following definition.
Definition 6.9.1 (Submodular function). A given set function f : 2V → R is submodular if for all
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.9. SUBMODULAR OPTIMIZATION
X, Y ⊆ V , we have the following inequality:
f(X) + f(Y ) ≥ f(X ∪ Y ) + f(X ∩ Y ) (6.218)
There are also many other equivalent definitions of submodularity [Bil22] some of which are more
intuitive and easier to understand. For example, submodular functions are those set functions that
satisfy the property of diminishing returns. If we think of a function f(X) as measuring the value of
a set X that is a subset of a larger set of data items X ⊆ V , then the submodular property means
that the incremental “value” of adding a data item v to set X decreases as the size of X grows. This
gives us a second classic definition of submodularity.
Definition 6.9.2 (Submodular function via diminishing returns). A given set function f : 2V → R
is submodular if for all X, Y ⊆ V , where X ⊆ Y and for all v /∈ Y , we have the following inequality:
f(X + v) − f(X) ≥ f(Y + v) − f(Y ) (6.219)
The property that the incremental value of lemon with tea is less than the incremental value
of lemon once milk is already in the tea is equivalent to Equation 6.218 if we set X = {m,t} and
Y = {l,t} (i.e., f(m,t) + f(l,t) > f(l, m,t) + f(t)). It is naturally also equivalent to Equation 6.219
if we set X = {t}, Y = {m,t}, and with v = l (i.e., f(l|m,t) < f(l|t)).
There are many functions that are submodular, one famous one being Shannon entropy seen
as a function of subsets of random variables. We first point out that there are non-negative (i.e.,
f(A) ≥ 0, ∀A), monotone non-decreasing (i.e., f(A) ≤ f(B) whenever A ⊆ B) submodular functions
that are not entropic [Yeu91b; ZY97; ZY98], so submodularity is not just a trivial restatement
of the class of entropy functions. When a function is monotone non-decreasing, submodular, and
normalized so that f(∅) = 0, it is often referred to as a polymatroid function. Thus, while the
entropy function is a polymatroid function, it does not encompass all polymatroid functions even
though all polymatroid functions satisfy the properties Claude Shannon mentioned as being natural
for an “information” function (see Section 6.9.7).
A function f is supermodular if and only if −f is submodular. If a function is both submodular
and supermodular, it is known as a modular function. It is always the case that a modular function
m : 2V → R may take the form of a vector-scalar pair. That is, for any A ⊆ V , we have that
m(A) = c +
P
v∈A mv where c is the scalar, and {mv}v∈V can be seen as the elements of a vector
indexed by elements of V . If the modular function is normalized, so that m(∅) = 0, then c = 0
and the modular function can be seen simply as a vector m ∈ R
V
. Hence, we sometimes say that
the modular function x ∈ R
V offers a value for set A as the partial sum x(A) = P
v∈A x(v). Many
combinatorial problems use modular functions as objectives. For example, the graph cut problem
uses a modular function defined over the edges, judges a cut in a graph as the modular function
applied to the edges that comprise the cut.
As can be seen from the above, and by considering Figure 6.19, a submodular function, and in
fact any set function, f : 2V → R can be seen as a function defined only on the vertices of the
n-dimensional unit hypercube [0, 1]n. Given any set X ⊆ V , we define 1X ∈ {0, 1}
V
to be the
characteristic vector of set X defined as 1X(v) = 1 if v ∈ X and 1X(v) = 0 otherwise. This gives us
a way to map from any set X ⊆ V to a binary vector 1X. We also see that 1X is itself a modular
function since 1X ∈ {0, 1}
V ⊂ R
V
.
Submodular functions share a number of properties in common with both convex and concave
functions [Lov83], including wide applicability, generality, multiple representations, and closure
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license320
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
under a number of common operators (including mixtures, truncation, complementation, and certain
convolutions). There is one important submodular closure property that we state here — that
if we take non-negative weighted (or conical) combinations of submodular functions, we preserve
submodularity. In other words, if we have a set of k submodular functions, fi
: 2V → R, i ∈ [k], and
we form f(X) = Pk
i=1 ωifi(X) where ωi ≥ 0 for all i, then Definition 6.9.1 immediately implies that
f is also submodular. When we consider Definition 6.9.1, we see that submodular functions live in a
cone in 2
n-dimensional space defined by the intersection of an exponential number of half-spaces each
one of which is defined by one of the inequalities of the form f(X) + f(Y ) ≥ f(X ∪ Y ) + f(X ∩ Y ).
Each submodular function is therefore a point in that cone. It is therefore not surprising that taking
conical combinations of such points stays within this cone.
6.9.3 Example submodular functions
As mentioned above, there are many functions that are submodular besides entropy. Perhaps the
simplest such function is f(A) = p
|A| which is the composition of the square-root function (which is
concave) with the cardinality |A| of the set A. The gain function is f(A + v) − f(A) = √
k + 1 −
√
k
if |A| = k, which we know to be a decreasing in k, thus establishing the submodularity of f. In
fact, if φ : R → R is any concave function, then f(A) = φ(|A|) will be submodular for the same
reason.8 Generalizing this slightly further, a function defined as f(A) = φ(
P
a∈A m(a)) is also
submodular, whenever m(a) ≥ 0 for all a ∈ V . This yields a composition of a concave function
with a modular function f(A) = φ(m(A)) since P
a∈A m(a) = m(A). We may take sums of
such functions as well as add a final modular function without losing submodularity, leading to
f(A) = P
u∈U
φu(
P
a∈A mu(a)) + P
a∈A m±(a) where φu can be a distinct concave function for
each u, mu(a) is a non-negative real value for all u and a, and m±(a) is an arbitrary real number.
Therefore, f(A) = P
u∈U
φu(mu(A))+m±(A) where mu is a u-specific non-negative modular function
and m± is an arbitrary modular function. Such functions are sometimes known as feature-based
submodular functions [BB17] because U can be a set of non-negative features (in the machine-learning
“bag-of-words” sense) and this function measures a form of dispersion over A as determined by the
set of features U.
A function such as f(A) = P
u∈U
φu(mu(A)) tends to award high diversity to a set A that has a
high valuation by a distinct set of the features U. The reason is that, due to the concave nature of
φu, any addition to the argument mu(A) by adding, say, v to A would diminish as A gets larger. In
order to produce a set larger than A that has a much larger valuation, one must use a feature u
′ 6= u
that has not yet diminished as much.
Facility location is another well-known submodular function — perhaps an appropriate nickname
would be the “k-means of submodular functions”, due to its applicability, utility, ease-of-use (it
needs only an affinity matrix), and similarity to k-medoids problems. The facility location function
is defined using an affinity matrix as follows: f(A) = P
v∈V maxa∈A sim(a, v) where sim(a, v) is a
non-negative measure of the affinity (or similarity) between element a and v. Here, every element
v ∈ V must have a representative within the set A and the representative for each v ∈ V is chosen
to be the element a ∈ A most similar to v. This function is also a form of dispersion or diversity
function because, in order to maximize it, every element v ∈ V must have some element similar to
8. While we will not be extensively discussing supermodular functions in this section, f(A) = φ(|A|) is supermodular
for any convex function φ.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.9. SUBMODULAR OPTIMIZATION
it in A. The overall score is then the sum of the similarity between each element v ∈ V and v’s
representative. This function is monotone (since as A includes more elements to become B ⊇ A, it is
possible only to find an element in B more similar to a given v than an element in A).
While the facility location looks quite different from a feature-based function, it is possible
to precisely represent any facility location function with a feature-based function. Consider
just maxa∈A xa and, without loss of generality, assume that 0 ≤ x1 ≤ x2 ≤ · · · ≤ xn. Then
maxa∈A xa =
Pn
i=1 yi min(|A ∩ {i, i + 1, . . . , n}|, 1) where yi = xi − xi−1 and we set x0 = 0. We note
that this is a sum of weighted concave composed with modular functions since min(α, 1) is concave
in α, and |A ∩ {i, i + 1, . . . , n}| is a modular function in A. Thus, the facility location function, a
sum of these, is merely a feature-based function.
Feature-based functions, in fact, are quite expressive, and can be used to represent many different
submodular functions including set cover and graph-based functions. For example, we can define a set
cover function, given a set of sets {Uv}v∈V , via f(X) =


S
v∈X Uv


. If f(X) = |U| where U =
S
v∈V Uv
then X indexes a set that fully covers U. This can also be represented as f(X) = P
u∈U min(1, mu(X))
where mu(X) is a modular function where mu(v) = 1 if and only if u ∈ Uv and otherwise mu(v) = 0.
We see that this is a feature-based submodular function since min(1, x) is concave in x, and U is a
set of features.
This construct can be used to produce the vertex cover function if we set U = V to be the set of
vertices in a graph, and set mu(v) = 1 if and only if vertices u and v are adjacent in the graph and
otherwise set mu(v) = 0. Similarly, the edge cover function can be expressed by setting V to be the
set of edges in a graph, U to be the set of vertices in the graph, and mu(v) = 1 if and only edge v is
incident to vertex u.
A generalization of the set cover function is the probabilistic coverage function. Let P [Bu,v = 1] be
the probability of the presence of feature (or concept) u within element v. Here, we treat Bu,v as a
Bernoulli random variable for each element v and feature u so that P [Bu,v = 1] = 1 − P [Bu,v = 0].
Then we can define the probabilistic coverage function as f(X) = P
u∈U
fu(X) where, for feature
u, we have fu(X) = 1 −
Q
v∈X(1 − P [Bu,v = 1]) which indicates the degree to which feature u is
“covered” by X. If we set P [Bu,v = 1] = 1 if and only if u ∈ Uv and otherwise P [Bu,v = 1] = 0, then
fu(X) = min(1, mu(X)) and the set cover function can be represented as P
u∈U
fu(X). We can
generalize this in two ways. First, to make it softer and more probabilistic we allow P [Bu,v = 1] to
be any number between zero and one. We also allow each feature to have a non-negative weight. This
yields the general form of the probabilistic coverage function, which is defined by taking a weighted
combination over all features: fu(X) = P
u∈U ωufu(X) where ωu ≥ 0 is a weight for feature u.
Observe that 1 −
Q
v∈X(1 − P [Bu,v = 1]) = 1 − exp(−mu(X)) = φ(mu(X)) where mu is a modular
function with evaluation mu(X) = P
v∈X log￾
1/(1−P [Bu,v = 1])

and for z ∈ R, φ(z) = 1−exp(−z)
is a concave function. Thus, the probabilistic coverage function (and its set cover specialization) is
also a feature-based function.
Another common submodular function is the graph cut function. Here, we measure the value of a
subset of V by the edges that cross between a set of nodes and all but that set of nodes. We are given
an undirected non-negative weighted graph G = (V, E, w) where V is the set of nodes, E ⊆ V × V is
the set of edges, and w ∈ R
E
+ are non-negative edge weights corresponding to symmetric matrix (so
wi,j = wj,i). For any e ∈ E, we have e = {i, j} for some i, j ∈ V with i 6= j, the graph cut function
f : 2V → R is defined as f(X) = P
i∈X,j∈X¯ wi,j where wi,j ≥ 0 is the weight of edge e = {i, j}
(wi,j = 0 if the edge does not exist), and where X¯ = V \ X is the complement of set X. Notice that
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens322
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
we can write the graph cut function as follows:
f(X) = X
i∈X,j∈X¯
wi,j =
X
i,j∈V
wi,j1{i ∈ X, j ∈ X¯} (6.220)
=
1
2
X
i,j∈V
wi,j min(|X ∩ {i, j}|, 1) + 1
2
X
i,j∈V
wi,j min(|(V \ X) ∩ {i, j}|, 1) −
1
2
X
i,j∈V
wi,j (6.221)
= ˜f(X) + ˜f(V \ X) − ˜f(V ) (6.222)
where ˜f(X) = 1
2
P
i,j∈V wi,j min(|X ∩ {i, j}|, 1). Therefore, since min(α, 1) is concave, and since
mi,j (X) = |X ∩ {i, j}| is modular, ˜f(X) is submodular for all i, j. Also, since ˜f(X) is submodular, so
is ˜f(V \ X) (in X). Therefore, the graph cut function can be expressed as a sum of non-normalized
feature-based functions. Note that here the second modular function is not normalized and is
non-increasing, and also we subtract the constant ˜f(V ) to achieve equality.
Another way to view the graph cut function is to consider the non-negative weights as a modular
function defined over the edges. That is, we view w ∈ R
E
+ as a modular function w : 2E → R+ where
for every A ⊆ E, w(A) = P
e∈A w(e) is the weight of the edges A where w(e) is the weight of edge
e. Then the graph cut function becomes f(X) = w({(a, b) ∈ E : a ∈ X, b ∈ X \ X}). We view
{(a, b) ∈ E : a ∈ X, b ∈ X \ X} as a set-to-set mapping function, that maps subsets of nodes to
subsets of edges, and the edge weight modular function w measures the weight of the resulting edges.
This immediately suggests that other functions can measure the weight of the resulting edges as
well, including non-modular functions. One example is to use a polymatroid function itself leading
h(X) = g({(a, b) ∈ E : a ∈ X, b ∈ X \ X}) where g : 2E → R+ is a submodular function defined
on subsets of edges. The function h is known as the cooperative cut function, and it is neither
submodular nor supermodular in general but there are many useful and practical algorithms that
can be used to optimize it [JB16] thanks to its internal yet exposed and thus available to exploit
submodular structure.
While feature-based functions are flexible and powerful, there is a strictly broader class of sub￾modular functions, unable to be expressed by feature-based functions, that are related to deep
neural networks. Here, we create a recursively nested composition of concave functions with sums of
compositions of concave functions. An example is f(A) = φ(
P
u∈U ωuφu(
P
a∈A mu(a))), where φ
is an outer concave function composed with a feature-based function, with mu(a) ≥ 0 and ωu ≥ 0.
This is known as a two-layer deep submodular function (DSF). A three-layer DSF has the form
f(A) = φ(
P
c∈C ωcφc(
P
u∈U ωu,cφu(
P
a∈A mu(a)))). DSFs strictly expand the class of submodular
functions beyond feature-based functions, meaning that there are feature-based functions that cannot
represent deep submodular functions, even simple ones [BB17].
6.9.4 Submodular optimization
Submodular functions, while discrete, would not be very useful if it was not possible to optimize
over them efficiently. There are many natural problems in machine learning that can be cast as
submodular optimization and that can be addressed relatively efficiently.
When one wishes to encourage diversity, information, spread, high complexity, independence,
coverage, or dispersion, one usually will maximize a submodular function, in the form of maxA∈C f(A)
where C ⊆ 2
V
is a constraint set, a set of subsets we are willing to accept as feasible solutions (more
on this below).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.9. SUBMODULAR OPTIMIZATION
Figure 6.20: Far left: cardinality constrained (to ten) submodular maximization of a facility location function
over 1000 points in two dimensions. Similarities are based on a Gaussian kernel sim(a, v) = exp(−d(a, v))
where d(·, ·) is a distance. Selected points are green stars, and the greedy order is also shown next to each
selected point. Right three plots: different uniformly-at-random subsets of size ten.
Why is submodularity, in general, a good model for diversity? Submodular functions are such
that once you have some elements, any other elements not in your possession but that are similar
to, explained by, or represented by the elements in your possession become less valuable. Thus, in
order to maximize the function, one must choose other elements that are dissimilar to, or not well
represented by, the ones you already have. That is, the elements similar to the ones you own are
diminished in value relative to their original values, while the elements dissimilar to the ones you
have do not have diminished value relative to their original values. Thus, maximizing a submodular
function successfully involves choosing elements that are jointly dissimilar amongst each other, which
is a definition of diversity. Diversity in general is a critically important aspect in machine learning
and artificial intelligence. For example, bias in data science and machine learning can often be seen
as some lack of diversity somewhere. Submodular functions have the potential to encourage (and
even ensure) diversity, enhance balance, and reduce bias in artificial intelligence.
Note that in order for a submodular function to appropriately model diversity, it is important
for it to be instantiated appropriately. Figure 6.20 shows an example in two dimensions. The plot
compares the ten points chosen according to a facility location instantiated with a Gaussian kernel,
along with the random samples of size ten. We see that the facility location selected points are more
diverse and tend to cover the space much better than any of the randomly selected points, each of
which miss large regions of the space and/or show cases where points near each other are jointly
selected.
When one wishes for homogeneity, conformity, low complexity, coherence, or cooperation, one will
usually minimize a submodular function, in the form of minA∈C f(A). For example, if V is a set of
pixels in an image, one might wish to choose a subset of pixels corresponding to a particular object
over which the properties (i.e., color, luminance, texture) are relatively homogeneous. Finding a set
X of size k, even if k is large, need not have a large valuation f(X), in fact it could even have the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license324
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
least valuation. Thus, semantic image segmentation could work even if the object being segmented
and isolated consists of the majority of image pixels.
6.9.4.1 Submodular maximization
While the cardinality constrained submodular maximization problem is NP complete [Fei98], it was
shown in [NWF78; FNW78] that the very simple and efficient greedy algorithm finds an approximate
solution guaranteed to be within 1−1/e ≈ 0.63 of the optimal solution. Moreover, the approximation
ratio achieved by the simple greedy algorithm is provably the best achievable in polynomial time,
assuming P 6= NP [Fei98]. The greedy algorithm proceeds as follows: Starting with X0 = ∅, we
repeat the following greedy step for i = 0 . . .(k − 1):
Xi+1 = Xi ∪ (argmax
v∈V \Xi
f(Xi ∪ {v})) (6.223)
What the above approximation result means is that if X∗ ∈ argmax{f(X) : |X| ≤ k}, and if X˜ is
the result of the greedy procedure, then f(X˜) ≥ (1 − 1/e)f(X∗
).
The 1 − 1/e guarantee is a powerful constant factor approximation result since it holds regardless
of the size of the initial set V and regardless of which polymatroid function f is being optimized.
It is possible to make this algorithm run extremely fast using various acceleration tricks [FNW78;
NWF78; Min78].
A minor bit of additional information about a polymatroid function, however, can improve
the approximation guarantee. Define the total curvature if the polymatroid function f as κ =
1 − minv∈V f(v|V − v)/f(v) where we assume f(v) > 0 for all v (if not, we may prune them from the
ground set since such elements can never improve a polymatroid function valuation). We thus have
0 ≤ κ ≤ 1, and [CC84] showed that the greedy algorithm gives a guarantee of 1
κ
(1 − e
−κ
) ≥ 1 − 1/e.
In fact, this is an equality (and we get the same bound) when κ = 1, which is the fully curved case.
As κ gets smaller, the bound improves, until we reach the κ = 0 case and the bound becomes unity.
Observe that κ = 0 if and only if the function is modular, in which case the greedy algorithm is
optimal for the cardinality constrained maximization problem. In some cases, non-submodular
functions can be decomposed into components that each might be more amenable to approximation.
We see below that any set function can be written as a difference of submodular [NB05; IB12]
functions, and sometimes (but not always) a given h can be composed into a monotone submodular
plus a monotone supermodular function, or a BP function [BB18], i.e., h = f + g where f is
submodular and g is supermodular. g has an easily computed quantity called the supermodular
curvature κ
g = 1 − minv∈V g(v)/g(v|V − v) that, together with the submodular curvature, can be
used to produce an approximation ratio having the form 1
κ
(1 − e
−κ(1−κ
g
)
) for greedy maximization
of h.
6.9.4.2 Discrete constraints
There are many other types of constraints one might desire besides a cardinality limitation. The next
simplest constraint allows each element v to have a non-negative cost, say m(v) ∈ R+. In fact, this
means that the costs are modular, i.e., the cost of any set X is m(X) = P
v∈X m(v). A submodular
maximization problem subject to a knapsack constraint then takes the form maxX⊆V :m(X)≤b f(X)
where b is a non-negative budget. While the greedy algorithm does not solve this problem directly, a
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.9. SUBMODULAR OPTIMIZATION
slightly modified cost-scaled version of the greedy algorithm [Svi04] does solve this problem for any
set of knapsack costs. This has been used for various multi-document summarization tasks [LB11;
LB12].
There is no single direct analogy for a convex set when one is optimizing over subsets of the set V ,
but there are a few forms of discrete constraints that are both mathematically interesting and that
often occur repeatedly in applications.
The first form is the independent subsets of a matroid. The independent sets of a matroid are useful
to represent a constraint set for submodular maximization [Cal+07; LSV09; Lee+10], maxX∈I f(X),
and this can be useful in many ways. We can see this by showing a simple example of what is known
as a partition matroid. Consider a partition V = {V1, V2, . . . , Vm} of V into m mutually disjoint
subsets that we call blocks. Suppose also that for each of the m blocks, there is a positive integer
limit ℓi for i ∈ [m]. Consider next the set of sets formed by taking all subsets of V such that each
subset has intersection with Vi no more than ℓi for each i. I.e., consider
Ip = {X : ∀i ∈ [m], |Vi ∩ X| ≤ ℓi}. (6.224)
Then (V, Ip) is a matroid. The corresponding submodular maximization problem is a natural
generalization of the cardinality constraint in that, rather than having a fixed number of elements
beyond which we are uninterested, the set of elements V is organized into groups, and here we have
a fixed per-group limit beyond which we are uninterested. This is useful for fairness applications
since the solution must be distributed over the blocks of the matroid. Still, there are many much
more powerful types of matroids that one can use [Oxl11; GM12].
Regardless of the matroid, the problem maxX∈I f(X) can be solved, with a 1/2 approximation
factor, using the same greedy algorithm as above [NWF78; FNW78]. Indeed, the greedy algorithm
has an intimate relationship with submodularity, a fact that is well studied in some of the seminal
works on submodularity [Edm70; Lov83; Sch04]. It is also possible to define constraints consisting
of an intersection of matroids, meaning that the solution must be simultaneously independent in
multiple distinct matroids. Adding on to this, we might wish a set to be independent in multiple
matroids and also satisfy a knapsack constraint. Knapsack constraints are not matroid constraints,
since there can be multiple maximal cost solutions that are not the same size (as must be the case in
a matroid). It is also possible to define discrete constraints using level sets of another completely
different submodular function [IB13] — given two submodular functions f and g, this leads to
optimization problems of the form maxX⊆V :g(X)≤α f(X) (the submodular cost submodular knapsack,
or SCSK, problem) and minX⊆V :g(X)≥α f(X) (the submodular cost submodular cover, or SCSC,
problem). Other examples include covering constraints [IN09], and cut constraints [JB16]. Indeed,
the type of constraints on submodular maximization for which good and scalable algorithms exist is
quite vast, and still growing.
One last note on submodular maximization. In the above, the function f has been assumed to be
a polymatroid function. There are many submodular functions that are not monotone [Buc+12].
One example we saw before, namely the graph cut function. Another example is the log of the
determinant (log-determinant) of a submatrix of a positive-definite matrix (which is the Gaussian
entropy plus a constant). Suppose that M is an n × n symmetric positive-definite (SPD) matrix,
and that MX is a row-column submatrix (i.e., it is an |X| × |X| matrix consisting of the rows and
columns of M consisting of the elements in X). Then the function defined as f(X) = log det(MX)
is submodular but not necessarily monotone non-decreasing. In fact, the submodularity of the
log-determinant function is one of the reasons that determinantal point processes (DPPs), which
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license326
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
instantiate probability distributions over sets in such a way that high probability is given to those
subsets that are diverse according to M, are useful for certain tasks where we wish to probabilistically
model diversity [KT11]. (See Supplementary Section 31.8.5 for details on DPPs.) Diversity of a
set X here is measured by the volume of the parallelepiped which is known to be computed as the
determinant of the submatrix MX and taking the log of this volume makes the function submodular
in X. A DPP in fact is an example of a log-submodular probabilistic model (more in Section 6.9.10).
6.9.4.3 Submodular function minimization
In the case of a polymatroid function, unconstrained minimization is again trivial. However, even in
the unconstrained case, the minimization of an arbitrary (i.e., not necessarily monotone) submodular
function minX⊆V f(X) might seem hopelessly intractable. Unconstrained submodular maximization
is NP-hard (albeit approximable), and this is not surprising given that there are an exponential
number of sets needing to be considered. Remarkably, submodular minimization does not require
exponential computation, and is not NP-hard; in fact, there are polynomial time algorithms for
doing so, something that is not at all obvious. This is one of the important characteristics that
submodular functions share with convex functions, their common amenability to minimization.
Starting in the very late 1960s and spearheaded by individuals such as Jack Edmonds [Edm70],
there was a concerted effort in the discrete mathematics community in search of either an algorithm
that could minimize a submodular function in polynomial time or a proof that such a problem was
NP-hard. The nut was finally cracked in a classic paper [GLS81] on the ellipsoid algorithm that gave
a polynomial time algorithm for submodular function minimization (SFM). While the algorithm
was polynomial, it was a continuous algorithm, and it was not practical, so the search continued
for a purely combinatorial strongly polynomial time algorithm. Queyranne [Que98] then proved
that an algorithm [NI92] worked for this problem when the set function also satisfies a symmetry
condition (i.e., ∀X ⊆ V, f(X) = f(V \ X)), which only requires O(n
3
) time. The result finally came
around the year 2000 using two mostly independent methods [IFF00; Sch00]. These algorithms,
however, also were impractical, in that while they are polynomial time, they had unrealistically
high polynomial degree (i.e., O˜(|V |
7 ∗ γ + |V |
8
) for [Sch00] and O˜(|V |
7 ∗ γ) for [IFF00]). This led to
additional work on combinatorial algorithms for SFM leading to algorithms that could perform SFM
in time O˜(|V |
5γ + |V |
6
) in [IO09]. Two practical algorithms for SFM include the Fujishige-Wolfe
procedure [Fuj05; Wol76]
9 as well as the Frank-Wolfe procedure, each of which minimize the 2-norm
on a polyhedron Bf associated with the submodular function f and which is defined below (it should
also be noted that the Frank-Wolfe algorithm can also be used to minimize the convex extension of
the function, something that is relatively easy to compute via the Lovász extension [Lov83]). More
recent work on SFM are also based on continuous relaxations of the problem in some form or another,
leading algorithms with strongly polynomial running time [LSW15] of O(|V |
3
log2
|V |) for which it
was possible to drop the log factors leading to a complexity of O(|V |
3
) in [Jia21], weakly-polynomial
running time [LSW15] of O˜(|V |
2
log M) (where M >= maxS⊆V |f(S)|), pseudopolynomial running
time [ALS20; Cha+17] of O˜(|V |M2
), and a ǫ-approximate minimization with a linear running
time [ALS20] of O˜(|V |/ǫ2
). There have been other efforts to utilize parallelism to further improve
SFM [BS20].
9. This is the same Wolfe as the Wolfe in Frank-Wolfe but not the same algorithm.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.9. SUBMODULAR OPTIMIZATION
6.9.5 Applications of submodularity in machine learning and AI
Submodularity arises naturally in applications in machine learning and artificial intelligence, but its
utility has still not yet been as widely recognized and exploited as other techniques. For example,
while information theoretic concepts like entropy and mutual information are extremely widely used
in machine learning (e.g., the cross-entropy loss for classification is ubiquitous), the submodularity
property of entropy is not nearly as widely explored.
Still, in the last several decades, submodularity has been increasingly studied and utilized in the
context of machine learning. In the below we begin to provide only a brief survey of some of the major
subareas within machine learning that have been touched by submodularity. The list is not meant
to be exhaustive, or even extensive. It is hoped that the below should, at least, offer a reasonable
introduction into how submodularity has been and can continue to be useful in machine learning and
artificial intelligence.
6.9.6 Sketching, coresets, distillation, and data subset and feature selection
A summary is a concise representation of a body of data that can be used as an effective and efficient
substitute for that data. There are many types of summaries, some being extremely simple. For
example, the mean or median of a list of numbers summarizes some property (the central tendency)
of that list. A random subset is also a form of summary.
Any given summary, however, is not guaranteed to do a good job serving all purposes. Moreover,
a summary usually involves at least some degree of approximation and fidelity loss relative to the
original, and different summaries are faithful to the original in different ways and for different tasks.
For these and other reasons, the field of summarization is rich and diverse, and summarization
procedures are often very specialized.
Several distinct names for summarization have been used over the past few decades, including
“sketches”, “coresets”, (in the field of natural language processing) “summaries”, and “distillation”.
Sketches [Cor17; CY20; Cor+12], arose in the field of computer science and was based on the
acknowledgment that data is often too large to fit in memory and too large for an algorithm to run
on a given machine, something enabled by a much smaller but still representative, and provably
approximate, representation of the data.
Coresets are similar to sketches and there are some properties that are more often associated
with coresets than with sketches, but sometimes the distinction is a bit vague. The notion of a
coreset [BHPI02; AHP+05; BC08] comes from the field of computational geometry where one is
interested in solving certain geometric problems based on a set of points in R
d
. For any geometric
problem and a set of points, a coreset problem typically involves finding the smallest weighted subset
of points so that when an algorithm is run on the weighted subset, it produces approximately the
same answer as when it is run on the original large dataset. For example, given a set of points, one
might wish to find the diameter of a set, or the radius of the smallest enclosing sphere, or finding the
narrowest annulus (ring) containing the points, or a subset of points whose k-center clustering is
approximately the same as the k-center clustering of the whole [BHPI02].
Document summarization became one of the most important problems in natural language process￾ing (NLP) in the 1990s although the idea of computing a summary of a text goes back much further to
the 1950s [Luh58; Edm69], also and coincidentally around the same time that the CliffsNotes [Wik21]
organization began. There are two main forms of document summarization [YWX17]. With extractive
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license328
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
summarization [NM12], a set of sentences (or phrases) are extracted from the documents needing to
be summarized, and the resulting subset of sentences, perhaps appropriately ordered, comprises the
summary.
With abstractive summarization [LN19], on the other hand, the goal is to produce an “abstract” of
the documents, where one is not constrained to have any of the sentences in the abstract correspond
to any of the sentences in the original documents. With abstractive summarization, therefore, the
goal is to synthesize a small set of new pseudo sentences that represent the original documents.
CliffsNotes, for example, are abstractive summaries of the literature being represented.
Another form of summarization that has more recently become popular in the machine learning
community is data distillation [SG06b; Wan+20c; Suc+20; BYH20; NCL20; SS21; Ngu+21] or
equivalently dataset condensation [ZMB21; ZB21]. With data distillation10, the goal is to produce a
small set of synthetic pseudosamples that can be used, for example, to train a model. The key here
is that in the reduced dataset, the samples are not compelled to be the same as, or a subset of, the
original dataset.
All of the above should be contrasted with data compression, which in some sense is the most
extreme data reduction method. With compression, either lossless or lossy, one is no longer under any
obligation that the reduced form of the data must be usable, or even recognizable, by any algorithm
or entity other than the decoder, or uncompression, algorithm.
6.9.6.1 Summarization Algorithm Design Choices
It is the author’s contention that the notions of summarization, coresets, sketching, and distillation
are certainly analogous and quite possibly synonymous, and they are all different from compression.
The different names for summarization are simply different nomenclatures for the same language
game. What matters is not what you call it but the choices one makes when designing a procedure
for summarization. And indeed, there are many choices.
Submodularity offers essentially an infinite number of ways to perform data sketching and coresets.
When we view the submodular function as an information function (as we discussed in Section 6.9.7),
where f(X) is the information contained in set X and f(V ) is the maximum available information,
finding the small X that maximizes f(X) (i.e., X∗ ∈ argmax{f(X) : |X| ≤ k}), is a form of coreset
computation that is parameterized by the function f which has 2
n parameters since f lives in a
2
n-dimensional cone. Performing this maximization will then minimize the residual information
f(V \ X|X) about anything not present in the summary V \ X since f(V ) = f(X ∪ V \ X) =
f(V \ X|X) + f(X) so maximizing f(X) will minimize f(V \ X|X). For every f, moreover, the same
algorithm (e.g., the greedy algorithm) can be used to produce the summarization, and in every case,
there is an approximation guarantee relative to the current f, as mentioned in earlier sections, as long
as f stays submodular. Hence, submodularity provides a universal framework for summarization,
coresets, and sketches to the extent that the space of submodular functions itself is sufficiently
diverse and spans over different coreset problems.
Overall, the coreset or sketching problem, when using submodular functions, therefore becomes
a problem of “submodular design”. That is, how do we construct a submodular function that, for
a particular problem, acts as a good coreset producer when the function is maximized. There are
three general approaches to produce an f that works well as a summarization objective: (1) a
10. Data distillation is distinct from the notion of knowledge distillation [HVD14; BC14; BCNM06] or model distillation,
where the “knowledge” contained in a large model is distilled or reduced down into a different smaller model.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.9. SUBMODULAR OPTIMIZATION
pragmatic approach where the function is constructed by hand and heuristics, (2) a learning approach
where all or part of the submodular function is inferred from an optimization procedure, and (3) a
mathematical approach where a given submodular function when optimized offers a coreset property.
When the primary goal is a practical and scalable algorithm that can produce an extractive
summary that works well on a variety of different data types, and if one is comfortable with heuristics
that work well in practice, a good option is to specify a submodular function by hand. For example,
given a similarity matrix, it is easy to instantiate a facility location function and maximize it to
produce a summary. If there are multiple similarity matrices, one can construct multiple facility
location functions and maximize their convex combination. Such an approach is viable and practical
and has been used successfully many times in the past for producing good summaries. One of the
earliest examples of this is the algorithm presented in [KKT03] that shows how a submodular model
can be used to select the most influential nodes in a social network. Perhaps the earliest example of
this approach used for data subset selection for machine learning is [LB09] which utilizes a submodular
facility location function based on Fisher kernels (gradients wrt parameters of log probabilities)
and applies it to unsupervised speech selection to reduce transcription costs. Other examples of
this approach includes: [LB10a; LB11] which developed submodular functions for query-focused
document summarization; [KB14b] which computes a subset of training data in the context of
transductive learning in a statistical machine translation system; [LB10b; Wei+13; Wei+14] which
develops submodular functions for speech data subset selection (the former, incidentally, is the first
use of a deep submodular function and the latter does this in an unsupervised label-free fashion);
[SS18a] which is a form of robust submodularity for producing coresets for training CNNs; [Kau+19]
which uses a facility location to facilitate diversity selection in active learning; [Bai+15; CTN17]
which develops a mixture of submodular functions for document summarization where the mixture
coefficients are also included in the hyperparameter set; and [Xu+15], which uses a symmetrized
submodular function for the purposes of video summarization.
The learnability and identifiability of submodular functions has received a good amount of study
from a theoretical perspective. Starting with the strictest learning settings, the problem looks pretty
dire. For example, [SF08; Goe+09] shows that if one is restricted to making a polynomial number of
queries (i.e., training pairs of the form (S, f(S))) of a monotone submodular function, then it is not
possible to approximate f with a multiplicative approximation factor better than Ω( ˜
√
n). In [BH11],
goodness is judged multiplicatively, meaning for a set A ⊆ V we wish that ˜f(A) ≤ f(A) ≤ g(n)f(A)
for some function g(n), and this is typically a probabilistic condition (i.e., measured by distribution,
or ˜f(A) ≤ f(A) ≤ g(n)f(A), should happen on a fraction at least 1 − β of the points). Alternatively,
goodness may also be measured by an additive approximation error, say by a norm. I.e., defining
errp(f, ˜f) = kf − ˜fkp = (EA∼Pr[|f(A) − ˜f(A)|
p
])1/p, we may wish errp(f, ˜f) < ǫ for p = 1 or p = 2.
In the PAC (probably approximately correct) model, we probably (δ > 0) approximately (ǫ > 0
or g(n) > 1) learn (β = 0) with a sample or algorithmic complexity that depends on δ and g(n).
In the PMAC (probably mostly approximately correct) model [BH11], we also “mostly” (β > 0)
learn. In some cases, we wish to learn the best submodular approximation to a non-submodular
function. In other cases, we are allowed to deviate from submodularity as long as the error is small.
Learning special cases includes coverage functions [FK14; FK13a], and low-degree polynomials [FV15],
curvature limited functions [IJB13], functions with a limited “goal” [DHK14; Bac+18], functions
that are Fourier sparse [Wen+20a], or that are of a family called “juntas” [FV16], or that come from
families other than submodular [DFF21], and still others [BRS17; FKV14; FKV17; FKV20; FKV13;
YZ19]. Other results include that one cannot minimize a submodular function by learning it first
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license330
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
from samples [BS17]. The essential strategy of learning is to attempt to construct a submodular
function approximation ˆf from an underlying submodular function f querying the latter only a small
number of times. The overall gist of these results is that it is hard to learn everywhere and accurately.
In the machine learning community, learning can be performed extremely efficiently in practice,
although there are not the types of guarantees as one finds above. For example, given a mixture
of submodular components of the form f(A) = P
i αifi(A), if each fi
is considered fixed, then the
learning occurs only over the mixture coefficients αi
. This can be solved as a linear regression problem
where the optimal coefficients can be computed in a linear regression setting. Alternatively, such
functions can be learnt in a max-margin setting where the goal is primarily to adjust αi to ensure
that f(A) is large on certain subsets [SSJ12; LB12; Tsc+14]. Even here there are practical challenges,
however, since it is in general hard in practice to obtain a training set of pairs {(Si
, F(Si))}i
.
Alternatively, one can also “learn” a submodular function in a reinforcement learning setting [CKK17]
by optimizing the implicit function directly from gain vectors queried from an environment. In general,
such practical learning algorithms have been used for image summarization [Tsc+14], document
summarization [LB12], and video summarization [GGG15; Vas+17a; Gon+14; SGS16; SLG17]. While
none of these learning approaches claim to approximate some true underlying submodular function,
in practice, they do perform better than the by-hand crafting of a submodular function mentioned
above.
By a submodularity based coreset, we mean one where the direct optimization of a submodular
function offers a theoretical guarantee for some specific problem. This is distinct from above where
the submodular function is used as a surrogate heuristic objective function and for which, even if the
submodular function is learnt, optimizing it is only a heuristic for the original problem. In some
limited cases, it can be shown that the function we wish to approximate is already submodular,
e.g., in the case of certain naive Bayes and k-NN classifiers [WIB15] where the training accuracy,
as a function of the training data subset, can be shown to be submodular. Hence, maximizing this
function offers the same guarantee on the training accuracy as it does on the submodular function.
Unfortunately, the accuracy for many models is not a submodular function, although they do have a
difference of submodular [NB05; IB12] decomposition.
In other cases, it can be shown that certain desirable coreset objectives are inherently submodular.
For example, in [MBL20], it is shown that the normed difference between the overall gradient
(from summing over all samples in the training data) and an approximate gradient (from summing
over only samples in a summary) can be upper bounded with a supermodular function that, when
converted to a submodular facility location function and maximized, will select a set that reduces
this difference, and will lead to similar convergence rates to an approximate optimum solution in the
convex case. A similar example of this in a DPP context is shown in [TBA19]. In other cases, subsets
of the training data and training occur simultaneously using a continuous-discrete optimization
framework, where the goal is to minimize the loss on diverse and challenging samples measured by a
submodular objective [ZB18]. In still other cases, bi-level objectives related to but not guaranteed to
be submodular can be formed where a set is selected from a training set with the deliberate purpose
of doing well on a validation set [Kil+20; BMK20].
The methods above have focused on reducing the number of samples in a training dataset.
Considering the transpose of a design matrix, however, all of the above methods can be used for
reducing the features of a machine learning procedure as well. Specifically, any of the extractive
summarization, subset selection, or coreset methods can be seen as feature selection while any of
the abstract summarization, sketching, or distillation approaches can be seen as dimensionality
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.9. SUBMODULAR OPTIMIZATION
reduction.
6.9.7 Combinatorial information functions
The entropy function over a set of random variables X1, X2, . . . , Xn is defined as H(X1, X2, . . . , Xn) =
−
P
x1,x2,...,xn
p(x1, . . . , xn)log p(x1, . . . , xn). From this we can define three set-argument conditional
mutual information functions as IH(A; B|C) = I(XA; XB|XC ) where the latter is the mutual
information between variables indexed by A and B given variables indexed by C. This mutual
information expresses the residual information between XA and XB that is not explained by their
common information with XC .
As mentioned above, we may view any polymatroid function as a type of information function over
subsets of V . That is, f(A) is the information in set A — to the extent that this is true, this property
justifies f’s use as a summarization objective as mentioned above. The reason f may be viewed as
an information function stems from f being normalized, f’s non-negativity, f’s monotonicity, and
the property that further conditioning reduces valuation (i.e., f(A|B) ≥ f(A|B, C) which is identical
to the submodularity property). These properties were deemed as essential to the entropy function in
Shannon’s original work [Sha48] but are true of any polymatroid function as well. Hence, given any
polymatroid function f, is it possible to define a combinatorial mutual information function [Iye+21]
in a similar way. Specifically, we can define the combinatorial (submodular) conditional mutual
information (CCMI) as If (A; B|C) = f(A + C) + f(B + C) − f(C) − f(A + B + C), which has been
known as the connectivity function [Cun83] amongst other names. If f is the entropy function, then
this yields the standard entropic mutual information but here the mutual information can be defined
for any submodular information measure f. For an arbitrary polymatroid f, therefore, If (A; B|C)
can be seen as an A, B set-pair similarity score that ignores, neglects, or discounts any common
similarity between the A, B pair that is due to C.
Historical use of a special case of CCMI, i.e., If (A; B) where C = ∅, occurred in a number of
circumstances. For example, in [GKS05] the function g(A) = If (A; V \A) (which, incidentally, is both
symmetric (g(A) = g(V \A) for all A) and submodular) was optimized using the greedy procedure; this
has a guarantee as long as g(A) is monotone up 2k elements whenever one wishes for a summary of size
k. This was done for f being the entropy function, but it can be used for any polymatroid function. In
similar work, where f is the Shannon entropy function, [KG05] demonstrated that gC (A) = If (A; C)
(for a fixed set C) is not submodular in A but if it is the case that the elements of V are independent
given C then submodularity is preserved. This can be immediately seen by the consequence of this
independence assumption which yields that If (A; C) = f(A) − f(A|C) = f(A) −
P
a∈A f(a|C) where
the second equality is due to the conditional independence property. In this case, If is the difference
between a submodular and a modular function which preserves submodularity for any polymatroid f.
On the other hand, it would be useful for gB,C (A) = If (A; B|C), where B and C are fixed, to be
possible to optimize in terms of A. One can view this function as one that, when it is maximized,
chooses A to be similar to B in a way that neglects or discounts any common similarity that A and
B have with C. One option to optimize this function to utilize difference of submodular [NB05; IB12]
optimization as mentioned earlier. A more recent result shows that in some cases gB,C (A) is still
submodular in A. Define the second-order partial derivative of a submodular function f as follows
f(i, j|S) , f(j|S + i) − f(j|S). Then if it is the case that f(i, j|S) is monotone non-decreasing in S
for S ⊆ V \ {i, j} then If (A; B|C) is submodular in A for fixed B and C. It may be thought that
only esoteric functions have this property, but in fact [Iye+21] shows that this is true for a number
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license332
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
of widely used submodular functions in practice, including the facility location function which results
in the form If (A; B|C) = P
v∈V max
min￾P
a∈A sim(v, a), maxb∈B sim(v, b)

− maxc∈C sim(v, c), 0

.
This function was used [Kot+22] to produce summaries A that were particularly relevant to a query
given by B but that should neglect information in C that can be considered “private” information to
avoid.
6.9.8 Clustering, data partitioning, and parallel machine learning
There are an almost unlimited number of clustering algorithms and a plethora of reviews on their
variants. Any given submodular function can also instantiate a clustering procedure as well, and
there are several ways to do this. Here we offer only a brief outline of the approach. In the last
section, we defined If (A; V \ A) as the CCMI between A and everything but A. When we view this
as a function of A, then g(A) = If (A; V \ A) and g(A) is a symmetric submodular function that
can be minimized using Queyranne’s algorithm [Que98; NI92]. Once this is done, the resulting A
is such that it is least similar to V \ A, according to If (A; V \ A) and hence forms a 2-clustering.
This process can then be recursively applied where we form two new functions gA(B) = If (B; A \ B)
for B ⊆ A and gV \A(B) = If (B; (V \ A) \ B) for B ⊆ V \ A. These are two symmetric submodular
functions on different ground sets that also can be minimized using Queyranne’s algorithm. This
recursive bisection algorithm then repeats until the desired number of clusters is formed. Hence, the
CCMI function can be used as a top-down recursive bisection clustering procedure and has been
called Q-clustering [NJB05; NB06]. It should be noted that such forms of clustering often generalize
forming a multiway cut in an undirected graph in which case the objective becomes the graph-cut
function that, as we saw above, is also submodular. In some cases, the number of clusters need
not be specified in advance [NKI10]. Another submodular approach to clustering can be found
in [Wei+15b] where the goal is to minimize the maximum valued block in a partitioning which can
lead to submodular load balancing or minimum makespan scheduling [HS88; LST90].
Yet another form of clustering can be seen via the simple cardinality constrained submodular
maximization process itself which can be compared to a k-medoids process whenever the objective f
is the facility location function. Hence, any such submodular function can be seen as a submodular￾function-parameterized form of finding the k “centers” among a set of data items. There have been
numerous applications of submodular clustering. For example, using these techniques it is possible to
identify parcellations of the human brain [Sal+17a]. Other applications include partitioning data for
more effective and accurate and lower variance distributed machine learning training [Wei+15a] and
also for more ideal mini-batch construction for training deep neural networks [Wan+19b].
6.9.9 Active and semi-supervised learning
Suppose we are given dataset {xi
, yi}i∈V consisting of |V | = n samples of x, y pairs but where the
labels are unknown. Samples are labeled one at a time or one mini-batch at a time, and after
each labeling step t each remaining unlabeled sample is given a score st(xi) that indicates the
potential benefit of acquiring a label for that sample. Examples include the entropy of the model’s
output distribution on xi
, or a margin-based score consisting of the difference between the top and
the second-from-the-top posterior probability. This produces a modular function on the unlabeled
samples, mt(A) = P
a∈A s(xa) where A ⊆ V . It is simple to use this modular function to produce
a mini-batch active learning procedure where at each stage we form At ∈ argmaxA⊆Ut:|A|=k mt(A)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.9. SUBMODULAR OPTIMIZATION
where Ut is the set of unlabeled samples at stage t. Then At is a set of size k that gets labeled, we
form Ut = Ut \ At, update st(a) for a ∈ Ut, and repeat. This is called active learning.
The reason for using active learning with mini-batches of size greater than one is that it is often
inefficient to ask for a single label at a time. The problem with such a minibatch strategy, however,
is that the set At can be redundant. The reason is that the uncertainty about every sample in At
could be owing to the same underlying cause — even though the model is most uncertain about
samples in At, once one sample in At is labeled, it may not be optimal to label the remaining samples
in At due to this redundancy. Utilizing submodularity, therefore, can help reduce this redundancy.
Suppose ft(A) is a submodular diversity model over samples at step t. At each stage, choosing
the set of samples to label becomes At ∈ argmaxA⊆Ut:|A|=k mt(A) + ft(A) — At is selected based
on a combination of both uncertainty (via mt(A)) and diversity (via ft(A)). This is precisely the
submodular active learning approach taken in [WIB15; Kau+19].
Another quite different approach to a form of submodular “batch” active learning setting where a
batch L of labeled samples are selected all at once and then used to label the rest of the unlabeled
samples. This also allows the remaining unlabeled samples to be utilized in a semi-supervised
framework [GB09; GB11]. In this setting, we start with a graph G = (V, E) where the nodes V
need to be given a binary {0, 1}-valued label, y ∈ {0, 1}
V
. For any A ⊆ V let yA ∈ {0, 1}
A be
the labels just for node set A. We also define V (y) ⊆ V as V (y) = {v ∈ V : yv = 1}. Hence
V (y) are the graph nodes labeled 1 by y and V \ V (y) are the nodes labeled 0. Given submodular
objective f, we form its symmetric CCMI variant If (A) , If (A; V \ A) — note that If (A) is always
submodular in A. This allows If (V (y)) to determine the “smoothness” of a given candidate labeling
y. For example, if If is the weighted graph cut function where each weight corresponds to an affinity
between the corresponding two nodes, then If (V (y)) would be small if V (y) (the 1-labeled nodes)
do not have strong affinity with V \ V (y) (the 0-labeled nodes). In general, however, If can be any
symmetric submodular function. Let L ⊆ V be any candidate set of nodes to be labeled, and define
Ψ(L) , minT ⊆(V \L):T6=∅ If (T)/|T|. Then Ψ(L) measures the “strength” of L in that if Ψ(L) is small,
an adversary can label nodes other than L without being too unsmooth according to If , while if
Ψ(L) is large, an adversary can do no such thing. Then [GB11] showed that given a node set L to be
queried, and the corresponding correct labels yL that are completed (in a semi-supervised fashion)
according to the following y
′ = argminyˆ∈{0,1}V :ˆyL=yL
If (V (yˆ)), then this results in the following
bound on the true labeling ky − y
′k
2 ≤ 2If (V (y))/Ψ(L) suggesting that we can find a good set
to query by maximizing L in Ψ(L), and this holds for any submodular function. Of course, it is
necessary to find an underlying submodular function f that fits a given problem, and this is discussed
in Section 6.9.6.
6.9.10 Probabilistic modeling
Graphical models are often used to describe factorization requirements on families of probability
distributions. Factorization is not the only way, however, to describe restrictions on such families.
In a graphical model, graphs describe only which random variable may directly interact with other
random variables. An entirely different strategy for producing families of often-tractable probabilistic
models can be produced without requiring any factorization property at all. Considering an energy
function E(x) where p(x) ∝ exp(−E(x)), factorizations correspond to there being cliques in the
graph such that the graph’s tree-width often is limited. On the other hand, finding maxx p(x) is the
same as finding minx E(x), something that can be done if E(x) = f(V (x)) is a submodular function
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license334
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(using the earlier used notation V (x) to map from binary vectors to subsets of V ). Even a submodular
function as simple as f(A) = p
|A|−m(A) where m is modular has tree-width of n−1, and this leads
to an energy function E(x) that allows maxx p(x) to be solved in polynomial time using submodular
function minimization (see Section 6.9.4.3). Such restrictions to E(x) therefore are not of the form
amongst the random variables, who is allowed to directly interact with whom, but rather amongst the
random variables, what is the manner that they interact. Such potential function restrictions can
also combine with direct interaction restrictions as well, and this has been widely used in computer
vision, leading to cases where graph-cut and graph-cut like “move making” algorithms (such as α − β
swap and α-expansion algorithms) used in attractive models (see Supplementary Section 9.3.4.3).
In fact, the culmination of these efforts [KZ02] lead to a rediscovery of the submodularity (or the
“regular” property) as being the essential ingredient for when Markov random fields can be solved
using graph cut minimization, which is a special case of submodular function minimization.
The above model can be seen as log-supermodular since log p(x) = −E(x) + log 1/Z is a super￾modular function. These are all distributions that put high probability on configurations that yield
small valuation by a submodular function. Therefore, these distributions have high probability when
x consists of a homogeneous set of assignments to the elements of x. For this reason, they are
useful for computer vision segmentation problems (e.g., in a segment of an image, the nearby pixels
should roughly be homogeneous as that is often what defines an object). The DPPs we saw above,
however, are an example of a log-submodular probability distribution since f(X) = log det(MX) is
submodular. These models have high probability for diverse sets.
More generally, E(x) being either a submodular or supermodular function can produce log￾submodular or log-supermodular distributions, covering both cases above where the partition function
takes the form Z =
P
A⊆V
exp(f(A)) for objective f. Moreover, we often wish to perform tasks much
more than just finding the most probable random variable assignments. This includes marginalization,
computing the partition function, constrained maximization, and so on. Unfortunately, many of these
more general probabilistic inference problems do not have polynomial time solutions even though
the objectives are submodular or supermodular. On the other hand, such structure has opened the
doors to an assortment of new probabilistic inference procedures that exploit this structure [DK14;
DK15a; DTK16; ZDK15; DJK18]. Most of these methods were of the variational sort and offered
bounds on the partition function Z, sometimes making use of the fact that submodular functions
have easily computable semi-gradients [IB15; Fuj05] which are modular upper and lower bounds on a
submodular or supermodular function that are tight at one or more subsets. Given a submodular (or
supermodular) function f and a set A, it is possible to easily construct (in linear time) a modular
function upper bound mA : 2V → R and a modular function lower bound mA : 2V → R having
the properties that mA(X) ≤ f(X) ≤ mA(X) for all X ⊆ V and that is tight at X = A meaning
mA(A) = f(A) = mA(A) [IB15]. For any modular function m, the probability function for a
characteristic vector x = 1A becomes p(1A) = 1/Z exp(E(1A)) = Q
a∈A σ(m(a)) Q
a /∈A σ(−m(a))
where σ is the logistic function. Thus, a modular approximation of a submodular function is like a
mean-field approximation of the distribution and makes the assumption that all random variables
are independent. Such an approximation can then be used to compute quantities such as upper and
lower bounds on the partition function, and much else.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.9. SUBMODULAR OPTIMIZATION
6.9.11 Structured norms and loss functions
Convex norms are used ubiquitously in machine learning, often as complexity penalizing regularizers
(e.g., the ubiquitous p-norms for p ≥ 1) and also sometimes as losses (e.g., squared error). Identifying
new useful structured and possibly learnable sparse norms is an interesting and useful endeavor,
and submodularity can help here as well. Firstly, recall the ℓ0 or counting norm kxk0 simply counts
the number of nonzero entries in x. When we wish for a sparse solution, we may wish to regularize
using kxk0 but it both leads to an intractable combinatorial optimization problem, and it leads to an
object that is not differentiable. The usual approach is to find the closest convex relaxation of this
norm and that is the one norm or kxk1. This is convex in x and has a sub-gradient structure and
hence can be combined with a loss function to produce an optimizable machine learning objective,
for example the lasso. On the other hand, kxk1 has no structure, as each element of x is penalized
based on its absolute value irrespective of the state of any of the other elements. There have thus
been efforts to develop group norms that penalize groups or subsets of elements of x together, such
as group lasso [HTW15].
It turns out that there is a way to utilize a submodular function as the regularizer. Penalizing
x via kxk0 is identical to penalizing it via |V (x)| and note that m(A) = |A| is a modular function.
Instead, we could penalize x via f(V (x)) for a submodular function f. Here, any element of x
being non-zero would allow for a diminishing penalty of other elements of x being zero all according
to the submodular function, and such cooperative penalties can be obtained via a submodular
parameterization. Like when using the zero-norm kxk0, this leads to the same combinatorial problem
due to continuous optimization of x with a penalty term of the form f(V (x)). To address this, we can
use the Lovász extension ˘f(x) on a vector x. This function is convex, but it is not a norm, but if we
consider the construct defined as kxkf = ˘f(|x|), it can be shown that this satisfies all the properties
of a norm for all non-trivial submodular functions [PG98; Bac+13] (i.e., those normalized submodular
functions for which f(v) > 0 for all v). In fact, the group lasso mentioned above is a special case
for a particularly simple feature-based submodular function (a sum of min-truncated cardinality
functions). But in principle, the same submodular design strategies mentioned in Section 6.9.6 can
be used to produce a submodular function to instantiate an appropriate convex structured norm for
a given machine learning problem.
6.9.12 Conclusions
We have only barely touched the surface of submodularity and how it applies to and can benefit
machine learning. For more details, see [Bil22] and the many references contained therein. Considering
once again the innocuous looking submodular inequality, then very much like the definition of
convexity, we observe something that belies much of its complexity while opening the gates to wide
and worthwhile avenues for machine learning exploration.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensePart II
Inference7 Inference algorithms: an overview
7.1 Introduction
In the probabilistic approach to machine learning, all unknown quantities — be they predictions
about the future, hidden states of a system, or parameters of a model — are treated as random
variables, and endowed with probability distributions. The process of inference corresponds to
computing the posterior distribution over these quantities, conditioning on whatever data is available.
In more detail, let θ represent the unknown variables, and D represent the known variables. Given
a likelihood p(D|θ) and a prior p(θ), we can compute the posterior p(θ|D) using Bayes’ rule:
p(θ|D) = p(θ)p(D|θ)
p(D)
(7.1)
The main computational bottleneck is computing the normalization constant in the denominator,
which requires solving the following high dimensional integral:
p(D) = Z
p(D|θ)p(θ)dθ (7.2)
This is needed to convert the unnormalized joint probability of some parameter value, p(θ, D), to a
normalized probability, p(θ|D), which takes into account all the other plausible values that θ could
have.
Once we have the posterior, we can use it to compute posterior expectations of some function of
the unknown variables, i.e.,
E [g(θ)|D] = Z
g(θ)p(θ|D)dθ (7.3)
By defining g in the appropriate way, we can compute many quantities of interest, such as the
following:
mean: g(θ) = θ (7.4)
covariance: g(θ) = (θ − E [θ|D])(θ − E [θ|D])T
(7.5)
marginals: g(θ) = p(θ1 = θ
∗
1
|θ2:D) (7.6)
predictive: g(θ) = p(yN+1|θ) (7.7)
expected loss: g(θ) = ℓ(θ, a) (7.8)340
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
θy
y1 yN
· · ·
x1 xN
(a)
θz
z1 zN
· · ·
x1 xN
θx
(b)
θz
z1 zN
· · ·
x1 xN
θx
(c)
Figure 7.1: Graphical models with (a) global hidden variables for representing the Bayesian discriminative
model p(y1:N , θy|x1:N ) = p(θy)
QN
n=1 p(yn|xn; θy); (b) local hidden variables for representing the generative
model p(x1:N , z1:N |θ) = QN
n=1 p(zn|θz)p(xn|zn, θx); (c) local and global hidden variables for representing
the Bayesian generative model p(x1:N , z1:N , θ) = p(θz)p(θx)
QN
n=1 p(zn|θz)p(xn|zn, θx). Shaded nodes are
assumed to be known (observed), unshaded nodes are hidden.
where yN+1 is the next observation after seeing the N examples in D, and the posterior expected
loss is computing using loss function ℓ and action a (see Section 34.1.3). Finally, if we define
g(θ) = p(D|θ, M) for model M, we can also phrase the marginal likelihood (Section 3.8.3) as an
expectation wrt the prior:
E [g(θ)|D] = Z
g(θ)p(θ|M)dθ =
Z
p(D|θ, M)p(θ|M)dθ = p(D|M) (7.9)
Thus we see that integration (and computing expectations) is at the heart of Bayesian inference,
whereas differentiation is at the heart of optimization.
In this chapter, we give a high level summary of algorithmic techniques for computing (approximate)
posteriors, and/or their corresponding expectations. We will give more details in the following chapters.
Note that most of these methods are independent of the specific model. This allows problem solvers
to focus on creating the best model possible for the task, and then relying on some inference engine
to do the rest of the work — this latter process is sometimes called “turning the Bayesian crank”.
For more details on Bayesian computation, see e.g., [Gel+14a; MKL21; MFR20].
7.2 Common inference patterns
There are kinds of posterior we may want to compute, but we can identify 3 main patterns, as we
discuss below. These give rise to different types of inference algorithm, as we will see in later chapters.
7.2.1 Global latents
The first pattern arises when we need to perform inference in models which have global latent
variables, such as parameters of a model θ, which are shared across all N observed training cases.
This is shown in Figure 7.1a, and corresponds to the usual setting for supervised or discriminative
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
7.2. COMMON INFERENCE PATTERNS
learning, where the joint distribution has the form
p(y1:N , θ|x1:N ) = p(θ)
"Y
N
n=1
p(yn|xn, θ)
#
(7.10)
The goal is to compute the posterior p(θ|x1:N , y1:N ). Most of the Bayesian supervised learning
models discussed in Part III follow this pattern.
7.2.2 Local latents
The second pattern arises when we need to perform inference in models which have local latent
variables, such as hidden states z1:N ; we assume the model parameters θ are known. This is shown
in Figure 7.1b. Now the joint distribution has the form
p(x1:N , z1:N |θ) = "Y
N
n=1
p(xn|zn, θx)p(zn|θz)
#
(7.11)
The goal is to compute p(zn|xn, θ) for each n. This is the setting we consider for most of the PGM
inference methods in Chapter 9.
If the parameters are not known (which is the case for most latent variable models, such as mixture
models), we may choose to estimate them by some method (e.g., maximum likelihood), and then
plug in this point estimate. The advantage of this approach is that, conditional on θ, all the latent
variables are conditionally independent, so we can perform inference in parallel across the data. This
lets us use methods such as expectation maximization (Section 6.5.3), in which we infer p(zn|xn, θt)
in the E step for all n simultaneously, and then update θt in the M step. If the inference of zn
cannot be done exactly, we can use variational inference, a combination known as variational EM
(Section 6.5.6.1).
Alternatively, we can use a minibatch approximation to the likelihood, marginalizing out zn for
each example in the minibatch to get
log p(Dt|θt) = X
n∈Dt
log "X
zn
p(xn, zn|θt)
#
(7.12)
where Dt is the minibatch at step t. If the marginalization cannot be done exactly, we can use
variational inference, a combination known as stochastic variational inference or SVI (Section 10.1.4).
We can also learn an inference network qφ(z|x; θ) to perform the inference for us, rather than running
an inference engine for each example n in each batch t; the cost of learning φ can be amortized
across the batches. This is called amortized SVI (see Section 10.1.5).
7.2.3 Global and local latents
The third pattern arises when we need to perform inference in models which have local and global
latent variables. This is shown in Figure 7.1c, and corresponds to the following joint distribution:
p(x1:N , z1:N , θ) = p(θx)p(θz)
"Y
N
n=1
p(xn|zn, θx)p(zn|θz)
#
(7.13)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license342
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
This is essentially a Bayesian version of the latent variable model in Figure 7.1b, where now we
model uncertainty in both the local variables zn and the shared global variables θ. This approach is
less common in the ML community, since it is often assumed that the uncertainty in the parameters
θ is negligible compared to the uncertainty in the local variables zn. The reason for this is that
the parameters are “informed” by all N data cases, whereas each local latent zn is only informed
by a single datapoint, namely xn. Nevertheless, there are advantages to being “fully Bayesian”, and
modeling uncertainty in both local and global variables. We will see some examples of this later in
the book.
7.3 Exact inference algorithms
In some cases, we can perform example posterior inference in a tractable manner. In particular, if
the prior is conjugate to the likelihood, the posterior will be analytically tractable. In general, this
will be the case when the prior and likelihood are from the same exponential family (Section 2.4). In
particular, if the unknown variables are represented by θ, then we assume
p(θ) ∝ exp(λ
T
0T (θ)) (7.14)
p(yi
|θ) ∝ exp(λ˜
i(yi)
T
T (θ)) (7.15)
where T (θ) are the sufficient statistics, and λ are the natural parameters. We can then compute the
posterior by just adding the natural parameters:
p(θ|y1:N ) = exp(λ
T
∗T (θ)) (7.16)
λ∗ = λ0 +
X
N
n=1
λ˜
n(yn) (7.17)
See Section 3.4 for details.
Another setting where we can compute the posterior exactly arises when the D unknown variables
are all discrete, each with K states; in this case, the integral for the normalizing constant becomes a
sum with KD terms. In many cases, KD will be too large to be tractable. However, if the distribution
satisfies certain conditional independence properties, as expressed by a probabilistic graphical model
(PGM), then we can write the joint as a product of local terms (see Chapter 4). This lets us use
dynamic programming to make the computation tractable (see Chapter 9).
7.4 Approximate inference algorithms
For most probability models, we will not be able to compute marginals or posteriors exactly, so we
must resort to using approximate inference. There are many different algorithms, which trade
off speed, accuracy, simplicity, and generality. We briefly discuss some of these algorithms below,
and give more detail in the following chapters. (See also [Alq22; MFR20] for a review of various
methods.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
7.4. APPROXIMATE INFERENCE ALGORITHMS
−2 0 2 4
x
0
2
4
p(x)
0.5N (x|0, 2)+
0.5N (x|2, 0.05)
mean
(a)
0 2 4 6
x
0.0
0.2
0.4
0.6
0.8
1.0
p(x)
Gamma(1,1) distribution
a=1.0, b=1.0
(b)
Figure 7.2: Two distributions in which the mode (highest point) is untypical of the distribution; the mean
(vertical red line) is a better summary. (a) A bimodal distribution. Generated by bimodal_dist_plot.ipynb.
(b) A skewed Ga(1, 1) distribution. Generated by gamma_dist_plot.ipynb.
7.4.1 The MAP approximation and its problems
The simplest approximate inference method is to compute the MAP estimate
θˆ = argmax p(θ|D) = argmax log p(θ) + log p(D|θ) (7.18)
and then to assume that the posterior puts 100% of its probability on this single value:
p(θ|D) ≈ δ(θ − θˆ) (7.19)
The advantage of this approach is that we can compute the MAP estimate using a variety of
optimization algorithms, which we discuss in Chapter 6. However, the MAP estimate also has various
drawbacks, some of which we discuss below.
7.4.1.1 The MAP estimate gives no measure of uncertainty
In many statistical applications (especially in science) it is important to know how much one can trust
a given parameter estimate. Obviously a point estimate does not convey any notion of uncertainty.
Although it is possible to derive frequentist notions of uncertainty from a point estimate (see
Section 3.3.1), it is arguably much more natural to just compute the posterior, from which we can
derive useful quantities such as the standard error (see Section 3.2.1.6) and credible regions (see
Section 3.2.1.7).
In the context of prediction (which is the main focus in machine learning), we saw in Section 3.2.2
that plugging in a point estimate can underestimate the predictive uncertainty, which can result in
predictions which are not just wrong, but confidently wrong. It is generally considered very important
for a predictive model to “know what it does not know”, and the Bayesian approach is a good strategy
for achieving this goal.
7.4.1.2 The MAP estimate is often untypical of the posterior
In some cases, we may not be interested in uncertainty, and instead we just want a single summary
of the posterior. However, the mode of a posterior distribution is often a very poor choice as a
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license344
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0.0 0.2 0.4 0.6 0.8 1.0
θ
0
2
4
p(θ)
True Posterior
Grid approximation
(a)
0.0 0.2 0.4 0.6 0.8 1.0
θ
0
2
4
p(θ)
Laplace approximation
True posterior
(b)
Figure 7.3: Approximating the posterior of a beta-Bernoulli model. (a) Grid approximation using 20 grid
points. (b) Laplace approximation. Generated by laplace_approx_beta_binom.ipynb.
summary statistic, since the mode is usually quite untypical of the distribution, unlike the mean or
median. This is illustrated in Figure 7.2(a) for a 1d continuous space, where we see that the mode is
an isolated peak (black line), far from most of the probability mass. By contrast, the mean (red line)
is near the middle of the distribution.
Another example is shown in Figure 7.2(b): here the mode is 0, but the mean is non-zero. Such
skewed distributions often arise when inferring variance parameters, especially in hierarchical models.
In such cases the MAP estimate (and hence the MLE) is obviously a very bad estimate.
7.4.1.3 The MAP estimate is not invariant to reparameterization
A more subtle problem with MAP estimation is that the result we get depends on how we parameterize
the probability distribution, which is not very desirable. For example, when representing a Bernoulli
distribution, we should be able to parameterize it in terms of probability of success, or in terms of
the log-odds (logit), without that affecting our beliefs.
For example, let xˆ = argmaxx px(x) be the MAP estimate for x. Now let y = f(x) be a
transformation of x. In general it is not the case that yˆ = argmaxy py(y) is given by f(xˆ). For
example, let x ∼ N (6, 1) and y = f(x), where f(x) = 1
1+exp(−x+5) . We can use the change of
variables (Section 2.5.1) to conclude py(y) = px(f
−1
(y))|
df−1
(y)
dy |. Alternatively we can use a Monte
Carlo approximation. The result is shown in Figure 2.12. We see that the original Gaussian for
p(x) has become “squashed” by the sigmoid nonlinearity. In particular, we see that the mode of the
transformed distribution is not equal to the transform of the original mode.
We have seen that the MAP estimate depends on the parameterization. The MLE does not suffer
from this since the likelihood is a function, not a probability density. Bayesian inference does not
suffer from this problem either, since the change of measure is taken into account when integrating
over the parameter space.
7.4.2 Grid approximation
If we want to capture uncertainty, we need to allow for the fact that θ may have a range of possible
values, each with non-zero probability. The simplest way to capture this property is to partition
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
7.4. APPROXIMATE INFERENCE ALGORITHMS
the space of possible values into a finite set of regions, call them r1, . . . , rK, each representing a
region of parameter space of volume ∆ centered on θk. This is called a grid approximation. The
probability of being in each region is given by p(θ ∈ rk|D) ≈ pk∆, where
pk =
p˜k
PK
k′=1 p˜k′
(7.20)
p˜k = p(D|θk)p(θk) (7.21)
As K increases, we decrease the size of each grid cell. Thus the denominator is just a simple numerical
approximation of the integral
p(D) = Z
p(D|θ)p(θ)dθ ≈
X
K
k=1
∆˜pk (7.22)
As a simple example, we will use the problem of approximating the posterior of a beta-Bernoulli
model. Specifically, the goal is to approximate
p(θ|D) ∝
"Y
N
n=1
Ber(yn|θ)
#
Beta(1, 1) (7.23)
where D consists of 10 heads and 1 tail (so the total number of observations is N = 11), with
a uniform prior. Although we can compute this posterior exactly using the method discussed in
Section 3.4.1, this serves as a useful pedagogical example since we can compare the approximation to
the exact answer. Also, since the target distribution is just 1d, it is easy to visualize the results.
In Figure 7.3a, we illustrate the grid approximation applied to our 1d problem. We see that it
is easily able to capture the skewed posterior (due to the use of an imbalanced sample of 10 heads
and 1 tail). Unfortunately, this approach does not scale to problems in more than 2 or 3 dimensions,
because the number of grid points grows exponentially with the number of dimensions.
7.4.3 Laplace (quadratic) approximation
In this section, we discuss a simple way to approximate the posterior using a multivariate Gaussian;
this known as a Laplace approximation or quadratic approximation (see e.g., [TK86; RMC09]).
Suppose we write the posterior as follows:
p(θ|D) = 1
Z
e
−E(θ)
(7.24)
where E(θ) = − log p(θ, D) is called an energy function, and Z = p(D) is the normalization constant.
Performing a Taylor series expansion around the mode θˆ (i.e., the lowest energy state) we get
E(θ) ≈ E(θˆ) + (θ − θˆ)
T
g +
1
2
(θ − θˆ)
TH(θ − θˆ) (7.25)
where g is the gradient at the mode, and H is the Hessian. Since θˆ is the mode, the gradient term is
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license346
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
zero. Hence
pˆ(θ, D) = e
−E(θˆ)
exp

−
1
2
(θ − θˆ)
TH(θ − θˆ)

(7.26)
pˆ(θ|D) = 1
Z
pˆ(θ, D) = N (θ|θˆ, H−1
) (7.27)
Z = e
−E(θˆ)
(2π)
D/2
|H|
− 1
2 (7.28)
The last line follows from normalization constant of the multivariate Gaussian.
The Laplace approximation is easy to apply, since we can leverage existing optimization algorithms
to compute the MAP estimate, and then we just have to compute the Hessian at the mode. (In high
dimensional spaces, we can use a diagonal approximation.)
In Figure 7.3b, we illustrate this method applied to our 1d problem. Unfortunately we see that it is
not a particularly good approximation. This is because the posterior is skewed, whereas a Gaussian
is symmetric. In addition, the parameter of interest lies in the constrained interval θ ∈ [0, 1], whereas
the Gaussian assumes an unconstrained space, θ ∈ R
D. Fortunately, we can solve this latter problem
by using a change of variable. For example, in this case we can apply the Laplace approximation to
α = logit(θ). This is a common trick to simplify the job of inference.
See Section 15.3.5 for an application of Laplace approximation to Bayesian logistic regression, and
Section 17.3.2 for an application of Laplace approximation to Bayesian neural networks.
7.4.4 Variational inference
In Section 7.4.3, we discussed the Laplace approximation, which uses an optimization procedure to
find the MAP estimate, and then approximates the curvature of the posterior at that point based on
the Hessian. In this section, we discuss variational inference (VI), also called variational Bayes
(VB). This is another optimization-based approach to posterior inference, but which has much more
modeling flexibility (and thus can give a much more accurate approximation).
VI attempts to approximate an intractable probability distribution, such as p(θ|D), with one that
is tractable, q(θ), so as to minimize some discrepancy D between the distributions:
q
∗ = argmin
q∈Q
D(q, p) (7.29)
where Q is some tractable family of distributions (e.g., fully factorized distributions). Rather than
optimizing over functions q, we typically optimize over the parameters of the function q; we denote
these variational parameters by ψ.
It is common to use the KL divergence (Section 5.1) as the discrepancy measure, which is given by
D(q, p) = DKL (q(θ|ψ) k p(θ|D)) = Z
q(θ|ψ) log q(θ|ψ)
p(θ|D)
dθ (7.30)
where p(θ|D) = p(D|θ)p(θ)/p(D). The inference problem then reduces to the following optimization
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
7.4. APPROXIMATE INFERENCE ALGORITHMS
0.0 0.2 0.4 0.6 0.8 1.0
θ
0
2
4
Density
p(x): true posterior
q(x): variational posterior
(a)
0 200 400 600 800 1000
Iterations
6
8
10
Negative ELBO
(b)
0 200 400 600 800 1000
Iterations
−2
−1
0
Eq[z]
mu
(c)
0 200 400 600 800 1000
Iterations
0.7
0.8
0.9
stdq[z]
sigma
(d)
Figure 7.4: ADVI applied to the beta-Bernoulli model. (a) Approximate vs true posterior. (b) Negative ELBO
over time. (c) Variational µ parameter over time. (d) Variational σ parameter over time. Generated by
advi_beta_binom.ipynb.
problem:
ψ
∗ = argmin
ψ
DKL (q(θ|ψ) k p(θ|D)) (7.31)
= argmin
ψ
Eq(θ|ψ)

log q(θ|ψ) − log 
p(D|θ)p(θ)
p(D)
 (7.32)
= argmin
ψ
Eq(θ|ψ)
[− log p(D|θ) − log p(θ) + log q(θ|ψ)]
| {z }
−Ł(ψ)
+ log p(D) (7.33)
Note that log p(D) is independent of ψ, so we can ignore it when fitting the approximate posterior,
and just focus on maximizing the term
Ł(ψ) , Eq(θ|ψ)
[log p(D|θ) + log p(θ) − log q(θ|ψ)] (7.34)
Since we have DKL (q k p) ≥ 0, we have Ł(ψ) ≤ log p(D). The quantity log p(D), which is the log
marginal likelihood, is also called the evidence. Hence Ł(ψ) is known as the evidence lower
bound or ELBO. By maximizing this bound, we are making the variational posterior closer to the
true posterior. (See Section 10.1 for details.)
We can choose any kind of approximate posterior that we like. For example, we may use a Gaussian,
q(θ|ψ) = N (θ|µ, Σ). This is different from the Laplace approximation, since in VI, we optimize
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license348
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0.0 0.2 0.4 0.6
θ
0
2
4
p(θ)
Density of samples
chain 1
chain 2
chain 3
chain 4
0 200 400 600 800 1000
iteration
0.00
0.25
0.50
θ
Trace plot
Figure 7.5: Approximating the posterior of a beta-Bernoulli model using MCMC. (a) Kernel density estimate
derived from samples from 4 independent chains. (b) Trace plot of the chains as they generate posterior
samples. Generated by hmc_beta_binom.ipynb.
Σ, rather than equating it to the Hessian. If Σ is diagonal, we are assuming the posterior is fully
factorized; this is called a mean field approximation.
A Gaussian approximation is not always suitable for all parameters. For example, in our 1d
example we have the constraint that θ ∈ [0, 1]. We could use a variational approximation of the form
q(θ|ψ) = Beta(θ|a, b), where ψ = (a, b). However choosing a suitable form of variational distribution
requires some level of expertise. To create a more easily applicable, or “turn-key”, method, that works
on a wide range of models, we can use a method called automatic differentiation variational
inference or ADVI [Kuc+16]. This uses the change of variables method to convert the parameters
to an unconstrained form, and then computes a Gaussian variational approximation. The method
also uses automatic differentiation to derive the Jacobian term needed to compute the density of the
transformed variables. See Section 10.2.2 for details.
We now apply ADVI to our 1d beta-Bernoulli model. Let θ = σ(z), where we replace p(θ|D) with
q(z|ψ) = N (z|µ, σ), where ψ = (µ, σ). We optimize a stochastic approximation to the ELBO using
SGD. The results are shown in Figure 7.4 and seem reasonable.
7.4.5 Markov chain Monte Carlo (MCMC)
Although VI is fast, it can give a biased approximation to the posterior, since it is restricted to a
specific function form q ∈ Q. A more flexible approach is to use a non-parametric approximation in
terms of a set of samples, q(θ) ≈
1
S
PS
s=1 δ(θ − θ
s
). This is called a Monte Carlo approximation.
The key issue is how to create the posterior samples θ
s ∼ p(θ|D) efficiently, without having to
evaluate the normalization constant p(D) = R
p(θ, D)dθ.
For low dimensional problems, we can use methods such as importance sampling, which we
discuss in Section 11.5. However, for high dimensional problems, it is more common to use Markov
chain Monte Carlo or MCMC. We give the details in Chapter 12, but give a brief introduction
here.
The most common kind of MCMC is known as the Metropolis-Hastings algorithm. The basic
idea behind MH is as follows: we start at a random point in parameter space, and then perform a
random walk, by sampling new states (parameters) from a proposal distribution q(θ
′
|θ). If q is
chosen carefully, the resulting Markov chain distribution will satisfy the property that the fraction of
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
7.4. APPROXIMATE INFERENCE ALGORITHMS
time we visit each point in space is proportional to the posterior probability. The key point is that
to decide whether to move to a newly proposed point θ
′ or to stay in the curent point θ, we only
need to evaluate the unnormalized density ratio
p(θ|D)
p(θ
′
|D)
=
p(D|θ)p(θ)/p(D)
p(D|θ
′)p(θ
′)/p(D)
=
p(D, θ)
p(D, θ
′)
(7.35)
This avoids the need to compute the normalization constant p(D). (In practice we usually work with
log probabilities, instead of joint probabilities, to avoid numerical issues.)
We see that the input to the algorithm is just a function that computes the log joint density,
log p(θ, D), as well as a proposal distribution q(θ
′
|θ) for deciding which states to visit next. It is
common to use a Gaussian distribution for the proposal, q(θ
′
|θ) = N (θ
′
|θ, σI); this is called the
random walk Metropolis algorithm. However, this can be very inefficient, since it is blindly
walking through the space, in the hopes of finding higher probability regions.
In models that have conditional independence structure, it is often easy to compute the full
conditionals p(θd|θ−d, D) for each variable d, one at a time, and then sample from them. This is
like a stochastic analog of coordinate ascent, and is called Gibbs sampling (see Section 12.3 for
details).
For models where all unknown variables are continuous, we can often compute the gradient of the
log joint, ∇θ log p(θ, D). We can use this gradient information to guide the proposals into regions of
space with higher probability. This approach is called Hamiltonian Monte Carlo or HMC, and
is one of the most widely used MCMC algorithms due to its speed. For details, see Section 12.5.
We apply HMC to our beta-Bernoulli model in Figure 7.5. (We use a logit transformation for
the parameter.) In panel b, we show samples generated by the algorithm from 4 parallel Markov
chains. We see that they oscillate around the true posterior, as desired. In panel a, we compute a
kernel density estimate from the posterior samples from each chain; we see that the result is a good
approximation to the true posterior in Figure 7.3.
7.4.6 Sequential Monte Carlo
MCMC is like a stochastic local search algorithm, in that it makes moves through the state space of
the posterior distribution, comparing the current value to proposed neighboring values. An alternative
approach is to use perform inference using a sequence of different distributions, from simpler to more
complex, with the final distribution being equal to the target posterior. This is called sequential
Monte Carlo or SMC. This approach, which is more similar to tree search than local search, has
various advantages over MCMC, which we discuss in Chapter 13.
A common application of SMC is to sequential Bayesian inference, in which we recursively
compute (i.e., in an online fashion) the posterior p(θt|D1:t), where D1:t = {(xn, yn) : n = 1 : t} is all
the data we have seen so far. This sequence of distributions converges to the full batch posterior
p(θ|D) once all the data has been seen. However, the approach can also be used when the data is
arriving in a continual, unending stream, as in state-space models (see Chapter 29). The application
of SMC to such dynamical models is known as particle filtering. See Section 13.2 for details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license350
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b) (c) (d)
Figure 7.6: Different approximations to a bimodal 2d distribution. (a) Local MAP estimate. (b) Parametric
Gaussian approximation. (c) Correlated samples from near one mode. (d) Independent samples from the
distribution. Adapted from Figure 2 of [PY14]. Used with kind permission of George Panadreou.
7.4.7 Challenging posteriors
In many applications, the posterior can be high dimensional and multimodal. Approximating such
distributions can be quite challenging. In Figure 7.6, we give a simple 2d example. We compare MAP
estimation (which does not capture any uncertainty), a Gaussian parametric approximation such as
the Laplace approximation or variational inference (see panel b), and a nonparametric approximation
in terms of samples. If the samples are generated from MCMC, they are serially correlated, and
may only explore a local model (see panel c). However, ideally we can draw independent samples
from the entire support of the distribution, as shown in panel d. We may also be able to fit a local
parametric approximation around each such sample (see Section 17.3.9.1), to get a semi-parametric
approximation to the posterior.
7.5 Evaluating approximate inference algorithms
There are many different approximate inference algorithms, each of which make different tradeoffs
between speed, accuracy, generality, simplicity, etc. This makes it hard to compare them on an equal
footing.
One approach is to evaluate the accuracy of the approximation q(θ) by comparing to the “true”
posterior p(θ|D), computed offline with an “exact” method. We are usually interested in accuracy
vs speed tradeoffs, which we can compute by evaluating DKL (p(θ|D) k qt(θ)), where qt(θ) is the
approximate posterior after t units of compute time. Of course, we could use other measures of
distributional similarity, such as Wasserstein distance.
Unfortunately, it is usually impossible to compute the true posterior p(θ|D). A simple alternative
is to evaluate the quality in terms of its prediction abilities on out of sample observed data, similar to
cross validation. More generally, we can compare the expected loss or Bayesian risk (Section 34.1.3)
of different posteriors, as proposed in [KPS98; KPS99]:
R = Ep∗(x,y)
[ℓ(y, q(y|x, D))] where q(y|x, D) = Z
p(y|x, θ)q(θ|D)dθ (7.36)
where ℓ(y, q(y)) is some loss function, such as log-loss. Alternatively, we can measure performance
of the posterior when it is used in some downstream task, such as continual or active learning, as
proposed in [Far22].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
7.5. EVALUATING APPROXIMATE INFERENCE ALGORITHMS
For some specialized methods for assessing variational inference, see [Yao+18b; Hug+20], and for
Monte Carlo methods, see [CGR06; CTM17; GAR16].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license8 Gaussian filtering and smoothing
8.1 Introduction
In this chapter, we consider the task of posterior inference in state-space models (SSMs). We
discuss SSMs in more detail in Chapter 29, but we can think of them as latent variable sequence
models with the conditional independencies shown by the chain-structured graphical model Figure 8.1.
The corresponding joint distribution has the form
p(y1:T , z1:T |u1:T ) = "
p(z1|u1)
Y
T
t=2
p(zt|zt−1,ut)
# "Y
T
t=1
p(yt|zt,ut)
#
(8.1)
where zt are the hidden variables at time t, yt are the observations (outputs), and ut are the optional
inputs. The term p(zt|zt−1,ut) is called the dynamics model or transition model, p(yt|zt,ut) is
called the observation model or measurement model, and p(z1|u1) is the prior or initial state
distribution.1
8.1.1 Inferential goals
Given the sequence of observations, and a known model, one of the main tasks with SSMs is to
perform posterior inference about the hidden states; this is also called state estimation.
For example, consider an airplane flying in the sky. (For simplicity, we assume the world is 2d, not
3d.) We would like to estimate its location and velocity zt ∈ R
4 given noisy sensor measurements of
its location yt ∈ R
2
, as illustrated in Figure 8.2(a). (We ignore the inputs ut for simplicity.)
We discuss a suitable SSM for this problem, that embodies Newton’s laws of motion, in Sec￾tion 8.2.1.1. We can use the model to compute the belief state p(zt|y1:t); this is called Bayesian
filtering. If we represent the belief state using a Gaussian, then we can use the Kalman filter to
solve this task, as we discuss in Section 8.2.2. In Figure 8.2(b) we show the results of this algorithm.
The green dots are the noisy observations, the red line shows the posterior mean estimate of the
location, and the black circles show the posterior covariance. (The posterior over the velocity is not
shown.) We see that the estimated trajectory is less noisy than the raw data, since it incorporates
prior knowledge about how the data was generated.
Another task of interest is the smoothing problem where we want to compute p(zt|y1:T ) using
an offline dataset. We can compute these quantities using the Kalman smoother described in
1. In some cases, the initial state distribution is denoted by p(z0), and then we derive p(z1|u1) by passing p(z0)
through the dynamics model. In this case, the joint distribution represents p(y1:T , z0:T |u1:T ).354
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
yt−1 yt
zt−1 zt
ut−1 ut
Figure 8.1: A state-space model represented as a graphical model. zt are the hidden variables at time t, yt
are the observations (outputs), and ut are the optional inputs.
10 15 20 25 30
10
12
14
16
true state
emissions
(a)
10 15 20 25 30
4
6
8
10
12
14
16
18
20 observed
true state
filtered means
(b)
10 15 20 25 30
6
8
10
12
14
16
18
20 observed
true state
smoothed means
(c)
Figure 8.2: Illustration of Kalman filtering and smoothing for a linear dynamical system. (a) Observations
(green cirles) are generated by an object moving to the right (true location denoted by blue squares). (b) Results
of online Kalman filtering. Red cross is the posterior mean, circles are 95% confidence ellipses derived from
the posterior covariance. (c) Same as (b), but using offline Kalman smoothing. The MSE in the trajectory
for filtering is 3.13, and for smoothing is 1.71. Generated by kf_tracking.ipynb.
Section 8.2.3. In Figure 8.2(c) we show the result of this algorithm. We see that the resulting estimate
is smoother compared to filtering, and that the posterior uncertainty is reduced (as visualized by the
smaller confidence ellipses).
To understand this behavior intuitively, consider a detective trying to figure out who committed
a crime. As they move through the crime scene, their uncertainty is high until he finds the key
clue; then they have an “aha” moment, the uncertainty is reduced, and all the previously confusing
observations are, in hindsight, easy to explain. Thus we see that, given all the data (including
finding the clue), it is much easier to infer the state of the world.
A disadvantage of the smoothing method is that we have to wait until all the data has been
observed before we start performing inference, so it cannot be used for online or realtime problems.
Fixed lag smoothing is a useful compromise between online and offline estimation; it involves
computing p(zt−ℓ|y1:t), where ℓ > 0 is called the lag. This gives better performance than filtering,
but incurs a slight delay. By changing the size of the lag, we can trade off accuracy vs delay. See
Figure 8.3 for an illustration.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.1. INTRODUCTION
t
T
fixed-interval
smoothing
fixed-lag
smoothing
prediction
filtering
ℓ
h
Figure 8.3: The main kinds of inference for state-space models. The shaded region is the interval for which
we have data. The arrow represents the time step at which we want to perform inference. t is the current
time, T is the sequence length, ℓ is the lag, and h is the prediction horizon. Used with kind permission of
Peter Chang.
In addition to infering the latent state, we may want to predict future observations. We can
compute the observed predictive distribution h steps into the future as follows:
p(yt+h|y1:t) = X
zt+h
p(yt+h|zt+h)p(zt+h|y1:t) (8.2)
where the hidden state predictive distribution is obtained by pushing the current belief state
through the dynamics model
p(zt+h|y1:t) = X
zt:t+h−1
p(zt|y1:t)p(zt+1|zt)p(zt+2|zt+1)· · · p(zt+h|zt+h−1) (8.3)
(When the states are continuous, we need to replace the sums with integrals.)
8.1.2 Bayesian filtering equations
The Bayes filter is an algorithm for recursively computing the belief state p(zt|y1:t) given the
prior belief from the previous step, p(zt−1|y1:t−1), the new observation yt, and the model. This can
be done using sequential Bayesian updating, and requires a constant amount of computation
per time step (independent of t). For a dynamical model, this reduces to the predict-update cycle
described below.
The prediction step is just the Chapman-Kolmogorov equation:
p(zt|y1:t−1) = Z
p(zt|zt−1)p(zt−1|y1:t−1)dzt−1 (8.4)
The prediction step computes the one-step-ahead predictive distribution for the latent state, which
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license356
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
updates the posterior from the previous time step into the prior for the current step.2
The update step is just Bayes’ rule:
p(zt|y1:t) = 1
Zt
p(yt|zt)p(zt|y1:t−1) (8.5)
where the normalization constant is
Zt =
Z
p(yt|zt)p(zt|y1:t−1)dzt = p(yt|y1:t−1) (8.6)
We can use the normalization constants to compute the log likelihood of the sequence as follows:
log p(y1:T ) = X
T
t=1
log p(yt|y1:t−1) = X
T
t=1
log Zt (8.7)
where we define p(y1|y0) = p(y1). This quantity is useful for computing the MLE of the parameters.
8.1.3 Bayesian smoothing equations
In the offline setting, we want to compute p(zt|y1:T ), which is the belief about the hidden state at
time t given all the data, both past and future. This is called (fixed interval) smoothing. We first
perform the forwards or filtering pass, and then compute the smoothed belief states by working
backwards, from right (time t = T) to left (t = 1), as we explain below. Hence this method is also
called forwards filtering backwards smoothing or FFBS.
Suppose, by induction, that we have already computed p(zt+1|y1:T ). We can convert this into a
joint smoothed distribution over two consecutive time steps using
p(zt, zt+1|y1:T ) = p(zt|zt+1, y1:T )p(zt+1|y1:T ) (8.8)
To derive the first term, note that from the Markov properties of the model, and Bayes’ rule, we have
p(zt|zt+1, y1:T ) = p(zt|zt+1, y1:t,✘yt+1: ✘✘T ) (8.9)
=
p(zt, zt+1|y1:t)
p(zt+1|y1:t)
(8.10)
=
p(zt+1|zt)p(zt|y1:t)
p(zt+1|y1:t)
(8.11)
Thus the joint distribution over two consecutive time steps is given by
p(zt, zt+1|y1:T ) = p(zt|zt+1, y1:t)p(zt+1|y1:T ) = p(zt+1|zt)p(zt|y1:t)p(zt+1|y1:T )
p(zt+1|y1:t)
(8.12)
2. The prediction step is not needed at t = 1 if p(z1) is provided as input to the model. However, if we just provide
p(z0), we need to compute p(z1|y1:0) = p(z1) by applying the prediction step.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.2. INFERENCE FOR LINEAR-GAUSSIAN SSMS
from which we get the new smoothed marginal distribution:
p(zt|y1:T ) = p(zt|y1:t)
Z 
p(zt+1|zt)p(zt+1|y1:T )
p(zt+1|y1:t)

dzt+1 (8.13)
=
Z
p(zt, zt+1|y1:t)
p(zt+1|y1:T )
p(zt+1|y1:t)
dzt+1 (8.14)
Intuitively we can interpret this as follows: we start with the two-slice filtered distribution,
p(zt, zt+1|y1:t), and then we divide out the old p(zt+1|y1:t) and multiply in the new p(zt+1|y1:T ),
and then marginalize out zt+1.
8.1.4 The Gaussian ansatz
In general, computing the integrals required to implement Bayesian filtering and smoothing is
intractable. However, there are two notable exceptions: if the state space is discrete, as in an HMM,
we can represent the belief states as discrete distributions (histograms), which we can update using
the forwards-backwards algorithm, as discussed in Section 9.2; and if the SSM is a linear-Gaussian
model, then we can represent the belief states by Gaussians, which we can update using the Kalman
filter and smoother, which we discuss in Section 8.2.2 and Section 8.2.3. In the nonlinear and/or
non-Gaussian setting, we can still use a Gaussian to represent an approximate belief state, as we
discuss in Section 8.3, Section 8.4, Section 8.5 and Section 8.6. We discuss some non-Gaussian
approximations in Section 8.7.
For most of this chapter, we assume the SSM can be written as a nonlinear model subject to
additive Gaussian noise:
zt = f(zt−1,ut) + N (0, Qt)
yt = h(zt,ut) + N (0, Rt)
(8.15)
where f is the transition or dynamics function, and h is the observation function. In some cases, we
will further assume that these functions are linear.
8.2 Inference for linear-Gaussian SSMs
In this section, we discuss inference in SSMs where all the distributions are linear Gaussian. This is
called a linear Gaussian state space model (LG-SSM) or a linear dynamical system (LDS).
We discuss such models in detail in Section 29.6, but in brief they have the following form:
p(zt|zt−1,ut) = N (zt|Ftzt−1 + Btut + bt, Qt) (8.16)
p(yt|zt,ut) = N (yt|Htzt + Dtut + dt, Rt) (8.17)
where zt ∈ R
Nz
is the hidden state, yt ∈ R
Ny is the observation, and ut ∈ R
Nu is the input. (We
have allowed the parameters to be time-varying, for later extensions that we will consider.) We often
assume the means of the process noise and observation noise (i.e., the bias or offset terms) are zero,
so bt = 0 and dt = 0. In addition, we often have no inputs, so Bt = Dt = 0. In this case, the model
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license358
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
simplifies to the following:3
p(zt|zt−1) = N (zt|Ftzt−1, Qt) (8.18)
p(yt|zt) = N (yt|Htzt, Rt) (8.19)
See Figure 8.1 for the graphical model.4
Note that an LG-SSM is just a special case of a Gaussian Bayes net (Section 4.2.3), so the
entire joint distribution p(y1:T , z1:T |u1:T ) is a large multivariate Gaussian with NyNzT dimensions.
However, it has a special structure that makes it computationally tractable to use, as we show below.
In particular, we will discuss the Kalman filter and Kalman smoother, that can perform exact
filtering and smoothing in O(T N3
z
) time.
8.2.1 Examples
Before diving into the theory, we give some motivating examples.
8.2.1.1 Tracking and state estimation
A common application of LG-SSMs is for tracking objects, such as airplanes or animals, from noisy
measurements, such as radar or cameras. For example, suppose we want to track an object moving
in 2d. (We discuss this example in more detail in Section 29.7.1.) The hidden state zt encodes the
location, (xt1, xt2), and the velocity, (x˙ t1, x˙ t1), of the moving object. The observation yt is a noisy
version of the location. (The velocity is not observed but can be inferred from the change in location.)
We assume that we obtain measurements with a sampling period of ∆. The new location is the old
location plus ∆ times the velocity, plus noise added to all terms:
zt =


1 0 ∆ 0
0 1 0 ∆
0 0 1 0
0 0 0 1


| {z }
F
zt−1 + qt (8.20)
where qt ∼ N (0, Qt). The observation extracts the location and adds noise:
yt =

1 0 0 0
0 1 0 0
| {z }
H
zt + rt (8.21)
where rt ∼ N (0, Rt).
Our goal is to use this model to estimate the unknown location (and velocity) of the object given
the noisy observations. In particular, in the filtering problem, we want to compute p(zt|y1:t) in
3. Our notation is similar to [SS23], except he writes p(xk|xk−1) = N (xk|Ak−1xk−1, Qk−1) instead of p(zt|zt−1) =
N (zt|Ftzt−1, Qt), and p(yk|xk) = N (yk|Hkxk, Rk) instead of p(yt|zt) = N (yt|Htzt, Rt).
4. Note that, for some problems, the evolution of certain components of the state vector is deterministic, in which case
the corresponding noise terms must be zero. To avoid singular covariance matrices, we can replace the dynamics noise
wt ∼ N (0, Qt) with Gtw˜ t, where w˜ t ∼ N (0, Q˜ t), where Q˜ t is a smaller Nq × Nq psd matrix, and Gt is a Ny × Nq.
In this case, the covariance of the noise becomes Qt = GtQ˜ tGT
t
.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.2. INFERENCE FOR LINEAR-GAUSSIAN SSMS
a recursive fashion. Figure 8.2(b) illustrates filtering for the linear Gaussian SSM applied to the
noisy tracking data in Figure 8.2(a) (shown by the green dots). The filtered estimates are computed
using the Kalman filter algorithm described in Section 8.2.2. The red line shows the posterior
mean estimate of the location, and the black circles show the posterior covariance. We see that the
estimated trajectory is less noisy than the raw data, since it incorporates prior knowledge about how
the data was generated.
Another task of interest is the smoothing problem where we want to compute p(zt|y1:T ) using an
offline dataset. Figure 8.2(c) illustrates smoothing for the LG-SSM, implemented using the Kalman
smoothing algorithm described in Section 8.2.3. We see that the resulting estimate is smoother, and
that the posterior uncertainty is reduced (as visualized by the smaller confidence ellipses).
8.2.1.2 Online Bayesian linear regression (recursive least squares)
In Section 29.7.2 we discuss how to use the Kalman filter to recursively compute the exact posterior
p(w|D1:t) for a linear regression model in an online fashion. This is known as the recursive least
squares algorithm. The basic idea is to treat the latent state to be the parameter values, zt = w,
and to define the non-stationary observation model as p(yt|zt) = N (yt|x
T
t zt, σ2
), and the dynamics
model as p(zt|zt−1) = N (zt|zt−1, 0I).
8.2.1.3 Time series forecasting
In Section 29.12, we discuss how to use Kalman filtering to perform time series forecasting.
8.2.2 The Kalman filter
The Kalman filter (KF) is an algorithm for exact Bayesian filtering for linear Gaussian state space
models. The resulting algorithm is the Gaussian analog of the HMM filter in Section 9.2.2. The belief
state at time t is now given by p(zt|y1:t) = N (zt|µt|t
, Σt|t), where we use the notation µt|t
′ and Σt|t
′
to represent the posterior mean and covariance given y1:t
′ .
5 Since everything is Gaussian, we can
perform the prediction and update steps in closed form, as we explain below (see Section 8.2.2.4 for
the derivation).
8.2.2.1 Predict step
The one-step-ahead prediction for the hidden state, also called the time update step, is given by
the following:
p(zt|y1:t−1,u1:t) = N (zt|µt|t−1
, Σt|t−1) (8.22)
µt|t−1 = Ftµt−1|t−1 + Btut + bt (8.23)
Σt|t−1 = FtΣt−1|t−1F
T
t + Qt (8.24)
5. We represent the mean and covariance of the filtered belief state by µt|t and Σt|t
, but some authors use the notation
mt and Pt instead. We represent the mean and covariance of the smoothed belief state by µt|T and Σt|T , but some
authors use the notation ms
t
and Ps
t
instead. Finally, we represent the mean and covariance of the one-step-ahead
posterior predictive distribution, p(zt|y1:t−1), by µt|t−1 and Σt|t−1, whereas some authors use m−
t
and P
−
t
instead.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license360
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.2.2.2 Update step
The update step (also called the measurement update step) can be computed using Bayes’ rule,
as follows:
p(zt|y1:t,u1:t) = N (zt|µt|t
, Σt|t) (8.25)
yˆt = Htµt|t−1 + Dtut + dt (8.26)
St = HtΣt|t−1HT
t + Rt (8.27)
Kt = Σt|t−1HT
t S
−1
t
(8.28)
µt|t = µt|t−1 + Kt(yt − yˆt) (8.29)
Σt|t = Σt|t−1 − KtHtΣt|t−1 (8.30)
= Σt|t−1 − KtStKT
t
(8.31)
where Kt is the Kalman gain matrix. Note that yˆt is the expected observation, so et = yt − yˆt is
the residual error, also called the innovation term. The covariance of the observation is denoted
by St, and the cross covariance bwteen the observation and state is denoted by Ct = Σt|t−1HT
t
. In
practice, to compute the Kalman gain, we do not use Kt = CtS
−1
t
, but instead we solve the linear
system KtSt = Ct.
6
To understand the update step intuitively, note that the update for the latent mean, µt|t =
µt|t−1 + Ktet, is the predicted new latent mean plus a correction factor, which is Kt times the error
signal et. If Ht = I, then Kt = Σt|t−1S
−1
t
; in the scalar case, this becomes kt = Σt|t−1/St, which
is the ratio between the variance of the prior (from the dynamics model) and the variance of the
measurement, which we can interpret as an inverse signal to noise ratio. If we have a strong prior
and/or very noisy sensors, |Kt| will be small, and we will place little weight on the correction term.
Conversely, if we have a weak prior and/or high precision sensors, then |Kt| will be large, and we
will place a lot of weight on the correction term. Similarly, the new covariance is the old covariance
minus a positive definite matrix, which depends on how informative the measurement is.
Note that, by using the matrix inversion lemma, the Kalman gain matrix can also be written as
Kt = Σt|t−1HT
t
(HtΣt|t−1HT
t + Rt)
−1 = (Σ
−1
t|t−1 + HT
t R−1
t Ht)
−1HT
t R−1
t
(8.32)
This is useful if R−1
t
is precomputed (e.g., if it is constant over time) and Ny ≫ Nz. In addition, in
Equation (8.97), we give the information form of the filter, which shows that the posterior precision
has the form Σ
−1
t = Σ
−1
t|t−1 + HT
t R−1
t Ht, so we can also write the gain matrix as Kt = ΣtHT
t R−1
t
.
8.2.2.3 Posterior predictive
The one-step-ahead posterior predictive density for the observations can be computed as follows. (We
ignore inputs and bias terms, for notational brevity.) First we compute the one-step-ahead predictive
density for latent states:
p(zt|y1:t−1) = Z
p(zt|zt−1)p(zt−1|y1:t−1)dzt−1 = N (zt|µt|t−1
, Σt|t−1) (8.33)
= N (zt|Ftµt−1|t−1
, FtΣt−1|t−1F
T
t + Qt) = N (zt|µt|t−1
, Σt|t−1) (8.34)
6. Equivalently we have S
T
t KT
t = CT
t
, so we can compute Kt in JAX using K = jnp.linalg.lstq(S.T, C.T)[0].T.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.2. INFERENCE FOR LINEAR-GAUSSIAN SSMS
Then we convert this to a prediction about observations by marginalizing out zt:
p(yt|y1:t−1) = Z
p(yt, zt|y1:t−1)dzt =
Z
p(yt|zt)p(zt|y1:t−1)dzt = N (yt|yˆt, St) (8.35)
This can also be used to compute the log-likelihood of the observations: The normalization constant
of the new posterior can be computed as follows:
log p(y1:T ) = X
T
t=1
log p(yt|y1:t−1) = X
T
t=1
log Zt (8.36)
where we define p(y1|y0) = p(y1). This is just a sum of the log probabilities of the one-step-ahead
measurement predictions, and is a measure of how “surprised” the model is at each step.
We can generalize the prediction step to predict observations K steps into the future by first
forecasting K steps in latent space, and then “grounding” the final state into predicted observations.
(This is in contrast to an RNN (Section 16.3.4), which requires generating observations at each step,
in order to update future hidden states.)
8.2.2.4 Derivation
In this section we derive the Kalman filter equations, following [SS23, Sec 6.3]. The results are
a straightforward application of the rules for manipulating linear Gaussian systems, discussed in
Section 2.3.2.
First we derive the prediction step. From Equation (2.120), the joint predictive distribution for
states is given by
p(zt−1, zt|y1:t−1) = p(zt|zt−1)p(zt−1|y1:t−1) (8.37)
= N (zt|Ftzt−1, Qt)N (zt−1|µt−1|t−1
, Σt−1|t−1) (8.38)
= N
zt−1
zt

|µ
′
, Σ
′

(8.39)
where
µ
′ =

µt−1|t−1
Ftµt−1|t−1

, Σ
′ =

Σt−1|t−1 Σt−1|t−1F
T
t
FtΣt−1|t−1 FtΣt−1|t−1F
T
t + Qt

(8.40)
Hence the marginal predictive distribution for states is given by
p(zt|y1:t−1) = N (zt|Ftµt−1|t−1
, FtΣt−1|t−1F
T
t + Qt) = N (zt|µt|t−1
, Σt|t−1) (8.41)
Now we derive the measurement update step. The joint distribution for state and observation is
given by
p(zt, yt|y1:t−1) = p(yt|zt)p(zt|y1:t−1) (8.42)
= N (yt|Htzt, Rt)N (zt|µt|t−1
, Σt|t−1) (8.43)
= N
zt
yt

|µ
′′
, Σ
′′
(8.44)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license362
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where
µ
′′ =

µt|t−1
Htµt|t−1

, Σ
′′ =

Σt|t−1 Σt|t−1HT
t
HtΣt|t−1 HtΣ
−1
t|t−1HT
t + Rt

(8.45)
Finally, we convert this joint into a conditional using Equation (2.78) as follows:
p(zt|yt, y1:t−1) = N (zt|µt|t
, Σt|t) (8.46)
µt|t = µt|t−1 + Σt|t−1HT
t
(HtΣt|t−1HT
t + Rt)
−1
[yt − Htµt|t−1
] (8.47)
= µt|t−1 + Kt[yt − Htµt|t−1
] (8.48)
Σt|t = Σt|t−1 − Σt|t−1HT
t
(HtΣt|t−1HT
t + Rt)
−1HtΣt|t−1 (8.49)
= Σt|t−1 − KtHtΣt|t−1 (8.50)
where
St = HtΣt|t−1HT
t + Rt (8.51)
Kt = Σt|t−1HT
t S
−1
t
(8.52)
8.2.2.5 Abstract formulation
We can represent the Kalman filter equations much more compactly by defining various functions
that create and manipulate jointly Gaussian systems, as in Section 2.3.2. In particular, suppose we
have the following linear Gaussian system:
p(z) = N (
`µ,
`
Σ) (8.53)
p(y|z) = N (Az + b, Ω) (8.54)
Then the joint is given by
p(z, y) = N
`µ
µ

,
 `
Σ C
CT S
 = N
  `µ
A `µ +b

,
 `
Σ
`
Σ AT
A
`
Σ A
`
Σ AT + Ω
!! (8.55)
and the posterior is given by
p(z|y) = N (z|
aµ,
a
Σ) = N

z|
`µ +K(y − µ),
`
Σ −KSKT

(8.56)
where K = CS−1
. See Algorithm 8.1 for the pseudocode.
We can now apply these functions to derive Kalman filtering as follows. In the prediction step, we
compute
p(zt−1, zt|y1:t−1) = N
µt−1|t−1
µt|t−1

,

Σt−1|t−1 Σt−1,t|t−1
Σt,t−1|t−1 Σt|t−1
 (8.57)
(µt|t−1
, Σt|t−1, Σt−1,t|t) = GaussMoments(µt−1|t−1
, Σt−1|t−1, Ft, Btut + bt, Qt) (8.58)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.2. INFERENCE FOR LINEAR-GAUSSIAN SSMS
Algorithm 8.1: Functions for a linear Gaussian system.
1 def GaussMoments(
`µ,
`
Σ, A, b, Ω) :
2 µ = A `µ +b
3 S = Ω + A
`
Σ AT
4 C =
`
Σ AT
5 Return (µ, S, C)
6 def GaussCondition(
`µ,
`
Σ, µ, S, C, y) :
7 K = CS−1
8
aµ=
`µ +K(y − µ)
9
a
Σ=
`
Σ −KSKT
10 ℓ = log N (y|µ, S)
11 Return (
aµ,
a
Σ, ℓ)
from which we get the marginal distribution
p(zt|y1:t−1) = N (µt|t−1
, Σt|t−1) (8.59)
In the update step, we compute the joint distribution
p(zt, yt|y1:t−1) = N
µt|t−1
µt

,

Σt|t−1 Ct
CT
t St
 (8.60)
(yˆt, St, Ct) = GaussMoments(µt|t−1
, Σt|t−1, Ht, Dtut + dt, Rt) (8.61)
We then condition this on the observations to get the posterior distribution
p(zt|yt, y1:t−1) = p(zt|y1:t) = N (µt|t
, Σt|t) (8.62)
(µt|t
, Σt|t
, ℓt) = GaussCondition(µt|t−1
, Σt|t−1, yˆt, St, Ct, yt) (8.63)
The overall KF algorithm is shown in Algorithm 8.2.
Algorithm 8.2: Kalman filter.
1 def KF(F1:T , B1:T , b1:T , Q1:T , H1:T , D1:T , d1:T , R1:T ,u1:T , y1:T , µ0|0
, Σ0|0) :
2 foreach t = 1 : T do
3 // Predict:
4 (µt|t−1
, Σt|t−1, −) = GaussMoments(µt−1|t−1
, Σt−1|t−1, Ft, Btut + bt, Qt)
5 // Update:
6 (µ, S, C) = GaussMoments(µt|t−1
, Σt|t−1, Ft, Btut + bt, Qt)
7 (µt|t
, Σt|t
, ℓt) = GaussCondition(µt|t−1
, Σt|t−1, µ, S, C, y)
8 Return (µt|t
, Σt|t)
T
t=1,
PT
t=1 ℓt
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license364
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.2.2.6 Numerical issues
In practice, the Kalman filter can encounter numerical issues. One solution is to use the information
filter, which recursively updates the natural parameters of the Gaussian, Λt|t = Σ
−1
t|t
and ηt|t =
Λtµt|t
, instead of the mean and covariance (see Section 8.2.4). Another solution is the square root
filter, which works with the Cholesky or QR decomposition of Σt|t
, which is much more numerically
stable than directly updating Σt|t
. These techniques can be combined to create the square root
information filter (SRIF) [May79]. (According to [Bie06], the SRIF was developed in 1969 for
use in JPL’s Mariner 10 mission to Venus.) In [Tol22] they present an approach which uses QR
decompositions instead of matrix inversions, which can also be more stable.
8.2.2.7 Continuous-time version
The Kalman filter can be extended to work with continuous time dynamical systems; the resulting
method is called the Kalman Bucy filter. See [SS19, p208] for details. q
8.2.3 The Kalman (RTS) smoother
In Section 8.2.2, we described the Kalman filter, which sequentially computes p(zt|y1:t) for each t.
This is useful for online inference problems, such as tracking. However, in an offline setting, we can
wait until all the data has arrived, and then compute p(zt|y1:T ). By conditioning on past and future
data, our uncertainty will be significantly reduced. This is illustrated in Figure 8.2(c), where we see
that the posterior covariance ellipsoids are smaller for the smoothed trajectory than for the filtered
trajectory.
We now explain how to compute the smoothed estimates, using an algorithm called the RTS
smoother or RTSS, named after its inventors, Rauch, Tung, and Striebel [RTS65]. It is also
known as the Kalman smoothing algorithm. The algorithm is the linear-Gaussian analog to the
forwards-filtering backwards-smoothing algorithm for HMMs in Section 9.2.4.
8.2.3.1 Algorithm
In this section, we state the Kalman smoother algorithm. We give the derivation in Section 8.2.3.2.
The key update equations are as follows: From this, we can extract the smoothed marginal
p(zt|y1:T ) = N (zt|µt|T
, Σt|T ) (8.64)
µt+1|t = Ftµt|t
(8.65)
Σt+1|t = FtΣt|tF
T
t + Qt+1 (8.66)
Jt = Σt|tF
T
t Σ
−1
t+1|t
(8.67)
µt|T = µt|t + Jt(µt+1|T − µt+1|t
) (8.68)
Σt|T = Σt|t + Jt(Σt+1|T − Σt+1|t)J
T
t
(8.69)
8.2.3.2 Derivation
In this section, we derive the RTS smoother, following [SS23, Sec 12.2]. As in the derivation of the
Kalman filter in Section 8.2.2.4, we make heavy use of the rules for manipulating linear Gaussian
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.2. INFERENCE FOR LINEAR-GAUSSIAN SSMS
systems, discussed in Section 2.3.2.
The joint filtered distribution for two consecutive time slices is
p(zt, zt+1|y1:t) = p(zt+1|zt)p(zt|y1:t) = N (zt+1|Ftzt, Qt+1)N (zt|µt|t
, Σt|t) (8.70)
= N
 zt
zt+1
|m1, V1

(8.71)
where
m1 =

µt|t
Ftµt|t

, V1 =

Σt|t Σt|tF
T
t
FtΣt|t FtΣt|tF
T
t + Qt+1
(8.72)
By the Markov property for the hidden states we have
p(zt|zt+1, y1:T ) = p(zt|zt+1, y1:t, yt+1:T ) = p(zt|zt+1, y1:t) (8.73)
and hence by conditioning the joint distribution p(zt, zt+1|y1:t) on the future state we get
p(zt|zt+1, y1:T ) = N (zt|m2, V2) (8.74)
µt+1|t = Ftµt|t
(8.75)
Σt+1|t = FtΣt|tF
T
t + Qt+1 (8.76)
Jt = Σt|tF
T
t Σ
−1
t+1|t
(8.77)
m2 = µt|t + Jt(zt+1 − µt+1|t
) (8.78)
V2 = Σt|t − JtΣt+1|tJ
T
t
(8.79)
where Jt is the backwards Kalman gain matrix. For future reference, we note that we can rewrite
this matrix as
Jt = Dt+1Σ
−1
t+1|t
(8.80)
where Dt+1 = Σt|tF
T
t
is the cross covariance term in the upper right block of V1.
The joint distribution of two consecutive time slices given all the data is
p(zt+1, zt|y1:T ) = p(zt|zt+1, y1:T )p(zt+1|y1:T ) (8.81)
= N (zt|m2(zt+1), V2)N (zt+1|µt|T
, Σt|T ) (8.82)
= N
zt+1
zt

|m3, V3

(8.83)
where
m3 =

µt+1|T
µt|t + Jt(µt+1|T − µt+1|t
)

, V3 =

Σt+1|T Σt+1|T J
T
t
JtΣt+1|T JtΣt+1|T J
T
t + V2

(8.84)
From this, we can extract p(zt|y1:T ), with the mean and covariance given by Equation (8.68) and
Equation (8.69).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license366
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.2.3.3 Two-filter smoothing
Note that the backwards pass of the Kalman smoother does not need access to the observations, y1:T ,
but does need access to the filtered belief states from the forwards pass, p(zt|y1:t) = N (zt|µt|t
, Σt|t).
There is an alternative version of the algorithm, known as two-filter smoothing [FP69; Kit04], in
which we compute the forwards pass as usual, and then separately compute backwards messages
p(yt+1:T |zt) ∝ N (zt|µ
b
t|t
, Σ
b
t|t
), similar to the backwards filtering algorithm in HMMs (Section 9.2.3).
However, these backwards messages are conditional likelihoods, not posteriors, which can cause
numerical problems. For example, consider t = T; in this case, we need to set the initial covariance
matrix to be Σ
b
T = ∞I, so that the backwards message has no effect on the filtered posterior (since
there is no evidence beyond step T). This problem can be resolved by working in information form.
An alternative approach is to generalize the two-filter smoothing equations to ensure the likelihoods
are normalizable by multiplying them by artificial distributions [BDM10].
In general, the RTS smoother is preferred to the two-filter smoother, since it is more numerically
stable, and it is easier to generalize it to the nonlinear case.
8.2.3.4 Time and space complexity
In general, the Kalman smoothing algorithm takes O(N3
y + N2
z + NyNz) per step, where there
are T steps. This can be slow when applied to long sequences. In [SGF21], they describe how to
reduce this to O(log T) steps using a parallel prefix scan operator that can be run efficiently on
GPUs. In addition, we can reduce the space from O(T), to O(log T) using the same algorithm as in
Section 9.2.5.
8.2.3.5 Forwards filtering backwards sampling
To draw posterior samples from the LG-SSM, we can leverage the following result:
p(zt|zt+1, y1:T ) = N (zt|µ˜t
, Σ˜
t) (8.85)
µ˜t = µt|t + Jt(zt+1 − Ftµt|t
) (8.86)
Σ˜
t = Σt|t − JtΣt+1|tJ
T
t = Σt|t − Σt|tF
T
t Σ
−1
t+1|tΣt+1|tJ
T
t
(8.87)
= Σt|t(I − F
T
t J
T
t
) (8.88)
where Jt is the backwards Kalman gain defined in Equation (8.67).
8.2.4 Information form filtering and smoothing
This section is written by Giles Harper-Donnelly.
In this section, we derive the Kalman filter and smoother algorithms in information form. We will
see that this is the “dual” of Kalman filtering/smoothing in moment form. In particular, while
computing marginals in moment form is easy, computing conditionals is hard (requires a matrix
inverse). Conversely, for information form, computing marginals is hard, but computing conditionals
is easy.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.2. INFERENCE FOR LINEAR-GAUSSIAN SSMS
8.2.4.1 Filtering: algorithm
The predict step has a similar structure to the update step in moment form. We start with the prior
p(zt−1|y1:t−1,u1:t−1) = Nc(zt−1|ηt−1|t−1
, Λt−1|t−1) and then compute
p(zt|y1:t−1,u1:t) = Nc(zt|ηt|t−1
, Λt|t−1) (8.89)
Mt = Λt−1|t−1 + F
T
t Q−1
t Ft (8.90)
Jt = Q−1
t FtM−1
t
(8.91)
Λt|t−1 = Q−1
t − Q−1
t Ft(Λt−1|t−1 + F
T
t Q−1
t Ft)
−1 F
T
t Q−1
t
(8.92)
= Q−1
t − JtF
T
t Q−1
t
(8.93)
= Q−1
t − JtMtJ
T
t
(8.94)
ηt|t−1 = Jtηt−1|t−1 + Λt|t−1(Btut + bt), (8.95)
where Jt is analogous to the Kalman gain matrix in moment form Equation (8.28). From the
matrix inversion lemma, Equation (2.93), we see that Equation (8.92) is the inverse of the predicted
covariance Σt|t−1 given in Equation (8.24).
The update step in information form is as follows:
p(zt|y1:t,u1:t) = Nc(zt|ηt|t
, Λt|t) (8.96)
Λt|t = Λt|t−1 + HT
t R−1
t Ht (8.97)
ηt|t = ηt|t−1 + HT
t R−1
t
(yt − Dtut − dt). (8.98)
8.2.4.2 Filtering: derivation
For the predict step, we first derive the joint distribution over hidden states at t, t − 1:
p(zt−1, zt|y1:t−1,u1:t) = p(zt|zt−1,ut)p(zt−1|y1:t−1,u1:t−1) (8.99)
= Nc(zt, |Q−1
t
(Ftzt−1 + Btut + bt), Q−1
t
) (8.100)
× Nc(zt−1, |ηt−1|t−1
, Λt−1|t−1) (8.101)
= Nc(zt−1, zt|ηt−1,t|t
, Λt−1,t|t) (8.102)
where
ηt−1,t|t−1 =

ηt−1|t−1 − F
T
t Q−1
t
(Btut + bt)
Q−1
t
(Btut + bt)

(8.103)
Λt−1,t|t−1 =

Λt−1|t−1 + F
T
t Q−1
t Ft −F
T
t Q−1
t
−Q−1
t Ft Q−1
t

(8.104)
The information form predicted parameters ηt|t−1
, Λt|t−1 can then be derived using the marginalisa￾tion formulae in Section 2.3.1.4.
For the update step, we start with the joint distribution over the hidden state and the observation
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license368
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
at t:
p(zt, yt|y1:t−1,u1:t) = p(yt|zt,ut)p(zt|y1:t−1,u1:t−1) (8.105)
= Nc(yt, |R−1
t
(Htzt + Dut + dt), R−1
t
)Nc(zt|ηt|t−1
, Λt|t−1) (8.106)
= Nc(zt, y|ηz,y|t
, Λz,y|t) (8.107)
where
ηz,y|t =

ηt|t−1 − HT
t R−1
t
(Dtut + dt)
R−1
t
(Dtut + dt)

(8.108)
Λz,y|t =

Λt|t−1 + HT
t R−1
t Ht −HT
t R−1
t
−R−1
t Ht R−1
t

(8.109)
The information form filtered parameters ηt|t
, Λt|t are then derived using the conditional formulae in
2.3.1.4.
8.2.4.3 Smoothing: algorithm
The smoothing equations are as follows:
p(zt|y1:T ) = Nc(zt|ηt|T
, Λt|T ) (8.110)
Ut = Q−1
t + Λt+1|T − Λt+1|t (8.111)
Lt = F
T
t Q−1
t U−1
t
(8.112)
Λt|T = Λt|t + F
T
t Q−1
t Ft − LtQ−1
t F (8.113)
= Λt|t + F
T
t Q−1
t Ft − LtUtL
T
t
(8.114)
ηt|T = ηt|t + Lt(ηt+1|T − ηt+1|t
). (8.115)
The parameters ηt|t and Λt|t are the filtered values from Equations (8.98) and (8.97) respectively.
Similarly, ηt+1|t and Λt+1|t are the predicted parameters from Equations (8.95) and (8.92). The
matrix Lt is the information form analog to the backwards Kalman gain matrix in Equation (8.67).
8.2.4.4 Smoothing: derivation
From the generic forwards-filtering backwards-smoothing equation, Equation (8.14), we have
p(zt|y1:T ) = p(zt|y1:t)
Z 
p(zt+1|zt)p(zt+1|y1:T )
p(zt+1|y1:t)

dzt+1 (8.116)
=
Z
p(zt, zt+1|y1:t)
p(zt+1|y1:T )
p(zt+1|y1:t)
dzt+1 (8.117)
=
Z
Nc(zt, zt+1|ηt,t+1|t
, Λt,t+1|t)
Nc(zt+1|ηt+1|T
, Λt+1|T )
Nc(zt+1|ηt+1|t
, Λt+1|t)
dzt+1 (8.118)
=
Z
Nc(zt, zt+1|ηt,t+1|T
, Λt,t+1|T )dzt+1. (8.119)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.3. INFERENCE BASED ON LOCAL LINEARIZATION
The parameters of the joint filtering predictive distribution, p(zt, zt+1|y1:t), take precisely the
same form as those in the filtering derivation described in Section 8.2.4.2:
ηt,t+1|t =

ηt|t
0

, Λt,t+1|t =

Λt|t + F
T
t+1Q−1
t+1Ft+1 −F
T
t+1Q−1
t+1
−Q−1
t+1Ft+1 Q−1
t+1 
, (8.120)
We can now update this potential function by subtracting out the filtered information and adding
in the smoothing information, using the rules for manipulating Gaussian potentials described in
Section 2.3.3:
ηt,t+1|T = ηt,t+1|t +

0
ηt+1|T

−

0
ηt+1|t

=

ηt|t
ηt+1|T − ηt+1|t

, (8.121)
and
Λt,t+1|T = Λt,t+1|t +

0 0
0 Λt+1|T

−

0 0
0 Λt+1|t

(8.122)
=

Λt|t + F
T
t+1Q−1
t+1Ft+1 −F
T
t+1Q−1
t+1
−Q−1
t+1Ft+1 Q−1
t+1 + Λt+1|T − Λt+1|t

(8.123)
Applying the information form marginalization formula Equation (2.85) leads to Equation (8.115)
and Equation (8.113).
8.3 Inference based on local linearization
In this section, we extend the Kalman filter and smoother to the case where the system dynamics
and/or the observation model are nonlinear. (We continue to assume that the noise is additive
Gaussian, as in Equation (8.15).) The basic idea is to linearize the dynamics and observation
models about the previous state estimate using a first order Taylor series expansion, and then to
apply the standard Kalman filter equations from Section 8.2.2. Intuitively we can think of this as
approximating a stationary non-linear dynamical system with a non-stationary linear dynamical
system. This approach is called the extended Kalman filter or EKF.
8.3.1 Taylor series expansion
Suppose x ∼ N (µ, Σ) and y = g(x), where g : R
n → R
m is a differentiable and invertible function.
The pdf for y is given by
p(y) = | det Jac(g
−1
)(y)| N (g
−1
(y)|µ, Σ) (8.124)
In general this is intractable to compute, so we seek an approximation.
Suppose x = µ + δ, where δ ∼ N (0, Σ). Then we can form a first order Taylor series expansion of
the function g as follows:
g(x) = g(µ + δ) ≈ g(µ) + G(µ)δ (8.125)
where G(µ) = Jac(g)(µ) is the Jacobian of g at µ:
[G(µ)]jj′ =
∂gj (x)
∂xj
′
|x=µ (8.126)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license370
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We now derive the induced Gaussian approximation to y = g(x). The mean is given by
E [y] ≈ E [g(µ) + G(µ)δ] = g(µ) + G(µ)E [δ] = g(µ) (8.127)
The covariance is given by
Cov [y] = E

(g(x) − E [g(x)])(g(x) − E [g(x)])T

(8.128)
≈ E

(g(x) − g(µ))(g(x) − g(µ))T

(8.129)
≈ E

(g(µ) + G(µ)δ − g(µ))(g(µ) + G(µ)δ − g(µ))T

(8.130)
= E

(G(µ)δ)(G(µ)δ)
T

(8.131)
= G(µ)E
h
δδT
i
G(µ)
T
(8.132)
= G(µ) Σ G(µ)
T
(8.133)
Algorithm 8.3: Linearized approximation to a joint Gaussian distribution.
1 def LinearizedMoments(µ, Σ, g, Ω) :
2 yˆ = g(µ)
3 G = Jac(g)(µ)
4 S = GΣGT + Ω
5 C = ΣGT
6 Return (yˆ, S, C)
When deriving the EKF, we need to compute the joint distribution p(x, y) where
x ∼ N (µ, Σ), y = g(x) + q, q ∼ N (0, Ω) (8.134)
where q is independent of x. We can compute this by defining the augmented function g˜(x) = [x, g(x)]
and following the procedure above. The resulting linear approximation to the joint is

x
y

∼ N µ
yˆ

,

Σ C
CT S
 = N
 µ
g(µ)

,

Σ ΣGT
GΣ GΣGT + Ω
 (8.135)
where the parameters are computed using Algorithm 8.3. We can then condition this joint Gaussian
on the observed value y to get the posterior.
It is also possible to derive an approximation for the case of non-additive Gaussian noise, where
y = g(x, q). See [SS23, Sec 7.1] for details.
8.3.2 The extended Kalman filter (EKF)
We now derive the extended Kalman filter for performing approximate inference in the model given by
Equation (8.15). We first linearize the dynamics model around µt−1|t−1
to get an approximation to
the one-step-ahead predictive distribution p(zt|y1:t−1,u1:t) = N (zt|µt|t−1
, Σt|t−1). We then linearize
the observation model around µt|t−1
, and then perform a Gaussian update. (In Section 8.3.2.2, we
consider linearizing around a different point that gives better accuracy.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.3. INFERENCE BASED ON LOCAL LINEARIZATION
We can write one step of the EKF algorithm using the notation from Section 8.2.2.5 as follows:
(µt|t−1
, Σt|t−1, −) = LinearizedMoments(µt−1|t−1
, Σt−1|t−1, f(·,ut), Qt) (8.136)
(yˆt, St, Ct) = LinearizedMoments(µt|t−1
, Σt|t−1, h(·,ut), Rt) (8.137)
(µt|t
, Σt|t
, ℓt) = GaussCondition(µt|t−1
, Σt|t−1, yˆt, St, Ct, yt) (8.138)
Spelling out the details more explicitly, we can write the predict step as follows:
µt|t−1 = f(µt−1
,ut) (8.139)
Σt|t−1 = FtΣt−1F
T
t + Qt (8.140)
where Ft ≡ Jac(f(·,ut))(µt|t−1
) is the Nz × Nz Jacobian matrix of the dynamics model. The update
step is as follows:
yˆt = h(µt|t−1
,ut) (8.141)
St = HtΣt|t−1HT
t + Rt (8.142)
Kt = Σt|t−1HT
t S
−1
t
(8.143)
µt|t = µt|t−1 + Kt(yt − yˆt) (8.144)
Σt|t = Σt|t−1 − KtHtΣt|t−1 = Σt|t−1 − KtStKT
t
(8.145)
where Ht ≡ Jac(h(·,ut))(µt|t−1
) is the Ny × Nz Jacobian matrix of the observation model and Kt is
the Nz × Ny Kalman gain matrix. See Supplementary Section 8.2.1 for the details of the derivation.
8.3.2.1 Accuracy
The EKF is widely used because it is simple and relatively efficient. However, there are two cases
when the EKF works poorly [IX00; VDMW03]. The first is when the prior covariance is large. In
this case, the prior distribution is broad, so we end up sending a lot of probability mass through
different parts of the function that are far from µt−1|t−1
, where the function has been linearized.
The other setting where the EKF works poorly is when the function is highly nonlinear near the
current mean (see Figure 8.5a).
A more accurate approach is to use a second-order Taylor series approximation, known as the
second order EKF. The resulting updates can still be computed in closed form (see [SS23, Sec 7.3]
for details). We can further improve performance by repeatedly re-linearizing the equations around
µt
instead of µt|t−1
; this is called the iterated EKF (see Section 8.3.2.2). In Section 8.4.2, we will
discuss an algorithm called the unscented Kalman filter (UKF) which is even more accurate, and is
derivative free (does not require computing Jacobians).
8.3.2.2 Iterated EKF
Another way to improve the accuracy of the EKF is by repeatedly re-linearizing the measurement
model around the current posterior, µt|t
, instead of µt|t−1
; this is called the iterated EKF [BC93].
See Algorithm 8.4 for the pseudocode. (If we set the number of iterations to J = 1, we recover the
standard EKF.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license372
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Algorithm 8.4: Iterated extended Kalman filter.
1 def IEKF(f, Q, h, R, y1:T , µ0|0
, Σ0|0, J) :
2 foreach t = 1 : T do
3 Predict step:
4 (µt|t−1
, Σt|t−1, −) = LinearizedMoments(µt−1|t−1
, Σt−1|t−1, f(·,ut), Qt)
5 Update step:
6 µt|t = µt|t−1
, Σt|t = Σt|t−1
7 foreach j = 1 : J do
8 (yˆt, St, Ct) = LinearizedMoments(µt|t
, Σt|t
, h(·,ut), Rt)
(µt|t
, Σt|t
, ℓt) = GaussCondition(µt|t−1
, Σt|t−1, yˆt, St, Ct, yt)
9 Return (µt|t
, Σt|t)
T
t=1
0 2 4 6 8
6
4
2
0
2
Noisy obervations from hidden trajectory
True States
Observations
(a)
0 2 4 6 8
6
4
2
0
2
EKF-filtered estimate of trajectory
True States
Observations
EKF Estimate
(b)
0 2 4 6 8
6
4
2
0
2
UKF-filtered estimate of trajectory
True States
Observations
UKF Estimate
(c)
Figure 8.4: Illustration of filtering applied to a 2d nonlinear dynamical system. (a) True underlying state and
observed data. (b) Extended Kalman filter estimate. Generated by ekf_spiral.ipynb. (c) Unscented Kalman
filter estimate. Generated by ukf_spiral.ipynb.
The IEKF can be interpreted as a Gauss–Newton method for finding MAP estimate of the state
at each step [BC93]. Specifically it minimizes the following objective:
L(zt) = 1
2
(yt − h(zt))TR−1
t
(yt − h(zt)) +
1
2
(zt − µt|t−1
)
TΣ
−1
t|t−1
(zt − µt|t−1
) (8.146)
See [SS23, Sec 7.4] for details.
Unfortunately the Gauss-Newton method can sometimes diverge. Various robust extensions —
including Levenberg-Marquardt, line search, and quasi-Newton methods — have been proposed in
[SHA15; SS20a]. See [SS23, Sec 7.5] for details.
8.3.2.3 Example: Tracking a point spiraling in 2d
In Section 8.2.1.1, we considered an example of state estimation and tracking of an object moving in
2d under a linear dynamics model with a linear observation model. However, motion and observation
models are often nonlinear. For example, consider an object that is moving along a curved trajectory,
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.4. INFERENCE BASED ON THE UNSCENTED TRANSFORM
such as this:
f(z) = (z1 + ∆ sin(z2), z2 + ∆ cos(z1)) (8.147)
where ∆ is the discrete step size (see [SS19, p221] for the continuous time version). For simplicity,
we assume full visibility of the state vector (modulo observation noise), so h(z) = z.
Despite the simplicity of this model, exact inference is intractable. However, we can easily apply
the EKF. The results are shown in Figure 8.4b.
8.3.2.4 Example: Neural network training
In Section 17.5.2, we show how to use the EKF to perform online parameter inference for an MLP
regression model.
8.3.3 The extended Kalman smoother (EKS)
We can extend the EKF to the offline smoothing case, resulting in the extended Kalman smoother,
also called the extended RTS smoother. We just need to linearize the dynamics around the
filtered mean when computing Ft, and then we can apply the standard Kalman smoother update.
See [SS23, Sec 13.1] for more details.
For improved accuracy, we can use the iterated EKS, which relinearizes the model at the previous
MAP estimate. In [Bel94], they show that IEKS is equivalent to a Gauss-Newton method for
computing the MAP estimate of the smoothing posterior. Unfortunately the IEKS can diverge in
some cases. A robust IEKS method, that uses line search and Levenberg-Marquardt to update the
parameters, is presented in [SS20a].
8.4 Inference based on the unscented transform
In this section, we replace the local linearization of the model with a different approximation. The key
idea is this: instead of computing a linear approximation to the dynamics and measurement functions,
and then passing a Gaussian distribtution through the linearized functions, we instead approximate
the joint distributions p(zt−1, zt|y1:t−1) and p(zt, yt|y1:t−1) by Gaussians, where the moments are
computed using numerical integration; we can then compute the marginal and conditional of these
distributions to perform the time and measurement updates.
There are many methods to compute the Gaussian moments, as we discuss in Section 8.5.1. Here
we use a method based on the unscented transform (see Section 8.4.1). Using the unscented transform
for the transition and observation models gives the the overall method, known as the unscented
Kalman filter or UKF, [JU97; JUDW00], also called the sigma point filter [VDMW03].
The main advantage of the UKF over the EKF is that it can be more accurate, and more stable.
(Indeed, [JU97; JUDW00] claim the term “unscented” was invented because the method “doesn’t
stink”.) In addition, the UKF does not need to compute Jacobians of the observation and dynamics
models, so it can be applied to non-differentiable models, or ones with hard constraints. However,
the UKF can be slower, since it requires Nz evaluations of the dynamics and observation models. In
addition, it has 3 hyper-parameters that need to be set.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license374
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
4 2 0 2 4
4
2
0
2
4
(a)
4 2 0 2 4
4
2
0
2
4
(b)
4 2 0 2 4
4
2
0
2
4
(c)
4 2 0 2 4
4
2
0
2
4
(d)
4 2 0 2 4
4
2
0
2
4
(e)
4 2 0 2 4
4
2
0
2
4
(f)
Figure 8.5: Illustration of different ways to approximate the distribution induced by a nonlinear transformation
f : R
2 → R
2
. (a) Data from the source distribution, D = {xi ∼ p(x)}, with Gaussian approximation
superimposed. (b) The dots show a Monte Carlo approximation to p(f(x)) derived from D
′ = {f(xi)}.
The dotted ellipse is a Gaussian approximation to this target distribution, computed from the empirical
moments. The solid ellipse is a Taylor transform. (c) Unscented sigma points. (d) Unscented transform. (e)
Gauss-Hermite points (order 5). (f ) GH transform. Adapted from Figures 5.3–5.4 of [Sar13]. Generated by
gaussian_transforms.ipynb.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.4. INFERENCE BASED ON THE UNSCENTED TRANSFORM
Algorithm 8.5: Computing sigma points using unscented transform.
1 def SigmaPoints(µ, Σ; α, β, κ) :
2 n = dimensionality of µ
3 λ = α
2
(n + κ) − n
4 Compute a set of 2n + 1 sigma points:
X0 = µ, Xi = µ +
√
n + λ [
√
Σ]:i
, Xi+n = µ −
√
n + λ [
√
Σ]:i
5 Compute a set of 2n + 1 weights for the mean and covariance:
w
m
0 =
λ
n+λ
, wc
0 =
λ
n+λ + (1 − α
2 + β), w
m
i = w
c
i =
1
2(n+λ)
6 Return (X0:2n, w
m
0:2n
, wc
0:2n
)
Algorithm 8.6: Unscented approximation to a joint Gaussian distribution.
1 def UnscentedMoments(µ, Σ, g, Ω; α, β, κ) :
2 (X0:2n, wm
0:2n
, wc
0:2n
) = SigmaPoints(µ, Σ; α, β, κ)
3 Yi = g(Xi), i = 0 : 2n
4 yˆ =
P2n
i=0 w
m
i Yi
5 S =
P2n
i=0 w
c
i
(Yi − µU )(Yi − µU )
T + Ω
6 C =
P2n
i=0 w
c
i
(Xi − µ)(Yi − µU )
T
7 Return (yˆ, S, C)
8.4.1 The unscented transform
Suppose we have two random variables x ∼ N (µ, Σ) and y = g(x), where g : R
n → R
m. The
unscented transform forms a Gaussian approximation to p(y) using the following process. First we
compute a set of 2n+ 1 sigma points, Xi
, and corresponding weights, w
m
i
and w
c
i
, using Algorithm 8.5,
for i = 0 : 2n. (The notation M:i means the i’th column of matrix M,
√
Σ is the matrix square root,
so √
Σ
√
Σ
T
= Σ.) Next we propagate the sigma points through the nonlinear function to get the
following 2n + 1 outputs:
Yi = g(Xi), i = 0 : 2n (8.148)
Finally we estimate the mean and covariance of the resulting set of points:
E [g(x)] ≈ yˆ =
X
2n
i=0
w
m
i Yi (8.149)
Cov [g(x)] ≈ S
′ =
X
2n
i=0
w
c
i
(Yi − yˆ)(Yi − yˆ)
T
(8.150)
Now suppose we want to approximate the joint distribution p(x, y), where y = g(x) + e, and
e ∼ N (0, Ω). By defining the augmented function g˜(x) = (x, g(x)), and applying the above
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license376
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
procedure (and adding extra noise), we get

x
y

∼ N µ
yˆ

,

Σ C
CT S
 (8.151)
where the parameters are computed using Algorithm 8.6.
The sigma points and their weights depend on three hyperparameters, α, β, and κ, which determine
the spread of the sigma points around the mean. A typical recommended setting for these is α = 10−3
,
κ = 1, β = 2 [Bit16].
In Figure 8.5(a-b), we show the linearized Taylor transform discussed in Section 8.3.1 applied to
a nonlinear function. In Figure 8.5(c-d), we show the corresponding unscented transform, which
we can see is more accurate. In fact, the unscented transform (which uses 2n + 1 sigma points)
is a third-order method in the sense that the mean of y is exact for polynomials up to order 3.
However the covariance is only exact for linear functions (first order polynomials), because the
square of a second order polynomial is already order 4. However, the UT idea can be extended to
order 5 using 2n
2 + 1 sigma points [MS67]; this can capture covariance terms exactly for quadratic
functions. We discuss even more accurate approximations, based on numerical integration methods,
in Section 8.5.1.4.
8.4.2 The unscented Kalman filter (UKF)
The UKF applies the unscented transform twice, once to approximate passing through the system
model f, and once to approximate passing through the measurement model h. By analogy to
Section 8.2.2.5, we can derive the UKF algorithm as follows:
(µt|t−1
, Σt|t−1, −) = UnscentedMoments(µt−1|t−1
, Σt−1|t−1, f(·,ut), Qt) (8.152)
(yˆt, St, Ct) = UnscentedMoments(µt|t−1
, Σt|t−1, h(·,ut), Rt) (8.153)
(µt|t
, Σt|t
, ℓt) = GaussCondition(µt|t−1
, Σt|t−1, yˆt, St, Ct, yt) (8.154)
See [SS23, Sec 8.8] for more details.
In Figure 8.4c, we illustrate the UKF algorithm (with α = 1, β = 0, κ = 2) applied to the 2d
nonlinear tracking problem from Section 8.3.2.3.
8.4.3 The unscented Kalman smoother (UKS)
The unscented Kalman smoother, also called the unscented RTS smoother [Sar08], is a
simple modification of the usual Kalman smoothing method, where we approximate the nonlinearity
by the unscented transform. The key insight is to notice that the reverse Kalman gain matrix Gt in
Equation (8.80) can be defined in terms of the predicted covariance and cross covariance, both of
which can be estimated using the UT. Once we have computed this, we can use the RTS equations
in the usual way. See [SS23, Sec 14.4] for the details.
An interesting application of unscented Kalman smoothing was its use by the UK government as
part of its COVID-19 contact tracing app [Lov+20; BCH20]. The app used the UKS to estimate
the distance between (anonymized) people based on bluetooth signal strength between their mobile
phones; the distance was then combined with other signals, such as contact duration and infectiousness
level of the index case, to estimate the risk of transmission. (See also [MKS21] for a way to learn the
risk score.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.5. OTHER VARIANTS OF THE KALMAN FILTER
8.5 Other variants of the Kalman filter
In this section, we briefly mention some other variants of Kalman filtering. For a more extensive
review, see [SS23; Li+17e].
8.5.1 General Gaussian filtering
This section is co-authored with Peter Chang.
Let p(z) = N (z|µ, Σ) and p(y|z) = N (y|hµ(z), Ω) for some function hµ. Let p(z, y) = p(z)p(y|z)
be the exact joint distribution. The best Gaussian approximation to the joint can be computed by
solving
q(z, y) = argmin
q∈N
DKL (p(z, y) k q(z, y)) (8.155)
As we explain in Section 5.1.4.2, this can be obtained by moment matching, i.e.,
q(z, y) = N
z
y

|

µ
yˆ

,

Σ C
CT S
 (8.156)
where
yˆ = E [y] = Z
hµ(z)N (z|µ, Σ)dz (8.157)
S = V [y] = Ω +
Z
(hµ(z) − yˆ)(hµ(z) − yˆ)
TN (z|µ, Σ)dz (8.158)
C = Cov [z, y] = Z
(z − µ)(hµ(z) − yˆ)
TN (z|µ, Σ)dz (8.159)
We can use the above Gaussian approximation either for the time update (i.e., going from
p(zt−1|y1:t−1) to p(zt|y1:t−1) via p(zt−1, zt|y1:t−1)), or for the measurement update, (i.e., going from
p(zt|y1:t−1) to p(zt|y1:t) via p(zt, yt|y1:t−1)). For example, if the prior from the time update is
p(zt) = N (zt|µt|t−1
, Σt|t−1), then the measurement update becomes
Kt = CtS
−1
t
(8.160)
µt|t = µt|t−1 + Kt(yt − yˆt) (8.161)
Σt|t = Σt|t−1 − KtStKT
t
(8.162)
The resulting method is called general Gaussian filtering or GGF [IX00; Wu+06].
8.5.1.1 Statistical linear regression
An alternative perspective on the above method is that we are approximating the likelihood by
q(y|z) = N (y|Az + b, Ω), where we define
A = CTΣ
−1
b = yˆ − Aµ
Ω = S − AΣAT
(8.163)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license378
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
This is called statistical linear regression or SLR [LBS01; AHE07], and ensures that we minimize
L(A, b, Ω) = EN(z|µ,Σ)
[DKL (p(y|z) k q(y|z; A, b, Ω))] (8.164)
For the proof, see [GF+15; Kam+22].
Equivalently, one can show that the above parameters minimize the following mean squared error
L(A, b) = E

(y − Ax − b)
T
(y − Ax − b)

(8.165)
with Ω given by the residual noise
Ω = E

(y − Ax − b)(y − Ax − b)
T

(8.166)
See [SS23, Sec 9.4] for the proof.
Note that although SLR results in a linear model, it is different than the Taylor series approximation
of Section 8.3.1, since the linearization is chosen to be optimal wrt a distribution of points (averaged
over N (z|µ, Σ)), instead of just being optimal at a single point µ.
8.5.1.2 Approximating the moments
To implement GGF, we need a way to compute yˆ, S and C. To help with this, we define two
functions to compute Gaussian first and second moments:
ge(f, µ, Σ) ,
Z
f(z)N (z|µ, Σ)dz (8.167)
gc(f, g, µ, Σ) ,
Z
(f(z) − f)(g(z) − g)
TN (z|µ, Σ)dz (8.168)
where f = ge(f, µ, Σ) and g = ge(g, µ, Σ). There are several ways to compute these integrals, as we
discuss below.
8.5.1.3 Approximation based on linearization
The simplest approach to approximating the moments is to linearize the functions f and g around µ,
which yields the following (see Section 8.3.1):
fˆ(z) = µ + F(z − µ) (8.169)
gˆ(z) = µ + G(z − µ) (8.170)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.5. OTHER VARIANTS OF THE KALMAN FILTER
where F and G are the Jacobians of f and g. Thus we get the following implementation of the
moment functions:
ge(fˆ, µ, Σ) = E [µ + F(z − µ)] = µ (8.171)
gc(fˆ, gˆ, µ, Σ) = E
h
(fˆ(z) − f)(gˆ(z) − g)
T
i
(8.172)
= E
h
fˆ(z)gˆ(z)
T + fg
T − fˆ(z)g
T − fgˆ(z)
T
i
(8.173)
= E

(µ + F(z − µ))(µ + G(z − µ))T + µµT − µµT − µµT

(8.174)
= E

µµT + F(z − µ)(z − µ)
TGT + F(z − µ)µ
T + µ(z − µ)
TGT − µµT

(8.175)
= FE

(z − µ)(z − µ)
T

GT = FΣGT
(8.176)
Using this inside the GGF is equivalent to the EKF in Section 8.3.2. However, this approach can
lead to large errors and sometimes divergence of the filter [IX00; VDMW03].
8.5.1.4 Approximation based on Gaussian quadrature
Since we are computing integrals wrt a Gaussian measure, we can use Gaussian quadrature
methods of the following form:
Z
h(z)N (z|µ, Σ)dz ≈
X
K
k=1
w
kh(z
k
) (8.177)
for a suitable set of evaluation points z
k
(sometimes called sigma points) and weights w
k
. (Note
that one-dimensional integrals are called quadratures, and multi-dimensional integrals are called
cubatures.)
One way to compute the sigma points is to use the unscented transform described in Section 8.4.1.
Using this inside the GGF is equivalent to the UKF in Section 8.4.2.
Alternatively, we can use spherical cubature integration, which gives rise to the cubature
Kalman filter or CKF [AH09]. This turns out (see [SS23, Sec 8.7]) to be a special case of the
UKF, with 2nz + 1 sigma points, and hyperparameter values of α = 1 and β = 0 (with κ left free).
A more accurate approximation uses Gauss-Hermite integration, which allows the user to
select more sigma points. In particular, an order p approximation will be exact for polynomials of
order up to 2p − 1. See [SS23, Sec 8.3] for details, and Figure 8.5(e-f) for an illustration. However,
this comes at a price: the number of sigma points is now p
n. Using Gauss-Hermite integration
for GGF gives rise to the Gauss-Hermite Kalman filter or GHKF [IX00], also known as the
quadrature Kalman filter or QKF [AHE07].
8.5.1.5 Approximation based on Monte Carlo integration
We can also approximate the integrals with Monte Carlo (see Section 11.2). Note, however, that
this is not the same as particle filtering (Section 13.2), which approximates the conditional p(zt|y1:t)
rather than the joint p(zt, yt|y1:t−1) (see Section 8.6.1 for discussion of this difference).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license380
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.5.2 Conditional moment Gaussian filtering
We can go beyond the Gaussian likelihood assumption by approximating the actual likelihood by a
linear Gaussian model, as proposed in [TGFS18]. The only requirement is that we can compute the
first and second conditional moments of the likelihood:
hµ(z) = E [y|z] = Z
yp(y|z)dy (8.178)
hΣ(z) = Cov [y|z] = Z
(y − hµ(z))(y − hµ(z))T
p(y|z)dy (8.179)
Note that these integrals may be wrt a non-Gaussian measure p(y|z). Also, y may be discrete, in
which case these integrals become sums.
Next we compute the unconditional moments. By the law of iterated expecations we have
yˆ = E [y] = E [E [y|z]] = Z
hµ(z)N (z|µ, Σ)dz = ge(hµ(z), µ, Σ) (8.180)
Similarly
C = Cov [z, y] = E [E [(z − µ)(y − yˆ)|z]] = E [(z − µ)(hµ(z) − yˆ)] (8.181)
=
Z
(z − µ)(hµ(z) − yˆ)
TN (z|µ, Σ)dz = gc(z, hµ(z), µ, Σ) (8.182)
Finally
S = V [y] = E [V [y|z]] + V [E [y|z]] (8.183)
=
Z
hΣ(z)N (z|µ, Σ)dz +
Z
(hµ(z) − yˆ)(hµ(z) − yˆ)
TN (z|µ, Σ)dz (8.184)
= ge(hΣ(z), µ, Σ) + gc(hµ(z), hµ(z), µ, Σ) (8.185)
Note that the equation for yˆ is the same in Equation (8.157) and Equation (8.180), and the equation
for C is the same in Equation (8.159) and Equation (8.182). Furthermore, if hΣ(z) = Ω, then the
equation for S is the same in Equation (8.158) and Equation (8.185).
We can approximate the unconditional moments using linearization or numerical integration.
We can then plug them into the GGF algorithm. We call this conditional moments Gaussian
filtering or CMGF.
We can use CMGF to perform approximate inference in SSMs with Poisson likelihoods. For
example, if p(y|z) = Poisson(y|cez
), we have
hµ(z) = hΣ(z) = cez
(8.186)
This method can be used to perform (extended) Kalman filtering with more general exponential
family likelihoods, as described in [TGFS18; Oll18]. For example, suppose we have a categorical
likelihood:
p(yt|zt) = Cat(yt|pt) = Cat(yt|softmax(ηt
)) = Cat(yt|softmax(h(zt)) (8.187)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.5. OTHER VARIANTS OF THE KALMAN FILTER
where ηt = h(zt) are the predicted logits. Then the conditional mean and covariance are given by
hµ(zt) = pt = softmax(h(zt)), hΣ(zt) = diag(pt) − ptp
T
t
(8.188)
(We can drop one of the classes from the vector pt to ensure the covariance is full rank.) This
approach can be used for online inference in neural network classifiers [CMJ22], as well as Gaussian
process classifiers [GFTS19] and recommender systems [GU16; GUK21]. We can also use this method
as a proposal distribution inside of a particle filtering algorithm (Section 13.2), as discussed in
[Hos+20b].
8.5.3 Iterated filters and smoothers
The GGF method in Section 8.5.1, and the CMGF method in Section 8.5.2, both require computing
moments wrt the predictive distribution N (zt|µt|t−1
, Σt|t−1) before performing the measurement
update. It is possible to do one step of GGF to compute the posterior given the new observation,
N (zt|µt|t
, Σt|t), and then to use this revised posterior to compute new moments in an iterated
fashion. This is called iterated posterior linearization filter or IPLF [GF+15]. (This is similar
to the iterated EKF which we discussed in Section 8.3.2.2.) See Algorithm 8.7 for the pseudocode,
and [SS23, Sec 10.4] for more details.
Algorithm 8.7: Iterated conditional moments Gaussian filter.
1 def Iterated-CMGF(f, Q, hµ, hΣ, y1:T , µ0|0
, Σ0|0, J, ge, gc) :
2 foreach t = 1 : T do
3 Predict step:
4 (µt|t−1
, Σt|t−1, −) = CondMoments(µt−1|t−1
, Σt−1|t−1, f, Q, ge, gc)
5 Update step:
6 µt|t = µt|t−1
, Σt|t = Σt|t−1
7 foreach j = 1 : J do
8 (yˆt, St, Ct) = CondMoments(µt|t
, Σt|t
, hµ, hΣ, ge, gc)
9 (µt|t
, Σt|t
, ℓt) = GaussCondition(µt|t−1
, Σt|t−1, yˆt, St, Ct, yt)
10 Return (µt|t
, Σt|t)
T
t=1
11 def CondMoments(µ, Σ, hµ, hΣ, ge, gc) :
12 yˆ = ge(hµ(z), µ, Σ)
13 S = ge(hΣ(z), µ, Σ) + gc(hµ(z), hµ(z), µ, Σ)
14 C = gc(z, hµ(z), µ, Σ)
15 Return (yˆ, S, C)
In a similar way, we can derive the iterated posterior linearization smoother or IPLS
[GFSS17]. This is similar to the iterated EKS which we discussed in Section 8.3.3.
Unfortunately the IPLF and IPLS can diverge. A more robust version of IPLF, that uses line search
to perform damped (partial) updates, is presented in [Rai+18b]. Similarly, a more robust version
of IPLS, that uses line search and Levenberg-Marquardt to update the parameters, is presented in
[Lin+21c].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license382
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Various extensions of the above methods have been proposed. For example, in [HPR19] they
extend IPLS to belief propagation in Forney factor graphs (Section 4.6.1.2), which enables the
method to be applied to a large class of graphical models beyond SSMs. In particular, they give a
general linearization formulation (including explicit message update rules) for nonlinear approximate
Gaussian BP (Section 9.4.3) where the linearization can be Jacobian-based (“EKF-style”), statistical
(moment matching), or anything else. They also show how any such linearization method can benefit
from iterations.
In [Kam+22], they present a method based on approximate expectation propagation (Section 10.7),
that is very similar to IPLS, except that the distributions that are used to compute the SLR terms,
needed to compute the Gaussian messages, are different. In particular, rather than using the smoothed
posterior from the last iteration, it uses the “cavity” distribution, which is the current posterior minus
the incoming message that was sent at the last iteration, similar to Section 8.2.4.4. The advantage of
this is that the outgoing message does not double count the evidence. The disadvantage is that this
may be numerically unstable.
In [WSS21], they propose a variety of “Bayes-Newton” methods for approximately computing
Gaussian posteriors to probabilistic models with nonlinear and/or non-Gaussian likelihoods. This
generalizes all of the above methods, and can be applied to SSMs and GPs.
8.5.4 Ensemble Kalman filter
The ensemble Kalman filter (EnKF) is a technique developed in the geoscience (meteorology)
community to perform approximate online inference in large nonlinear systems. In particular, it
is mostly used for problems where the hidden state represents an unknown physical quantity (e.g.,
temperature or pressure) at each point on a spatial grid, and the measurements are sparse and
spatially localized. Combining this information over space and time is called data assimilation.
The canonical reference is [Eve09], but a more accessible tutorial (using the same Bayesian signal
processing approach we adopt in this chapter) is in [Rot+17].
The key idea is to represent the belief state p(zt|y1:t) by a finite number of samples Zt|t = {z
s
t|t
:
s = 1 : Ns}, where each z
s
t|t ∈ R
Nz
. In contrast to particle filtering (Section 13.2), the samples are
updated in a manner that closely resembles the Kalman filter, so there is no importance sampling
or resampling step. The downside is that the posterior does not converge to the true Bayesian
posterior even as Ns → ∞ [LGMT11], except in the linear-Gaussian case. However, sometimes the
performance of EnKF can be better for small number of samples (although this depends of course on
the PF proposal distribution).
The posterior mean and covariance can be derived from the ensemble of samples as follows:
z˜t|t =
1
Ns
X
Ns
s=1
z
s
t|t =
1
Ns
Zt|t1 (8.189)
Σ˜
t|t =
1
Ns − 1
X
Ns
s=1
(z
s
t − z˜t|t)(z
s
t − z˜t|t)
T =
1
Ns − 1
Z˜
t|tZ˜T
t|t
(8.190)
where Z˜
t|t = Zt|t − z˜t|t1
T = Zt|t(INs −
1
Ns
11T
).
We update the samples as follows. For the time update, we first draw Ns system noise variables
q
s
t ∼ N (0, Qt), and then we pass these, and the previous state estimate, through the dynamics
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.5. OTHER VARIANTS OF THE KALMAN FILTER
model to get the one-step-ahead state predictions, z
s
t|t−1 = f(z
s
t−1|t−1
, q
s
t
), from which we get
Zt|t−1 = {z
s
t|t−1
}, which has size Nz×Ns. Next we draw Ns observation noise variables r
s
t ∼ N (0, Rt),
and use them to compute the one-step-ahead observation predictions, y
s
t|t−1 = h(z
s
t|t−1
, r
s
t
) and
Yt|t−1 = {y
s
t|t−1
}, which has size Ny × Ns. Finally we compute the measurement update using
Zt|t = Zt|t−1 + K˜
t(yt1
T − Yt|t−1) (8.191)
which is the analog of Equation (8.29).
We now discuss how to compute K˜
t, which is the analog of the Kalman gain matrix in Equa￾tion (8.28). First note that we can write the exact Kalman gain matrix (in the linear-Gaussian case)
as Kt = Σt|t−1HTS
−1
t = CtS
−1
t
, where St is the covariance of the measurements, and Ct is the
crosscovariance between the state and output predictions. In the EnKF, we approximate St and Ct
empirically as follows. First we compute the anomalies
Z˜
t|t−1 = Zt|t−1 − z˜t|t−11
T
, Y˜
t|t−1 = Yt|t−1 − y˜t|t−11
T
(8.192)
Then we compute the sample covariance matrices
C˜
t =
1
Ns − 1
Z˜
t|t−1Y˜ T
t|t−1
, S˜
t =
1
Ns − 1
Y˜
t|t−1Y˜ T
t|t−1
(8.193)
Finally we compute
K˜
t = C˜
tS˜−1
t
(8.194)
which has the same form as a multivariate least squares problem. For models with additive noise, we
can reduce the variance of this procedure by eliminating the sampling of the predicted observations.
Thus we replace Y˜
t|t−1 with its deterministic version, O˜
t|t−1 = HZ˜
t|t−1 (assuming a linear observation
model for notational simplicity). We then use C˜
t =
1
Ns−1Z˜
t|t−1O˜ T
t|t−1
, and S˜
t =
1
Ns−1O˜
t|t−1O˜ T
t|t−1 +
Rt. (It is also possible to eliminate the sampling for the latent states, by using the ensemble square
root filter [Tip+03], although this may be less robust.)
We now compare the computational complexity to the KF algorithm. Recall that Nz is the number
of latent dimensions, Ny is the number of observed dimensions, and Ns is the number of samples.
We will assume Nz > Ns > Ny, as occurs in most geospatial problems. The EnKF time update takes
O(N2
z Ns) time to propagate the samples though the model (assuming a linear model, for simplicity),
whereas the KF takes O(N3
z
) time to compute FtΣt−1Ft + Qt. The EnKF measurement update
takes O(NzNyNs) time to compute C˜
t, O(N2
y Ns) time to compute S˜
t, O(N3
y
) time to compute
S˜−1
t
, O(NzN2
y
) to compute K˜
t, and O(NzNyNs) time to compute Zt|t
. By contrast, in the KF, the
measurement update takes O(N2
z Ny) to compute Ct, O(N2
z Ny) to compute St, O(N3
y
) to compute
S
−1
t
, O(NzN2
y
) to compute Kt, and O(NzNy) to compute µt|t
. In summary, EnKF is ONzNs), but
EKF is O(N2
z
), if we ignore the dependency on Ny for simplicity.
Unfortunately, if Ns is too small, the EnKF can be become overconfident, and the filter can diverge.
A common heuristic to reduce this is known as covariance inflation, in which we replace Z˜
t|t−1
with Z˜
t|t−1 =
1
c
(Zt|t−1 − z˜t|t−11
T
) for some fudge factor c < 1.
Unlike the particle filter, the EnKF is not guaranteed to converge to the correct posterior. However,
hybrid PF/EnKF approaches have been developed (see e.g., [LGMT11; FK13b; Rei13]) with better
theoretical foundations.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license384
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.5.5 Robust Kalman filters
In practice we often have noise that is non-Gaussian. A common example is when we have clutter, or
outliers, in the observation model, or sudden changes in the process model. In this case, we might
use the Laplace distribution [Ara+09] or the Student t-distribution [Ara10; RÖG13; Ara+17] as
noise models.
[Hua+17b] proposes a variational Bayes (Section 10.3.3) approach, that allows the dynamical
prior and the observation model to both be (linear) Student distributions, but where the posterior is
approximated at each step using a Gaussian, conditional on the noise scale matrix, which is modeled
using an inverse Wishart distribution. An extension of this, to handle mixture distributions, can be
found in [Hua+19].
8.5.6 Dual EKF
In this section, we briefly discuss one approach to estimating the parameters of an SSM. In an offline
setting, we can use EM, SGD, or Bayesian inference to compute an approximation to p(θ|y1:T ) (see
Section 29.8). In the online setting, we want to compute p(θt|y1:t). We can do this by adding the
parameters to the state space, possibly with an artificial dynamics, p(θt|θt−1) = N (θt|θt−1, ǫI),
and then performing joint inference of states and parameters. The latent variables at each step
now contain the latent states, zt, and the latent parameters, θt. One approach to performing
approximating inference in such a model is to use the dual EKF, in which one EKF performs state
estimation and the other EKF performs parameter estimation [WN01].
8.5.7 Normalizing flow KFs
Normalizing flows, as discussed in Chapter 23, are a kind of deep generative model with a tractable
exact likelihood. These can be used to “upgrade” the observation model of a linear Gaussian SSM,
while still retaining tractable exact Gaussian inference, as shown in [Béz+20]. In particular, instead
of observing yt = Htzt + rt, where rt ∼ N (0, Rt), we observe yt = ft(ht), where ht = Htzt + rt,
and ft : R
Ny → R
Ny is an invertible function with a tractable Jacobian. In this case, the exact
posterior, p(zt|y1:t), is given by the usual Kalman filter equations applied to ht = f
−1
t
(yt) instead of
yt, which we denote by pLGSSM(zt|h1:t).
This result can be shown by induction. First note that, by the change of variable formula, p(yt|zt) =
p(ht|zt)Df −1
t
(yt), where Dg(a) , | det Jac(g)(a)|. By induction, we have p(zt−1|y1:t−1) = pLGSSM(zt−1|h1:t−1),
and hence by the linear Gaussian assumptions for the dynamics model, p(zt|y1:t−1) = pLGSSM(zt|h1:t−1).
Thus the filtering posterior is given by
p(zt|y1:t) = p(yt|zt)p(zt|y1:t−1)
R
p(yt|z
′
t
)p(z
′
t
|y1:t−1)dz
′
t
=
Df −1
t
(yt)p(ht|zt)p(zt|y1:t−1)
R
Df −1
t
(yt)p(ht|z
′
t
)p(z
′
t
|y1:t−1)
=
p(ht|zt)pLGSSM(zt|h1:t−1)
R
p(ht|z
′
t
)pLGSSM(z
′
t
|h1:t−1)
= pLGSSM(zt|h1:t)
Similar reasoning applies to the smoothing distribution.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.6. ASSUMED DENSITY FILTERING
qt−1
pt|t−1
pt
qt
pt+1|t
pt+1
qt+1
Predict
Update
Project
Predict
Update
Project
Figure 8.6: Illustration of the predict-update-project cycle of assumed density filtering. qt ∈ Q is a tractable
distribution, whereas we may have pt|t−1 6∈ Q and pt 6∈ Q.
8.6 Assumed density filtering
In this section, we discuss assumed density filtering or ADF [May79]. In this approach, we
assume the posterior has a specific form (e.g., a Gaussian). At each step, we update the previous
posterior with the new likelihood; the result will often not have the desired form (e.g., will no longer
be Gaussian), so we project it to the closest approximating distribution of the required type.
In more detail, we assume (by induction) that our prior qt−1(zt−1) ≈ p(zt−1|y1:t−1) satisfies
qt−1 ∈ Q, where Q is a family of tractable distributions. We can update the prior with the new
measurement to get the approximate posterior as follows. First we compute the one-step-ahead
predictive distribution
pt|t−1(zt|y1:t−1) = Z
p(zt|zt−1)qt−1(zt−1)dzt−1 (8.195)
Then we update this prior with the likelihood for step t to get the posterior
pt(zt|y1:t) = 1
Zt
p(yt|zt)pt|t−1(zt) (8.196)
where
Zt =
Z
p(yt|zt)pt|t−1(zt)dzt (8.197)
is the normalization constant. Unfortunately, we often find that the resulting posterior is no longer in
our tractable family, p(zt) 6∈ Q. So after Bayesian updating we seek the best tractable approximation
by computing
qt(zt|y1:t) = argmin
q∈Q
DKL (pt(zt|y1:t) k q(zt)) (8.198)
This minimizes the Kullback-Leibler divergence from the approximation q(zt) to the “exact” posterior
pt(zt), and can be thought of as projecting p onto the space of tractable distributions. Thus the
overall algorithm consists of three steps — predict, update, and project — as sketched in Figure 8.6.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license386
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Filtering
Exact Approximate
Joint 
Expectation
Conditional 
Expectation
Gaussian 
Filter
EKF
Kalman Filter
Monte 
Carlo
Particle 
Filter
Numeric
ADF UKF
Figure 8.7: A taxonomy of filtering algorithms. Adapted from Figure 2 of [Wüt+16].
Computing minq DKL (p k q) is known as moment projection, since the optimal q should have
the same moments as p (see Section 5.1.4.2). So in the Gaussian case, we just need to set the
mean and covariance of qt so they are the same as the mean and covariance of pt. We will give
some examples of this below. By contrast, computing minq DKL (q k p), as in variational inference
(Section 10.1), is known as information projection, and will result in mode seeking behavior (see
Section 5.1.4.1), rather than trying to capture overall moments.
8.6.1 Connection with Gaussian filtering
When Q is the set of Gaussian distributions, there is a close connection between ADF and Gaussian
filtering, which we discussed in Section 8.5.1. GF corresponds to solving the following optimization
problem
qt|t−1(zt, y˜t) = argmin
q∈Q
DKL (p(zt, y˜t|y1:t−1) k q(zt, y˜t|y1:t−1)) (8.199)
which can be solved by moment matching (see Section 8.5.1). We then condition this joint distribution
on the event y˜t = yt, where y˜t is the unknown random variable and yt is its observed value. This gives
pt(zt|y1:t), which is easy to compute, due to the Gaussian assumption. By contrast, in Gaussian ADF,
we first compute the (locally) exact posterior pt(zt|y1:t), and then approximate it with qt(zt|y1:t) by
projecting into Q. Thus ADF approximates the conditional pt(zt|y1:t), whereas GF approximates
the joint pt|t−1(zt, y˜t|y1:t−1), from which we derive pt(zt|y1:t) by conditioning.
ADF is more accurate than GF, since it directy approximates the posterior, but it is more
computationally demanding, for reasons explained in [Wüt+16]. However, in [Kam+22] they propose
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.6. ASSUMED DENSITY FILTERING
b
1
t−1
b
2
t−1
!
!✒!
❅
❅❅❘
!
!✒!
❅
❅❅❘
Filter 1
Filter 2
Filter 1
Filter 2
✲
✲
✲
✲
b
1,1
t
b
1,2
t
b
2,1
t
b
2,2
t
❅
❅❘❅
❇
❇
❇
❇
❇
❇
❇◆
✂
✂
✂
✂
✂
✂
✍✂
!
!!✒
Merge
Merge
✲
✲
b
1
t
b
2
t
(a)
b
1
t−1
b
2
t−1
✲
✲
Merge
✲
✲
˜b
1
t−1
˜b
2
t−1
✲
✲
Filter 1
Filter 2
✲
✲
b
1
t
b
2
t
(b)
Figure 8.8: ADF for a switching linear dynamical system with 2 discrete states. (a) GPB2 method. (b) IMM
method.
an approximate form of expectation propagation (which is a generalization of ADF) in which the
messages are computed using the same local joint Gaussian approximation as used in Gaussian
filtering. See Figure 8.7 for a summary of how these different methods relate.
8.6.2 ADF for SLDS (Gaussian sum filter)
In this section, we apply ADF to inference in switching linear dynamical systems (SLDS, Section 29.9),
which are a combination of HMM and LDS models. The resulting method is known as the Gaussian
sum filter (see e.g., [Cro+11; Wil+17]).
A Gaussian sum filter approximates the belief state at each step by a mixture of K Gaussians.
This can be implemented by running K Kalman filters in parallel. This is particularly well suited
to switching SSMs. We now describe one version of this algorithm, known as the “second order
generalized pseudo-Bayes filter” (GPB2) [BSF88]. We assume that the prior belief state bt−1 is
a mixture of K Gaussians, one per discrete state:
b
i
t−1 , p(zt−1, mt−1 = i|y1:t−1) = π
i
t−1|t−1N (zt−1|µ
i
t−1|t−1
, Σ
i
t−1|t−1
) (8.200)
where i ∈ {1, . . . , K}. We then pass this through the K different linear models to get
b
ij
t , p(zt, mt−1 = i, mt = j|y1:t) = π
ij
t|tN (zt|µ
ij
t|t
, Σ
ij
t|t
) (8.201)
where π
ij
t|t = π
i
t−1|t−1Aij , where Aij = p(mt = j|mt−1 = i). Finally, for each value of j, we collapse
the K Gaussian mixtures down to a single mixture to give
b
j
t , p(zt, mt = j|y1:t) = π
j
t|tN (zt|µ
j
t|t
, Σ
j
t|t
) (8.202)
See Figure 8.8a for a sketch.
The optimal way to approximate a mixture of Gaussians with a single Gaussian is given by
q = arg minq DKL (q k p), where p(z) = P
k
π
kN (z|µ
k
, Σ
k
) and q(z) = N (z|µ, Σ). This can be
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license388
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
solved by moment matching, that is,
µ = E [z] = X
k
π
kµ
k
(8.203)
Σ = Cov [z] = X
k
π
k

Σ
k + (µ
k − µ)(µ
k − µ)
T

(8.204)
In the graphical model literature, this is called weak marginalization [Lau92], since it preserves
the first two moments. Applying these equations to our model, we can go from b
ij
t
to b
j
t as follows
(where we drop the t subscript for brevity):
π
j =
X
i
π
ij (8.205)
π
j|i =
π
ij
P
j
′ π
ij′
(8.206)
µ
j =
X
i
π
j|iµ
ij (8.207)
Σ
j =
X
i
π
j|i
￾
Σ
ij + (µ
ij − µ
j
)(µ
ij − µj
)
T

(8.208)
This algorithm requires running K2 filters at each step. A cheaper alternative, known as interac￾tive multiple models or IMM [BSF88], can be obtained by first collapsing the prior to a single
Gaussian (by moment matching), and then updating it using K different Kalman filters, one per
value of mt. See Figure 8.8b for a sketch.
8.6.3 ADF for online logistic regression
In this section we discuss the application of ADF to online Bayesian parameter inference for a binary
logistic regression model, based on [Zoe07]. The overall approach is similar to the online linear
regression case (discussed in Section 29.7.2), but approximates the posterior after each update step,
which is necessary since the likelihood is not conjugate to the prior.
We assume our model has the following form:
p(yt|xt, wt) = Ber(yt|σ(x
T
t wt)) (8.209)
p(wt|wt−1) = N (wt|wt−1, Q) (8.210)
where Q is the covariance of the process noise, which allows the parameters to change slowly over
time. We will assume Q = ǫI; we can also set ǫ = 0, as in the recursive least squares method
(Section 29.7.2), if we believe the parameters will not change. See Figure 8.9 for an illustration of the
model.
As our approximating family, we will use diagonal Gaussians, for computational efficiency. Thus
the prior is the posterior from the previous time step, and has the form
p(wt−1|D1:t−1) ≈ pt−1(wt−1) = Y
j
N (w
j
t−1
|µ
j
t−1|t−1
, τ
j
t−1|t−1
) (8.211)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.6. ASSUMED DENSITY FILTERING
xt−1 xt
yt−1 yt
ηt−1 ηt
wt−1 wt
Figure 8.9: A dynamic logistic regression model. wt are the regression weights at time t, and ηt = wT
t xt.
Compare to Figure 29.24a.
where µ
j
t−1|t−1
and τ
j
t−1|t−1
are the posterior mean and variance for parameter j given past data.
Now we discuss how to update this prior.
First we compute the one-step-ahead predictive density pt|t−1(wt) using the standard linear￾Gaussian update, i.e., µt|t−1 = µt−1|t−1 and τ t|t−1 = τ t−1|t−1 + Q, where we can set Q = 0I if there
is no drift.
Now we concentrate on the measurement update step. Define the scalar sum (corresponding to the
logits, if we are using binary classification) as ηt = wT
t xt. If pt|t−1(wt) = Q
j N (w
j
t
|µ
j
t|t−1
, τ
j
t|t−1
),
then we can compute the 1d prior predictive distribution for ηt as follows:
p(ηt|D1:t−1, xt) ≈ pt|t−1(ηt) = N (ηt|mt|t−1, vt|t−1) (8.212)
mt|t−1 =
X
j
xt,jµ
j
t|t−1
(8.213)
vt|t−1 =
X
j
x
2
t,j τ
j
t|t−1
(8.214)
The posterior for the 1d ηt is given by
p(ηt|D1:t) ≈ pt(ηt) = N (ηt|mt, vt) (8.215)
mt =
Z
ηt
1
Zt
p(yt|ηt)pt|t−1(ηt)dηt (8.216)
vt =
Z
η
2
t
1
Zt
p(yt|ηt)pt|t−1(ηt)dηt − m2
t
(8.217)
Zt =
Z
p(yt|ηt)pt|t−1(ηt)dηt (8.218)
where p(yt|ηt) = Ber(yt|ηt). These integrals are one dimensional, and so can be efficiently computed
using Gaussian quadrature, as explained in [Zoe07; KB00].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license390
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10 20 30 40 50 60
number samples
1.0
0.5
0.0
0.5
1.0
weights
w0 batch (Laplace)
w0 online (adf)
(a)
10 20 30 40 50 60
number samples
1.0
0.5
0.0
0.5
1.0
1.5
weights
w1 batch (Laplace)
w1 online (adf)
(b)
10 20 30 40 50 60
number samples
0.00
0.25
0.50
0.75
1.00
1.25
1.50
weights
w2 batch (Laplace)
w2 online (adf)
(c)
Figure 8.10: Bayesian inference applied to a 2d binary logistic regression problem, p(y = 1|x) =
σ(w0 + w1x1 + w2x2). We show the marginal posterior mean and variance for each parameter vs time
as computed by ADF. The dotted horizontal line is the offline Laplace approximation. Generated by
adf_logistic_regression_demo.ipynb.
Having inferred pt(ηt), we need to compute pt(w|ηt). This can be done as follows. Define δm as
the change in the mean and δv as the change in the variance:
mt = mt|t−1 + δm, vt = vt|t−1 + δv (8.219)
Using the fact that p(ηt|w) = N (ηt|wTηt, 0) is a linear Gaussian system, with prior p(w) =
p(w|µt|t−1
, τ t|t−1) and “soft evidence” p(ηt) = N (mt, vt), we can derive the posterior for p(w|Dt) as
follows:
pt(w
i
t
) = N (w
i
t
|µ
i
t|t
, τ i
t|t
) (8.220)
µ
i
t|t = µ
i
t|t−1 + aiδm (8.221)
τ
i
t|t = τ
i
t|t−1 + a
2
i
δv (8.222)
ai ,
x
i
t
τ
i
t|t−1
P
j
(x
j
t
)
2 + τ
j
t|t−1
(8.223)
Thus we see that the parameters which correspond to inputs i with larger magnitude (big |x
i
t
|) or
larger uncertainty (big τ
i
t|t−1
) get updated most, due to a large ai factor, which makes intuitive sense.
As an example, we consider a 2d binary classification problem. We sequentially compute the
posterior using the ADF, and compare to the offline estimate computed using a Laplace approximation.
In Figure 8.10 we plot the posterior marginals over the 3 parameters as a function of “time” (i.e., after
conditioning on each training example one). We see that we converge to the offline MAP estimate. In
Figure 8.11, we show the results of performing sequential Bayesian updating in a different ordering
of the data. We still converge to approximate the same answer. In Figure 8.12, we see that the
resulting posterior predictive distributions from the Laplace estimate and ADF estimate (at the end
of training) are similar.
Note that the whole algorithm only takes O(D) time and space per step, the same as SGD. However,
unlike SGD, there are no step-size parameters, since the diagonal covariance implicitly specifies the
size of the update for each dimension. Furthermore, we get a posterior approximation, not just a
point estimate.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.7. OTHER INFERENCE METHODS FOR SSMS
10 20 30 40 50 60
number samples
1.0
0.5
0.0
0.5
1.0
weights
w0 batch (Laplace)
w0 online (adf)
(a)
10 20 30 40 50 60
number samples
1.0
0.5
0.0
0.5
1.0
1.5
weights
w1 batch (Laplace)
w1 online (adf)
(b)
10 20 30 40 50 60
number samples
0.25
0.00
0.25
0.50
0.75
1.00
1.25
weights
w2 batch (Laplace)
w2 online (adf)
(c)
Figure 8.11: Same as Figure 8.10, except the order in which the data is visited is different. Generated by
adf_logistic_regression_demo.ipynb.
Laplace Predictive distribution
(a)
ADF Predictive distribution
(b)
Figure 8.12: Predictive distribution for the binary logistic regression problem. (a) Result from Laplace
approximation. (b) Result from ADF at the final step. Generated by adf_logistic_regression_demo.ipynb.
The overall approach is very similar to the generalized posterior linearization filter of Section 8.5.3,
which uses quadrature (or the unscented transform) to compute a Gaussian approximation to the
joint p(yt, wt|D1:t−1), from which we can easily compute p(wt|D1:t). However, ADF approximates
the posterior rather than the joint, as explained in Section 8.6.1.
8.6.4 ADF for online DNNs
In Section 17.5.3, we show how to use ADF to recursively approximate the posterior over the
parameters of a deep neural network in an online fashion. This generalizes Section 8.6.3 to the case
of nonlinear models.
8.7 Other inference methods for SSMs
There are a variety of other inference algorithms that can be applied to SSMs. We give a very brief
summary below. For more details, see e.g., [Dau05; Sim06; Fra08; Sar13; SS23; Tri21].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license392
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 5 10 15 20 25
time
−5
0
5
10
True state
Measurements
(a)
−20 −10 0 10 20
z20
0.0
0.1
0.2
Probability
Filtering
Smoothing
True state
Measurement
(b)
Figure 8.13: (a) Observations and true and estimated state. (b) Marginal distributions for time step t = 20.
Generated by discretized_ssm_student.ipynb.
8.7.1 Grid-based approximations
A very simple approach to approximate inference in SSMs is to discretize the state space, and then
to apply the HMM filter and smoother (see Section 9.2.3), as proposed in [RG17]. This is called
a grid-based approximation. Unfortunately, this approach will not scale to higher dimensional
problems, due to the curse of dimensionality. In particular, we know that the HMM filter takes
O(K2
) operations per time step, if there are K states. If we have Nz dimensions, each discretized
into B bins, then we have K = BNz
, so the approach quickly becomes intractable.
However, this approach can be useful in 1d or 2d. As an illustration, consider a simple 1d SSM
with linear dynamics corrupted by additive Student noise:
zt = zt−1 + T2(0, 1) (8.224)
The observations are also linear, and are also corrupted by additive Student noise:
yt = zt + T2(0, 1) (8.225)
This robust observation model is useful when there are potential outliers in the observed data, such
as at time t = 20 in Figure 8.13a. (See also Section 8.5.5 for discussion of robust Kalman filters.)
Unfortunately the use of a non-Gaussian likelihood means that the resulting posterior can become
multimodal. Fortunately, this is not a problem for the grid-based approach. We show the results
for filtering and smoothing in Figure 8.14a and in Figure 8.14b. We see that at t = 20, the
filtering distribution, p(zt|y1:20), is bimodal, with a mean that is quite far from the true state (see
Figure 8.13b for a detailed plot). Such a multimodal distribution can be approximated by a suitably
fine discretization.
8.7.2 Expectation propagation
In Section 10.7 we discuss the expectation propagation (EP) algorithm, which can be viewed as
an iterative version of ADF (Section 8.6). In particular, at each step we combine each exact local
likelihood factor with approximate factors from both the past filtering distribution and the future
smoothed posterior; these factors are combined to compute the locally exact posterior, which is then
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.7. OTHER INFERENCE METHODS FOR SSMS
(a) (b)
Figure 8.14: Discretized posterior of the latent state at each time step. Red cross is the true latent state. Red
circle is observation. (a) Filtering. (b) Smoothing. Generated by discretized_ssm_student.ipynb.
projected back to the tractable family (e.g., Gaussian), before moving to the next time step. This
process can be iterated for increased accuracy. In many cases the local EP update is intractable,
but we can make a local Gaussian approximation, similar to the one in general Gaussian filtering
(Section 8.5.1), as explained in [Kam+22].
8.7.3 Variational inference
EP can be viewed as locally minimizing the inclusive KL, DKL (p(zt|y1:T ) k q(zt|y1:T )), for each time
step t. An alternative approach is to globally minimize the exclusive KL, DKL (q(z1:T |y1:T ) k p(z1:T |y1:T ));
this is called variational inference, and is explained in Chapter 10. The difference between these two
objectives is discussed in more detail in Section 5.1.4.1, but from a practical point of view, the main
advantage of VI is that we can derive a tractable lower bound to the objective, and can then optimize
it using stochastic optimization. This method is guaranteed to converge, unlike EP. For more details
on VI applied to SSMs (both state estimation and parameter estimation), see e.g., [CWS21; Cou+20;
Cou+21; BFY20; FLMM21; Cam+21].
8.7.4 MCMC
In Chapter 12 we discuss Markov chain Monte Carlo (MCMC) methods, which can be used to draw
samples from intractable posteriors. In the case of SSMs, this includes both the distribution over
states, p(z1:T |y1:T ), and the distribution over parameters, p(θ|y1:T ). In some cases, such as when
using HMMs or linear-Gaussian SSMs, we can perform blocked Gibbs sampling, in which we use
forwards filtering backwards sampling to sample an entire sequence from p(z1:T |y1:T , θ), followed by
sampling the parameters, p(θ|z1:T , y1:T ) (see e.g., [CK96; Sco02; CMR05] for details.) Alternatively
we can marginalize out the hidden states and just compute the parameter posterior p(θ|y1:T ). When
state inference is intractable, we can use gradient-based HMC methods (assuming the states are
continuous), although this does not scale well to long sequences.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license394
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
8.7.5 Particle filtering
In Section 13.2 we discuss particle filtering, which is a form of sequential Bayesian inference for SSMs
which replaces the assumption that the posterior is (approximately) Gaussian with a more flexible
representation, namely a set of weighted samples called “particles” (see e.g., [Aru+02; DJ11; NLS19]).
Essentially the technique amounts to a form of importance sampling, combined with steps to prevent
“particle impoverishment”, which refers to some samples receiving negligible weight because they are
too improbable in the posterior (which grows with time). Particle filtering is widely used because
it is very flexible, and has good theoretical properties. In practice it may require many samples to
get a good approximation, but we can use heuristic methods, such as the extended or unscented
Kalman filters, as proposal distributions, which can improve the efficiency significantly. In the offline
setting, we can use particle smoothing (Section 13.5) or SMC (sequential Monte Carlo) samplers
(Section 13.6).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20239 Message passing algorithms
9.1 Introduction
In this chapter we consider posterior inference (i.e., computing marginals, modes, samples, etc) for
probability distributions that can be represented by a probabilistic graphical model (PGM, Chapter 4)
with some kind of sparse graph structure (i.e., it is not a fully connected graph). The algorithms
we discuss will leverage the conditional independence properties encoded in the graph structure
(discussed in Chapter 4) in order to perform efficient inference. In particular, we will use the principle
of dynamic programming (DP), which finds an optimal solution by solving subproblems and then
combining them.
DP can be implemented by computing local quantities for each node (or clique) in the graph,
and then sending messages to neighboring nodes (or cliques) so that all nodes (cliques) can come
to an overall consensus about the global solutions. Hence these are known as message passing
algorithms. Each message can be intepreted as probability distribution about the value of a node
given evidence from part of the graph. These distributions are often called belief states, so these
algorithms are also called belief propagation (BP) algorithms.
In Section 9.2, we consider the special case where the graph structure is a 1d chain, which is an
important special case. (For a chain, a natural approach is to send messages forwards in time, and
then backwards in time, so this method can also be used for inference in state space models, as we
discuss in Chapter 8.) In Section 9.3, we can generalize this approach to work with trees, and in
Section 9.4, we generalize it work with any graph, including ones with cycles or loops. However,
sending messages on loopy graphs may give incorrect answers. In such cases, we may wish to convert
the graph to a tree, and then send messages on it, using the methods discussed in Section 9.5 and
Section 9.6. We can also pose the inference problem as an optimization problem, as we discuss in
Section 9.7.
9.2 Belief propagation on chains
In this section, we consider inference for PGMs where the graph structure is a 1d chain. For notational
simplicity, we focus on the case where the graphical model is directed rather than undirected, although
the resulting methods are easy to generalize. In addition, we only consider the case where all the
hidden variables are discrete; we discuss generalizations to handle continuous latent variables in
Chapter 8 and Chapter 13.396
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
y1 y2 y3
z1 z2 z3
Figure 9.1: An HMM represented as a graphical model. zt are the hidden variables at time t, yt are the
observations (outputs).












 


Figure 9.2: The state transition matrix A and observation matrix B for the casino HMM. Adapted from
[Dur+98, p54].
9.2.1 Hidden Markov Models
In this section we assume the graphical model can be represented as a state space model, as shown in
Figure 9.1. We discuss SSMs in more detail in Chapter 29, but we can think of them as latent variable
sequence models with the conditional independencies shown by the chain-structured graphical model
Figure 8.1. The corresponding joint distribution has the form
p(y1:T , z1:T ) = "
p(z1)
Y
T
t=2
p(zt|zt−1)
# "Y
T
t=1
p(yt|zt)
#
(9.1)
where zt are the hidden variables at time t, and yt are the observations (outputs). If all the latent
variables are discrete (as we assume in this section), the resulting model is called a hidden Markov
model or HMM. We consider SSMs with continuous latent variables in Chapter 8.
9.2.1.1 Example: casino HMM
As a concrete example from [Dur+98], we consider the occasionally dishonest casino. We assume
we are in a casino and observe a series of die rolls, yt ∈ {1, 2, . . . , 6}. Being a keen-eyed statistician,
we notice that the distribution of values is not what we expect from a fair die: it seems that there
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.2. BELIEF PROPAGATION ON CHAINS
are occasional “streaks”, in which 6s seem to show up more often than other values. We would like to
estimate the underlying state, namely whether the die is fair or loaded, so that we make predictions
about the future.
To formalize this, let zt ∈ {1, 2} represent the unknown hidden state (fair or loaded) at time t, and
let yt ∈ {1, . . . , 6} represent the observed outcome (die roll). Let Ajk = p(zt = k|zt−1 = j) be the
state transition matrix. Most of the time the casino uses a fair die, z = 1, but occasionally it switches
to a loaded die, z = 2, for a short period, as shown in the state transition diagram in Figure 9.2.
Let Bkl = p(yt = l|zt = k) be the observation matrix corresponding to a categorical distribution
over values of the die face. If z = 1 the observation distribution is a uniform categorical distribution
over the symbols {1, . . . , 6}. If z = 2, the observation distribution is skewed towards face 6. That is,
p(yt|zt = 1) = Cat(yt|[1/6, . . . , 1/6]) (9.2)
p(yt|zt = 2) = Cat(yt|[1/10, 1/10, 1/10, 1/10, 1/10, 5/10]) (9.3)
If we sample from this model, we may generate data such as the following:
hid: 1111111111222211111111111111111111112222222221222211111111111111111111
obs: 1355534526553366316351551526232112113462221263264265422344645323242361
Here obs refers to the observation and hid refers to the hidden state (1 is fair and 2 is loaded). In
the full sequence of length 300, we find the empirical fraction of times that we observe a 6 in hidden
state 1 to be 0.149, and in state 2 to be 0.472, which are very close to the expected fractions. (See
casino_hmm.ipynb for the code.)
9.2.1.2 Posterior inference
Our goal is to infer the hidden states by computing the posterior over all the hidden nodes in the
model, p(zt|y1:T ). This is called the smoothing distribution. By the Markov property, we can
break this into two terms:
p(zt = j|yt+1:T , y1:t) ∝ p(zt = j, yt+1:T |y1:t)p(zt = j|y1:t)p(yt+1:T |zt = j,✟y1:✟t) (9.4)
We will first compute the filtering distribution p(zt = j|y1:t) by working forwards in time. We
then compute the p(yt+1:T |zt = j) terms by working backwards in time, and then we finally combine
both terms. Both passes take (TK2
) time, where K is the number of discrete hidden states. We give
the details below.
9.2.2 The forwards algorithm
As we discuss in Section 8.1.2, the Bayes filter is an algorithm for recursively computing the belief
state p(zt|y1:t) given the prior belief from the previous step, p(zt−1|y1:t−1), the new observation yt,
and the model. In the HMM literature, this is known as the forwards algorithm.
In an HMM, the latent states zt are discrete, so we can define the belief state as a vector,
αt(j) , p(zt = j|y1:t), the local evidence as another vector, λt(j) , p(yt|zt = j), and the transition
matrix as Ai,j = p(zt = j|zt−1 = i). Then the predict step becomes
αt|t−1(j) , p(zt = j|y1:t−1) = X
i
p(zt = j|zt−1 = i)p(zt−1 = i|y1:t−1 =
X
i
Ai,jαt−1(i) (9.5)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license398
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
100 200 300
Observation number
0.0
0.5
1.0
p(loaded)
Filtered
(a)
100 200 300
Observation number
0.0
0.5
1.0
p(loaded)
Smoothed
(b)
100 200 300
Observation number
0.0
0.5
1.0
MAP state
Viterbi
(c)
Figure 9.3: Inference in the dishonest casino. Vertical gray bars denote times when the hidden state
corresponded to the loaded die. Blue lines represent the posterior probability of being in that state given
different subsets of observed data. If we recover the true state exactly, the blue curve will transition at the
same time as the gray bars. (a) Filtered estimates. (b) Smoothed estimates. (c) MAP trajectory. Generated
by casino_hmm.ipynb.
and the update step becomes
αt(j) = 1
Zt
p(yt|zt = j)p(zt = j|y1:t−1) =
1
Zt
λt(j)αt|t−1(j) = 1
Zt
λt(j)
"X
i
αt−1(i)Ai,j#
(9.6)
where the normalization constant for each time step is given by
Zt , p(yt|y1:t−1) = X
K
j=1
p(yt|zt = j)p(zt = j|y1:t−1) = X
K
j=1
λt(j)αt|t−1(j) (9.7)
We can write the update equation in matrix-vector notation as follows:
αt = normalize ￾
λt ⊙(ATαt−1)

(9.8)
where ⊙ represents elementwise vector multiplication, and the normalize function just ensures its
argument sums to one. (See Section 9.2.3.4 for more discussion on normalization.)
Figure 9.3(a) illustrates filtering for the casino HMM, applied to a random sequence y1:T of length
T = 300. In blue, we plot the probability that the die is in the loaded (vs fair) state, based on
the evidence seen so far. The gray bars indicate time intervals during which the generative process
actually switched to the loaded die. We see that the probability generally increases in the right
places.
9.2.3 The forwards-backwards algorithm
In this section, we present the most common approach to smoothing in HMMs, known as the forwards￾backwards or FB algorithm [Rab89]. In the forwards pass, we compute αt(j) = p(zt = j|y1:t) as
before. In the backwards pass, we compute the conditional likelihood
βt(j) , p(yt+1:T |zt = j) (9.9)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.2. BELIEF PROPAGATION ON CHAINS
We then combine these using
γt(j) = p(zt = j|yt+1:T , y1:t) ∝ p(zt = j, yt+1:T |y1:t) (9.10)
= p(zt = j|y1:t)p(yt+1:T |zt = j,✟y1:✟t) = αt(j)βt(j) (9.11)
In matrix notation, this becomes
γt = normalize(αt ⊙ βt
) (9.12)
Note that the forwards and backwards passes can be computed independently, but both need access
to the local evidence p(yt|zt). The results are only combined at the end. This is therefore called
two-filter smoothing [Kit04].
9.2.3.1 Backwards recursion
We can recursively compute the β’s in a right-to-left fashion as follows:
βt−1(i) = p(yt:T |zt−1 = i) (9.13)
=
X
j
p(zt = j, yt, yt+1:T |zt−1 = i) (9.14)
=
X
j
p(yt+1:T |zt = j,✚yt,✘z ✘✘✘ t−1 = i)p(zt = j, yt|zt−1 = i) (9.15)
=
X
j
p(yt+1:T |zt = j)p(yt|zt = j,✘z ✘✘✘ t−1 = i)p(zt = j|zt−1 = i) (9.16)
=
X
j
βt(j)λt(j)Ai,j (9.17)
We can write the resulting equation in matrix-vector form as
βt−1 = A(λt ⊙ βt
) (9.18)
The base case is
βT (i) = p(yT +1:T |zT = i) = p(∅|zT = i) = 1 (9.19)
which is the probability of a non-event.
Note that βt P
is not a probability distribution over states, since it does not need to satisfy
j
βt(j) = 1. However, we usually normalize it to avoid numerical underflow (see Section 9.2.3.4).
9.2.3.2 Example
In Figure 9.3(a-b), we compare filtering and smoothing for the casino HMM. We see that the posterior
distributions when conditioned on all the data (past and future) are indeed smoother than when just
conditioned on the past (filtering).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license400
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
zt zt+1
yt yt+1
At,t+1
λt λt+1
αt|t−1 βt+1
Figure 9.4: Computing the two-slice joint distribution for an HMM from the forwards messages, backwards
messages, and local evidence messages.
9.2.3.3 Two-slice smoothed marginals
We can compute the two-slice marginals using the output of the forwards-backwards algorithm as
follows:
p(zt, zt+1|y1:T ) = p(zt, zt+1|y1:t, yt+1:T ) (9.20)
∝ p(yt+1:T |zt, zt+1, y1:t)p(zt, zt+1|y1:t) (9.21)
= p(yt+1:T |zt+1)p(zt, zt+1|y1:t) (9.22)
= p(yt+1:T |zt+1)p(zt|y1:t)p(zt+1|zt) (9.23)
= p(yt+1, yt+2:T |zt+1)p(zt|y1:t)p(zt+1|zt) (9.24)
= p(yt+1|zt+1)p(yt+2:T |zt+1, yt+1)p(zt|y1:t)p(zt+1|zt) (9.25)
= p(yt+1|zt+1)p(yt+2:T |zt+1)p(zt|y1:t)p(zt+1|zt) (9.26)
We can rewrite this in terms of the already computed quantities as follows:
ξt,t+1(i, j) ∝ λt+1(j)βt+1(j)αt(i)Ai,j (9.27)
Or in matrix-vector form:
ξt,t+1 ∝ A ⊙

αt(λt+1 ⊙ βt+1)
T

(9.28)
Since αt ∝ λt ⊙ αt|t−1, we can also write the above equation as follows:
ξt,t+1 ∝ A ⊙

(λt ⊙ αt|t−1) ⊙ (λt+1 ⊙ βt+1)
T

(9.29)
This can be interpreted as a product of incoming messages and local factors, as shown in Figure 9.4.
In particular, we combine the factors αt|t−1 = p(zt|y1:t−1), A = p(zt+1|zt), λt ∝ p(yt|zt), λt+1 ∝
p(yt+1|zt+1), and βt+1 ∝ p(yt+2:T |zt+1) to get p(zt, zt+1, yt, yt+1, yt+2:T |y1:t−1), which we can then
normalize.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.2. BELIEF PROPAGATION ON CHAINS
9.2.3.4 Numerically stable implementation
In most publications on HMMs, such as [Rab89], the forwards message is defined as the following
unnormalized joint probability:
α
′
t
(j) = p(zt = j, y1:t) = λt(j)
"X
i
α
′
t−1
(i)Ai,j#
(9.30)
We instead define the forwards message as the normalized conditional probability
αt(j) = p(zt = j|y1:t) = 1
Zt
λt(j)
"X
i
αt−1(i)Ai,j#
(9.31)
The unnormalized (joint) form has several problems. First, it rapidly suffers from numerical
underflow, since the probability of the joint event that (zt = j, y1:t) is vanishingly small.1 Second,
it is less interpretable, since it is not a distribution over states. Third, it precludes the use of
approximate inference methods that try to approximate posterior distributions (we will see such
methods later). We therefore always use the normalized (conditional) form.
Of course, the two definitions only differ by a multiplicative constant, since p(zt = j|y1:t) =
p(zt = j, y1:t)/p(y1:t) [Dev85]. So the algorithmic difference is just one line of code (namely the
presence or absence of a call to the normalize function). Nevertheless, we feel it is better to present
the normalized version, since it will encourage readers to implement the method properly (i.e.,
normalizing after each step to avoid underflow).
In practice it is more numerically stable to compute the log probabilities ℓt(j) = log p(yt|zt = j)
of the evidence, rather than the probabilities λt(j) = p(yt|zt = j). We can combine the state
conditional log likelihoods λt(j) with the state prior p(zt = j|y1:t−1) by using the log-sum-exp trick,
as in Equation (28.30).
9.2.4 Forwards filtering backwards smoothing
An alternative way to perform offline smoothing is to use forwards filtering/backwards smoothing, as
discussed in Section 8.1.3. In this approach, we first perform the forwards or filtering pass, and then
compute the smoothed belief states by working backwards, from right (time t = T) to left (t = 1).
This approach is widely used for SSMs with continuous latent states, since the backwards likelihood
βt(i) used in Section 9.2.3 is not always well defined when the state space is not discrete.
We assume by induction that we have already computed
γt+1(j) , p(zt+1 = j|y1:T ) (9.32)
1. For example, if the observations are independent of the states, we have p(zt = j, y1:t) = p(zt = j)
Qt
i=1 p(yi),
which becomes exponentially small with t.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license402
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We then compute the smoothed joint distribution over two consecutive time steps:
ξt,t+1(i, j) , p(zt = i, zt+1 = j|y1:T ) = p(zt = i|zt+1 = j, y1:t)p(zt+1 = j|y1:T ) (9.33)
=
p(zt+1 = j|zt = i)p(zt = i|y1:t)p(zt+1 = j|y1:T )
p(zt+1=j |y1:t)
(9.34)
= αt(i)Ai,j
γt+1(j)
αt+1|t(j)
(9.35)
where
αt+1|t(j) = p(zt+1 = j|y1:t) = X
i
′
A(i
′
, j)αt(i
′
) (9.36)
is the one-step-ahead predictive distribution. We can interpret the ratio in Equation (9.35) as dividing
out the old estimate of zt+1 given y1:t, namely αt+1|t
, and multiplying in the new estimate given
y1:T , namely γt+1.
Once we have the two sliced smoothed distribution, we can easily get the marginal one slice
smoothed distribution using
γt(i) = p(zt = i|y1:T ) = X
j
ξt,t+1(i, j) = αt(i)
X
j

Ai,j
γt+1(j)
αt+1|t(j)

(9.37)
We initialize the recursion using γT (j) = αT (j) = p(zT = j|y1:T ).
9.2.5 Time and space complexity
It is clear that a straightforward implementation of the forwards-backwards algorithm takes O(K2T)
time, since we must perform a K × K matrix multiplication at each step. For some applications,
such as speech recognition, K is very large, so the O(K2
) term becomes prohibitive. Fortunately, if
the transition matrix is sparse, we can reduce this substantially. For example, in a sparse left-to-right
transition matrix (e.g., Figure 9.6(a)), the algorithm takes O(TK) time.
In some cases, we can exploit special properties of the state space, even if the transition matrix is
not sparse. In particular, suppose the states represent a discretization of an underlying continuous
state-space, and the transition matrix has the form Ai,j ∝ ρ(zj − zi), where zi
is the continuous
vector represented by state i and ρ(u) is some scalar cost function, such as Euclidean distance. Then
one can implement the forwards-backwards algorithm in O(TK log K) time. The key is to rewrite
Equation (9.5) as a convolution,
αt|t−1(j) = p(zt = j|y1:t−1) = X
i
αt−1(i)Ai,j =
X
i
αt−1(i)ρ(j − i) (9.38)
and then to apply the Fast Fourier Transform. (A similar transformation can be applied in the
backwards pass.) This is very useful for models with large state spaces. See [FHK03] for details.
We can also reduce inference to O(log T) time by using a parallel prefix scan operator that can
be run efficiently on GPUs. For details, see [HSGF21].
In some cases, the bottleneck is memory, not time. In particular, to compute the posteriors γt
, we
must store the fitered distributions αt for t = 1, . . . , T until we do the backwards pass. It is possible
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.2. BELIEF PROPAGATION ON CHAINS









1



   7
67$7(
2%6(59$7,21








Figure 9.5: The trellis of states vs time for a Markov chain. Adapted from [Rab89].
to devise a simple divide-and-conquer algorithm that reduces the space complexity from O(KT) to
O(K log T) at the cost of increasing the running time from O(K2T) to O(K2T log T). The basic
idea is to store αt and βt vectors at a logarithmic number of intermediate checkpoints, and then
recompute the missing messages on demand from these checkpoints. See [BMR97; ZP00] for details.
9.2.6 The Viterbi algorithm
The MAP estimate is (one of) the sequences with maximum posterior probability:
z
∗
1:T = argmax
z1:T
p(z1:T |y1:T ) = argmax
z1:T
log p(z1:T |y1:T ) (9.39)
= argmax
z1:T
log π1(z1) + log λ1(z1) +X
T
t=2
[log A(zt−1, zt) + log λt(zt)] (9.40)
This is equivalent to computing a shortest path through the trellis diagram in Figure 9.5, where
the nodes are possible states at each time step, and the node and edge weights are log probabilities.
This can be computed in O(TK2
) time using the Viterbi algorithm [Vit67], as we explain below.
9.2.6.1 Forwards pass
Recall the (unnormalized) forwards equation
α
′
t
(j) = p(zt = j, y1:t) = X
z1,...,zt−1
p(z1:t−1, zt = j, y1:t) (9.41)
Now suppose we replace sum with max to get
δt(j) , max
z1,...,zt−1
p(z1:t−1, zt = j, y1:t) (9.42)
This is the maximum probability we can assign to the data so far if we end up in state j. The key
insight is that the most probable path to state j at time t must consist of the most probable path to
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license404
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
some other state i at time t − 1, followed by a transition from i to j. Hence
δt(j) = λt(j)
h
max
i
δt−1(i)Ai,j i
(9.43)
We initialize by setting δ1(j) = πjλ1(j).
We often work in the log domain to avoid numerical issues. Let δ
′
t
(j) = − log δt(j), λ
′
t
(j) =
− log p(yt|zt = j), A′
(i, j) = − log p(zt = j|zt−1 = i). Then we have
δ
′
t
(j) = λ
′
t
(j) + h
min
i
δ
′
t−1
(i) + A
′
(i, j)
i
(9.44)
We also need to keep track of the most likely previous (ancestor) state, for each possible state
that we end up in:
at(j) , argmax
i
δt−1(i)Ai,j = argmin
i
δ
′
t−1
(i) + A
′
(i, j) (9.45)
That is, at(j) stores the identity of the previous state on the most probable path to zt = j. We will
see why we need this in Section 9.2.6.2.
9.2.6.2 Backwards pass
In the backwards pass, we compute the most probable sequence of states using a traceback procedure,
as follows: z
∗
t = at+1(z
∗
t+1), where we initialize using z
∗
T = arg maxi δT (i). This is just following the
chain of ancestors along the MAP path.
If there is a unique MAP estimate, the above procedure will give the same result as picking
zˆt = argmaxj γt(j), computed by forwards-backwards, as shown in [WF01b]. However, if there are
multiple posterior modes, the latter approach may not find any of them, since it chooses each state
independently, and hence may break ties in a manner that is inconsistent with its neighbors. The
traceback procedure avoids this problem, since once zt picks its most probable state, the previous
nodes condition on this event, and therefore they will break ties consistently.
9.2.6.3 Example
In Figure 9.3(c), we show the Viterbi trace for the casino HMM. We see that, most of the time, the
estimated state corresponds to the true state.
In Figure 9.6, we give a detailed worked example of the Viterbi algorithm, based on [Rus+95].
Suppose we observe the sequence of discrete observations y1:4 = (C1, C3, C4, C6), representing
codebook entries in a vector-quantized version of a speech signal. The model starts in state z1 = S1.
The probability of generating x1 = C1 in z1 is 0.5, so we have δ1(1) = 0.5, and δ1(i) = 0 for all other
states. Next we can self-transition to S1 with probability 0.3, or transition to S2 with proabability 0.7.
If we end up in S1, the probability of generating x2 = C3 is 0.3; if we end up in S2, the probability
of generating x2 = C3 is 0.2. Hence we have
δ2(1) = δ1(1)A(1, 1)λ2(1) = 0.5 · 0.3 · 0.3 = 0.045 (9.46)
δ2(2) = δ1(1)A(1, 2)λ2(2) = 0.5 · 0.7 · 0.2 = 0.07 (9.47)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.2. BELIEF PROPAGATION ON CHAINS
C1 0.5 0 0
C2 0.2 0 0
C3 0.3 0.2 0
C4 0 0.7 0.1
C5 0 0.1 0
C6 0 0 0.5
C7 0 0 0.4
S1
0.5
S1
0.045
S1
0.0
S1
0.0
S2
0.0
S3
0.0
S3
0.0
S3
0.0007
S2
0.0
S2
0.07
S2
0.0441
S3
0.0022
S1 S2 S3
0.7 0.1
0.3,0.3 0.3,0.0
0.7,0.2 0.7,0.7
0.9,0.7 0.9,0.0
0.1,0.1 0.1,0.5
0.4,0.5
0.3 0.9 0.4
(a) (b)
Figure 9.6: Illustration of Viterbi decoding in a simple HMM for speech recognition. (a) A 3-state HMM
for a single phone. We are visualizing the state transition diagram. We assume the observations have been
vector quantized into 7 possible symbols, C1, . . . , C7. Each state S1, S2, S3 has a different distribution over
these symbols. Adapted from Figure 15.20 of [RN02]. (b) Illustration of the Viterbi algorithm applied to this
model, with data sequence C1, C3, C4, C6. The columns represent time, and the rows represent states. The
numbers inside the circles represent the δt(j) value for that state. An arrow from state i at t − 1 to state
j at t is annotated with two numbers: the first is the probability of the i → j transition, and the second is
the probability of generating observation yt from state j. The red lines/circles represent the most probable
sequence of states. Adapted from Figure 24.27 of [RN95].
Thus state 2 is more probable at t = 2; see the second column of Figure 9.6(b). The algorithm
continues in this way until we have reached the end of the sequence. One we have reached the end,
we can follow the red arrows back to recover the MAP path (which is 1,2,2,3).
For more details on HMMs for automatic speech recognition (ASR) see e.g., [JM08].
9.2.6.4 Time and space complexity
The time complexity of Viterbi is clearly O(K2T) in general, and the space complexity is O(KT),
both the same as forwards-backwards. If the transition matrix has the form Ai,j ∝ ρ(zj − zi), where
zi
is the continuous vector represented by state i and ρ(u) is some scalar cost function, such as
Euclidean distance, we can implement Viterbi in O(TK) time, by using the generalized distance
transform to implement Equation (9.44). See [FHK03; FH12] for details.
9.2.6.5 N-best list
There are often multiple paths which have the same likelihood. The Viterbi algorithm returns one of
them, but can be extended to return the top N paths [SC90; NG01]. This is called the N-best list.
Computing such a list can provide a better summary of the posterior uncertainty.
In addition, we can perform discriminative reranking [CK05] of all the sequences in LN , based
on global features derived from (y1:T , z1:T ). This technique is widely used in speech recognition. For
example, consider the sentence “recognize speech”. It is possible that the most probable interpretation
by the system of this acoustic signal is “wreck a nice speech”, or maybe “wreck a nice beach” (see
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license406
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 34.3). Maybe the correct interpretation is much lower down on the list. However, by using
a re-ranking system, we may be able to improve the score of the correct interpretation based on a
more global context.
One problem with the N-best list is that often the top N paths are very similar to each other,
rather than representing qualitatively different interpretations of the data. Instead we might want to
generate a more diverse set of paths to more accurately represent posterior uncertainty. One way to
do this is to sample paths from the posterior, as we discuss in Section 9.2.7. Another way is to use a
determinantal point process (Supplementary Section 31.8.5) which encourages points to be diverse
[Bat+12; ZA12].
9.2.7 Forwards filtering backwards sampling
Rather than computing the single most probable path, it is often useful to sample multiple paths from
the posterior: z
s
1:T ∼ p(z1:T |y1:T ). We can do this by modifying the forwards filtering backwards
smoothing algorithm from Section 9.2.4, so that we draw samples on the backwards pass, rather than
computing marginals. This is called forwards filtering backwards sampling (also sometimes
unfortunately abbreviated to FFBS). In particular, note that we can write the joint from right to left
using
p(z1:T |y1:T ) = p(zT |y1:T )p(zT −1|zT , y1:T )p(zT −2|zT −1,✟z✟T , y1:T )· · · p(z1|z2,✘z3:✘T , y1:T ) (9.48)
= p(zT |y1:T )
Y
1
t=T −1
p(zt|zt+1, y1:T ) (9.49)
Thus at step t we sample z
s
t
from p(zt|z
s
t+1, y1:T ) given in Equation (9.49).
9.3 Belief propagation on trees
The forwards-backwards algorithm for HMMs discussed in Section 9.2.3 (and the Kalman smoother
algorithm for LDS which we discuss in Section 8.2.3) can be interpreted as a message passing algorithm
applied to a chain structured graphical model. In this section, we generalize these algorithms to work
with trees.
9.3.1 Directed vs undirected trees
Consider a pairwise undirected graphical model, which can be written as follows:
p
∗
(z) , p(z|y) ∝
Y
s∈V
ψs(zs|ys)
Y
(s,t)∈E
ψs,t(zs, zt) (9.50)
where ψs,t(zs, zt) are the pairwise clique potential, one per edge, ψs(zs|ys) are the local evidence
potentials, one per node, V is the set of nodes, and E is the set of edges. (We will henceforth drop
the conditioning on the observed values y for brevity.)
Now suppose the corresponding graph structure is a tree, such as the one in Figure 9.7a. We can
always convert this into a directed tree by picking an arbitrary node as the root, and then “picking
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.3. BELIEF PROPAGATION ON TREES
4 3
1 2
(a)
4 3
1 2
(b)
4 3
1 2
(c)
Figure 9.7: An undirected tree and two equivalent directed trees.
the tree up by the root” and orienting all the edges away from the root. For example, if we pick node
1 as the root we get Figure 9.7b. This corresponds to the following directed graphical model:
p
∗
(z) ∝ p
∗
(z1)p
∗
(z2|z1)p
∗
(z3|z2)p
∗
(z4|z2) (9.51)
However, if we pick node 2 as the root, we get Figure 9.7c. This corresponds to the following directed
graphical model:
p
∗
(z) ∝ p
∗
(z2)p
∗
(z1|z2)p
∗
(z3|z2)p
∗
(z4|z2) (9.52)
Since these graphs express the same conditional independence properties, they represent the same
family of probability distributions, and hence we are free to use any of these parameterizations.
To make the model more symmetric, it is preferable to use an undirected tree. If we define the
potentials as (possibly unnnormalized) marginals (i.e., ψs(zs) ∝ p
∗
(zs) and ψs,t(zs, zt) = p
∗
(zs, zt)),
then we can write
p
∗
(z) ∝
Y
s∈V
p
∗
(zs)
Y
(s,t)∈E
p
∗
(zs, zt)
p
∗(zs)p
∗(zt)
(9.53)
For example, for Figure 9.7a we have
p
∗
(z1, z2, z3, z4) ∝ p
∗
(z1)p
∗
(z2)p
∗
(z3)p
∗
(z4)
p
∗
(z1, z2)p
∗
(z2, z3)p
∗
(z2, z4)
p
∗(z1)p
∗(z2)p
∗(z2)p
∗(z3)p
∗(z2)p
∗(z4)
(9.54)
To see the equivalence with the directed representation, we can cancel terms to get
p
∗
(z1, z2, z3, z4) ∝ p
∗
(z1, z2)
p
∗
(z2, z3)
p
∗(z2)
p
∗
(z2, z4)
p
∗(z2)
(9.55)
= p
∗
(z1)p
∗
(z2|z1)p
∗
(z3|z2)p
∗
(z4|z2) (9.56)
= p
∗
(z2)p
∗
(z1|z2)p
∗
(z3|z2)p
∗
(z4|z2) (9.57)
where p
∗
(zt|zs) = p
∗
(zs, zt)/p∗
(zs).
Thus a tree can be represented as either an undirected or directed graph. Both representations
can be useful, as we will see.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license408
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
// Collect to root
for each node s in post-order
bels(zs) ∝ ψs(zs)
Q
t∈chs mt→s(zs)
t = parent(s)
ms→t(zt) = P
zs
ψst(zs, zt)bels(zs)
// Distribute from root
for each node t in pre-order
s = parent(t)
ms→t(zt) = P
zs
ψst(zs, zt)
bels(zs)
mt→s(zs)
belt(zt) ∝ belt(zt)ms→t(zt)
Figure 9.8: Belief propagation on a pairwise, rooted tree.
Figure 9.9: Illustration of how the top-down message from s to t is computed during BP on a tree. The ui
nodes are the other children of s, besides t. Square nodes represent clique potentials.
9.3.2 Sum-product algorithm
In this section, we assume that our model is an undirected tree, as in Equation (9.50). However,
we will pick an arbitrary node as a root, and orient all the edges downwards away from this root,
so that each node has a unique parent. For a directed, rooted tree, we can compute various node
orderings. In particular, in a pre-order, we traverse from the root to the left subtree and then to
right subtree, top to bottom. In a post-order, we traverse from the left subtree to the right subtree
and then to the root, bottom to top. We will use both of these below.
We now present the sum-product algorithm for trees. We first send messages from the leaves
to the root. This is the generalization of the forwards pass from Section 9.2.2. Let ms→t(zt) denote
the message from node s to node t. This summarizes the belief state about zt given all the evidence
in the tree below the s − t edge. Consider a node s in the ordering. We update its belief state by
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.3. BELIEF PROPAGATION ON TREES
combining the incoming messages from all its children with its own local evidence:
bels(zs) ∝ ψs(zs)
Y
t∈chs
mt→s(zs) (9.58)
To compute the outgoing message that s should send to its parent t, we pass the local belief through
the pairwise potential linking s and t, and then marginalize out s to get
ms→t(zt) = X
zs
ψst(zs, zt)bels(zs) (9.59)
At the root of the tree, belt(zt) = p(zt|y) will have seen all the evidence. It can then send messages
back down to the leaves. The message that s sends to its child t should be the product of all the
messages that s received from all its other children u, passed through the pairwise potential, and
then marginalized:
ms→t(zt) = X
zt

ψs(zs)ψst(zs, zt)
Y
u∈chs\t
mu→s(zs)

 (9.60)
See Figure 9.9. Instead of multiplying all-but-one of the messages that s has received, we can multiply
all of them and then divide out by the t → s message from child t. The advantage of this is that
the product of all the messages has already been computed in Equation (9.58), so we don’t need to
recompute that term. Thus we get
ms→t(zt) = X
zs
ψst(zs, zt)
bels(zs)
mt→s(zs)
(9.61)
We can think of bels(zs) as the new updated posterior p(zs|y) given all the evidence, and mt→s(zs)
as the prior predictive p(zs|y
−
t
), where y
−
t
is all the evidence in the subtree rooted at t. Thus the
ratio contains the new evidence that t did not already know about from its own subtree. We use this
to update the belief state at node t to get:
belt(zt) ∝ belt(zt)ms→t(zt) (9.62)
(Note that Equation (9.58) is a special case of this where we don’t divide out by ms→t, since in the
upwards pass, there is no incoming message from the parent.) This is analogous to the backwards
smoothing equation in Equation (9.37), with αt(i) replaced by belt(zt = i), A(i, j) replaced by
ψst(zs = i, zt = j), γt+1(j) replaced by bels(zs = j), and αt+1|t(j) replaced by mt→s(zs = j).
See Figure 9.8 for the overall pseudocode. This can be generalized to directed trees with multiple
root nodes (known as polytrees) as described in Supplementary Section 9.1.1.
9.3.3 Max-product algorithm
In Section 9.3.2 we described the sum-product algorithm, that computes the posterior marginals:
beli(k) = γi(k) = p(zi = k|y) = X
z−i
p(zi = k, z−i
|y) (9.63)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license410
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We can replace the sum operation with the max operation to get max-product belief propagation.
The result of this computation are a set of max marginals for each node:
ζi(k) = max
z−i
p(zi = k, z−i
|y) (9.64)
We can derive two different kinds of “MAP” estimates from these local quantities. The first is
zˆi = argmaxk γi(k); this is known as the maximizer of the posterior marginal or MPM estimate
(see e.g., [MMP87; SM12]); let zˆ = [zˆ1, . . . , zˆNz
] be the sequence of such estimates. The second is
z˜i = argmaxk
ζi(k); we call this the maximizer of the max marginal or MMM estimate; let
z˜ = [˜z1, . . . , z˜Nz
].
An interesting question is: what, if anything, do these estimates have to do with the “true” MAP
estimate, z
∗ = argmaxz p(z|y)? We discuss this below.
9.3.3.1 Connection between MMM and MAP
In [YW04], they showed that, if the max marginals are unique and computed exactly (e.g., if the
graph is a tree), then z˜ = z
∗
. This means we can recover the global MAP estimate by running max
product BP and then setting each node to its local max (i.e., using the MMM estimate).
However, if there are ties in the max marginals (corresponding to the case where there is more
than one globally optimal solution), this “local stitching” process may result in global inconsistencies.
If we have a tree-structured model, we can use a traceback procedure, analogous to the Viterbi
algorithm (Section 9.2.6), in which we clamp nodes to their optimal values while working backwards
from the root. For details, see e.g., [KF09a, p569].
Unfortunately, traceback does not work on general graphs. An alternative, iterative approach,
proposed in [YW04], is follows. First we run max product BP, and clamp all nodes which have unique
max marginals to their optimal values; we then clamp a single ambiguous node to an optimal value,
and condition on all these clamped values as extra evidence, and perform more rounds of message
passing, until all ties are broken. This may require many rounds of inference, although the number
of non-clamped (hidden) variables gets reduced at each round.
9.3.3.2 Connection between MPM and MAP
In this section, we discuss the MPM estimate, zˆ, which computes the maximum of the posterior
marginals. In general, this does not correspond to the MAP estimate, even if the posterior marginals
are exact. To see why, note that MPM just looks at the belief state for each node given all the visible
evidence, but ignores any dependencies or constraints that might exist in the prior.
To illustrate why this could be a problem, consider the error correcting code example from
Section 5.5, where we defined p(z, y) = p(z1)p(z2)p(z3|z1, z2)
Q3
i=1 p(yi
|zi), where all variables are
binary. The priors p(z1) and p(z2) are uniform. The conditional term p(z3|z1, z2) is deterministic,
and computes the parity of (z1, z2). In particular, we have p(z3 = 1|z1, z2) = I(odd(z1, z2)), so that
the total number of 1s in the block z1:3 is even. The likelihood terms p(yi
|zi) represent a bit flipping
noisy channel model, with noise level α = 0.2.
Suppose we observe y = (1, 0, 0). In this case, the exact posterior marginals are as follows:2 γ1 =
[0.3469, 0.6531], γ2 = [0.6531, 0.3469], γ3 = [0.6531, 0.3469]. The exact max marginals are all the same,
2. See error_correcting_code_demo.ipynb for the code.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.4. LOOPY BELIEF PROPAGATION
namely ζi = [0.3265, 0.3265]. Finally, the 3 global MAP estimates are z
∗ ∈ {[0, 0, 0], [1, 1, 0], [1, 0, 1]},
each of which corresponds to a single bit flip from the observed vector. The MAP estimates are all
valid code words (they have an even number of 1s), and hence are sensible hypotheses about the
value of z. By contrast, the MPM estimate is zˆ = [1, 0, 0], which is not a legal codeword. (And in
this example, the MMM estimate is not well defined, since the max marginals are not unique.)
So, which method is better? This depends on our loss function, as we discuss in Section 34.1. If
we want to minimize the prediction error of each zi
, also called bit error, we should compute the
MPM. If we want to minimize the prediction error for the entire sequence z, also called word error,
we should use MAP, since this can take global constraints into account.
For example, suppose we are performing speech recognition and someones says “recognize speech”.
MPM decoding may return “wreck a nice beach”, since locally it may be that “beach” is the most
probable interpretation of “speech” when viewed in isolation (see Figure 34.3). However, MAP
decoding would infer that “recognize speech” is the more likely overall interpretation, by taking into
account the language model prior, p(z).
On the other hand, if we don’t have strong constraints, the MPM estimate can be more robust
[MMP87; SM12], since it marginalizes out the other nodes, rather than maxing them out. For
example, in the casino HMM example in Figure 9.3, we see that the MPM method makes 49 bit
errors (out of a total possible of T = 300), and the MAP path makes 60 errors.
9.3.3.3 Connection between MPE and MAP
In the graphical models literature, computing the jointly most likely setting of all the latent variables,
z
∗ = argmaxz p(z|y), is known as the most probable explanation or MPE [Pea88]. In that
literature, the term “MAP” is used to refer to the case where we maximize some of the hidden
variables, and marginalize (sum out) the rest. For example, if we maximize a single node, zi
, but
sum out all the others, z−i
, we get the MPM zˆi = argmaxzi
P
z−i
p(z|y).
We can generalize the MPM estimate to compute the best guess for a set of query variables Q,
given evidence on a set of visible variables V , marginalizing out the remaining variables R, to get
z
∗
Q = arg max
zQ
X
zR
p(zQ, zR|zV ) (9.65)
(Here zR are called nuisance variables, since they are not of interest, and are not observed.) In
[Pea88], this is called a MAP estimate, but we will call it an MPM estimate, to avoid confusion with
the ML usage of the term “MAP” (where we maximize everything jointly).
9.4 Loopy belief propagation
In this section, we extend belief propagation to work on graphs with cycles or loops; this is called
loopy belief propagation or LBP. Unfortunately, this method may not converge, and even if it
does, it is not clear if the resulting estimates are valid. Indeed, Judea Pearl, who invented belief
propagation for trees, wrote the following about loopy BP in 1988:
When loops are present, the network is no longer singly connected and local propagation
schemes will invariably run into trouble . . . If we ignore the existence of loops and permit the
nodes to continue communicating with each other as if the network were singly connected,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license412
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
messages may circulate indefinitely around the loops and the process may not converge to a
stable equilibrium . . . Such oscillations do not normally occur in probabilistic networks . . .
which tend to bring all messages to some stable equilibrium as time goes on. However, this
asymptotic equilibrium is not coherent, in the sense that it does not represent the posterior
probabilities of all nodes of the network. — [Pea88, p.195]
Despite these reservations, Pearl advocated the use of belief propagation in loopy networks as an
approximation scheme (J. Pearl, personal communication). [MWJ99] found empirically that it works
on various graphical models, and it is now used in many real world applications, some of which we
discuss below. In addition, there is now some theory justifying its use in certain cases, as we discuss
below. (For more details, see e.g., [Yed11].)
9.4.1 Loopy BP for pairwise undirected graphs
In this section, we assume (for notational simplicity) that our model is an undirected pairwise PGM,
as in Equation (9.50). However, unlike Section 9.3.2, we do not assume the graph is a tree. We
can apply the same message passing equations as before. However, since there is no natural node
ordering, we will do this in a parallel, asynchronous way. The basic idea is that all nodes receive
messages from their neighbors in parallel, they then update their belief states, and finally they send
new messages back out to their neighbors. This message passing process repeats until convergence.
This kind of computing architecture is called a systolic array, due to its resemblance to a beating
heart.
More precisely, we initialize all messages to the all 1’s vector. Then, in parallel, each node absorbs
messages from all its neighbors using
bels(zs) ∝ ψs(zs)
Y
t∈nbrs
mt→s(zs) (9.66)
Then, in parallel, each node sends messages to each of its neighbors:
ms→t(zt) = X
zs

ψs(zs)ψst(zs, zt)
Y
u∈nbrs\t
mu→s(zs)

 (9.67)
The ms→t message is computed by multiplying together all incoming messages, except the one sent by
the recipient, and then passing through the ψst potential. We continue this process until convergence.
If the graph is a tree, the method is guaranteed to converge after D(G) iterations, where D(G) is the
diameter of the graph, that is, the largest distance between any two nodes.
9.4.2 Loopy BP for factor graphs
To implement loopy BP for general graphs, including those with higher-order clique potentials
(beyond pairwise), it is useful to use a factor graph representation described in Section 4.6.1. In
this section, we summarize the BP equations for the bipartite version of factor graphs, as derived in
[KFL01].3 For a version that works for Forney factor graphs, see [Loe+07].
3. For an efficient JAX implementation of these equations for discrete factor graphs, see https://github.com/
vicariousinc/PGMax. For the Gaussian case, see https://github.com/probml/pgm-jax.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.4. LOOPY BELIEF PROPAGATION
Fig. 6. A factor-graph fragment, showing the update rules of the sum-product
Figure 9.10: Message passing on a bipartite factor graph. Square nodes represent factors, and circles represent
variables. The yi nodes correspond to the neighbors x
′
i of f other than x. From Figure 6 of [KFL01]. Used
with kind permission of Brendan Frey.
In the case of bipartite factor graphs, we have two kinds of messages: variables to factors
mx→f (x) = Y
h∈nbr(x)\{f}
mh→x(x) (9.68)
and factors to variables
mf→x(x) = X
x′
f(x, x
′
)
Y
x′∈nbr(f)\{x}
mx′→f (x
′
) (9.69)
Here nbr(x) are all the factors that are connected to variable x, and nbr(f) are all the variables that
are connected to factor f. These messages are illustrated in Figure 9.10. At convergence, we can
compute the final beliefs as a product of incoming messages:
bel(x) ∝
Y
f∈nbr(x)
mf→x(x) (9.70)
The order in which the messages are sent can be determined using various heuristics, such as
computing a spanning tree, and picking an arbitrary node as root. Alternatively, the update
ordering can be chosen adaptively using residual belief propagation [EMK06]. Or fully parallel,
asynchronous implementations can be used.
9.4.3 Gaussian belief propagation
It is possible to genereralize (loopy) belief propagation to the Gaussian case, by using the “calculus for
linear Gaussian models” in Section 2.3.3 to compute the messages and beliefs. Note that computing
the posterior mean in a linear-Gaussian system is equivalent to solving a linear system, so these
methods are also useful for linear algebra. See e.g., [PL03; Bic09; Du+18] for details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license414
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 2 4 6 8
1.0
0.5
0.0
0.5
1.0
Measurements
(a)
0 2 4 6 8 10
1.0
0.5
0.0
0.5
1.0
Measurements
Beliefs
(b)
Figure 9.11: Interpolating noisy data using Gaussian belief propagation applied to a 1d MRF. Generated by
gauss-bp-1d-line.ipynb.
As an example of Gaussian BP, consider the problem of interpolating noisy data in 1d, as discussed
in [OED21]. In particular, let f : R → R be an unknown function for which we get N noisy
measurements yi at locations xi
. We want to estimate zi = f(gi) at G grid locations gi
. Let xi be
the closest location to gi
. Then we assume the measurement factor is as follows:
ψi(zi−1, zi) = 1
σ
2
(ˆyi − yi)
2
(9.71)
yˆi = (1 − γi)zi−1 + γizi (9.72)
γi =
xi − gi
gi − gi−1
(9.73)
Here yˆi
is the predicted measurement. The potential function makes the unknown function values
zi−1 and zi move closer to the observation, based on how far these grid points are from where the
measurement was taken. In addition, we add a pairwise smoothness potential, that encodes the prior
that zi should be close to zi−1 and zi+1:
φi(zi−1, zi) = 1
τ
2
δ
2
i
(9.74)
δi = zi − zi−1 (9.75)
The overall model is
p(z|x, y, g, σ2
, τ 2
) ∝
Y
G
i=1
ψi(zi−1, zi)φi(zi−1, zi) (9.76)
Suppose the true underlying function is a sine wave. We show some sample data in Figure 9.11(a).
We then apply Gaussian BP. Since this model is a chain, and the model is linear-Gaussian, the
resulting posterior marginals, shown in Figure 9.11(b), are exact. We see that the method has inferred
the underlying sine shape just based on a smoothness prior.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.4. LOOPY BELIEF PROPAGATION
Figure 9.12: (a) A simple loopy graph. (b) The computation tree, rooted at node 1, after 4 rounds of message
passing. Nodes 2 and 3 occur more often in the tree because they have higher degree than nodes 1 and 2.
From Figure 8.2 of [WJ08]. Used with kind permission of Martin Wainwright.
To perform message passing in models with non-linear (but Gaussian) potentials, we can generalize
the extended Kalman filter techniques from Section 8.3.2 and the moment matching techniques
(based on quadrature/sigma points) from Section 8.5.1 and Section 8.5.1.1 from chains to general
factor graphs (see e.g., [MHH14; PHR18; HPR19]). To extend to the non-Gaussian case, we can
use non-parametric BP or particle BP (see e.g., [Sud+03; Isa03; Sud+10; Pac+14]), which uses
ideas from particle filtering (Section 13.2).
9.4.4 Convergence
Loopy BP may not converge, or may only converge slowly. In this section, we discuss some techniques
that increase the chances of convergence, and the speed of convergence.
9.4.4.1 When will LBP converge?
The details of the analysis of when LBP will converge are beyond the scope of this chapter, but we
briefly sketch the basic idea. The key analysis tool is the computation tree, which visualizes the
messages that are passed as the algorithm proceeds. Figure 9.12 gives a simple example. In the
first iteration, node 1 receives messages from nodes 2 and 3. In the second iteration, it receives one
message from node 3 (via node 2), one from node 2 (via node 3), and two messages from node 4 (via
nodes 2 and 3). And so on.
The key insight is that T iterations of LBP is equivalent to exact computation in a computation
tree of height T + 1. If the strengths of the connections on the edges is sufficiently weak, then the
influence of the leaves on the root will diminish over time, and convergence will occur. See [MK05;
WJ08] and references therein for more information.
9.4.4.2 Making LBP converge
Although the theoretical convergence analysis is very interesting, in practice, when faced with a
model where LBP is not converging, what should we do?
One simple way to increase the chance of convergence is to use damping. That is, at iteration k,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license416
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Synchronous Asynchronous No smoothing True
0
1.0
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
10 20 30 40 50 60 70 80 90 100
Time (seconds)
% of messages converged
1.0
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
Time (seconds)
P(X10 = 0)
1.0
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
0 0.1 0.2 0.3 0.4 0.5
Time (seconds)
P(X115 = 0)
1.0
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
Time (seconds)
P(X61 = 0)
1.0
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
Time (seconds)
P(X17 = 0)
1.0
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
Time (seconds)
P(X7 = 0)
0 0.1 0.2 0.3 0.4 0.5
0 0.1 0.2 0.3 0.4 0.5 0 0.1 0.2 0.3 0.4 0.5 0 0.1 0.2 0.3 0.4 0.5
(a)
(d)
(b)
(e)
(c)
(f)
Figure 9.13: Illustration of the behavior of loopy belief propagation on an 11 × 11 Ising grid with random
potentials, wij ∼ Unif(−C, C), where C = 11. For larger C, inference becomes harder. (a) Percentage of
messages that have converged vs time for 3 different update schedules: Dotted = damped synchronous (few
nodes converge), dashed = undamped asychnronous (half the nodes converge), solid = damped asychnronous
(all nodes converge). (b-f) Marginal beliefs of certain nodes vs time. Solid straight line = truth, dashed =
sychronous, solid = damped asychronous. From Figure 11.C.1 of [KF09a]. Used with kind permission of
Daphne Koller.
we use an update of the form
mk
t→s
(xs) = λmt→s(xs) + (1 − λ)mk−1
t→s
(xs) (9.77)
where mt→s(xs) is the standard undamped message, where 0 ≤ λ ≤ 1 is the damping factor. Clearly
if λ = 1 this reduces to the standard scheme, but for λ < 1, this partial updating scheme can help
improve convergence. Using a value such as λ ∼ 0.5 is standard practice. The benefits of this
approach are shown in Figure 9.13, where we see that damped updating results in convergence much
more often than undamped updating (see [ZLG20] for some analysis of the benefits of damping).
It is possible to devise methods, known as double loop algorithms, which are guaranteed
to converge to a local minimum of the same objective that LBP is minimizing [Yui01; WT01].
Unfortunately, these methods are rather slow and complicated, and the accuracy of the resulting
marginals is usually not much greater than with standard LBP. (Indeed, oscillating marginals is
sometimes a sign that the LBP approximation itself is a poor one.) Consequently, these techniques
are not very widely used (although see [GF21] for a newer technique).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.4. LOOPY BELIEF PROPAGATION
9.4.4.3 Increasing the convergence rate with adaptive scheduling
The standard approach when implementing LBP is to perform synchronous updates, where all
nodes absorb messages in parallel, and then send out messages in parallel. That is, the new messages
at iteration k + 1 are computed in parallel using
mk+1
1:E = (f1(mk
), . . . , fE(mk
)) (9.78)
where E is the number of edges, and fi(m) is the function that computes the message for edge i
given all the old messages. This is analogous to the Jacobi method for solving linear systems of
equations.
It is well known [Ber97b] that the Gauss-Seidel method, which performs asynchronous updates
in a fixed round-robin fashion, converges faster when solving linear systems of equations. We can
apply the same idea to LBP, using updates of the form
mk+1
i = fi
￾
{mk+1
j
: j < i}, {mk
j
: j > i}

(9.79)
where the message for edge i is computed using new messages (iteration k + 1) from edges earlier in
the ordering, and using old messages (iteration k) from edges later in the ordering.
This raises the question of what order to update the messages in. One simple idea is to use a fixed
or random order. The benefits of this approach are shown in Figure 9.13, where we see that (damped)
asynchronous updating results in convergence much more often than synchronous updating.
However, we can do even better by using an adaptive ordering. The intuition is that we should
focus our computational efforts on those variables that are most uncertain. [EMK06] proposed
a technique known as residual belief propagation, in which messages are scheduled to be sent
according to the norm of the difference from their previous value. That is, we define the residual of
new message ms→t at iteration k to be
r(s, t, k) = || log ms→t − log mk
s→t
||∞ = max
j
| log ms→t(j)
mk
s→t
(j)
| (9.80)
We can store messages in a priority queue, and always send the one with highest residual. When a
message is sent from s to t, all of the other messages that depend on ms→t (i.e., messages of the form
mt→u where u ∈ nbr(t) \ s) need to be recomputed; their residual is recomputed, and they are added
back to the queue. In [EMK06], they showed (experimentally) that this method converges more often,
and much faster, than using sychronous updating, or asynchronous updating with a fixed order.
A refinement of residual BP was presented in [SM07]. In this paper, they use an upper bound on
the residual of a message instead of the actual residual. This means that messages are only computed
if they are going to be sent; they are not just computed for the purposes of evaluating the residual.
This was observed to be about five times faster than residual BP, although the quality of the final
results are similar.
9.4.5 Accuracy
For a graph with a single loop, one can show that the max-product version of LBP will find the
correct MAP estimate, if it converges [Wei00]. For more general graphs, one can bound the error in
the approximate marginals computed by LBP, as shown in [WJW03; IFW05; Vin+10b].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens418
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
1 2
7 8
4
3
9
5 6
1245
2 5
2356
5
4 78 5
5 8
5689
4 5 5 6
Figure 9.14: (a) Clusters superimposed on a 3 × 3 lattice graph. (b) Corresponding hyper-graph. Nodes
represent clusters, and edges represent set containment. From Figure 4.5 of [WJ08]. Used with kind permission
of Martin Wainwright.
Much stronger results are available in the case of Gaussian models. In particular, it can be shown
that, if the method converges, the means are exact, although the variances are not (typically the
beliefs are over confident). See e.g., [WF01a; JMW06; Bic09; Du+18] for details.
9.4.6 Generalized belief propagation
We can improve the accuracy of loopy BP by clustering together nodes that form a tight loop. This
is known as the cluster variational method, or generalized belief propagation [YFW00].
The result of clustering is a hyper-graph, which is a graph where there are hyper-edges between
sets of vertices instead of between single vertices. Note that a junction tree (Section 9.6) is a kind of
hyper-graph. We can represent a hyper-graph using a poset (partially ordered set) diagram, where
each node represents a hyper-edge, and there is an arrow e1 → e2 if e2 ⊂ e1. See Figure 9.14 for an
example.
If we allow the size of the largest hyper-edge in the hyper-graph to be as large as the treewidth
of the graph, then we can represent the hyper-graph as a tree, and the method will be exact, just
as LBP is exact on regular trees (with treewidth 1). In this way, we can define a continuum of
approximations, from LBP all the way to exact inference. See Supplementary Section 10.4.3.3 for
more information.
9.4.7 Convex BP
In Supplementary Section 10.4.3 we analyze LBP from a variational perspective, and show that the
resulting optimization problem, for both standard and generalized BP, is non-convex. However it is
possible to create a version of convex BP, as we explain in Supplementary Section 10.4.4, which
has the advantage that it will always converge.
9.4.8 Application: error correcting codes
LBP was first proposed by Judea Pearl in his 1988 book [Pea88]. He recognized that applying BP to
loopy graphs might not work, but recommended it as a heuristic.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.4. LOOPY BELIEF PROPAGATION
Figure 9.15: (a) A simple factor graph representation of a (2,3) low-density parity check code. Each message
bit (hollow round circle) is connected to two parity factors (solid black squares), and each parity factor is
connected to three bits. Each parity factor has the form ψstu(xs, xt, xu) = I(xs ⊗ xt ⊗ xu = 1), where ⊗ is
the xor operator. The local evidence factors for each hidden node are not shown. (b) A larger example of a
random LDPC code. We see that this graph is “locally tree-like”, meaning there are no short cycles; rather,
each cycle has length ∼ log m, where m is the number of nodes. This gives us a hint as to why loopy BP
works so well on such graphs. (Note, however, that some error correcting code graphs have short loops, so this
is not the full explanation.) From Figure 2.9 from [WJ08]. Used with kind permission of Martin Wainwright.
However, the main impetus behind the interest in LBP arose when McEliece, MacKay, and Cheng
[MMC98] showed that a popular algorithm for error correcting codes, known as turbocodes [BGT93],
could be viewed as an instance of LBP applied to a certain kind of graph.
We introduced error correcting codes in Section 5.5. Recall that the basic idea is to send the
source message x ∈ {0, 1}
m over a noisy channel, and for the receiver to try to infer it given noisy
measurements y ∈ {0, 1}
m or y ∈ R
m. That is, the receiver needs to compute x
∗ = argmaxx p(x|y) =
argmaxx p˜(x).
It is standard to represent p˜(x) as a factor graph (Section 4.6.1), which can easily represent any
deterministic relationships (parity constraints) between the bits. A factor graph is a bipartite graph
with xi nodes on one side, and factors on the other. A graph in which each node is connected to n
factors, and in which each factor is connected to k nodes, is called an (n, k) code. Figure 9.15(a)
shows a simple example of a (2, 3) code, where each bit (hollow round circle) is connected to two
parity factors (solid black squares), and each parity factor is connected to three bits. Each parity
factor has the form
ψstu(xs, xt, xu) ,

1 if xs ⊗ xt ⊗ xu = 1
0 otherwise (9.81)
If the degrees of the parity checks and variable nodes remain bounded as the blocklength m increases,
this is called a low-density parity check code, or LDPC code. (Turbocodes are constructed in
a similar way.)
Figure 9.15(b) shows an example of a randomly constructed LDPC code. This graph is “locally
tree-like”, meaning there are no short cycles; rather, each cycle has length ∼ log m. This fact is
important to the success of LBP, which is only guaranteed to work on tree-structured graphs. Using
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license420
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
c1 c2
1 2
s(1, ) s(2, )
A
cN
c3
2 3 N
s(3, ) s(N, )
…
k
…
s(i, )
… …
ci
Figure 9.16: Factor graphs for affinity propagation. Circles are variables, squares are factors. Each ci node
has N possible states. From Figure S2 of [FD07a]. Used with kind permission of Brendan Frey.
methods such as these, people have been able to approach the lower bound in Shannon’s channel
coding theorem, meaning they have produced codes with very little redundancy for a given amount
of noise in the channel. See e.g., [MMC98; Mac03] for more details. Such codes are widely used, e.g.,
in modern cellphones.
9.4.9 Application: affinity propagation
In this section, we discuss affinity propagation [FD07a], which can be seen as an improvement
to K-medoids clustering, which takes as input a pairwise similarity matrix. The idea is that each
datapoint must choose another datapoint as its exemplar or centroid; some datapoints will choose
themselves as centroids, and this will automatically determine the number of clusters. More precisely,
let ci ∈ {1, . . . , N} represent the centroid for datapoint i. The goal is to maximize the following
function
J(c) = X
N
i=1
S(i, ci) +X
N
k=1
δk(c) (9.82)
where S(i, ci) is the similarity between datapoint i and its centroid ci
. The second term is a penalty
term that is −∞ if some datapoint i has chosen k as its exemplar (i.e., ci = k), but k has not chosen
itself as an exemplar (i.e., we do not have ck = k). More formally,
δk(c) = 
−∞ if ck 6= k but ∃i : ci = k
0 otherwise (9.83)
This encourages “representative” samples to vote for themselves as centroids, thus encouraging
clustering behavior.
The objective function can be represented as a factor graph. We can either use N nodes, each
with N possible values, as shown in Figure 9.16, or we can use N2 binary nodes (see [GF09] for the
details). We will assume the former representation.
We can find a strong local maximum of the objective by using max-product loopy belief propagation
(Section 9.4). Referring to the model in Figure 9.16, each variable node ci sends a message to each
factor node δk. It turns out that this vector of N numbers can be reduced to a scalar message,
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.4. LOOPY BELIEF PROPAGATION
A
-5 0 +5
-5
0
+5
c ccc
ccc
c
cc
cc
c
cc cc
cc
ccc
c
c
cc
cc c
cccc
cc
cc
cc
ccc
c
cccc
cc c c
c
c c
cc
c
cc
c
c
c
c c
c
c
c
c
cc
cc
cc cc
ccc
cccc
c
c
cc
cc
c cccc
c
c
c
c cc
cc
cc
c
cc
ccc c
c
c
c
cc
-5 0 +5
-5
0
+5
c ccc
c
cccc
ccc
cc
cc
c
c c c
cc
cc
ccccc
ccc
c
cc
cc
cccc
c
cccc
cc
ccc c
cc
cc
cc
ccccc
cccc
c cc c c
cc
c cc
cc
cc
cc
c
c
ccc c c
c
c
cc
c
ccc
c cc
cc cc
cccccc
cccccc
cc
c
c
c
c
cc
cccccc
c
cccc
c ccc
cc
ccccc
c
c
cc
cccc
c
cc
c
cc
-5 0 +5
-5
0
+5
c ccc
ccc
ccc
c
cc
c
cc cc
ccc
ccc
c
cc
cc
ccc
c
cccc
cc
cc c
c
cc
cc
ccc
c
cccc
c cc c c
c
c cc
cc
cc
cc
c
c
c
c c
c
c
c
c
c
c cc
cc cc
ccccc
c
cccc
c
c
c
c
c
cc
c
ccc
c
cccc
c ccc
c
ccc
c
c
cc
cccc
c
c
c
cc
-5 0 +5
-5
0
+5
c cc
cccc
c
cc
c
ccc
c
ccccc
c
ccc
c
ccc
cc
c
c
cc
cc
ccc
c
c
cc
c ccc
c cc
cc
cc
c
c
cc c
c
c c
c c
cc
cccc
c
cccc
c
cc
cc
c
cc
c
cccc
ccc
c
cc
c
c
ccc c
c
c cc
-5 0 +5
-5
0
+5
c cc
cc
c
cc
c
ccc
cc
ccc
c
ccc
c
cc
c
c
cc
cc
cccc
c
cc
cc
c cc
cc
cc
c
c
cc c
c
c c
c c
cc
cc cc
cc
c
cc
c
c
cc
c
c
ccc
c
c cc
-5 0 +5
-5
0
+5
c cc
cc
c
c
c
ccc
cc
c
c
c
c
cc
cc
cccc
c
c
c
cc
ccc
cc
c
c
c
c
c
c
c
c
c
cc
c
cc
c
c
c
cc
ccc
-5 0 +5
-5
0
+5
c cc
cc
c
c
c
ccc
cc
c
c
c
c
c
cccc
c
c
c
cc
cc
cc
c
c
c
c
c
c
c
c
c c
c
c
c
c
c
-5 0 +5
-5
0
+5
c
c
c
c
c
c
c
c
c c c
c
c
c
c
c
c
c
c
c
c
c
c c
c
INITIALIZATION
ITERATION #4 ITERATION #5 ITERATION #6
ITERATION #1 ITERATION #2 ITERATION #3
CONVERGENCE
non-exemplar exemplar
Figure 9.17: Example of affinity propagation. Each point is colored coded by how much it wants to be
an exemplar (red is the most, green is the least). This can be computed by summing up all the incoming
availability messages and the self-similarity term. The darkness of the i → k arrow reflects how much point i
wants to belong to exemplar k. From Figure 1 of [FD07a]. Used with kind permission of Brendan Frey.
denoted ri→k, known as the responsibility. This is a measure of how much i thinks k would make a
good exemplar, compared to all the other exemplars i has looked at. In addition, each factor node
δk sends a message to each variable node ci
. Again this can be reduced to a scalar message, ai←k,
known as the availability. This is a measure of how strongly k believes it should an exemplar for i,
based on all the other datapoints k has looked at.
As usual with loopy BP, the method might oscillate, and convergence is not guaranteed. However,
by using damping, the method is very reliable in practice. If the graph is densely connected, message
passing takes O(N2
) time, but with sparse similarity matrices, it only takes O(E) time, where E is
the number of edges or non-zero entries in S.
The number of clusters can be controlled by scaling the diagonal terms S(i, i), which reflect how
much each datapoint wants to be an exemplar. Figure 9.17 gives a simple example of some 2d data,
where the negative Euclidean distance was used to measured similarity. The S(i, i) values were set
to be the median of all the pairwise similarities. The result is 3 clusters. Many other results are
reported in [FD07a], who show that the method significantly outperforms K-medoids.
9.4.10 Emulating BP with graph neural nets
There is a close connection between message passing in PGMs and message passing in graph neural
networks (GNNs), which we discuss in Section 16.3.6. However, for PGMs, the message computations
are computing using (non-learned) update equations that work for any model; all that is needed
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license422
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
is the graph structure G, model parameters θ, and evidence v. By contrast, GNNs are trained to
emulate specific functions using labeled input-output pairs.
It is natural to wonder what happens if we train a GNN on the exact posterior marginals derived
from a small PGM, and then apply that trained GNN to a different test PGM. In [Yoo+18; Zha+19d],
they show this method can work quite well if the test PGM is similar in structure to the one used for
training.
An alternative approach is to start with a known PGM, and then “unroll” the BP message passing
algorithm to produce a layered feedforward model, whose connectivity is derived from the graph. The
resulting network can then be trained discriminatively for some end-task (not necessarily computing
posterior marginals). Thus the BP procedure applied to the PGM just provides a way to design the
neural network structure. This method is called deep unfolding (see e.g., [HLRW14]), and can
often give very good results. (See also [SW20] for a more recent version of this approach, called
“neural enhanced BP”.)
These neural methods are useful if the PGM is fixed, and we want to repeatedly perform inference
or prediction with it, using different values of the evidence, but where the set of nodes which are
observed is always the same. This is an example of amortized inference, where we train a model
to emulate the results of running an iterative optimization scheme (see Section 10.1.5 for more
discussion).
9.5 The variable elimination (VE) algorithm
In this section, we discuss an algorithm to compute a posterior marginal p(zQ|y) for any query set
Q, assuming p is defined by a graphical model. Unlike loopy BP, it is guaranteed to give the correct
answers even if the graph has cycles. We assume all the hidden nodes are discrete, although a version
of the algorithm can be created for the Gaussian case by using the rules for sum and product defined
in Section 2.3.3.
9.5.1 Derivation of the algorithm
We will explain the algorithm by applying it to an example. Specifically, we consider the student
network from Section 4.2.2.2. Suppose we want to compute p(J = 1), the marginal probability that
a person will get a job. Since we have 8 binary variables, we could simply enumerate over all possible
assignments to all the variables (except for J), adding up the probability of each joint instantiation:
p(J) = X
L
X
S
X
G
X
H
X
I
X
D
X
C
p(C, D, I, G, S, L, J, H) (9.84)
However, this would take O(27
) time. We can be smarter by pushing sums inside products. This
is the key idea behind the variable elimination algorithm [ZP96], also called bucket elimination
[Dec96], or, in the context of genetic pedigree trees, the peeling algorithm [CTS78].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.5. THE VARIABLE ELIMINATION (VE) ALGORITHM
Coherence
Difficulty
Grade
Intelligence
SAT
Letter
Happy
Job
(a)
Coherence
Difficulty
Grade
Intelligence
SAT
Letter
Happy
Job
(b)
Coherence
Difficulty
Grade
Intelligence
SAT
Letter
Happy
Job
(c)
Figure 9.18: Example of the elimination process, in the order C, D, I, H, G, S, L. When we eliminate I (figure
c), we add a fill-in edge between G and S, since they are not connected. Adapted from Figure 9.10 of [KF09a].
In our example, we get
p(J) = X
L,S,G,H,I,D,C
p(C, D, I, G, S, L, J, H)
=
X
L,S,G,H,I,D,C
ψC (C)ψD(D, C)ψI (I)ψG(G, I, D)ψS(S, I)ψL(L, G)
× ψJ (J, L, S)ψH(H, G, J)
=
X
L,S
ψJ (J, L, S)
X
G
ψL(L, G)
X
H
ψH(H, G, J)
X
I
ψS(S, I)ψI (I)
×
X
D
ψG(G, I, D)
X
C
ψC (C)ψD(D, C)
We now evaluate this expression, working right to left as shown in Table 9.1. First we multiply
together all the terms in the scope of the P
C
operator to create the temporary factor
τ
′
1
(C, D) = ψC (C)ψD(D, C) (9.85)
Then we marginalize out C to get the new factor
τ1(D) = X
C
τ
′
1
(C, D) (9.86)
Next we multiply together all the terms in the scope of the P
D operator and then marginalize out
to create
τ
′
2
(G, I, D) = ψG(G, I, D)τ1(D) (9.87)
τ2(G, I) = X
D
τ
′
2
(G, I, D) (9.88)
And so on.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license424
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
X
L
X
S
ψJ (J, L, S)
X
G
ψL(L, G)
X
H
ψH(H, G, J)
X
I
ψS(S, I)ψI (I)
X
D
ψG(G, I, D)
X
C
ψC (C)ψD(D, C)
| {z }
τ1(D)
X
L
X
S
ψJ (J, L, S)
X
G
ψL(L, G)
X
H
ψH(H, G, J)
X
I
ψS(S, I)ψI (I)
X
D
ψG(G, I, D)τ1(D)
| {z }
τ2(G,I)
X
L
X
S
ψJ (J, L, S)
X
G
ψL(L, G)
X
H
ψH(H, G, J)
X
I
ψS(S, I)ψI (I)τ2(G, I)
| {z }
τ3(G,S)
X
L
X
S
ψJ (J, L, S)
X
G
ψL(L, G)
X
H
ψH(H, G, J)
| {z }
τ4(G,J)
τ3(G, S)
X
L
X
S
ψJ (J, L, S)
X
G
ψL(L, G)τ4(G, J)τ3(G, S)
| {z }
τ5(J,L,S)
X
L
X
S
ψJ (J, L, S)τ5(J, L, S)
| {z }
τ6(J,L)
X
L
τ6(J, L)
| {z }
τ7(J)
Table 9.1: Eliminating variables from Figure 4.38 in the order C, D, I, H, G, S, L to compute P(J).
The above technique can be used to compute any marginal of interest, such as p(J) or p(J, H). To
compute a conditional, we can take a ratio of two marginals, where the visible variables have been
clamped to their known values (and hence don’t need to be summed over). For example,
p(J = j|I = 1, H = 0) = p(J = j, I = 1, H = 0)
P
j
′ p(J = j
′
, I = 1, H = 0) (9.89)
9.5.2 Computational complexity of VE
The running time of VE is clearly exponential in the size of the largest factor, since we have to sum
over all of the corresponding variables. Some of the factors come from the original model (and are
thus unavoidable), but new factors may also be created in the process of summing out. For example,
in Table 9.1, we created a factor involving G, I, and S; but these nodes were not originally present
together in any factor.
The order in which we perform the summation is known as the elimination order. This can
have a large impact on the size of the intermediate factors that are created. For example, consider
the ordering in Table 9.1: the largest created factor (beyond the original ones in the model) has size
3, corresponding to τ5(J, L, S). Now consider the ordering in Table 9.2: now the largest factors are
τ1(I, D, L, J, H) and τ2(D, L, S, J, H), which are much bigger.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.5. THE VARIABLE ELIMINATION (VE) ALGORITHM
X
D
X
C
ψD(D, C)
X
H
X
L
X
S
ψJ (J, L, S)
X
I
ψI (I)ψS(S, I)
X
G
ψG(G, I, D)ψL(L, G)ψH(H, G, J)
| {z }
τ1(I,D,L,J,H)
X
D
X
C
ψD(D, C)
X
H
X
L
X
S
ψJ (J, L, S)
X
I
ψI (I)ψS(S, I)τ1(I, D, L, J, H)
| {z }
τ2(D,L,S,J,H)
X
D
X
C
ψD(D, C)
X
H
X
L
X
S
ψJ (J, L, S)τ2(D, L, S, J, H)
| {z }
τ3(D,L,J,H)
X
D
X
C
ψD(D, C)
X
H
X
L
τ3(D, L, J, H)
| {z }
τ4(D,J,H)
X
D
X
C
ψD(D, C)
X
H
τ4(D, J, H)
| {z }
τ5(D,J)
X
D
X
C
ψD(D, C)τ5(D, J)
| {z }
τ6(D,J)
X
D
τ6(D, J)
| {z }
τ7(J)
Table 9.2: Eliminating variables from Figure 4.38 in the order G, I, S, L, H, C, D.
We can determine the size of the largest factor graphically, without worrying about the actual
numerical values of the factors, by running the VE algorithm “symbolically”. When we eliminate a
variable zt, we connect together all variables that share a factor with zt (to reflect the new temporary
factor τ
′
t
). The edges created by this process are called fill-in edges. For example, Figure 9.18
shows the fill-in edges introduced when we eliminate in the C, D, I, . . . order. The first two steps do
not introduce any fill-ins, but when we eliminate I, we connect G and S, to capture the temporary
factor
τ
′
3
(G, S, I) = ψS(S, I)ψI (I)τ2(G, I) (9.90)
Let G≺ be the (undirected) graph induced by applying variable elimination to G using elimination
ordering ≺. The temporary factors generated by VE correspond to maximal cliques in the graph
G≺. For example, with ordering (C, D, I, H, G, S, L), the maximal cliques are as follows:
{C, D}, {D, I, G}, {G, L, S, J}, {G, J, H}, {G, I, S} (9.91)
It is clear that the time complexity of VE is
X
c∈C(G≺)
K|c|
(9.92)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license426
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where C(G) are the (maximal) cliques in graph G, |c| is the size of the clique c, and we assume for
notational simplicity that all the variables have K states each.
Let us define the induced width of a graph given elimination ordering ≺, denoted w≺, as the
size of the largest factor (i.e., the largest clique in the induced graph ) minus 1. Then it is easy to see
that the complexity of VE with ordering ≺ is O(Kw≺+1). The smallest possible induced width for a
graph is known at its treewidth. Unfortunately finding the corresponding optimal elimination order
is an NP-complete problem [Yan81; ACP87]. See Section 9.5.3 for a discussion of some approximate
methods for finding good elimination orders.
9.5.3 Picking a good elimination order
Many algorithms take time (or space) which is exponential in the tree width of the corresponding
graph. For example, this applies to Cholesky decompositions of sparse matrices, as well as to einsum
contractions (see https://github.com/dgasmith/opt_einsum). Hence we would like to find an
elimination ordering that minimizes the width. We say that an ordering π is a perfect elimination
ordering if it does not introduce any fill-in edges. Every graph that is already triangulated (e.g., a
tree) has a perfect elimination ordering. We call such graphs decomposable.
In general, we will need to add fill-in edges to ensure the resulting graph is decomposable. Different
orderings can introduce different numbers of fill-in edges, which affects the width of the resulting
chordal graph; for example, compare Table 9.1 to Table 9.2.
Choosing an elimination ordering with minimal width is NP-complete [Yan81; ACP87]. It is
common to use greedy approximation known as the min-fill heuristic, which works as follows:
eliminate any node which would not result in any fill-ins (i.e., all of whose uneliminated neighbors
already form a clique); if there is no such node, eliminate the node which would result in the minimum
number of fill-in edges. When nodes have different weights (e.g., representing different numbers of
states), we can use the min-weight heuristic, where we try to minimize the weight of the created
cliques at each step.
Of course, many other methods are possible. See [Heg06] for a general survey. [Kja90; Kja92]
compared simulated annealing with the above greedy method, and found that it sometimes works
better (although it is much slower). [MJ97] approximate the discrete optimization problem by a
continuous optimization problem. [BG96] present a randomized approximation algorithm. [Gil88]
present the nested dissection order, which is always within O(log N) of optimal. [Ami01] discuss
various constant-factor appoximation algorithms. [Dav+04] present the AMD or approximate
minimum degree ordering algorithm, which is implemented in Matlab.4 The METIS library can
be used for finding elimination orderings for large graphs; this implements the nested dissection
algorithm [GT86]. For a planar graph with N nodes, the resulting treewidth will have the optimal
size of O(N3/2
).
9.5.4 Computational complexity of exact inference
We have seen that variable elimination takes O(NKw+1) time to compute the marginals for a graph
with N nodes, and treewidth w, where each variable has K states. If the graph is densely connected,
then w = O(N), and so inference will take time exponential in N.
4. See the description of the symamd command at https://bit.ly/31N6E2b. (“sym” stands for symbolic, “amd” stands
approximate minimum degree.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.5. THE VARIABLE ELIMINATION (VE) ALGORITHM
Q1 Q2 Q3 Q4 Qn
C1
A1 A2 Am–2 X
C2 C3 Cm–1 Cm
. . .
. . .
Figure 9.19: Encoding a 3-SAT problem on n variables and m clauses as a DGM. The Qs variables are
binary random variables. The Ct variables are deterministic functions of the Qs’s, and compute the truth
value of each clause. The At nodes are a chain of AND gates, to ensure that the CPT for the final x node has
bounded size. The double rings denote nodes with deterministic CPDs. From Figure 9.1 of [KF09a]. Used
with kind permission of Daphne Koller.
Of course, just because some particular algorithm is slow doesn’t mean that there isn’t some
smarter algorithm out there. Unfortunately, this seems unlikely, since it is easy to show that exact
inference for discrete graphical models is NP-hard [DL93]. The proof is a simple reduction from the
satisfiability problem. In particular, note that we can encode any 3-SAT problem as a DPGM with
deterministic links, as shown in Figure 9.19. We clamp the final node, x, to be on, and we arrange
the CPTs so that p(x = 1) > 0 iff there is a satisfying assignment. Computing any posterior marginal
requires evaluating the normalization constant, p(x = 1), so inference in this model implicitly solves
the SAT problem.
In fact, exact inference is #P-hard [Rot96], which is even harder than NP-hard. The intuitive
reason for this is that to compute the normalizing constant, we have to count how many satisfying
assignments there are. (By contrast, MAP estimation is provably easier for some model classes
[GPS89], since, intuitively speaking, it only requires finding one satisfying assignment, not counting
all of them.) Furthermore, even approximate inference is computationally hard in general [DL93;
Rot96].
The above discussion was just concerned with inferring the states of discrete hidden variables.
When we have continuous hidden variables, the problem can be even harder, since even a simple
two-node graph, of the form z → y, can be intractable to invert if the variables are high dimensional
and do not have a conjugate relationship (Section 3.4). Inference in mixed discrete-continuous models
can also be hard [LP01].
As a consequence of these hardness results, we often have to resort to approximate inference
methods, such as variational inference (Chapter 10) and Monte Carlo inference (Chapter 11).
9.5.5 Drawbacks of VE
Consider using VE to compute all the marginals in a chain-structured graphical model, such as an
HMM. We can easily compute the final marginal p(zT |y) by eliminating all the nodes z1 to zT −1
in order. This is equivalent to the forwards algorithm, and takes O(K2T) time, as we discussed in
Section 9.2.3. But now suppose we want to compute p(zT −1|y). We have to run VE again, at a cost
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license428
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
X1
X2
X3 X4
X1
X2
X3 X4
X1
X2
X3 X4
X1
X2
X3 X4
(a)
(b)
m12
(x2
)
m32
(x2
)
m24
(x4
)
m32
(x2
)
m21
(x1
)
m42
(x2
)
m12
(x2
)
m32
(x2
) m42
(x4
)
m12
(x2
) m21
(x1
)
m32
(x2
) m42
(x2
)
m24
(x4
m23 )
(x3
)
Figure 9.20: Sending multiple messages along a tree. (a) z1 is root. (b) z2 is root. (c) z4 is root. (d) All of
the messages needed to compute all singleton marginals. Adapted from Figure 4.3 of [Jor07].
of O(K2T) time. So the total cost to compute all the marginals is O(K2T
2
). However, we know that
we can solve this problem in O(K2T) using the forwards-backwards, as we discussed in Section 9.2.3.
The difference is that FB caches the messages computed on the forwards pass, so it can reuse them
later. (Caching previously computed results is the core idea behind dynamic programming.)
The same problem arises when applying VE to trees. For example, consider the 4-node tree in
Figure 9.20. We can compute p(z1|y) by eliminating z2:4; this is equivalent to sending messages up
to z1 (the messages correspond to the τ factors created by VE). Similarly we can compute p(z2|y),
p(z3|y) and then p(z4|y). We see that some of the messages used to compute the marginal on one
node can be re-used to compute the marginals on the other nodes. By storing the messages for later
re-use, we can compute all the marginals in O(K2T) time, as we show in Section 9.3.
The question is: how do we get these benefits of message passing on a tree when the graph is not a
tree? We give the answer in Section 9.6.
9.6 The junction tree algorithm (JTA)
The junction tree algorithm or JTA is a generalization of variable elimination that lets us
efficiently compute all the posterior marginals without repeating redundant work, by using dynamic
programming, thus avoiding the problems mentioned in Section 9.5.5. The basic idea is to convert
the graph into a special kind of tree, known as a junction tree (also called a join tree, or clique
tree), and then to run belief propagation (message passing) on this tree. We can create the join
tree by running variable elimination “symbolically”, as discussed in Section 9.5.2, and adding the
generated fill-in edges to the graph. The resulting chordal graph can then be converted to a tree, as
explained in Supplementary Section 9.2.1. Once we have a tree, we can perform message passing on
it, using a variant of the method Section 9.3.2. See Supplementary Section 9.2.2 for details.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.7. INFERENCE AS OPTIMIZATION
9.7 Inference as optimization
In this section, we discuss how to perform posterior inference by solving an optimization problem,
which is often computationally simpler. See also Supplementary Section 9.3.
9.7.1 Inference as backpropagation
In this section, we discuss how to compute posterior marginals in a graphical model using automatic
differentiation. For notational simplicity, we focus on undirected graphical models, where the joint
can be represented as an exponential family (Section 2.4) follows:
p(x) = 1
Z
Y
c
ψc(xc) = exp(X
c
η
T
cT (xc) − log A(η)) = exp(η
T
T (x) − log A(η)) (9.93)
where ψc is the potential function for clique c, ηc are the natural parameters for clique c, T (xc) are
the corresponding sufficient statistics, and A = log Z is the log partition function.
We will consider pairwise models (with node and edge potentials), and discrete variables. The
natural parameters are the node and edge log potentials, η = ({ηs;j}, {ηs,t;j,k}), and the sufficient
statistics are node and edge indicator functions, T (x) = ({I(xs = j)}, {I(xs = j, xt = k)}). (Note:
we use s, t ∈ V to index nodes and j, k ∈ X to index states.)
The mean of the sufficient statistics are given by
µ = E [T (x)] = ({p(xs = j)}s, {p(xs = j, xt = k)}s6=t) = ({µs;j}s, {µst;jk}s6=t) (9.94)
The key result, from Equation (2.236), is that µ = ∇ηA(η). Thus as long as we have a function that
computes A(η) = log Z(η), we can use automatic differentiation (Section 6.2) to compute gradients,
and then we can extract the corresponding node marginals from the gradient vector. If we have
evidence (known values) on some of the variables, we simply “clamp” the corresponding entries to 0
or 1 in the node potentials.
The observation that probabilistic inference can be performed using automatic differentiation has
been discovered independently by several groups (e.g., [Dar03; PD03; Eis16; ASM17]). It also lends
itself to the development of differentiable approximations to inference (see e.g., [MB18]).
9.7.1.1 Example: inference in a small model
As a concrete example, consider a small chain structured model x1 − x2 − x3, where each node has
K states. We can represent the node potentials as K × 1 tensors (table of numbers), and the edge
potentials by K × K tensors. The partition function is given by
Z(ψ) = X
x1,x2,x3
ψ1(x1)ψ2(x2)ψ3(x3)ψ12(x1, x2)ψ23(x2, x3) (9.95)
Let η = log(ψ) be the log potentials, and A(η) = log Z(η) be the log partition function. We can
compute the single node marginals µs = p(xs = 1 : K) using µs = ∇ηsA(η), and the pairwise
marginals µs,t(j, k) = p(xs = j, xt = k) using µs,t = ∇ηs,tA(η).
We can compute the partition function Z efficiently use numpy’s einsum function, which imple￾ments tensor contraction using Einstein summation notation. We label each dimension of the tensors
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license430
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
by A, B, and C, so einsum knows how to match things up. We then compute gradients using an
auto-diff library.5 The result is that inference can be done in two lines of Python code, as shown in
Listing 9.1:
Listing 9.1: Computing marginals from derivative of log partition function
import jax . numpy as jnp
from jax import grad
logZ_fun = lambda logpots : np . log ( jnp . einsum ("A ,B ,C ,AB , BC ",
*[ jnp . exp ( lp ) for lp in logpots ]) )
probs = grad ( logZ_fun )( logpots )
To perform conditional inference, such as p(xs = k|xt = e), we multiply in one-hot indicator
vectors to clamp xt to the value e so that the unnormalized joint only assigns non-zero probability to
state combinations that are valid. We then sum over all values of the unclamped variables to get the
constrained partition function Ze. The gradients will now give us the marginals conditioned on the
evidence [Dar03].
9.7.2 Perturb and MAP
In this section, we discuss how to draw posterior samples from a graphical model by leveraging
optimization as a subroutine. The basic idea is to make S copies of the model, each of which has
slightly perturbed versions of the parameters, θs = θs + ǫs, and then to compute the MAP estimate,
xs = argmax p(x|y; θs). For a suitably chosen noise distribution for ǫs, this technique — known as
perturb-and-MAP — can be shown that this gives exact posterior samples [PY10; PY11; PY14].
9.7.2.1 Gaussian case
We first consider the case of a Gaussian MRF. Let x ∈ R
N be the vector of hidden states with prior
p(x) ∝ N (Gx|µp
, Σp) ∝ exp(−
1
2
x
TKxx + h
T
xx) (9.96)
where G ∈ R
K×N is a matrix that represents prior dependencies (e.g., pairwise correlations),
Kx = GTΣ
−1
p G, and hx = GTΣ
−1
p µp
. Let y ∈ RM be the measurements with likelihood
p(y|x) = N (y|Hx + c, Σn) ∝ exp(−
1
2
x
TKy|xx + h
T
y|xx −
1
2
y
TΣ
−1
n y) (9.97)
where H ∈ RM×N represents dependencies between the hidden and visible variables, Ky|x = HTΣ
−1
n H
and hy|x = HTΣ
−1
n
(y − c). The posterior is given by the following (cf. one step of the information
filter in Section 8.2.4)
p(x|y) = N (x|µ, Σ) (9.98)
Σ
−1 = K = GTΣ
−1
p G + HTΣ
−1
n H (9.99)
µ = K(GTΣ
−1
p µp + HTΣ
−1
n
(y − c)) (9.100)
5. See ugm_inf_autodiff.py for the full (JAX) code, and see https://github.com/srush/ProbTalk for a (PyTorch)
version by Sasha Rush.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
9.7. INFERENCE AS OPTIMIZATION
where we have assumed K = Kx + Ky|x is invertible (although the prior or likelihood on their own
may be singular).
The K rows of G = [g
T
1
; . . . ; g
T
K] and the M rows of H = [h
T
1
; . . . ; h
T
M] can be combined into the
L rows of F = [f
T
1
; . . . ; fL], which define the linear constraints of the system. If we assume that
Σp and Σn are diagonal, then the structure of the graphical model is uniquely determined by the
sparsity of F. The resulting posterior factorizes as a product of L Gaussian “experts”:
p(x|y) ∝
Y
L
l=1
exp(−
1
2
x
TKlx + h
T
l x) ∝
Y
L
l=1
N (f
T
l x; µl
, Σl) (9.101)
where Σl equals Σp,l,l for l = 1 : K and equals Σn,l′
,l′ for l = K + 1 : L where l
′ = l − K. Similarly
µl = µp,l for l = 1 : K and µl = (yl
′ − cl
′ ) for l = K + 1 : L.
To apply perturb and MAP, we proceed as follows. First perturb the prior mean by sampling µ˜ p ∼
N (µp
, Σp), and perturb the measurements by sampling y˜ ∼ N (y, Σn). (Note that this is equivalent
to first perturbing the linear term in each information form potential, using h˜
l = hl + flΣ
− 1
2
l
ǫl
,
where ǫl ∼ N (0, 1).) Then compute the MAP estimate for x using the perturbed parameters:
x˜ = K−1GTΣ
−1
p µ˜ p + K−1HTΣ
−1
n
(y˜ − c) (9.102)
= K−1GTΣ
−1
p
| {z }
A
(µp + ǫµ) + K−1HTΣ
−1
n
| {z }
B
(y + ǫy − c) (9.103)
= µ + Aǫµ + Bǫy (9.104)
We see that E [x˜] = µ and E

(x˜ − µ)(x˜ − µ)
T

= K−1 = Σ, so the method produces exact samples.
This approach is very scalable, since compute the MAP estimate of sparse GMRFs (i.e., posterior
mean) can be done efficiently using conjugate gradient solvers. Alternatively we can use loopy belief
propagation (Section 9.4), which can often compute the exact posterior mean (see e.g., [WF01a;
JMW06; Bic09; Du+18]).
9.7.2.2 Discrete case
In [PY11; PY14] they extend perturb-and-MAP to the case of discrete graphical models. This
setup is more complicated, and requires the use of Gumbel noise, which can be sampled using
ǫ = − log(− log(u)), where u ∼ Unif(0, 1). This noise should be added to all the potentials in the
model, but as a simple approximation, it can just be added to the unary terms, i.e., the local evidence
potentials. Let the score, or unnormalized log probability, of configuration x given inputs c be
S(x; c) = log p(x|c) + const = X
i
log φi(xi) +X
ij
log ψij (xi,j ) (9.105)
where we have assumed a pairwise CRF for notational simplicity. If we perturb the local evidence
potentials φi(k) by adding ǫik to each entry, where k indexes the discrete latent states, we get
S˜(x; c). We then compute a sample x˜ by solving x˜ = argmax S˜(x; c). The advantage of this
approach is that it can leverage efficient MAP solvers for discrete models, such as those discussed in
Supplementary Section 9.3. This can in turn be used for parameter learning, and estimating the
partition function [HJ12; Erm+13].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license10 Variational inference
10.1 Introduction
In this chapter, we discuss variational inference, which reduces posterior inference to optimization.
Note that VI is a large topic; this chapter just gives a high level overview. For more details, see e.g.,
[Jor+98; JJ00; Jaa01; WJ08; SQ05; TLG08; Zha+19b; Bro18].
10.1.1 The variational objective
Consider a model with unknown (latent) variables z, known variables x, and fixed parameters θ. (If
the parameters are unknown, they can be added to z, as we discuss later.) We assume the prior is
pθ(z) and the likelihood is pθ(x|z), so the unnormalized joint is pθ(x, z) = pθ(x|z)pθ(z), and the
posterior is pθ(z|x) = pθ(x, z)/pθ(x). We assume that it is intractable to compute the normalization
constant, pθ(x) = R
pθ(x, z)dz, and hence intractable to compute the normalized posterior. We
therefore seek an approximation to the posterior, which we denote by q(z), such that we minimize
the following loss:
q = argmin
q∈Q
DKL (q(z) k pθ(z|x)) (10.1)
Since we are minimizing over functions (namely distributions q), this is called a variational method.
In practice we pick a parametric family Q, where we use ψ, known as the variational parameters,
to specify which member of the family we are using. We can compute the best variational parameters
(for given x) as follows:
ψ
∗ = argmin
ψ
DKL (qψ(z) k pθ(z|x)) (10.2)
= argmin
ψ
Eqψ(z)

log qψ(z) − log 
pθ(x|z)pθ(z)
pθ(x)
 (10.3)
= argmin
ψ
Eqψ(z)
[log qψ(z) − log pθ(x|z) − log pθ(z)]
| {z }
L(θ,ψ|x)
+ log pθ(x) (10.4)
The final term log pθ(x) = log(
R
pθ(x, z)dz) is generally intractable to compute. Fortunately, it is
independent of ψ, so we can drop it. This leaves us with the first term, which we write as follows:
L(θ, ψ|x) = Eqψ(z)
[− log pθ(x, z) + log qψ(z)] (10.5)434
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 10.1: Illustration of variational inference. The large oval represents the set of variational distributions
Q = {qψ(z) : ψ ∈ ⊖}, where ⊖ is the set of possible variational parameters. The true distribution is the
point p(z|x), which we assume lies outside the set. Our goal is to find the best approximation to p within our
variational family; this is the point ψ
∗ which is closest in KL divergence. We find this point by starting an
optimization procedure from the random initial point ψ
init. Adapted from a figure by David Blei.
Minimizing this objective will minimize the KL divergence, causing our approximation to approach
the true posterior. See Figure 10.1 for an illustration. In the sections below, we give two different
interpretations of this objective function.
10.1.1.1 The view from physics: minimize the variational free energy
If we define Eθ(z) = − log pθ(z, x) as the energy, then we can rewrite the loss in Equation (10.5)
L(θ, ψ|x) = Eqψ(z)
[Eθ(z)] − H(qψ) = expected energy − entropy (10.6)
In physics, this is known as the variational free energy (VFE). This is an upper bound on the
free energy (FE), − log pθ(x), which follows from the fact that
DKL (qψ(z) k pθ(z|x)) = L(θ, ψ|x) + log pθ(x) ≥ 0 (10.7)
L(θ, ψ|x)
| {z }
VFE
≥ − log pθ(x)
| {z }
FE
(10.8)
Variational inference is equivalent to minimizing the VFE. If we we reach the minimum value of
− log pθ(x), then the KL divergence term will be 0, so our approximate posterior will be exact.
10.1.1.2 The view from statistics: maximize the evidence lower bound (ELBO)
The negative of the VFE is known as the evidence lower bound or ELBO function [BKM16]:
Ł(θ, ψ|x) , Eqψ(z)
[log pθ(x, z) − log qψ(z)] = ELBO (10.9)
The name “ELBO” arises because
Ł(θ, ψ|x) ≤ log pθ(x) (10.10)
where log pθ(x) is called the “evidence”. The inequality follows from Equation (10.8). Therefore
maximizing the ELBO wrt ψ will minimize the original KL, since log pθ(x) is a constant wrt ψ.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.1. INTRODUCTION
(Note: we use the symbol Ł for the ELBO, rather than L, since we want to maximize Ł but minimize
L.)
We can rewrite the ELBO as follows:
Ł(θ, ψ|x) = Eqψ(z)
[log pθ(x, z)] + H(qψ(z)) (10.11)
We can interpret this
ELBO = expected log joint + entropy (10.12)
The second term encourages the posterior to be maximum entropy, while the first term encourages it
to be a joint MAP configuration.
We can also rewrite the ELBO as
Ł(ψ|θ, x) = Eqψ(z)
[log pθ(x|z) + log pθ(z) − log qψ(z)] (10.13)
= Eqψ(z)
[log pθ(x|z)] − DKL (qψ(z) k pθ(z)) (10.14)
We can interpret this as follows:
ELBO = expected log likelihood − KL from posterior to prior (10.15)
The KL term acts like a regularizer, preventing the posterior from diverging too much from the prior.
10.1.2 Form of the variational posterior
There are two main approaches for choosing the form of the variational posterior, qψ(z|x). In the first
approach, we pick a convenient functional form, such as multivariate Gaussian, and then optimize the
ELBO using gradient-based methods. This is called fixed-form VI, and is discussed in Section 10.2.
An alternative is to make the mean field assumption, namely that the posterior factorizes:
qψ(z) = Y
J
j=1
qj (zj ) (10.16)
where qj (zj ) = qψj
(zj ) is the posterior over the j’th group of variables. We don’t need to specify the
functional form for each qj . Instead, the optimal distributional form can be derived by maximizing
the ELBO wrt each group of variational parameters one at a time, in a coordinate ascent manner.
This is therefore called free-form VI, and is discussed in Section 10.3.
We now give a simple example of variational inference applied to a 2d latent vector z, representing
the mean of a Gaussian. The prior is N (z| m` ,
`
V), and the likelihood is
p(D|z) = Y
N
n=1
N (xn|z, Σ) ∝ N (x|z,
1
N
Σ) (10.17)
The exact posterior, p(z|D) = N (z| ma ,
a
V), can be computed analytically, as discussed in Sec￾tion 3.4.4.1. In Figure 10.2, we compare three Gaussian variational approximations to the posterior.
If q uses a full covariance matrix, it matches the exact posterior; however, this is intractable in high
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license436
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 1
z1
1.0
1.5
2.0
2.5
z2
analytic
mean field
low rank
full rank
Figure 10.2: Variational approximation to the exact (Gaussian) posterior for the mean of a 2d Gaussian
likelihood with a Gaussian prior. We show 3 Gaussian approximations to the posterior, using a full covari￾ance (blue), a diagonal covariance (green), and a diagonal plus rank one covariance (red). Generated by
gaussian_2d_vi.ipynb.
dimensions. If q uses a diagonal covariance matrix (corresponding to the mean field approximation),
we see that the approximation is over confident, which is a well-known flaw of variational inference,
due to the mode-seeking nature of minimizing DKL (q k p) (see Section 5.1.4.3 for details). Finally, if
q uses a rank-1 plus diagonal approximation, we get a much better approximation; furthermore, this
can be computed quite efficiently, as we discuss in Section 10.2.1.3.
10.1.3 Parameter estimation using variational EM
So far, we have assumed the model parameters θ are known. However, we can try to estimate them
by maximing the log marginal likelihood of the dataset, D = {xn : n = 1 : N},
log p(D|θ) = X
N
n=1
log p(xn|θ) (10.18)
In general, this is intractable to compute, but we discuss approximations below.
10.1.3.1 MLE for latent variable models
Suppose we have a latent variable model of the form
p(D, z1:N |θ) = Y
N
n=1
p(zn|θ)p(xn|zn, θ) (10.19)
as shown in Figure 10.3a. Furthermore, suppose we want to compute the MLE for θ given the dataset
D = {xn : n = 1 : N}. Since the local latent variables zn are hidden, we must marginalize them out
to get the local (per example) log marginal likelihood:
log p(xn|θ) = log Z
p(xn|zn, θ)p(zn|θ)dzn

(10.20)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.1. INTRODUCTION
θ
z1 zN
· · ·
x1 xN
(a)
ξ
θ
x1 · · · xN
(b)
Figure 10.3: Graphical models with: (a) Local stochastic latent variables zn and global deterministic latent
parameter θ. (b) Global stochastic latent parameter θ and global deterministic latent hyper-parameter ξ. The
observed variables xn are shown by shaded circles.
Unfortunately, computing this integral is usually intractable, since it corresponds to the normalization
constant of the exact posterior. Fortunately, the ELBO is a lower bound on this:
Ł(θ, ψn|xn) ≤ log p(xn|θ) (10.21)
We can thus optimize the model parameters by maximizing
Ł(θ, ψ1:N |D) ,
X
N
n=1
Ł(θ, ψn|xn) ≤ log p(D|θ) (10.22)
This is the basis of the variational EM algorithm. We discuss this in more detail in Section 6.5.6.1,
but the basic idea is to alternate between maximizing the ELBO wrt the variational parameters
{ψn} in the E step, to give us qψn
(zn), and then maximizing the ELBO (using the new ψn) wrt the
model parameters θ in the M step. (We can also use SGD and amortized inference to speed this up,
as we explain in Sections 10.1.4 to 10.1.5.)
10.1.3.2 Empirical Bayes for fully observed models
Suppose we have a fully observed model (with no local latent variables) of the form
p(D, θ|ξ) = p(θ|ξ)
Y
N
n=1
p(xn|θ) (10.23)
as shown in Figure 10.3b. In the context of Bayesian parameter inference, our goal is to compute the
parameter posterior:
p(θ|D, ξ) = p(D|θ)p(θ|ξ)
p(D|ξ)
(10.24)
where θ are the global unknown model parameters (latent variables), and ξ are the hyper-parameters
for the prior. If the hyper-parameters are unknown, we can estimate them using empirical Bayes (see
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license438
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Section 3.7) by computing
ˆξ = argmax
ξ
log p(D|ξ) (10.25)
We can use variational EM to compute this, similar to Section 10.1.3.1, except now the parameters
to be estimated are ξ, the latent variables are the shared global parameters θ, and the observations
are the entire dataset, D. We then get the lower bound
log p(D|ξ) ≥ Ł(ξ, ψ|D) = Eqψ(θ)
"X
N
n=1
log p(xn|θ)
#
− DKL (qψ(θ) k p(θ|ξ)) (10.26)
We optimize this wrt the parameters of the variational posterior, ψ, and wrt the prior hyper-parameters
ξ.
If the prior ξ is fixed, we just need to optimize the variational parameters ψ to compute the
posterior, qψ(θ|D). This is known as variational Bayes. See Section 10.3.3 for more details.
10.1.4 Stochastic VI
In Section 10.1.3, we saw that parameter estimation requires optimizing the ELBO for the entire
dataset, which is defined as the sum of the ELBOs for each of the N data samples xn. Computing
this objective can be slow if N is large. Fortunately, we can replace this objective with a stochastic
approximation, which is faster to compute, and provides an unbiased estimate. In particular, at each
step, we can draw a random minibatch of B = |B| examples from the dataset, and then make the
approximation
Ł(θ, ψ1:N |D) = X
N
n=1
Ł(θ, ψn|xn) ≈
N
B
X
xn∈B
h
Eqψn
(zn)

log pθ(xn|zn) + log pθ(zn) − log qψn
(zn)

i
(10.27)
This can be used inside of a stochastic optimization algorithm, such as SGD. This is called stochastic
variational inference or SVI [Hof+13], and allows VI to scale to large datasets.
10.1.5 Amortized VI
In Section 10.1.4, we saw that in each iteration of SVI, we need to optimize the local variational
parameters ψn for each example n in the minibatch. This nested optimization can be quite slow.
An alternative approach is to train a model, known as an inference network or recognition
network, to predict ψn from the observed data, xn, using ψn = f
inf
φ
(xn). This technique is known
as amortized variational inference [GG14], or inference compilation [LBW17], since we are
reducing the cost of per-example time inference by training a model that is shared across all examples.
(See also [Amo22] for a general discussion of amortized optimization.) For brevity, we will write the
amortized posterior as
q(zn|ψn) = q(zn|f
inf
φ (xn)) = qφ(zn|xn) (10.28)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.2. GRADIENT-BASED VI
The corresponding ELBO becomes
Ł(θ, φ|D) = X
N
n=1

Eqφ(zn|xn)
[log pθ(xn, zn) − log qφ(z|xn)]
(10.29)
If we combine this with SVI we get an amortized version of Equation (10.27). For example, if we use
a minibatch of size 1, we get
Ł(θ, φ|xn) ≈ N

Eqφ(zn|xn)
[log pθ(xn, zn) − log qφ(z|xn)]
(10.30)
We can optimize this as shown in Algorithm 10.1. Note that the (partial) maximization wrt θ in
the M step is usually done with a gradient update, but the maximization wrt φ in the E step is
trickier, since the loss uses φ to define an expectation operator, so we can’t necessarily push the
gradient operator inside; we discuss ways to optimize the variational parameters in Section 10.2 and
Section 10.3.
Algorithm 10.1: Amortized stochastic variational EM
1 Initialize θ, φ
2 repeat
3 Sample xn ∼ pD
4 E step: φ = argmaxφ Ł(θ, φ|xn)
5 M step: θ = argmaxθ Ł(θ, φ|xn)
6 until converged
10.1.6 Semi-amortized inference
Amortized SVI is widely used for fitting LVMs, e.g., for VAEs (see Section 21.2), for topic models
[SS17a], for probabilistic programming [RHG16], for CRFs [TG18], etc. However, the use of an
inference network can result in a suboptimal setting of the local variational parameters ψn. This
is called the amortization gap [CLD18]. We can close this gap by using the inference network
to warm-start an optimizer for ψn; this is known as semi-amortized VI [Kim+18c]. (See also
[MYM18], who propose a closely related method called iterative amortized inference.)
An alternative approach is to use the inference network as a proposal distribution. If we combine
this with importance sampling, we get the IWAE bound of Section 10.5.1. If we use this with
Metropolis-Hastings, we get a VI-MCMC hybrid (see Section 10.4.5).
10.2 Gradient-based VI
In this section, we will choose some convenient form for qψ(z), such as a Gaussian for continuous
z, or a product of categoricals for discrete z, and then optimize the ELBO using gradient based
methods.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license440
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
z
φ x φ x ε
z = g(φ,x,ε)
Original form Reparameterized form
f
f
~ qφ(z|x)
~ p(ε)
Backprop
∇φ f
∇z f
: Deterministic node
: Random node
: Evaluation of f
: Differentiation of f
Figure 10.4: Illustration of the reparameterization trick. The objective f depends on the variational parameters
φ, the observed data x, and the latent random variable z ∼ qφ(z|x). On the left, we show the standard form
of the computation graph. On the right, we show a reparameterized form, in which we move the stochasticity
into the noise source ǫ, and compute z deterministically, z = g(φ, x, ǫ). The rest of the graph is deterministic,
so we can backpropagate the gradient of the scalar f wrt φ through z and into φ. From Figure 2.3 of [KW19a].
Used with kind permission of Durk Kingma.
The gradient wrt the generative parameters θ is easy to compute, since we can push gradients
inside the expectation, and use a single Monte Carlo sample:
∇θŁ(θ, φ|x) = ∇θEqφ(z|x)
[log pθ(x, z) − log qφ(z|x)] (10.31)
= Eqφ(z|x)
[∇θ {log pθ(x, z) − log qφ(z|x)}] (10.32)
≈ ∇θ log pθ(x, z
s
) (10.33)
where z
s ∼ qφ(z|x). This is an unbiased estimate of the gradient, so can be used with SGD.
The gradient wrt the inference parameters φ is harder to compute since
∇φŁ(θ, φ|x) = ∇φEqφ(z|x)
[log pθ(x, z) − log qφ(z|x)] (10.34)
6= Eqφ(z|x)
[∇φ {log pθ(x, z) − log qφ(z|x)}] (10.35)
However, we can often use the reparameterization trick, which we discuss in Section 10.2.1. If not,
we can use blackbox VI, which we discuss in Section 10.2.3.
10.2.1 Reparameterized VI
In this section, we discuss the reparameterization trick for taking gradients wrt distributions over
continuous latent variables z ∼ qφ(z|x). We explain this in detail in Section 6.3.5, but we summarize
the basic idea here.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.2. GRADIENT-BASED VI
The key trick is to rewrite the random variable z ∼ qφ(z|x) as some differentiable (and invertible)
transformation g of another random variable ǫ ∼ p(ǫ), which does not depend on φ, i.e., we assume
we can write
z = g(φ, x, ǫ) (10.36)
For example,
z ∼ N (µ, diag(σ)) ⇐⇒ z = µ + ǫ ⊙ σ, ǫ ∼ N (0, I) (10.37)
Using this, we have
Eqφ(z|x)
[f(z)] = Ep(ǫ)
[f(z)] s.t. z = g(φ, x, ǫ) (10.38)
where we define
fθ,φ(z) = log pθ(x, z) − log qφ(z|x) (10.39)
Hence
∇φEqφ(z|x)
[f(z)] = ∇φEp(ǫ)
[f(z)] = Ep(ǫ)
[∇φf(z)] (10.40)
which we can approximate with a single Monte Carlo sample. This lets us propagate gradients back
through the f function. See Figure 10.4 for an illustration. This is called reparameterized VI or
RVI.
Since we are now working with the random variable ǫ, we need to use the change of variables
formula to compute
log qφ(z|x) = log p(ǫ) − log




det 
∂z
∂ǫ




(10.41)
where ∂z
∂ǫ
is the Jacobian:
∂z
∂ǫ
=


∂z1
∂ǫ1
· · ·
∂z1
∂ǫk
.
.
.
.
.
.
.
.
.
∂zk
∂ǫ1
· · ·
∂zk
∂ǫk

 (10.42)
We design the transformation z = g(ǫ) such that this Jacobian is tractable to compute. We give
some examples below.
10.2.1.1 Gaussian with diagonal covariance (mean field)
Suppose we use a fully factorized Gaussian posterior. Then the reparameterization process becomes
ǫ ∼ N (0, I) (10.43)
z = µ + σ ⊙ ǫ (10.44)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license442
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where the inference network generates the parameters of the transformation:
(µ, log σ) = f
inf
φ (x) (10.45)
Thus to sample from the posterior qφ(z|x), we sample ǫN (0, I), and then compute z.
Given the sample, we need to evaluate the ELBO:
f(z) = log pθ(x|z) + log pθ(z) − log qφ(z|x) (10.46)
To evaluate the pθ(x|z) term, we can just plug z into the likelihood. To evaluate the log qφ(z|x)
term, we need to use the change of variables formula from Equation (10.41). The Jacobian is given
by ∂z
∂ǫ = diag(σ). Hence
log qφ(z|x) = X
K
k=1
[log N (ǫk|0, 1) − log σk] = −
X
K
k=1

1
2
log(2π) + 1
2
ǫ
2
k + log σk

(10.47)
Finally, to evaluate the p(z) term, we can use the transformation z = 0 + 1 ⊙ ǫ, so the Jacobian is
the identity and we get
log p(z) = X
K
k=1

1
2
z
2
k +
1
2
log(2π)

(10.48)
An alternative is to use the objective
f
′
(z) = log pθ(x|z) + DKL (qφ(Z|x) k pθ(Z)) (10.49)
In some cases, we evaluate the second term analytically, without needing Monte Carlo. For example,
if we assume a diagonal Gaussian prior, p(z) = N (z|0, I), and diagonal gaussian posterior, q(z|x) =
N (z|µ, diag(σ)), we can use Equation (5.78) to compute the KL in closed form:
DKL (q k p) = −
1
2
X
K
k=1

log σ
2
k − σ
2
k − µ
2
k + 1
(10.50)
The objective f
′
(z) is often lower variance than f(z), since it computes the KL analytically. However,
it is harder to generalize this objective to settings where the prior and/or posterior are not Gaussian.
10.2.1.2 Gaussian with full covariance
Now consider using a full covariance Gaussian posterior. We will compute a Cholesky decomposition
of the covariance, Σ = LLT, where L is a lower triangular matrix with non-zero entries on the
diagonal. Hence the reparameterization becomes
ǫ ∼ N (0, I) (10.51)
z = µ + Lǫ (10.52)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.2. GRADIENT-BASED VI
The Jacobian of this affine transformation is ∂z
∂ǫ = L. Since L is a triangular matrix, its determinant
is the product of its main diagonal, so
log




det ∂z
∂ǫ



 =
X
K
k=1
log |Lkk| (10.53)
We can compute L using
L = M⊙ L
′ + diag(σ) (10.54)
where M is a masking matrix with 0s on and above the diagonal, and 1s below the diagonal, and
where (µ, log σ,L
′
) is predicted by the inference network. With this construction, the diagonal entries
of L are given by σ, so
log




det ∂z
∂ǫ



 =
X
K
k=1
log |Lkk| =
X
K
k=1
log σk (10.55)
10.2.1.3 Gaussian with low-rank plus diagonal covariance
In high dimensions, an efficient alternative to using a Cholesky decomposition is the factor decompo￾sition
Σ = BBT + C2
(10.56)
where B is the factor loading matrix of size d × f, where f ≪ d is the number of factors, d is
the dimensionality of z, and C = diag(c1, . . . , cd). This reduces the total number of variational
parameters from d + d(d + 1)/2 to (f + 2)d. In [ONS18], they called this approach VAFC (short for
variational approximation with factor covariance).
In the special case where f = 1, the covariance matrix becomes
Σ = bbT + diag(c
2
) (10.57)
In this case, it is possible to compute the natural gradient (Section 6.4) of the ELBO in closed form
in O(d) time, as shown in [Tra+20b; TND21], who call the approach NAGVAC-1 (natural gradient
Gaussian variational approximation). This can result in much faster convergence than following the
normal gradient.
In Section 10.1.2, we show that this low rank approximation is much better than a diagonal
approximation. See Supplementary Section 10.1 for more examples.
10.2.1.4 Other variational posteriors
Many other kinds of distribution can be written in a reparameterizable way, as described in [Moh+20].
This includes standard exponential family distributions, such as the gamma and Dirichlet, as well as
more exotic forms, such as inverse autoregressive flows (see Section 10.4.3).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license444
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
θ
x1 · · · xN
(a)
θ
z1 zN
· · ·
x1 xN
(b)
Figure 10.5: Graphical models with (a) Global latent parameter θ and observed variables x1:N . (b) Local
latent variables z1:N , global latent parameter θ, and observed variables x1:N .
10.2.1.5 Example: Bayesian parameter inference
In this section, we use reparameterized SVI to infer the posterior for the parameters of a Gaussian
mixture model (GMM). We will marginalize out the discrete latent variables, so just need to
approximate the posterior over the global latent, p(θ|D). This is sometimes called a “collapsed”
model, since we have marginalized out all the local latent variables. That is, we have converted the
model in Figure 10.5b to the one in Figure 10.5a. We choose a factored (mean field) variational
posterior that is conjugate to the likelihood, but is also reparameterizable. This lets us fit the
posterior with SGD.
For simplicity, we assume diagonal covariance matrices for each Gaussian mixture component.
Thus the likelihood for one datapoint, x ∈ R
D, is
p(x|θ) = X
K
k=1
πkN (x|µk
, diag(λk)
−1
) (10.58)
where µk = (µk1, . . . , µkD) are the means, λk = (λk1, . . . , λkD) are the precisions, and π =
(π1, . . . , πK) are the mixing weights. We use the following prior for these parameters:
pξ(θ) = "Y
K
k=1
Y
D
d=1
N (µkd|0, 1)Ga(λkd|5, 5)#
Dir(π|1) (10.59)
where ξ are the hyperparameters. We assume the following mean field posterior:
qψ(θ) = "Y
K
k=1
Y
D
d=1
N (µkd|mkd, skd)Ga(λkd|αkd, βkd)
#
Dir(π|c) (10.60)
where ψ = (m1:K,1:D, s1:K,1:D, α1:K,1:D, β1:K,1:D, c) are the variational parameters for θ.
We can compute the ELBO using
Ł(ξ, ψ|D) = Eqψ(θ)
[log p(D|θ) + log pξ(θ) − log qψ(θ)] (10.61)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.2. GRADIENT-BASED VI
10 5 0 5 10
8
6
4
2
0
2
4
6
(a)
6 4 2 0 2 4 6
6
4
2
0
2
4
6
0.00
0.01
0.02
0.03
0.04
0.05
Likelihood
(b)
2.10 2.05 2.00 1.95 1.90
4.10
4.05
4.00
3.95
3.90
3.85
(c)
Figure 10.6: SVI for fitting a mixture of 3 Gaussians in 2d. (a) 3000 training points. (b) Fitted density,
plugging in the posterior mean parameters. (c) Kernel density estimate fit to 10,000 samples from q(µ1
|ψ).
Generated by svi_gmm_demo_2d.ipynb.
Since the distributions are reparameterizable, we can and push gradients inside this expression. We
can approximate the expectation by drawing a single posterior sample, and can approximate the
log likelihood using minibatching. We can then update the variational parameters, (and optionally
the hyperparameters of the prior, as we discussed in Section 10.1.3.2) using the pseudcode in
Algorithm 10.2.
Algorithm 10.2: Reparameterized SVI for Bayesian parameter inference
1 Initialize ψ, ξ
2 repeat
3 Sample minibatch B = {xb ∼ D : b = 1 : B}
4 Sample ǫ ∼ q0
5 Compute θ˜ = g(ψ, ǫ)
6 Compute L(ψ|D, θ˜) = −
N
B
P
xn∈B log p(xn|θ˜) − log pξ(θ˜) + log qψ(θ˜)
7 Update ξ := ξ − η∇ξL(ξ, ψ|D, θ˜)
8 Update ψ := ψ − η∇ψL(ξ, ψ|D, θ˜)
9 until converged
Figure 10.6 gives an example of this in practice. We generate a dataset from a mixture of 3
Gaussians in 2d, using µ
∗
1 = [2, 0], µ
∗
2 = [−2, −4], µ
∗
3 = [−2, 4], precisions λ
∗
dk = 1, and uniform
mixing weights, π
∗ = [1/3, 1/3, 1/3]. Figure 10.6a shows the training set of 3000 points. We fit
this using SVI, with a batch size of 500, for 1000 epochs, using the Adam optimizer. Figure 10.6b
shows the predictions of the fitted model. More precisely, it shows p(x|θ), where θ = Eq(θ|ψ)
[θ].
Figure 10.6c shows a kernel density estimate fit to 10,000 samples from q(µ1
|ψ). We see that the
posterior mean is E [µ1
] ≈ [−2, −4]. Due to label switching unidentifiability, we see this matches µ
∗
2
rather than µ
∗
1
.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license446
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.2.1.6 Example: MLE for LVMs
In this section, we consider reparameterized SVI for computing the MLE for latent variable models
(LVMs) with continuous latents, such as variational autoencoders (Section 21.2). Unlike Sec￾tion 10.2.1.5, we cannot analytically marginalize out the local latents. Instead we will use amortized
inference, as in Section 10.1.5, which means we learn an inference network (with parameters φ) to
predict the local variational parameters ψn given input xn. If we sample a single example xn from
the dataset at each iteration, and a single latent variable zn from the variational posterior, then we
get the pseudocode in Algorithm 10.3.
Algorithm 10.3: Reparameterized amortized SVI for MLE of an LVM
1 Initialize θ, φ
2 repeat
3 Sample xn ∼ pD
4 Sample ǫn ∼ q0
5 Compute zn = g(φ, xn, ǫn)
6 Compute L(θ, φ|xn, zn) = − log pθ(xn, zn) + log qφ(zn|xn)
7 Update θ := θ − η∇θL(φ, θ|xn, zn)
8 Update φ := φ − η∇φL(φ, θ|xn, zn)
9 until converged
10.2.2 Automatic differentiation VI
To apply Gaussian VI, we need to transform constrained parameters (such as variance terms) to
unconstrained form, so they live in R
D. This technique can be used for any distribution for which
we can define a bijection to R
D. This approach is called automatic differentiation variational
inference or ADVI [Kuc+16]. We give the details below.
10.2.2.1 Basic idea
Our goal is to approximate the posterior p(θ|D) ∝ p(θ)p(D|θ), where θ ∈ Θ lives in some D￾dimensional constrained parameter space. Let T : Θ → R
D be a bijective mapping that maps from
the constrained space Θ to the unconstrained space R
D. with inverse T
−1
: R
D → Θ. Let u = T(θ)
be the unconstrained latent variables. We will use a Gaussian variational approximation to the
posterior for u, i.e.,: qψ(u) = N (u|µd
, Σ), where ψ = (µ, Σ).
By the change of variable formula Equation (2.257), we have
p(u) = p(T
−1
(u))| det(JT −1 (u))| (10.62)
where JT −1 is the Jacobian of the inverse mapping u → θ. Hence the ELBO becomes
Ł(ψ) = Eu∼qψ(u)

log p(D|T
−1
(u)) + log p(T
−1
(u)) + log | det(JT −1 (u))|

+ H(ψ) (10.63)
This is a tractable objective, assuming the Jacobian is tractable, since the final entropy term is
available in closed form, and we can use a Monte Carlo approximation of the expectation over u.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.2. GRADIENT-BASED VI
Since the objective is stochastic, and reparamterizable, we can use SGD to optimize it. However,
[Ing20] propose deterministic ADVI, in which the samples ǫs ∼ N (0, I) are held fixed during
the optimization process. This is called the common random numbers trick (Section 11.6.1), and
makes the objective a deterministic function; this allows for the use of more powerful second-order
optimization methods, such as BFGS. (Of course, if the dataset is large, we might need to use
minibatch subsampling, which reintroduces stochasticity.)
10.2.2.2 Example: ADVI for beta-binomial model
To illustrate ADVI, we consider the 1d beta-binomial model from Section 7.4.4. We want to
approximate p(θ|D) using the prior p(θ) = Beta(θ|a, b) and likelihood p(D|θ) = Q
i Ber(yi
|θ), where
the sufficient statistics are N1 = 10, N0 = 1, and the prior is uninformative, a = b = 1. We use the
transformation θ = T
−1
(z) = σ(z), and optimize the ELBO with SGD. The results of this method
are shown in Figure 7.4 and show that the Gaussian fit is a good approximation, despite the skewed
nature of the posterior.
10.2.2.3 Example: ADVI for GMMs
In this section, we use ADVI to approximate the posterior of the parameters of a mixture of Gaussians.
The difference from the VBEM algorithm of Section 10.3.6 is that we use ADVI combined with a
Gaussian variational posterior, rather than using a mean field approximation defined by a product of
conjugate distributions.
To apply ADVI, we marginalize out the discrete local discrete latents mn ∈ {1, . . . , K} analytically,
so the likelihood has the form
p(D|θ) = Y
N
n=1 "X
K
k=1
πkN (yn|µk
, diag(Σk))#
(10.64)
We use an uniformative Gaussian prior for the µk
, a uniform LKJ prior for the Lk, a log-normal
prior for the σk, and a uniform Dirichlet prior for the mixing weights π. (See [Kuc+16, Fig 21]
for a definition of the model in STAN syntax.) The posterior approximation for the unconstrained
parameters is a block-diagonal gaussian. q(u) = N (u|ψµ, ψΣ), where the unconstrained parameters
are computed using suitable bijections (see code for details).
We apply this method to the Old Faithful dataset from Figure 10.12, using K = 10 mixture
components. The results are shown in Figure 10.7. In the top left, we show the special case where we
constrain the posterior to be a MAP estimate, by setting ψΣ = 0. We see that there is no sparsity in
the posterior, since there is no Bayesian “Occam factor” from marginalizing out the parameters. In
panels c–d, we show 3 samples from the posterior. We see that the Bayesian method strongly prefers
just 2 mixture components, although there is a small amount of support for some other Gaussian
components (shown by the faint ellipses).
10.2.2.4 More complex posteriors
We can combine ADVI with any of the improved posterior approximations that we discuss in
Section 10.4 — such as Gaussian mixtures [Mor+21b] or normalizing flows [ASD20] — to create a
high-quality, automatic approximate inference scheme.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license448
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−1 0 1
−2
−1
0
1
2
data
loc
0.00 0.25
Weights
0
1
2
3
4
5
6
7
8
9
Mixture components
(a)
−1 0 1
−2
−1
0
1
2
data
loc
0.0 0.5
Weights
0
1
2
3
4
5
6
7
8
9
Mixture components
(b)
−1 0 1
−2
−1
0
1
2
data
loc
0.0 0.5
Weights
0
1
2
3
4
5
6
7
8
9
Mixture components
(c)
−1 0 1
−2
−1
0
1
2
data
loc
0.0 0.5
Weights
0
1
2
3
4
5
6
7
8
9
Mixture components
(d)
Figure 10.7: Posterior over the mixing weights (histogram) and the means and covariances of each Gaussian
mixture component, using K = 10, when fitting the model to the Old Faithful dataset from Figure 10.12. (a)
MAP approximation. (b-d) 3 samples from the Gaussian approximation. The intensity of the shading is
proportional to the mixture weight. Generated by gmm_advi_bijax.ipynb.
10.2.3 Blackbox variational inference
In this section, we assume that we can evaluate L˜(ψ, z) = log p(z, x) − log qψ(z) pointwise, but
we do not assume we can take gradients of this function. (For example, z may contain discrete
variables.) We are thus treating the model as a “blackbox”. Hence this approach is called blackbox
variational inference or BBVI [RGB14; ASD20].
10.2.3.1 Estimating the gradient using REINFORCE
To estimate the gradient of the ELBO, we will use the score function estimator, also called the
REINFORCE estimator (Section 6.3.4). In particular, suppose we write the ELBO as
Ł(ψ) = Eq(z|ψ)
h
L˜(ψ, z)
i
= Eq(z|ψ)
[log p(x, z) − log q(z|ψ)] (10.65)
Then from Equation (6.58) we have
∇ψŁ(ψ) = Eq(z|ψ)
h
L˜(ψ, z)∇ψ log q(z|ψ)
i
(10.66)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.3. COORDINATE ASCENT VI
We can then compute a Monte Carlo approximation to this:
∇ψ\Ł(ψt
) = 1
S
X
S
s=1
L˜(ψ, zs)∇ψ log qψ(zs)|ψ=ψt
(10.67)
We can pass this to any kind of gradient optimizer, such as SGD or Adam.
10.2.3.2 Reducing the variance using control variates
In practice, the variance of this estimator is quite large, so it is important to use methods such
as control variates or CV (Section 6.3.4.1). To see how this works, consider the naive gradient
estimator in Equation (10.67), which for the i’th component we can write as
∇ψ\i
Ł(ψt
)
naive
=
1
S
X
S
s=1
g˜i(zs) (10.68)
g˜i(zs) = gi(zs) × L˜(ψ, zs) (10.69)
gi(zs) = ∇ψi
log qψ(zs) (10.70)
The control variate version of this can be obtained by replacing g˜i(zs) with
g˜
cv
i
(z) = ˜gi(z) + ci(E [bi(z)] − bi(z)) (10.71)
where bi(z) is a baseline function and ci
is some constant, to be specified below. A convenient
baseline is the score function, bi(z) = ∇ψi
log qψi
(z) = gi(z), since this is correlated with g˜i(z), and
has the property that E [bi(z)] = 0, since the expected value of the score function is zero, as we
showed in Equation (3.44). Hence
g˜
cv
i
(z) = g˜i(z) − cigi(z) = gi(z)(L˜(ψ, z) − ci) (10.72)
so the CV estimator is given by
∇ψ\i
Ł(ψt
)
cv
=
1
S
X
S
s=1
gi(zs) × (L˜(ψ, zs) − ci) (10.73)
One can show that the optimal ci that minimizes the variance of the CV estimator is
ci =
Cov h
gi(z)L˜(ψ, z), gi(z)
i
V [gi(z)] (10.74)
For more details, see e.g., [TND21].
10.3 Coordinate ascent VI
A common approximation in variational inference is to assume that all the latent variables are
independent, i.e.,
qψ(z) = Y
J
j=1
qj (zj ) (10.75)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license450
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where J is the number of hidden variables, and qj (zj ) is shorthand for qψj
(zj ), where ψj are the
variational parameters for the j’th distribution. This is called the mean field approximation.
From Equation (10.11), the ELBO becomes
Ł(ψ) = Z
qψ(z) log pθ(x, z)dz +
X
J
j=1
H(qj ) (10.76)
since the entropy of a product distribution is the sum of entropies of each component in the product.
The first term also often decomposes according to the Markov properties of the graphical model.
This allows us to use a coordinate ascent optimization scheme to estimate each ψj
, as we explain
in Section 10.3.1. This is called coordinate ascent variational inference or CAVI, and is an
alternative to gradient-based VI.
10.3.1 Derivation of CAVI algorithm
In this section, we derive the coordinate ascent variational inference (CAVI) procedure.
To derive the update equations, we initially assume there are just 3 discrete latent variables, to
simplify notation. In this case the ELBO is given by
Ł(q1, q2, q3) = X
z1
X
z2
X
z3
q1(z1)q2(z2)q3(z3) log ˜p(z1, z2, z3) +X
3
j=1
H(qj ) (10.77)
where we define p˜(z) = pθ(z, x) for brevity. We will optimize this wrt each qi
, one at a time, keeping
the others fixed.
Let us look at the objective for q3:
Ł3(q3) = X
z3
q3(z3)
"X
z1
X
z2
q1(z1)q2(z2) log ˜p(z1, z2, z3)
#
+ H(q3) + const (10.78)
=
X
z3
q3(z3) [g3(z3) − log q3(z3)] + const (10.79)
where
g3(z3) ,
X
z1
X
z2
q1(z1)q2(z2) log ˜p(z1, z2, z3) = Ez−3
[log ˜p(z1, z2, z3)] (10.80)
where z−3 = (z1, z2) is all variables except z3. Here g3(z3) can be interpreted as an expected negative
energy (log probability). We can convert this into an unnormalized probability distribution by
defining
˜f3(z3) = exp(g3(z3)) (10.81)
which we can normalize to get
f3(z3) =
˜f3(z3)
P
z
′
3
˜f3(z
′
3
)
∝ exp(g3(z3)) (10.82)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.3. COORDINATE ASCENT VI
Since g3(z3) ∝ log f3(z3) we get
Ł3(q3) = X
z3
q3(z3) [log f3(z3) − log q3(z3)] + const = −DKL (q3 k f3) + const (10.83)
Since DKL (q3 k f3) achieves its minimal value of 0 when q3(z3) = f3(z3) for all z3, we see that
q
∗
3
(z3) = f3(z3).
Now suppose that the joint distribution is defined by a Markov chain, where z1 → z2 → z3, so
z1 ⊥ z3|z2. Hence log ˜p(z1, z2, z3) = log ˜p(z2, z3|z1) + log ˜p(z1), where the latter term is independent
of q3(z3). Thus the ELBO simplifies to
Ł3(q3) = X
z3
q3(z3)
"X
z2
q2(z2) log ˜p(z2, z3)
#
+ H(q3) + const (10.84)
=
X
z3
q3(z3) [log f3(z3) − log q3(z3)] + const (10.85)
where
f3(z3) ∝ exp "X
z2
q2(z2) log ˜p(z2, z3)
#
= exp 
Ezmb3
[log ˜p(z2, z3)]
(10.86)
where zmb3 = z2 is the Markov blanket (Section 4.2.4.3) of z3. As before, the optimal variational
distribution is given by q3(z3) = f3(z3).
In general, when we have J groups of variables, the optimal variational distribution for the j’th
group is given by
qj (zj ) ∝ exp h
Ezmbj

log ˜p(zj , zmbj
)

i
(10.87)
(Compare to the equation for Gibbs sampling in Equation (12.19).) The CAVI method simply
computes qj for each dimension j in turn, in an iterative fashion (see Algorithm 10.4). Convergence
is guaranteed since the bound is convex wrt each of the factors qi
[Bis06, p. 466].
Algorithm 10.4: Coordinate ascent variational inference (CAVI).
1 Initialize qj (zj ) for j = 1 : J
2 foreach t = 1 : T do
3 foreach j = 1 : J do
4 Compute gj (zj ) = Ezmbi
[log ˜p(zi
, zmbi
)]
5 Compute qj (zj ) ∝ exp(gj (zj ))
Note that the functional form of the qi distributions does not need to be specified in advance, but
will be determined by the form of the log joint. This is therefore called free-form VI, as opposed to
fixed-form, where we explicitly choose a convenient distributional type for q (we discuss fixed-form
VI in Section 10.2). We give some examples below that will make this clearer.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license452
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
x3 x4
z3 z4
x1
x2
z1 z2
Figure 10.8: A grid-structured MRF with hidden nodes zi and local evidence nodes xi. The prior p(z) is an
undirected Ising model, and the likelihood p(x|z) = Q
i
p(xi|zi) is a directed fully factored model.
10.3.2 Example: CAVI for the Ising model
In this section, we apply CAVI to perform mean field inference in an Ising model (Section 4.3.2.1),
which is a kind of Markov random field defined on binary random variables, zi ∈ {−1, +1}, arranged
in a 2d grid.
Originally Ising models were developed as models of atomic spins for magnetic materials, although
we will apply them to an image denoising problem. Specifically, let zi be the hidden value of pixel i,
and xi ∈ R be the observed noisy value. See Figure 10.8 for the graphical model.
Let Li(zi) , log p(xi
|zi) be the log likelihood for the i’th pixel (aka the local evidence for node i
in the graphical model). The overall likelihood has the form
p(x|z) = Y
i
p(xi
|zi) = exp(X
i
Li(zi)) (10.88)
Our goal is to approximate the posterior p(z|x). We will use an Ising model for the prior:
p(z) = 1
Z0
exp(−E0(z)) (10.89)
E0(z) = −
X
i∼j
Wij zizj (10.90)
where we sum over each i − j edge. Therefore the posterior has the form
p(z|x) = 1
Z(x)
exp(−E(z)) (10.91)
E(z) = E0(z) −
X
i
Li(zi) (10.92)
We will now make the following fully factored approximation:
q(z) = Y
i
qi(zi) = Y
i
Ber(zi
|µi) (10.93)
where µi = Eqi
[zi
] is the mean value of node i. To derive the update for the variational parameter µi
,
we first compute the unnormalized log joint, log ˜p(z) = −E(z), dropping terms that do not involve
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.3. COORDINATE ASCENT VI
zi
:
log ˜p(z) = zi
X
j∈nbri
Wij zj + Li(zi) + const (10.94)
This only depends on the states of the neighboring nodes. Hence
qi(zi) ∝ exp(Eq−i(z)
[log ˜p(z)]) = exp

zi
X
j∈nbri
Wijµj + Li(zi)

 (10.95)
where q−i(z) = Q
j6=i
q(zj ). Thus we replace the states of the neighbors by their average values.
(Note that this replaces binary variables with continuous ones.)
We now simplify this expression. Let mi =
P
j∈nbri Wijµj be the mean field influence on node i.
Also, let L
+
i , Li(+1) and L
−
i , Li(−1). The approximate marginal posterior is given by
qi(zi = 1) = e
mi+L
+
i
emi+L
+
i + e
−mi+L
−
i
=
1
1 + e
−2mi+L
−
i −L
+
i
= σ(2ai) (10.96)
ai , mi + 0.5(L
+
i − L
−
i
) (10.97)
Similarly, we have qi(zi = −1) = σ(−2ai). From this we can compute the new mean for site i:
µi = Eqi
[zi
] = qi(zi = +1) · (+1) + qi(zi = −1) · (−1) (10.98)
=
1
1 + e−2ai
−
1
1 + e
2ai
=
e
ai
e
ai + e−ai
−
e
−ai
e−ai + e
ai
= tanh(ai) (10.99)
We can turn the above equations into a fixed point algorithm by writing
µ
t
i = tanh


X
j∈nbri
Wijµ
t−1
j + 0.5(L
+
i − L
−
i
)

 (10.100)
Following [MWJ99], we can use damped updates of the following form to improve convergence:
µ
t
i = (1 − λ)µ
t−1
i + λ tanh


X
j∈nbri
Wijµ
t−1
j + 0.5(L
+
i − L
−
i
)

 (10.101)
for 0 < λ < 1. We can update all the nodes in parallel, or update them asynchronously.
Figure 10.9 shows the method in action, applied to a 2d Ising model with homogeneous attractive
potentials, Wij = 1. We use parallel updates with a damping factor of λ = 0.5. (If we don’t use
damping, we tend to get “checkerboard” artifacts.)
10.3.3 Variational Bayes
In Bayesian modeling, we treat the parameters θ as latent variables. Thus our goal is to approximate
the parameter posterior p(θ|D) ∝ p(θ)p(D|θ). Applying VI to this problem is called variational
Bayes [Att00].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license454
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
sample 1, meanfieldH
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
(a)
sample 3, meanfieldH
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
(b)
mean after 15 sweeps of meanfieldH
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
(c)
Figure 10.9: Example of image denoising using mean field (with parallel updates and a damping factor of 0.5).
We use an Ising prior with Wij = 1 and a Gaussian noise model with σ = 2. We show the results after 1, 3
and 15 iterations across the image. Compare to Figure 12.3, which shows the results of using Gibbs sampling.
Generated by ising_image_denoise_demo.ipynb.
In this section, we assume there are no latent variables except for the shared global parameters, so
the model has the form
p(θ, D) = p(θ)
Y
N
n=1
p(Dn|θ) (10.102)
These conditional independencies are illustrated in Figure 10.5a.
We will fit the variational posterior by maximizing the ELBO
Ł(ψθ
|D) = Eq(θ|ψθ
)
[log p(θ, D)] + H(q(θ|ψθ
)) (10.103)
We will assume the variational posterior factorizes over the parameters:
q(θ|ψθ
) = Y
j
q(θj |ψθj
) (10.104)
We can then update each ψθj
using CAVI (Section 10.3.1).
10.3.4 Example: VB for a univariate Gaussian
Consider inferring the parameters of a 1d Gaussian. The likelihood is given by p(D|θ) = QN
n=1 N (xn|µ, λ−1
),
where µ is the mean and λ is the precision. Suppose we use a conjugate prior of the form
p(µ, λ) = N (µ|µ0,(κ0λ)
−1
)Ga(λ|a0, b0) (10.105)
It is possible to derive the posterior p(µ, λ|D) for this model exactly, as shown in Section 3.4.3.3.
However, here we use the VB method with the following factored approximate posterior:
q(µ, λ) = q(µ|ψµ
)q(λ|ψλ
) (10.106)
We do not need to specify the forms for the distributions q(µ|ψµ
) and q(λ|ψλ
); the optimal forms
will “fall out” automatically during the derivation (and conveniently, they turn out to be Gaussian
and gamma respectively). Our presentation follows [Mac03, p429].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.3. COORDINATE ASCENT VI
10.3.4.1 Target distribution
The unnormalized log posterior has the form
log ˜p(µ, λ) = log p(µ, λ, D) = log p(D|µ, λ) + log p(µ|λ) + log p(λ) (10.107)
=
N
2
log λ −
λ
2
X
N
n=1
(xn − µ)
2 −
κ0λ
2
(µ − µ0)
2
+
1
2
log(κ0λ) + (a0 − 1) log λ − b0λ + const (10.108)
10.3.4.2 Updating q(µ|ψµ)
The optimal form for q(µ|ψµ
) is obtained by averaging over λ:
log q(µ|ψµ
) = Eq(λ|ψλ)
[log p(D|µ, λ) + log p(µ|λ)] + const (10.109)
= −
Eq(λ|ψλ)
[λ]
2
(
κ0(µ − µ0)
2 +
X
N
n=1
(xn − µ)
2
)
+ const (10.110)
By completing the square one can show that q(µ|ψµ
) = N (µ|µN , κ−1
N ), where
µN =
κ0µ0 + Nx
κ0 + N
, κN = (κ0 + N)Eq(λ|ψλ)
[λ] (10.111)
At this stage we don’t know what q(λ|ψλ
) is, and hence we cannot compute E [λ], but we will derive
this below.
10.3.4.3 Updating q(λ|ψλ)
The optimal form for q(λ|ψλ
) is given by
log q(λ|ψλ
) = Eq(µ|ψµ)
[log p(D|µ, λ) + log p(µ|λ) + log p(λ)] + const (10.112)
= (a0 − 1) log λ − b0λ +
1
2
log λ +
N
2
log λ
−
λ
2
Eq(µ|ψµ)
"
κ0(µ − µ0)
2 +
X
N
n=1
(xn − µ)
2
#
+ const (10.113)
We recognize this as the log of a gamma distribution, hence q(λ|ψλ
) = Ga(λ|aN , bN ), where
aN = a0 +
N + 1
2
(10.114)
bN = b0 +
1
2
Eq(µ|ψµ)
"
κ0(µ − µ0)
2 +
X
N
n=1
(xn − µ)
2
#
(10.115)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license456
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.3.4.4 Computing the expectations
To implement the updates, we have to specify how to compute the various expectations. Since
q(µ) = N (µ|µN , κ−1
N ), we have
Eq(µ)
[µ] = µN (10.116)
Eq(µ)

µ
2

=
1
κN
+ µ
2
N (10.117)
Since q(λ) = Ga(λ|aN , bN ), we have
Eq(λ)
[λ] = aN
bN
(10.118)
We can now give explicit forms for the update equations. For q(µ) we have
µN =
κ0µ0 + Nx
κ0 + N
(10.119)
κN = (κ0 + N)
aN
bN
(10.120)
and for q(λ) we have
aN = a0 +
N + 1
2
(10.121)
bN = b0 +
1
2
κ0(E

µ
2

+ µ
2
0 − 2E [µ] µ0) + 1
2
X
N
n=1
￾
x
2
n + E

µ
2

− 2E [µ] xn

(10.122)
We see that µN and aN are in fact fixed constants, and only κN and bN need to be updated
iteratively. (In fact, one can solve for the fixed points of κN and bN analytically, but we don’t do
this here in order to illustrate the iterative updating scheme.)
10.3.4.5 Illustration
Figure 10.10 gives an example of this method in action. The green contours represent the exact
posterior, which is Gaussian-gamma. The dotted red contours represent the variational approximation
over several iterations. We see that the final approximation is reasonably close to the exact solution.
However, it is more “compact” than the true distribution. It is often the case that mean field inference
underestimates the posterior uncertainty, for reasons explained in Section 5.1.4.1.
10.3.4.6 Lower bound
In VB, we maximize a lower bound on the log marginal likelihood:
Ł(ψθ
|D) ≤ log p(D) = log Z Z p(D|µ, λ)p(µ, λ)dµdλ (10.123)
It is very useful to compute the lower bound itself, for three reasons. First, it can be used to assess
convergence of the algorithm. Second, it can be used to assess the correctness of one’s code: as with
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.3. COORDINATE ASCENT VI
−1.0 −0.5 0.0 0.5 1.0
µ
0.0
0.5
1.0
1.5
2.0
τ
Exact
VB
(a)
−1.0 −0.5 0.0 0.5 1.0
µ
0.0
0.5
1.0
1.5
2.0
τ
Exact
VB
(b)
−1.0 −0.5 0.0 0.5 1.0
µ
0.0
0.5
1.0
1.5
2.0
τ
Exact
VB
(c)
−1.0 −0.5 0.0 0.5 1.0
µ
0.0
0.5
1.0
1.5
2.0
τ
Exact
VB
(d)
Figure 10.10: Factored variational approximation (orange) to the Gaussian-gamma distribution (blue). (a)
Initial guess. (b) After updating q(µ|ψµ
). (c) After updating q(λ|ψλ
). (d) At convergence (after 5 iterations).
Adapted from Fig. 10.4 of [Bis06]. Generated by unigauss_vb_demo.ipynb.
EM, if we use CAVI to optimize the objective, the bound should increase monotonically at each
iteration, otherwise there must be a bug. Third, the bound can be used as an approximation to
the marginal likelihood, which can be used for Bayesian model selection or empirical Bayes (see
Section 10.1.3). In the case of the current model, one can show that the lower bound has the following
form:
Ł = const +
1
2
ln 1
κN
+ ln Γ(aN ) − aN ln bN (10.124)
10.3.5 Variational Bayes EM
In Bayesian latent variable models, we have two forms of hidden variables: local (or per example)
hidden variables zn, and global (shared) hidden variables θ, which represent the parameters of the
model. See Figure 10.5b for an illustration. (Note that the parameters, which are fixed in number,
are sometimes called intrinsic variables, whereas the local hidden variables are called extrinsic
variables.) If h = (θ, z1:N ) represents all the hidden variables, then the joint distribution is given
by
p(h, D) = p(θ, z1:N , D) = p(θ)
Y
N
n=1
p(zn|θ)p(xn|zn, θ) (10.125)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license458
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We will make the following mean field assumption:
q(θ, z1:N |ψ1:N , ψθ
) = q(θ|ψθ
)
Y
N
n=1
q(zn|ψn) (10.126)
where ψ = (ψ1:N , ψθ
).
We will use VI to maximize the ELBO:
Ł(ψ|D) = Eq(θ,z1:N |ψ1:N ,ψθ
)
[log p(z1:N , θ, D) − log q(θ, z1:N )] (10.127)
If we use the mean field assumption, then we can apply the CAVI approach to optimize each set of
variational parameters. In particular, we can alternate between optimizing the qn(zn) in parallel,
independently of each other, with q(θ) held fixed, and then optimizing q(θ) with the qn held fixed.
This is known as variational Bayes EM [BG06]. It is similar to regular EM, except in the E step,
we infer an approximate posterior for zn averaging out the parameters (instead of plugging in a point
estimate), and in the M step, we update the parameter posterior parameters using the expected
sufficient statistics.
Now suppose we approximate q(θ) by a delta function, q(θ) = δ(θ − θˆ). The Bayesian LVM ELBO
objective from Equation (10.127) simplifies to the “LVM ELBO”:
Ł(θ, ψ1:N |D) = Eq(z1:N |ψ1:N )
[log p(θ, D, z1:N ) − log q(z1:N |ψ1:N )] (10.128)
We can optimize this using the variational EM algorithm, which is a CAVI algorithm which updates
the ψn in parallel in the variational E step, and then updates θ in the M step.
VEM is simpler than VBEM since in the variational E step, we compute q(zn|xn, θˆ), instead of
Eθ[q(zn|xn, θ)]; that is, we plug in a point estimate of the model parameters, rather than averaging
over the parameters. For more details on VEM, see Section 10.1.3.
10.3.6 Example: VBEM for a GMM
Consider a standard Gaussian mixture model (GMM):
p(z, x|θ) = Y
n
Y
k
π
znk
k N (xn|µk
, Λ
−1
k
)
znk (10.129)
where znk = 1 if datapoint n belongs to cluster k, and znk = 0 otherwise. Our goal is to approximate
the posterior p(z, θ|x) under the following conjugate prior
p(θ) = Dir(π|
`α)
Y
k
N (µk
| m` ,(
`κ Λk)
−1
)Wi(Λk|
`
L,
`ν) (10.130)
where Λk is the precision matrix for cluster k. For the mixing weights, we usually use a symmetric
prior, `α= α01.
The exact posterior p(z, θ|D) is a mixture of KN distributions, corresponding to all possible
labelings z, which is intractable to compute. In this section, we derive a VBEM algorithm, which
will approximate the posterior around a local mode. We follow the presentation of [Bis06, Sec 10.2].
(See also Section 10.2.1.5 and Section 10.2.2.3, where we discuss variational approximations based on
stochastic gradient descent, which can scale better to large datasets compared to VBEM.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.3. COORDINATE ASCENT VI
10.3.6.1 The variational posterior
We will use the standard mean field approximation to the posterior: q(θ, z1:N ) = q(θ)
Q
n
qn(zn). At
this stage we have not specified the forms of the q functions; these will be determined by the form of
the likelihood and prior. Below we will show that the optimal forms are as follows:
qn(zn) = Cat(zn|rn) (10.131)
q(θ) = Dir(π|
aα)
Y
k
N (µk
| ma
k,(
aκk Λk)
−1
)Wi(Λk|
a
Lk,
aνk) (10.132)
where rn are the posterior responsibilities, and the parameters with hats on them are the hyperpa￾rameters from the prior updated with data.
10.3.6.2 Derivation of q(θ) (variational M step)
Using the mean field recipe in Algorithm 10.4, we write down the log joint, and take expectations
over all variables except θ, so we average out the zn wrt q(zn) = Cat(zn|rn):
log q(θ) = log p(π) +X
n
Eq(zn)
[log p(zn|π)]
| {z }
Lπ
+
X
k






log p(µk, Λk)
X
n
Eq(zn)
[znk] log N (xn|µk
, Λ
−1
k
)
| {z }
Lµk,Λk






+ const (10.133)
Since the expected log joint factorizes into a term involving π and terms involving (µk
, Λk), we see
that the variational posterior also factorizes into the form
q(θ) = q(π)
Y
k
q(µk
, Λk) (10.134)
For the π term, we have
log q(π) = (α0 − 1)X
k
log πk +
X
k
X
n
rnk log πk + const (10.135)
Exponentiating, we recognize this as a Dirichlet distribution:
q(π) = Dir(π|
aα) (10.136)
aαk = α0 + Nk (10.137)
Nk =
X
n
rnk (10.138)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license460
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
For the µk and Λk terms, we have
q(µk
, Λk) = N (µk
| ma
k,(
aκk Λk)
−1
)Wi(Λk|
a
Lk,
aνk) (10.139)
aκk =
`κ +Nk (10.140)
ma
k = (`κ m` +Nkxk)/
aκk (10.141)
a
L
−1
k =
`
L
−1
+NkSk +
`κ Nk
`κ +Nk
(xk− m` )(xk− m` )
T
(10.142)
aνk =
`ν +Nk (10.143)
xk =
1
Nk
X
n
rnkxn (10.144)
Sk =
1
Nk
X
n
rnk(xn − xk)(xn − xk)
T
(10.145)
This is very similar to the M step for MAP estimation for GMMs, except here we are computing
the parameters of the posterior for θ rather than a point estimate θˆ.
10.3.6.3 Derivation of q(z) (variational E step)
The variational E step is more interesting, since it is quite different from the E step in regular EM,
because we need to average over the parameters, rather than condition on them. In particular, we
have
log q(z) = X
n
X
k
znk 
Eq(π)
[log πk] + 1
2
Eq(Λk)
[log |Λk|] −
D
2
log(2π)
−
1
2
Eq(θ)

(xn − µk
)
TΛk(xn − µk
)


+ const (10.146)
Using the fact that q(π) = Dir(π|
aα), one can show that
exp(Eq(π)
[log πk]) = exp(ψ(
aαk))
exp(ψ(
P
k′
aαk′ ))
, π˜k (10.147)
where ψ is the digamma function:
ψ(x) = d
dx log Γ(x) (10.148)
This takes care of the first term.
For the second term, one can show
Eq(Λk)
[log |Λk|] = X
D
j=1
ψ
 aνk +1 − j
2

+ D log 2 + log |
a
Lk | (10.149)
Finally, for the expected value of the quadratic form, one can show
Eq(µk,Λk)

(xn − µk
)
TΛk(xn − µk
)

= D
aκ
−1
k +
aνk (xn− ma
k)
T a
Lk (xn− ma
k) , Λ˜
k (10.150)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.3. COORDINATE ASCENT VI
(a) (b)
Figure 10.11: (a) We plot exp(ψ(x)) vs x. We see that this function performs a form of shrinkage, so that
small values get set to zero. (b) We plot Nk vs time for 4 different states (z values), starting from random
initial values. We perform a series of VBEM updates, ignoring the likelihood term. We see that states that
initially had higher counts get reinforced, and sparsely populated states get killed off. From [LK07]. Used with
kind permission of Percy Liang.
Thus we get that the posterior responsibility of cluster k for datapoint n is
rnk ∝ π˜kΛ˜
1
2
k
exp 
−
D
2
aκk
−
aνk
2
(xn− ma
k)
T a
Λk (xn− ma
k)

(10.151)
Compare this to the expression used in regular EM:
r
EM
nk ∝ πˆk|Λˆ
k|
1
2 exp 
−
1
2
(xn − µˆk
)
TΛˆ
k(xn − µˆk
)

(10.152)
where πˆk is the MAP estimate for πk. The significance of this difference is discussed in Section 10.3.6.4.
10.3.6.4 Automatic sparsity inducing effects of VBEM
In regular EM, the E step has the form given in Equation (10.152), whereas in VBEM, the E step has
the form given in Equation (10.151). Although they look similar, they differ in an important way. To
understand this, let us ignore the likelihood term, and just focus on the prior. From Equation (10.147)
we have
r
V B
nk = ˜πk =
exp(ψ(
aαk))
exp(ψ(
P
k′
aαk′ )) (10.153)
And from the usual EM MAP estimation equations for GMM mixing weights (see e.g., [Mur22, Sec
8.7.3.4]) we have
r
EM
nk = ˆπk =
aαk −1
P
k′ (
aαk′ −1) (10.154)
where aαk= α0 + Nk, and Nk =
P
n
rnk is the expected number of assignments to cluster k.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license462
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We know from Figure 2.6 that using α0 ≪ 1 causes π to be sparse, which will encourage rn to be
sparse, which will “kill off” unnecessary mixture components (i.e., ones for which Nk ≪ N, meaning
very few datapoints are assigned to cluster k). To encourage this sparsity promoting effect, let us set
α0 = 0. In this case, the updated parameters for the mixture weights are given by the following:
π˜k =
exp(ψ(Nk))
exp(ψ(
P
k′ Nk′ )) (10.155)
πˆk =
Nk − 1
P
k′ (Nk′ − 1) (10.156)
Now consider a cluster which has no assigned data, so Nk = 0. In regular EM, πˆk might end up
negative, as pointed out in [FJ02]. (This will not occur if we use maximum likelihood training, which
corresponds to α0 = 1, but this will not induce any sparsity, either.) This problem does not arise in
VBEM, since we use the digamma function, which is always positive, as shown in Figure 10.11(a).
More interestingly, let us consider the effect of these updates on clusters that have unequal,
but non-zero, number of assignments. Suppose we start with a random assignment of counts to 4
clusters, and iterate the VBEM algorithm, ignoring the contribution from the likelihood for simplicity.
Figure 10.11(b) shows how the counts Nk evolve over time. We notice that clusters that started out
with small counts end up with zero counts, and clusters that started out with large counts end up with
even larger counts. In other words, the initially popular clusters get more and more members. This
is called the rich get richer phenomenon; we will encounter it again in Supplementary Section 31.2,
when we discuss Dirichlet process mixture models.
The reason for this effect is shown in Figure 10.11(a): we see that exp(ψ(Nk)) < Nk, and is zero if
Nk is sufficiently small, similar to the soft-thresholding behavior induced by ℓ1-regularization (see
Section 15.2.6). Importantly, this effect of reducing Nk is greater on clusters with small counts.
We now demonstrate this automatic pruning method on a real example. We fit a mixture of 6
Gaussians to the Old Faithful dataset, using α0 = 0.001. Since the data only really “needs” 2 clusters,
the remaining 4 get “killed off”, as shown in Figure 10.12. In Figure 10.13, we plot the initial and
final values of αk; we see that aαk= 0 for all but two of the components k.
Thus we see that VBEM for GMMs with a sparse Dirichlet prior provides an efficient way to choose
the number of clusters. Similar techniques can be used to choose the number of states in an HMM
and other latent variable models. However, this variational pruning effect (also called posterior
collapse), is not always desirable, since it can cause the model to “ignore” the latent variables z if
the likelihood function p(x|z) is sufficiently powerful. We discuss this more in Section 21.4.
10.3.6.5 Lower bound on the marginal likelihood
The VBEM algorithm is maximizing the following lower bound
L =
X
z
Z
dθ q(z, θ) log p(x, z, θ)
q(z, θ)
≤ log p(x) (10.157)
This quantity increases monotonically with each iteration, as shown in Figure 10.14.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.3. COORDINATE ASCENT VI
−2 −1.5 −1 −0.5 0 0.5 1 1.5
−2.5
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
1
2
3
4
5
6
iter 1
(a)
−2 −1.5 −1 −0.5 0 0.5 1 1.5
−2.5
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
4
5
iter 94
(b)
Figure 10.12: We visualize the posterior mean parameters at various stages of the VBEM algorithm applied
to a mixture of Gaussians model on the Old Faithful data. Shading intensity is proportional to the mixing
weight. We initialize with K-means and use α0 = 0.001 as the Dirichlet hyper-parameter. (The red dot on the
right panel represents all the unused mixture components, which collapse to the prior at 0.) Adapted from
Figure 10.6 of [Bis06]. Generated by gmm_vb_em.ipynb.
1 2 3 4 5 6
0
10
20
30
40
50
60
70
80
90
iter 1
(a)
1 2 3 4 5 6
0
20
40
60
80
100
120
140
160
180
iter 94
(b)
Figure 10.13: We visualize the posterior values of αk for the model in Figure 10.12 after the first and last
iteration of the algorithm. We see that unnecessary components get “killed off ”. (Interestingly, the initially
large cluster 6 gets “replaced” by cluster 5.) Generated by gmm_vb_em.ipynb.
0 20 40 60 80 100
−1100
−1050
−1000
−950
−900
−850
−800
−750
−700
−650
−600
iter
lower bound on log marginal likelihood
variational Bayes objective for GMM on old faithful data
Figure 10.14: Lower bound vs iterations for the VB algorithm in Figure 10.12. The steep parts of the curve
correspond to places where the algorithm figures out that it can increase the bound by “killing off ” unnecessary
mixture components, as described in Section 10.3.6.6. The plateaus correspond to slowly moving the clusters
around. Generated by gmm_vb_em.ipynb.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license464
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.3.6.6 Model selection using VBEM
Section 10.3.6.4 discusses a way to choose K automatically, during model fitting, by “killing off”
unneeded clusters. An alternative approach is to fit several models, and then to use the variational
lower bound to the log marginal likelihood, L(K) ≤ log p(D|K), to approximate p(K|D). In particular,
if we have a uniform prior, we get the posterior
p(K|D) = p(D|K)
P
K′ p(D|K′)
≈
e
L(K)
P
K′ e
L(K′)
(10.158)
It is shown in [BG06] that the VB approximation to the marginal likelihood is more accurate than
BIC [BG06]. However, the lower bound needs to be modified somewhat to take into account the
lack of identifiability of the parameters. In particular, although VB will approximate the volume
occupied by the parameter posterior, it will only do so around one of the local modes. With K
components, there are K! equivalent modes, which differ merely by permuting the labels. Therefore a
more accurate approximation to the log marginal likelihood is to use log p(D|K) ≈ L(K) + log(K!).
10.3.7 Variational message passing (VMP)
In this section, we describe the CAVI algorithm for a generic model in which each complete conditional,
p(zj |z−j , x), is in the exponential family, i.e.,
p(zj |z−j , x) = h(zj ) exp[ηj
(z−j , x)
T
T (zj ) − Aj (ηj
(z−j , x))] (10.159)
where T (zj ) is the vector of sufficient statistics, ηj are the natural parameters, Aj is the log partition
function, and h(zj ) is the base distribution. This assumption holds if the prior p(zj ) is conjugate to
the likelihood, p(z−j , x|zj ).
If Equation (10.159) holds, the mean field update node j becomes
qj (zj ) ∝ exp [E [log p(zj |z−j , x)]] (10.160)
= exp h
log h(zj ) + E

ηj
(z−j , x)
T
T (zj ) − E

Aj (ηj
(z−j , x))
i
(10.161)
∝ h(zj ) exp h
E

ηj
(z−j , x)
T
T (zj )
i
(10.162)
Thus we update the local natural parameters using the expected values of the other nodes. These
become the new variational parameters:
ψj = E

ηj
(z−j , x)

(10.163)
We can generalize the above approach to work with any model where each full conditional is
conjugate. The resulting algorithm is known as variational message passing or VMP [WB05]
that works for any directed graphical model. VMP is similar to belief propagation (Section 9.3): at
each iteration, each node collects all the messages from its parents, and all the messages from its
children (which might require the children to get messages from their co-parents), and combines them
to compute the expected value of the node’s sufficient statistics. The messages that are sent are the
expected sufficient statistics of a node, rather than just a discrete or Gaussian distribution (as in BP).
Several software libraries have implemented this framework (see e.g., [Win; Min+18; Lut16; Wan17]).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.4. MORE ACCURATE VARIATIONAL POSTERIORS
VMP can be extended to the case where each full conditional is conditionally conjugate using the
CVI framework in Supplementary Section 10.3.1. See also [ABV21], where they use local Laplace
approximations to intractable factors inside of a message passing framework.
10.3.8 Autoconj
The VMP method requires the user to manually specify a graphical model; the corresponding node
update equations are then computed for each node using a lookup table, for each possible combination
of node types. It is possible to automatically derive these update equations for any conditionally
conjugate directed graphical model using a technique called autoconj [HJT18]. This is analogous to
the use of automatic differentiation (autodiff) to derive the gradient for any differentiable function.
(Note that autoconj uses autodiff internally.) The resulting full conditionals can be used for CAVI,
and also for Gibbs sampling (Section 12.3).
10.4 More accurate variational posteriors
In general, we can improve the tightness of the ELBO lower bound, and hence reduce the KL
divergence of our posterior approximation, if we use more flexible posterior families (although
optimizing within more flexible families may be slower, and can incur statistical error if the sample
size is low [Bha+21]). In this section, we give several examples of more accurate variational posteriors,
going beyond fully factored mean field approximations, or simple unimodal Gaussian approximations.
10.4.1 Structured mean field
The mean field assumption is quite strong, and can sometimes give poor results. Fortunately,
sometimes we can exploit tractable substructure in our problem, so that we can efficiently handle
some kinds of dependencies between the variables in the posterior in an analytic way, rather than
assuming they are all independent. This is called the structured mean field approach [SJ95].
A common example arises when appling VI to time series models, such as HMMs, where the
latent variables within each sequence are usually highly correlated across time. Rather than as￾suming a fully factorized posterior, we can treat each sequence zn,1:T as a block, and just assume
independence between blocks and the parameters: q(z1:N,1:T , θ) = q(θ)
QN
n=1 q(zn,1:T ), where
q(zn,1:T ) = Q
t
q(zn,t|zn,t−1). We can compute the joint distribution q(zn,1:T ), taking into account
the dependence between time steps, using the forwards-backwards algorithm. For details, see
[JW14; Fot+14]. A similar approach was applied to the factorial HMM model, as we discuss in
Supplementary Section 10.3.2.
An automatic way to derive a structured variational approximation to a probabilistic model,
specified by a probabilistic programming language, is discussed in [AHG20].
10.4.2 Hierarchical (auxiliary variable) posteriors
Suppose qφ(z|x) = Q
k
qφ(zk|x) is a factorized distribution, such as a diagonal Gaussian. This does
not capture dependencies between the latent variables (components of z). We could of course use a
full covariance matrix, but this might be too expensive.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license466
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
An alternative approach is to use a hierarchical model, in which we add auxiliary latent variables
a, which are used to increase the flexibility of the variational posterior. In particular, we can still
assume qφ(z|x, a) is conditionally factorized, but when we marginalize out a, we induce dependencies
between the elements of z, i.e.,
qφ(z|x) = Z
qφ(z|x, a)qφ(a|x)da 6=
Y
k
qφ(zk|x) (10.164)
This is called a hierarchical variational model [Ran16], or an auxiliary variable deep gener￾ative model [Maa+16].
In [TRB16], they model qφ(z|x, a) as a Gaussian process, which is a flexible nonparametric
distribution (see Chapter 18), where a are the inducing points. This combination is called a
variational GP.
10.4.3 Normalizing flow posteriors
Normalizing flows are a class of probability models which work by passing a simple source distribution,
such as a diagonal Gaussian, through a series of nonlinear, but invertible, mappings f to create a
more complex distribution. This can be used to get more accurate posterior approximations than
standard Gaussian VI, as we discuss in Section 23.1.2.2.
10.4.4 Implicit posteriors
In Chapter 26, we discuss implicit probability distributions, which are models which we can sample
from, but which we cannot evaluate pointwise. For example, consider passing a Gaussian noise term,
z0 ∼ N (0, I), through a nonlinear, non-invertible mapping f to create z = f(z0); it is easy to sample
from q(z), but it is intractable to evaluate the density q(z) (unlike with flows). This makes it hard to
evaluate the log density ratio log pθ(z)/qψ(z|x), which is needed to compute the ELBO. However, we
can use the same method as is used in GANs (generative adversarial networks, Chapter 26), in which
we train a classifier that discriminates prior samples from samples from the variational posterior by
evaluating T(x, z) = log qψ(z|x) − log pθ(z). See e.g., [TR19] for details.
10.4.5 Combining VI with MCMC inference
There are various ways to combine variational inference with MCMC to get an improved approximate
posterior. In [SKW15], they propose Hamiltonian variational inference, in which they train an
inference network to initialize an HMC sampler (Section 12.5). The gradient of the log posterior (wrt
the latents), which is needed by HMC, is given by
∇z log pθ(z|x) = ∇z log [pθ(x, z) − log pθ(x)] = ∇z log pθ(x, z) (10.165)
This is easy to compute. They use the final sample to approximate the posterior qφ(z|x). To compute
the entropy of this distribution, they also learn an auxiliary inverse inference network to reverse the
HMC Markov chain.
A simpler approach is proposed in [Hof17]. Here they train an inference network to initialize an
HMC sampler, using the standard ELBO for φ, but they optimize the generative parameters θ using
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.5. TIGHTER BOUNDS
a stochastic approximation to the log marginal likelihood, given by log pθ(z, x) where z is a sample
from the HMC chain. This does not require learning a reverse inference network, and avoids problems
with variational pruning, since it does not use the ELBO for training the generative model.
10.5 Tighter bounds
Another way to improve the quality of the posterior approximation is to optimize q wrt a bound that
is a tighter approximation to the log marginal likelihood compared to the standard ELBO. We give
some examples below.
10.5.1 Multi-sample ELBO (IWAE bound)
In this section, we discuss a method known as the importance weighted autoencoder or IWAE
[BGS16], which is a way to tighten the variational lower bound by using self-normalized importance
sampling (Section 11.5.2). (It can also be interpreted as standard ELBO maximization in an expanded
model, where we add extra auxiliary variables [CMD17; DS18; Tuc+19].)
Let the inference network qφ(z|x) be viewed as a proposal distribution for the target posterior
pθ(z|x). Define w
∗
s =
pθ(x,zs)
qφ(zs|x)
as the unnormalized importance weight for a sample, and ws =
w
∗
s /(
PS
s
′=1 w
∗
s
′ ) as the normalized importance weights. From Equation (11.43) we can compute an
estimate of the marginal likelihood p(x) using
pˆS(x|z1:S) ,
1
S
X
S
k=1
pθ(x, zs)
qφ(zs|x)
=
1
S
X
S
k=1
ws (10.166)
This is unbiased, i.e., Eqφ(z1:S |x)
[ˆpS(x|z1:S)] = p(x), where qφ(z1:S|x) = QS
s=1 qφ(zs|x). In addition,
since the estimator is always positive, we can take logarithms, and thus obtain a stochastic lower
bound on the log likelihood:
ŁS(φ, θ|x) , Eqφ(z1:S |x)
"
log 
1
S
X
S
s=1
ws
!# = Eqφ(z1:S |x)
[log ˆpS(z1:S)] (10.167)
≤ log Eqφ(z1:S |x)
[ˆpS(z1:S)] = log p(x) (10.168)
where we used Jensen’s inequality in the penultimate line, and the unbiased property in the last
line. This is called the multi-sample ELBO or IWAE bound [BGS16]. The gradients of this
expression wrt θ and φ are given in Equation (10.179). If S = 1, ŁS reduces to the standard ELBO:
Ł1(φ, θ|x) = Eq(z|x)
[log w] = Z
qφ(z|x) log pθ(z, x)
qφ(z|x)
dz (10.169)
One can show [BGS16] that increasing the number of samples S is guaranteed to make the bound
tighter, thus making it a better proxy for the log likelihood. Intuitively, averaging the S samples
inside the log removes the need for every sample zs to explain the data x. This encourages the
proposal distribution q to be less concentrated than the single-sample variational posterior.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license468
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.5.1.1 Pathologies of optimizing the IWAE bound
Unfortunately, increasing the number of samples in the IWAE bound can decrease the signal to noise
ratio, resulting in learning a worse model [Rai+18a]. Intuitively, the reason this happens is that
increasing S reduces the dependence of the bound on the quality of the inference network, which
makes the gradient of the ELBO wrt φ less informative (higher variance).
One solution to this is to use the doubly reparameterized gradient estimator [TL18b].
Another approach is to use alternative estimation methods that avoid ELBO maximization, such
as using the thermodynamic variational objective (see Section 10.5.2) or the reweighted wake-sleep
algorithm (see Section 10.6).
10.5.2 The thermodynamic variational objective (TVO)
In [MLW19; Bre+20b], they present the thermodynamic variational objective or TVO. This
is an alternative to IWAE for creating tighter variational bounds, which has certain advantages,
particularly for posteriors that are not reparameterizable (e.g., discrete latent variables). The
framework also has close connections with the reweighted wake-sleep algorithm from Section 10.6, as
we will see in Section 10.5.3.
The TVO technique uses thermodynamic integration, also called path sampling, which is
a technique used in physics and phylogenetics to approximate intractable normalization constants
of high dimensional distributions (see e.g., [GM98; LP06; FP08]). This is based on the insight
that it is easier to calculate the ratio of two unknown constants than to calculate the constants
themselves. This is similar to the idea behind annealed importance sampling (Section 11.5.4), but TI
is deterministic. For details, see [MLW19; Bre+20b].
10.5.3 Minimizing the evidence upper bound
Recall that the evidence lower bound or ELBO is given by
Ł(θ, φ|x) = log pθ(x) − DKL (qφ(z|x)) k pθ(z|x)) ≤ log pθ(x) (10.170)
By analogy, we can define the evidence upper bound or EUBO as follows:
EUBO(θ, φ|x) = log pθ(x) + DKL (pθ(z|x) k qφ(z|x)) ≥ log pθ(x) (10.171)
Minimizing this wrt the variational parameters φ, as an alternative to maxmimizing the ELBO, was
proposed in [MLW19], where they showed that it can sometimes converge to the true log pθ(x) faster.
The above bound is for a specific input x. If we sample x from the generative model, and
minimize Epθ(x)
[EUBO(θ, φ|x)] wrt φ, we recover the sleep phase of the wake-sleep algorithm (see
Section 10.6.2).
Now suppose we sample x from the empirical distribution, and minimize EpD(x)
[EUBO(θ, φ|x)]
wrt φ. To approximate the expectation, we can use self-normalized importance sampling, as in
Equation (10.188), to get
∇φEUBO(θ, φ|x) = X
S
s=1
ws∇φ log qφ(z
s
|x) (10.172)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.6. WAKE-SLEEP ALGORITHM
where ws = w
(s)/(
P
s
′ w
(s
′
)
), and w
(s) =
p(x,z
s
)
q(zs|φt
)
. This is equivalent to the “daydream” update (aka
“wake-phase φ update”) of the wake-sleep algorithm (see Section 10.6.3).
10.6 Wake-sleep algorithm
So far in this chapter we have focused on fitting latent variable models by maximizing the ELBO.
This has two main drawbacks. First, it does not work well when we have discrete latent variables,
because in such cases we cannot use the reparameterization trick; thus we have to use higher variance
estimators, such as REINFORCE (see Section 10.2.3). Second, even in the case where we can use
the reparameterization trick, the lower bound may not be very tight. We can improve the tightness
by using the IWAE multi-sample bound (Section 10.5.1), but paradoxically this may not result in
learning a better model, for reasons discussed in Section 10.5.1.1.
In this section, we discuss a different way to jointly train generative and inference models, which
avoids some of the problems with ELBO maximization. The method is known as the wake-sleep
algorithm [Hin+95; BB15b; Le+19; FT19]. because it alternates between two steps: in the wake
phase, we optimize the generative model parameters θ to maximize the marginal likelihood of the
observed data (we approximate log pθ(x) by drawing importance samples from the inference network),
and in the sleep phase, we optimize the inference model parameters φ to learn to invert the generative
model by training the inference network on labeled (x, z) pairs, where x are samples generated by
the current model parameters. This can be viewed as a form of adaptive importance sampling,
which iteratively improves its proposal, while simultaneously optimizing the model. We give further
details below.
10.6.1 Wake phase
In the wake phase, we minimize the KL divergence from the empirical distribution to the model’s
distribution:
L(θ) = DKL (pD(x) k pθ(x)) = EpD(x)
[− log pθ(x)] + const (10.173)
where pθ(x) = R
pθ(z)pθ(x|z)dz. This is equivalent to maximizing the likelihood of the observed
data:
ℓ(θ) = EpD(x)
[log pθ(x)] (10.174)
Since the log marginal likelihood log pθ(x) cannot be computed exactly, we will approximate it.
In the original wake-sleep paper, they proposed to use the ELBO lower bound. In the reweighted
wake-sleep (RWS) algorithm of [BB15b; Le+19], they propose to use the IWAE bound from
Section 10.5.1 instead. In particular, if we draw S samples from the inference network, zs ∼ qφ(z|x),
we get the following estimator:
ℓ(θ|φ, x) = log 
1
S
X
S
s=1
ws
!
(10.175)
where ws =
pθ(x,zs)
qφ(zs|x)
. Note that this is the same as the IWAE bound in Equation (10.168).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license470
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We now discuss how to compute the gradient of this objective wrt θ or φ. Using the log-derivative
trick, we have that
∇ log ws =
1
ws
∇ws (10.176)
Hence
∇ℓ(θ|φ, x) = 1
1
S
PS
s=1 ws
 
1
S
X
S
s=1
∇ws
!
(10.177)
=
1
PS
s=1 ws
 X
S
s=1
ws∇ log ws
!
(10.178)
=
X
S
s=1
ws∇ log ws (10.179)
where ws = ws/(
PS
s
′=1 ws
′ ).
In the case of the derivatives wrt θ, we have
∇θ log ws =
1
ws
∇θws =
qφ(zs|x)
pθ(x, zs)
∇θ
pθ(x, zs)
qφ(zs|x)
=
1
pθ(x, zs)
∇θpθ(x, zs) = ∇θ log pθ(x, zs)
(10.180)
and hence we get
∇θℓ(θ|φ, x)
X
S
s=1
ws∇ log pθ(x, zs) (10.181)
10.6.2 Sleep phase
In the sleep phase, we try to minimize the KL divergence between the true posterior (under the
current model) and the inference network’s approximation to that posterior:
L(φ) = Epθ(x)
[DKL (pθ(z|x) k qφ(z|x))] = Epθ(z,x)
[− log qφ(z|x)] + const (10.182)
Equivalently, we can maximize the following log likelihood objective:
ℓ(φ|θ) = E(z,x)∼pθ(z,x)
[log qφ(z|x)] (10.183)
where pθ(z, x) = pθ(z)pθ(x|z). We see that the sleep phase amounts to maximum likelihood training
of the inference network based on samples from the generative model. These “fantasy samples”,
created while the network “dreams”, can be easily generated using ancestral sampling (Section 4.2.5).
If we use S such samples, the objective becomes
ℓ(φ|θ) = 1
S
X
S
s=1
log qφ(z
′
s
|x
′
s
) (10.184)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.6. WAKE-SLEEP ALGORITHM
where (z
′
s
, x
′
s
) ∼ pθ(z, x). The gradient of this is given by
∇φℓ(φ|θ) = 1
S
X
S
s=1
∇φ log qφ(z
′
s
|x
′
s
) (10.185)
We do not require qφ(z
′
|x) to be reparameterizable, since the samples are drawn from a distribution
that is independent of φ. This means it is easy to apply this method to models with discrete latent
variables.
10.6.3 Daydream phase
The disadvantage of the sleep phase is that the inference network, qφ(z|x), is trying to follow a
moving target, pθ(z|x). Furthermore, it is only being trained on synthetic data from the model,
not on real data. The reweighted wake-sleep algorithm of [BB15b] proposed to learn the inference
network by using real data from the empirical distribution, in addition to fantasy data. They call
the case where you use real data the “wake-phase q update”, but we will call it the “daydream
phase”, since, unlike sleeping, the system uses real data x to update the inference model, instead of
fantasies.1
[Le+19] went further, and proposed to only use the wake and daydream phases, and to
skip the sleep phase entirely.
In more detail, the new objective which we want to minimize becomes
L(φ|θ) = EpD(x)
[DKL (pθ(z|x) k qφ(z|x))] (10.186)
We can compute a single sample approximation to the negative of the above expression as follows:
ℓ(φ|θ, x) = Epθ(z|x)
[log qφ(z|x)] (10.187)
where x ∼ pD. We can approximate this expectation using importance sampling, with qφ as the
proposal. This results in the following estimator of the gradient for each datapoint:
∇φℓ(φ|θ, x) = Z
pθ(z|x)∇φ log qφ(z|x)dz ≈
X
S
s=1
ws∇φ log qφ(zs|x) (10.188)
where zs ∼ qφ(zs|x) and ws are the normalized weights.
We see that Equation (10.188) is very similar to Equation (10.185). The key difference is that in
the daydream phase, we sample from (x, zs) ∼ pD(x)qφ(z|x), where x is a real datapoint, whereas
in the sleep phase, we sample from (x
′
s
, z
′
s
) ∼ pθ(z, x), where x
′
s
is generated datapoint.
10.6.4 Summary of algorithm
We summarize the RWS algorithm in Algorithm 10.5. The disadvantage of the RWS algorithm is
that it does not optimize a single well-defined objective, so it is not clear if the method will converge,
in contrast to ELBO maximization. On the other hand, the method is fairly simple, since it consists
of two alternating weighted maximum likelihood problems. It can also be shown to “sandwich” a
1. We thank Rif A. Saurous for suggesting this term.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license472
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Algorithm 10.5: One SGD update using wake-sleep algorithm.
1 Sample xn from dataset
2 Draw S samples from inference network: zs ∼ q(z|xn)
3 Compute unnormalized weights: ws =
p(xn,zs)
q(zs|xn)
4 Compute normalized weights: ws = P ws
S
s′=1 ws′
5 Optional: Compute estimate of log likelihood: log p(xn) = log( 1
S
PS
s=1 ws)
6 Wake phase: Update θ using PS
s=1 ws∇θ log pθ(zs, xn)
7 Daydream phase: Update φ using PS
s=1 ws∇φ log qφ(zs|xn)
8 Optional sleep phase: Draw S samples from model, (x
′
s
, z
′
s
) ∼ pθ(x, z) and update φ using
1
S
PS
s=1 ∇φ log qφ(z
′
s
|x
′
s
)
9 b
lower and upper bound of the log marginal likelihood. We can think of this in terms of the two joint
distributions pθ(x, z) = pθ(z)pθ(x|z) and qD,φ(x, z) = pD(x)qφ(z|x):
wake phase min
θ
DKL (qD,φ(x, z) k pθ(x, z)) (10.189)
daydream phase min
φ
DKL (pθ(x, z) k qD,φ(x, z)) (10.190)
10.7 Expectation propagation (EP)
One problem with lower bound maximization (i.e., standard VI) is that we are minimizing DKL (q k p),
which induces zero-forcing behavior, as we discussed in Section 5.1.4.1. This means that q(z|x)
tends to be too compact (over-confident), to avoid the situation in which q(z|x) > 0 but p(z|x) = 0,
which would incur infinite KL penalty.
Although zero-forcing can be desirable behavior for some multi-modal posteriors (e.g., mixture
models), it is not so reasonable for many unimodal posteriors (e.g., Bayesian logistic regression, or
GPs with log-concave likelihoods). One way to avoid this problem is to minimize DKL (p k q), which
is zero-avoiding, as we discussed in Section 5.1.4.1. This tends to result in broad posteriors, which
avoids overconfidence. In this section, we discuss expectation propagation or EP [Min01b], which
can be seen as a local approximation to DKL (p k q).
10.7.1 Algorithm
We assume the exact posterior can be written as follows:
p(θ|D) = 1
Zp
pˆ(θ), pˆ(θ) = p0(θ)
Y
K
k=1
fk(θ) (10.191)
where pˆ(θ) is the unnormalized posterior, p0 is the prior, fk corresponds to the k’th likelihood term
or local factor (also called a site potential). Here Zp = p(D)Z0 is the normalization constant for
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.7. EXPECTATION PROPAGATION (EP)
the posterior, where Z0 is the normalization constant for the prior. To simplify notation, we let
f0(θ) = p0(θ) be the prior.
We will approximate the posterior as follows:
q(θ) = 1
Zq
qˆ(θ), qˆ(θ) = p0(θ)
Y
K
k=1
˜fk(θ) (10.192)
where ˜fk ∈ Q is the approximate local factor, and Q is some tractable family in the exponential
family, usually a Gaussian [Gel+14b].
We will optimize each ˜fi
in turn, keeping the others fixed. We initialize each ˜fi using an
uninformative distribution from the family Q. so q(θ) = p0(θ).
To compute the new local factor ˜f
new
i
, we proceed as follows. First we compute the cavity
distribution by deleting the ˜fi from the approximate posterior by dividing it out:
q
cavity
−i
(θ) = q(θ)
˜fi(θ)
∝
Y
k6=i
˜fk(θ) (10.193)
This division operation can be implemented by subtracting the natural parameters, as explained in
Section 2.3.3.2. The cavity distribution represents the effect of all the factors except for fi (which is
approximated by ˜fi).
Next we (conceptually) compute the tilted distribution by multiplying the exact factor fi onto
the cavity distribution:
q
tilted
i
(θ) = 1
Zi
fi(θ)q
cavity
−i
(θ) (10.194)
where Zi =
R
q
cavity
−i
(θ)fi(θ)dθ is the normalization constant for the tilted distribution. This is the
result of combining the current approximation, excluding factor i, with the exact fi term.
Unfortunately, the resulting tilted distribution may be outside of our model family (e.g., if we
combine a Gaussian prior with a non-Gaussian likelihood). So we will approximate the tilted
distribution as follows:
q
proj
i
(θ) = proj(q
tilted
i
) , argmin
q˜∈Q
D(q
tilted
i
||q˜) (10.195)
This can be thought of as projecting the tilted distribution into the approximation family. If
D(q
tilted
i
||q) = DKL ￾
q
tilted
i
k q

, this can be done by moment matching, as shown in Section 5.1.4.2.
For example, suppose the cavity distribution is Gaussian, q
cavity
−i
(θ) = Nc(θ|r−i
, Q−i), using the
canonical parameterization. Then the log of the tilted distribution is given by
log q
tilted
i
(θ) = α log fi(θ) −
1
2
θ
TQ−iθ + r
T
−iθ + const (10.196)
Let θˆ be a local maximum of this objective. If Q is the set of Gaussians, we can compute the
projected tilted distribution as a Gaussian with the following parameters:
Q\i = −∇2
θ
log q
tilted
i
(θ)|θ=θˆ, r\i = Q\iθˆ (10.197)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens474
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Tilted distribu,on, p(yi|θ)g-i(θ)
Cavity distribu,on, g-i(θ)
Likelihood factor, p(yi|θ)
Figure 10.15: Combining a logistic likelihood factor fi = p(yi|θ) with the cavity prior, q
cavity
−i = g−i(θ), to get
the tilted distribution, q
tilted
i = p(yi|θ)g−i(θ). Adapted from Figure 2 of [Gel+14b].
This is called Laplace propagation [SVE04]. For more general distributions, we can use Monte
Carlo approximations; this is known as blackbox EP [HL+16a; Li+18c].
Finally, we compute a local factor that, if combined with the cavity distribution, would give the
same results as this projected distribution:
˜f
new
i
(θ) = q
proj
i
(θ)
q
cavity
−i
(θ)
(10.198)
We see that q
cavity
−i
(θ)
˜f
new
i
(θ) = q
proj
i
(θ), so combining this approximate factor with the cavity
distribution results in a distribution which is the best possible approximation (within Q) to the
results of using the exact factor.
10.7.2 Example
Figure 10.15 illustrates the process of combining a very non-Gaussian likelihood fi with a Gaussian
cavity prior q
cavity
−i
to yield a nearly Gaussian tilted distribution q
tilted
i
, which can then be approximated
by a Gaussian using projection.
Thus instead of trying to “Gaussianize” each likelihood term fi
in isolation (as is done, e.g., in
EKF), we try to find the best local factor ˜fi (within some family) that achieves approximately the
same effect, when combined with all the other terms (represented by the cavity distribution, q−i), as
using the exact factor fi
. That is, we choose a local factor that works well in the context of all the
other factors.
10.7.3 EP as generalized ADF
We can view EP as a generalization of the ADF algorithm discussed in Section 8.6. ADF is a
form of sequential Bayesian inference. At each step, it maintains a tractable approximation to
the posterior, qt(z) ∈ Q, updates it with the likelihood from the next observation, pˆt+1(z) ∝
qt(z)p(xt|z), and then projects the resulting updated posterior back to the tractable family using
qt+1 = argminq∈Q DKL (ˆpt+1 k q). ADF minimizes KL in the desired direction. However, it is a
sequential algorithm, designed for the online setting. In the batch setting, the method can given
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
10.7. EXPECTATION PROPAGATION (EP)
different results depending on the order in which the updates are performed. In addition, if we
perform multiple passes over the data, we will include the same likelihood terms multiple times,
resulting in an overconfident posterior. EP overcomes this problem.
10.7.4 Optimization issues
In practice, EP can be numerically unstable. For example, if we use Gaussians as our local factors,
we might end up with negative variance when we subtract the natural parameters. To reduce the
chance of this, it is common to use damping, in which we perform a partial update of each factor
with a step size of δ. More precisely, we change the final step to be the following:
˜f
new
i
(θ) = 
˜fi(θ)
1−δ
 
q
proj
i
(θ)
q
cavity
−i
!δ
(10.199)
This can be implemented by scaling the natural parameters by δ. [ML02] suggest δ = 1/K as a safe
strategy (where K is the number of factors), but this results in very slow convergence. [Gel+14b]
suggest starting with δ = 0.5, and then reducing to δ = 1/K over K iterations.
In addition to numerical stability, there is no guarantee that EP will converge in its vanilla form,
although empirically it can work well, especially with log-concave factors fi (e.g., as in GP classifiers).
10.7.5 Power EP and α-divergence
We also have a choice about what divergence measure D(q
tilted
i
||q) to use when we approximate
the tilted distribution. If we use DKL ￾
q
tilted
i
k q

, we recover classic EP, as described above. If
we use DKL ￾
q k q
tilted
i

, we recover the reverse KL used in standard variational inference. We can
generalize the above results by using α-divergences (Section 2.7.1.2), which allow us to interpolate
between mode seeking and mode covering behavior, as shown in Figure 2.20. We can optimize the
α-divergence by using the power EP method of [Min04].
Algorithmically, this is a fairly small modification to regular EP. In particular, we first compute the
cavity distribution, q
cavity
−i ∝
q
f˜α
i
; we then approximate the tilted distribution, q
proj
i = proj(q
cavity
−i
f
α
i
);
and finally we compute the new factor ˜f
new
i ∝

q
proj
i
q
cavity
−i
1/α
.
10.7.6 Stochastic EP
The main disadvantage of EP in the big data setting is that we need to store the ˜fn(θ) terms for
each datapoint n, so we can compute the cavity distribution. If θ has D dimensions, and we use full
covariance Gaussians, this requires O(ND2
) memory.
The idea behind stochastic EP [LHLT15] is to approximate the local factors with a shared factor
that acts like an aggregated likelihood, i.e.,
Y
N
n=1
fn(θ) ≈ ˜f(θ)
N (10.200)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licen476
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where typically fn(θ) = p(xn|θ). This exploits the fact that the posterior only cares about approxi￾mating the product of the likelihoods, rather than each likelihood separately. Hence it suffices for
˜f(θ) to approximate the average likelihood.
We can modify EP to this setting as follows. First, when computing the cavity distribution, we
use
q−1(θ) ∝ q(θ)/
˜f(θ) (10.201)
We then compute the tilted distribution
q\n(θ) ∝ fn(θ)q−1(θ) (10.202)
Next we derive the new local factor for this datapoint using moment matching:
˜fn(θ) = proj(q\n(θ))/q−1(θ) (10.203)
Finally, we perform a damped update of the average likelihood ˜f(θ) using this new local factor:
˜fnew(θ) = ˜fold(θ)
1−1/N ˜fn(θ)
1/N (10.204)
The ADF algorithm is similar to SEP, in that we compute the tilted distribution q\t ∝ ftqt−1 and
then project it, without needing to keep the ft factors. The difference is that instead of using the
cavity distribution q−1(θ) as a prior, it uses the posterior from the previous time step, qt−1. This
avoids the need to compute and store ˜f, but results in overconfidence in the batch setting.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 202311 Monte Carlo methods
11.1 Introduction
In this chapter, we discuss Monte Carlo methods, which are a stochastic approach to solving
numerical integration problems. The name refers to the “Monte Carlo” casino in Monaco; this was
used as a codename by von Neumann and Ulam, who invented the technique while working on
the atomic bomb during WWII. Since then, the technique has become widely adopted in physics,
statistics, machine learning, and many areas of science and engineering.
In this chapter, we give a brief introduction to some key concepts. In Chapter 12, we discuss
MCMC, which is the most widely used MC method for high-dimensional problems. In Chapter 13,
we discuss SMC, which is widely used for MC inference in state space models, but can also be applied
more generally. For more details on MC methods, see e.g., [Liu01; RC04; KTB11; BZ20].
11.2 Monte Carlo integration
We often want to compute the expected value of some function of a random variable, E [f(X)]. This
requires computing the following integral:
E [f(x)] = Z
f(x)p(x)dx (11.1)
where x ∈ R
n, f : R
n → R
m, and p(x) is the target distribution of X.
1
In low dimensions (up to, say,
3), we can compute the above integral efficiently using numerical integration, which (adaptively)
computes a grid, and then evaluates the function at each point on the grid.2 But this does not scale
to higher dimensions.
An alternative approach is to draw multiple random samples, xn ∼ p(x), and then to compute
E [f(x)] ≈
1
Ns
X
Ns
n=1
f(xn) (11.2)
This is called Monte Carlo integration. It has the advantage over numerical integration that
the function is only evaluated in places where there is non-negligible probability, so it does not
1. In many cases, the target distribution may be the posterior p(x|y), which can be hard to compute; in such problems,
we often work with the unnormalized distribution, p˜(x) = p(x, y), instead, and then normalize the results using
Z =
R
p(x, y)dx = p(y).
2. In 1d, numerical integration is called quadrature; in higher dimensions, it is called cubature [Sar13].478
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−2 0 2
−2
−1
0
1
2
Figure 11.1: Estimating π by Monte Carlo integration using 5000 samples. Blue points are inside the circle,
red points are outside. Generated by mc_estimate_pi.ipynb.
need to uniformly cover the entire space. In particular, it can be shown that the accuracy is in
principle independent of the dimensionality of x, and only depends on the number of samples Ns
(see Section 11.2.2 for details). The catch is that we need a way to generate the samples xn ∼ p(x)
in the first place. In addition, the estimator may have high variance. We will discuss this topic at
length in the sections below.
11.2.1 Example: estimating π by Monte Carlo integration
MC integration can be used for many applications, not just in ML and statistics. For example,
suppose we want to estimate π. We know that the area of a circle with radius r is πr2
, but it is also
equal to the following definite integral:
I =
Z r
−r
Z r
−r
I
￾
x
2 + y
2 ≤ r
2

dxdy (11.3)
Hence π = I/(r
2
). Let us approximate this by Monte Carlo integration. Let f(x, y) = I
￾
x
2 + y
2 ≤ r
2

be an indicator function that is 1 for points inside the circle, and 0 outside, and let p(x) and p(y) be
uniform distributions on [−r, r], so p(x) = p(y) = 1/(2r). Then
I = (2r)(2r)
Z Z f(x, y)p(x)p(y)dxdy (11.4)
= 4r
2
Z Z f(x, y)p(x)p(y)dxdy (11.5)
≈ 4r
2
1
Ns
X
Ns
n=1
f(xn, yn) (11.6)
Using 5000 samples, we find πˆ = 3.10 with standard error 0.09 compared to the true value of π = 3.14.
We can plot the points that are accepted or rejected as in Figure 11.1.
11.2.2 Accuracy of Monte Carlo integration
The accuracy of an MC approximation increases with sample size. This is illustrated in Figure 11.2.
On the top line, we plot a histogram of samples from a Gaussian distribution. On the bottom line,
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 201
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
11.2. MONTE CARLO INTEGRATION
0 1 2 3
0.0
0.5
1.0
1.5
2.0
n samples = 10
samples
true pdf
estimated pdf
(a)
0 1 2 3
0.0
0.5
1.0
1.5
2.0
n samples = 100
samples
true pdf
estimated pdf
(b)
Figure 11.2: 10 and 100 samples from a Gaussian distribution, N (µ = 1.5, σ2 = 0.25). A dotted red line
denotes kernel density estimate derived from the samples. Generated by mc_accuracy_demo.ipynb.
we plot a smoothed version of these samples, created using a kernel density estimate. This smoothed
distribution is then evaluated on a dense grid of points and plotted. Note that this smoothing is just
for the purposes of plotting, it is not used for the Monte Carlo estimate itself.
If we denote the exact mean by µ = E [f(X)], and the MC approximation by µˆ, one can show that,
with independent samples,
(ˆµ − µ) → N (0,
σ
2
Ns
) (11.7)
where
σ
2 = V [f(X)] = E

f(X)
2

− E [f(X)]
2
(11.8)
This is a consequence of the central limit theorem. Of course, σ
2
is unknown in the above expression,
but it can be estimated by MC:
σˆ
2 =
1
Ns
X
Ns
n=1
(f(xn) − µˆ)
2
(11.9)
Thus for large enough Ns we have
P

µˆ − 1.96
σˆ
√
Ns
≤ µ ≤ µˆ + 1.96
σˆ
√
Ns

≈ 0.95 (11.10)
The term q σˆ
2
Ns
is called the (numerical or empirical) standard error, and is an estimate of our
uncertainty about our estimate of µ.
If we want to report an answer which is accurate to within ±ǫ with probability at least 95%, we
need to use a number of samples Ns which satisfies 1.96p
σˆ
2/Ns ≤ ǫ. We can approximate the 1.96
factor by 2, yielding Ns ≥
4ˆσ
2
ǫ
2 .
The remarkable thing to note about the above results is that the error in the estimate, σ
2/Ns, is
theoretically independent of the dimensionality of the integral. The catch is that sampling from high
dimensional distributions can be hard. We turn to that topic next.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license480
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 2 4 6
N (3, 1)
0.0
0.5
1.0
Unif(0, 1)
Inverse cdf sampling
cdf-N (3, 1)
samples Unif(0, 1)
samples N (3, 1)
pdf N (3, 1)
Figure 11.3: Sampling from N (3, 1) using an inverse cdf.
11.3 Generating random samples from simple distributions
We saw in Section 11.2 how we can evaluate E [f(X)] for different functions f of a random variable X
using Monte Carlo integration. The main computational challenge is to efficiently generate samples
from the probability distribution p
∗
(x) (which may be a posterior, p
∗
(x) ∝ p(x|D)). In this section,
we discuss sampling methods that are suitable for parametric univariate distributions. These can be
used as building blocks for sampling from more complex multivariate distributions.
11.3.1 Sampling using the inverse cdf
The simplest method for sampling from a univariate distribution is based on the inverse probability
transform. Let F be a cdf of some distribution we want to sample from, and let F
−1 be its inverse.
Then we have the following result.
Theorem 11.3.1. If U ∼ U(0, 1) is a uniform rv, then F
−1
(U) ∼ F.
Proof.
Pr(F
−1
(U) ≤ x) = Pr(U ≤ F(x)) (applying F to both sides) (11.11)
= F(x) (because Pr(U ≤ y) = y) (11.12)
where the first line follows since F is a monotonic function, and the second line follows since U is
uniform on the unit interval.
Hence we can sample from any univariate distribution, for which we can evaluate its inverse cdf, as
follows: generate a random number u ∼ U(0, 1) using a pseudorandom number generator (see
e.g., [Pre+88] for details). Let u represent the height up the y axis. Then “slide along” the x axis
until you intersect the F curve, and then “drop down” and return the corresponding x value. This
corresponds to computing x = F
−1
(u). See Figure 11.3 for an illustration.
For example, consider the exponential distribution
Expon(x|λ) , λe−λx I(x ≥ 0) (11.13)
The cdf is
F(x) = 1 − e
−λx I(x ≥ 0) (11.14)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
11.4. REJECTION SAMPLING
whose inverse is the quantile function
F
−1
(p) = −
ln(1 − p)
λ
(11.15)
By the above theorem, if U ∼ Unif(0, 1), we know that F
−1
(U) ∼ Expon(λ). So we can sample from
the exponential distribution by first sampling from the uniform and then transforming the results
using − ln(1 − u)/λ. (In fact, since 1 − U ∼ Unif(0, 1), we can just use − ln(u)/λ.)
11.3.2 Sampling from a Gaussian (Box-Muller method)
In this section, we describe a method to sample from a Gaussian. The idea is we sample uniformly
from a unit radius circle, and then use the change of variables formula to derive samples from a
spherical 2d Gaussian. This can be thought of as two samples from a 1d Gaussian.
In more detail, sample z1, z2 ∈ (−1, 1) uniformly, and then discard pairs that do not satisfy z
2
1+z
2
2 ≤
1. The result will be points uniformly distributed inside the unit circle, so p(z) = 1
π
I(z inside circle).
Now define
xi = zi

−2 ln r
2
r
2
1
2
(11.16)
for i = 1 : 2, where r
2 = z
2
1 + z
2
2
. Using the multivariate change of variables formula, we have
p(x1, x2) = p(z1, z2)|
∂(z1, z2)
∂(x1, x2)
| =

1
√
2π
exp(−
1
2
x
2
1
)
  1
√
2π
exp(−
1
2
x
2
2
)

(11.17)
Hence x1 and x2 are two independent samples from a univariate Gaussian. This is known as the
Box-Muller method.
To sample from a multivariate Gaussian, we first compute the Cholesky decomposition of its
covariance matrix, Σ = LLT, where L is lower triangular. Next we sample x ∼ N (0, I) using the
Box-Muller method. Finally we set y = Lx + µ. This is valid since
Cov [y] = LCov [x]L
T = L I LT = Σ (11.18)
11.4 Rejection sampling
Suppose we want to sample from the target distribution
p(x) = ˜p(x)/Zp (11.19)
where p˜(x) is the unnormalized version, and
Zp =
Z
p˜(x) dx (11.20)
is the (possibly unknown) normalization constant. One of the simplest approaches to this problem is
rejection sampling, which we now explain.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license482
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Accept Region
Mq(x ) (i)
uMq(x ) (i)
Reject Region
(i) X ~ q(x)
p(x )(i)
(a)
0 2 4 6 8 10
0.0
0.5
1.0
target p(x)
comparison
function Mq(x)
(b)
Figure 11.4: (a) Schematic illustration of rejection sampling. From Figure 2 of [And+03]. Used with kind
permission of Nando de Freitas. (b) Rejection sampling from a Ga(α = 5.7, λ = 2) distribution (solid blue)
using a proposal of the form MGa(k, λ−1) (dotted red), where k = ⌊5.7⌋ = 5. The curves touch at α−k = 0.7.
Generated by rejection_sampling_demo.ipynb.
11.4.1 Basic idea
In rejection sampling, we require access to a proposal distribution q(x) which satisfies Cq(x) ≥
p˜(x), for some constant C. The function Cq(x) provides an upper envelope for p˜.
We can use the proposal distribution to generate samples from the target distribution as follows.
We first sample x0 ∼ q(x), which corresponds to picking a random x location, and then we sample
u0 ∼ Unif(0, Cq(x0)), which corresponds to picking a random height (y location) under the envelope.
If u0 > p˜(x0), we reject the sample, otherwise we accept it. This process is illustrated in 1d in
Figure 11.4(a): the acceptance region is shown shaded, and the rejection region is the white region
between the shaded zone and the upper envelope.
We now prove this procedure is correct. First note that the probability of any given sample x0
being accepted equals the probability of a sample u0 ∼ Unif(0, Cq(x0)) being less than or equal to
p˜(x0), i.e.,
q(accept|x0) = Z p˜(x0)
0
1
Cq(x0)
du =
p˜(x0)
Cq(x0)
(11.21)
Therefore
q(propose and accept x0) = q(x0)q(accept|x0) = q(x0)
p˜(x0)
Cq(x0)
=
p˜(x0)
C
(11.22)
Integrating both sides give
Z
q(x0)q(accept|x0) dx0 = q(accept) =
R
p˜(x0) dx0
C
=
Zp
C
(11.23)
Hence we see that the distribution of accepted points is given by the target distribution:
q(x0|accept) = q(x0, accept)
q(accept)
=
p˜(x0)
C
C
Zp
=
p˜(x0)
Zp
= p(x0) (11.24)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
11.4. REJECTION SAMPLING
How efficient is this method? If p˜ is a normalized target distribution, the acceptance probability is
1/C. Hence we want to choose C as small as possible while still satisfying Cq(x) ≥ p˜(x).
11.4.2 Example
For example, suppose we want to sample from a gamma distribution:3
Ga(x|α, λ) = 1
Γ(α)
x
α−1λ
α
exp(−λx) (11.25)
where Γ(α) is the gamma function. One can show that if Xi
iid∼ Expon(λ), and Y = X1 + · · · + Xk,
then Y ∼ Ga(k, λ). For non-integer shape parameters α, we cannot use this trick. However, we can
use rejection sampling using a Ga(k, λ − 1) distribution as a proposal, where k = ⌊α⌋. The ratio has
the form
p(x)
q(x)
=
Ga(x|α, λ)
Ga(x|k, λ − 1) =
x
α−1λ
α exp(−λx)/Γ(α)
x
k−1(λ − 1)k exp(−(λ − 1)x)/Γ(k)
(11.26)
=
Γ(k)λ
α
Γ(α)(λ − 1)k
x
α−k
exp(−x) (11.27)
This ratio attains its maximum when x = α − k. Hence
C =
Ga(α − k|α, λ)
Ga(α − k|k, λ − 1) (11.28)
See Figure 11.4(b) for a plot.
11.4.3 Adaptive rejection sampling
We now describe a method that can automatically come up with a tight upper envelope q(x) to
any log concave 1d density p(x). The idea is to upper bound the log density with a piecewise linear
function, as illustrated in Figure 11.5(a). We choose the initial locations for the pieces based on a
fixed grid over the support of the distribution. We then evaluate the gradient of the log density at
these locations, and make the lines be tangent at these points.
Since the log of the envelope is piecewise linear, the envelope itself is piecewise exponential:
q(x) = Ciλi exp(−λi(x − xi−1)), xi−1 < x ≤ xi (11.29)
where xi are the grid points. It is relatively straightforward to sample from this distribution. If the
sample x is rejected, we create a new grid point at x, and thereby refine the envelope. As the number
of grid points is increased, the tightness of the envelope improves, and the rejection rate goes down.
This is known as adaptive rejection sampling (ARS) [GW92]. Figure 11.5(b-c) gives an example
of the method in action. As with standard rejection sampling, it can be applied to unnormalized
distributions.
3. This section is based on notes by Ioana A. Cosma, available at http://users.aims.ac.za/~ioana/cp2.pdf.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license484
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a)
−5 0 5
x
0.0
0.5
1.0
f(x)
f(x) half-gaussian
(b)
−5 0 5
x
0
500
1000
samples
samples from f(x) (by ARS)
(c)
Figure 11.5: (a) Idea behind adaptive rejection sampling. We place piecewise linear upper (and lower) bounds
on the log-concave density. Adapted from Figure 1 of [GW92]. Generated by ars_envelope.ipynb. (b-c) Using
ARS to sample from a half-Gaussian. Generated by ars_demo.ipynb.
11.4.4 Rejection sampling in high dimensions
It is clear that we want to make our proposal q(x) as close as possible to the target distribution p(x),
while still being an upper bound. But this is quite hard to achieve, especially in high dimensions. To
see this, consider sampling from p(x) = N (0, σ2
p
I) using as a proposal q(x) = N (0, σ2
q
I). Obviously
we must have σ
2
q ≥ σ
2
p
in order to be an upper bound. In D dimensions, the optimum value is given
by C = (σq/σp)
D. The acceptance rate is 1/C (since both p and q are normalized), which decreases
exponentially fast with dimension. For example, if σq exceeds σp by just 1%, then in 1000 dimensions
the acceptance ratio will be about 1/20,000. This is a fundamental weakness of rejection sampling.
11.5 Importance sampling
In this section, we describe a Monte Carlo method known as importance sampling for approxi￾mating integrals of the form
E [ϕ(x)] = Z
ϕ(x)π(x)dx (11.30)
where ϕ is called a target function, and π(x) is the target distribution, often a conditional
distribution of the form π(x) = p(x|y). Since in general it is difficult to draw from the target
distribution, we will instead draw from some proposal distribution q(x) (which will usually
depend on y). We then adjust for the inaccuracies of this by associating weights with each sample,
so we end up with a weighted MC approximation:
E [ϕ(x)] ≈
X
N
n=1
Wnϕ(xn) (11.31)
We discuss two cases, first when the target is normalized, and then when it is unnormalized. This
will affect the ways the weights are computed, as well as statistical properties of the estimator.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
11.5. IMPORTANCE SAMPLING
11.5.1 Direct importance sampling
In this section, we assume that we can evaluate the normalized target distribution π(x), but we
cannot sample from it. So instead we will sample from the proposal q(x). We can then write
Z
ϕ(x)π(x)dx =
Z
ϕ(x)
π(x)
q(x)
q(x)dx (11.32)
We require that the proposal be non-zero whenever the target is non-zero, i.e., the support of q(x)
needs to be greater or equal to the support of π(x). If we draw Ns samples xn ∼ q(x), we can write
E [ϕ(x)] ≈
1
Ns
X
Ns
n=1
π(xn)
q(xn)
ϕ(xn) = 1
Ns
X
Ns
n=1
w˜nϕ(xn) (11.33)
where we have defined the importance weights as follows:
w˜n =
π(xn)
q(xn)
(11.34)
The result is an unbiased estimate of the true mean E [ϕ(x)].
11.5.2 Self-normalized importance sampling
The disadvantage of direct importance sampling is that we need a way to evaluate the normalized
target distribution π in order to compute the weights. It is often much easier to evaluate the
unnormalized target distribution
γ˜(x) = Zπ(x) (11.35)
where
Z =
Z
γ˜(x)dz (11.36)
is the normalization constant. (For example, if π(x) = p(x|y), then γ˜(x) = p(x, y) and Z = p(y).)
The key idea is to also approximate the normalization constant Z with importance sampling. This
method is called self-normalized importance sampling. The resulting estimate is a ratio of
two estimates, and hence is biased. However as Ns → ∞, the bias goes to zero, under some weak
assumptions (see e.g., [RC04] for details).
In more detail, SNIS is based on this approximation:
E [ϕ(x)] = Z
ϕ(x)π(x)dx =
R
ϕ(x)˜γ(x)dx
R
γ˜(x)dx
=
R
h
γ˜(x)
q(x)
ϕ(x)
i
q(x)dx
R
h
γ˜(x)
q(x)
i
q(x)dx
(11.37)
≈
1
Ns
PNs
n=1 w˜nϕ(xn)
1
Ns
PNs
n=1 w˜n
(11.38)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license486
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where we have defined the unnormalized weights
w˜n =
γ˜(xn)
q(xn)
(11.39)
We can write Equation (11.38) more compactly as
E [ϕ(x)] ≈
X
Ns
n=1
Wnϕ(xn) (11.40)
where we have defined the normalized weights by
Wn =
w˜n PNs
n′=1 w˜n′
(11.41)
This is equivalent to approximating the target distribution using a weighted sum of delta functions:
π(x) ≈
X
Ns
n=1
Wnδ(x − xn) , πˆ(x) (11.42)
As a byproduct of this algorithm we get the following appoximation to the normalization constant:
Z ≈
1
Ns
X
Ns
n=1
w˜n , Zˆ (11.43)
11.5.3 Choosing the proposal
The performance of importance sampling depends crucially on the quality of the proposal distribution.
As we mentioned, we require that the support of q cover the support of the target (i.e., γ˜(x) > 0 =⇒
q(x) > 0). However, we also want the proposal to not be too “loose” of a “covering”. Ideally it should
also take into account properties of the target function ϕ as well, as shown in Figure 11.6. This can
yield subsantial benefits, as shown in the “target aware Bayesian inference” scheme of [Rai+20].
However, usually the target function ϕ is unknown or ignored, so we just try to find a “generally
useful” approximation to the target.
One way to come up with a good proposal is to learn one, by optimizing the variational lower
bound or ELBO (see Section 10.1.1.2). Indeed, if we fix the parameters of the generative model, we
can think of importance weighted autoencoders (Section 10.5.1) as learning a good IS proposal. More
details on this connection can be found in [DS18].
11.5.4 Annealed importance sampling (AIS)
In this section, we describe a method known as annealed importance sampling [Nea01] for
sampling from complex, possibly multimodal distributions. Assume we want to sample from some
target distribution p0(x) ∝ f0(x) (where f0(x) is the unnormalized version), but we cannot easily do
so, because p0 is complicated in some way (e.g., high dimensional and/or multi-modal). However,
suppose that there is an easier distribution which we can sample from, call it pn(x) ∝ fn(x); for
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
11.5. IMPORTANCE SAMPLING
￾￾￾￾￾￾￾￾￾￾￾￾￾￾￾ ￾￾￾￾￾￾￾￾￾￾￾￾￾￾￾ ￾￾￾￾￾￾￾￾￾￾￾￾￾￾￾
￾￾￾￾￾￾￾￾￾￾￾￾￾￾￾ ￾￾￾￾￾￾￾￾￾￾￾￾￾￾￾ ￾￾￾￾￾￾￾￾￾￾￾￾￾￾￾
￾￾￾￾￾￾￾￾￾￾￾￾￾￾￾ ￾￾￾￾￾￾￾￾￾￾￾￾￾￾￾ ￾￾￾￾￾￾￾￾￾￾￾￾￾￾￾
￾￾￾￾￾￾￾￾￾￾￾￾￾￾￾ ￾￾￾￾￾￾￾￾￾￾￾￾￾￾￾ ￾￾￾￾￾￾￾￾￾￾￾￾￾￾￾
 
  
  
  
p(x)
E
Contours of p(x)
α E
Contours of q(x) I (x)p(x)
Figure 11.6: In importance sampling, we should sample from a distribution that takes into account regions
where π(x) has high probability and where ϕ(x) is large. Here the function to be evaluated is an indicator
function of a set, corresponding to a set of rare events in the tail of the distribution. From Figure 3 of
[And+03]. Used with kind permission of Nando de Freitas.
example, this might be the prior. We now construct a sequence of intermediate distributions than
move slowly from pn to p0 as follows:
fj (x) = f0(x)
βj fn(x)
1−βj
(11.44)
where 1 = β0 > β1 > · · · > βn = 0, where βj is an inverse temperature. We will sample a set of
points from fn, and then from fn−1, and so on, until we eventually sample from f0.
To sample from each fj , suppose we can define a Markov chain Tj (x, x
′
) = pj (x
′
|x), which leaves
p0 invariant (i.e., R
pj (x
′
|x)p0(x)dx = p0(x
′
)). (See Chapter 12 for details on how to construct such
chains.) Given this, we can sample x from p0 as follows: sample vn ∼ pn; sample vn−1 ∼ Tn−1(vn, ·);
and continue in this way until we sample v0 ∼ T0(v1, ·); finally we set x = v0 and give it weight
w =
fn−1(vn−1)
fn(vn−1)
fn−2(vn−2)
fn−1(vn−2)
· · ·
f1(v1)
f2(v1)
f0(v0)
f1(v0)
(11.45)
This can be shown to be correct by viewing the algorithm as a form of importance sampling in an
extended state space v = (v0, . . . , vn). Consider the following distribution on this state space:
p(v) ∝ ϕ(v) = f0(v0)T˜
0(v0, v1)T˜
2(v1, v2)· · · T˜
n−1(vn−1, vn) (11.46)
∝ p(v0)p(v1|v0)· · · p(vn|vn−1) (11.47)
where T˜
j is the reversal of Tj :
T˜
j (v, v
′
) = Tj (v
′
, v)pj (v
′
)/pj (v) = Tj (v
′
, v)fj (v
′
)/fj (v) 488
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We can sample on this extended state space using the above algorithm, which corresponds to the
following proposal:
q(v) ∝ g(v) = fn(vn)Tn−1(vn, vn−1)· · · T2(v2, v1)T0(v1, v0) (11.49)
∝ p(vn)p(vn−1|vn)· · · p(v1|v0) (11.50)
One can show that the importance weights w =
ϕ(v0,...,vn)
g(v0,...,vn)
are given by Equation (11.45). Since
marginals of the sampled sequences from this extended model are equivalent to samples from p0(x),
we see that we are using the correct weights.
11.5.4.1 Estimating normalizing constants using AIS
An important application of AIS is to evaluate a ratio of partition functions. Notice that Z0 = R
f0(x)dx =
R
ϕ(v)dv, and Zn =
R
fn(x)dx =
R
g(v)dv. Hence
Z0
Zn
=
R
ϕ(v)dv
R
g(v)dv
=
R ϕ(v)
g(v)
g(v)dv
R
g(v)dv
= Eg

ϕ(v)
g(v)

≈
1
S
X
S
s=1
ws (11.51)
where ws = ϕ(vs)/g(vs). If f0 is a prior and fn is the posterior, we can estimate Zn = p(D) using
the above equation, provided the prior has a known normalization constant Z0. This is generally
considered the method of choice for evaluating difficult partition functions. See e.g., [GM98] for more
details.
11.6 Controlling Monte Carlo variance
As we mentioned in Section 11.2.2, the standard error in a Monte Carlo estimate is O(1/
√
S), where
S is the number of (independent) samples. Consequently it may take many samples to reduce the
variance to a sufficiently small value. In this section, we discuss some ways to reduce the variance of
sampling methods. For more details, see e.g., [KTB11].
11.6.1 Common random numbers
When performing Monte Carlo optimization, we often want to compare Ep(z)
[f(θ, z)] to Ep(z)
[f(θ
′
, z)]
for different values of the parameters θ and θ
′
. To reduce the variance of this comparison, we can
use the same random samples zs for evaluating both functions. In this way, differences in the
outcome can be ascribed to differences in the parameters θ, rather than to the noise terms. This
is called the common random numbers trick, and is widely used in ML (see e.g., [GBJ18;
NJ00]), since it can often convert a stochastic optimization problem into a deterministic one,
enabling the us of more powerful optimization methods. For more details on CRN, see e.g.,
https://en.wikipedia.org/wiki/Variance_reduction#Common_Random_Numbers_(CRN).
11.6.2 Rao-Blackwellization
In this section, we discuss a useful technique for reducing the variance of MC estimators known as
Rao-Blackwellization. To explain the method, suppose we have two rv’s, X and Y , and we want
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
11.6. CONTROLLING MONTE CARLO VARIANCE
to estimate f = E [f(X, Y )]. The naive approach is to use an MC approximation
ˆfMC =
1
S
X
S
s=1
f(Xs, Ys) (11.52)
where (Xs, Ys) ∼ p(X, Y ). This is an unbiased estimator of f. However, it may have high variance.
Now suppose we can analytically marginalize out Y , provided we know X, i.e., we can tractably
compute
fX(Xs) = Z
dY p(Y |Xs)f(Xs, Y ) = E [f(X, Y )|X = Xs] (11.53)
Let us define the Rao-Blackwellized estimator
ˆfRB =
1
S
X
S
s=1
fX(Xs) (11.54)
where Xs ∼ p(X). This is an unbiased estimator, since E
h
ˆfRBi
= E [E [f(X, Y )|X]] = f. However,
this estimate can have lower variance than the naive estimator. The intuitive reason is that we are
now sampling in a reduced dimensional space. Formally we can see this by using the law of iterated
variance to get
V [E [f(X, Y )|X]] = V [f(X, Y )] − E [V [f(X, Y )] |X] ≤ V [f(X, Y )] (11.55)
For some examples of this in practice, see Section 6.3.4.2, Section 13.4, and Section 12.3.8.
11.6.3 Control variates
Suppose we want to estimate µ = E [f(X)] using an unbiased estimator m(X ) = 1
S
PS
s=1 m(xs),
where xs ∼ p(X) and E [m(X)] = µ. (We abuse notation slightly and use m to refer to a function of
a single random variable as well as a set of samples.) Now consider the alternative estimator
m∗
(X ) = m(X ) + c (b(X ) − E [b(X )]) (11.56)
This is called a control variate, and b is called a baseline. (Once again we abuse notation and use
b(X ) = 1
S
PS
s=1 b(xs) and m∗
(X ) = 1
S
PS
s=1 m∗
(xs).)
It is easy to see that m∗
(X ) is an unbiased estimator, since E [m∗
(X)] = E [m(X)] = µ. However,
it can have lower variance, provided b is correlated with m. To see this, note that
V [m∗
(X)] = V [m(X)] + c
2V [b(X)] + 2cCov [m(X), b(X)] (11.57)
By taking the derivative of V [m∗
(X)] wrt c and setting to 0, we find that the optimal value is
c
∗ = −
Cov [m(X), b(X)]
V [b(X)] (11.58)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license490
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The corresponding variance of the new estimator is now
V [m∗
(X)] = V [m(X)] −
Cov [m(X), b(X)]2
V [b(X)] = (1 − ρ
2
m,b)V [m(X)] ≤ V [m(X)] (11.59)
where ρ
2
m,b is the correlation of the basic estimator and the baseline function. If we can ensure
this correlation is high, we can reduce the variance. Intuitively, the CV estimator is exploiting
information about the errors in the estimate of a known quantity, namely E [b(X)], to reduce the
errors in estimating the unknown quantity, namely µ.
We give a simple worked example in Section 11.6.3.1. See Section 10.2.3 for an example of this
technique applied to blackbox variational inference.
11.6.3.1 Example
We now give a simple worked example of control variates.4 Consider estimating µ = E [f(X)] where
f(X) = 1/(1 + X) and X ∼ Unif(0, 1). The exact value is
µ =
Z 1
0
1
1 + x
dx = ln 2 ≈ 0.693 (11.60)
The naive MC estimate, using S samples, is m(X ) = 1
S
PS
s=1 f(xs). Using S = 1500, we find
E [m(X )] = 0.6935 with standard error se = 0.0037.
Now let us use b(X) = 1 + X as a baseline, so b(X ) = (1/S)
P
s
(1 + xs). This has expectation
E [b(X)] = R 1
0
(1 + x)dx =
3
2
. The control variate estimator is given by
m∗
(X ) = 1
S
X
S
s=1
f(xs) + c
 
1
S
X
S
s=1
b(xs) −
3
2
!
(11.61)
The optimal value can be estimated from the samples of m(xs) and b(xs), and plugging into
Equation (11.58) to get c
∗ ≈ 0.4773. Using S = 1500, we find E [m∗
(X )] = 0.6941 and se = 0.0007.
See also Section 11.6.4.1, where we analyze this example using antithetic sampling.
11.6.4 Antithetic sampling
In this section, we discuss antithetic sampling, which is a simple way to reduce variance.5 Suppose
we want to estimate θ = E [Y ]. Let Y1 and Y2 be two samples. An unbiased estimate of θ is given by
ˆθ = (Y1 + Y2)/2. The variance of this estimate is
V
h
ˆθ
i
=
V [Y1] + V [Y2] + 2Cov [Y1, Y2]
4
(11.62)
so the variance is reduced if Cov [Y1, Y2] < 0. So whenever we sample Y1, we should set Y2 to be its
“opposite”, but with the same mean.
For example, suppose Y ∼ Unif(0, 1). If we let y1, . . . , yn be iid samples from Unif(0, 1), then we
can define y
′
i = 1 − yi
. The distribution of y
′
i
is still Unif(0, 1), but Cov [yi
, y′
i
] < 1.
4. The example is from https://en.wikipedia.org/wiki/Control_variates, with modified notation. See con￾trol_variates.ipynb for some code.
5. Our presentation is based on https://en.wikipedia.org/wiki/Antithetic_variates. See anti￾thetic_sampling.ipynb for the code.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
11.6. CONTROLLING MONTE CARLO VARIANCE
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
Unit square
512 MC
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
Unit square
512 QMC
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
Unit square
512 RQMC
Figure 11.7: Illustration of Monte Carlo (MC), Quasi-MC (QMC) from a Sobol sequence, and randomized
QMC using a scrambling method. Adapted from Figure 1 of [OR20]. Used with kind permission of Art Owen.
11.6.4.1 Example
To see why this can be useful, consider the example from Section 11.6.3.1. Let µˆmc be the classic MC
estimate using 2N samples from Unif(0, 1), and let µˆanti be the MC estimate using the above antithetic
sampling scheme applied to N base samples from Unif(0, 1). The exact value is µ = ln 2 ≈ 0.6935.
For the classical method, with N = 750, we find E [ˆµmc] = 0.69365 with a standard error of 0.0037.
For the antithetic method, we find E [ˆµanti] = 0.6939 with a standard error of 0.0007, which matches
the control variate method of Section 11.6.3.1.
11.6.5 Quasi-Monte Carlo (QMC)
Quasi-Monte Carlo (see e.g., [Lem09; Owe13]) is an approach to numerical integration that replaces
random samples with low discrepancy sequences, such as the Halton sequence (see e.g., [Owe17])
or Sobol sequence. Intuitively, these are space filling sequences of points, constructed to reduce
the unwanted gaps and clusters that would arise among randomly chosen inputs. See Figure 11.7 for
an example.6
More precisely, consider the problem of evaluating the following D-dimensional integral:
f =
Z
[0,1]D
f(x)dx ≈ ˆfN =
1
N
X
N
n=1
f(xn) (11.63)
Let ǫN = |f − ˆfN | be the error. In standard Monte Carlo, if we draw N independent samples, then
we have ǫN ∼ O

√
1
N

. In QMC, it can be shown that ǫN ∼ O

(log N)
D
N

. For N > 2
D, the latter
is smaller than the former.
One disadvantage of QMC is that it just provides a point estimate of f, and does not give an
uncertainty estimate. By contrast, in regular MC, we can estimate the MC standard error, discussed
in Section 11.2.2. Randomized QMC (see e.g., [L’E18]) provides a solution to this problem. The
basic idea is to repeat the QMC method R times, by perturbing the sequence of N points by a
6. More details on QMC can be found at http://roth.cs.kuleuven.be/wiki/Main_Page. For connections to Bayesian
quadrature, see e.g., [DKS13; HKO22].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license492
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
random amount. In particular, define
yi,r = xi + ur (mod 1) (11.64)
where x1, . . . , xN is a low-discrepancy sequence, and ur ∼ Unif(0, 1)D is a random perturbation.
The set {yj} is low discrepancy, and satisfies that each yj ∼ Unif(0, 1)D, for j = 1 : N × R. This
has much lower variance than standard MC. (Typically we take R to be a power of 2.) Recently,
[OR20] proved a strong law of large numbers for RQMC.
QMC and RQMC can be used inside of MCMC inference (see e.g., [OT05]) and variational inference
(see e.g., [BWM18]). It is also commonly used to select the initial set of query points for Bayesian
optimization (Section 6.6).
Another technique that can be used is orthogonal Monte Carlo, where the samples are condi￾tioned to be pairwise orthogonal, but with the marginal distributions matching the original ones (see
e.g., [Lin+20]).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 202312 Markov chain Monte Carlo
12.1 Introduction
In Chapter 11, we considered non-iterative Monte Carlo methods, including rejection sampling and
importance sampling, which generate independent samples from some target distribution. The trouble
with these methods is that they often do not work well in high dimensional spaces. In this chapter,
we discuss a popular method for sampling from high-dimensional distributions known as Markov
chain Monte Carlo or MCMC. In a survey by SIAM News1
, MCMC was placed in the top 10
most important algorithms of the 20th century.
The basic idea behind MCMC is to construct a Markov chain (Section 2.6) on the state space X
whose stationary distribution is the target density p
∗
(x) of interest. (In a Bayesian context, this
is usually a posterior, p
∗
(x) ∝ p(x|D), but MCMC can be applied to generate samples from any
kind of distribution.) That is, we perform a random walk on the state space, in such a way that the
fraction of time we spend in each state x is proportional to p
∗
(x). By drawing (correlated) samples
x0, x1, x2, . . . , from the chain, we can perform Monte Carlo integration wrt p
∗
.
Note that the initial samples from the chain do not come from the stationary distribution, and
should be discarded; the amount of time it takes to reach stationarity is called the mixing time or
burn-in time; reducing this is one of the most important factors in making the algorithm fast, as
we will see.
The MCMC algorithm has an interesting history. It was discovered by physicists working on the
atomic bomb at Los Alamos during World War II, and was first published in the open literature in
[Met+53] in a chemistry journal. An extension was published in the statistics literature in [Has70],
but was largely unnoticed. A special case (Gibbs sampling, Section 12.3) was independently invented
in [GG84] in the context of Ising models (Section 4.3.2.1). But it was not until [GS90] that the
algorithm became well-known to the wider statistical community. Since then it has become wildly
popular in Bayesian statistics, and is becoming increasingly popular in machine learning.
In the rest of this chapter, we give a brief introduction to MCMC methods. For more details on
the theory, see e.g., [GRS96; BZ20]. For more details on the implementation side, see e.g., [Lao+20].
And for an interactive visualization of many of these algorithsm in 2d, see http://chi-feng.github.
io/mcmc-demo/app.html.
1. Source: http://www.siam.org/pdf/news/637.pdf.494
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.2 Metropolis-Hastings algorithm
In this section, we describe the simplest kinds of MCMC algorithm known as the Metropoli￾Hastings or MH algorithm.
12.2.1 Basic idea
The basic idea in MH is that at each step, we propose to move from the current state x to a new state
x
′ with probability q(x
′
|x), where q is called the proposal distribution (also called the kernel).
The user is free to use any kind of proposal they want, subject to some conditions which we explain
below. This makes MH quite a flexible method.
Having proposed a move to x
′
, we then decide whether to accept this proposal, or to reject it,
according to some formula, which ensures that the long-term fraction of time spent in each state is
proportional to p
∗
(x). If the proposal is accepted, the new state is x
′
, otherwise the new state is the
same as the current state, x (i.e., we repeat the sample).
If the proposal is symmetric, so q(x
′
|x) = q(x|x
′
), the acceptance probability is given by the
following formula:
A = min 
1,
p
∗
(x
′
)
p
∗(x)

(12.1)
We see that if x
′
is more probable than x, we definitely move there (since p
∗
(x
′
)
p∗(x) > 1), but if x
′
is
less probable, we may still move there anyway, depending on the relative probabilities. So instead of
greedily moving to only more probable states, we occasionally allow “downhill” moves to less probable
states. In Section 12.2.2, we prove that this procedure ensures that the fraction of time we spend in
each state x is equal to p
∗
(x).
If the proposal is asymmetric, so q(x
′
|x) 6= q(x|x
′
), we need the Hastings correction, given by
the following:
A = min(1, α) (12.2)
α =
p
∗
(x
′
)q(x|x
′
)
p
∗(x)q(x′
|x)
=
p
∗
(x
′
)/q(x
′
|x)
p
∗(x)/q(x|x′)
(12.3)
This correction is needed to compensate for the fact that the proposal distribution itself (rather than
just the target distribution) might favor certain states.
An important reason why MH is a useful algorithm is that, when evaluating α, we only need to
know the target density up to a normalization constant. In particular, suppose p
∗
(x) = 1
Z
p˜(x), where
p˜(x) is an unnormalized distribution and Z is the normalization constant. Then
α =
(˜p(x
′
)/Z) q(x|x
′
)
(˜p(x)/Z) q(x′
|x)
(12.4)
so the Z’s cancel. Hence we can sample from p
∗
even if Z is unknown.
A proposal distribution q is valid or admissible if it “covers” the support of the target. Formally,
we can write this as
supp(p
∗
) ⊆ ∪xsupp(q(·|x)) (12.5)
With this, we can state the overall algorithm as in Algorithm 12.1.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.2. METROPOLIS-HASTINGS ALGORITHM
Algorithm 12.1: Metropolis-Hastings algorithm
1 Initialize x
0
2 for s = 0, 1, 2, . . . do
3 Define x = x
s
4 Sample x
′ ∼ q(x
′
|x)
5 Compute acceptance probability
α =
p˜(x
′
)q(x|x
′
)
p˜(x)q(x
′
|x)
6 Compute A = min(1, α)
7 Sample u ∼ U(0, 1)
8 Set new sample to
x
s+1 =

x
′
if u ≤ A (accept)
x
s
if u > A (reject)
12.2.2 Why MH works
To prove that the MH procedure generates samples from p
∗
, we need a bit of Markov chain theory,
as discussed in Section 2.6.4.
The MH algorithm defines a Markov chain with the following transition matrix:
p(x
′
|x) = 
q(x
′
|x)A(x
′
|x) if x
′ 6= x
q(x|x) + P
x′6=x
q(x
′
|x)(1 − A(x
′
|x)) otherwise (12.6)
This follows from a case analysis: if you move to x
′
from x, you must have proposed it (with
probability q(x
′
|x)) and it must have been accepted (with probability A(x
′
|x)); otherwise you stay in
state x, either because that is what you proposed (with probability q(x|x)), or because you proposed
something else (with probability q(x
′
|x)) but it was rejected (with probability 1 − A(x
′
|x)).
Let us analyze this Markov chain. Recall that a chain satisfies detailed balance if
p(x
′
|x)p
∗
(x) = p(x|x
′
)p
∗
(x
′
) (12.7)
This means in the in-flow to state x
′
from x is equal to the out-flow from state x
′ back to x, and vice
versa. We also showed that if a chain satisfies detailed balance, then p
∗
is its stationary distribution.
Our goal is to show that the MH algorithm defines a transition function that satisfies detailed balance
and hence that p
∗
is its stationary distribution. (If Equation (12.7) holds, we say that p
∗
is an
invariant distribution wrt the Markov transition kernel q.)
Theorem 12.2.1. If the transition matrix defined by the MH algorithm (given by Equation (12.6))
is ergodic and irreducible, then p
∗
is its unique limiting distribution.
Proof. Consider two states x and x
′
. Either
p
∗
(x)q(x
′
|x) < p∗
(x
′
)q(x|x
′
) (12.8)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license496
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
or
p
∗
(x)q(x
′
|x) ≥ p
∗
(x
′
)q(x|x
′
) (12.9)
Without loss of generality, assume that p
∗
(x)q(x
′
|x) > p∗
(x
′
)q(x|x
′
). Hence
α(x
′
|x) = p
∗
(x
′
)q(x|x
′
)
p
∗(x)q(x′
|x)
< 1 (12.10)
Hence we have A(x
′
|x) = α(x
′
|x) and A(x|x
′
) = 1.
Now to move from x to x
′ we must first propose x
′ and then accept it. Hence
p(x
′
|x) = q(x
′
|x)A(x
′
|x) = q(x
′
|x)
p
∗
(x
′
)q(x|x
′
)
p
∗(x)q(x′
|x)
=
p
∗
(x
′
)
p
∗(x)
q(x|x
′
) (12.11)
Hence
p
∗
(x)p(x
′
|x) = p
∗
(x
′
)q(x|x
′
) (12.12)
The backwards probability is
p(x|x
′
) = q(x|x
′
)A(x|x
′
) = q(x|x
′
) (12.13)
since A(x|x
′
) = 1. Inserting this into Equation (12.12) we get
p
∗
(x)p(x
′
|x) = p
∗
(x
′
)p(x|x
′
) (12.14)
so detailed balance holds wrt p
∗
. Hence, from Theorem 2.6.3, p
∗
is a stationary distribution.
Furthermore, from Theorem 2.6.2, this distribution is unique, since the chain is ergodic and irreducible.
12.2.3 Proposal distributions
In this section, we discuss some common proposal distributions. Note, however, that good proposal
design is often intimately dependent on the form of the target distribution (most often the posterior).
12.2.3.1 Independence sampler
If we use a proposal of the form q(x
′
|x) = q(x
′
), where the new state is independent of the old
state, we get a method known as the independence sampler, which is similar to importance
sampling (Section 11.5). The function q(x
′
) can be any suitable distribution, such as a Gaussian.
This has non-zero probability density on the entire state space, and hence is a valid proposal for any
unconstrained continuous state space.
12.2.3.2 Random walk Metropolis (RWM) algorithm
The random walk Metropolis algorithm corresponds to MH with the following proposal distribu￾tion:
q(x
′
|x) = N (x
′
|x, τ 2
I) (12.15)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.2. METROPOLIS-HASTINGS ALGORITHM
Iterations
0
250
500
750
1000 Samples
−100
−50
0
50
100
0.00
0.01
0.02
0.03
0.04
MH with N (0, 1
2
) proposal
(a)
Iterations
0
250
500
750
1000 Samples
−100
−50
0
50
100
0.00
0.02
0.04
0.06
0.08
MH with N (0, 5002
) proposal
(b)
Iterations
0
250
500
750
1000 Samples
−100
−50
0
50
100
0.00
0.01
0.02
0.03
MH with N (0, 8
2
) proposal
(c)
Figure 12.1: An example of the Metropolis-Hastings algorithm for sampling from a mixture of two 1d
Gaussians (µ = (−20, 20), π = (0.3, 0.7), Σ = (100, 100)), using a Gaussian proposal with standard deviation
of τ ∈ {1, 8, 500}. (a) When τ = 1, the chain gets trapped near the starting state and fails to sample from
the mode at µ = −20. (b) When τ = 500, the chain is very “sticky”, so its effective sample size is low (as
reflected by the rough histogram approximation at the end). (c) Using a variance of τ = 8 is just right and
leads to a good approximation of the true distribution (shown in red). Compare to Figure 12.4. Generated by
mcmc_gmm_demo.ipynb.
Here τ is a scale factor chosen to facilitate rapid mixing. [RR01b] prove that, if the posterior is
Gaussian, the asymptotically optimal value is to use τ
2 = 2.382/D, where D is the dimensionality of
x; this results in an acceptance rate of 0.234, which (in this case) is the optimal tradeoff between
exploring widely enough to cover the distribution without being rejected too often. (See [Béd08] for
a more recent account of optimal acceptance rates for random walk Metropolis methods.)
Figure 12.1 shows an example where we use RWM to sample from a mixture of two 1D Gaussians.
This is a somewhat tricky target distribution, since it consists of two somewhat separated modes.
It is very important to set the variance of the proposal τ
2
correctly: if the variance is too low, the
chain will only explore one of the modes, as shown in Figure 12.1(a), but if the variance is too large,
most of the moves will be rejected, and the chain will be very sticky, i.e., it will stay in the same
state for a long time. This is evident from the long stretches of repeated values in Figure 12.1(b).
If we set the proposal’s variance just right, we get the trace in Figure 12.1(c), where the samples
clearly explore the support of the target distribution.
12.2.3.3 Composing proposals
If there are several proposals that might be useful, one can combine them using a mixture proposal,
which is a convex combination of base proposals:
q(x
′
|x) = X
K
k=1
wkqk(x
′
|x) (12.16)
where wk are the mixing weights that sum to one. As long as each qk is an individually valid proposal,
and each wk > 0, then the overall mixture proposal will also be valid. In particular, if each proposal
is reversible, so it satisfies detailed balance (Section 2.6.4.4), then so does the mixture.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license498
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
It is also possible to compose individual proposals by chaining them together to get
q(x
′
|x) = X
x1
· · ·
X
xK−1
q1(x1|x)q2(x2|x1)· · · qK(x|xK−1) (12.17)
A common example is where each base proposal only updates a subset of the variables (see e.g.,
Section 12.3).
12.2.3.4 Data-driven MCMC
In the case where the target distribution is a posterior, p
∗
(x) = p(x|D), it is helpful to condition the
proposal not just on the previous hidden state, but also the visible data, i.e., to use q(x
′
|x, D). This
is called data-driven MCMC (see e.g., [TZ02; Jih+12]).
One way to create such a proposal is to train a recognition network to propose states using
q(x
′
|x, D) = f(x). If the state space is high-dimensional, it might be hard to predict all the hidden
components, so we can alternatively train individual “experts” to predict specific pieces of the hidden
state. For example, in the context of estimating the 3d pose of a person from an image, we might
combine a face detector with a limb detector. We can then use a mixture proposal of the form
q(x
′
|x, D) = π0q0(x
′
|x) +X
k
πkqk(x
′
k
|fk(D)) (12.18)
where q0 is a standard data-independent proposal (e.g., random walk), and qk updates the k’th
component of the state space.
The overall procedure is a form of generate and test: the discriminative proposals q(x
′
|x, D)
generate new hypotheses, which are then “tested” by computing the posterior ratio p(x
′
|D)
p(x|D)
, to see if
the new hypothesis is better or worse. (See also Section 13.3, where we discuss learning proposal
distributions for particle filters.)
12.2.3.5 Adaptive MCMC
One can change the parameters of the proposal as the algorithm is running to increase efficiency.
This is called adaptive MCMC. This allows one to start with a broad covariance (say), allowing
large moves through the space until a mode is found, followed by a narrowing of the covariance to
ensure careful exploration of the region around the mode.
However, one must be careful not to violate the Markov property; thus the parameters of the
proposal should not depend on the entire history of the chain. It turns out that a sufficient condition
to ensure this is that the adaption is “faded out” gradually over time. See e.g., [AT08] for details.
12.2.4 Initialization
It is necessary to start MCMC in an initial state that has non-zero probability. A natural approach
is to first use an optimizer to find a local mode. However, at such points the gradients of the log
joint are zero, which can cause problems for some gradient-based MCMC methods, such as HMC
(Section 12.5), so it can be better to start “close” to a MAP estimate (see e.g., [HFM17, Sec 7.]).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.3. GIBBS SAMPLING
12.3 Gibbs sampling
The major problems with MH are the need to choose the proposal distribution, and the fact that the
acceptance rate may be low. In this section, we describe an MH method that exploits conditional
independence properties of a graphical model to automatically create a good proposal, with acceptance
probability 1. This method is known as Gibbs sampling.
2
(In physics, this method is known as
Glauber dynamics or the heat bath method.) This is the MCMC analog of coordinate descent.3
12.3.1 Basic idea
The idea behind Gibbs sampling is to sample each variable in turn, conditioned on the values of all
the other variables in the distribution. For example, if we have D = 3 variables, we use
• x
s+1
1 ∼ p(x1|x
s
2
, xs
3
)
• x
s+1
2 ∼ p(x2|x
s+1
1
, xs
3
)
• x
s+1
3 ∼ p(x3|x
s+1
1
, xs+1
2
)
This readily generalizes to D variables. (Note that if xi
is a known variable, we do not sample it, but
it may be used as input to th another conditional distribution.)
The expression p(xi
|x−i) is called the full conditional for variable i. In general, xi may only
depend on some of the other variables. If we represent p(x) as a graphical model, we can infer
the dependencies by looking at i’s Markov blanket, which are its neighbors in the graph (see
Section 4.2.4.3), so we can write
x
s+1
i ∼ p(xi
|x
s
−i
) = p(xi
|x
s
mb(i)
) (12.19)
(Compare to the equation for mean field variational inference in Equation (10.87).)
We can sample some of the nodes in parallel, without affecting correctness. In particular, suppose
we can create a coloring of the (moralized) undirected graph, such that no two neighboring nodes
have the same color. (In general, computing an optimal coloring is NP-complete, but we can use
efficient heuristics such as those in [Kub04].) Then we can sample all the nodes of the same color in
parallel, and cycle through the colors sequentially [Gon+11].
12.3.2 Gibbs sampling is a special case of MH
It turns out that Gibbs sampling is a special case of MH where we use a sequence of proposals of the
form
qi(x
′
|x) = p(x
′
i
|x−i)I
￾
x
′
−i = x−i

(12.20)
That is, we move to a new state where xi
is sampled from its full conditional, but x−i
is left
unchanged.
2. Josiah Willard Gibbs, 1839–1903, was an American physicist.
3. Several software libraries exist for applying Gibbs sampling to general graphical models, including Nimble, which is
a C++ library with an R wrapper, and which replaces older programs such as BUGS and JAGS.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens500
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 12.2: Illustration of checkerboard pattern for a 2d MRF. This allows for parallel updates.
We now prove that the acceptance rate of each such proposal is 100%, so the overall algorithm
also has an acceptance rate of 100%. We have
α =
p(x
′
)qi(x|x
′
)
p(x)qi(x′
|x)
=
p(x
′
i
|x
′
−i
)p(x
′
−i
)p(xi
|x
′
−i
)
p(xi
|x−i)p(x−i)p(x
′
i
|x−i)
(12.21)
=
p(x
′
i
|x−i)p(x−i)p(xi
|x−i)
p(xi
|x−i)p(x−i)p(x
′
i
|x−i)
= 1 (12.22)
where we exploited the fact that x
′
−i = x−i
.
The fact that the acceptance rate is 100% does not necessarily mean that Gibbs will converge
rapidly, since it only updates one coordinate at a time (see Section 12.3.7). However, if we can group
together correlated variables, then we can sample them as a group, which can significantly help
mixing.
12.3.3 Example: Gibbs sampling for Ising models
In Section 4.3.2.1, we discuss Ising models and Potts models, which are pairwise MRFs with a 2d
grid structure. The joint distribution has the form
p(x) = 1
Z
Y
i∼j
ψij (xi
, xj |θ) (12.23)
where i ∼ j means i and j are neighbors in the graph.
To apply Gibbs sampling to such a model, we just need to iteratively sample from each full
conditional:
p(xi
|x−i) ∝
Y
j∈nbr(i)
ψij (xi
, xj ) (12.24)
Note that although Gibbs sampling is a sequential algorithm, we can sometimes exploit conditional
independence properties to perform parallel updates [RS97a]. In the case of a 2d grid, we can color
code nodes using a checkerboard pattern shown in Figure 12.2. This has the property that the black
nodes are conditionally independent of each other given the white nodes, and vice versa. Hence we
can sample all the black nodes in parallel (as a single group), and then sample all the white nodes,
etc.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.3. GIBBS SAMPLING
sample 1, Gibbs
−1
−0.5
0
0.5
1
(a)
sample 5, Gibbs
−1
−0.5
0
0.5
1
(b)
mean after 15 sweeps of Gibbs
−1
−0.5
0
0.5
1
(c)
Figure 12.3: Example of image denoising using Gibbs sampling. We use an Ising prior with J = 1 and a
Gaussian noise model with σ = 2. (a) Sample from the posterior after one sweep over the image. (b) Sample
after 5 sweeps. (c) Posterior mean, computed by averaging over 15 sweeps. Compare to Figure 10.9 which
shows the results of mean field inference. Generated by ising_image_denoise_demo.ipynb.
To perform the sampling, we need to compute the full conditional in Equation (12.24). In the
case of an Ising model with edge potentials ψ(xi
, xj ) = exp(Jxixj ), where xi ∈ {−1, +1}, the full
conditional becomes
p(xi = +1|x−i) =
Q
j∈nbr(i) ψij (xi = +1, xj )
Q
j∈nbr(i) ψ(xi = +1, xj ) + Q
j∈nbr(i) ψ(xi = −1, xi)
(12.25)
=
exp[J
P
j∈nbr(i)
xj ]
exp[J
P
j∈nbr(i)
xj ] + exp[−J
P
j∈nbr(i)
xj ]
(12.26)
=
exp[Jηi
]
exp[Jηi
] + exp[−Jηi
]
= σ(2Jηi) (12.27)
where J is the coupling strength, ηi ,
P
j∈nbr(i)
xj , and σ(u) = 1/(1 + e
−u
) is the sigmoid function.
(If we use xi ∈ {0, 1}, this becomes p(xi = +1|x−i) = σ(Jηi).) It is easy to see that ηi = xi(ai − di),
where ai
is the number of neighbors that agree with (have the same sign as) node i, and dt is the
number of neighbors who disagree. If this number is equal, the “forces” on xi cancel out, so the full
conditional is uniform. Some samples from this model are shown in Figure 4.17.
One application of Ising models is as a prior for binary image denoising problems. In particular,
suppose y is a noisy version of x, and we wish to compute the posterior p(x|y) ∝ p(x)p(y|x), where
p(x) is an Ising prior, and p(y|x) = Q
i
p(yi
|xi) is a per-site likelihood term. Suppose this is a
Gaussian. Let ψi(xi) = N (yi
|xi
, σ2
) be the corresponding “local evidence” term. The full conditional
becomes
p(xi = +1|x−i
, y) = exp[Jηi
]ψi(+1)
exp[Jηi
]ψi(+1) + exp[−Jηi
]ψi(−1) (12.28)
= σ

2Jηi − log ψi(+1)
ψi(−1)
(12.29)
Now the probability of xi entering each state is determined both by compatibility with its neighbors
(the Ising prior) and compatibility with the data (the local likelihood term).
See Figure 12.3 for an example of this algorithm applied to a simple image denoising problem. The
results are similar to the mean field results in Figure 10.9.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license502
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.3.4 Example: Gibbs sampling for Potts models
We can extend Section 12.3.3 to the Potts models as follows. Recall that the model has the following
form:
p(x) = 1
Z
exp(−E(x)) (12.30)
E(x) = −J
X
i∼j
I(xi = xj ) (12.31)
For a node i with neighbors nbr(i), the full conditional is thus given by
p(xi = k|x−i) =
exp(J
P
n∈nbr(i)
I(xn = k))
P
k′ exp(J
P
n∈nbr(i)
I(xn = k
′)) (12.32)
So if J > 0, a node i is more likely to enter a state k if most of its neighbors are already in state k,
corresponding to an attractive MRF. If J < 0, a node i is more likely to enter a different state from
its neighbors, corresponding to a repulsive MRF. See Figure 4.18 for some samples from this model
created using this method.
12.3.5 Example: Gibbs sampling for GMMs
In this section, we consider sampling from a Bayesian Gaussian mixture model of the form
p(z = k, x|θ) = πkN (x|µk
, Σk) (12.33)
p(θ) = Dir(π|α)
Y
K
k=1
N (µk
|m0, V0)IW(Σk, S0, ν0) (12.34)
12.3.5.1 Known parameters
Suppose, initially, that the parameteters θ are known. We can easily draw independent samples from
p(x|θ) by using ancestral sampling: first sample z and then x. However, for illustrative purposes, we
will use Gibbs sampling to draw correlated samples. The full conditional for p(x|z = k, θ) is just
N (x|µk
, Σk), and the full conditional for p(z = k|x) is given by Bayes’ rule:
p(z = k|x, θ) = πkN (x|µk
, Σk)
P
k′ πk′N (x|µk′ , Σk′ )
(12.35)
An example of this procedure, applied to a mixture of two 1d Gaussians with means at −20 and
+20, is shown in Figure 12.4. We see that the samples are auto correlated, meaning that if we are
in state 1, we will likely stay in that state for a while, and generate values near µ1; then we will
stochastically jump to state 2, and stay near there for a while, etc. (See Section 12.6.3 for a way to
measure this.) By contrast, independent samples from the joint would not be correlated at all.
In Section 12.3.5.2, we modify this example to sample the parameters of the GMM from their
posterior, p(θ|D), instead of sampling from p(D|θ).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.3. GIBBS SAMPLING
0 200 400 600 800 1000
Sample number
−40
−20
0
20
40
Value of
x
(a)
Iterations
0
250
500
750
1000
Samples
−100
−50
0
50
100
0.00
0.01
0.02
0.03
0.04
(b)
Figure 12.4: (a) Some samples from a mixture of two 1d Gaussians generated using Gibbs sampling. Color
denotes the value of z, vertical location denotes the value of x. Horizontal axis represents time (sample
number). (b) Traceplot of x over time, and the resulting empirical distribution is shown in blue. The true
distribution is shown in red. Compare to Figure 12.1. Generated by mcmc_gmm_demo.ipynb.
12.3.5.2 Unknown parameters
Now suppose the parameters are unknown, so we want to fit the model to data. If we use a
conditionally conjugate factored prior, then the full joint distribution is given by
p(x, z, µ, Σ,π) = p(x|z, µ, Σ)p(z|π)p(π)
Y
K
k=1
p(µk
)p(Σk) (12.36)
=
 Y
N
i=1
Y
K
k=1
(πkN (xi
|µk
, Σk))I(zi=k)
!
× (12.37)
Dir(π|α)
Y
K
k=1
N (µk
|m0, V0)IW(Σk|S0, ν0) (12.38)
We use the same prior for each mixture component.
The full conditionals are as follows. For the discrete indicators, we have
p(zi = k|xi
, µ, Σ,π) ∝ πkN (xi
|µk
, Σk) (12.39)
For the mixing weights, we have (using results from Section 3.4.2)
p(π|z) = Dir({αk +
X
N
i=1
I(zi = k)}
K
k=1) (12.40)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license504
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
For the means, we have (using results from Section 3.4.4.1)
p(µk
|Σk, z, x) = N (µk
|mk, Vk) (12.41)
V−1
k = V−1
0 + NkΣ
−1
k
(12.42)
mk = Vk(Σ
−1
k Nkxk + V−1
0 m0) (12.43)
Nk ,
X
N
i=1
I(zi = k) (12.44)
xk ,
PN
i=1 I(zi = k) xi
Nk
(12.45)
For the covariances, we have (using results from Section 3.4.4.2)
p(Σk|µk
, z, x) = IW(Σk|Sk, νk) (12.46)
Sk = S0 +
X
N
i=1
I(zi = k) (xi − µk
)(xi − µk
)
T
(12.47)
νk = ν0 + Nk (12.48)
12.3.6 Metropolis within Gibbs
When implementing Gibbs sampling, we have to sample from the full conditionals. If the distributions
are conjugate, we can compute the full conditional in closed form, but in the general case, we will
need to devise special algorithms to sample from the full conditionals.
One approach is to use the MH algorithm; this is called Metropolis within Gibbs. In particular,
to sample from x
s+1
i ∼ p(xi
|x
s+1
1:i−1
, x
s
i+1:D), we proceed in 3 steps:
1. Propose x
′
i ∼ q(x
′
i
|x
s
i
)
2. Compute the acceptance probability Ai = min(1, αi) where
αi =
p(x
s+1
1:i−1
, x′
i
, x
s
i+1:D)/q(x
′
i
|x
s
i
)
p(x
s+1
1:i−1
, xs
i
, x
s
i+1:D)/q(x
s
i
|x
′
i
)
(12.49)
3. Sample u ∼ U(0, 1) and set x
s+1
i = x
′
i
if u < Ai
, and set x
s+1
i = x
s
i
otherwise.
12.3.7 Blocked Gibbs sampling
Gibbs sampling can be quite slow, since it only updates one variable at a time (so-called single
site updating). If the variables are highly correlated, the chain will move slowly through the state
space. This is illustrated in Figure 12.5, where we illustrate sampling from a 2d Gaussian. The ellipse
represents the covariance matrix. The size of the moves taken by Gibbs sampling is controlled by the
variance of the conditional distributions. If the variance is ℓ along some coordinate direction, but the
support of the distribution is L along this dimension, then we need O((L/ℓ)
2
) steps to obtain an
independent sample.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.3. GIBBS SAMPLING
−3 −2 −1 0 1 2 3
−2
0
2 L
l
Figure 12.5: Illustration of potentially slow sampling when using Gibbs sampling for a skewed 2d Gaussian.
Adapted from Figure 11.11 of [Bis06]. Generated by gibbs_gauss_demo.ipynb.
In some cases we can efficiently sample groups of variables at a time. This is called blocked
Gibbs sampling [JKK95; WY02], and can make much bigger moves through the state space.
As an example, suppose we want to perform Bayesian inference for a state-space model, such as an
HMM, i.e., we want to sample from
p(θ, z|x) ∝ p(θ)
Y
T
t=1
p(xt|zt, θ)p(zt|zt−1, θ) (12.50)
We can use blocked Gibbs sampling, where we alternate between sampling from p(θ|z, x) and
p(z|x, θ). The former is easy to do (assuming conjugate priors), since all variables in the model are
observed (see Section 29.8.4.1). The latter can be done using forwards-filtering backwards-sampling
(Section 9.2.7).
12.3.8 Collapsed Gibbs sampling
We can sometimes gain even greater speedups by analytically integrating out some of the unknown
quantities. This is called a collapsed Gibbs sampler, and it tends to be more efficient, since
it is sampling in a lower dimensional space. This can result in lower variance, as discussed in
Section 11.6.2.
As an example, consider a GMM with a fully conjugate prior. This can be represented as a DPGM
as shown in Figure 12.6a. Since the prior is conjugate, we can analytically integrate out the model
parameters µk
, Σk, and π, so the only remaining hidden variables are the discrete indicator variables
z. However, once we integrate out π, all the zi nodes become inter-dependent. Similarly, once we
integrate out θk = (µk
, Σk), all the xi nodes become inter-dependent, as shown in Figure 12.6b.
Nevertheless, we can easily compute the full conditionals, and hence implement a Gibbs sampler, as
we explain below. In particular, the full conditional for the latent indicators is given by
p(zi = k|z−i
, x, α, β) ∝ p(zi = k|z−i
, α,✓β)p(x|zi = k, z−i
,✚α, β) (12.51)
∝ p(zi = k|z−i
, α)p(xi
|x−i
, zi = k, z−i
, β)
p(x−i
|✘z ✘✘ i = k, z−i
, β) (12.52)
∝ p(zi = k|z−i
, α)p(xi
|x−i
, zi = k, z−i
, β) (12.53)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license506
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
α
π
z1 zi zN
x1 xi xN
θ1:K
β
(a)
α
z1 zi zN
x1 xi xN
β
(b)
Figure 12.6: (a) A mixture model represented as an “unrolled” DPGM. (b) After integrating out the continuous
latent parameters.
where β = (m0, V0, S0, ν0) are the hyper-parameters for the class-conditional densities. We now
discuss how to compute these terms.
Suppose we use a symmetric prior of the form π ∼ Dir(α), where αk = α/K, for the mixing
weights. Then we can obtain the first term in Equation (12.53), from Equation (3.96), where
p(z1, . . . , zN |α) = Γ(α)
Γ(N + α)
Y
K
k=1
Γ(Nk + α/K)
Γ(α/K)
(12.54)
Hence
p(zi = k|z−i
, α) = p(z1:N |α)
p(z−i
|α)
=
1
Γ(N+α)
1
Γ(N+α−1)
×
Γ(Nk + α/K)
Γ(Nk,−i + α/K)
(12.55)
=
Γ(N + α − 1)
Γ(N + α)
Γ(Nk,−i + 1 + α/K)
Γ(Nk,−i + α/K)
=
Nk,−i + α
N + α − 1
(12.56)
where Nk,−i ,
P
n6=i
I(zn = k) = Nk − 1, and where we exploited the fact that Γ(x + 1) = xΓ(x).
To obtain the second term in Equation (12.53), which is the posterior predictive distribution for
xi given all the other data and all the assignments, we use the fact that
p(xi
|x−i
, z−i
, zi = k, β) = p(xi
|D−i,k, β) (12.57)
where D−i,k = {xj : zj = k, j =6 i} is all the data assigned to cluster k except for xi
. If we use a
conjugate prior for θk, we can compute p(xi
|D−i,k, β) in closed form. Furthermore, we can efficiently
update these predictive likelihoods by caching the sufficient statistics for each cluster. To compute
the above expression, we remove xi
’s statistics from its current cluster (namely zi), and then evaluate
xi under each cluster’s posterior predictive distribution. Once we have picked a new cluster, we add
xi
’s statistics to this new cluster.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.4. AUXILIARY VARIABLE MCMC
Some pseudo-code for one step of the algorithm is shown in Algorithm 12.2, based on [Sud06, p94].
(We update the nodes in random order to improve the mixing time, as suggested in [RS97b].) We
can initialize the sample by sequentially sampling from p(zi
|z1:i−1, x1:i). In the case of GMMs, both
the naive sampler and collapsed sampler take O(NKD) time per step.
Algorithm 12.2: Collapsed Gibbs sampler for a mixture model
1 for each i = 1 : N in random order do
2 Remove xi
’s sufficient statistics from old cluster zi
3 for each k = 1 : K do
4 Compute pk(xi
|β) = p(xi
|{xj : zj = k, j 6= i}, β)
5 Compute p(zi = k|z−i
, α) ∝ (Nk,−i + α/K)pk(xi)
6 Sample zi ∼ p(zi
|·)
7 Add xi
’s sufficient statistics to new cluster zi
The primary advantage of using the collapsed sampler is that it extends to the case where we
have an “infinite” number of mixture components, as in the Dirichlet process mixture model of
Supplementary Section 31.2.2.
12.4 Auxiliary variable MCMC
Sometimes we can dramatically improve the efficiency of sampling by introducing auxiliary variables,
in order to reduce correlation between the original variables. If the original variables are denoted by
x, and the auxiliary variables by v, then the augmented distribution becomes p(x, v). We assume it
is easier to sample from this than the marginal distribution p(x). If so, we can draw joint samples
(x
s
, v
s
) ∼ p(x, v), and then just “throw away” the v
s
, and the result will be samples from the desired
marginal, x
s ∼
P
v
p(x, v). We give some examples of this below.
12.4.1 Slice sampling
Consider sampling from a univariate, but multimodal, distribution p(x) = p˜(x)/Zp, where p˜(x) is
unnormalized, and Zp =
R
p˜(x)dx. We can sometimes improve the ability to make large moves by
adding a uniform auxiliary variable v. We define the joint distribution as follows:
pˆ(x, v) = 
1/Zp if 0 ≤ v ≤ p˜(x)
0 otherwise (12.58)
The marginal distribution over x is given by
Z
pˆ(x, v)dv =
Z p˜(x)
0
1
Zp
dv =
p˜(x)
Zp
= p(x) (12.59)
so we can sample from p(x) by sampling from pˆ(x, v) and then ignoring v. To do this, we will use a
technique called slice sampling [Nea03].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license508
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
x x
u x
(i+1)
(i)
(i+1)
f(x ) (i)
(a)
5 4 3 2 1 0 1 2 3 4
0
20
40
60
80
100
120
140
160
180
(b)
Figure 12.7: Slice sampling. (a) Illustration of one step of the algorithm in 1d. Given a previous sample x
i
, we
sample u
i+1 uniformly on [0, f(x
i
)], where f = p˜ is the (unnormalized) target density. We then sample x
i+1
along the slice where f(x) ≥ u
i+1. From Figure 15 of [And+03]. Used with kind permission of Nando de Freitas.
(b) Output of slice sampling applied to a 1d distribution. Generated by slice_sampling_demo_1d.ipynb.
Slope
3.0
3.5
4.0
4.5
5.0
5.5
Intercept
2.4
2.2
2.0
1.8
1.6
1.4
1.2
1.0
Posterior density 1e 11
0.0
0.5
1.0
1.5
2.0
2.5
3.0
3.5
4.0
Slope
3.5
4.0
4.5
5.0
5.5
6.0
Intercept
2.2
2.0
1.8
1.6
1.4
1.2
1.0
0.8
Posterior density
0.0
2.5
5.0
7.5
10.0
12.5
15.0
17.5
20.0
Figure 12.8: Posterior for binomial regression for 1d data. Left: slice sampling approximation. Right: grid
approximation. Generated by slice_sampling_demo_2d.ipynb.
This works as follows. Given previous sample x
i
, we sample v
i+1 from
p(v|x
i
) = U[0,p˜(xi)](v) (12.60)
This amounts to uniformly picking a point on the vertical line between 0 and p˜(x
i
), We use this to
construct a “slice” of the density at or above this height, by computing Ai+1 = {x : p˜(x) ≥ v
i+1}.
We then sample x
i+1 uniformly from ths set. See Figure 12.7(a) for an illustration.
To compute the level set A, we can use an iterative search procedure called stepping out, in which
we start with an interval xmin ≤ x ≤ xmax around the current point x
i of some width, and then we
keep extending it until the endpoints fall outside the slice. We can then use rejection sampling to
sample from the interval. For the details, see [Nea03].
To apply the method to multivariate distributions, we sample one extra auxiliary variable for
each dimension. Thus we perfom 2D sampling operations to draw a single joint sample, where
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.4. AUXILIARY VARIABLE MCMC
Figure 12.9: Illustration of the Swendsen-Wang algorithm on a 2d grid. Used with kind permission of Kevin
Tang.
D is the number of random variables. The advantage of this over Gibbs sampling applied to the
original (non-augmented) distribution is that it only needs access to the unnormalized joint, not the
full-conditionals.
Figure 12.7(b) illustrates the algorithm in action on a synthetic 1d problem. Figure 12.8 illustrates
its behavior on a slightly harder problem, namely binomial logistic regression. The model has the
form yi ∼ Bin(ni
, logit(β1 + β2xi)). We use a vague Gaussian prior for the βj ’s. On the left we
show the slice sampling approximation to the posterior, and on the right we shpw a grid-based
approximation, as a simple deteterministic proxy for the true posterior. We see a close correpondence.
12.4.2 Swendsen-Wang
Consider an Ising model of the following form: p(x) = 1
Z
Q
e Ψ(xe), where xe = (xi
, xj ) for edge
e = (i, j), xi ∈ {+1, −1}, and the edge potential is defined by 
e
J
e
−J
e
−J
e
J

, where J is the edge
strength. In Section 12.3.3, we discussed how to apply Gibbs sampling to this model. However, this
can be slow when J is large in absolute value, because neighboring states can be highly correlated.
The Swendsen-Wang algorithm [SW87b] is an auxiliary variable MCMC sampler which mixes
much faster, at least for the case of attractive or ferromagnetic models, with J > 0.
Suppose we introduce auxiliary binary variables, one per edge.4 These are called bond variables,
and will be denoted by v. We then define an extended model p(x, v) of the form p(x, v) =
4. Our presentation of the method is based on notes by David MacKay, available from http://www.inference.phy.
cam.ac.uk/mackay/itila/swendsen.pdf.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license510
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
1
Z′
Q
e Ψ(xe, ve), where ve ∈ {0, 1}, and we define the new edge potentials as follows:
Ψ(xe, ve = 0) = 
e
−J
e
−J
e
−J
e
−J

, Ψ(xe, ve = 1) = 
e
J − e
−J 0
0 e
J − e
−J

(12.61)
It is clear that P1
ve=0 Ψ(xe, ve) = Ψ(xe), and hence that P
v
p(x, v) = p(x), as required.
Fortunately, it is easy to apply Gibbs sampling to this extended model. The full conditional p(v|x)
factorizes over the edges, since the bond variables are conditionally independent given the node
variables. Furthermore, the full conditional p(ve|xe) is simple to compute: if the nodes on either end
of the edge are in the same state (xi = xj ), we set the bond ve to 1 with probability p = 1 − e
−2J
,
otherwise we set it to 0. In Figure 12.9 (top right), the bonds that could be turned on (because their
corresponding nodes are in the same state) are represented by dotted edges. In Figure 12.9 (bottom
right), the bonds that are randomly turned on are represented by solid edges.
To sample p(x|v), we proceed as follows. Find the connected components defined by the graph
induced by the bonds that are turned on. (Note that a connected component may consist of a
singleton node.) Pick one of these components uniformly at random. All the nodes in each such
component must have the same state. Pick a state ±1 uniformly at random, and set all the variables
in this component to adopt this new state. This is illustrated in Figure 12.9 (bottom right), where
the green square denotes the selected connected component; we set all the nodes within this square
to white, to get the bottom left configuration.
It should be intuitively clear that Swendsen-Wang makes much larger moves through the state space
than Gibbs sampling. The gains are exponentially large for certain settings of the edge parameter.
More precisely, let the edge strength be parameterized by J/T, where T > 0 is a computational
temperature. For large T, the nodes are roughly independent, so both methods work equally well.
However, as T approaches a critical temperature Tc, the typical states of the system have very
long correlation lengths, and Gibbs sampling takes a very long time to generate independent samples.
As the temperature continues to drop, the typical states are either all on or all off. The frequency
with which Gibbs sampling moves between these two modes is exponentially small. By contrast, SW
mixes rapidly at all temperatures.
Unfortunately, if any of the edge weights are negative, J < 0, the system is frustrated, and there
are exponentially many modes, even at low temperature. SW does not work very well in this setting,
since it tries to force many neighboring variables to have the same state. In fact, sampling from these
kinds of frustrated systems is provably computationally hard for any algorithm [JS93; JS96].
12.5 Hamiltonian Monte Carlo (HMC)
Many MCMC algorithms perform poorly in high dimensional spaces, because they rely on a form
of random search based on local perturbations. In this section, we discuss a method known as
Hamiltonian Monte Carlo or HMC, that leverages gradient information to guide the local moves.
This is an auxiliary variable method (Section 12.4) derived from physics [Dua+87; Nea93; Mac03;
Nea10; Bet17].5
In particular, the method builds on Hamiltonian mechanics, which we describe
below.
5. The method was originally called hybrid MC [Dua+87]. It was introduced to the statistics community in [Nea93],
and was renamed to Hamiltonian MC in [Mac03].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.5. HAMILTONIAN MONTE CARLO (HMC)
12.5.1 Hamiltonian mechanics
Consider a particle rolling around an energy landscape. We can characterize the motion of the particle
in terms of its position θ ∈ R
D (often denoted by q) and its momentum v ∈ R
D (often denoted by
p). The set of possible values for (θ, v) is called the phase space. We define the Hamiltonian
function for each point in phase space as follows:
H(θ, v) , E(θ) + K(v) (12.62)
where E(θ) is the potential energy, K(v) is the kinetic energy, and the Hamiltonian is the total
energy. In a physical setting, the potential energy is due to the pull of gravity, and the momentum is
due to the motion of the particle. In a statistical setting, we often take the potential energy to be
E(θ) = − log ˜p(θ) (12.63)
where p˜(θ) is a possibly unnormalized distribution, such as p(θ, D), and the kinetic energy to be
K(v) = 1
2
v
TΣ
−1
v (12.64)
where Σ is a positive definite matrix, known as the inverse mass matrix.
Stable orbits are defined by trajectories in phase space that have a constant energy, The trajectory
of a particle within an energy level set can be obtained by solving the following continuous time
differential equations, known as Hamilton’s equations:
dθ
dt =
∂H
∂v
=
∂K
∂v
dv
dt = −
∂H
∂θ
= −
∂E
∂θ
(12.65)
To see why energy is conserved, note that
dH
dt =
X
D
i=1

∂H
∂θi
dθi
dt +
∂H
∂vi
dvi
dt 
=
X
D
i=1

∂H
∂θi
∂H
∂vi
−
∂H
∂θi
∂H
∂vi

= 0 (12.66)
Intuitively, we can understand this result as follows: a satellite in orbit around a planet will “want”
to continue in a straight line due to its momentum, but will get pulled in towards the planet due
to gravity, and if these forces cancel, the orbit is stable. If the satellite starts spiraling towards the
planet, its kinetic energy will increase but its potential energy will decrease.
Note that the mapping from (θ(t), v(t)) to (θ(t+s), v(t+s)) for some time increment s is invertible
for small enough time steps. Furthermore, this mapping is volume preserving, so has a Jacobian
determinant of 1. (See e.g., [BZ20, p287] for a proof.) These facts will be important later when we
turn this system into an MCMC algorithm.
12.5.2 Integrating Hamilton’s equations
In this section, we discuss how to simulate Hamilton’s equations in discrete time.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license512
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.5.2.1 Euler’s method
The simplest way to model the time evolution is to update the position and momentum simultaneously
by a small amount, known as the step size η:
vt+1 = vt + η
dv
dt (θt, vt) = v(t) − η
∂E(θt)
∂θ
(12.67)
θt+1 = θt + η
dθ
dt (θt, vt) = θt + η
∂K(vt)
∂v
(12.68)
If the kinetic energy has the form in Equation (12.64) then the second expression simplifies to
θt+1 = θt + ηΣ
−1
vt+1 (12.69)
This is known as Euler’s method.
12.5.2.2 Modified Euler’s method
The modified Euler’s method is slightly more accurate, and works as follows: First update the
momentum, and then update the position using the new momentum:
vt+1 = vt + η
dv
dt (θt, vt) = vt − η
∂E(θt)
∂θ
(12.70)
θt+1 = θt + η
dθ
dt (θt, vt+1) = θt + η
∂K(vt+1)
∂v
(12.71)
Unfortunately, the asymmetry of this method can cause some theoretical problems (see e.g., [BZ20,
p287]) which we resolve below.
12.5.2.3 Leapfrog integrator
In this section, we discuss the leapfrog integrator, which is a symmetrized version of the modified
Euler method. We first perform a “half” update of the momentum, then a full update of the position,
and then finally another “half” update of the momentum:
vt+1/2 = vt −
η
2
∂E(θt)
∂θ
(12.72)
θt+1 = θt + η
∂K(vt+1/2)
∂v
(12.73)
vt+1 = vt+1/2 −
η
2
∂E(θt+1)
∂θ
(12.74)
If we perform multiple leapfrog steps, it is equivalent to performing a half step update of v at the
beginning and end of the trajectory, and alternating between full step updates of θ and v in between.
12.5.2.4 Higher order integrators
It is possible to define higher order integrators that are more accurate, but take more steps. For
details, see [BRSS18].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.5. HAMILTONIAN MONTE CARLO (HMC)
12.5.3 The HMC algorithm
We now describe how to use Hamiltonian dynamics to define an MCMC sampler in the expanded
state space (θ, v). The target distribution has the form
p(θ, v) = 1
Z
exp [−H(θ, v)] = 1
Z
exp 
−E(θ) −
1
2
v
TΣv

(12.75)
The marginal distribution over the latent variables of interest has the form
p(θ) = Z
p(θ, v)dv =
1
Zq
e
−E(θ)
Z
1
Zp
e
− 1
2
v
TΣv
dv =
1
Zq
e
−E(θ)
(12.76)
Suppose the previous state of the Markov chain is (θt−1, vt−1). To sample the next state, we
proceed as follows. We set the initial position to θ
′
0 = θt−1, and sample a new random momentum,
v
′
0 ∼ N (0, Σ). We then initialize a random trajectory in the phase space, starting at (θ
′
0
, v
′
0
), and
followed for L leapfrog steps, until we get to the final proposed state (θ
∗
, v
∗
) = (θ
′
L
, v
′
L
). If we have
simulated Hamiltonian mechanics correctly, the energy should be the same at the start and end
of this process; if not, we say the HMC has diverged, and we reject the sample. If the energy is
constant, we compute the MH acceptance probability
α = min 
1,
p(θ
∗
, v
∗
)
p(θt−1, vt−1)

= min (1, exp [−H(θ
∗
, v
∗
) + H(θt−1, vt−1)]) (12.77)
(The transition probabilities cancel since the proposal is reversible.) Finally, we accept the proposal
by setting (θt, vt) = (θ
∗
, v
∗
) with probability α, otherwise we set (θt, vt) = (θt−1, vt−1). (In practice
we don’t need to keep the momentum term, it is only used inside of the leapfrog algorithm.) See
Algorithm 12.3 for the pseudocode.6
Algorithm 12.3: Hamiltonian Monte Carlo
1 for t = 1 : T do
2 Generate random momentum vt−1 ∼ N (0, Σ)
3 Set (θ
′
0
, v
′
0
) = (θt−1, vt−1)
4 Half step for momentum: v
′
1
2
= v
′
0 −
η
2 ∇E(θ
′
0
)
5 for l = 1 : L − 1 do
6 θ
′
l = θ
′
l−1 + ηΣ
−1
v
′
l−1/2
7 v
′
l+1/2 = v
′
l−1/2 − η∇E(θ
′
l
)
8 Full step for location: θ
′
L = θ
′
L−1 + ηΣ
−1
v
′
L−1/2
9 Half step for momentum: v
′
L = v
′
L−1/2 −
η
2 ∇E(θ
′
L
)
10 Compute proposal (θ
∗
, v
∗
) = (θ
′
L
, v
′
L
)
11 Compute α = min (1, exp[−H(θ
∗
, v
∗
) + H(θt−1, vt−1)])
12 Set θt = θ
∗ with probability α, otherwise θt = θt−1.
6. There are many high-quality implementations of HMC. For example, BlackJAX in JAX.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license514
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We need to sample a new momentum at each iteration to satisfy ergodicity. To see why, recall that
H(θ, v) stays approximately constant as we move through phase space. If H(θ, v) = E(θ) + 1
2
v
TΣv,
then clearly E(θ) ≤ H(θ, v) = h for all locations θ along the trajectory. Thus the sampler cannot
reach states where E(θ) > h. To ensure the sampler explores the full space, we must pick a random
momentum at the start of each iteration.
12.5.4 Tuning HMC
We need to specify three hyperparameters for HMC: the number of leapfrog steps L, the step size η,
and the covariance Σ.
12.5.4.1 Choosing the number of steps using NUTS
We want to choose the number of leapfrog steps L to be large enough that the algorithm explores
the level set of constant energy, but without doubling back on itself, which would waste computation,
due to correlated samples. Fortunately, there is an algorithm, known as the no-U-turn sampler or
NUTS algorithm [HG14], which can adaptively choose L for us.
12.5.4.2 Choosing the step size
When Σ = I, the ideal step size η should be roughly equal to the width of E(θ) in the most constrained
direction of the local energy landscape. For a locally quadratic potential, this corresponds to the
square root of the smallest marginal standard deviation of the local covariance matrix. (If we think
of the energy surface as a valley, this corresponds to the direction with the steepest sides.) A step
size much larger than this will cause moves that are likely to be rejected because they move to places
which increase the potential energy too much. On the other hand, if the step size is too low, the
proposal distribution will not move much from the starting position, and the algorithm will be very
slow.
In [BZ20, Sec 9.5.4] they recommend the following heuristic for picking η: set Σ = I and L = 1,
and then vary η until the acceptance rates are in the range of 40%–80%. Of course, different step
sizes might be needed in different parts of the state space. In this case, we can use learning rate
schedules from the optimization literature, such as cyclical schedules [Zha+20d].
12.5.4.3 Choosing the covariance (inverse mass) matrix
To allow for larger step sizes, we can use a smarter choice for Σ, also called the inverse mass matrix.
One way to estimate a fixed Σ is to run HMC with Σ = I for a warm-up period, until the chain is
“burned in” (see Section 12.6); then we run for a few more steps, so we can compute the empirical
covariance matrix using Σ = E

(θ − θ)(θ − θ)
T

. In [Hof+19] they propose a method called the
NeuTra HMC algorithm which “neutralizes” bad geometry by learning an inverse autoregressive
flow model (Section 23.2.4.3) in order to map the warped distribution to an isotropic Gaussian. This
is often an order of magnitude faster than vanilla HMC.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.5. HAMILTONIAN MONTE CARLO (HMC)
12.5.5 Riemann manifold HMC
If we let the covariance matrix change as we move position, so Σ is a function of θ, the method
is known as Riemann manifold HMC or RM-HMC [GC11; Bet13], since the moves follow a
curved manifold, rather than the flat manifold induced by a constant Σ.
A natural choice for the covariance matrix is to use the Hessian at the current location, to capture
the local geometry:
Σ(θ) = ∇2
E(θ) (12.78)
Since this is not always positive definite, an alternative, that can be used for some problems, is to
use the Fisher information matrix (Section 3.3.4), given by
Σ(θ) = −Ep(x|θ)

∇2
log p(x|θ)

(12.79)
Once we have computed Σ(θ), we can compute the kinetic energy as follows:
K(θ, v) = 1
2
log((2π)
D|Σ(θ)|) + 1
2
v
TΣ(θ)v (12.80)
Unfortunately the Hamiltonian updates of θ and v are no longer separable, which makes the RM-HMC
algorithm more complex to implement, so it is not widely used.
12.5.6 Langevin Monte Carlo (MALA)
A special case of HMC occurs when we take L = 1 leapfrog steps. This is known as Langevin Monte
Carlo (LMC), or the Metropolis adjusted Langevin algorithm (MALA) [RT96]. This gives
rise to the simplified algorithm shown in Algorithm 12.4.
Algorithm 12.4: Langevin Monte Carlo
1 for t = 1 : T do
2 Generate random momentum vt−1 ∼ N (0, Σ)
3 θ
∗ = θt−1 −
η
2
2 Σ
−1∇E(θt−1) + ηΣ
−1
vt−1
4 v
∗ = vt−1 −
η
2 ∇E(θt−1) −
η
2 ∇E(θ
∗
)
5 Compute α = min (1, exp[−H(θ
∗
, v
∗
)]/ exp[−H(θt−1, vt−1)])
6 Set θt = θ
∗ with probability α, otherwise θt = θt−1.
A further simplification is to eliminate the MH acceptance step. In this case, the update becomes
θt = θt−1 −
η
2
2
Σ
−1∇E(θt−1) + ηΣ
−1
vt−1 (12.81)
= θt−1 −
η
2
2
Σ
−1∇E(θt−1) + η
p
Σ
−1
ǫt−1 (12.82)
where vt−1 ∼ N (0, Σ) and ǫt−1 ∼ N (0, I). This is just like gradient descent with added noise. If we
set Σ to be the Fisher information matrix, this becomes natural gradient descent (Section 6.4) with
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license516
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
added noise. If we approximate the gradient with a stochastic gradient, we get a method known as
SGLD, or stochastic gradient Langevin descent (see Section 12.7.1 for details).
Now suppose Σ = I, and we set η =
√
2. In continuous time, we get the following stochastic
differential equation (SDE), known as Langevin diffusion:
dθt = −∇E(θt)dt +
√
2dBt (12.83)
where Bt represents D-dimensional Brownian motion. If we use this to generate the samples, the
method is known as the anadjusted Langevin algorithm or ULA [Par81; RT96].
12.5.7 Connection between SGD and Langevin sampling
In this section, we discuss a deep connection between stochastic gradient descent (SGD) and Langevin
sampling, following the presentation of [BZ20, Sec 10.2.3].
Consider the minimization of the additive loss
L(θ) = X
N
n=1
Ln(θ) (12.84)
For example, we may define Ln(θ) = − log p(yn|xn, θ.) We will use a minibatch approximation to
the gradients:
∇BL(θ) = 1
B
X
n∈S
∇Ln(θ) (12.85)
where S = {i1, . . . , iB} is a randomly chosen set of indices of size B. For simplicity of analysis, we
assume the indices are chosen with replacement from {1, . . . , N}.
Let us define the (scaled) error (due to minibatching) in the estimated gradient by
vt ,
√
η(∇L(θt) − ∇BL(θt)) (12.86)
This is called the diffusion term. Then we can rewrite the SGD update as
θt+1 = θt − η∇BL(θt) = θt − η∇L(θt) + √
ηvt (12.87)
The diffusion term vt has mean 0, since
E [∇BL(θ)] = 1
B
X
B
j=1
E

∇Lij
(θ)

=
1
B
X
B
j=1
∇L(θ) = ∇L(θ) (12.88)
To compute the variance of the diffusion term, note that
V [∇BL(θ)] = 1
B2
X
B
j=1
V

∇Lij
(θ)

(12.89)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.5. HAMILTONIAN MONTE CARLO (HMC)
α
π
z1 zi zN
x1 xi xN
θ1:K
β
(a)
α
π
x1 xi xN
θ1:K
β
(b)
Figure 12.10: (a) A mixture model. (b) After integrating out the discrete latent variables.
where
V

∇Lij
(θ)

= E

∇Lij
(θ)∇Lij
(θ)
T

− E

∇Lij
(θ)

E

∇Lij
(θ)
T

(12.90)
=
 
1
N
X
N
n=1
∇Ln(θ)∇Ln(θ)
T
!
− ∇L(θ)∇L(θ)
T , D(θ) (12.91)
where D(θ) is called the diffusion matrix. Hence V [vt] = η
B D(θt).
[LTW15] prove that the following continuous time stochastic differential equation is a first-order
approximation of minibatch SGD (assuming the loss function is Lipschitz continuous):
dθ(t) = −∇L(θ(t))dt +
r
η
B
D(θt)dB(t) (12.92)
where B(t) is Brownian motion. Thus the noise from minibatching causes SGD to act like a Langevin
sampler. (See [Hu+17] for more information.)
The scale factor for the noise, τ =
η
B
, plays the role of temperature. Thus we see that using
a smaller batch size is like using a larger temperature; the added noise ensures that SGD avoids
going into narrow ravines, and instead spends most of its time in flat minima which have better
generalization performance [Kes+17]. See Section 17.4.1 for more discussion of this point.
12.5.8 Applying HMC to constrained parameters
To apply HMC, we require that all the latent quantities be continuous (real-valued) and have
unconstrained support, i.e., θ ∈ R
D, so discrete latent variables need to be marginalized out
(although some recent work, such as [NDL20; Zho20], relaxes this requirement).
As an example of how this can be done, consider a GMM. We can easily write the likelihood
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license518
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
without discrete latents as follows:
p(xn|θ) = X
K
k=1
πkN (xn|µk
, Σk) (12.93)
The corresponding “collapsed” model is shown in Figure 12.10(b). (Note that this is the opposite of
Section 12.3.8, where we integrated out the continuous parameters in order to apply Gibbs sampling
to the discrete latents.) We can apply similar techniques to other discrete latent variable models. For
example, to apply HMC to HMMs, we can use the forwards algorithm (Section 9.2.2) to efficiently
compute p(xn|θ) = P
z1:T
p(xn, zn,1:T |θ).
In addition to marginalizing out any discrete latent variables, we need to ensure the remaining
continuous latent variables are unconstrained. This often requires performing a change of variables
using a bijector. For example, instead of sampling the discrete probability vector from the probability
simplex π ∈ S
K, we should sample the logits η ∈ R
K. After sampling, we can transform back, since
bijectors are invertible. (For a practical example, see change_of_variable_hmc.ipynb.)
12.5.9 Speeding up HMC
Although HMC uses gradient information to explore the typical set, sometimes the geometry of the
typical set can be difficult to sample from. See Section 12.5.4.3 for ways to estimate the mass matrix,
which can help with such difficult cases.
Another issue is the cost of evaluating the target distribution, E(θ) = − log ˜p(θ). For many ML
applications, this has the form log ˜p(θ) = log p0(θ) + PN
n=1 log p(θn|θ). This takes O(N) time to
compute. We can speed this up by using stochastic gradient methods; see Section 12.7 for details.
12.6 MCMC convergence
We start MCMC from an arbitrary initial state. As we explained in Section 2.6.4, the samples will be
coming from the chain’s stationary distribution only when the chain has “forgotten” where it started
from. The amount of time it takes to enter the stationary distribution is called the mixing time (see
Section 12.6.1 for details). Samples collected before the chain has reached its stationary distribution
do not come from p
∗
, and are usually thrown away. The initial period, whose samples will be ignored,
is called the burn-in phase.
For example, consider a uniform distribution on the integers {0, 1, . . . , 20}. Suppose we sample
from this using a symmetric random walk. In Figure 12.11, we show two runs of the algorithm. On
the left, we start in state 10; on the right, we start in state 17. Even in this small problem it takes
over 200 steps until the chain has “forgotten” where it started from. Proposal distributions that
make larger changes can converge faster. For example, [BD92; Man] prove that it takes about 7 riffle
shuffles to properly mix a deck of 52 cards (i.e., to ensure the distribution is uniform).
In Section 12.6.1 we discuss how to compute the mixing time theoretically. In practice, this can be
very hard [BBM10] (this is one of the fundamental weaknesses of MCMC), so in Section 12.6.2, we
discuss practical heurstics.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.6. MCMC CONVERGENCE
p0(x)
Initial Condition x0 = 10
p1(x)
p2(x)
p3(x)
p10(x)
p100(x)
p200(x)
0 5 10 15 20
x
p400(x)
(a)
p0(x)
Initial Condition x0 = 17
p1(x)
p2(x)
p3(x)
p10(x)
p100(x)
p200(x)
0 5 10 15 20
x
p400(x)
(b)
Figure 12.11: Illustration of convergence to the uniform distribution over {0, 1, . . . , 20} using a symmetric
random walk starting from (left) state 10, and (right) state 17. Adapted from Figures 29.14 and 29.15 of
[Mac03]. Generated by random_walk_integers.ipynb.
12.6.1 Mixing rates of Markov chains
The amount of time it takes for a Markov chain to converge to the stationary distribution, and forget
its initial state, is called the mixing time. More formally, we say that the mixing time from state
x0 is the minimal time such that, for any constant ǫ > 0, we have that
τǫ(x0) , min{t : ||δx0
(x)T
t − p
∗
||1 ≤ ǫ} (12.94)
where δx0
(x) is a distribution with all its mass in state x0, T is the transition matrix of the chain
(which depends on the target p
∗ and the proposal q), and δx0
(x)T
t
is the distribution after t steps.
The mixing time of the chain is defined as
τǫ , max
x0
τǫ(x0) (12.95)
This is the maximum amount of time it takes for the chain’s distribution to get ǫ close to p
∗
from
any starting state.
The mixing time is determined by the eigengap γ = λ1 − λ2, which is the difference between
the first and second eigenvalues of the transition matrix. For a finie state chain, one cans show
τǫ = O(
1
γ
log n
ǫ
), where n is the number of states.
We can also study the problem by examining the geometry of the state space. For example,
consider the chain in Figure 12.12. We see that the state space consists of two “islands”, each of
which is connected via a narrow “bottleneck”. (If they were completely disconnected, the chain
would not be ergodic, and there would no longer be a unique stationary distribution, as discussed
in Section 2.6.4.3.) We define the conductance φ of a chain as the minimum probability, over all
subsets S of states, of transitioning from that set to its complement:
φ , min
S:0≤p∗(S)≤0.5
P
x∈S,x′∈Sc T(x → x
′
)
p
∗(S)
, (12.96)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license520
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
x
2
x
4
x
7
x
5
x
x 6
1
x
3
Figure 12.12: A Markov chain with low conductance. The dotted arcs represent transitions with very low
probability. From Figure 12.6 of [KF09a]. Used with kind permission of Daphne Koller.
One can show that τǫ ≤ O

1
φ2 log n
ǫ

. Hence chains with low conductance have high mixing time.
For example, distributions with well-separated modes usually have high mixing time. Simple MCMC
methods, such as MH and Gibbs, often do not work well in such cases, and more advanced algorithms,
such as parallel tempering, are necessary (see e.g., [ED05; Kat+06; BZ20]).
12.6.2 Practical convergence diagnostics
Computing the mixing time of a chain is in general quite difficult, since the transition matrix is
usually very hard to compute. Furthermore, diagnosing convergence is computationally intractable
in general [BBM10]. Nevertheless, various heuristics have been proposed — see e.g., [Gey92; CC96;
BR98; Veh+19]. We discuss some of the current recommended approaches below, following [Veh+19].
12.6.2.1 Trace plots
One of the simplest approaches to assessing if the method has converged is to run multiple chains
(typically 3 or 4) from very different overdispersed starting points, and to plot the samples of some
quantity of interest, such as the value of a certain component of the state vector, or some event
such as the value taking on an extreme value. This is called a trace plot. If the chain has mixed,
it should have “forgotten” where it started from, so the trace plots should converge to the same
distribution, and thus overlap with each other.
To illustrate this, we will consider a very simple, but enlightening, example from [McE20, Sec 9.5].
The model is a univariate Gaussian, yi ∼ N (α, σ), with just 2 observations, y1 = −1 and y2 = +1.
We first consider a very diffuse prior, α ∼ N (0, 1000) and σ ∼ Expon(0.0001), both of which allow
for very large values of α and σ. We fit the model using HMC using 3 chains and 500 samples. The
result is shown in Figure 12.13. On the right, we show the trace plots for α and σ for 3 different
chains. We see that they do not overlap much with each other. In addition, the numerous black
vertical lines at the bottom of the plot indicate that HMC had many divergences.
The problem is caused by the overly diffuse priors, which do not get overwhelmed by the likelihood
because we only have 2 datapoints. Thus the posterior is also diffuse. We can fix this by using
slightly stronger priors, that keep the parameters close to more sensible values. For example, suppose
we use α ∼ N (1, 10) and σ ∼ Expon(1). Now we get the results in Figure 12.14. On the right we see
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.6. MCMC CONVERGENCE
−1000 −500 0 500 1000
alpha
0 100 200 300 400
−1000
0
1000
alpha
0 500 1000 1500 2000
sigma
chain1
chain2
chain3
0 100 200 300 400
0
2000
sigma
Figure 12.13: Marginals (left) and trace plot (right) for the univariate Gaussian using the diffuse prior.
Black vertical lines indicate HMC divergences. Adapted from Figures 9.9–9.10 of [McE20]. Generated by
mcmc_traceplots_unigauss.ipynb.
−4 −2 0 2 4
alpha
0 100 200 300 400
−5
0
alpha
1 2 3 4 5
sigma
chain1
chain2
chain3
0 100 200 300 400
2.5
5.0
sigma
Figure 12.14: Marginals (left) and trace plot (right) for the univariate Gaussian using the sensible prior.
Adapted from Figures 9.9–9.10 of [McE20]. Generated by mcmc_traceplots_unigauss.ipynb.
that the traceplots overlap. On the left, we see that the marginal distributions from each chain have
support over a reasonable interval, and have a peak at the “right” place (the MLE for α is 0, and for
σ is 1). And we don’t see any divergence warnings (vertical black markers in the plot).
Since trace plots of converging chains correspond to overlapping lines, it can be hard to distinguish
success from failure. An alternative plot, known as a trace rank plot, was recently proposed in
[Veh+19]. (In [McE20], this is called a trankplot, a term we borrow.) The idea is to compute
the rank of each sample based on all the samples from all the chains, after burnin. We then plot
a histogram of the ranks for each chain separately. If the chains have converged, the distribution
over ranks should be uniform, since there should be no preference for high or low scoring samples
amongst the chains.
The trankplot for the model with the diffuse prior is shown in Figure 12.15. (The x-axis is from 1
to the total number of samples, which in this example is 1500, since we use 3 chains and draw 500
samples from each.) We can see that the different chains are clearly not mixing. The trankplot for
the model with the sensible prior is shown in Figure 12.16; this looks much better.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license522
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 250 500 750 1000 1250 1500
Rank (all chains)
0
1
2
Chain
alpha
0 250 500 750 1000 1250 1500
Rank (all chains)
0
1
2
Chain
sigma
Figure 12.15: Trace rank plot for the univariate Gaussian using the diffuse prior. Adapted from Figures
9.9–9.10 of [McE20]. Generated by mcmc_traceplots_unigauss.ipynb.
0 250 500 750 1000 1250 1500
Rank (all chains)
0
1
2
Chain
alpha
0 250 500 750 1000 1250 1500
Rank (all chains)
0
1
2
Chain
sigma
Figure 12.16: Trace rank plot for the univariate Gaussian using the sensible prior. Adapted from Figures
9.9–9.10 of [McE20]. Generated by mcmc_traceplots_unigauss.ipynb.
12.6.2.2 Estimated potential scale reduction (EPSR)
In this section, we discuss a way to assess convergence more quantitatively. The basic idea is this: if
one or more chains has not mixed well, then the variance of all the chains combined together will be
higher than the variance of the individual chains. So we will compare the variance of the quantity of
interest computed between and within chains.
More precisely, suppose we have M chains, and we draw N samples from each. Let xnm denote
the quantity of interest derived from the n’th sample from the m’th chain. We compute the between￾and within-sequence variances as follows:
B =
N
M − 1
X
M
m=1
(x·m − x··)
2
, where x·m =
1
N
X
N
n=1
xnm, x·· =
1
M
X
M
m=1
x·m (12.97)
W =
1
M
X
M
m=1
s
2
m, where s
2
m =
1
N − 1
X
N
n=1
(xnm − x·m)
2
(12.98)
The formula for s
2
m is the usual unbiased estimate for the variance from a set of N samples; W is
just the average of this. The formula for B is similar, but scaled up by N since it is based on the
variance of x·m, which are averaged over N values.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.6. MCMC CONVERGENCE
Next we compute the following average variance:
Vˆ + ,
N − 1
N
W +
1
N
B (12.99)
Finally, we compute the following quantity, known as the estimated potential scale reduction
or R-hat:
Rˆ ,
s
Vˆ +
W
(12.100)
In [Veh+19], they recommend checking if R <ˆ 1.01 before declaring convergence.
For example, consider the Rˆ values for various samplers for our univariate GMM example. In
particular, consider the 3 MH samplers in Figure 12.1, and the Gibbs sampler in Figure 12.4. The Rˆ
values are 1.493, 1.039, 1.005, and 1.007. So this diagnostic has correctly identified that the first two
samplers are unreliable, which evident from the figure.
In practice, it is recommended to use a slightly different quantity, known as split-Rˆ. This can
be computed by splitting each chain into the first and second halves, thus doubling the number of
chains M (but halving the number of samples N from each), before computing Rˆ. This can detect
non-stationarity within a single chain.
12.6.3 Effective sample size
Although MCMC lets us draw samples from a target distribution (assuming it has converged), the
samples are not independent, so we may need to draw a lot of them to get a reliable estimate. In
this section, we discuss how to compute the effective sample size or ESS from a set of (possibly
correlated) samples.
To start, suppose we draw N independent samples from the target distribution, and let xˆ =
1
N
PN
n=1 xn be our empirical estimate of the mean of the quantity of interest. The variance of this
estimate is given by
V [ˆx] = 1
N2
V
"X
N
n=1
xn
#
=
1
N2
X
N
n=1
V [xn] = 1
N
σ
2
(12.101)
where σ
2 = V [X]. If the samples are correlated, the variance of the estimate will be higher, as we
show below.
Recall that for N (not necessarily independent) random variables we have
V
"X
N
n=1
xn
#
=
X
N
i=1
X
N
j=1
Cov [xi
, xj ] = X
N
i=1
V [xi
] + 2 X
1≤i<j≤N
Cov [xi
, xj ] (12.102)
Let x =
1
N
PN
n=1 xn be our estimate based on these correlated samples. The variance of this estimate
is given by
V [x] = 1
N2
X
N
i=1
X
N
j=1
Cov [xi
, xj ] (12.103)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license524
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 10 20 30 40
0.0
0.5
1.0
MH with N (0, 1
2
) proposal
(a)
0 10 20 30 40
0.0
0.5
1.0
MH with N (0, 5002
) proposal
(b)
0 10 20 30 40
0.0
0.5
1.0
MH with N (0, 8
2
) proposal
(c)
0 10 20 30 40
0.0
0.5
1.0
gibbs sampling
(d)
Figure 12.17: Autocorrelation functions for various MCMC samplers for the mixture of two 1d Gaussians.
(a-c) These are the MH samplers in Figure 12.1. (d) This is the Gibbs sampler in Figure 12.4. Generated by
mcmc_gmm_demo.ipynb.
We now rewrite this in a more convenient form. First recall that the correlation of xi and xj is
given by
corr [xi
, xj ] = Cov [xi
, xj ]
p
V [xi
] V [xj ]
(12.104)
Since we assume we are drawing samples from the target distribution, we have V [xi
] = σ
2
, where σ
2
is the true variance. Hence
V [x] = σ
2
N2
X
N
i=1
X
N
j=1
corr[xi
, xj ] (12.105)
For a fixed i, we can think of corr [xi
, xj ] as a function of j. This will usually decay as j gets further
from i. As N → ∞ we can approximate the sum of correlations by
X
N
j=1
corr [xi
, xj ] →
X∞
ℓ=−∞
corr [xi
, xi+ℓ] = 1 + 2X∞
ℓ=1
corr [xi
, xi+ℓ] (12.106)
since corr [xi
, xi
] = 1 and corr [xi
, xi−≪] = corr [xi
, xi+ℓ] for lag ℓ > 0. Since we assume the samples
are coming from a stationary distribution, the index i does not matter. Thus we can define the
autocorrelation time as
ρ = 1 + 2X∞
ℓ=1
ρ(ℓ) (12.107)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.6. MCMC CONVERGENCE
where ρ(ℓ) is the autocorrelation function (ACF), defined as
ρ(ℓ) , corr [x0, xℓ] (12.108)
The ACF can be approximated efficiently by convolving the signal x with itself. In Figure 12.17,
we plot the ACF for our four samplers for the GMM. We see that the ACF of the Gibbs sampler
(bottom right) dies off to 0 much more rapidly than the MH samplers. Intuitively this indicates that
each Gibbs sample is “worth” more than each MH sample. We quantify this below.
From Equation (12.105), we can compute the variance of pur estimate in terms of the ACF as
follows: V [x] =
σ
2
N2
PN
i=1 ρ =
σ
2
N
ρ. By contrast, the variance of the estimate from independent
samples is V [ˆx] =
σ
2
N
. So we see that the variance is a factor ρ larger when there is correlation. We
therefore define the effective sample size of our set of samples to be
Neff ,
N
ρ
=
N
1 + 2P∞
ℓ=1 ρ(ℓ)
(12.109)
In practice, we truncate the sum at lag L, which is the last integer at which ρ(L) is positive. Also, if
we run M chains, the numerator should be NM, so we get the following estimate:
Nˆ
eff =
NM
1 + 2PL
ℓ=1 ρˆ(ℓ)
(12.110)
In [Veh+19], they propose various extensions of the above estimator, such as using rank statistics,
to make the estimate more robust.
12.6.4 Improving speed of convergence
There are many possible things you could try if the Rˆ value is too large, and/or the effective sample
size is too low. Here is a brief list:
• Try using a non-centered parameterization (see Section 12.6.5).
• Try sampling variables in groups or blocks (see Section 12.3.7).
• Try using Rao-Blackwellization, i.e., analytically integrating out some of the variables (see
Section 12.3.8).
• Try adding auxiliary variables (see Section 12.4).
• Try using adaptive proposal distributions (see Section 12.2.3.5).
More details can be found in [Rob+18].
12.6.5 Non-centered parameterizations and Neal’s funnel
A common problem that arises when applying sampling to hierarchical Bayesian models is when a
set of parameters at one level of the model have a tight depenendence on parameters at the level
above. We show some practical examples of this in the hierarchical Gaussian 8-schools example in
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license526
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−5 0 5
x
−5
0
5
v
Neal’s funnel
−7.0
−4.5
−2.0
(a)
−20 0 20
x
−10
0
10
v
Centered parameterization
(b)
−20 0 20
x
−10
0
10
v
Non-centered parameterization
(c)
Figure 12.18: Neal’s funnel. (a) Joint density. (b) HMC samples from centered representation. (c) HMC
samples from non-centered representation. Generated by neals_funnel.ipynb.
Section 3.6.2.2 and the hierarchical radon regression example in Section 15.5.2.2. Here, we focus on
the following simple toy model that captures the essence of the problem:
ν ∼ N (0, 3) (12.111)
x ∼ N (0, exp(ν)) (12.112)
The corresponding joint density p(x, ν) is shown in Figure 12.18a. This is known Neal’s funnel,
named after [Nea03]. It is hard for a sampler to “descend” in the narrow “neck” of the distribution,
corresponding to areas where the variance ν is small [BG13].
Fortunately, we can represent this model in an equivalent way that makes it easier to sample from,
providing we use a non-centered parameterization [PR03]. This has the form
ν ∼ N (0, 3) (12.113)
z ∼ N (0, 1) (12.114)
x = z exp(ν) (12.115)
This is easier to sample from, since p(z, ν) is a product of 2 independent Gaussians, and we can
derive x deterministically from these Gaussian samples. The advantage of this reparameterization is
shown in Figure 12.18. A method to automatically derive such reparameterizations is discussed in
[GMH20].
12.7 Stochastic gradient MCMC
Consider an unnormalized target distribution of the following form:
π(θ) ∝ p(θ, D) = p0(θ)
Y
N
n=1
p(xn|θ) (12.116)
where D = (x1, . . . , xN ). Alternatively we can define the target distribution in terms of an energy
function (negative log joint) as follows:
p(θ, D) ∝ exp(−E(θ)) (12.117)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.7. STOCHASTIC GRADIENT MCMC
The energy function can be decomposed over data samples:
E(θ) = X
N
n=1
En(θ) (12.118)
En(θ) = − log p(xn|θ) −
1
N
log p0(θ) (12.119)
Evaluating the full energy (e.g., to compute an acceptance probability in the Metropolis-Hastings
algorithm, or to compute the gradient in HMC) takes O(N) time, which does not scale to large data.
In this section, we discuss some solutions to this problem.
12.7.1 Stochastic gradient Langevin dynamics (SGLD)
Recall from Equation (12.83) that the Langevin diffusion SDE has the following form
dθt = −∇E(θt)dt +
√
2dWt (12.120)
where dWt is a Wiener noise (also called Brownian noise) process. In discrete time, we can use the
following Euler approximation:
θt+1 ≈ θt − ηt∇E(θt) + p
2ηtN (0, I) (12.121)
Computing the gradient g(θt) = ∇E(θt) at each step takes O(N) time. We can compute an
unbiased minibatch approximation to the gradient term in O(B) time using
gˆ(θt) = N
B
X
n∈Bt
∇En(θt) = −
N
B
 X
n∈Bt
∇ log p(xn|θt) + B
N
∇ log p0(θt)
!
(12.122)
where Bt is the minibatch at step t. This gives rise to the following approximate update:
θt+1 = θt − ηtgˆ(θt) + p
2ηtN (0, I) (12.123)
This is called stochastic gradient Langevin dynamics or SGLD [Wel11]. The resulting update
step is identical to SGD, except for the addition of a Gaussian noise term. (See [Neg+21] for some
recent analysis of this method; they also suggest setting ηt ∝ N −2/3
.)
12.7.2 Preconditionining
As in SGD, we can get better results (especially for models such as neural networks) if we use
preconditioning to scale the gradient updates. In [PT13], they use the Fisher information matrix
(FIM) as the preconditioner; this method is known as stochastic gradient Riemannian Langevin
dynamics or SGRLD.
Unfortunately, computing the FIM is often hard. In [Li+16], they propose to use the same kind of
diagonal approximation as used by RMSprop; this is called preconditioned SGLD. An alternative
is to use an Adam-like preconditioner, as proposed in [KSL21]. This is called SGLD-Adam. For
more details, see [CSN21].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license528
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.7.3 Reducing the variance of the gradient estimate
The variance of the noise introduced by minibatching can be quite large, which can hurt the
performance of methods such as SGLD [BDM18]. In [Bak+17], they propose to reduce the variance
of this estimate by using a control variate estimator; this method is therefore called SGLD-CV.
Specifically they use the following gradient approximation:
∇ˆ
cvE(θt) = ∇E(θˆ) + N
B
X
n∈St

∇En(θt) − ∇En(θˆ)

(12.124)
Here θˆ is any fixed value, but it is often taken to be an approximate MAP estimate (e.g., based on
one epoch of SGD). The reason Equation (12.124) is valid is because the terms we add and subtract
are equal in expectation, and hence we get an unbiased estimate:
E
h
∇ˆ
cvE(θt)
i
= ∇E(θˆ) + E
"
N
B
X
n∈St

∇En(θt) − ∇En(θˆ

#
(12.125)
= ∇E(θˆ) + ∇E(θt) − ∇E(θˆ) = ∇E(θt) (12.126)
Note that the first term, ∇E(θˆ) = PN
n=1 ∇En(θˆ), requires a single pass over the entire dataset, but
only has to be computed once (e.g., while estimating θˆ).
One disadvantage of SGLD-CV is that the reference point θˆ has to be precomputed, and is then
fixed. An alternative is to update the reference point online, by performing periodic full batch
estimates. This is called SVRG-LD [Dub+16; Cha+18], where SVRG stands for stochastic variance
reduced gradient, and LD stands for Langevin dynamics. If we use θ˜
t to denote the most recent
snapshot (reference point), the corresponding gradient estimate is given by
∇ˆ
svrgE(θt) = ∇E(θ˜
t) + N
B
X
n∈St

∇En(θt) − ∇En(θ˜
t)

(12.127)
We recompute the snapshot every τ steps (known as the epoch length). See Algorithm 12.5 for the
pseudo-code.
Algorithm 12.5: SVRG Langevin descent
1 Initialize θ0
2 for t = 1 : T do
3 if t mod τ = 0 then
4 θ˜ = θt
5 g˜ =
PN
n=1 En(θ˜)
6 Sample minibatch Bt ∈ {1, . . . , N}
7 gt = g˜ +
N
B
P
n∈Bt

∇En(θt) − ∇En(θ˜)

8 θt+1 = θt − ηtgt +
√
2ηtN (0, I)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.7. STOCHASTIC GRADIENT MCMC
The disadvantage of SVRG is that it needs to perform a full pass over the data every τ steps. An
alternative approach, called SAGA-LD [Dub+16; Cha+18] (which stands for stochastic averaged
gradient acceleration), avoids this by storing all N gradient vectors, and then doing incremental
updates. Unfortunately the memory requirements of this algorithm usually make it impractical.
12.7.4 SG-HMC
We discussed Hamiltonian Monte Carlo (HMC) in Section 12.5, which uses auxiliary momentum
variables to improve performance over Langevin MC. In this section, we discuss a way to speed it up
by approximating the gradients using minibatches. This is called SG-HMC [CFG14; ZG21], where
SG stands for “stochastic gradient”.
Recall that the leapfrog updates have the following form:
vt+1/2 = vt −
η
2
∇E(θt) (12.128)
θt+1 = θt + ηvt+1/2 = θt + ηvt −
η
2
∇E(θt) (12.129)
vt+1 = vt+1/2 −
η
2
∇E(θt+1) = vt −
η
2
∇E(θt) −
η
2
∇E(θt+1) (12.130)
We can replace the full batch gradient with a stochastic approximation, to get
θt+1 = θt + ηvt −
η
2
2
g(θt, ξt
) (12.131)
vt+1 = vt −
η
2
g(θt, ξt
) −
η
2
g(θt+1, ξt+1/2
) (12.132)
where ξt and ξt+1/2 are independent sources of randomness (e.g., batch indices). In [ZG21], they
show that this algorithm (even without the MH rejection step) provides a good approximation to the
posterior (in the sense of having small Wasserstein-2 distance) for the case where the energy functon
is strongly convex. Furthermore, performance can be considerably improved if we use the variance
reduction methods discussed in Section 12.7.3.
12.7.5 Underdamped Langevin dynamics
The underdamped Langevin dynamics (ULD) has the form of the following SDE [CDC15;
LMS16; Che+18a; Che+18d]:
dθt = vtdt
dvt = −g(θt)dt − γvtdt +
p
2γdWt
(12.133)
where g(θt) = ∇E(θt) is the gradient or force acting on the particle, γ > 0 is the friction parameter,
and dWt is Wiener noise.
Equation (12.133) is like the Langevin dynamics of Equation (12.83) but with an added momentum
term vt. We can solve the dynamics using various integration methods. It can be shown (see e.g.,
[LMS16]) that these methods are accurate to second order, whereas solving standard (overdamped)
Langevin is only accurate to first order, and thus will require more sampling steps to achieve a given
accuracy.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license530
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 12.19: To compare a 1d model against a 2d model, we first have to map the 1d model to 2d space so
the two have a common measure. Note that we assume the ridge has finite support, so it is integrable. From
Figure 17 of [And+03]. Used with kind permission of Nando de Freitas.
12.8 Reversible jump (transdimensional) MCMC
Suppose we have a set of models with different numbers of parameters, e.g., mixture models in which
the number of mixture components is unknown. Let the model be denoted by m, and let its unknowns
(e.g., parameters) be denoted by xm ∈ Xm (e.g., Xm = R
nm, where nm is the dimensionality of
model m). Sampling in spaces of differing dimensionality is called trans-dimensional MCMC. We
could sample the model indicator m ∈ {1, . . . , M} and sample all the parameters from the product
space QM
m=1 Xm, but this is very inefficient, and only works if M is finite. It is more parsimonious
to sample in the union space X = ∪M
m=1{m} × Xm, where we only worry about parameters for the
currently active model.
The difficulty with this approach arises when we move between models of different dimensionality.
The trouble is that when we compute the MH acceptance ratio, we are comparing densities defined
on spaces of different dimensionality, which is not well defined. For example, comparing densities on
two points of a sphere makes sense, but comparing a density on a sphere to a density on a circle
does not, as there is a dimensional mismatch in the two concepts. The solution, proposed by [Gre98]
and known as reversible jump MCMC or RJMCMC, is to augment the low dimensional space
with extra random variables so that the two spaces have a common measure. This is illustrated in
Figure 12.19.
We give a sketch of the algorithm below. For more details, see e.g., [Gre03; HG12].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.8. REVERSIBLE JUMP (TRANSDIMENSIONAL) MCMC
12.8.1 Basic idea
To explain the method in more detail, we follow the presentation of [And+03]. To ensure a common
measure, we need to define a way to extend each pair of subspaces Xm and Xn to Xm,n = Xm × Um,n
and Xn,m = Xn × Un,m. We also need to define a deterministic, differentiable and invertible mapping
(xm,um,n) = fn→m(xn,un,m) = (f
x
n→m(xn,un,m), fu
n→m(xn,un,m)) (12.134)
Invertibility means that
fm→n(fn→m(xn,un,m)) = (xn,un,m) (12.135)
Finally, we need to define proposals qn→m(un,m|n, xn) and qm→n(um,n|m, xm).
Suppose we are in state (n, xn). We move to (m, xm) by generating un,m ∼ qn→m(·|n, xn), and
then computing (xm,um,n) = fn→m(xn,un,m). We then accept the move with probability
An→m = min 
1,
p(m, x
∗
m)
p(n, xn)
×
q(n|m)
q(m|n)
×
qm→n(um,n|m, x
∗
m)
qn→m(un,m|n, xn)
× |det Jfm→n
|

(12.136)
where x
∗
m = f
x
n→m(xn,un,m), Jfm→n
is the Jacobian of the transformation
Jfm→n =
∂fn→m(xm,um,n)
∂(xm,um,n)
(12.137)
and | det J| is the absolute value of the determinant of the Jacobian.
12.8.2 Example
Let us consider an example from [AFD01]. They consider an RBF network for nonlinear regression
of the form
f(x) = X
k
j=1
ajK(||x − µj
||) + β
Tx + β0 + ǫ (12.138)
where K() is some kernel function (e.g., a Gaussian), k is the number of such basis functions, and ǫ
is a Gaussian noise term. If k = 0, the model corresponds to linear regression.
They fit this model to the data in Figure 12.20(a). The predictions on the test set are shown
in Figure 12.20(b). Estimates of p(k|D), the (distribution over the) number of basis functions, are
shown in Figure 12.20(c) as a function of the iteration number; the posterior at the final iteration is
shown in Figure 12.20(d). There is clearly the most posterior support for k = 2, which makes sense
given the two “bumps” in the data.
To generate these results, they consider several kinds of proposal. One of them is to split a current
basis function µ into two new ones using
µ1 = µ − un,n+1α, µ2 = µ + un,n+1α (12.139)
where α is a parameter of the proposal, and un,m is sampled from some distribution (e.g., uniform).
To ensure reversibility, they define a corresponding merge move
µ =
µ1 + µ2
2
(12.140)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license532
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 0.2 0.4 0.6 0.8 1
−3
−2
−1
0
1
2
3
4
Train output
Train input
(a)
0 0.2 0.4 0.6 0.8 1
−4
−3
−2
−1
0
1
2
3
4
Test output
Test input
True function
Test data
Prediction
(b)
0 500 1000 1500 2000
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Chain length
p(k|y)
1
2
3
4
(c)
1 2 3 4
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
p(k|data)
(d)
Figure 12.20: Fitting an RBF network to some 1d data using RJMCMC. (a) Prediction on train set. (b)
Prediction on test set. (c) Plot of p(k|D) vs iteration. (d) Final posterior p(k|D). Adapted from Figure 4 of
[AFD01]. Generated by rjmcmc_rbf, written by Nando de Freitas.
where µ1 is chosen at random, and µ2 is its nearest neighbor. To ensure these moves are reversible,
we require ||µ1 − µ2|| < 2β.
The acceptance ratio for the split move is given by
Asplit = min 
1,
p(k + 1, µk+1)
p(k, µk+1)
×
1/(k + 1)
1/k ×
1
p(un,m)
× |det Jsplit|

(12.141)
where 1/k is the probability of choosing one of the k bases uniformly at random. The Jacobian is
Jsplit =
∂(µ1, µ2)
∂(µ, un,m)
= det 
1 1
−β β
(12.142)
so |det Jsplit| = 2β. The acceptance ratio for the merge move is given by
Amerge = min 
1,
p(k − 1, µk−1)
p(k, µk)
×
1/(k − 1)
1/k × |det Jmerge|

(12.143)
where |det Jmerge| = 1/(2β).
The overall pseudo-code for the algorithm, assuming the current model has index k, is given in
Algorithm 12.6. Here bk is the probability of a birth move, dk is the probability of a death move, sk
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.9. ANNEALING METHODS
Algorithm 12.6: Generic reversible jump MCMC (single step)
1 Sample u ∼ U(0, 1)
2 If u ≤ bk
3 then birth move
4 else if u ≤ (bk + dk) then death move
5 else if u ≤ (bk + dk + sk) then split move
6 else if u ≤ (bk + dk + sk + mk) then merge move
7 else update parameters
is the probability of a split move, and mk is the probability of a merge move. If we don’t make a
dimension-changing move, we just update the parameters of the current model using random walk
MH.
12.8.3 Discussion
RJMCMC algorithms can be quite tricky to implement. If, however, the continuous parameters can
be integrated out (resulting in a method called collapsed RJMCMC), much of the difficulty goes
away, since we are just left with a discrete state space, where there is no need to worry about change
of measure. For example, if we fix the centers µj
in Equation (12.138) (e.g., using samples from the
data, or using K-means clustering), we are left with a linear model, where we can integrate out the
parameters. All that is left to do is sample which of these fixed basis functions to include in the
model, which is a discrete variable selection problem. See e.g., [Den+02] for details.
In Chapter 31, we discuss Bayesian nonparametric models, which allow for an infinite number of
different models. Surprisingly, such models are often easier to deal with computationally (as well as
more realistic, statistically) than working with a finite set of different models.
12.9 Annealing methods
Many distributions are multimodal and hence hard to sample from. However, by analogy to the way
metals are heated up and then cooled down in order to make the molecules align, we can imagine
using a computational temperature parameter to “smooth out” a distribution, gradually cooling it to
recover the original “bumpy” distribution. We first explain this idea in more detail in the context of
an algorithm for MAP estimation. We then discuss extensions to the sampling case.
12.9.1 Simulated annealing
In this section, we discuss the simulated annealing algorithm [KJV83; LA87], which is a variant of
the Metropolis-Hastings algorithm which is designed to find the global optimum of blackbox function.
(Other approaches to blackbox optimization are discussed in Section 6.7.)
Annealing is a physical process of heating a solid until thermal stresses are released, then cooling it
very slowly until the crystals are perfectly arranged, acheiving a minimum energy state. Depending
on how fast or slow the temperature is cooled, the results will have better or worse quality. We can
apply this approach to probability distributions, to control the number of modes (low energy states)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license534
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0
20
40
60
80
100
0
20
40
60
80
100
0.2
0.4
0.6
0.8
1.0
(a)
0
20
40
60
80
100
0
20
40
60
80
100
0.0
0.2
0.4
0.6
0.8
1.0
(b)
Figure 12.21: (a) A peaky distribution. (b) Corresponding energy function. Generated by simu￾lated_annealing_2d_demo.ipynb.
that they have, by defining
pT (x) = exp(−E(x)/T) (12.144)
where T is the temperature, which is reduced over time. As an example, consider the peaks function:
p(x, y) ∝ |3(1 − x)
2
e
−x
2−(y+1)2
− 10(x
5
− x
3 − y
5
)e
−x
2−y
2
−
1
3
e
−(x+1)2−y
2
| (12.145)
This is plotted in Figure 12.21a. The corresponding energy is in Figure 12.21b. We plot annealed
versions of this distribution in Figure 12.22. At high temperatures, T ≫ 1, the surface is approximately
flat, and hence it is easy to move around (i.e., to avoid local optima). As the temperature cools,
the largest peaks become larger, and the smallest peaks disappear. By cooling slowly enough, it is
possible to “track” the largest peak, and thus find the global optimum (minimum energy state). This
is an example of a continuation method.
In more detail, at each step, we sample a new state according to some proposal distribution
x
′ ∼ q(·|xt). For real-valued parameters, this is often simply a random walk proposal centered on
the current iterate, x
′ = xt + ǫt+1, where ǫt+1 ∼ N (0, Σ). (The matrix Σ is often diagonal, and
may be updated over time using the method in [Cor+87].) Having proposed a new state, we compute
the acceptance probability
αt+1 = exp (−(E(x
′
) − E(xt))/Tt) (12.146)
where Tt is the temperature of the system. We then accept the new state (i.e., set xt+1 = x
′
) with
probability min(1, αt+1), otherwise we stay in the current state (i.e., set xt+1 = xt). This means that
if the new state has lower energy (is more probable), we will definitely accept it, but if it has higher
energy (is less probable), we might still accept, depending on the current temperature. Thus the
algorithm allows “downhill” moves in probability space (uphill in energy space), but less frequently
as the temperature drops.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12.9. ANNEALING METHODS
0
20
40
60
80
100
0
20
40
60
80
100
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
T=10.00
(a)
0
20
40
60
80
100
0
20
40
60
80
100
0.2
0.4
0.6
0.8
1.0
T=2.00
(b)
0
20
40
60
80
100
0
20
40
60
80
100
0.0
0.2
0.4
0.6
0.8
1.0
T=0.40
(c)
0
20
40
60
80
100
0
20
40
60
80
100
0.0
0.2
0.4
0.6
0.8
1.0
T=0.08
(d)
Figure 12.22: Annealed version of the distribution in Figure 12.21a at different temperatures. Generated by
simulated_annealing_2d_demo.ipynb.
The rate at which the temperature changes over time is called the cooling schedule. It has been
shown [Haj88] that if one cools according to a logarithmic schedule, Tt ∝ 1/ log(t + 1), then the
method is guaranteed to find the global optimum under certain assumptions. However, this schedule
is often too slow. In practice it is common to use an exponential cooling schedule of the form
Tt+1 = γTt, where γ ∈ (0, 1] is the cooling rate. Cooling too quickly means one can get stuck in a
local maximum, but cooling too slowly just wastes time. The best cooling schedule is difficult to
determine; this is one of the main drawbacks of simulated annealing.
In Figure 12.23a, we show a cooling schedule using γ = 0.9. If we combine this with a Gaussian
random walk proposal with σ = 10 to the peaky distribution in Figure 12.21a, we get the results
shown in Figure 12.23 and Figure 12.23b. We see that the algorithm concentrates its samples near
the global optimum (the peak on the middle right).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license536
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 50 100 150 200 250 300
iteration
0.0
0.5
1.0
temperature
probability
(a)
0 20 40 60 80 100
x1
0
25
50
75
100
x2
0.25
0.50
0.75
1.00
(b)
Figure 12.23: Simulated annealing applied to the distribution in Figure 12.21a. (a) Temperature vs iteration
and probability of each visited point vs iteration. (b) Visited samples, superimposed on the target distribution.
The big red dot is the highest probability point found. Generated by simulated_annealing_2d_demo.ipynb.
12.9.2 Parallel tempering
Another way to combine MCMC and annealing is to run multiple chains in parallel at different
temperatures, and allow one chain to sample from another chain at a neighboring temperature. In
this way, the high temperature chain can make long distance moves through the state space, and have
this influence lower temperature chains. This is known as parallel tempering. See e.g., [ED05;
Kat+06] for details.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 202313 Sequential Monte Carlo
13.1 Introduction
In this chapter, we discuss sequential Monte Carlo or SMC algorithms, which can be used to
sample from a sequence of related probability distributions. SMC is most commonly used to solve
filtering in state-space models (SSM, Chapter 29), but it can also be applied to other problems, such
as sampling from a static (but possibly multi-modal) distribution, or for sampling rare events from
some process.
Our presentation is based on the excellent tutorial [NLS19], and differs from traditional presenta￾tions, such as [Aru+02], by emphasizing the fact that we are sampling sequences of related variables,
not just computing the filtering distribution of an SSM. This more general perspective will let us
tackle static estimation problems, as we will see. For another good introduction to SMC, see [DJ11].
For a more formal (measure theoretic) treatment of SMC, using the Feynman-Kac formalism, see
[CP20b].
13.1.1 Problem statement
In SMC, the goal is to sample from a sequence of related distributions of the form
πt(z1:t) = 1
Zt
γ˜t(z1:t) (13.1)
for t = 1 : T, where γ˜t is the unnormalized target distribution, πt is the normalized version,
and z1:t are the random variables of interest. In some applications (e.g., filtering in an SSM), we
care about each intermediate marginal distribution, πt(zt), for t = 1 : T; this is called particle
filtering. (The word “particle” just means “sample”.) In other applications, we only care about the
final distribution, πT (zT ), and the intermediate steps are introduced just for computational reasons;
this is called an SMC sampler. We briefly review both of these below, and go into more detail in
later sections.
13.1.2 Particle filtering for state-space models
An important application of SMC is to sequential (online) inference (state estimation) in SSMs. As
an example, consider a Markovian state-space model with the following joint distribution:
πT (z1:T ) ∝ p(z1:T , y1:T ) = p(z1)p(y1|z1)
Y
T
t=1
p(zt|zt−1)p(yt|zt) (13.2)538
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 2 4 6 8
−2
−1
0
1
2
3
4
Noisy observations from hidden trajectory
state space
(a)
0 2 4 6 8
−2
−1
0
1
2
3
4
filtered
(b)
Figure 13.1: Illustration of particle filtering (using the dynamical prior as the proposal) applied to a 2d
nonlinear dynamical system. (a) True underlying state and observed data. (b) PF estimate of the posterior
mean. Generated by bootstrap_filter_spiral.ipynb.
A common choice is to define the unnormalized target distribution at step t to be
γ˜t(z1:t) = p(z1:t, y1:t) = p(z1)p(y1|z1)
Yt
s=1
p(zs|zs−1)p(ys|zs) (13.3)
Note that this a distribution over an (ever growing) sequence of latent variables. However, we often
only care about the most recent marginal of this distribution, in which case we just need to compute
γ˜t(zt), which avoids having to store the full history.
For example, consider the following 2d nonlinear tracking problem (the same one as in Sec￾tion 8.3.2.3):
p(zt|zt−1) = N (zt|f(zt−1), qI)
p(yt|zt) = N (yt|zt, rI)
f(z) = (z1 + ∆ sin(z2), z2 + ∆ cos(z1))
(13.4)
where ∆ is the step size of the underlying continuous system, q is the variance of the system
noise, and r is the variance of the observation noise. (We treat ∆, q, and r as fixed constants; see
Supplementary Section 13.1.3 for a discussion of joint state and parameter estimation.) The true
underlying state trajectory, and the corresponding noisy measurements, are shown in Figure 13.1a.
The posterior mean estimate of the state, computed using 2000 samples in a simple form of SMC
called the bootstrap filter (Section 13.2.3.1), is shown in Figure 13.1b.
Particle filtering can also be applied to non-Markovian models, where zt may depend on all
the past hidden states, z1:t−1, and yt depends on the current zt and possibly also all the past hidden
states, z1:t−1, and optionally the past observatiobns, y1:t−1. In this case, the unnormalized target
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
13.2. PARTICLE FILTERING
distribution at step t is
γ˜t(z1:t) = p(z1)p(y1|z1)
Yt
s=1
p(zs|z1:s−1)p(ys|z1:s) (13.5)
For example, consider a 1d Gaussian sequence model where the dynamics are first-order Markov, but
the observations depend on the entire past sequence (this is example 1.2.1 from [NLS19]):
p(zt|z1:t−1) = N (zt|φzt−1, q)
p(yt|z1:t) = N (yt|
Xt
s=1
β
t−s
zs, r)
(13.6)
If we set β = 0, we get p(yt|z1:t) = N (yt|zt, r) (where we define 0
0 = 1), so the model becomes a
linear-Gaussian SSM. As β gets larger, the dependence on the past increases, making the inference
problem harder. (We will revisit this example below.)
13.1.3 SMC samplers for static parameter estimation
Now consider the problem of parameter estimation from a fixed dataset, D = {yn : n = 1 :
N}. We suppose the observations are conditionally iid, so the posterior has the form p(z|D) ∝
p(z)
QN
n=1 p(yn|z), where z is the unknown parameter. It is not immediately obvious how to
approximate p(z|D) using SMC, since we just have one distribution. However, we can convert
this into a sequential inference problem in several different ways. One approach, known as data
tempering, defines the (marginal) target distribution at step t as γ˜t(zt) = p(zt)p(y1:t|zt). In
this case, the number of time steps T is the same as the number of data samples, N. Another
approach, known as likelihood tempering, defines the (marginal) target distribution at step t as
γ˜t(zt) = p(zt)p(D|zt)
τt
, where 0 = τt < · · · < τT = 1 is a temperature parameter. In this case, the
number of steps T depends on how quickly we anneal the distibution from the initial prior p(z1) to
the final target p(zT )p(D|zT ).
Once we have defined the marginal target distributions γ˜t(zt), we need a way to expand this to a joint
target distribution over a sequence of variables, γ˜t(z1:t), so the distributions become connected to each
other. We explain how to do this in Section 13.6. We can then treat the model as an SSM and apply
particle filtering. At the end, we extract the final joint target distribution, γ˜T (z1:T ) = p(z1:T )p(D|zT ),
from which we can compute the marginal target distribution γ˜T (zT ) = p(zT , D), from which we can
get the posterior p(z|D) by normalizing. We give the details in Section 13.6.
13.2 Particle filtering
In this section, we cover the basics of SMC for state space models, culiminating in a method known
as the particle filter.
13.2.1 Importance sampling
We start by reviewing the self-normalized importance sampling method (SNIS), which is the
foundation of the particle filter. (See also Section 11.5.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license540
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Suppose we are interested in estimating the expectation of some function ϕt with respect to a
target distribution πt, which we denote by
πt(ϕ) , Eπt
[ϕt(z1:t)] = Z
γ˜t(z1:t)
Zt
ϕt(z1:t)dz1:t (13.7)
where Zt =
R
γ˜t(z1:t)dz1:t. Suppose we use SNIS with proposal qt(z1:t). We then get the following
approximation:
πt(ϕ) ≈
1
Zˆ
t
1
Ns
X
Ns
i=1
w˜t(z
i
1:t
)ϕt(z
i
1:t
) (13.8)
where z
i
1:t
iid∼ qt are independent samples from the proposal, w˜
i
t are the unnormalized weights
defined by
w˜
i
t =
γ˜t(z
i
1:t
)
qt(z
i
1:t
)
(13.9)
and Zˆ
t is the approximate normalization constant defined by
Zˆ
t ,
1
Ns
X
Ns
i=1
w˜
i
t
(13.10)
To simplify notation, let us define the normalized weights by
Wi
t =
w˜
i
P t
j w˜
j
t
(13.11)
Then we can write
Eπt
[ϕt(z1:t)] ≈
X
Ns
i=1
Wi
t ϕt(z
i
1:t
) (13.12)
Alternatively, instead of computing the expectation of a specific target function, we can just approxi￾mate the target distribution itself, using a sum of weighted samples:
πt(z1:t) ≈
X
Ns
i=1
Wi
t
δ(z1:t − z
i
1:t
) , πˆt(z1:t) (13.13)
The problem with importance sampling when applied in the context of sequential models is that
the dimensionality of the state space is very large, and increases with t. This makes it very hard to
define a good proposal that covers the high probability regions, resulting in most samples getting
negligible weight. In the sections below, we discuss solutions to this problem.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
13.2. PARTICLE FILTERING
13.2.2 Sequential importance sampling
In this section, we discuss sequential importance sampling or SIS, in which the proposal has
the following autoregressive structure:
qt(z1:t) = qt−1(z1:t−1)qt(zt|z1:t−1) (13.14)
We can obtain samples from qt−1(z1:t−1) by reusing the z
i
1:t−1
samples, which we then extend by
one step by sampling from the conditional qt(zt|z
i
1:t−1
). We can think of this as “growing” the chain
(sequence of states). The unnormalized weights can be computed recursively as follows:
w˜t(z1:t) = γ˜t(z1:t)
qt(z1:t)
=
γ˜t−1(z1:t−1)
γ˜t−1(z1:t−1)
γ˜t(z1:t)
qt(zt|z1:t−1)qt−1(z1:t−1)
(13.15)
=
γ˜t−1(z1:t−1)
qt−1(z1:t−1)
γ˜t(z1:t)
γ˜t−1(z1:t−1)qt(zt|z1:t−1)
(13.16)
= ˜wt−1(z1:t−1)
γ˜t(z1:t)
γ˜t−1(z1:t−1)qt(zt|z1:t−1)
(13.17)
The ratio factors are sometimes called the incremental importance weights:
αt(z1:t) = γ˜t(z1:t)
γ˜t−1(z1:t−1)qt(zt|z1:t−1)
(13.18)
See Algorithm 13.1 for pseudocode for the resulting SIS algorithm. (In practice we compute the
weights in log-space, and convert back using the log-sum-exp trick.)
Note that, in the special case of state space models, the weight computation can be further
simplified. In particular, suppose we have
γ˜t(z1:t) = p(z1:t, y1:t) = p(yt|z1:t)p(zt|z1:t−1)p(z1:t−1, y1:t−1) (13.19)
= p(yt|z1:t)p(zt|z1:t−1)˜γt−1(z1:t−1) (13.20)
Then the incremental weight is given by
αt(z1:t) = p(yt|z1:t)p(zt|z1:t−1)˜γt−1(z1:t−1)
γ˜t−1(z1:t−1)qt(zt|z1:t−1)
=
p(yt|z1:t)p(zt|z1:t−1)
qt(zt|z1:t−1)
(13.21)
Unfortunately SIS suffers from a problem known as weight degeneracy or particle impover￾ishment, in which most of the weights become very small (near zero), so the posterior ends up being
approximated by a single particle. This is illustrated in Figure 13.2a, where we apply SIS to the
non-Markovian example in Equation (13.6) using Ns = 5 particles. The reason for degeneracy is
that each particle has to “explain” (generate) the entire sequence of observations. Each sequence of
guessed states becomes increasingly improbable over time, due to the product of likelihood terms,
and the differences between the weights of each hypothesis will grow exponentally. Of course, there
has to be a best sequence amongst the set of candidates, so when we normalize the weights, the best
one will get weight 1 and the rest will get weight 0. But this is a waste of most of the particles. We
discuss a solution to this in Section 13.2.3.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license542
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Algorithm 13.1: Sequential importance sampling (SIS)
1 Initialization: z
i
1 ∼ q1(z1), w˜
i
1 =
γ˜1(z
i
1
)
q1(z
i
1
)
, Wi
1 =
w˜
i
P 1
j w˜
j
1
, πˆ1(z1) = PNs
i=1 Wi
1
δ(z1 − z
i
1
)
2 for t = 2 : T do
3 for i = 1 : Ns do
4 Sample z
i
t ∼ qt(zt|z
i
1:t−1
)
5 Compute incremental weight α
i
t =
γ˜t(z
i
1:t
)
γ˜t−1(z
i
1:t−1
)qt(z
i
t
|z
i
1:t−1
)
6 Compute unnormalized weight w˜
i
t = ˜w
i
t−1α
i
t
7 Compute normalized weights Wi
t =
w˜
i
P t
j w˜
j
t
for i = 1 : Ns
8 Compute MC posterior πˆt(z1:t) = PNs
i=1 Wi
t
δ(z1:t − z
i
1:t
)
1 2 3 4 5 6 7
Iteration (t)
0
1
2
3
4
Particle index (i)
(a)
resample
P(zt-1 | y1:t-1)
proposal q(zt | z
i
t-1)
P(yt | zt
)
weighting
P(zt| y1:t
)
prior
posterior
{zi
t-1 }
(b)
Figure 13.2: (a) Illustration of weight degeneracy for SIS applied to the model in Equation (13.6). with
parameters (φ, q, β, r) = (0.9, 10.0, 0.5, 1.0). We use T = 6 steps and Ns = 5 samples. We see that as t
increases, almost all the probability mass concentrates on particle 3. Generated by sis_vs_smc.ipynb. Adapted
from Figure 2 of [NLS19]. (b) Illustration of the bootstrap particle filtering algorithm.
13.2.3 Sequential importance sampling with resampling
In this section, we describe sequential importance sampling with resampling (SISR). The
basic idea is this: instead of “growing” all of the old particle sequences by one step, we first select the
Ns “fittest” particles, by sampling from the old posterior, and then we let these survivors grow by
one step.
In more detail, at step t, we sample from
q
SISR
t
(z1:t) = ˆπt−1(z1:t−1)qt(zt|z1:t−1) (13.22)
where πˆt−1(z1:t−1) is the previous weighted posterior approximation. By contrast, in SIS, we sample
from
q
SIS
t
(z1:t) = q
SIS
t−1
(z1:t−1)qt(zt|z1:t−1) (13.23)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
13.2. PARTICLE FILTERING
Algorithm 13.2: Sequential importance sampling with resampling (SISR)
1 Initialization: z
i
1 ∼ q1(z1), w˜
i
1 =
γ˜1(z
i
1
)
q1(z
i
1
)
, Wi
1 =
w˜
i
P 1
j w˜
j
1
, πˆ1(z1) = PNs
i=1 Wi
1
δ(z1 − z
i
1
)
2 for t = 2 : T do
3 Compute ancestors a
1:Ns
t−1 = resample( ˜w
1:Ns
t−1
)
4 Select z
1:Ns
t−1 = permute(a
1:Ns
t−1
, z
1:Ns
t−1
)
5 Reset unnormalized weights w˜
1:Ns
t−1 = 1/Ns
6 for i = 1 : Ns do
7 Sample z
i
t ∼ qt(zt|z
i
1:t−1
)
8 Compute unnormalized weight w˜
i
t = α
i
t =
γ˜t(z
i
1:t
)
γ˜t−1(z
i
1:t−1
)qt(z
i
t
|z
i
1:t−1
)
9 Compute normalized weights Wi
t =
w˜
i
P t
j w˜
j
t
for i = 1 : Ns
10 Compute MC posterior πˆt(z1:t) = PNs
i=1 Wi
t
δ(z1:t − z
i
1:t
)
We can sample from Equation (13.22) in two steps. First we resample Ns samples from πˆt−1(z1:t−1)
to get a uniformly weighted set of new samples z
i
1:t−1
. (See Section 13.2.4 for details on how to do
this.) Then we extend each sample using z
i
t ∼ qt(zt|z
i
1:t−1
), and concatenate z
i
t
to z
i
1:t−1
,
After making a proposal, we compute the unnormalized weights. We use the standard SNIS
method, except we “pretend” that the proposal is given by γ˜t−1(z
i
1:t−1
)qt(z
i
t
|z
i
1:t−1
) even though
we used πˆt−1(z
i
1:t−1
)qt(z
i
t
|z
i
1:t−1
). The intuitive reason why this is valid is because the previous
weighted approximation, πˆt−1(z
i
1:t−1
), was an unbiased estimate of the previous target distribution,
γ˜t−1(z1:t−1). (See e.g., [CP20b] for more theoretical details.) We then compute the unnormalized
weights, which are the same as the incremental weights, since the resampling step sets w˜
i
t−1 = 1. We
then normalize these weights and compute the new approximationg to the target posterior πˆt(z1:t).
See Algorithm 13.2 for the pseudocode.
13.2.3.1 Bootstrap filter
We now consider a special case of SISR, in which the model is an SSM, and the proposal distribution
is equal to the dynamical prior:
qt(zt|z1:t−1) = p(zt|z1:t−1) (13.24)
In this case, the corresponding incremental weight in Equation (13.21) simplifies to
αt(z1:t) =
p(yt|z1:t)p(zt|z1:t−1)
q(zt|z1:t−1)
=
p(yt|zt)p(zt|zt−1)
p(zt|zt−1)
= p(yt|z1:t) (13.25)
This special case is called the bootstrap filter [Gor93] or the survival of the fittest algorithm
[KKR95]. (In the computer vision literature, this is called the condensation algorithm, which
stands for “conditional density propagation” [IB98].) See Figure 13.2b for an illustration of how this
algorithm works, and Figure 13.1b for some sample results on real data.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license544
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
1 2 3 4 5 6 7
Iteration (t)
0
1
2
3
4
Particle index (i)
(a)
1 2 3 4 5 6 7
Iteration (t)
0
1
2
3
4
Particle index (i)
(b)
Figure 13.3: (a) Illustration of diversity of samples in SMC applied to the model in Equation (13.6). (b)
Illustration of the path degeneracy problem. Generated by sis_vs_smc.ipynb. Adapted from Figure 3 of
[NLS19].
The bootstrap filter is useful for models where we can sample from the dynamics, but cannot
evaluate the transition model pointwise. This occurs in certain implicit dynamical models, such as
those defined using differential equatons (see e.g., [IBK06]); such models are often used in epidemiology.
However, in general it is much more efficient to use proposals that take the current evidence yt into
account. We discuss ways to approximate such “locally optimal” proposals in Section 13.3.
13.2.3.2 Path degeneracy problem
In Figure 13.3a we show how particle filtering can result in a much more diverse set of active particles,
with more balanced weights when applied to the non-Markovian example in Equation (13.6).
While particle filtering does not suffer from weight degeneracy, it does suffer from another problem
known as path degeneracy. This refers to the fact that the number of particles that “survive” (have
non-negligible weight) over many steps may drop rapidly over time, resulting in a loss of diversity
when we try to represent the distribution over the past. We illustrate this in Figure 13.3b, where
we only include arrows for samples that have been resampled at each step up until the final step.
We see that we have Ns = 5 identical copies of z
1
1
in the final set of surviving sequences. (The
time at which all the paths meet at a common ancestor, when tracing backwards in time, is known
as the coalescence time.) We discuss some ways to ameliorate this issue in Section 13.2.4 and
Section 13.2.5.
13.2.3.3 Estimating the normalizing constant
We can use particle filtering to approximate the normalization constant ZT = p(y1:T ) = QT
t=1 p(yt|y1:t−1)
as follows:
Zˆ
T =
Y
T
t=1
Zˆ
t (13.26)
where, from Equation (13.10), we have
Zˆ
t =
1
Ns
X
Ns
i=1
w˜
i
t = Zˆ
t−1

Z\t/Zt−1

(13.27)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
13.2. PARTICLE FILTERING
where
Z\t/Zt−1 =
PNs
i=1 w˜
i
t PNs
i=1 w˜
i
t−1
(13.28)
This estimate of the marginal likelihood is very useful for tasks such as parameter estimation.
13.2.4 Resampling methods
Importance sampling gives a weighted set of particles, {(Wi
t
, z
i
t
) : i = 1 : N}, which we can use to
approximate posterior expectations using
E [f(zt)|y1:t] ≈
X
N
i=1
Wi
t
f(z
i
t
) (13.29)
Suppose we sample a single index A ∈ {1, . . . , N} with probabilities (W1
t
, . . . , WN
t
). Then the
expected value evaluated at this index is
E

f(z
A
t
)|y1:t

=
X
N
i=1
p(A = i)f(z
i
t
) = X
N
i=1
Wi
t
f(z
i
t
) (13.30)
If we sample N indices independently and compute their average, we get
E [f(zt)|y1:t, A1:N ] ≈
1
N
X
N
i=1
f(z
Ai
t
) (13.31)
which is a standard unweighted Monte Carlo estimate, with weights Wi
t = 1/N. Averaging over the
indices gives
EA1:N
"
1
N
X
N
i=1
f(z
Ai
t
)
#
=
X
N
i=1
Wi
t
f(z
i
t
) (13.32)
Thus using the output from the resampling procedure — which drops particles with low weight,
and duplicates particles with high weight — will give the same result in expectation as the original
weighted estimate. However, to reduce the variance of the method, we need to pick the resampling
method carefully, as we discuss below.
13.2.4.1 Inverse cdf
Most of the common resampling methods work as follows. First we form the cumulative distribution
from the weights W1:N , as illustrated by the staircase in Figure 13.4. (We drop the t index for
brevity.) Then, given a set of N uniform random variables, U
i ∼ Unif(0, 1), we check to see which
bin (interval) U
i
lands in; if it falls in bin a, we return index a, i.e., sample i gets mapped to index a
if
aX−1
j=1
Wj ≤ U
i <
Xa
j=1
Wj
(13.33)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license546
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 1 2 3 4
0
0.2
0.4
0.6
0.8
1
U
(1)
U
(2)
U
(3)
Figure 13.4: Illustration of how to sample from the empirical cdf P(x) = PN
n=1 Wn
I(x ≥ n) shown in black.
The height of step n is Wn. If U
m picks step n, then we set the ancestor of m to be n, i.e., A
m = n. In this
example, A
1:3 = (1, 2, 2). Adapted from Figure 9.3 of [CP20b].
It would seem that each index would take O(N) time to compute, for a total time of O(N2
), but
if the U
i are ordered from smallest to largest, we can implement it in O(N) time. We denote this
function A1:N = icdf(W1:N , U1:N ). See Listing 13.1 for some JAX code.1
Listing 13.1: Sampling from an ordered inverse CDF
def icdf ( weights , u) :
n = weights . shape [0]
cumsum = jnp . cumsum ( weights )
idx = jnp . searchsorted ( cumsum , u)
return jnp . clip ( idx , 0, n - 1)
13.2.4.2 Multinomial resampling
In multinomial resampling, we set U1:N to be an ordered set of N samples from the uniform
distribution. We then compute the ancestor indices using A1:N = icdf(W1:N , U1:N ).
Although this is a simple method, it can introduce a lot of variance into the representation of the
distribution. For example, suppose all the weights are equal, Wn = 1/N. Let Wn =
PN
m=1 I(Am = n)
be the number of “offspring” for particle n (i.e., the number of times this particle is chosen in the
resampling step). We have Wn ∼ Bin(N, 1/N), so P(Wn = 0) = (1 − 1/N)
N ≈ e
−1 ≈ 0.37. So there
is a 37% chance that any given particle will disappear even though they all had the same initial
weight. In the sections below, we discuss some low variance resampling methods.
13.2.4.3 Stratified resampling
A simple approach to improve on multinomial resampling is to use stratified resampling, in which
we divide the unit interval into Ns strata, (0, 1/Ns), (1/Ns, 2/Ns), up to (1 − 1/Ns, 1). We then
generate
U
i ∼ Unif((i − 1)/Ns, i/Ns) (13.34)
and compute A1:N = icdf(W1:N , U1:N ).
2
1. Modified from https://github.com/blackjax-devs/blackjax/blob/main/blackjax/smc/resampling.py.
2. To compute the U1:N , we can use v = jr.uniform(rngkey, (n,)) and u = (jnp.arange(n) + v) / n.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
13.3. PROPOSAL DISTRIBUTIONS
13.2.4.4 Systematic resampling
We can further reduce the variance by forcing all the samples to be deterministically generated from
a shared random source, u ∼ Unif(0, 1), by computing
U
i =
i − 1
Ns
+
u
Ns
(13.35)
We then compute A1:N = icdf(W1:N , U1:N ).
3
13.2.4.5 Comparison
It can be proved that all of the above methods are unbiased. Empirically it seems that systematic
resampling is lower variance than other methods [HSG06], although stratified resampling, and the
more complex method of [GCW19], have better theoretical properties. Multinomial resampling is
not recommended, since it has provably higher variance than the other methods.
13.2.5 Adaptive resampling
The resampling step can result in loss of diversity, since each ancestor may generate multiple children,
and some may generate no children, since the ancestor indices An
t are sampled independently; this is
the path degeneracy problem mentioned above. On the other hand, if we never resample, we end up
with SIS, which suffers from weight degeneracy (particles with negligible weight). A compromise is
to use adaptive resampling, in which we resample whenever the effective sample size or ESS
drops below some minimum, such as N/2. A common way to define the ESS is as follows:4
ESS(W1:N ) =
1
PN
n=1(Wn)
2
(13.36)
Alternatively we can compute the ESS using the unnormalized weights:
ESS( ˜w
1:N ) =
PN
n=1 w˜
n
2
PN
n=1( ˜wn)
2
(13.37)
Note that if we have k weights with w˜
n = 1 and N − k weights with w˜
n = 0, then the ESS is k; thus
ESS is between 1 and N.
The pseudocode for SISR with adaptive resampling is given in Algorithm 13.3. (We use the
notation of [Law+22, App. B], in which we first sample new extensions of the sequences, and then
optionally resample the sequences at the end of each step.)
13.3 Proposal distributions
The efficiency of PF is crucially dependent on the quality of the proposal distribution. We discuss
some options below.
3. To compute the U1:N , we can use v = jr.uniform(rngkey, ()) and u = (jnp.arange(n) + v) / n.
4. Note that the ESS used in SMC is different than the ESS used in MCMC (Section 12.6.3); the latter takes into
account auto-correlation of the MCMC samples.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license548
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Algorithm 13.3: SISR with adaptive resampling (generic SMC)
1 Initialization: w˜
1:Ns
0 = 1, Zˆ
0 = 1
2 for t = 1 : T do
3 for i = 1 : Ns do
4 Sample particle z
i
t ∼ qt(zt|z
i
1:t−1
)
5 Compute incremental weight α
i
t =
γ˜t(z
i
1:t
)
γ˜t−1(z
i
1:t−1
)qt(z
i
t
|z
i
1:t−1
)
6 Compute unnormalized weight w˜
i
t = ˜w
i
t−1α
i
t
7 Estimate normalization constant: Z\t/Zt−1 =
PNs
i=1 w˜
i
P t
Ns
i=1 w˜
i
t−1
, Zˆ
t = Zˆ
t−1(Z\t/Zt−1)
8 if ESS( ˜w
1:N
t−1
) < ESSmin then
9 Compute ancestors a
1:Ns
t = resample( ˜w
1:Ns
t
)
10 Select z
1:Ns
t = permute(a
1:Ns
t
, z
1:Ns
t
)
11 Reset unnormalized weights w˜
1:Ns
t = 1/Ns
12 Compute normalized weights Wi
t =
w˜
i
P t
j w˜
j
t
for i = 1 : Ns
13 Compute MC posterior πˆt(z1:t) = PNs
i=1 Wi
t
δ(z1:t − z
i
1:t
)
13.3.1 Locally optimal proposal
We define the (one-step) locally optimal proposal distribution q
∗
t
(zt|z1:t−1) to be the one that
minimizes
DKL (πt−1(z1:t−1)qt(zt|z1:t−1) k πt(z1:t)) (13.38)
= Eπt−1qt
[log {πt−1(z1:t−1)qt(zt|z1:t−1)} − log πt(z1:t)] (13.39)
= Eπt−1qt
[log qt(zt|z1:t−1) − log πt(zt|z1:t−1)] + const (13.40)
= Eπt−1qt
[DKL (qt(zt|z1:t−1) k πt(zt|z1:t−1))] + const (13.41)
The KL is minimized by choosing
q
∗
t
(zt|z1:t−1) = πt(zt|z1:t−1) = γ˜t(z1:t)
γ˜t(z1:t−1)
(13.42)
where γ˜t(z1:t−1) = R
γ˜t(z1:t)dzt is the probability of the past sequence under the current target
distribution.
Note that the subscript t specifies the t’th distribution, so in the context of SSMs, we have
πt(zt|z1:t−1) = p(zt|z1:t−1, y1:t). Thus we see that when proposing zt, we should condition on all
the data, including the most recent observation, yt; this is called a guided particle filter, and will
will be better than the bootstrap filter, which proposes from the prior.
In general, it is intractable to compute the locally optimal proposal, so we consider various
approximations below.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
13.3. PROPOSAL DISTRIBUTIONS
13.3.2 Proposals based on the extended and unscented Kalman filter
One way to approximate the locally optimal proposal distribution is based on the extended Kalman
filter (Section 8.3.2) or the unscented Kalman filter (Section 13.3.2), which gives rise to the extended
particle filter [DGA00] and unscented particle filter [Mer+00] respectively. To explain these
methods, we follow the presentation of [NLS19, p36]. As usual, we assume the dynamical system
can be written as zt = f(zt−1) + qt and yt = h(zt) + rt, where qt is the system noise and rt is
the observation noise. The EKF and UKF approximations assume that the joint distribution over
neighboring time steps, given the i’th history, is Gaussian:
p(zt, yt|z
i
1:t−1
) ≈ N zt
yt

|µˆ
i
, Σˆ i

(13.43)
where
µˆ
i =

µˆ
i
z
µˆ
i
y

, Σˆ i =
 
Σˆ i
zz Σˆ i
zy
Σˆ i
yz Σˆ i
yy!
(13.44)
(See Section 8.5.1 for details.)
The EKF and UKF compute µˆ
i and Σˆ i
differently. In the EKF, we linearize f and h, and assume
the noise terms are Gaussian. We then compute p(zt, yt|z
i
1:t−1
) exactly for this linearized model
(see Section 8.3.1). In the UKF, we propagate sigma points through f and h, and approximate the
resulting means and covariances using the unscented transform, which can be more accurate (see
Section 8.4). Once we have computed µˆ
i and Σˆ i
, we can use standard rules for Gaussian conditioning
to compute the approximate proposal as follows:
q(zt|z
i
1:t−1
, yt) ≈ N (zt|µ
i
t
, Σ
i
t
) (13.45)
µ
i
t = µˆ
i
z + Σˆ i
zy(Σˆ i
yy)
−1
(yt − µˆ
i
y
) (13.46)
Σ
i
t = Σˆ i
zz − Σˆ i
zy(Σˆ i
yy)
−1Σˆ i
yz (13.47)
Note that the linearization (or sigma point) approximation needs to be performed for each particle
sepatately.
13.3.3 Proposals based on the Laplace approximation
To handle non-Gaussian likelihoods in an SSM, we can use the Laplace approximation (Section 7.4.3),
as suggested in [DGA00]. In particular, consider an SSM with linear-Gaussian latent dynamics and a
GLM likelihood. At each step, we compute the maximum z
∗
t = argmax log p(yt|zt) as step t (e.g.,
using Newton-Raphson), and then approximate the likelihood using
p(yt|zt) ≈ N (zt|z
∗
t
, −H∗
t
) (13.48)
where H∗
t
is the Hessian of the log-likelihood at the mode. We now compute p(zt|z
i
t−1
, yt) using the
update step of the Kalman filter, using the same equations as in Section 13.3.2. This combination is
called the Laplace Gaussian filter [Koy+10]. We give an example in Section 13.3.3.1.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license550
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 5 10 15 20 25
t
0
200
400
600
800
1000
ESS
boot
guided
Figure 13.5: Effective sample size at each step for the bootstrap particle filter and a guided particle fil￾ter for a Gaussian SSM with Poisson likelihood. Adapted from Figure 10.4 of [CP20b]. Generated by
pf_guided_neural_decoding.ipynb.
13.3.3.1 Example: neural decoding
In this section, we give an example where we apply the Laplace approximation to an SSM with
linear-Gaussian dynamics and a Poisson likelihood. The application arises from neuroscience. In
particular, assume we record the neural spike trains as a monkey moves its hand around in space.
Let zt ∈ R
6
represent the 3d location and velocity of the hand. We model the dynamics of the hand
using a simple Brownian random walk model [CP20b, p157]:

zt(i)
zt(i + 3)
|zt−1 ∼ N2
1 ∆
0 1   zt−1(i)
zt−1(i + 3)
, σ2Q

, i = 1 : 3 (13.49)
where the covariance of the noise is given by the following, assuming a discretization step of ∆:
Q =

∆3/3 ∆2/2
∆2/2 ∆ 
(13.50)
We assume the k’th observation at time t is the number of spikes for neuron k in this sensing
interval:
p(yt(k)|zt) = Poi(λk(zt)) (13.51)
log λk(zt) = αk + β
T
kzt (13.52)
Our goal is to compute p(zt|y1:t), which lets us infer the position of the hand from the neural code.
(Apart from its value for furthering basic science, this can be useful for applications such as helping
disabled people control their arms using “mind control”.)
To illustrate this, we sample a synthetic dataset from the model, to simulate a “monkey” moving
its arm for T = 25 time steps; this generates K = 50 neuronal counts per time step. We then apply
particle filtering to this dataset (using the true model), using either the bootstrap filter (i.e., proposal
is the random walk prior) or the guided filter (i.e., proposal is the Laplace approximation mentioned
above). In Figure 13.5, we see that the effective sample size of the guided filter is much higher than
for the bootstrap filter.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
13.4. RAO-BLACKWELLIZED PARTICLE FILTERING (RBPF)
13.3.4 Proposals based on SMC (nested SMC)
It is possible to use SMC as a subroutine to compute a proposal distribution for SMC: at each step t,
for each particle i, we run an SMC algorithm where the target distribution is the optimal proposal,
p(zt|z
i
1:t−1
, y1:t). This is called nested SMC [NLS15; NLS19].
This method can approximate the locally optimal proposal arbitrarily well, since it does not make
any limiting parametric assumptions. However, the method can be slow, although the inner SMC
algorithm can be run in parallel for each outer sample [NLS15; NLS19].
13.4 Rao-Blackwellized particle filtering (RBPF)
In some models, we can partition the hidden variables into two kinds, mt and zt, such that we can
analytically integrate out zt provided we know the values of m1:t. This means we only have to sample
m1:t, and can represent p(zt|m1:t, y1:t) parametrically. These hybrid particles are sometimes called
distributional particles or collapsed particles [KF09a, Sec 12.4]. This combines techniques from
particle filtering (Section 13.2) with deterministic methods such as Kalman filtering (Section 8.2.2).
The advantage of this approach is that we reduce the dimensionality of the space in which we are
sampling, which reduces the variance of our estimate. This technique is known as Rao-Blackwellized
particle filtering or RBPF for short. (See Section 11.6.2 for more details on Rao-Blackwellization.)
In Section 13.4.1 we give an example of RBPF for inference in a switching linear dynamical systems.
In Section 13.4.3 we illustrate RBPF for inference in the SLAM model for a mobile robot.
13.4.1 Mixture of Kalman filters
In this section, we consider the application of RBPF to a switching linear dynamical system
(Section 29.9). This model has both continuous and discrete latent variables. This can be used
to track a system that switches between discrete modes or operating regimes, represented by the
discrete variable mt.
For notational simplicity, we ignore the control inputs ut. Thus the model is given by
p(zt|zt−1, mt = k) = N (zt|Fkzt−1, Qk) (13.53)
p(yt|zt, mt = k) = N (yt|Hkzt, Rk) (13.54)
p(mt = k|mt−1 = j) = Ajk (13.55)
We let θk = (Fk, Hk, Qk, Rk, A:,k) represent all the parameters for state k.
Exact inference is intractable, but if we sample the discrete variables, we can infer the continuous
variables conditoned on the discretes exactly, making this a good candidate for RBPF. In particular,
if we sample trajectories mn
1:t
, we can apply a Kalman filter to each particle. This can be thought of
as a mixture of Kalman filters [CL00]. The resulting belief state is represented by
p(zt,mt|y1:t) ≈
X
N
n=1
Wn
t
δ(mt − mn
t
)N (zt|µ
n
t
, Σ
n
t
) (13.56)
To derive the filtering algorithm, note that the full posterior at time t can be written as follows:
p(m1:t, z1:t|y1:t) = p(z1:t|m1:t, y1:t)p(m1:t|y1:t) (13.57)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license552
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The second term is given by the following:
p(m1:t|y1:t) ∝ p(yt|m1:t, y1:t−1)p(m1:t|y1:t−1) (13.58)
= p(yt|m1:t, y1:t−1)p(mt|m1:t−1, y1:t−1)p(m1:t−1|y1:t−1) (13.59)
= p(yt|m1:t, y1:t−1)p(mt|mt−1)p(m1:t−1|y1:t−1) (13.60)
Note that, unlike the case of standard particle filtering, we cannot write p(yt|m1:t, y1:t−1) = p(yt|mt),
since mt does not d-separate the past observations from yt, as is evident from Figure 29.25a.
Suppose we use the following recursive proposal distribution:
q(m1:t|y1:t) = q(mt|m1:t−1, y1:t)q(m1:t−1|y1:t) (13.61)
Then we get the unnormalized importance weights
w˜
n
t ∝
p(yt|mn
t
,mn
1:t−1
, y1:t−1)p(mn
t
|mn
t−1
)
q(mn
t
|mn
1:t−1
, y1:t)
w˜
n
t−1
(13.62)
As a special case, suppose we propose from the prior, q(mt|mn
t−1
, y1:t) = p(mt|mn
t−1
). If we sample
discrete state k, the weight update becomes
w˜
n
t ∝ w˜
n
t−1p(yt|mn
t = k,mn
1:t−1
, y1:t−1) = ˜w
n
t−1L
n
tk (13.63)
where
L
n
tk = p(yt|mt = k,mn
1:t−1
, y1:t−1) = Z
p(yt|mt = k, zt)p(zt|mt = k, y1:t−1,mn
1:t−1
)dzt (13.64)
The quantity L
n
tk is the predictive density for the new observation yt conditioned on mt = k and
the history of previous latents, mn
1:t−1
. In the case of SLDS models, this can be computed using
the normalization constant of the Kalman filter, Equation (8.35). The resulting algorithm is shown
in Algorithm 13.4. The step marked “KFupdate” refers to the Kalman filter update equations in
Section 8.2.2, and is applied to each particle separately.
Algorithm 13.4: One step of RBPF for SLDS using prior as proposal
1 for n = 1 : N do
2 k ∼ p(mt|mn
t−1
)
3 mn
t
:= k
4 (µ
n
t
, Σ
n
t
, Ln
tk
) = KFupdate(µ
n
t−1
, Σ
n
t−1
, yt, θk)
5 w˜
n
t = ˜w
n
t−1L
n
tk
6 Compute ESS = ESS( ˜w
1:Ns
t
)
7 if ESS < ESSmin then
8 a
1:N
t = Resample(w˜
1:N
t
)
9 (m1:Ns
t
, µ
1:Ns
t
, Σ
1:Ns
t
) = permute(at,m1:Ns
t
, µ
1:Ns
t
, Σ
1:Ns
t
)
10 w˜
n
t = 1/Ns
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
13.4. RAO-BLACKWELLIZED PARTICLE FILTERING (RBPF)
13.4.1.1 Improvements
An improved version of the algorithm can be developed based on the fact that we are sampling a
discrete state space. At each step, we propagate each of the N old particles through all K possible
transition models. We then compute the weight for all NK new particles, and sample from this to
get the final set of N particles. This latter step can be done using the optimal resampling method
of [FC03], which will stochastically select the particles with the largest weight, while also ensuring
the result is an unbiased approximation. In addition, this approach ensures that we do not have
duplicate particles, which is wasteful and unnecessary when the state space is discrete.
13.4.2 Example: tracking a maneuvering object
In this section we give an example of RBPF for an SLDS from [DGK01]. Our goal is to track an
object that has the following motion model:
p(zt|zt−1, mt = k) = N (zt|Fzt−1 + bk, Q) (13.65)
where zt = (x1t, x˙ 1t, x2t, x˙ 2t) contains the 2d position and velocity. We define the observaton matrix
by H = I and the observation covariance by R = 10 diag(2, 1, 2, 1). We define the dynamics matrix
by
F =


1 ∆ 0 0
0 1 0 0
0 0 1 ∆
0 0 0 1


(13.66)
where ∆ = 0.1,. We set the noise covariance to Q = 0.2I and the input bias vectors for each state
to b1 = (0, 0, 0, 0), b2 = (−1.225, −0.35, 1.225, 0.35) and b3 = (1.225, 0.35, −1.225, −0.35). Thus the
system will turn in different directions depending on the discrete state. The discrete state transition
matrix is given by
A =


0.8 0.1 0.1
0.1 0.8 0.1
0.1 0.1 0.8

 (13.67)
Figure 13.6a shows some observations, and the true state of the system, from a sample run, for
100 steps. The colors denote the discrete state, and the location of the symbol denotes the (x, y)
location. The small dots represent noisy observations. Figure 13.6b shows the estimate of the state
computed using RBPF with the optimal proposal with 1000 particles. In Figure 13.6c, we show the
analogous estimate using the boostrap filter, which does much worse.
In Figure 13.7a and Figure 13.7b, we show the posterior marginals of the (x, y) locations over time.
In Figure 13.7c we show the true discrete state, and in Figure 13.7d we show the posterior marginal
over discrete states. The overall state classification error rate is 29%, but it seems that occasionally
misclassifying isolated time steps does not significantly hurt estimation of the continuous states, as
we can see from Figure 13.6b.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license554
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−50 −40 −30 −20 −10 0
−30
−20
−10
0
10
20
Data
(a)
−50 −40 −30 −20 −10 0
−20
−10
0
10
20
RBPF MSE: 7.66
(b)
−50 −40 −30 −20 −10 0
−30
−20
−10
0
10
20
Bootstrap Filter MSE: 10.95
(c)
Figure 13.6: Illustration of state estimation for a switching linear model. (a) Black dots are observations,
hollow circles are the true location, colors represent the discrete state. (b) Estimate from RBPF. Generated
by rbpf_maneuver.ipynb. (c) Estimate from bootstrap filter. Generated by bootstrap_filter_maneuver.ipynb.
13.4.3 Example: FastSLAM
Consider a robot moving around an environment, such as a maze or indoor office environment. It
needs to learn a map of the environment, and keep track of its location (pose) within that map.
This problem is known as simultaneous localization and mapping, or SLAM for short. SLAM
is widely used in mobile robotics (see e.g., [SC86; CN01; TBF06] for details). It is also useful in
augmented reality, where the task is to recursively estimate the 3d pose of a handheld camera with
respect to a set of 2d visual landmarks (this is known as visual SLAM, [TUI17; SMT18; Cza+20;
DH22]).
Let us assume we can represent the map as the 2d locations of a set of K landmarks, denote them
by l
1
, . . . ,l
K (each is a vector in R
2
). (We can use data association to figure out which landmark
generated each observation, as discussed in Section 29.9.3.2.) Let rt represent the unknown location
of the robot at time t. Let zt = (rt,l
1:K
t
) be the combined state space. We can then perform online
inference so that the robot can update its estimate of its own location, and the landmark locations.
The state transition model is defined as
p(zt|zt−1,ut) = p(rt|rt−1,l
1:K
t−1
,ut)
Y
K
k=1
p(l
k
t
|l
k
t−1
) (13.68)
where p(rt|rt−1,l
1:K
t−1
,ut) specifies how the robot moves given the control signal ut and the location
of the obstacles l
1:K
t−1
. (Note that in this section, we assume that a human is joysticking the robot
through the environment, so u1:t is given as input, i.e., we do not address the decision-theoretic issue
of choosing where to move.)
If the obstacles (landmarks) are static, we can define p(l
k
t
|l
k
t−1
) = δ(l
k
t − l
k
t−1
), which is equivalent
to treating the map as an unknown parameter that is shared globally across all time steps. More
generally, we can let the landmark locations evolve over time [Mur00].
The observations yt measure the distance from rt to the set of closest landmarks. Figure 13.8
shows the corresponding graphical model for the case where K = 2, and where on the first step it
sees landmarks 1 and 2, then just landmark 2, then just landmark 1, etc.
If all the CPDs are linear-Gaussian, then we can use a Kalman filter to maintain our belief state
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
13.4. RAO-BLACKWELLIZED PARTICLE FILTERING (RBPF)
t
0
20
40
60
80
100 xd = 0,t
−50
−40
−30
−20
−10
0
p
(
xd
,
t
|
y1 :
t
)
0.0
0.2
0.4
0.6
0.8
1.0
(a)
t
0
20
40
60
80
100 xd = 2,t
−30
−20
−10
0
10
20
p
(
xd
,
t
|
y1 :
t
)
0.0
0.2
0.4
0.6
0.8
1.0
(b)
0 1 2
0
5
10
15
20
25
30
35
40
45
50
55
60
65
70
75
80
85
90
95
Data
(c)
0 1 2
0
5
10
15
20
25
30
35
40
45
50
55
60
65
70
75
80
85
90
95
MAP (error rate: 0.2900)
(d)
Figure 13.7: Visualizing the posterior from the RBPF algorithm. Top row: Posterior marginals of the location
of the object over time, derived from the mixture of Gaussian representation for (a) x location (dimension
0), (b) y location (dimension 2). Bottom row: visualization of the true (c) and predicted (d) discrete states.
Generated by rbpf_maneuver.ipynb.
about the location of the robot and the location of the landmarks, p(zt|y1:t,u1:t). In the more
general case of a nonlinear model, we can use the EKF (Section 8.3.2) or UKF (Section 8.4.2).
Over time, the uncertainty in the robot’s location will increase, due to wheel slippage, etc., but when
the robot returns to a familiar location, its uncertainty will decrease again. This is called closing
the loop, and is illustrated in Figure 13.9(a), where we see the uncertainty ellipses, representing
Cov [zt|y1:t,u1:t], grow and then shrink.
In addition to visualizing the uncertainty of the robot’s location, we can visualize the uncertainty
about the map. To do this, consider the posterior precision matrix, Λt = Σ
−1
t
. Zeros in the precision
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license556
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
l
2
y
2
1
y
2
2
y
2
T
y
1
1
y
1
3
r1 r2 r3
. . .
rT
l
1
(a)
l
1
1
l
1
2
l
1
3
. . .
l
1
T
l
2
1
l
2
2
l
2
3
. . .
l
2
T
y
2
1
y
1
1
y
2
2
y
1
3
y
2
T
r1 r2 r3
. . .
rT
(b)
Figure 13.8: Graphical model representing the SLAM problem. l
k
t
is the location of landmark k at time
t, rt is the location of the robot at time t, and yt is the observation vector. In the model on the left, the
landmarks are static (so they act like global shared parameters), on the right, their location can change over
time. The robot’s observations are based on the distance to the nearest landmarks from the current state,
denoted f(rt,l
k
t ). The number of observations per time step is variable, depending on how many landmarks
are within the range of the sensor. Adapted from Figure 15.A.3 of [KF09a].
Robot pose
(a) (b)
Figure 13.9: Illustration of the SLAM problem. (a) A robot starts at the top left and moves clockwise in
a circle back to where it started. We see how the posterior uncertainty about the robot’s location increases
and then decreases as it returns to a familar location, closing the loop. If we performed smoothing, this
new information would propagate backwards in time to disambiguate the entire trajectory. (b) We show the
precision matrix, representing sparse correlations between the landmarks, and between the landmarks and
the robot’s position (pose). The conditional independencies encoded by the sparse precision matrix can be
visualized as a Gaussian graphical model, as shown on the right. From Figure 15.A.3 of [KF09a]. Used with
kind permission of Daphne Koller.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
13.5. EXTENSIONS OF THE PARTICLE FILTER
matrix correspond to absent edges in the corresponding undirected Gaussian graphical model (GGM,
see Section 4.3.5). Initially all the beliefs about landmark locations are uncorrelated (by assumption),
so the GGM is a disconnected graph, and Λt is diagonal. However, as the robot moves about, it will
induce correlation between nearby landmarks. Intuitively this is because the robot is estimating its
position based on distance to the landmarks, but the landmarks’ locations are being estimated based
on the robot’s position, so they all become interdependent. This can be seen more clearly from the
graphical model in Figure 13.8: it is clear that l
1 and l
2 are not d-separated by y1:t, because there is
a path between them via the unknown sequence of r1:t nodes. Consequently, the precision matrix
becomes denser over time. As a consequence of the precision matrix becoming denser, each inference
step takes O(K3
) time. This prevents the method from being applied to large maps.
One way to speed this up is based on the following observation: conditional on knowing the robot’s
path, r1:t, the landmark locations are independent, i.e., p(lt|r1:t, y1:t) = QK
k=1 p(l
k
t
|r1:t, y1:t). This
can be seen by looking at the DGM in Figure 13.8. We can therefore sample the trajectory using
some proposal, and apply (2d) Kalman filtering to each landmark independently. This is an example
of RBPF, and reduces the inference cost to O(NK), where N is the number of particles and K is
the number of landmarks.
The overall cost of this technique is O(NK) per step. Fortunately, the number of particles N
needed for good performance is quite small, so the algorithm is essentially linear in the number of
landmarks, making it quite scalable. This idea was first suggested in [Mur00], who applied it to
grid-structured occupancy grids (and used the HMM filter for each particle). It was subsequently
extended to landmark-based maps in [Thr+04], using the Kalman filter for each particle; they called
the technique FastSLAM.
13.5 Extensions of the particle filter
There are many extensions to the basic particle filtering algorithm, such as the following:
• We can increase particle diversity by applying one or more steps of MCMC sampling (Section 12.2)
at each PF step using πt(zt) as the target distribution. This is called the resample-move
algorithm [DJ11]. It is also possible to use SMC instead of MCMC to diversify the samples
[GM17].
• We can extend PF to the case of offline inference; this is called particle smoothing (see e.g.,
[Kla+06]).
• We can extend PF to inference in general graphical models (not just chains) by combining PF
with loopy belief propagation (Section 9.4); this is called non-parametric BP or particle BP
(see e.g., [Sud+03; Isa03; Sud+10; Pac+14]).
• We can extend PF to perform inference in static models (e.g., for parameter inference), as we
discuss in Section 13.6.
13.6 SMC samplers
In this section, we discuss SMC samplers (sequential Monte Carlo samplers), which are a way
to apply particle filters to sample from a generic target distribution, π(z) = γ˜(z)/Z, rather than
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license558
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
requiring the model to be an SSM. Thus SMC is an alternative to MCMC.
The advantages of SMC samplers over MCMC are as follows: we can estimate the normalizing
constant Z; we can more easily develop adaptive versions that tune the transition kernel using the
current set of samples; and the method is easier to parallelize (see e.g., [CCS22; Gre+22]).
The method works by defining a sequence of intermediate distributions, πt(zt), which we expand
to a sequence of distributions over all the past variables, πt(z1:t). We then use the particle filtering
algorithm to sample from each of these intermediate distributions. By marginalizing all but the final
state, we recover samples from the target distribution, π(z) = P
z1:T−1
πT (z1:T ), as we explain below.
(For more details, see e.g., [Dai+20a; CP20b].)
13.6.1 Ingredients of an SMC sampler
To define an SMC sampler, we need to specify several ingredients:
• A sequence of distributions defined on the same state space, πt(zt) = ˜γt(zt)/Zt, for t = 0 : T;
• A forwards kernel Mt(zt|zt−1) (often written as Mt(zt−1, zt)), which satisfies P
zt Mt(zt|zt−1) =
1. This can be used to propose new samples from our current estimate when we apply particle
filtering.
• A backwards kernel Lt(zt|zt+1) (often written as L(zt, zt+1)), which satisfies P
zt
Lt(zt|zt+1) =
1. This allows us to create a sequence of variables by working backwards in time from the final
target value to the first time step. In particular, we create the following joint distribution:
πt(z1:t) = πt(zt)
tY−1
s=1
Ls(zs|zs+1) (13.69)
This satisfies P
z1:t−1
πt(z1:t) = πt(zt), so if we apply particle filtering to this for t = 1 : T, then
samples from the “end” of such sequences will be from the target distribution πt.
With the above ingredients, we can compute the incremental weight at step t using
αt =
πt(z1:t)
πt−1(z1:t−1)Mt(zt|zt−1)
∝
γ˜t(zt)
γ˜t−1(zt−1)
Lt−1(zt−1|zt)
Mt(zt|zt−1)
(13.70)
This can be plugged into the generic SMC algorithm, Algorithm 13.3.
We still have to specify the forwards and backwards kernels. We will assume the forwards kernel
Mt is an MCMC kernel that leaves πt invariant. We can then define the backwards kernel to be the
time reversal of the forwards kernel. More precisely, suppose we define Lt−1 so it satisfies
πt(zt)Lt−1(zt−1|zt) = πt(zt−1)Mt(zt|zt−1) (13.71)
In this case, the incremental weight simplifies as follows:
αt =
Ztπt(zt)Lt−1(zt−1|zt)
Zt−1πt−1(zt−1)Mt(zt|zt−1)
(13.72)
=
Ztπt(zt−1)Mt(zt|zt−1)
Zt−1πt−1(zt−1)Mt(zt|zt−1)
(13.73)
=
γ˜t(zt−1)
γ˜t−1(zt−1)
(13.74)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
13.6. SMC SAMPLERS
We can use any kind of MCMC kernel for Mt. For example, if the parameters are real valued and
unconstrained, we can use a Markov kernel that corresponds to K steps of a random walk Metropolis￾Hastings sampler. We can set the covariance of the proposal to δ
2Σˆ
t−1, where Σˆ
t−1 is the empirical
covariance of the weighted samples from the previous step, (W1:N
t−1
, z
1:N
t−1
), and δ = 2.38D−3/2
(which
is the optimal scaling parameter for RWMH). In high dimensional problems, we can use gradient
based Markov kernels, such as HMC [BCJ20] and NUTS [Dev+21]. For binary state spaces, we can
use the method of [SC13].
13.6.2 Likelihood tempering (geometric path)
There are many ways to specify the intermediate target distributions. In the geometric path
method, we specify the intermediate distributions to be
γ˜t(z) = ˜γ0(z)
1−λt γ˜(z)
λt
(13.75)
where 0 = λ0 < λ1 < · · · < λT = 1 are inverse temperature parameters, and γ˜0 is the initial
proposal. If we apply particle filtering to this model, but “turn off” the resampling step, the method
becomes equivalent to annealed importance sampling (Section 11.5.4).
In the context of Bayesian parameter inference, we often denote the latent variable z by θ, we
define γ˜0(θ) ∝ π0(θ) as the prior, and γ˜(z) = π0(θ)p(D|θ) as the posterior. We can then define the
intermediate distributions to be
γ˜t(θ) = π0(θ)
1−λtπ0(θ)
λt p(D|θ)
λt = π0(θ)
1−λt exp[−λtE(θ)] (13.76)
where E(θ) = − log p(D, θ) is the energy (potential) function. The incremental weights are given by
αt(θ) = π0(θ)
1−λt exp[−λtE(θ)]
π0(θ)
1−λt exp[−λt−1E(θ)] = exp[−δtE(θ)] (13.77)
where λt = λt−1 + δt.
For this method to work well, it is important to choose the λt so that the successive distributions
are “equidistant”; this is called adaptive tempering. In the case of a Gaussian prior and Gaussian
energy, one can show [CP20b] that this can be achieved by picking λt = (1 + γ)
t+1 − 1, where γ > 0
is some constant. Thus we should increase λ slowly at first, and then make bigger and bigger steps.
In practice we can estimate λt by setting λt = λt−1 + δt , where
δt = argmin
δ∈[0,1−λt−1]
(ESSLW({−δ E(θ
n
t
)}) − ESSmin) (13.78)
where ESSLW({ln}) = ESS({e
ln }) computes the ESS (Equation (13.37)) from the log weights,
ln = log ˜w
n. This ensures the change in the ESS across steps is close to the desired minimum ESS,
typically 0.5N. (If there is no solution for δ in the interval, we set δt = 1−λt−1.) See Algorithm 13.5
for the overall algorithm.
13.6.2.1 Example: sampling from a 1d bimodal distribution
Consider the simple distribution
p(θ) ∝ N (θ|0, I) exp(−E(θ)) (13.79)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license560
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Algorithm 13.5: SMC with adaptive tempering
1 λ−1 = 0, t = −1, Wn
−1 = 1
2 while λt < 1 do
3 t = t + 1
4 if t = 0 then
5 θ
n
0 ∼ π0(θ)
6 else
7 A1:N
t = Resample(W1:N
t−1
)
8 θ
n
t ∼ Mλt−1
(θ
A
n
t
t−1
, ·)
9 Compute δt using Equation (13.78)
10 λt = λt−1 + δt
11 w˜
n
t = exp[−δE(θ
n
t
)]
12 Wn
t = ˜w
n
t /(
PN
m=1 w˜
m
t
)
−2 −1 0 1 2
0.0
0.5
1.0
1
(a)
−2 −1 0 1 2
0.0
0.5
1.0
0.0
0.25
0.5
0.75
1.0
(b)
Figure 13.10: (a) Illustration of a bimodal target distribution. (b) Tempered versions of the target at different
inverse temperatures, from λT = 1 down to λ1 = 0. Generated by smc_tempered_1d_bimodal.ipynb.
where E(θ) = c(||θ||2 − 1)2
. We plot this in 1d in Figure 13.10a for c = 5; we see that it has a
bimodal shape, since the low energy states correspond to parameter vectors whose norm is close to 1.
SMC is particularly useful for sampling from multimodal distributions, which can be provably
hard to efficiently sample from using other methods, including HMC [MPS18], since gradients only
provide local information about the curvature. As an example, in Figure 13.11a and Figure 13.11b
we show the result of applying HMC (Section 12.5) and NUTS (Section 12.5.4.1) to this problem.
We see that both algorithms get stuck near the initial state of θ0 = 1.
In Figure 13.10b, we show tempered versions of the target distribution at 5 different temperatures,
chosen uniformly in the interval [0, 1]. We see that at λ1 = 0, the tempered target is equal to the
Gaussian prior (blue line), which is easy to sample from. Each subsequent distribution is close to the
previous one, so SMC can track the change until it ends up at the target distribution with λT = 1,
as shown in Figure 13.11c.
These SMC results were obtained using the adaptive tempering scheme described above. In
Figure 13.11d we see that initially the temperature is small, and then it increases exponentially. The
algorithm takes 8 steps until λT ≥ 1.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
13.6. SMC SAMPLERS
−2 −1 0 1 2
0
1
2
3
4
(a)
−2 −1 0 1 2
0
1
2
3
4
(b)
−2 −1 0 1 2
0
1
2
3
4
(c)
0 2 4 6 8
t
0.0
0.5
1.0
tempering exponent
(d)
Figure 13.11: Sampling from the bimodal distribution in Figure 13.10a. (a) HMC. (b) NUTS. (c) Tem￾pered SMC with HMC kernel (single step). (d) Adaptive inverse temperature schedule. Generated by
smc_tempered_1d_bimodal.ipynb.
13.6.3 Data tempering
If we have a set of iid observations, we can define the t’th target to be
γ˜t(θ) = p(θ)p(y1:t|θ) (13.80)
We can now apply SMC to this model. From Equation (13.74), the incremental weight becomes
αt(θ) = γ˜t(zt−1)
γ˜t−1(zt−1)
=
p(θ)p(y1:t|θ)
p(θ)p(y1:t−1|θ)
= p(yt|y1:t−1, θ) (13.81)
This can be plugged into the generic SMC algorithm in Algorithm 13.3.
Unfortunately, to sample from the MCMC kernel will typically take O(t) time, since the MH
accept/reject step requires computing p(θ
′
)
Qt
i=1 p(y1i
|θ
′
) for any proposed θ
′
. Hence the total
cost is O(T
2
) if there are T observations. To reduce this, we can only sample parameters at times
t when the ESS drops below a certain level; in the remaining steps, we just grow the sequence
deterministically by repeating the previously sampled value. This technique was proposed in [Cho02],
who called it the iterated batch importance sampling or IBIS algorithm.
13.6.3.1 Example: IBIS for a 1d Gaussian
In this section, we give a simple example of IBIS applied to data from a 1d Gaussian, yt ∼ N (µ =
3.14, σ = 1) for t = 1 : 30. The unknowns are θ = (µ, σ). The prior is p(θ) = N (µ|0, 1)Ga(σ|a =
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license562
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−5 0 5
mu
0
1
2
0.0 2.5 5.0
sigma
0
1
2
3
t=1
t=29
(a)
0 10 20 30
t
250
500
750
ESS
(b)
Figure 13.12: Illustration of IBIS applied to 30 samples from N (µ = 3.14, σ = 1). (a) Posterior approximation
after t = 1 and t = 29 observations. (b) Effective sample size over time. The sudden jumps up occur whenever
resampling is triggered, which happens when the ESS drops below 500. Generated by smc_ibis_1d.ipynb.
1, b = 1). We use IBIS with an adaptive RWMH kernel. We use N = 20 particles, each updated for
K = 50 MCMC steps, so we collect 1000 samples per time step.
Figure 13.12a shows the approximate posterior after t = 1 and t = 29 time steps. We see that the
posterior concentrates on the true values of µ = 3.14 and σ = 1.
Figure 13.12b plots the ESS vs time. The number of particles is 1000, and resampling (and MCMC
moves) is triggered whenever this drops below 500. We see that we only need to invoke MCMC
updates 3 times.
13.6.4 Sampling rare events and extrema
Suppose we want to sample values from π0(θ) conditioned on the event that S(θ) > λ∗
, where S
is some score or “fitness” function. If λ
∗
is in the tail of the score distribution, this corresponds to
sampling a rare event, which can be hard.
One approach is to use SMC to sample from a sequence of distributions with gradually increasing
thresholds:
πt(θ) = 1
Zt
I(S(θ) ≥ λt) π0(θ) (13.82)
with λ0 < · · · < λT = λ
∗
. We can then use likelihood tempering, where the “likelihood” is the
function
Gt(θt) = I(S(θt) ≥ λt) (13.83)
We can use SMC to generate samples from the final distribution πT . We may also be interested in
estimating
ZT = p(S(θ) ≥ λT ) (13.84)
where the probability is taken wrt π0(θ).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
13.6. SMC SAMPLERS
We can adaptively set the thresholds λt as follows: at each step, sort the samples by their score,
and set λt to the α’th highest quantile. For example, if we set α = 0.5, we keep the top 50% fittest
particles. This ensures the ESS equals the minimum threshold at each step. For details, see [Cér+12].
Note that this method is very similar to the cross-entropy method (Section 6.7.5). The difference
is that CEM fits a parametric distribution (e.g., a Gaussian) to the particles at each step and samples
from that, rather than using a Markov kernel.
13.6.5 SMC-ABC and likelihood-free inference
The term likelihood-free inference refers to estimating the parameters θ of a blackbox from which
we can sample data, y ∼ p(·|θ), but where we cannot evaluate p(y|θ) pointwise. Such models are
called simulators, so this approach to inference is also called simulation-based inference (see e.g.,
[Nea+08; CBL20; Gou+96]). These models are also called implicit models (see Section 26.1).
If we want to approximate the posterior of a model with no known likelihood, we can use
approximate Bayesian computation or ABC (see e.g., [Bea19; SFB18; Gut+14; Pes+21]).
In this setting, we sample both parameters θ and synthetic data y such that the synthetic data
(generated from θ) is sufficiently close to the observed data y
∗
, as judged by some distance score,
d(y, y
∗
) < ǫ. (For high dimensional problems, we typically require d(s(y), s(y
∗
)) < ǫ, where s(y) is
a low-dimensionary summary statistic of the data.)
In SMC-ABC, we gradually decrease the discrepancy ǫ to get a series of distributions as follows:
πt(θ, y) = 1
Zt
π0(θ)p(y|θ)I(d(y, y
∗
) < ǫt) (13.85)
where ǫ0 > ǫ1 > · · · . This is similar to the rare event SMC samplers in Section 13.6.4, except that we
can’t directly evaluate the quality of a candidate, θ. Instead we must first convert it to data space
and make the comparison there. For details, see [DMDJ12].
Although SMC-ABC is popular in some fields, such as genetics and epidemiology, this method
is quite slow and does not scale to high dimensional problems. In such settings, a more efficient
approach is to train a generative model to emulate the simulator; if this model is parametric with a
tractable likelihood (e.g., a flow model), we can use the usual methods for posterior inference of its
parameters (including gradient based methods like HMC). See e.g., [Bre+20a] for details.
13.6.6 SMC2
We have seen how SMC can be a useful alternative to MCMC. However it requires that we can
efficiently evaluate the likelihood ratio terms γt(θt)
γt−1(θt)
. In cases where this is not possible (e.g., for
latent variable models), we can use SMC (specifically the estimate Zˆ
t in Equation (13.10)) as a
subroutine to approximate these likelihoods. This is called SMC2
. For details, see [CP20b, Ch. 18].
13.6.7 Variational filtering SMC
One way to improve SMC is to learn a proposal distribution (e.g., using a neural network) such that
the approximate posterior, πˆT (z1:T ; φ, θ), is close to the target posterior, πT (z1:T ; θ), where θ are
the model parameters, and φ are the proposal parameters (which may depend on θ). One can show
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license564
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[Nae+18] that the KL divergence between these distributions can be bounded as follows:
0 ≤ DKL (E [ˆπT (z1:T )] k πT (z1:T )) ≤ −E
"
log Zˆ
T
ZT
#
(13.86)
where
ZT (θ) = pθ(y1:T ) = Z
pθ(z1:T , y1:T )dz1:T (13.87)
Hence
E
h
log Zˆ
T (θ, φ)
i
≤ E [log ZT (θ)] = log ZT (θ) (13.88)
Thus we can use SMC sampling to compute an unbiased approximation to E
h
log Zˆ
T (θ, φ)
i
, which is
a lower bound on the evidence (log marginal likelihood).
We can now maximize this lower bound wrt θ and φ using SGD, as a way to learn both proposals
and the model. Unfortunately, computing the gradient of the bound is tricky, since the resampling
step is non-differentiable. However, in practice one can ignore the dependence of the resampling
operator on the parameters, or one can use differentiable approximations (see e.g., [Ros+22]). This
overall approach was independently proposed in several papers: the FIVO (filtering variational
objective) paper [Mad+17], the variational SMC paper [Nae+18] and the auto-encoding SMC
paper [Le+18].
13.6.8 Variational smoothing SMC
The methods in Section 13.6.7 use SMC in which the target distributions are defined to be the
filtered distributions, πt(z1:t) = pθ(z1:t|y1:t); this is called filtering SMC. Unfortunately, this can
work poorly when fitting models to offline sequence data, since at time t, all future observations are
ignored in the objective, no matter how good the proposal. This can create situations where future
observations are unlikely given the current set of sampled trajectories, which can result in particle
impoverishment and high variance in the estimate of the lower bound.
Recently, a new method called SIXO (smoothing inference with twisted objectives) was proposed
in [Law+22] that uses the smoothing distributions as targets, πt(z1:t) = pθ(z1:t|y1:T ), to create a
much lower variance variational lower bound. Of course it is impossible to directly compute this
posterior, but we can approximate it using twisted particle filters [WL14a; AL+16]. In this
approach, we approximate the (unnormalized) posterior using
pθ(z1:t, y1:T ) = pθ(z1:t, y1:t)pθ(yt+1:T |z1:t, y1:t) (13.89)
= pθ(z1:t, y1:t)pθ(yt+1:T |zt) (13.90)
≈ pθ(z1:t, y1:t)rψ(yt+1:T , zt) (13.91)
where rψ(yt+1:T , zt) ≈ pθ(yt+1:T |zt) is the twisting function, which acts as a “lookahead func￾tion”.
One way to approximate the twisting function is to note that
pθ(yt+1:T |zt) = pθ(zt|yt+1:T )pθ(yt+1:T )
pθ(zt)
∝
pθ(zt|yt+1:T )
pθ(zt)
(13.92)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
13.6. SMC SAMPLERS
where we drop terms that are independent of zt since such terms will cancel out when we normalize
the sampling weights. We can approximate the density ratio using the binary classifier method of
Section 2.7.5. To do this, we define one distribution to be p1 = pθ(zt, yt+1:T ) and the other to be
p2 = pθ(zt)pθ(yt+1:T ), so that p1/p2 =
pθ(zt|yt+1:T )
pθ(zt)
. We can easily draw a sample (z1:T , y1:T ) ∼ pθ
using ancestral sampling, from which we can compute (zt, yt+1:T ) ∼ p1 by marginalization. We can
also sample a fresh sequence from (z˜1:T , y˜1:T ) ∼ pθ from which we can compute (z˜t, y˜t+1:T ) ∼ p2
by marginalization. We then use (zt, yt+1:T ) as a positive example and (z˜t, y˜t+1:T ) as a negative
example when training the binary classifier, rψ(yt+1:T , zt).
Once we have updated the twisting parameters ψ, we can rerun SMC to get a tighter lower bound
on the log marginal likelihood, which we can then optimize wrt the model parameters θ and proposal
parameters φ. Thus the overall method is a stochastic variational EM-like method for optimziing
the bound
LSIXO(θ, φ, ψ, y1:T ) , E
h
log Zˆ
SIXO(θ, φ, ψ, y1:T )
i
(13.93)
≤ log E
h
Zˆ
SIXO(θ, φ, ψ, y1:T )
i
= log pθ(y1:T ) (13.94)
In [Law+22] they prove the following: suppose the true model p
∗
is an SSM in which the optimal
proposal function for the model satisfies p
∗
(zt|z1:t−1, y1:T ) ∈ Q, and the optimal lookahead function
for the model satisfies p
∗
(yt+1:T |zt) ∈ R. Furthermore, assume the SIXO objective has a unique
maximizer. Then, at the optimum, we have that the learned proposal qφ∗ (zt|z1:t−1, y1:T ) ∈ Q is
equal to the optimal proposal, the learned twisting function rψ∗ (yt+1:T , zt) ∈ R is equal to the
optimal lookahead, and the lower bound is tight (i.e., LSIXO(θ
∗
, φ
∗
, ψ
∗
) = p
∗
(y1:T )) for any number
of samples Ns ≥ 1 and for any kind of SSM p
∗
. (This is in contrast to the FIVO bound, whiere the
bound does not usually become tight.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licensePart III
Prediction14 Predictive models: an overview
14.1 Introduction
The vast majority of machine learning is concerned with tackling a single problem, namely learning
to predict outputs y from inputs x using some function f that is estimated from a labeled training
set D = {(xn, yn) : n = 1 : N}, for xn ∈ X ⊆ R
D and yn ∈ Y ⊆ R
C . We can model our uncertainty
about the correct output for a given input using a conditional probability model of the form p(y|f(x)).
When Y is a discrete set of labels, this is called (in the ML literature) a discriminative model,
since it lets us discriminate (distinguish) between the different possible values of y. If the output
is real-valued, Y = R, this is called a regression model. (In the statistics literature, the term
“regression model” is used in both cases, even if Y is a discrete set.) We will use the more generic
term “predictive model” to refer to such models.
A predictive model can be considered as a special case of a conditional generative model (discussed
in Chapter 20). In a predictive model, the output is usually low dimensional, and there is a single
best answer that we want to predict. However, in most generative models, the output is usually high
dimensional, such as images or sentences, and there may be many correct outputs for any given input.
We will discuss a variety of types of predictive model in Section 14.1.1, but we defer the details to
subsequent chapters. The rest of this chapter then discusses issues that are relevant to all types of
predictive model, regardless of the specific form, such as evaluation.
14.1.1 Types of model
There are many different kinds of predictive model p(y|x). The biggest distinction is between
parametric models, that have a fixed number of parameters independent of the size of the training
set, and non-parametric models that have a variable number of parameters that grows with the
size of the training set. Non-parametric models are usually more flexible, but can be slower to use
for prediction. Parametric models are usually less flexible, but are faster to use for prediction.
Most non-parametric models are based on comparing a test input x to some or all of the stored
training examples {xn, n = 1 : N}, using some form of similarity, sn = K(x, xn) ≥ 0, and then
predicting the output using some weighted combination of the training labels, such as yˆ =
PN
n=1 snyn.
A typical example is a Gaussian process, which we discuss in Chapter 18. Other examples, such as
K-nearest neighbor models, are discussed in the prequel to this book, [Mur22].
Most parametric models have the form p(y|x) = p(y|f(x; θ)), where f is some kind of function
that predicts the parameters (e.g., the mean, or logits) of the output distribution (e.g., Gaussian
or categorical). There are many kinds of function we can use. If f is a linear function of θ (i.e.,570
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
f(x; θ) = θ
Tφ(x) for some fixed feature transformation φ), then the model is called a generalized
linear model or GLM, which we discuss in Chapter 15. If f is a non-linear, but differentiable, function
of θ (e.g., f(x; θ) = θ
T
2φ(x; θ1) for some learnable function φ(x; θ1)), then it is common to represent
f using a neural network (Chapter 16). Other types of predictive model, such as decision trees and
random forests, are discussed in the prequel to this book, [Mur22].
14.1.2 Model fitting using ERM, MLE, and MAP
In this section, we briefly discuss some methods used for fitting (parametric) models. The most
common approach is to use maximum likelihood estimation or MLE, which amounts to solving
the following optimization problem:
θˆ = argmax
θ∈Θ
p(D|θ) = argmax
θ∈Θ
log p(D|θ) (14.1)
If the dataset is N iid data samples, the likelihood decomposes into a product of terms, p(D|θ) =
QN
n=1 p(yn|xn, θ). Thus we can instead minimize the following (scaled) negative log likelihood:
θˆ = argmin
θ∈Θ
1
N
X
N
n=1
[− log p(yn|xn, θ)] (14.2)
We can generalize this by replacing the log loss ℓn(θ) = − log p(yn|xn, θ) with a more general
loss function to get
θˆ = argmin
θ∈Θ
r(θ) (14.3)
where r(θ) is the empirical risk
r(θ) = 1
N
X
N
n=1
ℓn(θ) (14.4)
This approach is called empirical risk minimization or ERM.
ERM can easily result in overfitting, so it is common to add a penalty or regularizer term to get
θˆ = argmin
θ∈Θ
r(θ) + λC(θ) (14.5)
where λ ≥ 0 controls the degree of regularization, and C(θ) is some complexity measure. If we use
log loss, and we define C(θ) = − log π0(θ), where π0(θ) is some prior distribution, and we use λ = 1,
we recover the MAP estimate
θˆ = argmax
θ∈Θ
log p(D|θ) + log π0(θ) (14.6)
This can be solved using standard optimization methods (see Chapter 6).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
14.1. INTRODUCTION
14.1.3 Model fitting using Bayes, VI, and generalized Bayes
Another way to prevent overfitting is to estimate a probability distribution over parameters, q(θ),
instead of a point estimate. That is, we can try to estimate the ERM in expectation:
qˆ = argmin
q∈P(Θ)
Eq(θ)
[r(θ)] (14.7)
If P(Θ) is the space of all probability distributions over parameters, then the solution will converge
to a delta function that puts all its probability on the MLE. Thus this approach, on its own, will
not prevent overfitting. However, we can regularize the problem by preventing the distribution from
moving too far from the prior. If we measure the divergence between q and the prior using KL
divergence, we get
qˆ = argmin
q∈P(Θ)
Eq(θ)
[r(θ)] + 1
λ
DKL (q k π0) (14.8)
The solution to this problem is known as the Gibbs posterior, and is given by the following:
qˆ(θ) = e
−λr(θ)π0(θ)
R
e−λr(θ′)π0(θ
′)dθ
′
(14.9)
This is widely used in the PAC-Bayes community (see e.g., [Alq21].
Now suppose we use log loss, and set λ = N, to get
qˆ(θ) = e
PN
n=1 log p(yn|xn,θ)π0(θ)
R
e
PN
n=1 log p(yn|xn,θ′)π0(θ
′)dθ
′
(14.10)
Then the resulting distribution is equivalent to the Bayes posterior:
qˆ(θ) = p(D|θ)π0(θ)
R
p(D|θ
′)π0(θ
′)dθ
′
(14.11)
Often computing the Bayes posterior is intractable. We can simplify the problem by restricting
attention to a limited family of distributions, Q(Θ) ⊂ P(Θ). This gives rise to the following objective:
qˆ = argmin
q∈Q(Θ)
Eq(θ)
[− log p(D|θ)] + DKL (q k π0) (14.12)
This is known as variational inference; see Chapter 10 for details.
We can generalize this by replacing the negative log likelihood with a general risk, r(θ). Furthermore,
we can replace the KL with a general divergence, D(q||π0), which we can weight using a general λ.
This gives rise to the following objective:
qˆ = argmin
q∈Q(Θ)
Eq(θ)
[r(θ)] + λD(q||π0) (14.13)
This is called generalized Bayesian inference [BHW16; KJD19; KJD21].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license572
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
14.2 Evaluating predictive models
In this section we discuss how to evaluate the quality of a trained discriminative model.
14.2.1 Proper scoring rules
It is common to measure performance of a predictive model using a proper scoring rule [GR07a],
which is defined as follows. Let S(pθ,(y, x)) be the score for predictive distribution pθ(y|x) when
given an event y|x ∼ p
∗
(y|x), where p
∗
is the true conditional distribution. (If we want to evaluate
a Bayesian model, where we marginalize out θ rather than condition on it, we just replace pθ(y|x)
with p(y|x) = R
pθ(y|x)p(θ|D)dθ.) The expected score is defined by
S(pθ, p∗
) = Z
p
∗
(x)p
∗
(y|x)S(pθ,(y, x))dydx (14.14)
A proper scoring rule is one where S(pθ, p∗
) ≤ S(p
∗
, p∗
), with equality iff pθ(y|x) = p
∗
(y|x). Thus
maximizing such a proper scoring rule will force the model to match the true probabilities.
The log-likelihood, S(pθ,(y, x)) = log pθ(y|x), is a proper scoring rule. This follows from Gibbs
inequality:
S(pθ, p∗
) = Ep∗(x)p∗(y|x)
[log pθ(y|x)] ≤ Ep∗(x)p∗(y|x)
[log p
∗
(y|x)] (14.15)
Therefore minimizing the NLL (aka log loss) should result in well-calibrated probabilities. However,
in practice, log-loss can over-emphasize tail probabilities [QC+06].
A common alternative is to use the Brier score [Bri50], which is defined as follows:
S(pθ,(y, x)) ,
1
C
X
C
c=1
(pθ(y = c|x) − I(y = c))2
(14.16)
This is just the squared error of the predictive distribution p = p(1 : C|x) compared to the one-hot
label distribution y. Since it based on squared error, the Brier score is less sensitive to extremely
rare or extremely common classes. The Brier score is also a proper scoring rule.
14.2.2 Calibration
A model whose predicted probabilities match the empirical frequencies is said to be calibrated
[Daw82; NMC05; Guo+17]. For example, if a classifier predicts p(y = c|x) = 0.9, then we expect this
to be the true label about 90% of the time. A well-calibrated model is useful to avoid making the
wrong decision when the outcome is too uncertain. In the sections below, we discuss some ways to
measure and improve calibration.
14.2.2.1 Expected calibration error
To assess calibration, we divide the predicted probabilities into a finite set of bins or buckets, and then
assess the discrepancy between the empirical probability and the predicted probability by counting.
More precisely, suppose we have B bins. Let Bb be the set of indices of samples whose prediction
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
14.2. EVALUATING PREDICTIVE MODELS
0.0 0.2 0.4 0.6 0.8 1.0
0.0
0.2
0.4
0.6
0.8
1.0
Accuracy
ECE=12.67
Uncal. - CIFAR-100
ResNet-110 (SD)
Outputs
Gap
0.0 0.2 0.4 0.6 0.8 1.0
ECE=0.96
Temp. Scale - CIFAR-100
ResNet-110 (SD)
Outputs
Gap
0.0 0.2 0.4 0.6 0.8 1.0
ECE=2.46
Hist. Bin. - CIFAR-100
ResNet-110 (SD)
Outputs
Gap
0.0 0.2 0.4 0.6 0.8 1.0
ECE=4.16
Iso. Reg. - CIFAR-100
ResNet-110 (SD)
Outputs
Gap
Confidence
Figure 14.1: Reliability diagrams for the ResNet CNN image classifier [He+16b] applied to CIFAR-100
dataset. ECE is the expected calibration error, and measures the size of the red gap. Methods from left to
right: original probabilities; after temperature scaling; after histogram binning; after isotonic regression. From
Figure 4 of [Guo+17]. Used with kind permission of Chuan Guo.
confidence falls into the interval Ib = ( b−1
B
,
b
B
]. Here we use uniform bin widths, but we could also
define the bins so that we can get an equal number of samples in each one.
Let f(x)c = p(y = c|x), yˆn = argmaxc∈{1,...,C} f(xn)c, and pˆn = maxc∈{1,...,C} f(xn)c. The
accuracy within bin b is defined as
acc(Bb) = 1
|Bb|
X
n∈Bb
I(ˆyn = yn) (14.17)
The average confidence within this bin is defined as
conf(Bb) = 1
|Bb|
X
n∈Bb
pˆn (14.18)
If we plot accuracy vs confidence, we get a reliability diagram, as shown in Figure 14.1. The
gap between the accuracy and confidence is shown in the red bars. We can measure this using the
expected calibration error (ECE) [NCH15]:
ECE(f) =
X
B
b=1
|Bb|
B
|acc(Bb) − conf(Bb)| (14.19)
In the multiclass case, the ECE only looks at the error of the MAP (top label) prediction. We
can extend the metric to look at all the classes using the marginal calibration error, proposed in
[KLM19]:
MCE =
X
C
c=1
wcE

(p(Y = c|f(x)c) − f(x)c)
2

(14.20)
=
X
C
c=1
wc
X
B
b=1
|Bb,c|
B
(acc(Bb,c) − conf(Bb,c))2
(14.21)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license574
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where Bb,c is the b’th bin for class c, and wc ∈ [0, 1] denotes the importance of class c. (We can set
wc = 1/C if all classes are equally important.) In [Nix+19], they call this metric static calibration
error; they show that certain methods that have good ECE may have poor MCE. Other multi-class
calibration metrics are discussed in [WLZ19].
14.2.2.2 Improving calibration
In principle, training a classifier so it optimizes a proper scoring rule (such as NLL) should auto￾matically result in a well-calibrated classifier. In practice, however, unbalanced datasets can result
in poorly calibrated predictions. Below we discuss various ways for improving the calibration of
probabilistic classifiers, following [Guo+17].
14.2.2.3 Platt scaling
Let z be the log-odds, or logit, and p = σ(z), produced by a probabilistic binary classifier. We wish
to convert this to a more calibrated value q. The simplest way to do this is known as Platt scaling,
and was proposed in [Pla00]. The idea is to compute q = σ(az + b), where a and b are estimated via
maximum likelihood on a validation set.
In the multiclass case, we can extend Platt scaling by using matrix scaling: q = softmax(Wz + b),
where we estimate W and b via maximum likelihood on a validation set. Since W has K × K
parameters, where K is the number of classes, this method can easily overfit, so in practice we restrict
W to be diagonal.
14.2.2.4 Nonparametric (histogram) methods
Platt scaling makes a strong assumption about how the shape of the calibration curve. A more
flexible, nonparametric, method is to partion the predicted probabilities into bins, pm, and to
estimate an empirical probability qm for each such bin; we then replace pm with qm; this is known
as histogram binning [ZE01a]. We can regularize this method by requiring that q = f(p) be a
piecewise constant, monotonically non-decreasing function; this is known as isotonic regression
[ZE01a]. An alternative approach, known as the scaling-binning calibrator, is to apply a scaling
method (such as Platt scaling), and then to apply histogram binning to that. This has the advantage
of using the average of the scaled probabilities in each bin instead of the average of the observed
binary labels (see Figure 14.2). In [KLM19], they prove that this results in better calibration, due to
the lower variance of the estimator.
In the multiclass case, z is the vector of logits, and p = softmax(z) is the vector of probabilities.
We wish to convert this to a better calibrated version, q. [ZE01b] propose to extend histogram
binning and isotonic regression to this case by applying the above binary method to each of the K
one-vs-rest problems, where K is the number of classes. However, this requires K separate calibration
models, and results in an unnormalized probability distribution.
14.2.2.5 Temperature scaling
In [Guo+17], they noticed empirically that the diagonal version of Platt scaling, when applied to
a variety of DNNs, often ended learning a vector of the form w = (c, c, . . . , c), for some constant c.
This suggests a simpler form of scaling, which they call temperature scaling: q = softmax(z/T),
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
14.2. EVALUATING PREDICTIVE MODELS
Figure 14.2: Visualization of 3 different approaches to calibrating a binary probabilistic classifier. Black crosses
are the observed binary labels, red lines are the calibrated outputs. (a) Platt scaling. (b) Histogram binning
with 3 bins. The output in each bin is the average of the binary labels in each bin. (c) The scaling-binning
calibrator. This first applies Platt scaling, and then computes the average of the scaled points (gray circles) in
each bin. From Figure 1 of [KLM19]. Used with kind permission of Ananya Kumar.
0.0
0.2
0.4
0.6
0.8
1.0
T = 100
0.0
0.2
0.4
0.6
0.8
1.0
T = 2
0.0
0.2
0.4
0.6
0.8
1.0
T = 1
Figure 14.3: Softmax distribution softmax(a/T), where a = (3, 0, 1), at temperatures of T = 100, T = 2
and T = 1. When the temperature is high (left), the distribution is uniform, whereas when the temperature
is low (right), the distribution is “spiky”, with most of its mass on the largest element. Generated by
softmax_plot.ipynb.
where T > 0 is a temperature parameter, which can be estimated by maximum likelihood on the
validation set. The effect of this temperature parameter is to make the distribution less peaky, as
shown in Figure 14.3. [Guo+17] show empirically that this method produces the lowest ECE on a
variety of DNN classification problems (see Figure 14.1 for a visualization). Furthermore, it is much
simpler and faster than the other methods.
Note that Platt scaling and temperature scaling do not affect the identity of the most probable
class label, so these methods have no impact on classification accuracy. However, they do improve
calibration performance. A more recent multi-class calibration method is discussed in [Kul+19].
14.2.2.6 Label smoothing
When training classifiers, we usually represent the true target label as a one-hot vector, say y = (0, 1, 0)
to represent class 2 out of 3. We can improve results if we “spread” some of the probability mass
across all the bins. For example we may use y = (0.1, 0.8, 0.1). This is called label smoothing and
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license576
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
often results in better-calibrated models [MKH19].
14.2.2.7 Bayesian methods
Bayesian approaches to fitting classifiers often result in more calibrated predictions, since they
represent uncertainty in the parameters. See Section 17.3.8 for an example. However, [Ova+19]
shows that well-calibrated models (even Bayesian ones) often become mis-calibrated when applied to
inputs that come from a different distribution (see Section 19.2 for details).
14.2.3 Beyond evaluating marginal probabilities
Calibration (Section 14.2.2) focuses on assessing properties of the marginal predictive distribution
p(y|x). But this can sometimes be insufficient to distinguish between a good and bad model, especially
in the context of online learning and sequential decision making, as pointed out in [Lu+22; Osb+21;
WSG21; KKG22]. For example, consider two learning agents who observe a sequence of coin tosses.
Let the outcome at time t be Yt ∼ Ber(θ), where θ is the unknown parameter. Agent 1 believes
θ = 2/3, whereas agent 2 believes either θ = 0 or θ = 1, but is not sure which, and puts probabilities
1/3 and 2/3 on these events. Thus both agents, despite having different models, make identical
predictions for the next outcome: p(Y
i
1 = 0) = 1/3 for agents i = 1, 2. However, the predictions of
the two agents about a sequence of τ future outcomes is very different: In particular, agent 1 predicts
each individual coin toss is a random Bernoulli event, where the probability is due to irreducible
noise or aleatoric uncertainty:
p(Y
1
1 = 0, . . . , Y 1
τ = 0) = 1
3
τ
(14.22)
By contrast, agent 2 predicts that the sequence will either be all heads or all tails, where the
probability is induced by epistemic uncertainty about the true parameters:
p(Y
2
1 = y1, . . . , Y 2
τ = yτ ) =



1/3 if y1 = · · · = yτ = 0
2/3 if y1 = · · · = yτ = 1
0 otherwise
(14.23)
The difference in beliefs between these agents will impact their behavior. For example, in a casino,
agent 1 incurs little risk on repeatedly betting on heads in the long run, but for agent 2, this would
be a very unwise strategy, and some initial information gathering (exploration) would be worthwhile.
Based on the above, we see that it is useful to evaluate joint predictive distributions when assessing
predictive models. In [Lu+22; Osb+21] they propose to evaluate the posterior predictive distributions
over τ outcomes y = YT +1:T +τ , given a set of τ inputs x = XT:T +τ−1, and the past T data samples,
DT = {(Xt, Yt+1) : t = 0, 1, . . . , T − 1}. The Bayes optimal predictive distribution is
P
B
T = p(y|x, DT ) (14.24)
This is usually intractable to compute. Instead the agent will use an approximate distribution, known
as a belief state, which we denote by
QT = p(y|x, DT ) (14.25)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
14.2. EVALUATING PREDICTIVE MODELS
The natural performance metric is the KL between these distributions. Since this depend on the
inputs x and DT = (X0:T −1, Y1:T ), we will averaged the KL over these values, which are drawn iid
from the true data generating distribution, which we denote by
P(X, Y, E) = P(X|E)P(Y |X, E)P(E) (14.26)
where E is the true but unknown environment. Thus we define our metric as
d
KL
B,Q = EP (x,DT )

DKL ￾
P
B(y|x, DT ) k Q(y|x, DT )
 (14.27)
where
P(x, DT , E) = P(E)
"
T
Y−1
t=0
P(Xt|E)P(Yt+1|Xt, E)
#
| {z }
P (DT |E)
"
T +
Yτ−1
t=T
P(xt|E)
#
| {z }
P (x|E)
(14.28)
and P(x, DT ) marginalizes this over environments.
Unfortunately, it is usually intractable to compute the exact Bayes posterior, P
B
T
, so we cannot
evaluate d
KL
B,Q. However, in Section 14.2.3.1, we show that
d
KL
B,Q = d
KL
E,Q − I(E; y|DT , x) (14.29)
where the second term is a constant wrt the agent, and the first term is given by
d
KL
E,Q = EP (x,DT ,E)
[DKL (P(y|x, E) k Q(y|x, DT ))] (14.30)
= EP (y|x,E)P (x,DT ,E)

log P(y|x, E)
Q(y|x, DT )

(14.31)
Hence if we rank agents in terms of d
KL
E,Q, it will give the same results as ranking them by d
KL
B,Q.
To compute d
KL
E,Q in practice, we can use a Monte Carlo approximation: we just have to sample
J environments, E
j ∼ P(E), sample a training set DT from each environment, D
j
T ∼ P(DT |Ej
),
and then sample N data vectors of length τ , (x
j
n
, y
j
n
) ∼ P(XT:T +τ−1, YT +1:T +τ |Ej
). We can then
compute
ˆd
KL
E,Q =
1
JN
X
J
j=1
X
N
n=1
h
log P(y
j
n
|x
j
n
, E
j
) − log Q(y
j
n
|x
j
n
, D
j
T
)
i
(14.32)
where
pjn = P(y
j
n
|x
j
n
, E
j
) =
T +
Yτ−1
t=T
P(Y
j
n,t+1|X
j
n,t, E
j
) (14.33)
qjn = Q(y
j
n
|x
j
n
, D
j
T
) = Z
Q(y
j
n
|x
j
n
, θ)Q(θ|Dj
T
)dθ (14.34)
≈
1
M
X
M
m=1
T +
Yτ−1
t=T
Q(Y
j
n,t+1|X
j
n,t, θ
j
m) (14.35)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens578
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where θ
j
m ∼ Q(θ|Dj
T
) is a sample from the agent’s posterior over the environment.
The above assumes that P(Y |X) is known; this will be the case if we use a synthetic data generator,
as in the “neural testbed” in [Osb+21]. If we just have an J empirical distributions for P
j
(X, Y ), we
can replace the KL with the cross entropy, which only differs by an additive constant:
d
KL
E,Q = EP (x,DT ,E)
[DKL (P(y|x, E) k Q(y|x, DT ))] (14.36)
= EP (x,y,E)
[log P(y|x, E)]
| {z }
const
− EP (x,y,DT |E)P (E)
[log Q(y|x, DT )]
| {z }
dCE
E,Q
(14.37)
where the latter term is just the empirical negative log likelihood (NLL) of the agent on samples
from the environment. Hence if we rank agents in terms of their NLL or cross entropy d
CE
E,Q we will
get the same results as ranking them by d
KL
E,Q, which will in turn give the same results as ranking
them by d
KL
B,Q.
In practice we can approximate the cross entropy as follows:
ˆd
CE
E,Q = −
1
JN
X
J
j=1
X
N
n=1
log Q(y
j
n
|x
j
n
, D
j
T
) (14.38)
where D
j
T ∼ P
j
, and (x
j
n
, y
j
n
) ∼ P
j
.
An alternative to estimating the KL or NLL is to evaluate the joint predictive accuracy by using it
in a downstream task. In [Osb+21], they show that good predictive accuracy (for τ > 1) correlates
with good performance on a bandit problem (see Section 34.4). In [WSG21] they show that good
predictive accuracy (for τ > 1) results in good performance on a transductive active learning task.
14.2.3.1 Proof of claim
We now prove Equation (14.29), based on [Lu+21a]. First note that
d
KL
E,Q = EP (x,DT ,E)P (y|x,E)

log P(y|x, E)
Q(y|x, DT )

(14.39)
= E

log P(y|x, DT )
Q(y|x, DT )

+ E

log P(y|x, E)
P(y|x, DT )

(14.40)
For the first term in Equation (14.40) we have
E

log P(y|x, DT )
Q(y|x, DT )

=
XP(x, y, DT ) log P(y|x, DT )
Q(y|x, DT )
(14.41)
=
XP(x, DT )
XP(y|x, DT ) log P(y|x, DT )
Q(y|x, DT )
(14.42)
= EP (x,DT )
[DKL (P(y|x, DT ) k Q(y|x, DT ))] = d
KL
B,Q (14.43)
We now show that the second term in Equation (14.40) reduces to the mutual information. We
exploit the fact that
P(y|x, E) = P(y|DT , x, E) = P(E, y|DT , x)
P(E|DT , x)
(14.44)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
14.3. CONFORMAL PREDICTION
Figure 14.4: Prediction set examples on Imagenet. We show three progressively more difficult examples of the
class fox squirrel and the prediction sets generated by conformal prediction. (Compare to Figure 17.9.) From
Figure 1 of [AB21]. Used with kind permission of Anastasios Angelopoulos.
since DT has no new information in beyond E. From this we get
E

log P(y|x, E)
P(y|x, DT )

= E

log P(E, y|DT , x)/P(E|DT , x)
P(y|D, DT )

(14.45)
=
XP(DT , x)
XP(E, y|DT , x) log P(E, y|DT , x)
P(y|DT , x)P(E|DT , x)
(14.46)
= I(E; y|DT , x) (14.47)
Hence
d
KL
E,Q = d
KL
B,Q + I(E; y|DT , x) (14.48)
as claimed.
14.3 Conformal prediction
In this section, we briefly discuss conformal prediction [VGS05; SV08; ZFV20; AB21; KSB21;
Man22b]. This is a simple but effective way to create prediction intervals or sets with guaranteed
frequentist coverage probability from any predictive method p(y|x). This can be seen as a form
of distribution free uncertainty quantification, since it works without making assumptions
(beyond exchangeability of the data) about the true data generating process or the form of the
model.1 Our presentation is based on the excellent tutorial of [AB21].2
In conformal prediction, we start with some heuristic notion of uncertainty — such as the softmax
score for a classification problem, or the variance for a regression problem — and we use it to define
a conformal score s(x, y) ∈ R, which measures how badly the output y “conforms” to x. (Large
1. The exchangeability assumption rules out time series data, which is serially correlated. However, extensions to
conformal prediction have been developed for the time series case, see e.g., [Zaf+22]. The exchangeability assumption
also rules out distribution shift, although this has also been partially addressed.
2. See also the easy-to-use MAPIE Python library at https://mapie.readthedocs.io/en/latest/index.html, and
the list of papers at [Man22a].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license580
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
values of the score are less likely, so it is better to think of it as a non-conformity score.) Next we
apply this score to a calibration set of n labeled examples, that was not used to train f, to get
S = {si = s(xi
, yi) : i = 1 : n}.
3 The user specifies a desired confidence threshold α, say 0.1, and we
then compute the (1 − α) quantile qˆ of S. (In fact, we should replace 1 − α with ⌈(n+1)(1−α)⌉
n
, to
account for the finite size of S.) Finally, given a new test input, xn+1, we compute the prediction set
to be
T (xn+1) = {y : s(xn+1, y) ≤ qˆ} (14.49)
Intuitively, we include all the outputs y that are plausible given the input. See Figure 14.4 for an
illustration.
Remarkably, one can show the following general result
1 − α ≤ P
∗
(y
n+1 ∈ T (xn+1)) ≤ 1 − α +
1
n + 1
(14.50)
where the probability is wrt the true distribution P
∗
(xn+1, yn+1). We say that the prediction set has
a coverage level of 1 − α. This holds for any value of n ≥ 1 and α ∈ [0, 1]. The only assumption is
that the values (xi
, yi) are exchangeable, and hence the calibration scores si are also exchangeable.
To see why this is true, let us sort the scores so s1 < · · · sn, so qˆ = si
, where i =
⌈(n+1)(1−α)⌉
n
. (We
assume the scores are distinct, for simplicity.) The score sn+1 is equally likely to fall in anywhere
between the calibration points s1, . . . , sn, since the points are exchangeable. Hence
P
∗
(sn+1 ≤ sk) = k
n + 1
(14.51)
for any k ∈ {1, . . . , n + 1}. The event {yn+1 ∈ T (xn+1)} is equivalent to {sn+1 ≤ qˆ}. Hence
P
∗
(yn+1 ∈ T (xn+1)) = P
∗
(sn+1 ≤ qˆ) = ⌈(n + 1)(1 − α)⌉
n + 1
≥ 1 − α (14.52)
For the proof of the upper bound, see [Lei+18].
Although this result may seem like a “free lunch”, it is worth noting that we can always achieve
a desired coverage level by defining the prediction set to be all possible labels. In this case, the
prediction set will be independent of the input, but it will cover the true label 1 − α of the time. To
rule out some degenerate cases, we seek prediction sets that are as small as possible (although we
allow for the set to be larger for harder examples), while meeting the coverage requirement. Achieving
this goal requires that we define suitable conformal scores. Below we give some examples of how
to compute conformal scores s(x, y) for different kinds of problem.4
It is also important to note
that the coverage guarantees are frequentist in nature, and refer to average behavior, rather than
representing per-instance uncertainty, as in the Bayesian approach.
3. Using a calibration set is called split conformal prediction. If we don’t have enough data to adopt this
splitting approach, we can use full conformal prediction [VGS05], which requires fitting the model n times using a
leave-one-out type procedure.
4. It is also possible to learn conformal scores in an end-to-end way, jointly with the predictive model, as discussed in
[Stu+22].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
14.3. CONFORMAL PREDICTION
(a) (b) (c)
Figure 14.5: (a) Illusration of adaptive prediction set. From Figure 5 of [AB21]. Used with kind permission
of Anastasios Angelopoulos. (b) Illustrate of conformalized quantile regression. From Figure 6 of [AB21].
Used with kind permission of Anastasios Angelopoulos. (c) Illustration of pinball loss function.
14.3.1 Conformalizing classification
The simplest way to apply conformal prediction to multiclass classification is to derive the conformal
score from the softmax score assigned to the label using s(x, y) = 1 − f(x)y, so large values are
considered less likely than small values. We compute the threshold qˆ as described above, and then we
define the prediction set to be T (x) = {y : f(x)y ≥ 1 − qˆ}, which matches Equation (14.49). That is,
we take the set of all class labels above the specified threshold, as illustrated in Figure 14.4.
Although the above approach produces prediction sets with the smallest average size (as proved in
[SLW19]), the size of the set tends to be too large for easy examples and too small for hard examples.
We now present an improved method, known as adaptive prediction sets, due to [RSC20], which
solves this problem. The idea is simple: we sort all the softmax scores, f(x)c for c = 1 : C, to get
permutation π1:C , and then we define s(x, y) to be the cumulative sum of the scores up until we
reach label y: s(x, y) = Pk
c=1 f(x)πj
, where k = πy. We now compute qˆ as before, and define the
prediction set T (x) to be the set of all labels, sorted in order of decreasing probability, until we
cover qˆ of the probability mass. See Figure 14.5a for an illustration. This uses all the softmax scores
output by the model, rather than just the top score, which accounts for its improved performance.
14.3.2 Conformalizing regression
In this section, we consider conformalized regression problems. Since now y ∈ R, computing the
prediction set in Equation (14.49) is expensive, so instead we will compute a prediction interval,
specified by a lower and upper bound.
14.3.2.1 Conformalizing quantile regression
In this section, we use quantile regression to compute the lower and upper bounds. We first fit a
function of the form tγ(x), which predicts the γ quantile of the cdf PY (Y ) = p(Y |x). For example, if
we set γ = 0.5, we get the median. If we use γ = 0.05 and γ = 0.95, we can get an approximate 90%
prediction interval using [t0.05(x), t0.95(x)], as illustrated by the gray lines in Figure 14.5b.
To fit the quantile regression model, we just replace squared loss with the quantile loss, also
called the pinball loss, which is defined as
ℓγ(y,tˆ) = (γ − I
￾
y < tˆ

)(y − tˆ) = (y − tˆ)γI
￾
y > tˆ

+ (tˆ− y)(1 − γ)I
￾
y < tˆ

(14.53)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND lice582
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where y is the true output and tˆ is the predicted value at quantile γ. See Figure 14.5c for an
illustration. They key property of this loss function is that its minimizer is the γ-quantile of the
distribution PY , i.e.,
argmin
tˆ
EpY (y)

ℓγ(y,tˆ)

= P
−1
Y
(γ)
However, the regression quantiles are usually only approximately a 90% interval because the model
may be mismatched to the true distribution. However we can use conformal prediction to fix this. In
particular, let us define the conformal score to be
s(x, y) = max ￾
tˆα/2(x) − y, y − tˆα/2(x)

(14.54)
In other words, s(x, y) is a positive measure of how far the value y is outside the prediction interval,
or is a negative measure if y is inside the prediction interval. We compute qˆ as before, and define the
conformal prediction interval to be
T (x) = [tˆα/2(x) − q, ˆ tˆα/2(x) + ˆq] (14.55)
This makes the quantile regression interval wider if qˆ is positive (if the base method was overconfident),
and narrower if qˆ is negative (if the base method was underconfident). See Figure 14.5b for an
illustration. This approach is called conformalized quantile regression or CQR [RPC19].
14.3.2.2 Conformalizing predicted variances
There are many ways to define uncertainty scores u(x), such as the predicted standard deviation,
from which we can derive a prediction interval using
T (x) = [f(x) − u(x)ˆq, f(x) + u(x)ˆq] (14.56)
Here qˆ is derived from the quantiles of the following conformal scores
s(x, y) = |y − f(x)|
u(x)
(14.57)
The interval produced by this method tends to be wider than the one computed by CQR, since it
extends an equal amount above and below the predicted value f(x). In addition, the uncertainty
measure u(x) may not scale properly with α. Nevertheless, this is a simple post-hoc method that
can be applied to many regression methods without needing to retrain them.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20215 Generalized linear models
15.1 Introduction
A generalized linear model or GLM [MN89] is a conditional version of an exponential family
distribution (Section 2.4). More precisely, the model has the following form:
p(yn|xn, w, σ2
) = exp 
ynηn − A(ηn)
σ
2
+ log h(yn, σ2
)

(15.1)
where ηn = wTxn is the natural parameter for the distribution, A(ηn) is the log normalizer, T (y) = y
is the sufficient statistic, and σ
2
is the dispersion term. Based on the results in Section 2.4.3, we can
show that the mean and variance of the response variable are as follows:
µn , E

yn|xn, w, σ2

= A
′
(ηn) , ℓ
−1
(ηn) (15.2)
V

yn|xn, w, σ2

= A
′′(ηn) σ
2
(15.3)
We will denote the mapping from the linear inputs to the mean of the output using µn = ℓ
−1
(ηn),
where the function ℓ is known as the link function, and ℓ
−1
is known as the mean function. This
relationship is usually written as follows:
ℓ(µn) = ηn = wTxn (15.4)
GLMs are quite limited in their predictive power, due to the assumption of linearity (although
we can always use basis function expansion on xn to improve the flexibility). However, the main
use of GLMs in the statistics literature is not for prediction, but for hypothesis testing, as we
explain in Section 3.10.3. This relies on the ability to compute the posterior, p(w|D), which we
discuss in Section 15.1.4. We can use this to draw conclusions about whether any of the inputs (e.g.,
representing different groups) have a significant effect on the output.
15.1.1 Some popular GLMs
In this section, we give some examples of widely used GLMs.
15.1.1.1 Linear regression
Recall that linear regression has the form
p(yn|xn, w, σ2
) = 1
√
2πσ2
exp(−
1
2σ
2
(yn − wTxn)
2
) (15.5)584
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Hence
log p(yn|xn, w, σ
2
) = −
1
2σ
2
(yn − ηn)
2 −
1
2
log(2πσ2
) (15.6)
where ηn = wTxn. We can write this in GLM form as follows:
log p(yn|xn, w, σ2
) = ynηn −
η
2
n
2
σ
2
−
1
2

y
2
n
σ
2
+ log(2πσ2
)

(15.7)
We see that A(ηn) = η
2
n/2 and hence
E [yn] = ηn = wTxn (15.8)
V [yn] = σ
2
(15.9)
See Section 15.2 for details on linear regression.
15.1.1.2 Binomial regression
If the response variable is the number of successes in Nn trials, yn ∈ {0, . . . , Nn}, we can use
binomial regression, which is defined by
p(yn|xn, Nn, w) = Bin(yn|σ(wTxn), Nn) (15.10)
We see that binary logistic regression is the special case when Nn = 1.
The log pdf is given by
log p(yn|xn, Nn, w) = yn log µn + (Nn − yn) log(1 − µn) + log 
Nn
yn

(15.11)
= yn log( µn
1 − µn
) + Nn log(1 − µn) + log 
Nn
yn

(15.12)
where µn = σ(ηn). To rewrite this in GLM form, let us define
ηn , log 
µn
(1 − µn)

= log "
1
1 + e−wTxn
1 + e
−wTxn
e−wTxn
#
= log 1
e−wTxn
= wTxn (15.13)
Hence we can write binomial regression in GLM form as follows
log p(yn|xn, Nn, w) = ynηn − A(ηn) + h(yn) (15.14)
where h(yn) = log 
Nn
yn

and
A(ηn) = −Nn log(1 − µn) = Nn log(1 + e
ηn ) (15.15)
Hence
E [yn] = dA
dηn
=
Nne
ηn
1 + e
ηn
=
Nn
1 + e−ηn
= Nnµn (15.16)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.1. INTRODUCTION
and
V [yn] = d
2A
dη2
n
= Nnµn(1 − µn) (15.17)
See Section 15.3.9 for an example of binomial regression.
15.1.1.3 Poisson regression
If the response variable is an integer count, yn ∈ {0, 1, . . .}, we can use Poisson regression, which
is defined by
p(yn|xn, w) = Poi(yn| exp(wTxn)) (15.18)
where
Poi(y|µ) = e
−µ µ
y
y!
(15.19)
is the Poisson distribution. Poisson regression is widely used in bio-statistical applications, where
yn might represent the number of diseases of a given person or place, or the number of reads at a
genomic location in a high-throughput sequencing context (see e.g., [Kua+09]).
The log pdf is given by
log p(yn|xn, w) = yn log µn − µn − log(yn!) (15.20)
where µn = exp(wTxn). Hence in GLM form we have
log p(yn|xn, w) = ynηn − A(ηn) + h(yn) (15.21)
where ηn = log(µn) = wTxn, A(ηn) = µn = e
ηn , and h(yn) = − log(yn!). Hence
E [yn] = dA
dηn
= e
ηn = µn (15.22)
and
V [yn] = d
2A
dη2
n
= e
ηn = µn (15.23)
15.1.1.4 Zero-inflated Poisson regression
In many forms of count data, the number of observed 0s is larger than what a model might expect,
even after taking into account the predictors. Intuitively, this is because there may be many ways
to produce no outcome. For example, consider predicting sales data for a product. If the sales are
0, does it mean the product is unpopular (so the demand is very low), or was it simply sold out
(implying the demand is high, but supply is zero)? Similar problems arise in genomics, epidemiology,
etc.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license586
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
To handle such situations, it is common to use a zero-inflated Poisson or ZIP model. The
likelihood for this model is a mixture of two distributions: a spike at 0, and a standard Poisson.
Formally, we define
ZIP(y|ρ, λ) = (
ρ + (1 − ρ) exp(−λ) if y = 0
(1 − ρ)
λ
y
exp(−λ)
y!
if y > 0
(15.24)
Here ρ is the prior probability of picking the spike, and λ is the rate of the Poisson. We see that
there are two “mechanisms” for generating a 0: either (with probability ρ) we choose the spike, or
(with probability 1 − ρ) we simply generate a zero count just because the rate of the Poisson is so
low. (This latter event has probability λ
0
e
−λ/0! = e
−λ
.)
15.1.2 GLMs with noncanonical link functions
We have seen how the mean parameters of the output distribution are given by µ = ℓ
−1
(η), where
the function ℓ is the link function. There are several choices for this function, as we now discuss.
The canonical link function ℓ satisfies the property that θ = ℓ(µ), where θ are the canonical
(natural) parameters. Hence
θ = ℓ(µ) = ℓ(ℓ
−1
(η)) = η (15.25)
This is what we have assumed so far. For example, for the Bernoulli distribution, the canonical
parameter is the log-odds η = log(µ/(1 − µ)), which is given by the logit transform
η = ℓ(µ) = logit(µ) = log 
µ
1 − µ

(15.26)
The inverse of this is the sigmoid or logistic funciton
µ = ℓ
−1
(η) = σ(η) = 1/(1 + e
−η
) (15.27)
However, we are free to use other kinds of link function. For example, in Section 15.4 we use
η = ℓ(µ) = Φ−1
(µ) (15.28)
µ = ℓ
−1
(η) = Φ(η) (15.29)
This is known as the probit link function.
Another link function that is sometimes used for binary responses is the complementary log-log
function
η = ℓ(µ) = log(− log(1 − µ)) (15.30)
This is used in applications where we either observe 0 events (denoted by y = 0) or one or more
(denoted by y = 1), where events are assumed to be governed by a Poisson distribution with rate λ.
Let E be the number of events. The Poisson assumption means p(E = 0) = exp(−λ) and hence
p(y = 0) = (1 − µ) = p(E = 0) = exp(−λ) (15.31)
Thus λ = − log(1 − µ). When λ is a function of covariates, we need to ensure it is positive, so we use
λ = e
η
, and hence
η = log(λ) = log(− log(1 − µ)) (15.32)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.1. INTRODUCTION
15.1.3 Maximum likelihood estimation
GLMs can be fit using similar methods to those that we used to fit logistic regression. In particular,
the negative log-likelihood has the following form (ignoring constant terms):
NLL(w) = − log p(D|w) = −
1
σ
2
X
N
n=1
ℓn (15.33)
where
ℓn , ηnyn − A(ηn) (15.34)
where ηn = wTxn. For notational simplicity, we will assume σ
2 = 1.
We can compute the gradient for a single term as follows:
gn ,
∂ℓn
∂w
=
∂ℓn
∂ηn
∂ηn
∂w
= (yn − A
′
(ηn))xn = (yn − µn)xn (15.35)
where µn = f(wTxn), and f is the inverse link function that maps from canonical parameters to
mean parameters. (For example, in the case of logistic regression, we have µn = σ(wTx).)
The Hessian is given by
H =
∂
2
∂w∂wT
NLL(w) = −
X
N
n=1
∂gn
∂wT
(15.36)
where
∂gn
∂wT
=
∂gn
∂µn
∂µn
∂wT
= −xnf
′
(wTxn)x
T
n
(15.37)
Hence
H =
X
N
n=1
f
′
(ηn)xnx
T
n
(15.38)
For example, in the case of logistic regression, f(ηn) = σ(ηn) = µn, and f
′
(ηn) = µn(1 − µn). In
general, we see that the Hessian is positive definite, since f
′
(ηn) > 0; hence the negative log likelihood
is convex, so the MLE for a GLM is unique (assuming f(ηn) > 0 for all n).
For small datasets, we can use the iteratively reweighted least squares or IRLS algorithm,
which is a form of Newton’s method, to compute the MLE (see e.g., [Mur22, Sec 10.2.6]). For
large datsets, we can use SGD. (In practice it is often useful to combine SGD with methods that
automatically tune the step size, such as [Loi+21].)
15.1.4 Bayesian inference
Maximum likelihood estimation provides a point estimate of the parameters, but does not convey
any notion of uncertainty, which is important for hypothesis testing, as we explain in Section 3.10.3,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license588
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
as well as for avoiding overfitting. To compute the uncertainty, we will perform Bayesian inference of
the parameters. To do this, we we first need to specify a prior. Choosing a suitable prior depends on
the form of link function. For example, a “flat” or “uninformative” prior on the offset term α ∈ R will
not translate to an uninformative prior on the probability scale if we pass α through a sigmoid, as
we discuss in Section 15.3.4.
Once we have chosen the prior, we can compute the posterior using a variety of approximate
inference methods. For small datasets, HMC (Section 12.5) is the easiest to use, since you just need
to write down the log likelihood and log prior; we can then use autograd to compute derivatives
which can be passed to the HMC engine (see e.g., [BG13] for details).
There are many standard software packages for HMC analysis of (hierarchical) GLMs, such as
Bambi (https://github.com/bambinos/bambi), which is a Python wrapper on top of PyMC/Black￾JAX, RStanARM (https://cran.r-project.org/web/packages/rstanarm/index.html), which
is an R wrapper on top of Stan, and BRMS (https://cran.r-project.org/web/packages/brms/
index.html), which is another R wrapper on top of Stan. These libraries support a convenient
formula syntax, initially created in the R language, for compactly specifying the form of the model,
including possible interaction terms between the inputs.
For large datasets, HMC can be slow, since it is a full batch algorithm. In such settings, variational
Bayes (see e.g., [HOW11; TN13]), expectation propagation (see e.g., [KW18]), or more specialized
algorithms (e.g., [HAB17]) are the best choice.
15.2 Linear regression
Linear regression is the simplest case of a GLM, and refers to the following model:
p(y|x, θ) = N (y|w0 + wTx, σ2
) (15.39)
where θ = (w0, w, σ2
) are all the parameters of the model. (In statistics, the parameters w0 and w
are usually denoted by β0 and β.) We gave a detailed introduction to this model in the prequel to
this book, [Mur22]. In this section, we briefly discuss maximum likelihood estimation, and then focus
on a Bayesian analysis.
15.2.1 Ordinary least squares
From Equation (15.39), we can derive the negative log likelihood of the data as follows:
NLL(w, σ2
) = −
X
N
n=1
log "
1
2πσ2
1
2
exp 
−
1
2σ
2
(yn − wTxn)
2
#
(15.40)
=
1
2σ
2
X
N
n=1
(yn − yˆn)
2 +
N
2
log(2πσ2
) (15.41)
where we have defined the predicted response yˆn , wTxn. In [Mur22, Sec 11.2.2] we show that the
MLE is given by
wˆ mle = (XTX)
−1XTy (15.42)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.2. LINEAR REGRESSION
This is called the ordinary least squares (OLS) solution.
The MLE for the observation noise is given by
σˆ
2
mle = argmin
σ2
NLL(wˆ , σ2
) = 1
N
X
N
n=1
(yn − x
T
nwˆ )
2
(15.43)
This is just the mean squared error of the residuals, which is an intuitive result.
15.2.2 Conjugate priors
In this section, we derive the posterior for the parameters using a conjugate prior. We first consider
the case where just w is unknown (so the observation noise variance parameter σ
2
is fixed), and then
we consder the general case, where both σ
2 and w are unknown.
15.2.2.1 Noise variance is known
The conjugate prior for linear regression has the following form:
p(w) = N (w|
`w,
`
Σ) (15.44)
We often use `w= 0 as the prior mean and `
Σ= τ
2
ID as the prior covariance. (We assume the bias
term is included in the weight vector, but often use a much weaker prior for it, since we typically do
not want to regularize the overall mean level of the output.)
To derive the posterior, let us first rewrite the likelihood in terms of an MVN as follows:
ℓ(w) = p(D|w, σ2
) = Y
N
n=1
p(yn|wTx, σ2
) = N (y|Xw, σ2
IN ) (15.45)
where IN is the N × N identity matrix. We can then use Bayes’ rule for Gaussians (Equation (2.121))
to derive the posterior, which is as follows:
p(w|X, y, σ2
) ∝ N (w|
`w,
`
Σ)N (y|Xw, σ2
IN ) = N (w|
aw,
a
Σ) (15.46)
aw ,
a
Σ (
`
Σ
−1 `w +
1
σ
2 XTy) (15.47)
a
Σ , (
`
Σ
−1
+
1
σ
2 XTX)
−1
(15.48)
where aw is the posterior mean, and a
Σ is the posterior covariance.
Now suppose `w= 0 and `
Σ= τ
2
I. In this case, the posterior mean becomes
aw=
1
σ
2
a
Σ XTy = (σ
2
τ
2
I + XTX)
−1XTy (15.49)
If we define λ =
σ
2
τ
2 , we see this is equivalent to ridge regression, which optimizes
L(w) = RSS(w) + λ||w||2
(15.50)
where RSS is the residual sum of squares:
RSS(w) = 1
2
X
N
n=1
(yn − wTxn)
2 =
1
2
||Xw − y||
2
2 =
1
2
(Xw − y)
T
(Xw − y) (15.51)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license590
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.2.2.2 Noise variance is unknown
In this section, we assume w and σ
2 are both unknown. The likelihood is given by
ℓ(w, σ2
) = p(D|w, σ2
) ∝ (σ
2
)
−N/2
exp 
−
1
2σ
2
X
N
n=1
(yn − wTxn)
2
!
(15.52)
Since the regression weights now depend on σ
2
in the likelihood, the conjugate prior for w has the
form
p(w|σ
2
) = N (w|
`w, σ2 `
Σ) (15.53)
For the noise variance σ
2
, the conjugate prior is based on the inverse gamma distrbution, which has
the form
IG(σ
2
|
`a,
`
b) =
`
b
`a
Γ(`a)
(σ
2
)
−(`a+1) exp(−
`
b
σ
2
) (15.54)
(See Section 2.2.3.4 for more details.) Putting these two together, we find that the joint conjugate
prior is the normal inverse gamma distribution:
NIG(w, σ2
|
`w,
`
Σ,
`a,
`
b) , N (w|
`w, σ2 `
Σ)IG(σ
2
|
`a,
`
b) (15.55)
=
`
b
`a
(2π)D/2|
`
Σ |
1
2 Γ(`a)
(σ
2
)
−(`a+(D/2)+1)
× exp
"
−
(w−
`w)
T `
Σ
−1
(w−
`w) + 2 `
b
2σ
2
#
(15.56)
This results in the following posterior:
p(w, σ2
|D) = NIG(w, σ2
|
aw,
a
Σ,
aa,
a
b) (15.57)
aw =
a
Σ (
`
Σ
−1 `w +XTy) (15.58)
a
Σ = (`
Σ
−1
+XTX)
−1
(15.59)
aa =
`a +N/2 (15.60)
a
b =
`
b +
1
2

`w
T `
Σ
−1 `w +y
Ty−
aw
T a
Σ
−1 aw

(15.61)
The expressions for aw and a
Σ are similar to the case where σ
2
is known. The expression for aa is also
intuitive, since it just updates the counts. The expression for a
b can be interpreted as follows: it is
the prior sum of squares, `
b, plus the empirical sum of squares, y
Ty, plus a term due to the error in
the prior on w.
The posterior marginals are as follows. For the variance, we have
p(σ
2
|D) = Z
p(w|σ
2
, D)p(σ
2
|D)dw = IG(σ
2
|
aa,
a
b) (15.62)
For the regression weights, it can be shown that
p(w|D) = Z
p(w|σ
2
, D)p(σ
2
|D)dσ2 = T (w|
aw,
a
b
aa
a
Σ, 2
aa) (15.63)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.2. LINEAR REGRESSION
15.2.2.3 Posterior predictive distribution
In machine learning we usually care more about uncertainty (and accuracy) of our predictions, not
our parameter estimates. Fortunately, one can derive the posterior predictive distribution in closed
form. In particular, one can show that, given N′ new test inputs X˜ , we have
p(y˜|X˜ , D) = Z Z p(y˜|X˜ , w, σ2
)p(w, σ2
|D)dwdσ2
(15.64)
=
Z Z N (y˜|X˜ w, σ2
IN′ )NIG(w, σ2
|
aw,
a
Σ,
aa,
a
b)dwdσ2
(15.65)
= T (y˜|X˜ aw,
a
b
aa
(IN′ + X˜
a
Σ X˜ T
), 2
aa) (15.66)
The posterior predictive mean is equivalent to “normal” linear regression, but where we plug in
wˆ = E [w|D] instead of the MLE. The posterior predictive variance has two components: a
b/
aaIN′
due to the measurement noise, and a
b/
aaX˜
a
Σ X˜ T due to the uncertainty in w. This latter term varies
depending on how close the test inputs are to the training data. The results are similar to using a
Gaussian prior (with fixed σˆ
2
), except the predictive distribution is even wider, since we are taking
into account uncertainty about σ
2
.
15.2.3 Uninformative priors
A common criticism of Bayesian inference is the need to use a prior. This is sometimes thought to
“pollute” the inferences one makes from the data. We can minimize the effect of the prior by using an
uninformative prior, as we discussed in Section 3.5. Below we discuss various uninformative priors
for linear regression.
15.2.3.1 Jeffreys prior
From Section 3.5.3.1, we know that the Jeffreys prior for the location parameter has the form
p(w) ∝ 1, and from Section 3.5.3.2, we know that the Jeffreys prior for the scale factor has the
form p(σ) ∝ σ
−1
. We can emulate these priors using an improper NIG prior with `w= 0,
`
Σ= ∞I,
`a= −D/2 and `
b= 0. The corresponding posterior is given by
p(w, σ2
|D) = NIG(w, σ2
|
aw,
a
Σ,
aa,
a
b) (15.67)
aw = wˆ mle = (XTX)
−1XTy (15.68)
a
Σ = (XTX)
−1 , C (15.69)
aa =
ν
2
(15.70)
a
b =
s
2ν
2
(15.71)
s
2 ,
||y − yˆ||
2
ν
(15.72)
ν = N − D (15.73)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license592
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Hence the posterior distribution of the weights is given by
p(w|D) = T (w|wˆ , s
2C, ν) (15.74)
where wˆ is the MLE. The marginals for each weight therefore have the form
p(wd|D) = T (wd|wˆd, s2Cdd, ν) (15.75)
15.2.3.2 Connection to frequentist statistics
Interestingly, the posterior when using Jeffreys prior is formally equivalent to the frequentist
sampling distribution of the MLE, which has the form
p( ˆwd|D∗
) = T ( ˆwd|wd, s2Cdd, ν) (15.76)
where D∗ = (X, y
∗
) is hypothetical data generated from the true model given the fixed inputs X. In
books on frequentist statistics, this is more commonly written in the following equivalent way (see
e.g., [Ric95, p542]):
wˆd − wd
s
√
Cdd
∼ tN−D (15.77)
The sampling distribution is numerically the same as the posterior distribution in Equation (15.75)
because T (w|µ, σ2
, ν) = T (µ|w, σ2
, ν). However, it is semantically quite different, since the sampling
distribution does not condition on the observed data, but instead is based on hypothetical data
drawn from the model. See [BT73, p117] for more discussion of the equivalences between Bayesian
and frequentist analysis of simple linear models when using uninformative priors.
15.2.3.3 Zellner’s g-prior
It is often reasonable to assume an uninformative prior on σ
2
, since that is just a scalar that does not
have much influence on the results, but using an uninformative prior for w can be dangerous, since
the strength of the prior controls how well regularized the model is, as we know from ridge regression.
A common compromise is to use an NIG prior with `a= −D/2,
`
b= 0 (to ensure p(σ
2
) ∝ 1) and
`w= 0 and `
Σ= g(XTX)
−1
, where g > 0 plays a role analogous to 1/λ in ridge regression. This is
called Zellner’s g-prior [Zel86].1 We see that the prior covariance is proportional to (XTX)
−1
rather
than I; this ensures that the posterior is invariant to scaling of the inputs, e.g., due to a change in
the units of measurement [Min00a].
1. Note this prior is conditioned on the inputs X, but not the outputs y; this is totally valid in a conditional
(discriminative) model, where all calculations are conditioned on X, which is treated like a fixed constant input.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.2. LINEAR REGRESSION
35 40 45 50 55 60
weight
100
0
100
200
300
400
height
b ~ Normal(0, 10)
(a)
35 40 45 50 55 60
weight
100
0
100
200
300
400
height
b ~ LogNormal(0, 1)
embryo
worlds tallest man
(b)
30 40 50 60 70
weight
130
140
150
160
170
180
190
height
(c)
Figure 15.1: Linear regression for predicting height given weight, y ∼ N (α + βx, σ2
). (a) Prior predictive
samples using a Gaussian prior for β. (b) Prior predictive samples using a log-Gaussian prior for β. (c)
Posterior predictive samples using the log-Gaussian prior. The inner shaded band is the 95% credible
interval for µ, representing epistemic uncertainty. The outer shaded band is the 95% credible interval for the
observations y, which also adds data uncertainty due to σ. Adapted from Figures 4.5 and 4.10 of [McE20].
Generated by linreg_height_weight.ipynb.
With this prior, the posterior becomes
p(w, σ2
|g, D) = NIG(w, σ2
|wN , VN , aN , bN ) (15.78)
VN =
g
g + 1
(XT X)
−1
(15.79)
wN =
g
g + 1
wˆ mle (15.80)
aN = N/2 (15.81)
bN =
s
2
2
+
1
2(g + 1)wˆ
T
mleXT Xwˆ mle (15.82)
Various approaches have been proposed for setting g, including cross validation, empirical Bayes
[Min00a; GF00], hierarchical Bayes [Lia+08], etc.
15.2.4 Informative priors
In many problems, it is possible to use domain knowledge to come up with plausible priors. As an
example, we consider the problem of predicting the height of a person given their weight. We will
use a dataset collected from Kalahari foragers by the anthropologist Nancy Howell (this example is
from [McE20, p93]).
Let xi be the weight (in kg) and yi be height (in cm) of the i’th person, and let x be the mean of
the inputs. The observation model is given by
yi ∼ N (µi
, σ) (15.83)
µi = α + β(xi − x) (15.84)
We see that the intercept α is the predicted output if xi = x, and the slope β is the predicted change
in height per unit change in weight above or below the average weight.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license594
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
6.2 20.9 35.6 50.3 65.0
weight
50
75
100
125
150
175
200
height
(a)
6.2 20.9 35.6 50.3 65.0
weight
50
75
100
125
150
175
200
height
(b)
6.2 20.9 35.6 50.3 65.0
weight
60
80
100
120
140
160
180
height
(c)
Figure 15.2: Linear regression for predicting height given weight for the full dataset (including children) using
polynomial regression. (a) Posterior fit for linear model with log-Gaussian prior for β1. (b) Posterior fit for
quadratic model with log-Gaussian prior for β2. (c) Posterior fit for quadratic model with Gaussian prior for
β2. Adapted from Figure 4.11 of [McE20]. Generated by linreg_height_weight.ipynb.
The question is: what priors should we use? To be truly Bayesian, we should set these before
looking at the data. A sensible prior for α is the height of a “typical person”, with some spread. We
use α ∼ N (178, 20), since the author of the book from which this example is taken is 178cm. By
using a standard deviation of 20, the prior puts 95% probability on the broad range of 178 ± 40.
What about the prior for β? It is tempting to use a vague prior, or weak prior, such as
β ∼ N (0, 10), which is similar to a flat (uniform) prior, but more concentrated at 0 (a form of mild
regularization). To see if this is reasonable, we can compute samples from the prior predictive
distribution, i.e., we sample (αs, βs) ∼ p(α)p(β), and then plot αsx + βs for a range of x values,
for different samples s = 1 : S. The results are shown in Figure 15.1a. We see that this is not a very
sensible prior. For example, we see that it suggests that it is just as likely for the height to decrease
with weight as increase with weight, which is not plausible. In addition, it predicts heights which
are larger than the world’s tallest person (272 cm) and smaller than the world’s shortest person (an
embryo, of size 0).
We can encode the monotonically increasing relationship between weight and height by restricting
β to be positive. An easy way to do this is to use a log-normal or log-Gaussian prior. (If β˜ = log(β)
is Gaussian, then e
β˜ must be positive.) Specifically, we will assume β ∼ LN (0, 1). Samples from this
prior are shown in Figure 15.1b. This is much more reasonable.
Finally we must choose a prior over σ. In [McE20] they use σ ∼ Unif(0, 50). This ensures that σ
is positive, and that the prior predictive distribution for the output is within 100cm of the average
height. However, it is usually easier to specify the expected value for σ than an upper bound. To
do this, we can use σ ∼ Expon(λ), where λ is the rate. We then set E [σ] = 1/λ to the value of the
standard deviation that we expect. For example, we can use the empirical standard deviation of the
data.
Since these priors are no longer conjugate, we cannot compute the posterior in closed form. However,
we can use a variety of approximate inference methods. In this simple example, it suffices to use a
quadratic (Laplace) approximation (see Section 7.4.3). The results are shown in Figure 15.1c, and
look sensible.
So far, we have only considered a subset of the data, corresponding to adults over the age of 18. If
we include children, we find that the mapping from weight to height is nonlinear. This is illustrated
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.2. LINEAR REGRESSION
in Figure 15.2a. We can fix this problem by using polynomial regression. For example, consider a
quadratic expansion of the standardized features xi
:
µi = α + β1xi + β2x
2
i
(15.85)
If we use a log-Gaussian prior for β2, we find that the model is too constrained, and it underfits.
This is illustrated in Figure 15.2b. The reason is that we need to use an inverted quadratic with
a negative coefficient, but since this is disallowed by the prior, the model ends up not using this
degree of freedom (we find E [β2|D] ≈ 0.08). If we use a Gaussian prior on β2, we avoid this problem,
illustrated in Figure 15.2c.
This example shows that it can be useful to think about the functional form of the mapping from
inputs to outputs in order to specify sensible priors.
15.2.5 Spike and slab prior
It is often useful to be able to select a subset of the input features when performing prediction, either
to reduce overfitting, or to improve interpretability of the model. This can be achieved if we ensure
that the weight vector w is sparse (i.e., has many zero elements), since if wd = 0, then xd plays no
role in the inner product wTx.
The canonical way to achieve sparsity when using Bayesian inference is to use a spike-and-slab
(SS) prior [MB88], which has the form of a 2 component mixture model, with one component being
a “spike” at 0, and the other being a uniform “slab” between −a and a:
p(w) = Y
D
d=1
(1 − π)δ(wd) + πUnif(wd| − a, a) (15.86)
where π is the prior probability that each coefficient is non-zero. The corresponding log prior on the
coefficients is thus
log p(w) = ||w||0 log(1 − π) + (D − ||w||0) log π = −λ||w||0 + const (15.87)
where λ = log π
1−π
controls the sparsity of the model, and ||w||0 =
PD
d=1 I(wd 6= 0) is the ℓ0 norm
of the weights. Thus MAP estimation with a spike and slab prior is equivalent ℓ0 regularization;
this penalizes the number of non-zero coefficients. Interestingly, posterior samples will also be sparse.
By contrast, consider using a Laplace prior. The lasso estimator uses MAP estimation, which
results in a sparse estimate. However, posterior samples are not sparse. Interestingly, [EY09] show
theoretically (and [SPZ09] confirm experimentally) that using the posterior mean with a spike-and￾slab prior also results in better prediction accuracy than using the posterior mode with a Laplace
prior.
In practice, we often approximate the uniform slab with a broad Gaussian distribution,
p(w) = Y
d
(1 − π)δ(wd) + πN (wd|0, σ2
w) (15.88)
As σ
2
w → ∞, the second term approaches a uniform distribution over [−∞, +∞]. We can implement
the mixture model by associating a binary random variable, sd ∼ Ber(π), with each coefficient, to
indicate if the coefficient is “on” or “off”.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license596
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
σ
2
N
yi
xi
D
wj
τj
γ
(a)
σ
2
yi
xi
w11 w12 w21 w22 w23
τ1 τ2
γ
(b)
Figure 15.3: (a) Representing lasso using a Gaussian scale mixture prior. (b) Graphical model for group lasso
with 2 groups, the first has size G1 = 2, the second has size G2 = 3.
Unfortunately, MAP estimation (not to mention full Bayesian inference) with such discrete mixture
priors is computationally difficult. Various approximate inference methods have been proposed,
including greedy search (see e.g., [SPZ09]) or MCMC (see e.g., [HS09]).
15.2.6 Laplace prior (Bayesian lasso)
A computationally cheap way to achieve sparsity is to perform MAP estimation with a Laplace prior
by minimizing the penalized negative log likelihood:
PNLL(w) = − log p(D|w) − log p(w|λ) = ||Xw − y||2
2 + λ||w||1 (15.89)
where ||w||1 ,
PD
d=1 |wd| is the ℓ1 norm of w. This method is called lasso, which stands for “least
absolute shrinkage and selection operator” [Tib96]. See Section 11.4 of the prequel to this book,
[Mur22], for details.
In this section, we discuss posterior inference with this prior; this is known as the Bayesian lasso
[PC08]. In particular, we assume the following prior:
p(w|σ
2
) = Y
j
λ
2
√
σ
2
e
−λ|wj |/
√
σ2
(15.90)
(Note that conditioning the prior on σ
2
is important to ensure that the full posterior is unimodal.)
To simplify inference, we will represent the Laplace prior as a Gaussian scale mixture, which we
discussed in Section 28.2.3.2. In particular, one can show that the Laplace distribution is an infinite
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.2. LINEAR REGRESSION
weighted sum of Gaussians, where the precision comes from a gamma distribution:
Laplace(w|0, λ) = Z
N (w|0, τ 2
)Ga(τ
2
|1,
λ
2
2
)dτ 2
(15.91)
We can therefore represent the Bayesian lasso model as a hierarchical latent variable model, as shown
in Figure 15.3a. The corresponding joint distribution has the following form:
p(y, w, τ , σ2
|X) = N (y|Xw, σ2
IN )


Y
j
N (wj |0, σ2
τ
2
j
)Ga(τ
2
j
|1, λ2
/2)

 p(σ
2
) (15.92)
We can also create a GSM to match the group lasso prior, which sets multiple coefficients to
zero at the same time:
wg|σ
2
, τ 2
g ∼ N (0, σ2
τ
2
g
Idg
) (15.93)
τ
2
g ∼ Ga(dg + 1
2
,
λ
2
2
) (15.94)
where dg is the size of group g. So we see that there is one variance term per group, each of which
comes from a gamma prior, whose shape parameter depends on the group size, and whose rate
parameter is controlled by γ.
Figure 15.3b gives an example, where we have 2 groups, one of size 2 and one of size 3. This picture
makes it clearer why there should be a grouping effect. For example, suppose w1,1 is small; then τ
2
1
will be estimated to be small, which will force w1,2 to be small, due to shrinkage (cf. Section 3.6).
Conversely, suppose w1,1 is large; then τ
2
1 will be estimated to be large, which will allow w1,2 to be
become large as well.
Given these hierachical models, we can easily derive a Gibbs sampling algorithm (Section 12.3) to
sample from the posterior (see e.g., [PC08]). Unfortunately, these posterior samples are not sparse,
even though the MAP estimate is sparse. This is because the prior puts infinitessimal probability on
the event that each coefficient is zero.
15.2.7 Horseshoe prior
The Laplace prior is not suitable for sparse Bayesian models, because posterior samples are not
sparse. The spike and slab prior does not have this problem but is often too slow to use (although see
[BRG20]). Fortunately, it is possible to devise continuous priors (without discrete latent variables)
that are both sparse and computationally efficient. One popular prior of this type is the horseshoe
prior [CPS10], so-named because of the shape of its density function.
In the horseshoe prior, instead of using a Laplace prior for each weight, we use the following
Gaussian scale mixture:
wj ∼ N (0, λ2
j
τ
2
) (15.95)
λj ∼ C+(0, 1) (15.96)
τ
2 ∼ C+(0, 1) (15.97)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license598
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where C+(0, 1) is the half-Cauchy distribution (Section 2.2.2.4), λj is a local shrinkage factor, and τ
2
is a global shrinkage factor. The Cauchy distribution has very fat tails, so λj is likely to be either
0 or very far from 0, which emulates the spike and slab prior, but in a continuous way. For more
details, see e.g., [Bha+19].
15.2.8 Automatic relevancy determination
An alternative to using posterior inference with a sparsity promoting prior is to use posterior inference
with a Gaussian prior, wj ∼ N (0, 1/αj ), but where we use empirical Bayes to optimize the precisions
αj . That is, we first compute αˆ = argmaxα p(y|X, α), and then compute wˆ = argmaxw N (w|0, αˆ
−1
).
Perhaps surprisingly, we will see that this results in a sparse estimate, for reasons we explain in
Section 15.2.8.2.
This technique is known as sparse Bayesian learning [Tip01] or automatic relevancy de￾termination (ARD) [Mac95; Nea96]. It has also been called NUV estimation, which stands for
“normal prior with unknown variance” [Loe+16]. It was originally developed for neural networks
(where sparsity is applied to the first layer weights), but here we apply it to linear models.
15.2.8.1 ARD for linear models
In this section, we explain ARD in more detail, by applying it to linear regression. The likelihood
is p(y|x, w, β) = N (y|wTx, 1/β), where β = 1/σ2
. The prior is p(w) = N (w|0, A−1
), where
A = diag(α). The marginal likelihood can be computed analytically (using Equation (2.129)) as
follows:
p(y|X, α, β) = Z
N (y|Xw,(1/β)IN )N (w|0, A−1
)dw (15.98)
= N (y|0, β−1
IN + XA−1XT
) (15.99)
= N (y|0, Cα) (15.100)
where Cα , β
−1
IN + XA−1XT. This is very similar to the marginal likelihood under the spike-and￾slab prior (Section 15.2.5), which is given by
p(y|X, s, σ2
w, σ2
y
) =
Z
N (y|Xsws, σ2
y
I)N (ws|0s, σ2
wI)dws = N (y|0, Cs) (15.101)
where Cs = σ
2
y
IN + σ
2
wXsXT
s
. (Here Xs refers to the design matrix where we select only the columns
of X where sd = 1.) The difference is that we have replaced the binary sj ∈ {0, 1} variables with
continuous αj ∈ R
+, which makes the optimization problem easier.
The objective is the log marginal likelihood, given by
ℓ(α, β) = −2 log p(y|X, α, β) = log |Cα| + y
TC−1
α y (15.102)
There are various algorithms for optimizing ℓ(α, β), some of which we discuss in Section 15.2.8.3.
ARD can be used as an alternative to ℓ1 regularization. Although the ARD objective is not convex,
it tends to give much sparser results [WW12]. In addition, it can be shown [WRN10] that the ARD
objective has many fewer local optima than the ℓ0-regularized objective, and hence is much easier to
optimize.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.2. LINEAR REGRESSION
x
y
(a) (b)
Figure 15.4: Illustration of why ARD results in sparsity. The vector of inputs x does not point towards the
vector of outputs y, so the feature should be removed. (a) For finite α, the probability density is spread in
directions away from y. (b) When α = ∞, the probability density at y is maximized. Adapted from Figure 8
of [Tip01].
15.2.8.2 Why does ARD result in a sparse solution?
Once we have estimated α and β, we can compute the posterior over the parameters using Bayes’
rule for Gaussians, to get p(w|D, αˆ , βˆ) = N (w|
aw,
a
Σ), where a
Σ
−1
= βˆXTX + A and aw= βˆ
a
Σ XTy.
If we have αˆd ≈ ∞, then awd≈ 0, so the solution vector will be sparse.
We now give an intuitive argument, based on [Tip01], about when such a sparse solution may be
optimal. We shall assume β = 1/σ2
is fixed for simplicity. Consider a 1d linear regression with 2
training examples, so X = x = (x1, x2), and y = (y1, y2). We can plot x and y as vectors in the
plane, as shown in Figure 15.4. Suppose the feature is irrelevant for predicting the response, so x
points in a nearly orthogonal direction to y. Let us see what happens to the marginal likelihood as we
change α. The marginal likelihood is given by p(y|x, α, β) = N (y|0, Cα), where Cα =
1
β
I +
1
α
xxT.
If α is finite, the posterior will be elongated along the direction of x, as in Figure 15.4(a). However,
if α = ∞, we have Cα =
1
β
I, which is spherical, as in Figure 15.4(b). If |Cα| is held constant, the
latter assigns higher probability density to the observed response vector y, so this is the preferred
solution. In other words, the marginal likelihood “punishes” solutions where αd is small but X:,d is
irrelevant, since these waste probability mass. It is more parsimonious (from the point of view of
Bayesian Occam’s razor) to eliminate redundant dimensions.
Another way to understand the sparsity properties of ARD is as approximate inference in a
hierarchical Bayesian model [BT00]. In particular, suppose we put a conjugate prior on each
precision, αd ∼ Ga(a, b), and on the observation precision, β ∼ Ga(c, d). Since exact inference with a
Student prior is intractable, we can use variational Bayes (Section 10.3.3), with a factored posterior
approximation of the form
q(w, α) = q(w)q(α) ≈ N (w|µ, Σ)
Y
d
Ga(αd|
aad,
a
bd) (15.103)
ARD approximates q(α) by a point estimate. However, in VB, we integrate out α; the resulting
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license600
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
posterior marginal q(w) on the weights is given by
p(w|D) = Z
N (w|0, diag(α)
−1
)
Y
d
Ga(αd|
aad,
a
b)dα (15.104)
This is a Gaussian scale mixture, and can be shown to be the same as a multivariate Student
distribution (see Section 28.2.3.1), with non-diagonal covariance. Note that the Student has a large
spike at 0, which intuitively explains why the posterior mean (which, for a Student distribution, is
equal to the posterior mode) is sparse.
Finally, we can also view ARD as a MAP estimation problem with a non-factorial prior [WN07].
Intuitively, the dependence between the wj parameters arises, despite the use of a diagonal Gaussian
prior, because the prior precision αj is estimated based after marginalizing out all w, and hence
depends on all the features. Interestingly, [WRN10] prove that MAP estimation with non-factorial
priors is strictly better than MAP estimation with any possible factorial prior in the following
sense: the non-factorial objective always has fewer local minima than factorial objectives, while still
satisfying the property that the global optimum of the non-factorial objective corresponds to the
global optimum of the ℓ0 objective — a property that ℓ1 regularization, which has no local minima,
does not enjoy.
15.2.8.3 Algorithms for ARD
There are various algorithms for optimizing ℓ(α, β). One approach is to use EM, in which we compute
p(w|D, α) in the E step and then maximize α in the M step. In variational Bayes, we infer both w
and α (see [Dru08] for details). In [WN10], they present a method based on iteratively reweighted ℓ1
estimation.
Recently, [HXW17] showed that the nested iterative computations performed these methods can
emulated by a recurrent neural network (Section 16.3.4). Furthermore, by training this model, it is
possible to achieve much faster convergence than manually designed optimization algorithms.
15.2.8.4 Relevance vector machines
Suppose we create a linear regression model of the form p(y|x; θ) = N (y|wTφ(x), σ2
), where
φ(x) = [K(x, x1), . . . , K(x, xN )], where K() is a kernel function (Section 18.2) and x1, . . . , xN are
the N training points. This is called kernel basis function expansion, and transforms the input
from x ∈ X to φ(x) ∈ R
N . Obviously this model has O(N) parameters, and hence is nonparametric.
However, we can use ARD to select a small subset of the exemplars. This technique is called the
relevance vector machine (RVM) [Tip01; TF03].
15.2.9 Multivariate linear regression
This section is written by Xinglong Li.
In this section, we consider the multivariate linear regression model, which has the form
Y = WX + E (15.105)
where W ∈ R
Ny×Nx is the matrix of regression coefficient, X ∈ R
Nx×N is the matrix of input features
(with each row being an input variable and each column being an observation), Y ∈ R
Ny×N is the
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.2. LINEAR REGRESSION
matrix of responses (with each row being an output variable and each column being an observation),
and E = [e1, · · · , eN ] is the matrix of residual errors, where ei
iid∼ N (0, Σ). It can be seen from
the definition that given Σ, W and X, columns of Y are independently random variables following
multivariate normal distributions. So the likelihood of the observation is
p(Y|W, X, Σ) = 1
(2π)Ny×N |Σ|N/2
exp
 X
N
i=1
−
1
2
(yi − Wxi)
TΣ
−1
(yi − Wxi)
!
(15.106)
=
1
(2π)Ny×N |Σ|N/2
exp

−
1
2
tr ￾
(Y − WX)
TΣ
−1
(Y − WX)


(15.107)
= MN (Y|WX, Σ, IN×N ), (15.108)
The conjugate prior for this is the matrix normal inverse Wishart distribution,
W, Σ ∼ MNIW(M0, V0, ν0, Ψ0) (15.109)
where the MNIW is defined by
W|Σ ∼ MN (M0, Σ0, V0) (15.110)
Σ ∼ IW(ν0, Ψ0), (15.111)
where V0 ∈ R
Nx×Nx
++ , Ψ0 ∈ R
Ny×Ny
++ and ν0 > Nx − 1 is the degree of freedom of the inverse Wishart
distribution.
The posterior distribution of {W, Σ} still follows a matrix normal inverse Wishart distribution.
We follow the derivation in [Fox09, App.F]. Tthe density of the joint distribution is
p(Y,W, Σ) ∝|Σ|
−(ν0+Ny+1+Nx+N)/2 × exp 
−
1
2
tr(Ω0)

(15.112)
Ω0 , Ψ0Σ
−1 + (Y − WX)
TΣ
−1
(Y − WX) + (W − M0)
TΣ
−1
(W − M0)V0
(15.113)
We first aggregate items including W in the exponent so that it takes the form of a matrix normal
distribution. This is similar to the “completing the square” technique that we used in deriving the
conjugate posterior for multivariate normal distributions in Section 3.4.4.3. Specifically,
tr 
(Y − WX)
TΣ
−1
(Y − WX) + (W − M0)
TΣ
−1
(W − M0)V0

(15.114)
=tr ￾
Σ
−1
[(Y − WX)(Y − WX)
T + (W − M0)V0(W − M0)
T
]

(15.115)
=tr ￾
Σ
−1
[WSxxWT − 2SyxWT + Syy]

(15.116)
=tr ￾
Σ
−1
[(W − SyxS
−1
xx )Sxx(W − SyxS
−1
xx )
T + Sy|x]

. (15.117)
where
Sxx = XXT + V0, Syx = YXT + M0V0, (15.118)
Syy = YYT + M0V0MT
0
, Sy|x = Syy − SyxS
−1
xx S
T
yx. (15.119)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND lic602
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Therefore, it can be see from Equation (15.117) that given Σ, W follows a matrix normal distribution
W|Σ, X, Y ∼ MN (SyxS
−1
xx , Σ, Sxx). (15.120)
Marginalizing out W (which corresponds to removing the terms including W in the exponent
in Equation (15.113)), it can be shown that the posterior distribution of Σ is an inverse Wishart
distribution. In fact, by replacing Equation (15.117) to the corresponding terms in Equation (15.113),
it can be seen that the only terms left after integrating out W are Σ
−1Ψ and Σ
−1Sy|x, which
indicates that the scale matrix of the posterior inverse Wishart distribution is Ψ0 + Sy|x.
In conclusion, the joint posterior distribution of {W, Σ} given the observation is
W, Σ|X, Y ∼ MNIW(M1, V1, ν1, Ψ1) (15.121)
M1 = SyxS
−1
xx (15.122)
V1 = Sxx (15.123)
ν1 = N + ν0 (15.124)
Ψ1 = Ψ0 + Sy|x (15.125)
The MAP estimate of W and Σ are the mode of the posterior matrix normal inverse Wishart
distribution. To derive this, notice that W only appears in the matrix normal density function in
the posterior, so the matrix W maximizing the posterior density of {W, Σ} is the matrix W that
maximizes the matrix normal posterior of W. So the MAP estimate of W is Wˆ = M1 = SyxS
−1
xx ,
and this holds for any value of Σ. By plugging W = Wˆ into the joint posterior of {W, Σ}, and taking
derivatives over Σ, it can be seen that the matrix maximizing the density is (ν1 + Ny + Nx + 1)−1Ψ1.
Since Ψ1 is positive definite, it is the MAP estimate of Σ.
In conclusion, the MAP estimate of {W, Σ} are
Wˆ = SyxS
−1
xx (15.126)
Σˆ =
1
ν1 + Ny + Nx + 1
(Ψ0 + Sy|x) (15.127)
15.3 Logistic regression
Logistic regression is a very widely used discriminative classification model that maps input
vectors x ∈ R
D to a distribution over class labels, y ∈ {1, . . . , C}. If C = 2, this is known as
binary logistic regression, and if C > 2, it is known as multinomial logistic regression, or
alternatively, multiclass logistic regression.
15.3.1 Binary logistic regression
In the binary case, where y ∈ {0, 1}, the model has the following form
p(y|x; θ) = Ber(y|σ(wTx + b)) (15.128)
where w are the weights, b is the bias (offset), and σ is the sigmoid or logistic function, defined by
σ(a) ,
1
1 + e−a
(15.129)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.3. LOGISTIC REGRESSION
Let ηn = wTxn + b be the logits for example n, and µn = σ(ηn) = p(y = 1|xn) be the mean of
the output. Then we can write the log likelihood as the negative cross entropy:
log p(D|θ) = log Y
N
n=1
µ
yn
n
(1 − µn)
1−yn =
X
N
n=1
yn log µn + (1 − yn) log(1 − µn) (15.130)
We can expand this equation into a more explicit form (that is commonly seen in implementations)
by performing some simple algebra. First note that
µn =
1
1 + e−ηn
=
e
ηn
1 + e
ηn
, 1 − µn = 1 −
e
ηn
1 + e
ηn
=
1
1 + e
ηn
(15.131)
Hence
log p(D|θ) = X
N
n=1
yn[log e
ηn − log(1 + e
ηn )] + (1 − yn)[log 1 − log(1 + e
ηn )] (15.132)
=
X
N
n=1
yn[ηn − log(1 + e
ηn )] + (1 − yn)[− log(1 + e
ηn )] (15.133)
=
X
N
n=1
ynηn −
X
N
n=1
log(1 + e
ηn ) (15.134)
Note that the log(1 + e
a
) function is often implemented using np.log1p(np.exp(a)).
15.3.2 Multinomial logistic regression
Multinomial logistic regression is a discriminative classification model of the following form:
p(y|x; θ) = Cat(y|softmax(Wx + b)) (15.135)
where x ∈ R
D is the input vector, y ∈ {1, . . . , C} is the class label, W is a C × D weight matrix, b
is C-dimensional bias vector, and softmax() is the softmax function, defined as
softmax(a) ,
"
e
a1
PC
c
′=1 e
ac′
, . . . ,
e
aC
PC
c
′=1 e
ac′
#
(15.136)
If we define the logits as ηn = Wxn + b, the probabilities as µn = softmax(ηn), and let yn be the
one-hot encoding of the label yn, then the log likelihood can be written as the negative cross entropy:
log p(D|θ) = log Y
N
n=1
Y
C
c=1
µ
ync
nc =
X
N
n=1
X
C
c=1
ync log µnc (15.137)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license604
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.3.3 Dealing with class imbalance and the long tail
In many problems, some classes are much rarer than others; this problem is called class imbalance.
In such a setting, standard maximum likelihood training may not work well, since it designed to
minimize (a bound on) the 0-1 loss, which can be dominated by the most frequent classes. A natural
alternative is to consider the balanced error rate, which computes the average of the per-class
error rates of classifier f:
BER(f) = 1
C
X
C
y=1
p
∗
x|y

y 6∈ argmax
y′∈Y
fy′ (x)

(15.138)
where p
∗
is the true distribution. The classifier that optimizes this loss, f
∗
, must satisfy
argmax
y∈Y
f
∗
y
(x) = argmax
y∈Y
p
∗
bal(y|x) = argmax
y∈Y
p
∗
(x|y) (15.139)
where p
∗
bal(y|x) ∝
1
C
p
∗
(x|y) is the predictor when using balanced classes. Thus to minimize the BER,
we should using the class-conditional likelihood, p(x|y), rather than the class posterior, p(y|x).
In [Men+21], they propose a simple scheme called logit adjustment that can achieve this optimal
classifier. We assume the model computes logits using fy(x) = wT
yφ(x), where φ(x) = x for a GLM.
In the post-hoc version, the model is trained in the usual way, and then at prediction time, we use
argmax
y∈Y
p(x|y) = argmax
y∈Y
p(y|x)p(x)
p(y)
= argmax
y∈Y
exp(wT
yφ(x))
πy
(15.140)
where πy = p(y) is the empirical label prior. In practice, it is helpful to inroduce a tuning parameter
τ > 0 and to use the predictor
ˆf(x) = argmax
y∈Y
fy(x) − τ log πy (15.141)
Alternatively, we can change the loss function used during training, by using the following logit
adjusted softmax cross-entropy loss:
ℓ(y, f(x)) = − log e
fy(x)+τ log πy
PC
y′=1 e
fy′ (x)+τ log πy′
(15.142)
This is like training with a predictor of the form gy(x) = fy(x) + τ log πy, and then at test time
using argmaxy
fy(x) = argmaxy
gy(x) − τ log πy, as above.
We can also combine the above loss with a prior on the parameters and perform Bayesian inference,
as we discuss below. (The use a non-standard likelihood can be justifed using the generalized Bayesian
inference framework, as discussed in Section 14.1.3.)
15.3.4 Parameter priors
As with linear regression, it is standard to use Gaussian priors for the weights in a logistic regression
model. It is natural to set the prior mean to 0, to reflect the fact that the output could either
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.3. LOGISTIC REGRESSION
0.00 0.25 0.50 0.75 1.00
σ(α)
0
2
4
6
density
variance=1.50
variance=10.00
(a)
0 1
1
2
3
1 prediction,
std=1.50
0 1
5 prediction,
std=1.50
0 1
15 prediction,
std=1.50
(b)
Figure 15.5: (a) Prior on logistic regression output when using N (0, ω) prior for the offset term, for ω = 10
or ω = 1.5. Adapted from Figure 11.3 of [McE20]. Generated by logreg_prior_offset.ipynb. (b) Distribution
over the fraction of 1s we expect to see when using binary logistic regression applied to random binary feature
vectors of increasing dimensionality. We use a N (0, 1.5) prior on the regression coefficients. Adapted from
Figure 3 of [Gel+20]. Generated by logreg_prior.ipynb.
increase or decrease in probability depending on the input. But how do we set the prior variance? It
is tempting to use a large value, to approximate a uniform distribution, but this is a bad idea. To
see why, consider a binary logistic regression model with just an offset term and no features:
p(y|θ) = Ber(y|σ(α)) (15.143)
p(α) = N (α|0, ω) (15.144)
If we set the prior to the large value of ω = 10, the implied prior for y is an extreme distribution,
with most of its density near 0 or 1, as shown in Figure 15.5a. By contrast, if we use the smaller
value of ω = 1.5, we get a flatter distribution, as shown.
If we have input features, the problem gets a little trickier, since the magnitude of the logits will
now depend on the number and distribution of the input variables. For example, suppose we generate
N random binary vectors xn, each of dimension D, where xnd ∼ Ber(p), where p = 0.8. We then
compute p(yn = 1|xn) = σ(β
Txn), where β ∼ N (0, 1.5I). We sample S values of β, and for each
one, we sample a vector of labels, y1:N,s from the above distribution. We then compute the fraction
of positive labels, fs =
1
N
PN
n=1 I(yn,s = 1). We plot the distribution of {fs} as a function of D in
Figure 15.5b. We see that the induced prior is initially flat, but eventually becomes skewed towards
the extreme values of 0 and 1. To avoid this, we should standardize the inputs, and scale the variance
of the prior by 1/
√
D. We can also use a heavier tailed distribution, such as a Cauchy or Student
[Gel+08; GLM15], instead of the Gaussian prior.
15.3.5 Laplace approximation to the posterior
Unfortunately, we cannot compute the posterior analytically, unlike with linear regression, since
there is no corresponding conjugate prior. (This mirrors the case with MLE, where we have a closed
form solution for linear regression, but not for logistic regression.) Fortunately, there are a range of
approximate inference methods we can use.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license606
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−7.5 −5.0 −2.5 0.0 2.5 5.0 7.5
−7.5
−5.0
−2.5
0.0
2.5
5.0
7.5
1
0
(a) Data
−5 0 5
−5
0
5
1
2
3 4
−2240
−1920
−1600
−1280
−960
−640
−320
0
(b) Log likelihood
−5 0 5
−5
0
5
−2240
−1920
−1600
−1280
−960
−640
−320
0
(c) Log-unnormalized posterior
−5 0 5
−5
0
5
−96
−84
−72
−60
−48
−36
−24
−12
0
(d) Laplace approximation to posterior
Figure 15.6: (a) Illustration of the data and some decision boundaries. (b) Log-likelihood for a logistic
regression model. The line is drawn from the origin in the direction of the MLE (which is at infinity). The
numbers correspond to 4 points in parameter space, corresponding to the colored lines in (a). (c) Unnormalized
log posterior (assuming vague spherical prior). (d) Laplace approximation to posterior. Adapted from a figure
by Mark Girolami. Generated by logreg_laplace_demo.ipynb.
In this section, we use the Laplace approximation. As we explain in Section 7.4.3, this approximates
the posterior using a Gaussian. The mean of the Gaussian is equal to the MAP estimate wˆ , and the
covariance is equal to the inverse Hessian H computed at the MAP estimate, i.e.,
p(w|D) ≈ N (w|wˆ , H−1
), wˆ = arg min − log p(w, D), H = −∇2
w log p(w, D)|wˆ (15.145)
We can find the mode using a standard optimization method, and we can then compute the Hessian
at the mode analytically or using automatic differentiation.
As an example, consider the binary data illustrated in Figure 15.6(a). There are many parameter
settings that correspond to lines that perfectly separate the training data; we show 4 example lines.
For each decision boundary in Figure 15.6(a), we plot the corresponding parameter vector as point
in the log likelihood surface in Figure 15.6(b). These parameters values are w1 = (3, 1), w2 = (4, 2),
w3 = (5, 3), and w4 = (7, 3). These points all approximately satisfy wi(1)/wi(2) ≈ wˆ mle(1)/wˆ mle(2),
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.3. LOGISTIC REGRESSION
and hence are close to the orientation of the maximum likelihood decision boundary. The points
are ordered by increasing weight norm (3.16, 4.47, 5.83, and 7.62). The unconstrained MLE has
||w|| = ∞, so is infinitely far to the top right.
To ensure a unique solution, we use a (spherical) Gaussian prior centered at the origin, N (w|0, σ2
I).
The value of σ
2
controls the strength of the prior. If we set σ
2 = ∞, we force the MAP estimate
to be w = 0; this will result in maximally uncertain predictions, since all points x will produce a
predictive distribution of the form p(y = 1|x) = 0.5. If we set σ
2 = 0, the MAP estimate becomes
the MLE, resulting in minimally uncertain predictions. (In particular, all positively labeled points
will have p(y = 1|x) = 1.0, and all negatively labeled points will have p(y = 1|x) = 0.0, since the
data is separable.) As a compromise (to make a nice illustration), we pick the value σ
2 = 100.
Multiplying this prior by the likelihood results in the unnormalized posterior shown in Figure 15.6(c).
The MAP estimate is shown by the blue dot. The Laplace approximation to this posterior is shown
in Figure 15.6(d). We see that it gets the mode correct (by construction), but the shape of the
posterior is somewhat distorted. (The southwest-northeast orientation captures uncertainty about the
magnitude of w, and the southeast-northwest orientation captures uncertainty about the orientation
of the decision boundary.)
15.3.6 Approximating the posterior predictive distribution
Next we need to convert the posterior over the parameters into a posterior over predictions, as follows:
p(y|x, D) = Z
p(y|x, w)p(w|D)dw (15.146)
The simplest way to evaluate this integral is to use a Monte Carlo approximation. For example, in
the case of binary logistic regression, we have
p(y = 1|x, D) ≈
1
S
X
S
s=1
σ(wT
sx) (15.147)
where ws ∼ p(w|D) are posterior samples.
However, we can also use deterministic approximations to the integral, which are often faster. Let
f∗ = f(x∗, w) be the predicted logits, before the sigmoid/softmax layer, given test point x∗. If the
posterior over the parameters is Gaussian, p(w|D) = N (µ, Σ), then the predictive distribution over
logits is also Gaussian:
p(f∗|x∗, D) = Z
δ(f∗ − f(x∗, w))N (w|D)dw = N (f∗|µ
Tx∗, x
T
∗Σx∗) , N (f∗|µ∗
, Σ∗) (15.148)
In the case of binary logistic regression, we can approximate the sigmoid with the probit function Φ
(see Section 15.4), which allows us to solve the integral analytically:
p(y∗|x∗) ≈
Z
Φ(f∗)N (f∗|µ∗, σ2
∗
)df∗ = σ
 
p
µ∗
1 + π
8
σ
2
∗
!
(15.149)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license608
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−5 0 5
−7.5
−5.0
−2.5
0.0
2.5
5.0
7.5
1
0
0.00
0.12
0.24
0.36
0.48
0.60
0.72
0.84
0.96
(a) p(y = 1|x, wMAP )
−7.5 −5.0 −2.5 0.0 2.5 5.0 7.5
−7.5
−5.0
−2.5
0.0
2.5
5.0
7.5
(b) Decision boundary for sampled w
−5 0 5
−7.5
−5.0
−2.5
0.0
2.5
5.0
7.5
0.00
0.12
0.24
0.36
0.48
0.60
0.72
0.84
0.96
(c) MC approx of p(y = 1|x)
−5 0 5
−7.5
−5.0
−2.5
0.0
2.5
5.0
7.5
0.00
0.12
0.24
0.36
0.48
0.60
0.72
0.84
0.96
(d) Deterministic approx of p(y = 1|x)
Figure 15.7: Posterior predictive distribution for a logistic regression model in 2d. (a) Contours of p(y =
1|x, wˆ map). (b) Samples from the posterior predictive distribution. (c) Averaging over these samples. (d)
Moderated output (probit approximation). Generated by logreg_laplace_demo.ipynb.
This is called the probit approximation [SL90]. In [Gib97], a generalization to the multiclass case
was provided. This is known as the generalized probit approximation, and has the form
p(y∗|x∗) ≈
Z
softmax(f∗)N (f∗|µ∗
, Σ∗)df∗ = softmax 
{p
µ∗,c
1 + π
8 Σ∗,cc
}
!
(15.150)
This ignores the correlations between the logits, because it only depends on the diagonal elements
of Σ∗. Nevertheless it can work well, even in the case of neural net classifiers [LIS20]. Another
deterministic approximation, known as the Laplace bridge, is discussed in Section 17.3.10.2.
We now illustrate the posterior predictive for our binary example. Figure 15.7(a) shows the plugin
approximation using the MAP estimate. We see that there is no uncertainty about the location
of the decision boundary, even though we are generating probabilistic predictions over the labels.
Figure 15.7(b) shows what happens when we plug in samples from the Gaussian posterior. Now
we see that there is considerable uncertainty about the orientation of the “best” decision boundary.
Figure 15.7(c) shows the average of these samples. By averaging over multiple predictions, we see
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.3. LOGISTIC REGRESSION
4.5 5.0 5.5 6.0 6.5 7.0
sepal length
2
4
6
8
sepal width
setosa
versicolor
Posterior mean
(a)
4.5 5.0 5.5 6.0 6.5 7.0
sepal length
2
4
6
8
sepal width
(b)
Figure 15.8: Illustration of the posterior over the decision boundary for classifying iris flowers (setosa
vs versicolor) using 2 input features. (a) 25 examples per class. Adapted from Figure 4.5 of [Mar18].
(b) 5 examples of class 0, 45 examples of class 1. Adapted from Figure 4.8 of [Mar18]. Generated by
logreg_iris_bayes_2d.ipynb.
that the uncertainty in the decision boundary “splays out” as we move further from the training data.
Figure 15.7(d) shows that the probit approximation gives very similar results to the Monte Carlo
approximation.
15.3.7 MCMC inference
Markov chain Monte Carlo, or MCMC, is often considered the “gold standard” for approximate
inference, since it makes no explicit assumptions about the form of the posterior. It is explained in
depth in Chapter 12, but the output is a set of (correlated) samples from the posterior, which gives
the following non-parametric approximation:
q(θ|D) ≈
1
S
X
S
s=1
δ(θ − θ
s
) (15.151)
where θ
s ∼ p(θ|D). Once we have the samples, we can plug them into Equation (15.147) to
approximate the posterior predictive distribution.
A common MCMC method is known as Hamiltonian Monte Carlo (Section 12.5); this can leverage
our ability to compute the gradient of the log joint, ∇θ log p(D, θ), for improved efficiency. Let us
apply HMC to a 2-dimensional, 2-class version of the iris classification problem, where we just use
two input features, sepal length and sepal width, and two classes, Virginica and non-Virginica. The
decision boundary is the set of points (x
∗
1
, x∗
2
) such that σ(b + w1x
∗
1 + w2x
∗
2
) = 0.5. Such points must
lie on the following line:
x
∗
2 = −
b
w2
+

−
w1
w2
x
∗
1

(15.152)
We can therefore compute an MC approximation to the posterior over decision boundaries by sampling
the parameters from the posterior, (w1, w2, b) ∼ p(θ|D), and plugging them into the above equation,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license610
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Dept. Di Gender Gi # Admitted Ai # Rejected Ri # Applications Ni
A male 512 313 825
A female 89 19 108
B male 353 207 560
B female 17 8 25
C male 120 205 325
C female 202 391 593
D male 138 279 417
D female 131 244 375
E male 53 138 191
E female 94 299 393
F male 22 351 373
F female 24 317 341
Table 15.1: Admissions data for UC Berkeley from [BHO75].
to get p(x
∗
1
, x2 ∗ |D). The results of this method (using a vague Gaussian prior for the parameters)
are shown in Figure 15.8a. The solid line is the posterior mean, and the shaded interval is a 95%
credible interval. As before, we see that the uncertainty about the location of the boundary is higher
as we move away from the training data.
In Figure 15.8b, we show what happens to the decision boundary when we have unbalanced classes.
We notice two things. First, the posterior uncertainty increases, because we have less data from the
blue class. Second, we see that the posterior mean of the decision boundary shifts towards the class
with less data. This follows from linear discriminant analysis, where one can show that changing
the class prior changes the location of the decision boundary, so that more of the input space gets
mapped to the class which is higher a priori. (See [Mur22, Sec 9.2] for details.)
15.3.8 Other approximate inference methods
There are many other approximate inference methods we can use, as we discuss in Part II. A
common approach is variational inference (Section 10.1), which converts approximate inference
into an optimization problem. It does this by choosing an approximate distribution q(w; ψ) and
optimizing the variational parameters ψ to maximize the evidence lower bound (ELBO). This has the
effect of making q(w; ψ) ≈ p(w|D) in the sense that the KL divergence is small. There are several
ways to tackle this: use a stochastic estimate of the ELBO (see Section 10.2.1), use the conditionally
conjugate VI method of Supplementary Section 10.3.1.2, or use a “local” VI method that creates a
quadratic lower bound to the logistic function (see Supplementary Section 15.1).
In the online setting, we can use assumed density filtering (ADF) to recursively compute a Gaussian
approximate posterior p(w|D1:t), as we discuss in Section 8.6.3.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.3. LOGISTIC REGRESSION
15.3.9 Case study: is Berkeley admissions biased against women?
In this section, we consider a simple but interesting example of logistic regression from [McE20, Sec
11.1.4]. The question of interest is whether admission to graduate school at UC Berkeley is biased
against women. The dataset comes from a famous paper [BHO75], which collected statistics for 6
departments for men and women. The data table only has 12 rows, shown in Table 15.1, although
the total sample size (number of observations) is 4526. We conduct a regression analysis to try to
determine if gender “causes” imbalanced admissions rates.
An obvious way to attempt to answer the question of interest is to fit a binomial logistic regression
model, in which the outcome is the admissions rate, and the input is a binary variable representing
the gender of each sample (make or female). One way to write this model is as follows:
Ai ∼ Bin(Ni
, µi) (15.153)
logit(µi) = α + βMALE[i] (15.154)
α ∼ N (0, 10) (15.155)
β ∼ N (0, 1.5) (15.156)
Here Ai
is the number of admissions for sample i, Ni
is the nunber of applications, and MALE[i] = 1
iff the sample is male. So the log odds is α for female cases, and α + β for male candidates. (The
choice of prior for these parameters is discussed in Section 15.3.4.)
The above formulation is asymmetric in the genders. In particular, the log odds for males has two
random variables associated with it, and hence is a priori is more uncertain. It is often better to
rewrite the model in the following symmetric way:
Ai ∼ Bin(Ni
, µi) (15.157)
logit(µi) = αGENDER[i] (15.158)
αj ∼ N (0, 1.5), j ∈ {1, 2} (15.159)
Here GENDER[i] is the gender (1 for male, 2 for female), so the log odds is α1 for males and α2 for
females.
We can perform posterior inference using a variety of methods (see Chapter 7). Here we use HMC
(Section 12.5). We find the 89% credible interval for α1 is [−0.29, 0.16] and for α2 is [−0.91, 0.75].
2
The corresponding distribution for the difference in probability, σ(α1) − σ(α2), is [0.12, 0.16], with a
mean of 0.14. So it seems that Berkeley is biased in favor of men.
However, before jumping to conclusions, we should check if the model is any good. In Figure 15.9a,
we plot the posterior predictive distribution, along with the original data. We see the model is a very
bad fit to the data (the blue data dots are often outside the black predictive intervals). In particular,
we see that the empirical admissions rate for women is actually higher in all the departments except
for C and E, yet the model says that women should have a 14% lower chance of admission.
The trouble is that men and women did not apply to the same departments in equal amounts.
Women tended not to apply to departments, like A and B, with high admissions rates, but instead
applied more to departments, like F, with low admissions rates. So even though less women were
accepted overall, within in each department, women tended to be accepted at about the same rate.
2. McElreath uses 89% interval instead of 95% to emphasize the arbitrary nature of these values. The difference is
insignificant.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license612
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
1 2 3 4 5 6 7 8 9 10 11 12
case
0.0
0.2
0.4
0.6
0.8
1.0
admit
A
B
C D
E
F
(a)
1 2 3 4 5 6 7 8 9 10 11 12
case
0.0
0.2
0.4
0.6
0.8
1.0
admit
A
B
C D
E
F
(b)
Figure 15.9: Blue dots are admission rates for each of the 6 departments (A-F) for males (left half of each
dyad) and females (right half ). The circle is the posterior mean of µi, the small vertical black lines indicate 1
standard deviation of µi. The + marks indicate 95% predictive interval for Ai. (a) Basic model, only taking
gender into account. (b) Augmented model, adding department specific offsets. Adapted from Figure 11.5 of
[McE20]. Generated by logreg_ucb_admissions_numpyro.ipynb.
We can get a better understanding if we consider the DAG in Figure 15.10a. This is intended to
be a causal model of the relevant factors. We discuss causality in more detail in Chapter 36, but the
basic idea should be clear from this picture. In particular, we see that there is an indirect causal path
G → D → A from gender to acceptance, so to infer the direct affect G → A, we need to condition on
D and close the indirect path. We can do this by adding department id as another feature:
Ai ∼ Bin(Ni
, µi) (15.160)
logit(µi) = αGENDER[i] + γDEPT[i] (15.161)
αj ∼ N (0, 1.5), j ∈ {1, 2} (15.162)
γk ∼ N (0, 1.5), k ∈ {1, . . . , 6} (15.163)
Here j ∈ {1, 2} (for gender) and k ∈ {1, . . . , 6} (for department). Note that there 12 parameters in
this model, but each combination (slice of the data) has a fairly large sample size of data associated
with it, as we see in Table 15.1.
In Figure 15.9b, we plot the posterior predictive distribution for this new model; we see the fit is
now much better. We find the 89% credible interval for α1 is [−1.38, 0.35] and for α2 is [−1.31, 0.42].
The corresponding distribution for the difference in probability, σ(α1) − σ(α2), is [−0.05, 0.01]. So it
seems that there is no bias after all.
However, the above conclusion is based on the correctness of the model in Figure 15.10a. What if
there are unobserved confounders U, such as academic ability, influencing both admission rate
and department choice? This hypothesis is shown in Figure 15.10b. In this case, conditioning on
the collider D opens up a non-causal path between gender and admissions, G → D ← U → A. This
invalidates any causal conclusions we may want to draw.
The point of this example is to serve as a cautionary tale to those trying to draw causal conclusions
from predictive models. See Chapter 36 for more details.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.4. PROBIT REGRESSION
A
G
D
(a)
A
G
D
(b)
Figure 15.10: Some possible causal models of admissions rates. G is gender, D is department, A is acceptance
rate. (a) No hidden confounders. (b) Hidden confounder (small dot) affects both D and A. Generated by
logreg_ucb_admissions_numpyro.ipynb.
−6 −4 −2 0 2 4 6
x
0.00
0.25
0.50
0.75
1.00
f(x)
sigmoid
probit
Figure 15.11: The logistic (sigmoid) function σ(x) in solid red, with the Gaussian cdf function Φ(λx) in
dotted blue superimposed. Here λ =
p
π/8, which was chosen so that the derivatives of the two curves match
at x = 0. Adapted from Figure 4.9 of [Bis06]. Generated by probit_plot.ipynb.
15.4 Probit regression
In this section, we discuss probit regression, which is similiar to binary logistic regression except
it uses µn = Φ(an) instead of µn = σ(an) as the mean function, where Φ is the cdf of the standard
normal, and an = wTxn. The corresponding link function is therefore an = ℓ(µn) = Φ−1
(µn); the
inverse of the Gaussian cdf is known as the probit function.
The Gaussian cdf Φ is very similar to the logistic function, as shown in Figure 15.11. Thus probit
regression and “regular” logistic regression behave very similarly. However, probit regression has some
advantages. In particular, it has a simple interpretation as a latent variable model (see Section 15.4.1),
which arises from the field of choice theory as studied in economics (see e.g., [Koo03]). This also
simplifies the task of Bayesian parameter inference.
15.4.1 Latent variable interpretation
We can interpret an = wTxn as a factor that is proportional to how likely a person is respond
positively (generate yn = 1) given input xn. However, typically there are other unobserved factors that
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license614
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
influence someone’s response. Let us model these hidden factors by Gaussian noise, ǫn ∼ N (0, 1). Let
the combined preference for positive outcomes be represented by the latent variable zn = wTxn + ǫn.
We assume that the person will pick the positive label iff this latent factor is positive rather than
negative, i.e.,
yn = I(zn ≥ 0) (15.164)
When we marginalize out zn, we recover the probit model:
p(yn = 1|xn, w) = Z
I(zn ≥ 0) N (zn|wTxn, 1)dzn (15.165)
= p(wTxn + ǫn ≥ 0) = p(ǫn ≥ −wTxn) (15.166)
= 1 − Φ(−wTxn) = Φ(wTxn) (15.167)
Thus we can think of probit regression as a threshold function applied to noisy input.
We can interpret logistic regression in the same way. However, in that case the noise term ǫn
comes from a logistic distribution, defined as follows:
f(y|µ, s) ,
e
−
y−µ
s
s(1 + e
−
y−µ
s )
2
=
1
4s
sech2
(
y − µ
s
2
) (15.168)
where the mean is µ and the variance is s
2π
2
3
. The cdf of this distribution is given by
F(y|µ, s) = 1
1 + e
−
y−µ
s
(15.169)
It is clear that if we use logistic noise with µ = 0 and s = 1 we recover logistic regression. However,
it is computationally easier to deal with Gaussian noise, as we show below.
15.4.2 Maximum likelihood estimation
In this section, we discuss some methods for fitting probit regression using MLE.
15.4.2.1 MLE using SGD
We can find the MLE for probit regression using standard gradient methods. Let µn = wTxn, and
let y˜n ∈ {−1, +1}. Then the gradient of the log-likelihood for a single example n is given by
gn ,
d
dw
log p(y˜n|wTxn) = dµn
dw
d
dµn
log p(y˜n|wTxn) = xn
y˜nφ(µn)
Φ(˜ynµn)
(15.170)
where φ is the standard normal pdf, and Φ is its cdf. Similarly, the Hessian for a single case is given
by
Hn =
d
dw2
log p(y˜n|wTxn) = −xn

φ(µn)
2
Φ(˜ynµn)
2
+
y˜nµnφ(µn)
Φ(˜ynµn)

x
T
n
(15.171)
This can be passed to any gradient-based optimizer.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.4. PROBIT REGRESSION
0 20 40 60 80 100
iter
0
25
50
Negative log-likelihood
probit regression with L2 regularizer of 0.010
EM
BFGS
Figure 15.12: Fitting a probit regression model in 2d using a quasi-Newton method or EM. Generated by
probit_reg_demo.ipynb.
15.4.2.2 MLE using EM
We can use the latent variable interpretation of probit regression to derive an elegant EM algorithm
for fitting the model. The complete data log likelihood has the following form, assuming a N (0, V0)
prior on w:
ℓ(z, w|V0) = log p(y|z) + log N (z|Xw, I) + log N (w|0, V0) (15.172)
=
X
n
log p(yn|zn) −
1
2
(z − Xw)
T
(z − Xw) −
1
2
wTV−1
0 w (15.173)
The posterior in the E step is a truncated Gaussian:
p(zn|yn, xn, w) = 
N (zn|wTxn, 1)I(zn > 0) if yn = 1
N (zn|wTxn, 1)I(zn < 0) if yn = 0 (15.174)
In Equation (15.173), we see that w only depends linearly on z, so we just need to compute
E [zn|yn, xn, w], so we just need to compute the posterior mean. One can show that this is given by
E [zn|w, xn] = (
µn +
φ(µn)
1−Φ(−µn) = µn +
φ(µn)
Φ(µn)
if yn = 1
µn −
φ(µn)
Φ(−µn) = µn −
φ(µn)
1−Φ(µi)
if yn = 0
(15.175)
where µn = wTxn.
In the M step, we estimate w using ridge regression, where µ = E [z] is the output we are trying
to predict. Specifically, we have
wˆ = (V−1
0 + XTX)
−1XTµ (15.176)
The EM algorithm is simple, but can be much slower than direct gradient methods, as illustrated
in Figure 15.12. This is because the posterior entropy in the E step is quite high, since we only
observe that z is positive or negative, but are given no information from the likelihood about its
magnitude. Using a stronger regularizer can help speed convergence, because it constrains the range
of plausible z values. In addition, one can use various speedup tricks, such as data augmentation
[DM01].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license616
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.4.3 Bayesian inference
It is possible to use the latent variable formulation of probit regression in Section 15.4.2.2 to derive a
simple Gibbs sampling algorithm for approximating the posterior p(w|D) (see e.g., [AC93; HH06]).
The key idea is to use an auxiliary latent variable, which, when conditioned on, makes the whole
model a conjugate linear-Gaussian model. The full conditional for the latent variables is given by
p(zi
|yi
, xi
, w) = 
N (zi
|wT xi
, 1)I(zi > 0) if yi = 1
N (zi
|wT xi
, 1)I(zi < 0) if yi = 0 (15.177)
Thus the posterior is a truncated Gaussian. We can sample from a truncated Gaussian, N (z|µ, σ)I(a ≤ z ≤ b)
in two steps: first sample u ∼ U(Φ((a − µ)/σ), Φ((b − µ)/σ)), then set z = µ + σΦ
−1
(u) [Rob95a].
The full conditional for the parameters is given by
p(w|D, z,λ) = N (wN , VN ) (15.178)
VN = (V−1
0 + XT X)
−1
(15.179)
wN = VN (V−1
0 w0 + XT z) (15.180)
For further details, see e.g., [AC93; FSF10]. It is also possible to use variational Bayes, which
tends to be much faster (see e.g., [GR06a; FDZ19]).
15.4.4 Ordinal probit regression
One advantage of the latent variable interpretation of probit regression is that it is easy to extend to
the case where the response variable is ordered in some way, such as the outputs low, medium, and
high. This is called ordinal regression. The basic idea is as follows. If there are C output values,
we introduce C + 1 thresholds γj and set
yn = j if γj−1 < zn ≤ γj (15.181)
where γ0 ≤ · · · ≤ γC . For identifiability reasons, we set γ0 = −∞, γ1 = 0 and γC = ∞. For example,
if C = 2, this reduces to the standard binary probit model, whereby zn < 0 produces yn = 0 and
zn ≥ 0 produces yn = 1. If C = 3, we partition the real line into 3 intervals: (−∞, 0], (0, γ2], (γ2, ∞).
We can vary the parameter γ2 to ensure the right relative amount of probability mass falls in each
interval, so as to match the empirical frequencies of each class label. See e.g., [AC93] for further
details.
Finding the MLEs for this model is a bit trickier than for binary probit regression, since we need
to optimize for w and γ, and the latter must obey an ordering constraint. See e.g., [KL09] for an
approach based on EM. It is also possible to derive a simple Gibbs sampling algorithm for this model
(see e.g., [Hof09, p216]).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.5. MULTILEVEL (HIERARCHICAL) GLMS
N
J
x
j
n
y
j
n
θ
j
θ
0
(a)
N
J
gn xn
yn
θ
j
θ
0
(b)
Figure 15.13: Hierarchical Bayesian discriminative models with J groups. (a) Nested formulation. (b)
Non-nested formulation, with group indicator gn ∈ {1, . . . , J}.
15.4.5 Multinomial probit models
Now consider the case where the response variable can take on C unordered categorical values,
yn ∈ {1, . . . , C}. The multinomial probit model is defined as follows:
znc = wT
cxnc + ǫnc (15.182)
ǫ ∼ N (0, R) (15.183)
yn = arg max
c
znc (15.184)
See e.g., [DE04; GR06b; Sco09; FSF10] for more details on the model and its connection to multinomial
logistic regression.
If instead of setting yn = argmaxc
zic we use ync = I(znc > 0), we get a model known as
multivariate probit, which is one way to model C correlated binary outcomes (see e.g., [TMD12]).
15.5 Multilevel (hierarchical) GLMs
Suppose we have a set of J related datasets, each of which contains a series of Nj datapoints
Dj = {(x
j
n
, y
j
n
) : n = 1 : Nj}. There are 3 main ways to fit models in such a setting: we could fit J
separate models, p(y|x; Dj ), which might result in overfitting if some Dj are small; we could pool all
the data to get D = ∪
J
j=1Dj and fit a single model, p(y|x; D), which might result in underfitting; or
we can use a hierarchical Bayesian model, also called a multilevel model or partially pooled
model, in which we assume each group has its own parameters, θ
j
, but that these have something
in common, as modeled by a shared global prior p(θ
0
). (Note that each group could be a single
individual.) The overall model has the form
p(θ
0:J
, D) = p(θ
0
)
Y
J
j=1

p(θ
j
|θ
0
)
Y
Nj
n=1
p(y
j
n
|x
j
n
, θ
j
)

 (15.185)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license618
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
See Figure 15.13a, which represents the model using nested plate notation.
It is often more convenient to represent the model as in Figure 15.13b, which eliminates the
nested plates (and hence the double indexing of variables) by associating a group indicator variable
gn ∈ {1, . . . , J}, which specifies which set of parameters to use for each datapoint. Thus the model
now has the form
p(θ
0:J
, D) = p(θ
0
)


Y
J
j=1
p(θ
j
|θ
0
)


"Y
N
n=1
p(yn|xn, gn, θ)
#
(15.186)
where
p(yn|xn, gn, θ) = Y
J
j=1
p(yn|xn, θ
j
)
I(gn=j)
(15.187)
If the likelihood function is a GLM, this hierarchical model is called a hierarchical GLM [LN96].
This class of models is very widely used in applied statistics. For much more details, see e.g., [GH07;
GHV20b; Gel+22].
15.5.1 Generalized linear mixed models (GLMMs)
Suppose that the prior on the per-group parameters is Gaussian, so p(θ
j
|θ
0
) = N (θ
j
|θ
0
, Σ
j
). If we
have a GLM likelihood, the model becomes
p(yn|xn, gn = j, θ) = p(yn|ℓ(ηn)) (15.188)
ηn = x
T
nθ
j = x
T
n
(θ
0 + ǫ
j
) = x
T
nθ
0 + x
T
n
ǫ
j
(15.189)
where ℓ is the link function, and ǫ
j ∼ N (0, Σ). This is known as a generalized linear mixed
model (GLMM) or mixed effects model. The shared (common) parameters θ
0 are called fixed
effects, and the group-specific offsets ǫ
j are called random effects.
3 We can see that the random
effects model group-specific deviations or idiosyncracies away from the shared fixed parameters.
Furthermore, we see that the random effects are correlated, which allows us to model dependencies
between the observations that would not be captured by a standard GLM.
For model fitting, we can use any of the Bayesian inference methods that we discussed in Sec￾tion 15.1.4.
15.5.2 Example: radon regression
In this section, we give an example of a hierarchical Bayesian linear regression model. We apply it to
a simplified version of the radon example from [Gel+14a, Sec 9.4].
Radon is known to be the highest cause of lung cancer in non-smokers, so reducing it where possible
is desirable. To help with this, we fit a regression model, that predicts the (log) radon level as a
function of the location of the house, as represented by a categorical feature indicating its county, and
3. Note that there are multiple definitions of the terms “fixed effects” and random effects”, as explained in this blog
post by Andrew Gelman: https://statmodeling.stat.columbia.edu/2005/01/25/why_i_dont_use/.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.5. MULTILEVEL (HIERARCHICAL) GLMS
N
J
gn xn
yn
α
j β
j
µα σα µβ σβ
σy
Figure 15.14: A hierarchical Bayesian linear regression model for the radon problem.
a binary feature representing whether the house has a basement or not. We use a dataset consisting
of J = 85 counties in Minnesota; each county has between 2 and 80 measurements.
We assume the following likelihood:
p(yn|xn, gn = j, θ) = N (yn|αj + βjxn, σ2
y
) (15.190)
where gn ∈ {1, . . . , J} is the county for house i, and xn ∈ {0, 1} indicates if the floor is at level 0
(i.e., in the basement) or level 1 (i.e., above ground). Intuitively we expect the radon levels to be
lower in houses without basements, since they are more insulated from the earth which is the source
of the radon.
Since some counties have very few datapoints, we use a hierarchical prior in which we assume
αj ∼ N (µα, σ2
α), and βj ∼ N (µβ, σ2
β
). We use weak priors for the parameters: µα ∼ N (0, 1),
µβ ∼ N (0, 1), σα ∼ C+(1), σβ ∼ C+(1), σy ∼ C+(1). See Figure 15.14 for the graphical model.
15.5.2.1 Posterior inference
Figure 15.15 shows the posterior marginals for µα, µβ, αj and βj . We see that µβ is close to −0.6
with high probability, which confirms our suspicion that having x = 1 (i.e., no basement) decreases
the amount of radon in the house. We also see that the distribution of the αj parameters is quite
variable, due to different base rates across the counties.
Figure 15.16 shows predictions from the hierarchical and non-hierarchical model for 3 different
counties. We see that the predictions from the hierarchical model are more consistent across counties,
and work well even if there are no examples of certain feature combinations for a given county (e.g.,
there are no houses without basements in the sample from Cass county). If we sample data from the
posterior predictive distribution, and compare it to the real data, we find that the RMSE is 0.13 for
the non-hierarchical model and 0.08 for the hierarchical model, indicating that the latter fits better.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license620
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 1 2 3
0
2
4
6
Density
alpha
−3 −2 −1 0 1
beta
Figure 15.15: Posterior marginals for αj and βj for each county j in the radon model. Generated by
linreg_hierarchical_non_centered.ipynb.
basement first floor
−1
0
1
2
3
4
log radon level
CASS
basement first floor
CROW WING
individual
hierarchical
original data
basement first floor
FREEBORN
Figure 15.16: Predictions from the radon model for 3 different counties in Minnesota. Black dots are observed
datapoints. Red represents results of hierarchical (shared) prior, blue represents results of non-hierarchical
prior. Thick lines are the result of using the posterior mean, thin lines are the result of using posterior
samples. Generated by linreg_hierarchical_non_centered.ipynb.
15.5.2.2 Non-centered parameterization
One problem that frequently arises in hierarchical models is that the parameters be very correlated.
This can cause computational problems when performing inference.
Figure 15.17a gives an example where we plot p(βj , σβ|D) for some specific county j. If we believe
that σβ is large, then βc is “allowed” to vary a lot, and we get the broad distribution at the top of
the figure. However, if we believe that σβ is small, then βj is constrained to be close to the global
prior mean of µβ, so we get the narrow distribution at the bottom of the figure. This is often called
Neal’s funnel, after a paper by Radford Neal [Nea03]. It is difficult for many algorithms (especially
sampling algorithms) to explore parts of parameter space at the bottom of the funnel. This is evident
from the marginal posterior for σβ shown (as a histogram) on the right hand side of the plot: we see
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
15.5. MULTILEVEL (HIERARCHICAL) GLMS
−2 −1 0 1
slope b 75
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
slope group variance sigma b
(a)
−2 −1 0 1
slope b 75
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
slope group variance sigma b
(b)
Figure 15.17: (a) Bivariate posterior p(βj , σβ|D) for the hierarchical radon model for county j = 75 using
centered parameterization. (b) Similar to (a) except we plot p(β˜j , σβ|D) for the non-centered parameterization.
Generated by linreg_hierarchical_non_centered.ipynb.
that it excludes the interval [0, 0.1], thus ruling out models in which we shrink βj all the way to 0.
In cases where a covariate has no useful predictive role, we would like to be able to induce sparsity,
so we need to overcome this problem.
A simple solution to this is to use a non-centered parameterization [PR03]. That is, we replace
βj ∼ N (µβ, σ2
β
) with βj = µβ + β˜
jσβ, where β˜
j ∼ N (0, 1) represents the offset from the global mean,
µβ. The correlation between β˜
j and σβ is much less, as shown in Figure 15.17b. See Section 12.6.5
for more details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license16 Deep neural networks
16.1 Introduction
The term “deep neural network” or DNN, in its modern usage, refers to any kind of differentiable
function that can be expressed as a computation graph, where the nodes are primitive operations
(like matrix mulitplication), and edges represent numeric data in the form of vectors, matrices, or
tensors. In its simplest form, this graph can be constructed as a linear series of nodes or “layers”.
The term “deep” refers to models with many such layers.
In Section 16.2 we discuss some of the basic building blocks (node types) that are used in the field.
In Section 16.3 we give examples of common architectures which are constructed from these building
blocks. In Section 6.2 we show how we can efficiently compute the gradient of functions defined on
such graphs. If the function computes the scalar loss of the model’s predictions given a training set,
we can pass this gradient to an optimization routine, such as those discussed in Chapter 6, in order
to fit the model. Fitting such models to data is called “deep learning”.
We can combine DNNs with probabilistic models in two different ways. The first is to use them
to define nonlinear functions which are used inside conditional distributions. For example, we may
construct a classifier using p(y|x, θ) = Cat(y|softmax(f(x; θ))), where f(x; θ) is a neural network
that maps inputs x and parameters θ to output logits. Or we may construct a joint probability
distribution over multiple variables using a directed graphical model (Chapter 4) where each CPD
p(xi
|pa(xi)) is a DNN. This lets us construct expressive probability models.
The other way we can combine DNNs and probabilistic models is to use DNNs to approximate
the posterior distribution, i.e., we learn a function f to compute q(z|f(D; φ)), where z are the
hidden variables (latents and/or parameters), D are the observed variables (data), f is an inference
network, and φ are its parameters; for details, see Section 10.1.5. Note that in this latter, setting
the joint model p(z, D) may be a “traditional” model without any “neural” components. For example,
it could be a complex simulator. Thus the DNN is just used for computational purposes, not
statistical/modeling purposes.
More details on DNNs can be found in such books as [Zha+20a; Cho21; Gér19; GBC16; Raf22], as
well as a multitude of online courses. For a more theoretical treatment, see e.g., [Ber+21; Cal20;
Aro+21; RY21].
16.2 Building blocks of differentiable circuits
In this section we discuss some common building blocks used in constructing neural networks. We
denote the input to a block as x and the output as y.624
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a)
Sum
...
...
(b)
Figure 16.1: An artiticial “neuron”, the most basic building block of a DNN. (a) The output y is a weighted
combination of the inputs x, where the weights vector is denoted by w. (b) Alternative depiction of the
neuron’s behavior. The bias term b can be emulated by defining wN = b and XN = 1.
16.2.1 Linear layers
The most basic building block of a DNN is a single “neuron”, which corresponds to a real-valued
signal y computed by multiplying a vector-valued input signal x by a weight vector w, and then
adding a bias term b. That is,
y = f(x; θ) = wTx + b (16.1)
where θ = (w, b) are the parameters for the function f. This is depicted in Figure 16.1. (The bias
term is omitted for clarity.)
It is common to group a set of neurons together into a layer. We can then represent the activations
of a layer with D units as a vector z ∈ R
D. We can transform an input vector of activations x into
an output vector y by multiplying by a weight matrix W, an adding an offset vector or bias term b
to get
y = f(x; θ) = Wx + b (16.2)
where θ = (W, b) are the parameters for the function f. This is called a linear layer, or fully
connected layer.
It is common to prepend the bias vector onto the first column of the weight matrix, and to append
a 1 to the vector x, so that we can write this more compactly as x = W˜ Tx˜, where W˜ = [W, b] and
x˜ = [x, 1]. This allows us to ignore the bias term from our notation if we want to.
16.2.2 Nonlinearities
A stack of linear layers is equivalent to a single linear layer where we multliply together all the
weight matrices. To get more expressive power we can transform each layer by passing it elementwise
(pointwise) through a nonlinear function called an activation function. This is denoted by
y = ϕ(x) = [ϕ(x1), . . . , ϕ(xD)] (16.3)
See Table 16.1 for a list of some common activation functions, and Figure 16.2 for a visualization.
For more details, see e.g., [Mur22, Sec 13.2.3].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
16.2. BUILDING BLOCKS OF DIFFERENTIABLE CIRCUITS
Name Definition Range Reference
Sigmoid σ(a) = 1
1+e−a [0, 1]
Hyperbolic tangent tanh(a) = 2σ(2a) − 1 [−1, 1]
Softplus σ+(a) = log(1 + e
a
) [0, ∞] [GBB11]
Rectified linear unit ReLU(a) = max(a, 0) [0, ∞] [GBB11; KSH12a]
Leaky ReLU max(a, 0) + α min(a, 0) [−∞, ∞] [MHN13]
Exponential linear unit max(a, 0) + min(α(e
a − 1), 0) [−∞, ∞] [CUH16]
Swish aσ(a) [−∞, ∞] [RZL17]
GELU aΦ(a) [−∞, ∞] [HG16]
Table 16.1: List of some popular activation functions for neural networks.
−4 −2 0 2 4
−0.5
0.0
0.5
1.0
1.5
2.0
Activation function
sigmoid
leaky-relu
elu
swish
gelu
(a)
−4 −2 0 2 4
−0.5
0.0
0.5
1.0
1.5
2.0
Gradient of activation function
sigmoid
leaky-relu
elu
swish
gelu
(b)
Figure 16.2: (a) Some popular activation functions. “ReLU” stands for “restricted linear unit”. “GELU”
stands for “Gaussian error linear unit”. (b) Plot of their gradients. Generated by activation_fun_deriv.ipynb.
16.2.3 Convolutional layers
When dealing with image data, we can apply the same weight matrix to each local patch of the
image, in order to reduce the number of parameters. If we “slide” this weight matrix over the image
and add up the results, we get a technique known as convolution; in this case the weight matrix is
often called a “kernel” or “filter”.
More precisely, let X ∈ R
H×W be the input image, and W ∈ R
h×w be the kernel. The output is
denoted by Z = X ⊛W, where (ignoring boundary conditions) we have the following:1
Zi,j =
h
X−1
u=0
wX−1
v=0
xi+u,j+vwu,v (16.4)
Essentially we compare a local patch of x, of size h × w and centered at (i, j), to the filter w; the
output just measures how similar the input patch is to the filter. We can define convolution in 1d or
3d in an analogous manner. Note that the spatial size of the outputs may be smaller than inputs,
1. Note that, technically speaking, we are using cross correlation rather than convolution. However, these terms are
used interchangeably in deep learning.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license626
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
1 0 -1
1 0 -1
1 0 -1
4 9 2 5 8 3
5 6 2 4 0 3
2 4 5 4 5 2
5 6 5 4 7 8
5 7 7 9 2 1
5 8 5 3 8 4
4 9 2 5 8 3
5 6 2 4 0 3
2 4 5 4 5 2
5 6 5 4 7 8
5 7 7 9 2 1
5 8 5 3 8 4
4 9 2 5 8 3
5 6 2 4 0 3
2 4 5 4 5 2
5 6 5 4 7 8
5 7 7 9 2 1
5 8 5 3 8 4
1 0 -1
1 0 -1
1 0 -1
1 0 -1
1 0 -1
1 0 -1
1 0 -1
1 0 -1
1 0 -1
1 0 -1
1 0 -1
1 0 -1
0 0 0
1 1 1
-1 -1 -1
Input
Filter 1
*
Filter 2
=
=
Output
6 x 6 x 3
3 x 3 x 3
3 x 3 x 3 4 x 4
4 x 4
4 x 4 x 2
Figure 16.3: A 2d convolutional layer with 3 input channels and 2 output channels. The kernel has size 3 × 3
and we use stride 1 with 0 padding, so the 6 × 6 input gets mapped to the 4 × 4 output.
due to boundary effects, although this can be solved by using padding. See [Mur22, Sec 14.2.1] for
more details.
We can repeat this process for multiple layers of inputs, and by using multiple filters, we can
generate multiple layers of output. In general, if we have C input channels, and we want to map it
to D output (feature) channels, then we define D kernels, each of size h × w × C, where h, w are the
height and width of the kernel. The d’th output feature map is obtained by convolving all C input
feature maps with the d’th kernel, and then adding up the results elementwise:
zi,j,d =
h
X−1
u=0
wX−1
v=0
C
X−1
c=0
xi+u,j+v,cwu,v,c,d (16.5)
This is called a convolutional layer, and is illustrated in Figure 16.3.
The advantage of a convolutional layer compared to using a linear layer is that the weights of
the kernel are shared across locations in the input. Thus if a pattern in the input shifts locations,
the corresponding output activation will also shift. This is called shift equivariance. In some
cases, we want the output to be the same, no matter where the input pattern occurs; this is called
shift invariance, and can be obtained by using a pooling layer, which computes the maximum or
average value in each local patch of the input. (Note that pooling layers have no free (learnable)
parameters.) Other forms of invariance can also be captured by neural networks (see e.g., [CW16;
FWW21]).
16.2.4 Residual (skip) connections
If we stack a large number of nonlinear layers together, the signal may get squashed to zero or may
blow up to infinity, depending on the magnitude of the weights, and the nature of the nonlinearities.
Similar problems can plague gradients that are passed backwards through the network (see Section 6.2).
To reduce the effect of this we can add skip connections, also called residual connections, which
allow the signal to skip one or more layers, which prevents it from being modified. For example,
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
16.2. BUILDING BLOCKS OF DIFFERENTIABLE CIRCUITS
Conv Nonlin
Figure 16.4: A residual connection around a convolutional layer.
Figure 16.4 illustrates a network that computes
y = f(x;W) = ϕ(conv(x;W)) + x (16.6)
Now the convolutional layer only needs to learn an offset or residual to add (or subtract) to the input
to match the desired output, rather than predicting the output directly. Such residuals are often
small in size, and hence are easier to learn using neurons with weights that are bounded (e.g., close
to 1).
16.2.5 Normalization layers
To learn an input-output mapping, it is often best if the inputs are standardized, meaning that
they have zero mean and unit standard deviation. This ensures that the required magnitude of the
weights is small, and comparable across dimensions. To ensure that the internal activations have this
property, it is common to add normalization layers.
The most common approach is to use batch normalization (BN) [IS15]. However this relies
on having access to a batch of B > 1 input examples. Various alternatives have been proposed
to overcome the need of having an input batch, such as layer normalization [BKH16], instance
normalization [UVL16], group normalization [WH18], filter response normalization [SK20],
etc. More details can be found in [Mur22, Sec 14.2.4].
16.2.6 Dropout layers
Neural networks often have millions of parameters, and thus can sometimes overfit, especially when
trained on small datasets. There are many ways to ameliorate this effect, such as applying regularizers
to the weights, or adopting a fully Bayesian approach (see Chapter 17). Another common heuristic
is known as dropout [Sri+14a], in which edges are randomly omitted each time the network is used,
as illustrated in Figure 16.5. More precisely, if wlij is the weight of the edge from node i in layer
l − 1 to node j in layer l + 1, then we replace it with θlij = wlij ǫli, where ǫli ∼ Ber(1 − p), where p is
the drop probability, and 1 − p is the keep probability. Thus if we sample ǫli = 0, then all of the
weights going out of unit i in layer l − 1 into any j in layer l will be set to 0.
During training, the gradients will be zero for the weights connected to a neuron which has been
switched “off”. However, since we resample ǫlij every time the network is used, different combinations
of weights will be updated on each step. The result is an ensemble of networks, each with slightly
different sparse graph structures.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license628
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 16.5: Illustration of dropout. (a) A standard neural net with 2 hidden layers. (b) An example of a
thinned net produced by applying dropout with p = 0.5. Units that have been dropped out are marked with an
x. From Figure 1 of [Sri+14a]. Used with kind permission of Geoff Hinton.
Figure 16.6: Attention layer. (a) Mapping a single query q to a single output, given a set of keys and values.
From Figure 10.3.1 of [Zha+20a]. Used with kind permission of Aston Zhang.
At test time, we usually turn the dropout noise off, so the model acts deterministically. To ensure
the weights have the same expectation at test time as they did during training (so the input activation
to the neurons is the same, on average), at test time we should use E [θlij ] = wlijE [ǫli]. For Bernoulli
noise, we have E [ǫ] = 1 − p, so we should multiply the weights by the keep probability, 1 − p, before
making predictions. We can, however, use dropout at test time if we wish. This is called Monte
Carlo dropout (see Section 17.3.1).
16.2.7 Attention layers
In all of the neural networks we have considered so far, the hidden activations are a linear combination
of the input activations, followed by a nonlinearity: Z = ϕ(XW), where X ∈ R
n×d are the hidden
feature vectors, and W ∈ R
d×dv are a fixed set of weights that are learned on a training set to
produce Z ∈ R
n×dv outputs. However, we can imagine a more flexible model in which the weights
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
16.2. BUILDING BLOCKS OF DIFFERENTIABLE CIRCUITS
Figure 16.7: (a) Scaled dot-product attention in matrix form. (b) Multi-head attention. From Figure 2 of
[Vas+17b]. Used with kind permission of Ashish Vaswani.
depend on the inputs, i.e., Z = ϕ(XW(X)), where W(X) is a function to be defined below. This
kind of multiplicative interaction is called attention.
We can better understand attention by comparing it to non-parametric kernel based prediction
methods, such as Gaussian processes (Chapter 18). In this approach we compare the input query
x ∈ R
d
to each of the training examples X = (x1, . . . , xn) using a kernel to get a vector of similarity
scores, α = [K(x, xi)]n
i=1. We then use this to retrieve a weighted combination of the corresponding
m target values yi ∈ R
dv to compute the predicted output, as follows:
yˆ =
Xn
i=1
αiyi (16.7)
See Section 18.3.7 for details.
We can make a differentiable and parametric version of this as follows (see [Tsa+19] for details).
First we replace the stored examples matrix X with a learned embedding, to create a set of stored
keys, K = XWk ∈ R
n×dk . Similarly we replace the stored output matrix Y with a learned
embedding, to create a set of stored values, V = YWv ∈ R
n×dv . Finally we embed the input to
create a query, q = Wqx ∈ R
dk . The parameters to be learned are the three embedding matrices.
Next, we replace fixed kernel function with a soft attention layer. More precisely, we define the
weighted output for query q to be
Attn(q,(k1, v1), . . . ,(kn, vn)) = Attn(q,(k1:n, v1:n)) = Xn
i=1
αi(q, k1:n)vi (16.8)
where αi(q, k1:n) is the i’th attention weight; these weights satisfy 0 ≤ αi(q, k1:n) ≤ 1 for each i
and P
i αi(q, k1:n) = 1.
The attention weights can be computed from an attention score function a(q, ki) ∈ R, that
computes the similarity of query q to key ki
. For example, we can use (scaled) dot product
attention, which has the form
a(q, k) = q
Tk/
p
dk (16.9)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license630
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(The scaling by √
dk is to reduce the dependence of the output on the dimensionality of the vectors.)
Given the scores, we can compute the attention weights using the softmax function:
αi(q, k1:n) = softmaxi([a(q, k1), . . . , a(q, kn)]) = exp(a(q, ki))
Pn
j=1 exp(a(q, kj )) (16.10)
See Figure 16.6 for an illustration.
In some cases, we want to restrict attention to a subset of the dictionary, corresponding to valid
entries. For example, we might want to pad sequences to a fixed length (for efficient minibatching),
in which case we should “mask out” the padded locations. This is called masked attention. We
can implement this efficiently by setting the attention score for the masked entries to a large negative
number, such as −106
, so that the corresponding softmax weights will be 0.
For efficiently, we usually compute all n vectors in parallel. Let the corresponding matrices of
queries, keys and values be denoted by Q ∈ R
n×dk , K ∈ R
n×dk , V ∈ R
n×dv . Let
zj =
Xn
i=1
αi(qj , K)vi (16.11)
be the j’th output corresponding to the j’th query. We can compute all outputs Z ∈ R
n×dv in
parallel using
Z = Attn(Q, K, V) = softmax(QKT
√
dk
)V (16.12)
where the softmax function softmax is applied row-wise. See Figure 16.7 (left) for an illustration.
To increase the flexibility of the model, we often use a multi-head attention layer, as illustrated
in Figure 16.7 (right). Let the i’th head be
hi = Attn(QWQ
i
, KWK
i
, VWV
i
) (16.13)
where WQ
i ∈ R
d×dk , WK
i ∈ R
d×dk and WV
i ∈ R
d×dv are linear projection matrices. We define the
output of the MHA layer to be
Z = MHA(Q, K, V) = Concat(h1, . . . , hh)WO (16.14)
where h is the number of heads, and WO ∈ R
hdv×d
. Having multiple heads can increase performance
of the layer, in the event that some of the weight matrices are poorly initialized; after training, we
can often remove all but one of the heads [MLN19].
When the output of one attention layer is used as input to another, the method is called self￾attention. This is the basis of the transformer model, which we discuss in Section 16.3.5.
16.2.8 Recurrent layers
We can make the model be stateful by augmenting the input x with the current state st, and then
computing the output and the new state using some kind of function:
(y, st+1) = f(x, st) (16.15)
This is called a recurrent layer, as shown in Figure 16.8. This forms the basis of recurrent neural
networks, discussed in Section 16.3.4. In a vanilla RNN, the function f is a simple MLP, but it
may also use attention (Section 16.2.7).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
16.2. BUILDING BLOCKS OF DIFFERENTIABLE CIRCUITS
Weight Matrix 
Figure 16.8: Recurrent layer.
16.2.9 Multiplicative layers
In this section, we discuss multiplicative layers, which are useful for combining different information
sources. Our presentation follows [Jay+20].
Suppose we have inputs x ∈ R
n and z ∈ R
m, In a linear layer (and, by extension, convolutional
layers), it is common to concatenate the inputs to get f(x, z) = W[x; z]+b, where W ∈ R
k×(m+n) and
b ∈ R
k
. We can increase the expressive power of the model by using multiplicative interactions,
such as the following bilinear form:
f(x, z) = z
TWx + Uz + Vx + b (16.16)
where W ∈ R
m×n×k
is a weight tensor, defined such that
(z
TWx)k =
X
ij
ziWijkxj (16.17)
That is, the k’th entry of the output is the weighted inner product of z and x, where the weight
matrix is the k’th “slice” of W. The other parameters have size U ∈ R
k×m, V ∈ R
k×n, and b ∈ R
k
.
This formulation includes many interesting special cases. In particular, a hypernetwork [HDL17]
can be viewed in this way. A hypernetwork is a neural network that generates parameters for another
neural network. In particular, we replace f(x; θ) with f(x; g(z; φ)). If f and g are affine, this is
equivalent to a multiplicative layer. To see this, let W′ = z
TW + V and b
′ = Uz + b. If we define
g(z; Φ) = [W′
, b
′
], and f(x; θ) = W′x + b
′
, we recover Equation (16.16).
We can also view the gating layers used in RNNs (Section 16.3.4) as a form of multiplicative
interaction. In particular, if the hypernetwork computes the diagonal matrix W′ = σ(z
TW + V) =
diag(a1, . . . , an), then we can define f(x, z; θ) = a(z) ⊙ x, which is the standard gating mechanism.
Attention mechanisms (Section 16.2.7) are also a form of multiplicative interaction, although they
involve three-way interactions, between query, key, and value.
Another variant arises if the hypernetwork just computes a scalar weight for each channel of a
convolutional layer, plus a bias term:
f(x, z) = a(z) ⊙ x + b(z) (16.18)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license632
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 16.9: Explicit vs implicit layers.
This is called FiLM, which stands for “feature-wise linear modulation” [Per+18]. For a de￾tailed tutorial on the FiLM layer and its many applications, see https://distill.pub/2018/
feature-wise-transformations.
16.2.10 Implicit layers
So far we have focused on explicit layers, which specify how to transform the input to the output
using y = f(x). We can also define implicit layers, which specify the output indirectly, in terms of
a constraint function:
y ∈ argmin
y
f(x, y) such that g(x, y) = 0 (16.19)
The details on how to find a solution to this constrained optimization problem can vary depending
on the problem. For example, we may need to run an inner optimization routine, or call a differential
equation solver. The main advantage of this approach is that the inner computations do not need to
be stored explicitly, which saves a lot of memory. Furthermore, once the solution has been found, we
can propagate gradients through the whole layer, by leveraging the implicit function theorem. This
lets us use higher level primitives inside an end-to-end framework. For more details, see [GHC21]
and http://implicit-layers-tutorial.org/.
16.3 Canonical examples of neural networks
In this section, we give several “canonical” examples of neural network architectures that are widely
used for different tasks.
16.3.1 Multilayer perceptrons (MLPs)
A multilayer perceptron (MLP), also called a feedforward neural network (FFNN), is one
of the simplest kinds of neural networks. It consists of a series of L linear layers, combined with
elementwise nonlinearities:
f(x; θ) = WLϕL(WL−1ϕL−1(· · · ϕ1(W1x)· · ·)) (16.20)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
16.3. CANONICAL EXAMPLES OF NEURAL NETWORKS
x1
xd
xD
h
(1)
1
h
(1)
j
h
(1)
K1
h
(2)
1
h
(2)
k
h
(2)
K2
y1
yC
.
.
.
.
.
.
.
.
.
.
.
.
w
(2)
jk
Figure 16.10: A feedforward neural network with D inputs, K1 hidden units in layer 1, K2 hidden units in
layer 2, and C outputs. w
(l)
jk is the weight of the connection from node j in layer l − 1 to node k in layer l.
For example, Figure 16.10 shows an MLP with 1 input layer of D units, 2 hidden layers of K1 and
K2 units, and 1 output layer with C units. The k’th hidden unit in layer l is given by
h
(l)
k = ϕl

b
(l)
k +
K
Xl−1
j=1
w
(l)
jk h
(l−1)
j

 (16.21)
where ϕl
is the nonlinear activation function at layer l.
For a classification problem, the final nonlinearity is usually the softmax function. However, it is
also common for the final layer to have linear activations, in which case the outputs are interpreted
as logits; the loss function used during training then converts to (log) probabilities internally.
We can also use MLPs for regression. Figure 16.11 shows how we can make a model for het￾eroskedastic nonlinear regression. (The term “heteroskedastic” just means that the predicted output
variance is input-dependent, rather than a constant.) This function has two outputs which compute
fµ(x) = E [y|x, θ] and fσ(x) = p
V [y|x, θ]. We can share most of the layers (and hence parameters)
between these two functions by using a common “backbone” and two output “heads”, as shown in
Figure 16.11. For the µ head, we use a linear activation, ϕ(a) = a. For the σ head, we use a softplus
activation, ϕ(a) = σ+(a) = log(1 + e
a
). If we use linear heads and a nonlinear backbone, the overall
model is given by
p(y|x, θ) = N
￾
y|wT
µf(x; wshared), σ+(wT
σf(x; wshared))
(16.22)
16.3.2 Convolutional neural networks (CNNs)
A vanilla convolutional neural network or CNN consists of a series of convolutional layers,
pooling layers, linear layers, and nonlinearities. See Figure 16.12 for an example. More sophisticated
architectures, such as the ResNet model [He+16a; He+16b], add skip (residual) connections,
normalization layers, etc. The ConvNeXt model of [Liu+22b] is considered the current (as of
February 2022) state of the art CNN architecture for a wide variety of vision tasks. See e.g., [Mur22,
Ch.14] for more details on CNNs.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens634
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
y
σ
x µ
Figure 16.11: Illustration of an MLP with a shared “backbone” and two output “heads”, one for predicting
the mean and one for predicting the variance. From https: // brendanhasz. github. io/ 2019/ 07/ 23/
bayesian-density-net. html . Used with kind permission of Brendan Hasz.
Figure 16.12: One of the first CNNs ever created, for classifying MNIST images. From Figure 3 of [LeC+89].
For a “modern” implementation, see lecun1989.ipynb.
16.3.3 Autoencoders
An autoencoder is a neural network that maps inputs x to a low-dimensional latent space using an
encoder, z = fe(x), and then attempts to reconstruct the inputs using a decoder, xˆ = fd(z). The
model is trained to minimize
L(θ) = ||r(x) − x||2
2
(16.23)
where r(x) = fd(fe(x)). (We can also replace squared error with more general conditional log
likelihoods.) See Figure 16.13 for an illustration of a 3 layer AE.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
16.3. CANONICAL EXAMPLES OF NEURAL NETWORKS
x1
x2
x3
x4
x5
x6
Input Layer Latent
Representation
xˆ1
xˆ2
xˆ3
xˆ4
xˆ5
xˆ6
Output Layer
Figure 16.13: Illustration of an autoencoder with 3 hidden layers.
(a)
(b) (c)
Figure 16.14: (a) Some MNIST digits. (b) Reconstruction of these images using a convolutional autoencoder.
(c) t-SNE visualization of the 20-d embeddings. The colors correspond to class labels, which were not used
during training. Generated by ae_mnist_conv_jax.ipynb.
For image data, we can make the encoder be a convolutional network, and the decoder be a
transpose convolutional network. We can use this to compute low dimensional embeddings of image
data. For example, suppose we fit such a model to some MNIST digits. We show the reconstruction
abilities of such a model in Figure 16.14b. In Figure 16.14c, we show a 2d visualization of the
20-dimensional embedding space computed using t-SNE. The colors correspond to class labels, which
were not used during training. We see fairly good separation, showing that images which are visually
similar are placed close to each other in the embedding space, as desired. (See also Section 21.2.3,
where we compare AEs with variational AEs.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license636
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
yt
ht
yt+1
(a)
y1 y2 y3
h1 h2 h3
(b)
Figure 16.15: Illustration of a recurrent neural network (RNN). (a) With self-loop. (b) Unrolled in time.
16.3.4 Recurrent neural networks (RNNs)
A recurrent neural network (RNN) is a network with a recurrent layer, as in Equation (16.15).
This is illustrated in Figure 16.15. Formally this defines the following probability distribution over
sequences:
p(y1:T ) = X
h1:T
p(y1:T , h1:T ) = X
h1:T
I(h1 = h
∗
1
) p(y1|h1)
Y
T
t=2
p(yt|ht)I(ht = f(ht−1, yt−1)) (16.24)
where ht is the deterministic hidden state, computed from the last hidden state and last output
using f(ht−1, yt−1). (At training time, yt−1 is observed, but at prediction time, it is generated.)
In a vanilla RNN, the function f is a simple MLP. However, we can also use attention to selectively
update parts of the state vector based on similarity between the input the previous state, as in the
GRU (gated recurrent unit) model, and the LSTM (long short term memory) model. We can also
make the model into a conditional sequence model, by feeding in extra inputs to the f function. See
e.g., [Mur22, Ch. 15] for more details on RNNs.
16.3.5 Transformers
Consider the problem of classifying each word in a sentence, for example with its part of speech tag
(noun, verb, etc). That is, we want to learn a mapping f : X → Y, where X = V
T
is the set of
input sequences defined over (word) vocabulary V, T is the length of the sentence, and Y = T
T
is
the set of output sequences, defined over (tag) vocabulary T . To do well at this task, we need to
learn a contextual embedding of each word. RNNs process one token at a time, so the embedding of
the word at location t, zt, depends on the hidden state of the network, st, which may be a lossy
summary of all the previously seen words. We can create bidirectional RNNs so that future words
can also affect the embedding of zt, but this dependence is still mediated via the hidden state. An
alternative approach is to compute zt as a direct function of all the other words in the sentence,
by using the attention operator discussed in Section 16.2.7 rather than using hidden state. This is
called an (encoder-only) transformer, and is used by models such as BERT [Dev+19]. This idea is
sketched in Figure 16.16.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
16.3. CANONICAL EXAMPLES OF NEURAL NETWORKS
This is a sentence RNN
This is another sentence Transf.
Translation? 
Sentiment?
Next word? 
Part-of-speech tags? 
Figure 16.16: Visualizing the difference between an RNN and a transformer. From [Jos20]. Used with kind
permission of Chaitanya Joshi.
It is also possible to create a decoder-only transformer, in which each output yt only attends to all
the previously generated outputs, y1:t−1. This can be implemented using masked attention, and is
useful for generative language models, such as GPT (see Section 22.4.1). We can combine the encoder
and decoder to create a conditional sequence-to-sequence model, p(y1:Ty
|x1:Tx
), as proposed in the
original transformer paper [Vas+17c]. See Supplementary Section 16.1.1 and [PH22] for more details.
It has been found that large transformers are very flexible sequence-to-sequence function approx￾imators, if trained on enough data (see e.g., [Lin+21a] for a review in the context of NLP, and
[Kha+21; Han+20; Zan21] for reviews in the context of computer vision). The reasons why they
work so well are still not very clear. However, some initial insights can be found in, e.g., [Rag+21;
WGY21; Nel21; BP21]. See also Supplementary Section 16.1.2.5 where we discuss the connection
with graph neural networks.
16.3.6 Graph neural networks (GNNs)
It is possible to define neural networks for working with graph-structured data. These are called
graph neural networks or GNNs. See Supplementary Section 16.1.2 for details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license17 Bayesian neural networks
This chapter is coauthored with Andrew Wilson.
17.1 Introduction
Deep neural networks (DNNs) are usually trained using a (penalized) maximum likelihood objective
to find a single setting of parameters. However, large flexible models like neural networks can
represent many functions, corresponding to different parameter settings, which fit the training data
well, yet generalize in different ways. (This phenomenon is known as underspecification (see e.g.,
[D’A+20]; see Figure 17.11 for an illustration.) Considering all of these different models together
can lead to improved accuracy and uncertainty representation. This can be done by computing the
posterior predictive distribution using Bayesian model averaging:
p(y|x, D) = Z
p(y|x, θ)p(θ|D)dθ (17.1)
where p(θ|D) ∝ p(θ)p(D|θ).
The main challenges in applying Bayesian inference to DNNs are specifying suitable priors, and
efficiently computing the posterior, which is challenging due to the large number of parameters and
the large datasets. The application of Bayesian inference to DNNs is sometimes called Bayesian
deep learning or BDL. By contrast, the term deep Bayesian learning or DBL refers to the
use of deep models to help speed up Bayesian inference of “classical” models, usually by training
amortized inference networks that can be used as part of a variational inference or importance
sampling algorithm, as discussed in Section 10.1.5.) For more details on the topic of BDL, see e.g.,
[PS17; Wil20; WI20; Jos+22; Kha20; MI23].
17.2 Priors for BNNs
To perform Bayesian inference for the parameters of a DNN, we need to specify a prior p(θ). [Nal18;
WI20; For22] discusses the issue of prior selection at length. Here we just give a brief summary of
common approaches.640
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.2.1 Gaussian priors
Consider an MLP with one hidden layer with activation function ϕ and a linear output:
f(x; θ) = W2ϕ(W1x + b1) + b2 (17.2)
(If the output is nonlinear, such as a softmax transform, we can fold it into the loss function during
training.) If we have two hidden layers this becomes
f(x; θ) = W3 (ϕ (W2ϕ(W1x + b1) + b2)) + b3 (17.3)
In general, with L − 1 hidden layers and a linear output, we have
f(x; θ) = WL (· · · ϕ(W1x + b1)) + bL (17.4)
We need to specify the priors for Wl and bl for l = 1 : L. The most common choice is to use a
factored Gaussian prior:
Wℓ ∼ N (0, α2
ℓ
I), bℓ ∼ N (0, β2
ℓ
I) (17.5)
The Xavier initialization or Glorot initialization, named after the first author of [GB10], is to
set
α
2
ℓ =
2
nin + nout
(17.6)
where nin is the fan-in of a node in level ℓ (number of weights coming into a neuron), and nout is
the fan-out (number of weights going out of a neuron). LeCun initialization, named after Yann
LeCun, corresponds to using
α
2
ℓ =
1
nin
(17.7)
We can get a better understanding of these priors by considering the effect they have on the
corresponding distribution over functions that they define. To help understand this correspondence,
let us reparameterize the model as follows:
Wℓ = αℓηℓ
, ηℓ ∼ N (0, I), bℓ = βℓǫℓ, ǫℓ ∼ N (0, I) (17.8)
Hence every setting of the prior hyperparameters specifies the following random function:
f(x; α, β) = αLηL(· · · ϕ(α1η1x + β1ǫ1)) + βLǫL (17.9)
To get a feeling for the effect of these hyperparameters, we can sample MLP parameters from this
prior and plot the resulting random functions. We use a sigmoid nonlinearity, so ϕ(a) = σ(a). We
consider L = 2 layers, so W1 are the input-to-hidden weights, and W2 are the hidden-to-output
weights. We assume the input and output are scalars, so we are generating random nonlinear 1d
mappings f : R → R.
Figure 17.1(a) shows some sampled functions where α1 = 5, β1 = 1, α2 = 1, β2 = 1. In
Figure 17.1(b) we increase α1; this allows the first layer weights to get bigger, making the sigmoid-like
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.2. PRIORS FOR BNNS
−1.0 −0.5 0.0 0.5 1.0
x
−10
0
10
y
α1 = 5, β1 = 1, α2 = 1, β2 = 1
(a)
−1.0 −0.5 0.0 0.5 1.0
x
−10
0
10
y
α1 = 25, β1 = 1, α2 = 1, β2 = 1
(b)
−1.0 −0.5 0.0 0.5 1.0
x
−10
0
10
y
α1 = 5, β1 = 5, α2 = 1, β2 = 1
(c)
−1.0 −0.5 0.0 0.5 1.0
x
−10
0
10
y
α1 = 5, β1 = 1, α2 = 5, β2 = 1
(d)
Figure 17.1: The effects of changing the hyperparameters on an MLP with one hidden layer. (a) Random
functions sampled from a Gaussian prior with hyperparameters α1 = 5, β1 = 1, α2 = 1, β2 = 1. (b) Increasing
α1 by a factor of 5. (c) Increasing β1 by a factor of 5. (d) Inreasing α2 by a factor of 5. Generated by
mlp_priors_demo.ipynb.
shape of the functions steeper. In Figure 17.1(c), we increase β1; this allows the first layer biases to
get bigger, which allows the center of the sigmoid to shift left and right more, away from the origin.
In Figure 17.1(d), we increase α2; this allows the second layer linear weights to get bigger, making
the functions more “wiggly” (greater sensitivity to change in the input, and hence larger dynamic
range).
The above results are specific to the case of sigmoidal activation functions. ReLU units can behave
differently. For example, [WI20, App. E] show that for MLPs with ReLU units, if we set βℓ = 0, so
the bias terms are all zero, the effect of changing αℓ is just to rescale the output. To see this, note
that Equation (17.9) simplifies to
f(x; α, β = 0) = αLηL(· · · ϕ(α1η1x)) = αL · · · α1ηL(· · · ϕ(η1x)) (17.10)
= αL · · · α1f(x; (α = 1, β = 0)) (17.11)
where we used the fact that for ReLU, ϕ(αz) = αϕ(z) for any positive α, and ϕ(αz) = 0 for any
negative α (since the preactivation z ≥ 0). In general, it is the ratio of α and β that matters for
determining what happens to input signals as they propagate forwards and backwards through a
randomly initialized model; for details, see e.g., [Bah+20].
We see that initializing the model’s parameters at a particular random value is like sampling a
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license642
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
point from this prior over functions. In the limit of infinitely wide neural networks, we can derive
this prior distribution analytically: this is known as a neural network Gaussian process, and is
explained in Section 18.7.
17.2.2 Sparsity-promoting priors
Although Gaussian priors are simple and widely used, they are not the only option. For some
applications, it is useful to use sparsity promoting priors, such as the Laplace, which encourage
most of the weights (or channels in a CNN) to be zero (cf. Section 15.2.6). For details, see [Hoe+21].
17.2.3 Learning the prior
We have seen how different priors for the parameters correspond to different priors over functions.
We could in principle set the hyperparameters (e.g., the α and β parameters of the Gaussian prior)
using grid search to optimize cross-validation loss. However, cross-validation can be slow, particularly
if we allow different priors for each layer of the network, as our grid search will grow exponentially
with the number of hyperparameters we wish to determine.
An alternative is to use gradient based methods to optimize the marginal likelihood
log p(D|α, β) = Z
log p(D|θ)p(θ|α, β)dθ (17.12)
This approach is known as empirical Bayes (Section 3.7) or evidence maximization, since
log p(D|α, β) is also called the evidence [Mac92a; WS93; Mac99]. This can give rise to sparse
models, as we discussed in the context of automatic relevancy determination (Section 15.2.8). Unfor￾tunately, computing the marginal likelihood is computationally difficult for large neural networks.
Learning the prior is more meaningful if we can do it on a separate, but related dataset. In
[SZ+22] they propose to train a model on an initial, large dataset D1 (possibly unsupervised) to
get a point estimate, θˆ
1, from which they can derive an approximate low-rank Gaussian posterior,
using the SWAG method (Section 17.3.8). They then use this informative prior when fine-tuning
the model on a downstream dataset D2. The fine-tuning can either be a MAP estimate θˆ
2 or some
approximate posterior, p(θ2|D2, D1), e.g., computed using MCMC (Section 17.3.7). They call this
technique “Bayesian transfer learning”. (See Section 19.5.1 for more details on transfer learning.)
17.2.4 Priors in function space
Typically, the relationship between the prior distribution over parameters and the functions preferred
by the prior is not transparent. In some cases, it can be possible to pick more informative priors
based on principles such as desired invariances that we want the function to satisfy (see e.g., [Nal18]).
[FBW21] introduces residual pathway priors, providing a mechanism for encoding high level concepts
into prior distributions, such as locality, independencies, and symmetries, without constraining model
flexibility. A different approach to encoding interpretable priors over functions leverages kernel
methods such as Gaussian processes (e.g., [Sun+19a]), as we discuss in Section 18.1.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.3. POSTERIORS FOR BNNS
17.2.5 Architectural priors
Beyond specifying the parametric prior, it is important to note that the architecture of the model
can have an even larger effect on the induced distribution over functions, as argued in Wilson and
Izmailov [WI20] and Izmailov et al. [Izm+21b]. For example, a CNN architecture encodes prior
knowledge about translation equivariance, due to its use of convolution, and hierarchical structure,
due to its use of multiple layers. Other forms of inductive bias are induced by different architectures,
such as RNNs. (Models such as transformers have weaker inductive bias, but consequently often
need more data to perform well.) Thus we can think of the field of neural architecture search
(reviewed in [EMH19]) as a form of structural prior learning.
In fact, with a suitable architecture, we can often get good results using random (untrained) models.
For example, Ulyanov, Vedaldi, and Lempitsky [UVL18] showed that an untrained CNN with random
parameters (sampled from a Gaussian) often works very well for low-level image processing tasks,
such as image denoising, super-resolution, and image inpainting. The resulting prior over functions
has been called the deep image prior. Similarly, Pinto and Cox [PC12] showed that untrained
CNNs with the right structure can do well at face recognition. Moreover, Zhang et al. [Zha+17]
show that randomly initialized CNNs can process data to provide features that greatly improve the
performance of other models, such as kernel methods.
17.3 Posteriors for BNNs
There are a large number of different approximate inference schemes that have been applied to
Bayesian neural networks, with different strengths and limitations. In the sections below, we briefly
describe some of these.
17.3.1 Monte Carlo dropout
Monte Carlo dropout (MCD) [GG16; KG17] is a very simple and widely used method for
approximating the Bayesian predictive distribution. Usually stochastic dropout layers are added as a
form of regularization, and are “turned off” at test time, as described in Section 16.2.6, However, the
idea in MCD is to also perform random sampling at test time. More precisely, we drop out each
hidden unit by sampling from a Bernoulli(p) distribution; we repeat this procedure S times, to create
S distinct models. We then create an equally weighted average of the predictive distributions for
each of these models:
p(y|x, D) ≈
1
S
X
S
s=1
p(y|x, θ
s
) (17.13)
where θ
s
is a version of the MAP parameter estimate where we randomly drop out some connections.
We give an example of this process in action in Figure 17.2. We see that it succesfully captures
uncertainty due to “out of distribution” inputs. (See Section 19.3.2 for more discussion of OOD
detection.)
One drawback of MCD is that it is slow at test time. However this can be overcome by “distilling”
the model’s predictions into a deterministic “student” network, as we discuss in Section 17.3.10.3.
A more fundamental problem is that MCD does not give proper uncertainty estimates, as argued in
[Osb16; LF+21]. The problem is the following. Although MCD can be viewed as a form of variational
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license644
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
1 2 3 4 5 6 7 8 9 10 11 12
−10
0
10
20
Logits
1
5
7
(a)
1 2 3 4 5 6 7 8 9 10 11 12
0.0
0.2
0.4
0.6
0.8
1.0
Probability
1
5
7
(b)
Figure 17.2: Illustration of MC dropout applied to the LeNet architecture. The inputs are some rotated images
of the digit 1 from the MNIST dataset. (a) Softmax inputs (logits). (b) Softmax outputs (proabilities). We see
that the inputs are classified as digit 7 for the last three images (as shown by the probabilities), even though
the model has high uncertainty (as shown by the logits). Adapted from Figure 4 of [GG16]. Generated by
mnist_classification_mc_dropout.ipynb
inference [GG16], this is only true under a degenerate posterior approximation, corresponding to a
mixture of two delta functions, one at 0 (for dropped out nodes) and one at the MLE. This posterior
will not converge to the true posterior (which is a delta function at the MLE) even as the training
set size goes to infinity, since we are always dropping out hidden nodes with a constant probability p
[Osb16]. Fortunately this pathology can be fixed if the noise rate is optimized [GHK17]. For more
details, see e.g., [HGMG18; NHLS19; LF+21].
17.3.2 Laplace approximation
In Section 7.4.3, we introduced the Laplace approximation, which computes a Gaussian approximation
to the posterior, p(θ|D), centered at the MAP estimate, θ
∗
. The posterior prediction matrix is equal
to the Hessian of the negative log joint computed at the mode. The benefits of this approach are
that it is simple, and it can be used to derive a Bayesian estimate from a pretrained model. The
main disadvantage is that computing the Hessian can be expensive. In addition, it may not be
positive definite, since the log likelihood of DNNs is non-convex. It is therefore common to use a
Gauss-newton approximation to the Hessian instead, as we explain below.
Following the notation of [Dax+21], let f(xn, θ) ∈ R
C be the prediction function with C outputs,
and θ ∈ R
P be the parameter vector. Let r(y; f) = ∇f log p(y|f) be the residual1
, and Λ(y; f) =
−∇2
f
log p(y|f) be the per-input noise term. In addition, let J ∈ R
C×P be the Jacobian, [Jθ(x)]ci =
∂fc(x,θ)
∂θi
, and H ∈ R
C×P ×P be the Hessian, [Hθ(x)]cij =
∂
2
fc(x,θ)
∂θi∂θj
. Then the gradient and Hessian
1. In the Gaussian case, this term becomes ∇f ||y − f||2 = 2||y − f||, so it can be interpreted as a residual error.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.3. POSTERIORS FOR BNNS
of the log likelihood are given by the following [IKB21]:
∇θ log p(y|f(x, θ)) = Jθ(x)
T
r(y; f) (17.14)
∇2
θ
log p(y|f(x, θ)) = Hθ(x)
T
r(y; f) − Jθ(x)
TΛ(y; f)Jθ(θ) (17.15)
Since the network Hessian H is usually intractable to compute, it is usually dropped, leaving only the
Jacobian term. This is called the generalized Gauss-Newton or GGN approximation [Sch02;
Mar20]. The GGN approximation is guaranteed to be positive definite. By contrast, this is not
true for the original Hessian in Equation (17.15), since the objective is not convex. Furthermore,
computing the Jacobian term is cheaper to compute than the Hessian.
Putting it all together, for a Gaussian prior, p(θ) = N (θ|m0, S0), the Laplace approximation
becomes p(θ|D) ≈ (N |θ
∗
, ΣGGN), where
Σ
−1
GGN =
X
N
n=1
Jθ∗ (xn)
TΛ(yn; fn)Jθ∗ (xn) + S
−1
0
(17.16)
Unfortunately inverting this matrix takes O(P
3
) time, so for models with many parameters, further
approximations are usually used. The simplest is to use a diagonal approximation, which takes O(P)
time and space. A more sophisticated approach is presented in [RBB18a], which leverages the KFAC
(Kronecker factored curvature) approximation of [MG15]. This approximates the covariance of each
layer using a Kronecker product.
A limitation of the Laplace approximation is that the posterior covariance is derived from the
Hessian evaluated at the MAP parameters. This means Laplace forms a highly local approximation:
even if the non-Gaussian posterior could be well-described by a Gaussian distribution, the Gaussian
distribution formed using Laplace only captures the local characteristics of the posterior at the
MAP parameters — and may therefore suffer badly from local optima, providing overly compact
or diffuse representations. In addition, the curvature information is only used after the model has
been estimated, and not during the model optimization process. By contrast, variational inference
(Section 17.3.3) can provide more accurate approximations for comparable cost.
17.3.3 Variational inference
In fixed-form variational inference (Section 10.2), we choose a distribution for the posterior approxi￾mation qψ(θ)and minimize DKL (q k p), with respect to ψ. We often choose a Gaussian approximate
posterior, qψ(θ) = N (θ|µ, Σ), which lets us use the reparameterization trick to create a low variance
estimator of the gradient of the ELBO (see Section 10.2.1). Despite the use of a Gaussian, the
parameters that minimize the KL objective are often different what we would find with the Laplace
approximation (Section 17.3.2).
Variational methods for neural networks date back to at least Hinton and Camp [HC93]. In deep
learning, [Gra11] revisited variational methods, using a Gaussian approximation with a diagonal
covariance matrix. This approximates the distribution of every parameter in the model by a univariate
Gaussian, where the mean is the point estimate, and the variance captures the uncertainty, as shown in
Figure 17.3. This approach was improved further in [Blu+15], who used the reparameterization trick
to compute lower variance estimates of the ELBO; they called their method Bayes by backprop
(BBB). This is essentially identical to the SVI algorithm in Algorithm 10.2, except the likelihood
becomes p(yn|xn, θ) from the DNN, and the prior pξ(θ) and variational posterior qψ(θ) are Gaussians.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license646
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
x1
x2
h1
h2
h3
h4
y
x1
x2
h1
h2
h3
h4
y
0.2
0.05
−0.1
−0.25
0.55
0.4
0.25
0.1
0.2
0.55
0.9
1.25
Figure 17.3: Illustration of an MLP with (left) a point estimate for each weight, (right) a marginal distribution
for each weight, corresponding to a fully factored posterior approximation.
Many extensions of the BBB have been proposed. In [KSW15], they propise the local repa￾rameterization trick, that samples the activations a = Wz at each layer, instead of the weights
W, which results in a lower variance estimate of the ELBO gradient. In [Osa+19a], they used
the variational online Gauss-Newton (VOGN) method of [Kha+18], for improved scalability.
VOGN is a noisy version of natural gradient descent, where the extra noise emulates the effect
of variational inference. In [Mis+18], they replaced the diagonal approximation with a low-rank
plus diagonal approximation, and used VOGN for fitting. In [Tra+20b], they use a rank-one plus
diagonal approximation known as NAGVAC (see Section 10.2.1.3). In this case, there are only 3
times as many parameters as when computing a point estimate (for the variational mean, variance,
and rank-one vector), making the approach very scalable. In addition, in this case it is possible to
analytically compute the natural gradient, which speeds up model fitting (see Section 6.4). Many
other variational methods have also been proposed (see e.g., [LW16; Zha+18; Wu+19a; HHK19]).
See also Section 17.5.4 for a discussion of online VI for DNNs.
17.3.4 Expectation propagation
Expectation propagation (EP) is similar to variational inference, except it locally optimizes DKL (p k q)
instead of DKL (q k p), where p is the exact posterior and q is the approximate posterior. For details,
see Section 10.7.
A special case of EP is the assumed density filtering (ADF) algorithm of Section 8.6, which is
equivalent to the first pass of ADF. In Section 8.6.3 we show how to apply ADF to online logistic
regression. In [HLA15a], they extend ADF to the case of BNNs; they called their method probabilistic
backpropagation or PBP. They approximate every parameter in the model by a Gaussian factor, as
in Figure 17.3. See Section 17.5.3 for the details.
17.3.5 Last layer methods
A very simple approximation to the posterior is to only “be Bayesian” about the weights in the final
layer, and to use MAP estimates for all the other parameters. This is called the neural-linear
approximation [RTS18]. In more detail, let z = f(x, θ) be the predicted outputs (e.g., logits) of
the model before any optional final nonlinearity. We assume this has the form z = wT
Lφ(x; θ),
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.3. POSTERIORS FOR BNNS
where φ(x) are the features extracted by the first L − 1 layers. This gives us a Bayesian GLM.
We can use standard techniques, such as the Laplace approximation (Section 15.3.5), to compute
p(wL|D) = N (µL, ΣL), given φ(). To estimate the parameters of the feature extractor, we can
optimize the log-likelihood in the usual way. Given the posterior over the last layer weights, we can
compute the posterior predictive distribution over the logits using
p(z|x, D) = N (z|µLφ(x), φ(x)ΣLφ(x)
T
) (17.17)
This can be passed through the final softmax layer to compute p(y|x, D) as described in Section 15.3.6.
In [KHH20] they show this can reduce overconfidence in predictions for inputs that are far from the
training data. However, this approach ignores uncertainty introduced by the earlier feature extraction
layers, where most of the parameters reside. We discuss a solution to this in Section 17.3.6.
17.3.6 SNGP
It is possible to combine DNNs with Gaussian process (GP) models (Chapter 18), by using the DNN
to act as a feature extractor, which is then fed into the kernel in the final layer. This is called “deep
kernel learning” (see Section 18.6.6).
One problem with this is that the feature extractor may lose information which is not needed for
classification accuracy, but which is needed for robust performance on out-of-distribution inputs (see
Section 17.4.6.2). The basic problem is that, in a classification problem, there is no reduction in
training accuracy (log likelihood) if points which are far away are projected close together, as long as
they are on the correct side of the decision boundary. Thus the distances between two inputs can be
erased by the feature extraction layers, so that OOD inputs appear to the final layer to be close to
the training set.
One solution to this is to use the SNGP (spectrally normalized Gaussian process) method of
[Liu+20d; Liu+22a]. This constrains the feature extraction layers to be “distance preserving”, so
that two inputs that are far apart in input space remain far apart after many layers of feature
extraction, by using spectral normalization of the weights to bound the Lipschitz constant of the
feature extractor. The overall approach ensures that information that is relevant for computing the
confidence of a prediction, but which might be irrelevant to computing the label of a prediction, is
not lost. This can help performance in tasks such as out-of-distribution detection (Section 17.4.6.2).
17.3.7 MCMC methods
Some of the earliest work on inference for BNNs was done by Radford Neal, who proposed to use
Hamiltonian Monte Carlo (Section 12.5) to approximate the posterior [Nea96]. This is generally
considered the gold standard method, since it does not make strong assumptions about the form of
the posterior. For more recent work on scaling up HMC for BNNs, see e.g., [Izm+21b; CJ21].
We give a simple example of vanilla HMC in Figure 17.4, where we fit a shallow MLP to a small
2d binary dataset. We plot the mean and standard deviation of the posterior predictive distribution,
p(y = 1|x; D). We see that the uncertainty is higher as we move away from the training data.
(Compare to Bayesian logistic regression in 1d in Figure 15.8a.)
However, a significant limitation of standard MCMC procedures, including HMC, is that they
require access to the full training set at each step. Stochastic gradient MCMC methods, such as
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license648
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Posterior mean
(a)
Posterior std
0.00
0.06
0.12
0.18
0.24
0.30
0.36
0.42
0.48
0.54
(b)
Figure 17.4: Illustration of an MLP fit to the two-moons dataset using HMC. (a) Posterior mean. (b)
Posterior standard derivation. The uncertainty increases as we move away from the training data. Generated
by bnn_mlp_2d_hmc.ipynb.
SGLD, operate instead using mini-batches of data, offering a scalable alternative, as we discuss in
Section 12.7.1. For an example of SGLD applied to an MLP, see Section 19.3.3.1.
17.3.8 Methods based on the SGD trajectory
In [MHB17; SL18; CS18], it was shown that, under some assumptions, the iterates produced by
stochastic gradient descent (SGD), when run at a fixed learning rate, correspond to samples from
a Gaussian approximation to the posterior centered at a local mode, p(θ|D) ≈ N (θ|θˆ, Σ). We can
therefore use SGD to generate approximate posterior samples. This is similar to SG-MCMC methods,
except we do not add explicit gradient noise, and the learning rate is held constant.
In [Izm+18], they noted that these SGD solutions (with fixed learning rate) surround the periphery
of points of good generalization, as shown in Figure 17.5. This is in part because SGD does not
converge to a local optimum unless the learning rate is annealed to 0. They therefore proposed to
compute the average of several SGD samples, each one collected after a certain interval (e.g., one
epoch of training), to get θ =
1
S
PS
s=1 θs. They call this stochastic weight averaging (SWA).
They showed that the resulting point tends to correspond to a broader local minimum than the SGD
solutions (see Figure 17.10), resulting in better generalization performance.
The SWA approach is related to Polyak-Ruppert averaging, which is often used in convex optimiza￾tion. The difference is that Polyak-Ruppert typically assumes the learning rate decays to zero, and
uses an exponential moving average (EMA) of iterates, rather than an equal average; Polyak-Ruppert
averaging is mainly used to reduce variance in the SGD estimate, rather than as a method to find
points of better generalization.
The SWA approach is also related to snapshot ensembles [Hua+17a], and fast geometric
ensembles [Gar+18c]; these methods save the parameters θs after increasing and decreasing the
learning rate multiple times in a cyclical fashion, and then computing the average of the predictions
using p(y|x, D) ≈
1
S
PS
s=1 p(y|x, θs), rather than computing the average of the parameters and
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.3. POSTERIORS FOR BNNS
Figure 17.5: Illustration of stochastic weight averaging (SWA). The three crosses represent different SGD
solutions. The star in the middle is the average of these parameter values. From Figure 1 of [Izm+18]. Used
with kind permission of Andrew Wilson.
predicting with a single model (which is faster). Moreover, by finding a flat region, representing a
“center or mass” in the posterior, SWA can be seen as approximating the Bayesian model average in
Equation 17.1 with a single model.
In [Mad+19], they proposed to fit a Gaussian distribution to the set of samples produced by SGD
near a local mode. They use the SWA solution as the mean of the Gaussian. For the covariance
matrix, they use a low-rank plus diagonal approximation of the form p(θ|D) = N (θ|θ, Σ), where
Σ = (Σdiag + Σlr)/2, Σdiag = diag(θ
2 − (θ)
2
), θ =
1
S
PS
s=1 θs, θ
2 =
1
S
PS
s=1 θ
2
s
, and Σlr =
1
S∆∆T
is the sample covariance matrix of the last K samples of ∆i = (θi − θi), where θi
is the running
average of the parameters from the first i samples. They call this method SWAG, which stands for
“stochastic weight averaging with Gaussian posterior”. This can be used to generate an arbitrary
number of posterior samples at prediction time. They show that SWAG scales to large residual
networks with millions of parameters, and large datasets such as ImageNet, with improved accuracy
and calibration over conventional SGD training, and no additional training overhead.
17.3.9 Deep ensembles
Many conventional approximate inference methods focus on approximating the posterior p(θ|D) in a
local neighborhood around one of the posterior modes. While this is often not a major limitation in
classical machine learning, modern deep neural networks have highly multi-modal posteriors, with
parameters in different modes giving rise to very different functions. On the other hand, the functions
in a neighborhood of a single mode may make fairly similar predictions. So using such a local
approximation to compute the posterior predictive will underestimate uncertainty and generalize
more poorly.
A simple alternative method is to train multiple models, and then to approximate the posterior
using an equally weighted mixture of delta functions,
p(θ|D) ≈
1
M
X
M
m=1
δ(θ − θˆm) (17.18)
where M is the number of models, and θˆm is the MAP estimate for model m. See Figure 17.6 for a
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license650
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 17.6: Cartoon illustration of the NLL as it varies across the parameter space. Subspace methods
(red) model the local neighborhood around a local mode, whereas ensemble methods (blue) approximate the
posterior using a set of distinct modes. From Figure 1 of [FHL19]. Used with kind permission of Balaji
Lakshminarayanan.
sketch. This approach is called deep ensembles [LPB17; FHL19].
The models can differ in terms of their random seed used for initialization [LPB17], or hyper￾parameters [Wen+20c], or architecture [Zai+20], or all of the above. In addition, [DF21; TB22]
discusses how to add an explicit repulsive term to ensure functional diversity between the ensemble
members. This way, each member corresponds to a distinct prediction function. Combining these is
more effective than combining multiple samples from the same basin of attraction, especially in the
presence of dataset shift [Ova+19].
17.3.9.1 Multi-SWAG
We can further improve on this approach by fitting a Gaussian to each local mode using the SWAG
method from Section 17.3.8 to get a mixture of Gaussians approximation:
p(θ|D) ≈
1
M
X
M
m=1
N (θ|θˆm, Σm) (17.19)
This approach is known as MultiSWAG [WI20]. MultiSWAG performs a Bayesian model average
both across multiple basins of attraction, like deep ensembles, but also within each basin, and provides
an easy way to generate an arbitrary number of posterior samples, S > M, in an any-time fashion.
17.3.9.2 Deep ensembles with random priors
The standard way to fit each member of a deep ensemble is to initialize them each with a different
random set of parameters, but them to train them all on the same data. Unfortunately this can
result in the predictions from each ensemble member being rather similar, which reduces the benefit
of the approach. One way to increase diversity is to train each member on a different subset of the
data; this is called bootstrap sampling. Another approach is to define the i’th ensemble member
gi(x) to be the addition of a trainable model ti(x) and a fixed, but random, prior network, pi(x),
to get
gi(x; θi) = ti(x; θi) + βpi(x) (17.20)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.3. POSTERIORS FOR BNNS
0
1 model #1 model #2
0
1 model #3 model #4
0
1 model #5 model #6
-0.5 0 0.5 1
0
1 model #7
-0.5 0 0.5 1
model #8
0
2
β=0.001 β=0.001
0
2
β=5 β=5
0
2
β=50 β=50
-0.5 0 0.5 1
0
2
β=100
-0.5 0 0.5 1
β=100
Figure 17.7: Deep ensemble with random priors. (a) Individual predictions from each member. Blue is the
fixed random prior function, orange is the trainable function, green is the combination of the two. (b) Overall
prediction from the ensemble, for increasingly large values of β. On the left we show (in red) the posterior
mean and pointwise standard deviation, and on the right we show samples from the posterior. As β increases,
we trust the random priors more, and pay less attention to the data, thus getting a more diffuse posterior.
Generated by randomized_priors.ipynb.
where β ≥ 0 controls the amount of data-independent variation between the members. The trainable
network learns to model the residual error between the true output and the value predicted by the
prior. This is called a random prior deep ensemble [OAC18]. See Figure 17.7 for an illustration.
17.3.9.3 Deep ensembles as approximate Bayesian inference
The posterior predictive distribution for a Bayesian neural network cannot be expressed in closed
form. Therefore all Bayesian inference approaches in deep learning are approximate. In this context,
all approximate inference procedures fall onto a spectrum, representing how closely they approximate
the true posterior predictive distribution. Deep ensembles can provide better approximations to a
Bayesian model average than a single basin marginalization approach, because point masses from
different basins of attraction represent greater functional diversity than standard Bayesian approaches
which sample within a single basin.
17.3.9.4 Deep ensembles vs classical ensembles
Note that deep ensembles are slightly different from classical ensemble methods (see e.g., [Die00]),
such as bagging and random forests, which obtain diversity of their predictors by training them on
different subsets of the data (created using bootstrap resampling), or on different features. This data
perturbation is necessary to get diversity when the base learner is a convex problem (such as a linear
model, or shallow decision tree). In the deep ensemble approach, every model is trained on the same
data, and the same input features. The diversity arises due to different starting parameters, different
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license652
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
One shared
weight matrix 
(slow weight)...
...multiplied by 
independent rank 
one fast weights...
...yields ensemble 
weight matrices for 
each member.
-1 0 1
W
Figure 17.8: Illustration of batch ensemble with 2 ensemble members. From Figure 2 of [WTB20]. Used with
kind permission of Paul Vicol.
random seeds, and SGD noise, which induces different solutions due to the nonconvex loss. It is
also possible to explicitly enforce diversity of the ensemble members, which can provably improve
performance [TB22].
17.3.9.5 Deep ensembles vs mixtures of experts and stacking
If we use weighted combinations of the models, p(θ|D) = PM
m=1 p(m|D)p(θ|m, D), where p(m|D) is
the marginal likelihood of model m, then, in the large sample limit, this mixture will concentrate on
the MAP model, so only one component will be selected. By contrast, in deep ensembles, we always
use M equally weighted models. Thus we see that Bayes model averaging is not the same as model
ensembling [Min00b]. Indeed, ensembling can enlarge the expressive power of the posterior predictive
distribution compared to BMA [OCM21].
We can also make the mixing weights be conditional on the inputs:
p(y|x, D) = X
m
wm(x)p(y|x, θm) (17.21)
If we constrain the weights to be non-zero and sum to one, this is called a mixture of experts.
However, if we allow a general positive weighted combination, the approach is called stacking [Wol92;
Bre96; Yao+18a; CAII20]. In stacking, the weights wm(x) are usually estimated on hold-out data,
to make the method more robust to model misspecification.
17.3.9.6 Batch ensemble
Deep ensembles require M times more memory and time than a single model. One way to reduce
the memory cost is to share most of the parameters — which we call slow weights, W — and then
let each ensemble member m estimate its own local perturbation, which we will call fast weights,
Fm. We then define Wm = W⊙ Fm. For efficiency, we can define Fm to be a rank-one matrix,
Fm = smr
T
m, as illustrated in Figure 17.8. This is called batch ensemble [WTB20].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.3. POSTERIORS FOR BNNS
It is clear that the memory overhead is very small compared to naive ensembles, since we just need
to store 2M vectors (s
l
m and r
l
m) for every layer l, which is negligible compared to the quadratic
cost of storing the shared weight matrix Wl
.
In addition to memory savings, batch ensemble can reduce the inference time by a constant factor
by leveraging within-device parallelism. To see this, consider the output of one layer using ensemble
m on example n:
y
m
n = ϕ
￾WT
mxn

= ϕ
￾
(W⊙ smr
T
m)
Txn

= ϕ
￾
(WT
(xn ⊙ sm) ⊙ rm

(17.22)
We can vectorize this for a minibatch of inputs X by replicating rm and sm along the B rows in the
batch to form matrices, giving
Ym = ϕ (((X ⊙ Sm)W) ⊙ Rm) (17.23)
This applies the same ensemble parameters m to every example in the minibatch of size B. To
achieve diversity during training, we can divide the minibatch into M sub-batches, and use sub-batch
m to train Wm. (Note that this reduces the batch size for training each ensemble to B/M.) At test
time, when we want to average over M models, we can replicate each input M times, leading to a
batch size of BM.
In [WTB20], they show that this method outperforms MC dropout at negligible extra memory
cost. However, the best combination was to combine batch ensemble with MC dropout; in some
cases, this approached the performance of naive ensembles.
17.3.10 Approximating the posterior predictive distribution
Once we have approximated the parameter posterior, q(θ) ≈ p(θ|D), we can use it to approximate
the posterior predictive distribution:
p(y|x, D) = Z
q(θ)p(y|x, θ)dθ (17.24)
We often approximate this integral using Monte Carlo:
p(y|x, D) ≈
1
S
X
S
s=1
p(y|f(x, θ
s
)) (17.25)
where θ
s ∼ q(θ|D). We discuss some extensions of this approach below.
17.3.10.1 A linearized approximation
In [IKB21] they point out that samples from an approximate posterior, q(θ), can result in bad
predictions when plugged into the model if the posterior puts probability density “in the wrong
places”. This is because f(x; θ) is a highly nonlinear function of θ that might behave quite differently
when θ is far from the MAP estimate on which q(θ) is centered. To avoid this problem, they propose
to replace f(x; θ) with a linear approximation centered at the MAP estimate θ
∗
:
f
θ
∗
lin (x, θ) = f(x, θ
∗
) + J(x)(θ − θ
∗
) (17.26)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND lice654
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where Jθ∗ (x) = ∂f(x;θ)
∂θ
|θ∗ is the P × C Jacobian matrix, where P is the number of parameters, and
C is the number of outputs. Such a model is well behaved around θ
∗
, and so the approximation
p(y|x, D) ≈
1
S
X
S
s=1
p(y|f
θ
∗
lin (x, θ
s
)) (17.27)
often works better than Equation (17.25).
Note that z = f
θ
∗
lin (x, θ) is a linear function of the parameters θ, but a nonlinear function of
the inputs x. Thus p(y|f
θ
∗
lin (x, θ)) is a generalized linear model (Section 15.1), so [IKB21] call this
approximation the GLM predictive distribution.
If we have a Gaussian approximation to the parameter, p(θ|D) ≈ N (θ|µ, Σ), then we can “push
this through” the linear approximation to get
p(z|x, D) ≈ N (z|f(x, µ), J(x)
TΣJ(x)) (17.28)
where z are the logits. (Alternatively, we can use the last layer method of Equation (17.17) to get
a Gaussian approximation to p(z|x, D).) If we approximate the final softmax layer with a probit
function, we can analytically pass this Gaussian through the final softmax layer to deterministically
compute the predictive probabilities p(y = c|x, D), using Equation (15.150). Alternatively, we can
use the Laplace bridge approximation in Section 17.3.10.2.
17.3.10.2 The Laplace bridge approximation
Just using a point estimate of the probability of each class label, pc = p(y = c|x, D), can be unreliable,
since it does not convey any sense of uncertainty in the probability value, even though we may have
taken the uncertainty of the parameters into account (e.g., using the methods of Section 17.3.10.1).
An alternative is to represent the output over labels as a Dirichlet distribution, Dir(π|α), rather
than a categorical distribution, Cat(y|p), where p = softmax(z). This is more appropriate if we view
each datapoint as being annotated with a “soft” vector of probabilities (e.g., representing consensus
votes from human raters), rather than a one-hot encoding with a single “ground truth” value. This
can be useful for settings where the true label is ambiguous (see e.g., [Bey+20; Dum+18]).
We can either train the model to predict the Dirichlet parameters directly (as in the prior network
approach of [MG18]), or we can train the model to predict softmax outputs in the usual way, and
then derive the Dirichlet parameters from a Gaussian approximation to the posterior. The latter
approach is known as the Laplace bridge [HKH22], and has the advantage that it can be used as a
post-processing method. It works as follows. First we compute a Gaussian approximation to the
logits, p(z|x, D) = N (z|m, V) using Equation (17.28) or Equation (17.17). Then we compute
αi =
1
Vii

1 −
2
C
+
exp(mi)
C2
X
C
j=1
exp(−mj )

 (17.29)
where C is the number of classes. We can then derive the probabilities of each class label using
pc = E [πc] = αc/α0, where α0 =
PC
c=1 αc.
Note that the derivation of the above result assumes that the Gaussian terms sum to zero, since
the Gaussian has one less degree of freedom compared to the Dirichlet. To ensure this, it is necessary
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.3. POSTERIORS FOR BNNS
0.00 0.01 0.02 0.03 0.04 0.05
mouse
loupe
desk
hair spray
groom
face powder
stethoscope
lab coat
notebook
0.00 0.05 0.10 0.15 0.20 0.25
desktop computer
space bar
laptop
modem
notebook
0.000 0.025 0.050 0.075 0.100 0.125 0.150
home theater
entertainment center
desktop computer
television
notebook
monitor
screen
0.0 0.2 0.4 0.6 0.8 1.0
modem
hand-held computer
space bar
laptop
notebook
Figure 17.9: Illustration of uncertainty about individual labels in an image classification problem. Top row:
images from the “laptop” class of ImageNet. Bottom row: beta marginals for the top-k predtions for the
respective image. First column: high uncertainty about all the labels. Second column: “notebook” and “laptop”
have high confidence. Third column: “desktop”, “screen” and “monitor” have high confidence. Fourth column:
only “laptop” has high confidence. (Compare to Figure 14.4.) From Figure 6 of [HKH22]. Used with kind
permission of Philipp Hennig.
to first project the Gaussian distribution onto this constraint surface, yielding
p(z|x, D) = N

z|m −
V11Tm
1
TV∗1
, V −
V11TV
1
TV1 
= N (z|m′
, V′
) (17.30)
where 1 is the ones vector of size C. To avoid potential problems where α is sparse, [HKH22] propose
to also scale the posterior (after the zero-sum constraint) by using m′′ = m′/
√
c and V′′ = V′/c,
where c = (P
ii V
′
ii)/
p
C/2.
One useful property of the Laplace bridge approximation, compared to the probit approximation,
is that we can easily compute a marginal distribution over the probablility of each label being present.
This is because the marginals of a Dirichlet are beta distributions. We can use this to adaptively
compute a top-k prediction set; this is similar in spirit to conformal prediction (Section 14.3.1), but
is Bayesian, in the sense that it represents per-instance uncertainty. The method works as follows.
First we sort the class labels in decreasing order of expected probability, to get α˜ ; next we compute
the marginal distribution over the probability for the top label,
p(π1|x, D) = Beta(˜α1, α0 − α˜1) (17.31)
where α0 =
P
c αc. We then compute the marginal distributions for the other labels in a similar way,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license656
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
and return all labels that have significant overlap with the top label. As we see from the examples in
Figure 17.9, this approach can return variable-sized outputs, reflecting uncertainty in a natural way.
17.3.10.3 Distillation
The MC approximation to the posterior predictive is S times slower than a standard, determin￾istic plug-in approximation. One way to speed this up is to use distillation to approximate the
semi-parametric “teacher” model pt from Equation (17.25) by a parametric “student” model ps
by minimizing E [DKL (pt(y|x) k ps(y|x))] wrt ps. This approach was first proposed in [HVD14],
who called the technique “dark knowledge”, because the teacher has “hidden” information in its
predictive probabilities (logits) than is not apparent in the raw one-hot labels.
In [Kor+15], this idea was used to distill the predictions from a teacher whose parameter posterior
was computed using HMC; this is called “Bayesian dark knowledge”. A similar idea was used in
[BPK16; GBP18], who distilled the predictive distribution derived from MC dropout (Section 17.3.1).
Since the parametric student is typically less flexible than the semi-parametric teacher, it may be
overconfident, and lack diversity in its predictions. To avoid this overconfidence, it is safer to make
the student be a mixture distribution [SG05; Tra+20a].
17.3.11 Tempered and cold posteriors
When working with BNNs for classification problems, the likelihood is usually taken to be
p(y|x, θ) = Cat(y|softmax(f(x; θ))) (17.32)
where f(x; θ) ∈ R
C returns the logits over the C class labels. This is the same as in multinomial
logistic regression (Section 15.3.2); the only difference is that f is a nonlinear function of θ.
However, in practice, it is often found (see e.g., [Zha+18; Wen+20b; LST21; Noc+21]) that BNNs
give better predictive accuracy if the likelihood function is scaled by some power α. That is, instead
of targeting the posterior p(θ|D) ∝ p(y|x, θ)p(θ), these methods target the tempered posterior,
ptempered(θ|D) ∝ p(y|X, θ)
αp(θ). In log space, we have
log ptempered(θ|D) = α log p(y|X, θ) + log p(θ) + const (17.33)
This is also called an α-posterior or power posterior [Med+21].
Another common method is to target the cold posterior, pcold(θ|D) ∝ p(θ|X, y)
1/T , or, in log
space,
log pcold(θ|D) = 1
T
log p(y|X, θ) + 1
T
log p(θ) + const (17.34)
If T < 1, we say that the posterior is “cold”. Note that, in the case of a Gaussian prior, using the
cold prior is the same as using the tempered prior with a different hyperparameter, since
1
T
log N (θ|0, σ
2
coldI) = −
1
2T σ2
cold
X
i
θ
2
i + const = N (θ|0, σ2
temperedI) + const (17.35)
where σ
2
tempered = T σ2
cold. Thus both methods are effectively the same, and just reweight the
likelihood.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.4. GENERALIZATION IN BAYESIAN DEEP LEARNING
Figure 17.10: Flat vs sharp minima. From Figures 1 and 2 of [HS97]. Used with kind permission of Jürgen
Schmidhuber.
Cold posteriors in Bayesian neural network classifiers are a consequence of underrepresenting
aleatoric (label) uncertainty, as shown by [Kap+22]. On benchmarks such as CIFAR-100, we should
have essentially no uncertainty about the labels of the training images, yet Bayesian classifiers with
softmax likelihoods have very high uncertainty for these points. Moreover, [Izm+21b] showed that the
cold posterior effect in all the examples of [Wen+20b] when data augmentation is removed. [Kap+22]
show that with the SGLD inference in [Wen+20b], data augmentation has the effect of raising the
likelihood to a power 1/K for minibatches of size K. Cold posteriors exactly counteract this effect,
more honestly representing our beliefs about aleatoric uncertainty, by sharpening the likelihood.
However, tempering is not required, and [Kap+22] show that by using a Dirichlet observation
model to explicitly represent (lack of) label noise, there is no cold posterior effect, even with data
augmentation. The curation hypotheses of [Ait21] can be considered a special case of the above
explanation, where curation has the effect of increasing our confidence about training labels.
In Section 14.1.3, we discuss generalized variational inference, which gives a general framework for
understanding whether and how the likelihood or prior could benefit from tempering. Tempering is
particularly useful if (as is usually the case) the model is misspecified [KJD21].
17.4 Generalization in Bayesian deep learning
In this section, we discuss why “being Bayesian” can improve predictive accuracy and generalization
performance.
17.4.1 Sharp vs flat minima
Some optimization methods (in particular, second-order batch methods) are able to find “needles
in haystacks”, corresponding to narrow but deep “holes” in the loss landscape, corresponding to
parameter settings with very low loss. These are known as sharp minima, see Figure 17.10(right).
From the point of view of minimizing the empirical loss, the optimizer has done a good job. However,
such solutions generally correspond to a model that has overfit the data. It is better to find points
that correspond to flat minima, as shown in Figure 17.10(left); such solutions are more robust and
generalize better. To see why, note that flat minima correspond to regions in parameter space where
there is a lot of posterior uncertainty, and hence samples from this region are less able to precisely
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license658
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
memorize irrelevant details about the training set [AS17]. Put another way, the description length for
sharp minima is large, meaning you need to use many bits of precision to specify the exact location
in parameter space to avoid incurring large loss, whereas the description length for flat minima is
less, resulting in better generalization [Mac03].
SGD often finds such flat minima by virtue of the addition of noise, which prevents it from
“entering” narrow regions of the loss landscape (see Section 12.5.7). In addition, in higher dimensional
spaces, flat regions occupy a much greater volume, and are thus much more easily discoverable by
optimization procedures. More precisely, the analysis in [SL18] shows that the probability of entering
any given basin of attraction A around a minimum is given by pSGD(θ ∈ A) ∝
R
A
e
−L(θ)dθ. Note
that this is integrating over the volume of space corresponding to A, and hence is proportional to
the model evidence (marginal likelihood) for that region, as explained in Section 3.8.1. Since the
evidence is parameterization invariant (since we marginalize out the parameters), this means that
SGD will avoid regions that have low evidence (corresponding to sharp minima) regardless of how we
parameterize the model (contrary to the claims in [Din+17]).
In fact, several papers have shown that we can view SGD as approximately sampling from the
Bayesian posterior (see Section 17.3.8). The SWA method (Section 17.3.8) can be seen as finding a
center of mass in the posterior based on these SGD samples, finding solutions that generalize better
than picking a single SGD point.
If we must use a single solution, a flat one will help us better approximate the Bayesian model
average in the integral of Equation (17.1). However, by attempting to perform a more complete
Bayesian model average, we will select for flatness without having to deal with the messiness of
having to worry about flatness definitions, or the effects of reparameterization, or unknown implicit
regularization, as the model average will automatically weight regions with the greatest volume.
17.4.2 Mode connectivity and the loss landscape
In DNNs there are often many low-loss solutions, which provide complementary explanations of
the data. Moreover, in [Gar+18c] they showed that two independently trained SGD solutions can
be connected by a curve in a subspace, along which the training loss remains near-zero, known as
mode connectivity. Despite having the same training loss, these different parameter settings give
rise to very different functions, as illustrated in Figure 17.11, where we show predictions on a 1d
regression problem coming from different points in parameter space obtained by interpolating along
a mode connecting curve between two distinct MAP estimates. Using a Bayesian model average, we
can combine these functions together to provide much better performance over a single flat solution
[Izm+19].
Recently, it has been discovered [Ben+21b] that there are in fact large multidimensional simplexes
of low loss solutions, which can be combined together for significantly improved performance. These
results further motivate the Bayesian approach (Equation (17.1)), where we perform a posterior
weighted model average.
17.4.3 Effective dimensionality of a model
Modern DNNs have millions of parameters, but these parameters are often not well-determined
by the data, i.e., there can be a lot of posterior uncertainty. By averaging over the posterior, we
reduce the chance of overfitting, because we do not use “degrees of freedom” that are not needed or
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.4. GENERALIZATION IN BAYESIAN DEEP LEARNING
Figure 17.11: Diversity of high performing functions sampled from the posterior. Top row: we show predictions
on the 1d input domain for 4 different functions. We see that they extrapolate in different ways outside of the
support of the data. Bottom row: we show a 2d subspace spanning two distinct modes (MAP estimates), and
connected by a low-loss curved path computed as in [Gar+18c]. From Figure 8 of [WI20]. Used with kind
permission of Andrew Wilson.
warranted.
To quantify the number of degrees of freedom, or effective dimensionality [Mac92b], we follow
[MBW20] and define
Neff(H, c) =
X
k
i=1
λi
λi + c
, (17.36)
where λi are the eigenvalues of the Hessian matrix H computed at a local mode, and c > 0 is a
regularization parameter. Intuitively, the effective dimension counts the number of well-determined
parameters. A “flat minimum” will have many directions in parameter space that are not well￾determined, and hence will have low effective dimensionality. This means that we can perform
Bayesian inference in a low dimensional subspace [Izm+19]: Since there is functional homogeneity
in all directions but those defining the effective dimension, neural networks can be significantly
compressed.
This compression perspective can also be used to understand why the effective dimension can be a
good proxy for generalization. If two models have similar training loss, but one has lower effective
dimension, then it is providing a better compression for the data at the same fidelity. In Figure 17.12
we show that for CNNs with low training loss (above the green partition), the effective dimensionality
closely tracks generalization performance. We also see that the number of parameters alone is not a
strong determinant of generalization. Indeed, models with more parameters can have a lower number
of effective parameters. We also see that wide but shallow models overfit, while depth helps provide
lower effective dimensionality, leading to a better compression of the data. It is depth that makes
modern neural networks distinctive, providing hierarchical inductive biases making it possible to
discover more regularity in the data.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license660
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
12 16 20 24 28 32 36
Width
0
2
4
6
8
Depth
Effective Dimensionality
12 16 20 24 28 32 36
Width
0
2
4
6
8
Test Loss
12 16 20 24 28 32 36
Width
0
2
4
6
8
Train Loss
70
75
80
85
90
95
100
1.2
1.4
1.6
1.8
2.0
2.2
0.5
1.0
1.5
2.0
2.5
3.0
3.5
Figure 17.12: Left: effective dimensionality as a function of model width and depth for a CNN on CIFAR-100.
Center: test loss as a function of model width and depth. Right: train loss as a function of model width and
depth. Yellow level curves represent equal parameter counts (1e5, 2e5, 4e5, 1.6e6). The green curve separates
models with near-zero training loss. Effective dimensionality serves as a good proxy for generalization for
models with low train loss. We see wide but shallow models overfit, providing low train loss, but high test
loss and high effective dimensionality. For models with the same train loss, lower effective dimensionality
can be viewed as a better compression of the data at the same fidelity. Thus depth provides a mechanism for
compression, which leads to better generalization. From Figure 2 of [MBW20]. Used with kind permission of
Andrew Wilson.
17.4.4 The hypothesis space of DNNs
Zhang et al. [Zha+17] showed that CNNs can fit CIFAR-10 images with random labels with zero
training error, but can still generalize well on the noise-free test set. It has been claimed that this
result contradicts a classical understanding of generalization, because it shows that neural networks
are capable of significantly overfitting the data, but can still generalize well on structured inputs.
We can resolve this paradox by taking a Bayesian perspective. In particular, we know that modern
CNNs are very flexible, so they can fit almost pattern (since they are in fact universal approximators).
However, their architecture encodes a prior over what kinds of patterns they expect to see in the data
(see Section 17.2.5). Image datasets with random labels can be represented by this function class, but
such solutions receive very low marginal likelihood, since they strongly violate the prior assumptions
[WI20]. By contrast, image datasets where the output labels are consistent with patterns in the
input get much higher marginal likelihood.
This phenomenon is not unique to DNNs. For example, it also occurs with Gaussian processes
(Chapter 18). Such models are also universal approximators, but they allocate most of their probability
mass to a small range of solutions (depending on the chosen kernel). They can also fit image datasets
with random labels, but such data receives a low marginal likelihood [WI20].
In general, we can distinguish the support of a model, i.e., the set of functions it can represent,
from the distribution over that support, i.e., the inductive bias which leads it to prefer some functions
over others. We would like to use models where the support is large, so we can capture the complexity
of real-world data, but also where the inductive bias places probability mass on the kinds of functions
we expect to see. If we succeed at this, the posterior will quickly converge on the true function after
seeing a small amount of data. This idea is sketched in Figure 17.13.
17.4.5 PAC-Bayes
PAC-Bayes [McA99; LC02; Gue19; Alq21; GSZ21] provides a promising mechanism to derive
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.4. GENERALIZATION IN BAYESIAN DEEP LEARNING
Figure 17.13: Illustration of the behavior of different kinds of model families and the prior distributions
they induce over datasets. (a) The purple model is a simple linear model that has small support, and can
only represent a few kinds of datasets. The pink model is an unstructured MLP: this has support over a
large range of datasets with a fairly uninformative (broad) prior. Finally the green model is a CNN; this has
support over a large range of datasets but the prior is more concentrated on certain kinds of datasets that have
compositional structure. (b) The posterior for the green model (CNN) rapidly collapses to the true model,
since it is consistent with the data. (c) The posterior for the purple model (linear) also rapidly collapses, but
to a solution which cannot represent the true model. (d) The posterior for the pink model (MLP) collapses
very slowly (as a function of dataset size). From Figure 2 of [WI20]. Used with kind permission of Andrew
Wilson.
non-vacuous generalization bounds for large stochastic networks [Ney+17; NBS18; DR17], with
parameters sampled from a probability distribution. In particular, the difference between the train
error and the generalization error can be expressed as
s
DKL (Q k P) + c
2(N − 1) , (17.37)
where c is a constant, N is the number of training points, P is the prior distribution over the
parameters, and Q is an arbitrary distribution, which can be chosen to optimize the bound.
The perspective in this chapter is largely complementary, and in some ways orthogonal, to the
PAC-Bayes literature. Our focus has been on Bayesian marginalization, particularly multi-modal
marginalization, and a prescriptive approach to model construction. In contrast, PAC-Bayes bounds
are about bounding the empirical risk of a single sample, rather than marginalization, and are not
currently prescriptive: what we would do to improve the bounds, such as reducing the number
of model parameters, or using highly compact priors, does not typically improve generalization.
Moreover, while we have seen Bayesian model averaging over multimodal posteriors has a significant
effect on generalization, it has a minimal logarithmic effect on PAC-Bayes bounds. In general,
because the bounds are loose, albeit non-vacuous in some cases, there is often room to make modeling
choices that improve PAC-Bayes bounds without improving generalization, making it hard to derive
a prescription for model construction from the bounds.
17.4.6 Out-of-distribution generalization for BNNs
Bayesian methods are often assumed to be more robust in the context of distribution shift (discussed
in Chapter 19), because they capture more uncertainty than methods based on point estimation.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license662
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
No shift 1 2 3 4 5
Corruption Intensity
0.4
0.5
0.6
0.7
0.8
0.9
Accuracy
5%
25%
MAP BNN
−0.25 0.00 0.25 −0.05 0.00 0.05
(a) ResNet-20, CIFAR-10-C (b) BNN weights (c) MAP weights
Figure 17.14: Bayesian neural networks under covariate shift. a: Performance of a ResNet-20 on the pixelate
corruption in CIFAR-10-C. For the highest degree of corruption, a Bayesian model average underperforms a
MAP solution by 25% (44% against 69%) accuracy. See Izmailov et al. [Izm+21b] for details. b: Visualization
of the weights in the first layer of a Bayesian fully-connected network on MNIST sampled via HMC. c: The
corresponding MAP weights. We visualize the weights connecting the input pixels to a neuron in the hidden
layer as a 28 × 28 image, where each weight is shown in the location of the input pixel it interacts with. This
is Figure 1 of Izmailov et al. [Izm+21a].
However, there are some subtleties, some of which we discuss below.
17.4.6.1 BMA can give poor results with default priors
Many approximate inference methods, especially deep ensembles, are significantly less overconfident
(more well calibrated) in the presence of some kinds of covariate shifts [Ova+19]. However, in
[Izm+21b], it was noted that HMC, which arguably offers the most accurate approximation to the
posterior, often works poorly under distribution shift.
Rather than an idiosyncracy of HMC, Izmailov et al. [Izm+21a] show this lack of robustness
is a foundational issue of Bayesian model averaging under covariate shift, caused by degeneracies
in the training data, and a poor choice of prior. As an illustrative special case, MNIST digits all
have black corner pixels. Weights in the first layer of a neural network connected to these pixels
are multiplied by zero, and thus can take any value without affecting the outputs of the network.
Classical MAP training or deep ensembles of MAP solutions with a Gaussian prior will therefore
drive these parameters to zero, since they don’t help with the data fit, and the resulting network
will be robust to corruptions on these pixels. On the other hand, the posterior for these parameters
will be the same as the prior, and so a Bayesian model average will multiply corruptions by random
numbers sampled from the prior, leading to degraded predictive performance.
Figure 17.14(b, c) visualizes this example, showing the first-layer weights of a fully-connected
network for the MAP solution and a BNN posterior sample, on MNIST. The MAP weights corre￾sponding to zero intensity pixels near the boundary are near zero, while the BNN weights look noisy,
sampled from a Gaussian prior.
Izmailov et al. [Izm+21a] prove that this issue is a special case of a much more general problem,
whenever there are linear dependencies in the input features of the training data, both for fully￾connected and convolutional networks. In this case, the data live on a hyperplane. If a covariate or
domain shift, moves orthogonal to this hyperplane, the posterior will be the same as the prior in
the direction of the shift. The posterior model average will thus be highly vulnerable to shifts that
do not particularly affect the underlying semantic structure of the problem (such as corruptions),
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.5. ONLINE INFERENCE
whereas the MAP solution will be entirely robust to such shifts.
By introducing a prior over parameters which is aligned with the principal components of the
training inputs, we can substantially improve the generalization accuracy of Bayesian neural networks
in out-of-distribution settings. Izmailov et al. [Izm+21a] propose the following EmpCov prior:
p(w
1
) = N (0, αΣ + ǫI), where w
1 are the first layer weights, Σ = 1
n−1
Pn
i=1 xix
T
i
is the empirical
covariance of the training input features xi
, α > 0 determines the scale of the prior, and ǫ is a small
positive constant to ensure the covariance matrix is positive definite. With this improved prior they
are able to obtain a method that is much more robust to distribution shift.
17.4.6.2 BNNs can be overconfident on OOD inputs
An important problem in practice is how a predictive model will behave when it is given an input that
is “out of distribution” or OOD. Ideally we would like the model to express that it is not confident
in its prediction, so that the system can abstain from predicting (see Section 19.3.3). Using “exact”
inference methods, such as MCMC, for BNNs can give this behavior in some cases. For example,
in Section 19.3.3.1 we showed that an MLP which was fit to MNIST using SGLD would be less
overconfident than a point estimate (computed using SGD) when presented with inputs from fashion
MNIST. However, this behavior does not always occur reliably.
To illustrate the problem, consider the 2d nonlinear binary classification dataset shown in Fig￾ure 17.15. In addition to the two training classes, we have highlighted (in green) a set of OOD inputs
that are far from the support of the training set. Intuitively we would expect the model to predict
a probability of 0.5 (corresponding to “don’t know”) for such inputs that are far from the training
set. However we see that the only methods that do so are the Gaussian process (GP) classifier (see
Section 18.4) and the SNGP model (Section 17.3.6), which contains a GP layer on top of the feature
extractor.
The lesson we learn from this simple example is that “being Bayesian” only helps if we are using a
good hypothesis class. If we only consider a single MLP classifier, with standard Gaussian priors on
the weights, it is extremely unlikely that we will learn the kind of compact decision boundary shown
in Figure 17.15g, because that function has negligible support under our prior (c.f. Section 17.4.4).
Instead we should embrace the power of Bayes to avoid overfitting and use as complex a model class
as we can afford.
17.4.7 Model selection for BNNs
Historically, the marginal likelihood (aka Bayesian evidence) has been used for model selection
problems, such as choosing neural architectures or hyperparameter values [Mac92a]. Recent methods
based on the Laplace approximation, such as [Imm+21; Dax+21], have made this scalable to large
BNNs. However, [Lot+22] argue that it is much better to use the conditional marginal likelihood,
which we discuss in Section 3.8.5.
17.5 Online inference
In Section 17.3, we have focused on batch or offline inference. However, an important application
of Bayesian inference is in sequential settings, where the data arrives in a continuous stream, and
the model has to “keep up”. This is called sequential Bayesian inference, and is one approach to
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license664
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−2 0 2 4
−3
−2
−1
0
1
2
0
1
OOD
0.00
0.15
0.30
0.45
0.60
0.75
0.90
1.05
(a) SGD
−2 0 2 4
−3
−2
−1
0
1
2
(b) DE
−2 0 2 4
−3
−2
−1
0
1
2
(c) MC Dropout
−2 0 2 4
−3
−2
−1
0
1
2
(d) Bootstrap
−2 0 2 4
−3
−2
−1
0
1
2
(e) MCMC
−2 0 2 4
−3
−2
−1
0
1
2
(f) VI
−2 0 2 4
−3
−2
−1
0
1
2
(g) GP
−2 0 2 4
−3
−2
−1
0
1
2
(h) SNGP
Figure 17.15: Predictions made by various (B)NNs when presented with the training data shown in blue and
red. The green blob is an example of some OOD inputs. Methods are: (a) standard SGD; (b) deep Ensemble
of 10 models with different random initializations; (c) MC dropout with 50 samples; (d) bootstrap training,
where each of the 10 models is initialized identically but given different versions of the data, obtained by
resampling with replacement; (e) MCMC using NUTS algorithm with 3000 warmup steps and 3000 samples;
(f ) bariational inference; (g) Gaussian process classifier using RBF kernel; (h) SNGP. The model is an MLP
with 8,16,16,8 units in the hidden layers and ReLu activation. The output layer has 1 neuron with sigmoid
activation. Generated by makemoons_comparison.ipynb
online learning (see Section 19.7.5). In this section, we discuss some algorithmic approaches to
this problem in the context of DNNs. These methods are widely used for continual learning, which
we discuss Section 19.7.
17.5.1 Sequential Laplace for DNNs
In [RBB18b], they extended the Laplace method of Section 17.3.2 to the sequential setting. Specifically,
let p(θ|D1:t−1) ≈ N (θ|µt−1
, Λ
−1
t−1
) be the approximate posterior from the previous step; we assume
the precision matrix is Kronecker factored. We now compute the new mean by solving the MAP
problem
µt = argmax log p(Dt|θ) + log p(θ|Dt−1) (17.38)
= argmax log p(Dt|θ) −
1
2
(θ − µt−1
)Λ
−1
t−1
(θ − µt−1
) (17.39)
Once we have computed µt
, we compute the approximate Hessian at this point, and get the new
posterior precision
Λt = λH(µt
) + Λt−1 (17.40)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.5. ONLINE INFERENCE
where λ ≥ 0 is a weighting factor that trades off how much the model pays attention to the new data
vs old data.
Now suppose we use a diagonal approximation to the posterior prediction matrix. From Equa￾tion (17.39), we see that this amounts to adding a quadratic penalty to each new MAP estimate, to
encourage it to remain close to the parameters from previous tasks. This approach is called elastic
weight consolidation (EWC) [Kir+17].
17.5.2 Extended Kalman filtering for DNNs
In Section 29.7.2, we showed how Kalman filtering can be used to incrementally compute the
exact posterior for the weights of a linear regression model with known variance, i.e., we compute
p(θ|D1:t, σ2
), where D1:t = {(ui
, yi) : i = 1 : t} is the data seen so far, and
p(yt|ut, θ, σ2
) = N (yt|θ
Tut, σ2
) (17.41)
is the linear regression likelihood. The application of KF to this model is known as recursive least
squares.
Now consider the case of nonlinear regression:
p(yt|ut, θ, σ2
) = N (yt|f(θ,ut), σ2
) (17.42)
where f(θ,ut) is some nonlinear function, such as an MLP. We can use the extended Kalman filter
(Section 8.3.2) to approximately compute p(θt|D1:t, σ2
), where θt is the hidden state (see e.g., [SW89;
PF03]). To see this, note that we can set the dynamics model to the identity function, f(θt) = θt, so
the parameters are propagated through unchanged, and the observation model to the input-dependent
function f(θt) = f(θt,ut). We set the observation noise to Rt = σ
2
, and the dynamics noise to
Qt = qI, where q is a small constant, to allow the parameters to slowly drift according to artificial
process noise. (In practice it can be useful to anneal q from a large initial value to something near
0.)
17.5.2.1 Example
We now give an example of this process in action. We sample a synthetic dataset from the true
function
h
∗
(u) = x − 10 cos(u) sin(u) + u
3
(17.43)
and add Gaussian noise with σ = 3. We then fit this with an MLP with one hidden layer with H
hidden units, so the model has the form
f(θ,u) = W2 tanh(W1u + b1) + b2 (17.44)
where W1 ∈ R
H×1
, b1 ∈ R
H, W2 ∈ R
1×H, b2 ∈ R
1
. We set H = 6, so there are D = 19 parameters
in total.
Given the data, we sequentially compute the posterior, starting from a vague Gaussian prior,
p(θ) = N (θ|0, Σ0), where Σ0 = 100I. (In practice we cannot start from the prior mean, which is
θ0 = 0, since linearizing the model around this point results in a zero gradient, so we use an initial
random sample for θ0.) The results are shown in Figure 17.16. We can see that the model adapts
to the data, without having to specify any learning rate. In addition, we see that the predictions
become gradually more confident, as the posterior concentrates on the MLE.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license666
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−2 0 2
−20
0
20
Step=10
(a)
−2 0 2
−20
0
20
Step=20
(b)
−2 0 2
−20
0
20
Step=30
(c)
−2 0 2
−20
0
20
Step=200
(d)
Figure 17.16: Sequential Bayesian inference for the parameters of an MLP using the extended Kalman
filter. We show results after seeing the first 10, 20, 30 and 200 observations. (For a video of this, see
https: // bit. ly/ 3wXnWaM .) Generated by ekf_mlp.ipynb.
17.5.2.2 Setting the variance terms
In the above example, we set the variance terms by hand. In general we need to estimate the noise
variance σ, which determines Rt and hence the learning rate, as well as the strength of the prior Σ0,
which controls the amount of regularization. Some methods for doing this are discussed in [FNG00].
17.5.2.3 Reducing the computational complexity
The naive EKF method described above takes O(N3
z
) time, which is prohibitive for large neural
networks. A simple approximation, known as the decoupled EKF, was proposed in [PF91; SPD92]
(see [PF03] for a review). This partitions the weights into G groups or blocks, and estimates the
relevant matrices for each group g independently. If G = 1, this reduces the standard global EKF.
If we put each weight into its own group, we get a fully diagonal approximation. In practice this
does not work any better than SGD, since it ignores correlations between the parameters. A useful
compromise is to put all the weights corresponding to each neuron into its own group; this is called
node decoupled EKF, which has been used in [Sim02] to train RBF networks and [GUK21] to
train exponential family matrix factorization models (widely used in recommender systems). For
more details on DEKF, Supplementary Section 17.1.
Another approach to increasing computational efficiency is to leverage the fact that the effective
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.5. ONLINE INFERENCE
dimensionality of a DNN is often quite low (see Section 17.4.3). Indeed we can approximate the
model parameters by using a low dimensional vector of coefficients that specify the point in a linear
manifold corresponding to weight space; the basis set defining this linear manifold can either be
chosen randomly [Li+18b; GARD18; Lar+22], or can be estimated using PCA applied to the SGD
iterates [Izm+19]. We can exploit this observation to perform EKF in this low-dimensional subspace,
which significantly speeds up inference, as discussed in [DMKM22].
17.5.3 Assumed density filtering for DNNs
In Section 8.6.3, we discussed how to use assumed density filtering (ADF) to perform online (binary)
logistic regression. In this section, we generalize this to nonlinear predictive models, such as DNNs.
The key is to perform Gaussian moment matching of the hidden activations at each layer of the model.
This provides an alternative to the EKF approach in Section 17.5.2, which is based on linearization
of the network.
We will assume the following likelihood:
p(yt|ut, wt) = Expfam(yt|ℓ
−1
(f(ut; wt))) (17.45)
where f(x; w) is the DNN, ℓ
−1
is the inverse link function, and Expfam() is some exponential family
distribution. For example, if f is linear and we are solving a binary classification problem, we can
write
p(yt|ut, wt) = Ber(yt|σ(u
T
t wt)) (17.46)
We discussed using ADF to fit this model in Section 8.6.3.
In [HLA15b], they propose probabilistic backpropagation (PBP), which is an instance of ADF
applied to MLPs. The basic idea is to approximate the posterior over the weights in each layer using
a fully factorized distribution
p(wt|D1:t) ≈ pt(wt) = Y
L
l=1
Y
Dl
i=1
DlY−1+1
j=1
N (wijl|µ
t
ijl, τ t
ijl) (17.47)
where L is the number of layers, and Dl
is the number of neurons in layer l. (The expectation
backpropagation algorithm of [SHM14] is a special case of this, where the variances are fixed to
τ = 1.)
Suppose the parameters are static, so wt = wt−1. Then the new posterior, after conditioning on
the t’th observation, is given by
pˆt(w) = 1
Zt
p(yt|ut, w)N (w|µ
t−1
, Σ
t−1
) (17.48)
where Σ
t−1 = diag(τ
t−1
). We then project pˆt(w) instead the space of factored Gaussians to compute
the new (approximate) posterior, pt(w). This can be done by computing the following means and
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license668
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
variances [Min01a]:
µ
t
ijl = µ
t−1
ijl + τ
t−1
ijl
∂ lnZt
∂µt−1
ijl
(17.49)
τ
t
ijl = τ
t−1
ijl − (τ
t−1
ijl )
2


 
∂ lnZt
∂µt−1
ijl !2
− 2
∂ lnZt
∂τ t−1
ijl

 (17.50)
In the forwards pass, we compute Zt by propagating the input ut through the model. Since we have
a Gaussian distribution over the weights, instead of a point estimate, this induces an (approximately)
Gaussian distribution over the values of the hidden units. For certain kinds of activation functions
(such as ReLU), the relevant integrals (to compute the means and variances) can be solved analytically,
as in GP-neural networks (Section 18.7). The result is that we get a Gaussian distribution over the
final layer of the form N (ηt
|µ, Σ), where ηt = f(ut; wt) is the output of the neural network before
the GLM link function induced by pt(wt). Hence we can approximate the partition function using
Zt ≈
Z
p(yt|ηt
)N (ηt
|µ, Σ)dηt
(17.51)
We now discuss how to compute this integral. In the case of probit classification, with y ∈ {−1, +1},
we have p(y|x, w) = Φ(yη), where Φ is the cdf of the standard normal. We can then use the following
analytical result
Z
Φ(yη)N (h|µ, σ)dη = Φ 
yµ
√
1 + σ

(17.52)
In the case of logistic classification, with y ∈ {0, 1}, we have p(y|x, w) = Ber(y|σ(η)); in this case,
we can use the probit approximation from Section 15.3.6. For the multiclass case, where y ∈ {0, 1}
C
(one-hot encoding), we have p(y|x, w) = Cat(y|softmax(η)). A variational lower bound to log Zt for
this case is given in [GDFY16].
Once we have computed Zt, we can take gradients and update the Gaussian posterior moments,
before moving to the next step.
17.5.4 Online variational inference for DNNs
A natural approach to online learning is to use variational inference, where the prior is the posterior
from the previous step. This is known as streaming variational Bayes [Bro+13]. In more detail,
at step t, we compute
ψt = argmin
ψ
Eq(θ|ψ)
[ℓt(θ)] + DKL ￾
q(θ|ψ) k q(θ|ψt−1
)

| {z }
−Łt(ψ)
(17.53)
= argmin
ψ
Eq(θ|ψ)

ℓt(θ) + log q(θ|ψ) − log q(θ|ψt−1
)

(17.54)
where ℓt(θ) = − log p(Dt|θ) is the negative log likelihood (or, more generally, some loss function) of
the data batch at step t.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.6. HIERARCHICAL BAYESIAN NEURAL NETWORKS
When applied to DNNs, this approach is called variational continual learning or VCL [Ngu+18].
(We discuss continual learning in Section 19.7.) An efficient implementation of this, known as FOO￾VB (“fixed-point operator for online variational Bayes”) is given in [Zen+21].
One problem with the VCL objective in Equation (17.53) is that the KL term can cause the
model to become too sparse, which can prevent the model from adapting or learning new tasks.
This problem is called variational overpruning [TT17]. More precisely, the reason this happens
as is as follows: some weights might not be needed to fit a given dataset, so their posterior will be
equal to the prior, but sampling from these high-variance weights will add noise to the likeilhood; to
reduce this, the optimization method will prefer to set the bias term to a large negative value, so
the corresponding unit is “turned off”, and thus has no effect on the likelihood. Unfortunately, these
“dead units” become stuck, so there is not enough network capacity to learn the next task.
In [LST21], they propose a solution to this, known as generalized variational continual
learning or GVCL. The first step is to downweight the KL term by a factor β < 1 to get
Łt = Eq(θ|ψ)
[ℓt(θ)] + βDKL ￾
q(θ|ψ) k q(θ|ψt−1
)

(17.55)
Interestingly, one can show that in the limit of β → 0, this recovers several standard methods that
use a Laplace approximation based on the Hessian. In particular if we use a diagonal variational
posterior, this reduces to online EWC method of [Sch+18]; if we use a block-diagonal and Kronecker
factored posterior, this reduces to the online structured Laplace method of [RBB18b]; and if we use
a low-rank posterior precision matrix, this reduces to the SOLA method of [Yin+20].
The second step is to replace the prior and posterior by using tempering, which is useful when
the model is misspecified, as discussed in Section 17.3.11. In the case of Gaussians, raising the
distribution to the power λ is equivalent to tempering with a temperature of τ = 1/λ, which is the
same as scaling the covariance by λ
−1
. Thus the GVCL objective becomes
Łt = Eq(θ|ψ)
[ℓt(θ)] + βDKL ￾
q(θ|ψ)
λ
k q(θ|ψt−1
)
λ

(17.56)
This can be optimized using SGD, assuming the posterior is reparameterizable (see Section 10.2.1).
17.6 Hierarchical Bayesian neural networks
In some problems, we have multiple related datasets, such as a set of medical images from different
hospitals. Some aspects of the data (e.g., the shape of healthy vs diseased cells) is generally the same
across datasets, but other aspects may be unique or idiosyncractic (e.g., each hospital may use a
different colored die for staining). To model this, we can use a hierarchical Bayesian model, in which
we allow the parameters for each dataset to be different (to capture random effects), while coming from
a common prior (to capture shared effects). This is the setup we considered in Section 15.5, where
we discuss hierarchical Bayesian GLMs. In this section, we extend this to nonlinear predictors based
on neural networks. (The setup is very similar to domain generalization, discussed in Section 19.6.2,
except here we care about performance on all the domains, not just a held-out target domain.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licen670
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−2 −1 0 1 2 3
X1
−2.0
−1.5
−1.0
−0.5
0.0
0.5
1.0
1.5
2.0
X
2
Two moons dataset
Class 0
Class 1
(a)
−2
0
2
Task 1 Task 2
0.0 2.5
−2
0
2
Task 3
0.0 2.5
Task 4
Class 0
Class 1
(b)
Figure 17.17: (a) Two moons synthetic dataset. (b) Multi-task version, where we rotate the data to create
18 related tasks (groups). Each dataset has 50 training and 50 test points. Here we show the first 4 tasks.
Generated by bnn_hierarchical.ipynb.
17.6.1 Example: multimoons classification
In this section, we consider an example2 where we want to solve multiple related nonlinear binary
classification problems coming from J different environments or distributions. We assume that each
environment has its own unique decision boundary p(y|x, wj
), so this is a form of concept shift (see
Section 19.2.3). However we assume the overall shape of each boundary is similar to a common shared
boundary, denote p(y|x, w0
). We only have a small number Nj of examples from each environment,
Dj = {(x
j
n
, yj
n
) : n = 1 : Nj}, but we can utilize their common structure to do better than fitting J
separate models.
To illustrate this, we create some synthetic 2d data for the J = 18 tasks. We start with the
two-moons dataset, illustrated in Figure 17.17a. Each task is obtained by rotating the 2d inputs by a
different amount, to create 18 related classification problems (see Figure 17.17b). See Figure 17.17b
for the training data for 4 tasks.
To handle the nonlinear decision boundary, we use a multilayer perceptron. Since the dataset is
low-dimensional (2d input), we use a shallow model with just 2 hidden layers, each with 5 neurons.
We could fit a separate MLP to each task, but since we have limited data per task (Nj = 50 examples
for training), this works poorly, as we show below. We could also pool all the data and fit a single
model, but this does even worse, since the datasets come from different underlying distributions, so
mixing the data together from different “concepts” confuses the model. Instead we adopt a hierarchical
Bayesian approach.
Our modeling assumptions are shown in Figure 17.18. In particular, we assume the weight from
2. This example is from https://twiecki.io/blog/2018/08/13/hierarchical_bayesian_neural_network/. For a
real-world example of a similar approach applied to a gesture recognition task, see [Jos+17].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
17.6. HIERARCHICAL BAYESIAN NEURAL NETWORKS
y
e
n
z
j
2n
z
j
1n
x
j
n
n = 1 : Nj
w
j
3
ǫ
j
3
w
j
2
ǫ
j
2
w
j
1
ǫ
j
1
j = 1 : J
σ
0
3
w
0
3
σ
0
2
w
0
2
σ
0
1
w
0
1
Figure 17.18: Illustration of a hierarchical Bayesian MLP with 2 hidden layers. There are J different models,
each with Nj observed samples, and a common set of global shared parent parameters denoted with the 0
superscript. Nodes which are shaded are observed. Nodes with double ringed circles are deterministic functions
of their parents.
unit i to unit k in layer l for environment j, denoted w
j
i,k,l, comes from a common prior value w
0
i,k,l,
with a random offset. We use the non-centered parameterization from Section 12.6.5 to write
w
j
i,k,l = w
0
i,k,l + ǫ
j
i,k,l × σ
0
l
(17.57)
where ǫ
j
i,k,l ∼ N (0, 1). By allowing a different σ
0
l
per layer l, we let the model control the degree
of shrinkage to the prior for each layer separately. (We could also make the σ
j
l
parameters be
environment specific, which would allow for different amounts of distribution shift from the common
parent.) For the hyper-parameters, we put N (0, 1) priors on w
0
i,k,l, and N+(1) priors on σ
0
l
.
We compute the posterior p(ǫ
1:J
1:L
, w0
1:L
,σ
0
1:L
|D) using HMC (Section 12.5). We then evaluate this
model using a fresh set of labeled samples from each environment. The average classification accuracy
on the train and test sets for the non-hierarchical model (one MLP per environment, fit separately)
is 86% and 83%. For the hierarchical model, this improves to 91% and 89% respectively.
To see why the hierarchical model works better, we will plot the posterior predictive distribution
in 2d. Figure 17.19(top) shows the results for the nonhierarchical models; we see that the method
fails to learn the common underlying Z-shaped decision boundary. By contrast, Figure 17.19(bottom)
shows that the hierarchical method has correctly recovered the common pattern, while still allowing
group variation.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license672
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−2.5 0.0 2.5
−2
0
2
Dataset 1
−2.5 0.0 2.5
Dataset 2
−2.5 0.0 2.5
Dataset 3
−2.5 0.0 2.5
Dataset 4
Class 0
Class 1
−2.5 0.0 2.5
−2
0
2
Dataset 1
−2.5 0.0 2.5
Dataset 2
−2.5 0.0 2.5
Dataset 3
−2.5 0.0 2.5
Dataset 4
Class 0
Class 1
Figure 17.19: Top: Results of fitting separate MLPs on each dataset. Bottom: Results of fitting hierarchical
MLP on all datasets jointly. Generated by bnn_hierarchical.ipynb.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 202318 Gaussian processes
This chapter is coauthored with Andrew Wilson.
18.1 Introduction
Deep neural networks are a family of flexible function approximators of the form f(x; θ), where the
dimensionality of θ (i.e., the number of parameters) is fixed, and independent of the size N of the
training set. However, such parametric models can overfit when N is small, and can underfit when N
is large, due to their fixed capacity. In order to create models whose capacity automatically adapts
to the amount of data, we turn to nonparametric models.
There are many approaches to building nonparametric models for classification and regression (see
e.g., [Was06]). In this chapter, we consider a Bayesian approach in which we represent uncertainty
about the input-output mapping f by defining a prior distribution over functions, and then updating
it given data. In particular, we will use a Gaussian process to represent the prior p(f); we
then use Bayes’ rule to derive the posterior p(f|D), which is another GP, as we explain below.
More details on GPs can be found the excellent book [RW06], as well as the interative tutorial at
https://distill.pub/2019/visual-exploration-gaussian-processes. See also Chapter 31 for
other examples of Bayesian nonparametric models.
18.1.1 GPs: what and why?
To explain GPs in more detail, recall that a Gaussian random vector of length N, f = [f1, . . . , fN ],
is defined by its mean µ = E [f] and its covariance Σ = Cov [f]. Now consider a function f : X → R
evaluated at a set of inputs, X = {xn ∈ X }N
n=1. Let fX = [f(x1), . . . , f(xN )] be the set of unknown
function values at these points. If fX is jointly Gaussian for any set of N ≥ 1 points, then we
say that f : X → R is a Gaussian process. Such a process is defined by its mean function
m(x) ∈ R and a covariance function, K(x, x
′
) ≥ 0, which is any positive definite Mercer kernel
(see Section 18.2). For example, we might use an RBF kernel of the form K(x, x
′
) ∝ exp(−||x−x
′
||2
)
(see Section 18.2.1.1 for details).
We denote the corresponding GP by
f(x) ∼ GP(m(x), K(x, x
′
)) (18.1)674
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
x1 x2 x!
f1 f2 f!
y1 y2 y!
Figure 18.1: A Gaussian process for 2 training points, x1 and x2, and 1 testing point, x∗, represented as
a graphical model representing p(y, fX|X) = N (fX|m(X), K(X)) Q
i
p(yi|fi). The hidden nodes fi = f(xi)
represent the value of the function at each of the datapoints. These hidden nodes are fully interconnected
by undirected edges, forming a Gaussian graphical model; the edge strengths represent the covariance terms
Σij = K(xi, xj ). If the test point x∗ is similar to the training points x1 and x2, then the value of the hidden
function f∗ will be similar to f1 and f2, and hence the predicted output y∗ will be similar to the training
values y1 and y2.
where
m(x) = E [f(x)] (18.2)
K(x, x
′
) = E

(f(x) − m(x))(f(x
′
) − m(x
′
))T

(18.3)
This means that, for any finite set of points X = {x1, . . . , xN }, we have
p(fX|X) = N (fX|µX, KX,X) (18.4)
where µX = (m(x1), . . . , m(xN )) and KX,X(i, j) , K(xi
, xj ).
A GP can be used to define a prior over functions. We can evaluate this prior at any set of points
we choose. However, to learn about the function from data, we have to update this prior with a
likelihood function. We typically assume we have a set of N iid observations D = {(xi
, yi) : i = 1 : N},
where yi ∼ p(y|f(xi)), as shown in Figure 18.1. If we use a Gaussian likelihood, we can compute the
posterior p(f|D) in closed form, as we discuss in Section 18.3. For other kinds of likelihoods, we will
need to use approximate inference, as we discuss in Section 18.4. In many cases f is not directly
observed, and instead forms part of a latent variable model, both in supervised and unsupervised
settings such as in Section 28.3.7.
The generalization properties of a Gaussian process are controlled by its covariance function
(kernel), which we describe in Section 18.2. These kernels live in a reproducing kernel Hilbert space
(RKHS), described in Section 18.3.7.1.
GPs were originally designed for spatial data analysis, where the input is 2d. This special case
is called kriging. However, they can be applied to higher dimensional inputs. In addition, while
they have been traditionally limited to small datasets, it is now possible to apply GPs to problems
with millions of points, with essentially exact inference. We discuss these scalability advances in
Section 18.5.
Moreover, while Gaussian processes have historically been considered smoothing interpolators, GPs
now routinely perform representation learning, through covariance function learning, and multilayer
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.2. MERCER KERNELS
models. These advances have clearly illustrated that GPs and neural networks are not competing,
but complementary, and can be combined for better performance than would be achieved by deep
learning alone. We describe GPs for representation learning in Section 18.6.
The connections between Gaussian processes and neural networks can also be further understood
by considering infinite limits of neural networks that converge to Gaussian processes with particular
covariance functions, which we describe in Section 18.7.
So Gaussian processes are nonparametric models which can scale and do representation learning.
But why, in the age of deep learning, should we want to use a Gaussian process? There are several
compelling reasons to prefer a GP, including:
• Gaussian processes typically provide well-calibrated predictive distributions, with a good char￾acterization of epistemic (model) uncertainty — uncertainty arising from not knowing which of
many solutions is correct. For example, as we move away from the data, there are a greater variety
of consistent solutions, and so we expect greater uncertainty.
• Gaussian processes are often state-of-the-art for continuous regression problems, especially spa￾tiotemporal problems, such as weather interpolation and forecasting. In regression, Gaussian
process inference can also typically be performed in closed form.
• The marginal likelihood of a Gaussian process provides a powerful mechanism for flexible kernel
learning. Kernel learning enables us to provide long-range extrapolations, but also tells us
interpretable properties of the data that we didn’t know before, towards scientific discovery.
• Gaussian processes are often used as a probabilistic surrogate for optimizing expensive objectives,
in a procedure known as Bayesian optimization (Section 6.6).
18.2 Mercer kernels
The generalization properties of Gaussian processes boil down to how we encode prior knowledge
about the similarity of two input vectors. If we know that xi
is similar to xj , then we can encourage
the model to make the predicted output at both locations (i.e., f(xi) and f(xj )) to be similar.
To define similarity, we introduce the notion of a kernel function. The word “kernel” has many
different meanings in mathematics; here we consider a Mercer kernel, also called a positive
definite kernel. This is any symmetric function K : X × X → R
+ such that
X
N
i=1
X
N
j=1
K(xi
, xj )cicj ≥ 0 (18.5)
for any set of N (unique) points xi ∈ X , and any choice of numbers ci ∈ R. We assume K(xi
, xj ) > 0,
so that we can only achieve equality in the above equation if ci = 0 for all i.
Another way to understand this condition is the following. Given a set of N datapoints, let us
define the Gram matrix as the following N × N similarity matrix:
K =


K(x1, x1) · · · K(x1, xN )
.
.
.
K(xN , x1) · · · K(xN , xN )

 (18.6)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license676
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We say that K is a Mercer kernel iff the Gram matrix is positive definite for any set of (distinct)
inputs {xi}
N
i=1.
We discuss several popular Mercer kernels below. More details can be found at [Wil14] and
https://www.cs.toronto.edu/~duvenaud/cookbook/. See also Section 18.6 where we discuss how
to learn kernels from data.
18.2.1 Stationary kernels
For real-valued inputs, X = R
D, it is common to use stationary kernels (also called shift-invariant
kernels), which are functions of the form K(x, x
′
) = K(r), where r = x − x
′
; thus the output
only depends on the relative difference between the inputs. (See Section 18.2.2 for a discussion
of non-stationary kernels.) Furthermore, in many cases, all that matters is the magnitude of the
difference:
r = ||r||2 = ||x − x
′
|| (18.7)
We give some examples below. (See also Figure 18.3 and Figure 18.4 for some visualizations of these
kernels.)
18.2.1.1 Squared exponential (RBF) kernel
The squared exponential (SE) kernel, also sometimes called the exponentiated quadratic kernel
or the radial basis function (RBF) kernel, is defined as
K(r; ℓ) = exp 
−
r
2
2ℓ
2

(18.8)
Here ℓ corresponds to the length-scale of the kernel, i.e., the distance over which we expect
differences to matter.
From Equation (18.7) we can rewrite this kernel as
K(x, x
′
; ℓ) = exp

−
||x − x
′
||2
2ℓ
2

(18.9)
This is the RBF kernel we encountered earlier. It is also sometimes called the Gaussian kernel.
See Figure 18.3(f) and Figure 18.4(f) for a visualization in 1D.
18.2.1.2 ARD kernel
We can generalize the RBF kernel by replacing Euclidean distance with Mahalanobis distance, as
follows:
K(r; Σ, σ2
) = σ
2
exp 
−
1
2
r
TΣ
−1
r

(18.10)
where r = x − x
′
. If Σ is diagonal, this can be written as
K(r; ℓ, σ2
) = σ
2
exp 
−
1
2
X
D
d=1
1
ℓ
2
d
r
2
d
!
=
Y
D
d=1
K(rd; ℓd, σ2/d) (18.11)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.2. MERCER KERNELS
input x1
−2
0
input
2
x2
−2
0
2
output
y
-1
0
1
2
( a) input x1
−2
0
input
2
x2
−2
0
2
-1
0
1
2
( b)
−1
0
1
Figure 18.2: Function samples from a GP with an ARD kernel. (a) ℓ1 = ℓ2 = 1. Both dimensions contribute
to the response. (b) ℓ1 = 1, ℓ2 = 5. The second dimension is essentially ignored. Adapted from Figure 5.1 of
[RW06]. Generated by gpr_demo_ard.ipynb.
where
K(r; ℓ, τ 2
) = τ
2
exp 
−
1
2
1
ℓ
2
r
2

(18.12)
We can interpret σ
2 as the overall variance, and ℓd as defining the characteristic length scale of
dimension d. If d is an irrelevant input dimension, we can set ℓd = ∞, so the corresponding dimension
will be ignored. This is known as automatic relevance determination or ARD (Section 15.2.8).
Hence the corresponding kernel is called the ARD kernel. See Figure 18.2 for an illustration of
some 2d functions sampled from a GP using this prior.
18.2.1.3 Matérn kernels
The SE kernel gives rise to functions that are infinitely differentiable, and therefore are very smooth.
For many applications, it is better to use the Matérn kernel, which gives rise to “rougher” functions,
which can better model local “wiggles” without having to make the overall length scale very small.
The Matérn kernel has the following form:
K(r; ν, ℓ) = 2
1−ν
Γ(ν)
 √
2νr
ℓ
!ν
Kν
 √
2νr
ℓ
!
(18.13)
where Kν is a modified Bessel function and ℓ is the length scale. Functions sampled from this GP
are k-times differentiable iff ν > k. As ν → ∞, this approaches the SE kernel.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license678
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−10 0 10
(a) Matern12 k(x,0.0)
0
1
−10 0 10
(b) Matern32 k(x,0.0)
0
1
−10 0 10
(c) Matern52 k(x,0.0)
0
1
−10 0 10
(d) Periodic k(x,0.0)
0.5
1.0
−10 0 10
(e) Cosine k(x,0.0)
−1
0
1
−10 0 10
(f) RBF k(x,0.0)
0
1
−10 0 10
(g) Rational quadratic k(x,0.0)
0
1
−10 0 10
(h) Constant k(x,0.0)
0.95
1.00
1.05
−10 0 10
(i) Linear k(x,1.0)
−20
0
20
−10 0 10
(j) Quadratic k(x,1.0)
0
100
−10 0 10
(k) Polynomial k(x,1.0)
−5
0
5
−10 0 10
(l) White noise k(x,0.0)
0
1
Figure 18.3: GP kernels evaluated at k(x, 0) as a function of x. Generated by gpKernelPlot.ipynb.
For values ν ∈ { 1
2
,
3
2
,
5
2
}, the function simplifies as follows:
K(r;
1
2
, ℓ) = exp(−
r
ℓ
) (18.14)
K(r;
3
2
, ℓ) =
 
1 +
√
3r
ℓ
!
exp 
−
√
3r
ℓ
!
(18.15)
K(r;
5
2
, ℓ) =
 
1 +
√
5r
ℓ
+
5r
2
3ℓ
2
!
exp 
−
√
5r
ℓ
!
(18.16)
See Figure 18.3(a-c) and Figure 18.4(a-c) for a visualization.
The value ν =
1
2
corresponds to the Ornstein-Uhlenbeck process, which describes the velocity
of a particle undergoing Brownian motion. The corresponding function is continuous but not
differentiable, and hence is very “jagged”.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.2. MERCER KERNELS
−10 0 10
(a) Matern12
−2.5
0.0
2.5
−10 0 10
(b) Matern32
−2.5
0.0
2.5
−10 0 10
(c) Matern52
−2.5
0.0
2.5
−10 0 10
(d) Periodic
0
1
−10 0 10
(e) Cosine
−1
0
1
−10 0 10
(f) RBF
−2.5
0.0
2.5
−10 0 10
(g) Rational quadratic
0.0
2.5
−10 0 10
(h) Constant
0
1
−10 0 10
(i) Linear
−10
0
−10 0 10
(j) Quadratic
0
100
−10 0 10
(k) Polynomial
−5
0
5
−10 0 10
(l) White noise
−2.5
0.0
2.5
Figure 18.4: GP samples drawn using different kernels. Generated by gpKernelPlot.ipynb.
18.2.1.4 Periodic kernels
One way to create a periodic 1d random function is to map x to the 2d space u(x) = (cos(x),sin(x)),
and then use an SE kernel in u-space:
K(x, x′
) = exp 
−
2 sin2
((x − x
′
)/2)
ℓ
2

(18.17)
which follows since (cos(x)−cos(x
′
))2 + (sin(x)−sin(x
′
))2 = 4 sin2
((x−x
′
)/2). We can generalize this
by specifying the period p to get the periodic kernel, also called the exp-sine-squared kernel:
Kper(r; ℓ, p) = exp 
−
2
ℓ
2
sin2
(π
r
p
)

(18.18)
where p is the period and ℓ is the length scale. See Figure 18.3(d-e) and Figure 18.4(d-e) for a
visualization.
A related kernel is the cosine kernel:
K(r; p) = cos 
2π
r
p

(18.19)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license680
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.2.1.5 Rational quadratic kernel
We define the rational quadratic kernel to be
KRQ(r; ℓ, α) = 
1 +
r
2
2αℓ2
−α
(18.20)
We recognize this is proportional to a Student t density. Hence it can be interpreted as a scale
mixture of SE kernels of different characteristic lengths. In particular, let τ = 1/ℓ2
, and assume
τ ∼ Ga(α, ℓ2
). Then one can show that
KRQ(r) = Z
p(τ |α, ℓ2
)KSE(r|τ )dτ (18.21)
As α → ∞, this reduces to a SE kernel.
See Figure 18.3(g) and Figure 18.4(g) for a visualization.
18.2.1.6 Kernels from spectral densities
Consider the case of a stationary kernel which satisfies K(x, x
′
) = K(δ), where δ = x − x
′
, for
x, x
′ ∈ R
d
. Let us further assume that K(δ) is positive definite. In this case, Bochner’s theorem
tells us that we can represent K(δ) by its Fourier transform:
K(δ) = Z
Rd
p(ω)e
jω
Tδ
dω (18.22)
where j =
√
−1, e
jθ = cos(θ) + j sin(θ), ω is the frequency, and p(ω) is the spectral density (see
[SS19, p93, p253] for details).
We can easily derive and gain intuitions into several kernels from spectral densities. If we take
the Fourier transform of an RBF kernel we find the spectral density p(ω) = √
2πℓ2 exp ￾
−2π
2ω
2
ℓ
2

.
Thus the spectral density is also Gaussian, but with a bandwidth inversely proportional to the
length-scale hyperparameter ℓ. That is, as ℓ becomes large, the spectral density collapses onto a
point mass. This result is intuitive: as we increase the length-scale, our model treats points as
correlated over large distances, and becomes very smooth and slowly varying, and thus low-frequency.
In general, since the Gaussian distribution has relatively light tails, we can see that RBF kernels
won’t generally support high frequency solutions.
We can instead use a Student t spectral density, which has heavy tails that will provide greater
support for higher frequencies. Taking the inverse Fourier transform of this spectral density, we
recover the Matérn kernel, with degrees of freedom ν corresponding to the degrees of freedom in
the spectral density. Indeed, the smaller we make ν, the less smooth and higher frequency are the
associated fits to data using a Matérn kernel.
We can also derive spectral mixture kernels by modelling the spectral density as a scale-location
mixture of Gaussians and taking the inverse Fourier transform [WA13]. Since scale-location mixtures
of Gaussians are dense in the set of distributions, and can therefore approximate any spectral density,
this kernel can approximate any stationary kernel to arbitrary precision. The spectral mixture kernel
thus forms a powerful approach to kernel learning, which we discuss further in Section 18.6.5.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.2. MERCER KERNELS
18.2.2 Nonstationary kernels
A stationary kernel assumes the measure of similarity between two inputs is independent of their
location, i.e., K(x, x
′
) only depends on r = x−x
′
. A nonstationary kernel relaxes this assumption.
This is useful for a variety of problems, such as environmental modeling (see e.g., [GSR12; Pat+22]),
where correlations between locations can change depending on latent factors in the environment.
18.2.2.1 Polynomial kernels
A simple form of non-stationary kernel is the polynomial kernel (also called dot product kernel)
of order M, defined by
K(x, x
′
) = (x
Tx
′
)
M (18.23)
This contains all monomials of order M. For example, if M = 2, we get the quadratic kernel; in
2d, this becomes
(x
Tx
′
)
2 = (x1x
′
1 + x2x
′
2
)
2 = (x1x
′
1
)
2 + (x2x2)
2 + 2(x1x
′
1
)(x2x
′
2
) (18.24)
We can generalize this to contain all terms up to degree M by using the inhomogeneous
polynomial kernel
K(x, x
′
) = (x
Tx
′ + c)
M (18.25)
For example, if M = 2 and the inputs are 2d, we have
(x
Tx
′ + 1)2 = (x1x
′
1
)
2 + (x1x
′
1
)(x2x
′
2
) + (x1x
′
1
)
+ (x2x2)(x1x
′
1
) + (x2x
′
2
)
2 + (x2x
′
2
)
+ (x1x
′
1
) + (x2x
′
2
) + 1 (18.26)
18.2.2.2 Gibbs kernel
Consider an RBF kernel where the length scale hyper-parameter, and the signal variance hyper￾parameter, are both input dependent; this is called the Gibbs kernel [Gib97], and is defined by
K(x, x
′
) = σ(x)σ(x
′
)
s
2ℓ(x)ℓ(x′)
ℓ(x)
2 + ℓ(x′)
2
exp 
−
||x − x
′
||2
ℓ(x)
2 + ℓ(x′)
2

(18.27)
If ℓ(x) and σ(x) are constants, this reduces to the standard RBF kernel. We can model the functional
dependency of these kernel parameters on the input by using another GP (see e.g., [Hei+16]).
18.2.2.3 Other non-stationary kernels
Other ways to induce non-stationarity include using a neural network kernel (Section 18.7.1), non￾stationary spectral kernels [RHK17], or a deep GP (Section 18.7.3).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license682
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.2.3 Kernels for nonvectorial (structured) inputs
Kernels are particularly useful when the inputs are structured objects, such as strings and graphs,
since it is often hard to “featurize” variable-sized inputs. For example, we can define a string kernel
which compares strings in terms of the number of n-grams they have in common [Lod+02; BC17].
We can also define kernels on graphs [KJM19]. For example, the random walk kernel conceptually
performs random walks on two graphs simultaneously, and then counts the number of paths that
were produced by both walks. This can be computed efficiently as discussed in [Vis+10]. For more
details on graph kernels, see [KJM19].
For a review of kernels on structured objects, see e.g., [Gär03].
18.2.4 Making new kernels from old
Given two valid kernels K1(x, x
′
) and K2(x, x
′
), we can create a new kernel using any of the following
methods:
K(x, x
′
) = cK1(x, x
′
), for any constant c > 0 (18.28)
K(x, x
′
) = f(x)K1(x, x
′
)f(x
′
), for any function f (18.29)
K(x, x
′
) = q(K1(x, x
′
)) for any function polynomial q with nonneg. coef. (18.30)
K(x, x
′
) = exp(K1(x, x
′
)) (18.31)
K(x, x
′
) = x
TAx
′
, for any psd matrix A (18.32)
For example, suppose we start with the linear kernel K(x, x
′
) = xx′
. We know this is a valid
Mercer kernel, since the corresponding Gram matrix is just the (scaled) covariance matrix of the data.
From the above rules, we can see that the polynomial kernel K(x, x
′
) = (x
Tx
′
)M from Section 18.2.2.1
is a valid Mercer kernel.
We can also use the above rules to establish that the Gaussian kernel is a valid kernel. To see this,
note that
||x − x
′
||2 = x
Tx + (x
′
)
Tx
′ − 2x
Tx
′
(18.33)
and hence
K(x, x
′
) = exp(−||x − x
′
||2
/2σ
2
) = exp(−x
Tx/2σ
2
) exp(x
Tx
′
/σ2
) exp(−(x
′
)
Tx
′
/2σ
2
) (18.34)
is a valid kernel.
We can also combine kernels using addition or multiplication:
K(x, x
′
) = K1(x, x
′
) + K2(x, x
′
) (18.35)
K(x, x
′
) = K1(x, x
′
) × K2(x, x
′
) (18.36)
Multiplying two positive-definite kernels together always results in another positive definite kernel.
This is a way to get a conjunction of the individual properties of each kernel, as illustrated in
Figure 18.5.
In addition, adding two positive-definite kernels together always results in another positive definite
kernel. This is a way to get a disjunction of the individual properties of each kernel, as illustrated in
Figure 18.6.
For an example of combining kernels to forecast some time series data, see Section 18.8.1.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.2. MERCER KERNELS
x (with x
′ = 1)
0
20
Lin x Lin
quadratic functions
−10
0
(a)
x (with x
′ = 1)
0.5
1.0
SE x Per
locally periodic
−2
0
(b)
x (with x
′ = 1)
0
1
Lin x SE
increasing variation
0
5
(c)
x (with x
′ = 1)
0
5
Lin x Per
growing amplitude
−5
0
5
(d)
Figure 18.5: Examples of 1d structures obtained by multiplying elementary kernels. Top row shows K(x, x′ = 1).
Bottom row shows some functions sampled from GP(f|0, K). Adapted from Figure 2.2 of [Duv14]. Generated
by combining_kernels_by_multiplication.ipynb.
x (with x
′ = 1)
0
5
Lin + Per
periodic plus trend
−2.5
0.0
2.5
(a)
x (with x
′ = 1)
1
2
SE + Per
periodic plus noise
−2.5
0.0
(b)
x (with x
′ = 1)
0
5
SE + Lin
linear plus variation
−2.5
0.0
2.5
(c)
x (with x
′ = 1)
1
2
SElong + SEshort
slow & fast variation
−2.5
0.0
(d)
Figure 18.6: Examples of 1d structures obtained by summing elementary kernels. Top row shows K(x, x′ = 1).
Bottom row shows some functions sampled from GP(f|0, K). Adapted from Figure 2.2 of [Duv14]. Generated
by combining_kernels_by_summation.ipynb.
18.2.5 Mercer’s theorem
Recall that any positive definite matrix K can be represented using an eigendecomposition of the
form K = UTΛU, where Λ is a diagonal matrix of eigenvalues λi > 0, and U is a matrix containing
the eigenvectors. Now consider element (i, j) of K:
kij = (Λ
1
2 U:i)
T
(Λ
1
2 U:j ) (18.37)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license684
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where U:i
is the i’th column of U. If we define φ(xi) = U:i
, then we can write
kij =
X
M
m=1
λmφm(xi)φm(xj ) (18.38)
where M is the rank of the kernel matrix. Thus we see that the entries in the kernel matrix can be
computed by performing an inner product of some feature vectors that are implicitly defined by the
eigenvectors of the kernel matrix.
This idea can be generalized to apply to kernel functions, not just kernel matrices, as we now show.
First, we define an eigenfunction φ() of a kernel K with eigenvalue λ wrt measure µ as a function
that satisfies
Z
K(x, x
′
)φ(x)dµ(x) = λφ(x
′
) (18.39)
We usually sort the eigenfunctions in order of decreasing eigenvalue, λ1 ≥ λ2 ≥ · · · . The eigenfunctions
are orthogonal wrt µ:
Z
φi(x)φj (x)dµ(x) = δij (18.40)
where δij is the Kronecker delta. With this definition in hand, we can state Mercer’s theorem.
Informally, it says that any positive definite kernel function can be represented as the following
infinite sum:
K(x, x
′
) = X∞
m=1
λmφm(x)φm(x
′
) (18.41)
where φm are eigenfunctions of the kernel, and λm are the corresponding eigenvalues. This is the
functional analog of Equation (18.38).
A degenerate kernel has only a finite number of non-zero eigenvalues. In this case, we can
rewrite the kernel function as an inner product between two finite-length vectors. For example,
consider the quadratic kernel K(x, x
′
) = hx, x
′
i
2
from Equation (18.24). If we define φ(x1, x2) =
[x
2
1
,
√
2x1x2, x2
2
] ∈ R
3
, then we can write this as K(x, x
′
) = φ(x)
Tφ(x). Thus we see that this kernel
is degenerate.
Now consider the RBF kernel. In this case, the corresponding feature representation is infinite
dimensional (see Section 18.2.6 for details). However, by working with kernel functions, we can avoid
having to deal with infinite dimensional vectors.
From the anove, we see that we can replace inner product operations in an explicit (possibly infinite
dimensional) feature space with a call to a kernel function, i.e., we replace φ(x)
Tφ(x) with K(x, x
′
).
This is called the kernel trick.
18.2.6 Approximating kernels with random features
Although the power of kernels resides in the ability to avoid working with featurized representations
of the inputs, such kernelized methods can take O(N3
) time, in order to invert the Gram matrix
K, as we wil see in Section 18.3. This can make it difficult to use such methods on large scale data.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.3. GPS WITH GAUSSIAN LIKELIHOODS
Fortunately, we can approximate the feature map for many kernels using a randomly chosen finite
set of M basis functions, thus reducing the cost to O(NM + M3
).
We will show how to do this for shift-invariant kernels by returning to Bochner’s theorem in
Eq. (18.22). In the case of a Gaussian RBF kernel, we have seen that the spectral density is a
Gaussian distribution. Hence we can easily compute a Monte Carlo approximation to this integral by
sampling random Gaussian vectors. This yields the following approximation: K(x, x
′
) ≈ φ(x)
Tφ(x),
where the (real-valued) feature vector is given by
φ(x) = r
1
D

sin(z
T
1x), · · · ,sin(z
T
Dx), cos(z
T
1x), · · · , cos(z
T
Dx)

(18.42)
=
r
1
D

sin(Z
Tx), cos(Z
Tx)

(18.43)
Here Z = (1/σ)G, and G ∈ R
d×D is a random Gaussian matrix, where the entries are sampled iid
from N (0, 1). The representation in Equation (18.43) are called random Fourier features (RFF)
[SS15; RR08] or “weighted sums of random kitchen sinks” [RR09]. (One can obtain an even better
approximation by ensuring that the rows of Z are random but orthogonal; this is called orthogonal
random features [Yu+16].)
One can create similar random feature representations for other kinds of kernels. We can then
use such features for supervised learning by defining f(x; θ) = Wϕ(Zx) + b, where Z is a random
Gaussian matrix, and the form of ϕ depends on the chosen kernel. This is equivalent to a one layer
MLP with random input-to-hidden weights; since we only optimize the hidden-to-output weights
θ = (W, b), the model is equivalent to a linear model with fixed random features. If we use enough
random features, we can approximate the performance of a kernelized prediction model, but the
computational cost is now O(N) rather than O(N2
).
Unfortunately, random features can result in worse performance than using a non-degenerate
kernel, since they don’t have enough expressive power. We discuss other ways to scale GPs to large
datasets in Section 18.5.
18.3 GPs with Gaussian likelihoods
In this section, we discuss GPs for regression, using a Gaussian likelihood. In this case, all the
computations can be performed in closed form, using standard linear algebra methods. We extend
this framework to non-Gaussian likelihoods later in the chapter.
18.3.1 Predictions using noise-free observations
Suppose we observe a training set D = {(xn, yn) : n = 1 : N}, where yn = f(xn) is the noise-free
observation of the function evaluated at xn. If we ask the GP to predict f(x) for a value of x that it
has already seen, we want the GP to return the answer f(x) with no uncertainty. In other words, it
should act as an interpolator of the training data. Here we assume the observed function values
are noiseless. We will consider the case of noisy observations shortly.
Now we consider the case of predicting the outputs for new inputs that may not be in D. Specifically,
given a test set X∗ of size N∗ × D, we want to predict the function outputs f∗ = [f(x1), . . . , f(xN∗
)].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license686
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−5 0 5
x
−2
−1
0
1
f
(a)
−5 0 5
x
−2
0
2
f
(b)
−5 0 5
x
−2
0
2
f
(c)
Figure 18.7: Left: some functions sampled from a GP prior with RBF kernel. Middle: some samples from
a GP posterior, after conditioning on 5 noise-free observations. Right: some samples from a GP posterior,
after conditioning on 5 noisy observations. The shaded area represents E [f(x)] ± 2
p
V[f(x)]. Adapted from
Figure 2.2 of [RW06]. Generated by gpr_demo_noise_free.ipynb.
By definition of the GP, the joint distribution p(fX, f∗|X, X∗) has the following form

fX
f∗

∼ N µX
µ∗

,

KX,X KX,∗
KT
X,∗ K∗,∗
 (18.44)
where µX = (m(x1), . . . , m(xN )), µ∗ = (m(x
∗
1
), . . . , m(x
∗
N∗
)), KX,X = K(X, X) is N × N, KX,∗ =
K(X, X∗) is N × N∗, and K∗,∗ = K(X∗, X∗) is N∗ × N∗. See Figure 18.7 for a static illustration,
and http://www.infinitecuriosity.org/vizgp/ for an interactive visualization.
By the standard rules for conditioning Gaussians (Section 2.3.1.4), the posterior has the following
form
p(f∗|X∗, D) = N (f∗|µ∗|X, Σ∗|X) (18.45)
µ∗|X = µ∗ + KT
X,∗K−1
X,X(fX − µX) (18.46)
Σ∗|X = K∗,∗ − KT
X,∗K−1KX,∗ (18.47)
This process is illustrated in Figure 18.7. On the left we show some samples from the prior, p(f),
where we use an RBF kernel (Section 18.2.1.1) and a zero mean function. On the right, we show
samples from the posterior, p(f|D). We see that the model perfectly interpolates the training data,
and that the predictive uncertainty increases as we move further away from the observed data.
Note that the cost of the above method for sampling N∗ points is O(N3
∗
). This can be reduced to
O(N∗) time using the methods in [Ple+18; Wil+20a].
18.3.2 Predictions using noisy observations
In Section 18.3.1, we showed how to do GP regression when the training data was noiseless. Now let us
consider the case where what we observe is a noisy version of the underlying function, yn = f(xn)+ǫn,
where ǫn ∼ N (0, σ2
y
). In this case, the model is not required to interpolate the data, but it must
come “close” to the observed data. The covariance of the observed noisy responses is
Cov [yi
, yj ] = Cov [fi
, fj ] + Cov [ǫi
, ǫj ] = K(xi
, xj ) + σ
2
y
δij (18.48)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.3. GPS WITH GAUSSIAN LIKELIHOODS
where δij = I(i = j). In other words
Cov [y|X] = KX,X + σ
2
y
IN (18.49)
The joint density of the observed data and the latent, noise-free function on the test points is given
by

y
f∗

∼ N µX
µ∗

,

KX,X + σ
2
y
I KX,∗
KT
X,∗ K∗,∗
 (18.50)
Hence the posterior predictive density at a set of test points X∗ is
p(f∗|D, X∗) = N (f∗|µ∗|X, Σ∗|X) (18.51)
µ∗|X = µ∗ + KT
X,∗
(KX,X + σ
2
y
I)
−1
(y − µX) (18.52)
Σ∗|X = K∗,∗ − KT
X,∗
(KX,X + σ
2
y
I)
−1KX,∗ (18.53)
In the case of a single test input, this simplifies as follows
p(f∗|D, x∗) = N (f∗|m∗ + k
T
∗
(KX,X + σ
2
y
I)
−1
(y − µX), k∗∗ − k
T
∗
(KX,X + σ
2
y
I)
−1k∗) (18.54)
where k∗ = [K(x∗, x1), . . . , K(x∗, xN )] and k∗∗ = K(x∗, x∗). If the mean function is zero, we can
write the posterior mean as follows:
µ∗|X = k
T
∗ K−1
σ y
| {z }
α
=
X
N
n=1
K(x∗, xn)αn (18.55)
where
Kσ = KX,X + σ
2
y
I (18.56)
α = K−1
σ y (18.57)
Fitting this model amounts to computing α in Equation (18.57). This is usually done by computing
the Cholesky decomposition of Kσ, as described in Section 18.3.6. Once we have computed α, we
can compute predictions for each test point in O(N) time for the mean, and O(N2
) time for the
variance.
18.3.3 Weight space vs function space
In this section, we show how Bayesian linear regression is a special case of a GP.
Consider the linear regression model y = f(x) + ǫ, where f(x) = wTφ(x) and ǫ ∼ N (0, σ2
y
). If we
use a Gaussian prior p(w) = N (w|0, Σw), then the posterior is as follows (see Section 15.2.2 for the
derivation):
p(w|D) = N (w|
1
σ
2
y
A−1Φ
T y, A−1
) (18.58)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license688
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where Φ is the N × D design matrix, and
A = σ
−2
y Φ
TΦ + Σ
−1
w (18.59)
The posterior predictive distribution for f∗ = f(x∗) is therefore
p(f∗|D, x∗) = N (f∗|
1
σ
2
y
φ
T
∗A−1Φ
Ty, φ
T
∗A−1φ∗
) (18.60)
where φ∗ = φ(x∗). This views the problem of inference and prediction in weight space.
We now show that this is equivalent to the predictions made by a GP using a kernel of the form
K(x, x
′
) = φ(x)
TΣwφ(x
′
). To see this, let K = ΦΣwΦ
T
, k∗ = ΦΣwφ∗
, and k∗∗ = φ
T
∗Σwφ∗
. Using
this notation, and the matrix inversion lemma, we can rewrite Equation (18.60) as follows
p(f∗|D, x∗) = N (f∗|µ∗|X, Σ∗|X) (18.61)
µ∗|X = φ
T
∗ΣwΦ
T
(K + σ
2
y
I)
−1y = k
T
∗
(KX,X + σyI)
−1y (18.62)
Σ∗|X = φ
T
∗Σwφ∗ − φ
T
∗ΣwΦ
T
(K + σ
2
y
I)
−1ΦΣwφ∗ = k∗∗ − k
T
∗
(KX,X + σ
2
y
I)
−1k∗ (18.63)
which matches the results in Equation (18.54), assuming m(x) = 0. A non-zero mean can be captured
by adding a constant feature with value 1 to φ(x).
Thus we can derive a GP from Bayesian linear regression. Note, however, that linear regression
assumes φ(x) is a finite length vector, whereas a GP allows us to work directly in terms of kernels,
which may correspond to infinite length feature vectors (see Section 18.2.5). That is, a GP works in
function space.
18.3.4 Semiparametric GPs
So far, we have mostly assumed the mean of the GP is 0, and have relied on its interpolation abilities
to model the mean function. Sometimes it is useful to fit a global linear model for the mean, and use
the GP to model the residual errors, as follows:
g(x) = f(x) + β
Tφ(x) (18.64)
where f(x) ∼ GP(0, K(x, x
′
)), and φ() are some fixed basis functions. This combines a parametric
and a non-parametric model, and is known as a semi-parametric model.
If we assume β ∼ N (b, B), we can integrate these parameters out to get a new GP [O’H78]:
g(x) ∼ GP￾
φ(x)
T
b, K(x, x
′
) + φ(x)
TBφ(x
′
)

(18.65)
Let HX = φ(X)
T be the D ×N matrix of training examples, and H∗ = φ(X∗)
T be the D ×N∗ matrix
of test examples. The corresponding predictive distribution for test inputs X∗ has the following form
[RW06, p28]:
E [g(X∗)|D] = HT
∗β + KT
X,∗K−1
σ
(y − HT
Xβ) = E [f(X∗)|D] + RTβ (18.66)
Cov [g(X∗)|D] = Cov [f(X∗)|D] + RT
(B
−1 + HXK−1
σ HT
X)
−1R (18.67)
β = (B
−1 + HXK−1
σ HT
X)
−1
(HXK−1
σ y + B
−1
b) (18.68)
R = H∗ − HXK−1
σ KX,∗ (18.69)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.3. GPS WITH GAUSSIAN LIKELIHOODS
These results can be interpreted as follows: the mean is the usual mean from the GP, plus a global
offset from the linear model, using β; and the covariance is the usual covariance from the GP, plus
an additional positive term due to the uncertainty in β.
In the limit of an uninformative prior for the regression parameters, as B → ∞I, this simplifies to
E [g(X∗)|D] = E [f(X∗)|D] + RT
(HXK−1
σ HT
X)
−1HXK−1
σ y (18.70)
Cov [g(X∗)|D] = Cov [f(X∗)|D] + RT
(HXK−1
σ HT
X)
−1R (18.71)
18.3.5 Marginal likelihood
Most kernels have some free parameters. For example, the RBF-ARD kernel (Section 18.2.1.2) has
the form
K(x, x
′
) = exp 
−
1
2
X
D
d=1
1
ℓ
2
d
(xd − x
′
d
)
2
!
=
Y
D
d=1
Kℓd
(xd, x′
d
) (18.72)
where each ℓd is a length scale for feature dimension d. Let these (and the observation noise variance
σ
2
y
, if present) be denoted by θ. We can compute the likelihood of these parameters as follows:
p(y|X, θ) = p(D|θ) = Z
p(y|fX, θ)p(fX|X, θ)dfX (18.73)
Since we are integrating out the function f, we often call θ hyperparameters, and the quantity p(D|θ)
the marginal likelihood.
Since f is a GP, we can compute the above integral using the marginal likelihood for the corre￾sponding Gaussian. This gives
log p(D|θ) = −
1
2
(y − µX)
TK−1
σ
(y − µX) −
1
2
log |Kσ| − N
2
log(2π) (18.74)
The first term is the square of the Mahalanobis distance between the observations and the predicted
values: better fits will have smaller distance. The second term is the log determinant of the covariance
matrix, which measures model complexity: smoother functions will have smaller determinants, so
− log |Kσ| will be larger (less negative) for simpler functions. The marginal likelihood measures the
tradeoff between fit and complexity.
In Section 18.6.1, we discuss how to learn the kernel parameters from data by maximizing the
marginal likelihood wrt θ.
18.3.6 Computational and numerical issues
In this section, we discuss computational and numerical issues which arise when implementing the
above equations. For notational simplicity, we assume the prior mean is zero, m(x) = 0.
The posterior predictive mean is given by µ∗ = k
T
∗K−1
σ y. For reasons of numerical stability, it is
unwise to directly invert Kσ. A more robust alternative is to compute a Cholesky decomposition,
Kσ = LLT, which takes O(N3
) time. Given this, we can compute
µ∗ = k
T
∗K−1
σ y = k
T
∗L
−T
(L
−1y) = k
T
∗α (18.75)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license690
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Here α = L
T \ (L \ y), where we have used the backslash operator to represent backsubstitution.
We can compute the variance in O(N2
) time for each test case using
σ
2
∗ = k∗∗ − k
T
∗L
−TL
−1k∗ = k∗∗ − v
Tv (18.76)
where v = L \ k∗.
Finally, the log marginal likelihood (needed for kernel learning, Section 18.6) can be computed
using
log p(y|X) = −
1
2
y
Tα −
X
N
n=1
log Lnn −
N
2
log(2π) (18.77)
We see that overall cost is dominated by O(N3
). We discuss faster, but approximate, methods in
Section 18.5.
18.3.7 Kernel ridge regression
The term ridge regression refers to linear regression with an ℓ2 penalty on the regression weights:
w∗ = argmin
w
X
N
n=1
(yn − f(xn; w))2 + λ||w||2
2
(18.78)
where f(x; w) = wTx. The solution for this is
w∗ = (XTX + λI)
−1XTy = (X
N
n=1
xnx
T
n + λI)
−1
(
X
N
n=1
xnyn) (18.79)
In this section, we consider a function space version of this:
f
∗ = argmin
f∈F
X
N
n=1
(yn − f(xn))2 + λ||f||2
(18.80)
For this to make sense, we have to define the function space F and the norm ||f||. If we use a
function space derived from a positive definite kernel function K, the resulting method is called
kernel ridge regression (KRR). We will see that the resulting estimate f
∗
(x∗) is equivalent to
the posterior mean of a GP. We give the details below.
18.3.7.1 Reproducing kernel Hilbert spaces
In this section, we briefly introduce the relevant mathematical “machinery” needed to explain KRR.
Let F = {f : X → R} be a space of real-valued funcitons. Elements of this space (i.e., functions)
can be added and scalar multiplied as if they were vectors. That is, if f ∈ F and g ∈ F, then
αf +βg ∈ F for α, β ∈ R. We can also define an inner product for F, which is a mapping hf, gi ∈ R
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.3. GPS WITH GAUSSIAN LIKELIHOODS
which satisfies the following:
hαf1 + βf2, gi = αhf1, gi + βhf2, gi (18.81)
hf, gi = hg, fi (18.82)
hf, fi ≥ 0 (18.83)
hf, fi = 0 iff f(x) = 0 for all x ∈ X (18.84)
We define the norm of a function using
||f|| ,
p
hf, fi (18.85)
A function space H with an inner product operator is called a Hilbert space. (We also require
that the function space be complete, which means that every Cauchy sequence of functions fi ∈ H
has a limit that is also in H.)
The most common Hilbert space is the space known as L
2
. To define this, we need to specify a
measure µ on the input space X ; this is a function that assigns any (suitable) subset A of X to a
positive number, such as its volume. This can be defined in terms of the density function w : X → R,
as follows:
µ(A) = Z
A
w(x)dx (18.86)
Thus we have µ(dx) = w(x)dx. We can now define L
2
(X , µ) to be the space of functions f : X → R
that satisfy
Z
X
f(x)
2w(x)dx < ∞ (18.87)
This is known as the set of square-integrable functions. This space has an inner product defined
by
hf, gi =
Z
X
f(x)g(x)w(x)dx (18.88)
We define a Reproducing Kernel Hilbert Space or RKHS as follows. Let H be a Hilbert
space of functions f : X → R. We say that H is an RKHS endowed with inner product h·, ·iH if there
exists a (symmetric) kernel function K : X × X → R with the following properties:
• For every x ∈ X , K(x, ·) ∈ H.
• K satisfies the reproducing property:
hf(·), K(·, x
′
)i = f(x
′
) (18.89)
The reason for the term “reproducing property” is as follows. Let f(·) = K(x, ·). Then we have that
hK(x, ·), K(·, x
′
)i = K(x, x
′
) (18.90)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license692
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.3.7.2 Complexity of a function in an RKHS
The main utility of RKHS from the point of view of machine learning is that it allows us to define a
notion of a function’s “smoothness” or “complexity” in terms of its norm, as we now discuss.
Suppose we have a positive definite kernel function K. From Mercer’s theorem we have K(x, x
′
P
) =
∞
i=1 λiφi(x)φi(x
′
P
). Now consider a Hilbert space H defined by functions of the form f(x) =
∞
i=1 fiφ(x), with P∞
i=1 f
2
i
/λ < ∞. The inner product of two functions in this space is
hf, giH =
X∞
i=1
figi
λi
(18.91)
Hence the (squared) norm is given by
||f||2
H = hf, fiH =
X∞
i=1
f
2
i
λi
(18.92)
This is analogous to the quadratic form f
TK−1f which occurs in some GP objectives (see Equa￾tion (18.101)). Thus the smoothness of the function is controlled by the properties of the corresponding
kernel.
18.3.7.3 Representer theorem
In this section, we consider the problem of (regularized) empirical risk minimization in function space.
In particular, consider the following problem:
f
∗ = argmin
f∈HK
X
N
n=1
ℓ(yn, f(xn)) + λ
2
||f||2
H (18.93)
where HK is an RKHS with kernel K and ℓ(y, yˆ) ∈ R is a loss function. Then one can show [KW70;
SHS01] the following result:
f
∗
(x) = X
N
n=1
αnK(x, xn) (18.94)
where αn ∈ R are some coefficients that depend on the training data. This is called the representer
theorem.
Now consider the special case where the loss function is squared loss, and λ = σ
2
y
. We want to
minimize
L(f) = 1
2σ
2
y
X
N
n=1
(yn − f(xn))2 +
1
2
||f||2
H (18.95)
Substituting in Equation (18.94), and using the fact that hK(·, xi), K(·, xj )i = K(xi
, xj ), we obtain
L(f) = 1
2
α
TKα +
1
2σ
2
y
||y − Kα||
2
(18.96)
=
1
2
α
T
(K +
1
σ
2
y
K2
)α −
1
σ
2
y
y
TKα +
1
2σ
2
y
y
Ty (18.97)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.4. GPS WITH NON-GAUSSIAN LIKELIHOODS
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
data
−4
−2
0
2
4
target
data
True
KRR
GPR
Figure 18.8: Kernel ridge regression (KRR) compared to Gaussian process regression (GPR) using the same
kernel. Generated by krr_vs_gpr.ipynb.
Minimizing this wrt α gives αˆ = (K + σ
2
y
I)
−1y, which is the same as Equation (18.57). Furthermore,
the prediction for a test point is
ˆf(x∗) = k
T
∗α = k
T
∗
(K + σ
2
y
I)
−1y (18.98)
This is known as kernel ridge regression [Vov13]. We see that the result matches the posterior
predictive mean of a GP in Equation (18.55).
18.3.7.4 Example of KRR vs GPR
In this section, we compare KRR with GP regression on a simple 1d problem. Since the underlying
function is believed to be periodic, we use the periodic kernel from Equation (18.18). To capture the
fact that the observations are noisy, we add to this a white noise kernel
K(x, x
′
) = σ
2
y
δ(x − x
′
) (18.99)
as in Equation (18.48). Thus there are 3 GP hyper-parameters: the kernel length scale ℓ, the kernel
periodicity p, and the noise level σ
2
y
. We can optimize these by maximizing the marginal likelihood
using gradient descent (see Section 18.6.1). For KRR, we also have 3 hyperparameters (ℓ, p, and
λ = σ
2
y
); we optimize these using grid search combined with cross validation (which in general is
slower than gradient based optimization). The resulting model fits are shown in Figure 18.8, and are
very similar, as is to be expected.
18.4 GPs with non-Gaussian likelihoods
So far, we have focused on GPs for regression using Gaussian likelihoods. In this case, the posterior
is also a GP, and all computation can be performed analytically. However, if the likelihood is
non-Gaussian, we can no longer compute the posterior exactly. We can create variety of different
“classical” models by changing the form of the likelihood, as we show in Table 18.1. In the sections
below, we briefly discuss some approximate inference methods. (For more details, see e.g., [WSS21].)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license694
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Model Likelihood Section
Regression N (fi
, σ2
y
) Section 18.3.2
Robust regression Tν(fi
, σ
2
y
) Section 18.4.4
Binary classification Ber(σ(fi)) Section 18.4.1
Multiclass classification Cat(softmax(fi
)) Section 18.4.2
Poisson regression Poi(exp(fi)) Section 18.4.3
Table 18.1: Summary of GP models with a variety of likelihoods.
log p(yi
|fi)
∂
∂fi
log p(yi
|fi)
∂
2
∂f2
i
log p(yi
|fi)
log σ(yifi) ti − πi −πi(1 − πi)
log Φ(yifi)
yiφ(fi)
Φ(yifi) −
φ
2
i
Φ(yifi)
2 −
yifiφ(fi)
Φ(yifi)
Table 18.2: Likelihood, gradient, and Hessian for binary logistic/probit GP regression. We assume yi ∈
{−1, +1} and define ti = (yi + 1)/2 ∈ {0, 1} and πi = σ(fi) for logistic regression, and πi = Φ(fi) for probit
regression. Also, φ and Φ are the pdf and cdf of N (0, 1). From [RW06, p43].
18.4.1 Binary classification
In this section, we consider binary classification using GPs. If we use the sigmoid link function, we
have p(yn = 1|xn) = σ(ynf(xn)). If we assume yn ∈ {−1, +1}, then we have p(yn|xn) = σ(ynfn),
since σ(−z) = 1 − σ(z). If we use the probit link, we have p(yn = 1|xn) = Φ(ynf(xn)), where Φ(z) is
the cdf of the standard normal. More generally, let p(yn|xn) = Ber(yn|ϕ(fn)). The overall log joint
has the form
L(fX) = log p(y|fX) + log p(fX|X) (18.100)
= log p(y|fX) −
1
2
f
T
XK−1
X,XfX −
1
2
log |KX,X| −
N
2
log 2π (18.101)
The simplest approach to approximate inference is to use a Laplace approximation (Section 7.4.3).
The gradient and Hessian of the log joint are given by
∇L = ∇ log p(y|fX) − K−1
X,XfX (18.102)
∇2L = ∇2
log p(y|fX) − K−1
X,X = −Λ − K−1
X,X (18.103)
where Λ , −∇2
log p(y|fX) is a diagonal matrix, since the likelihood factorizes across examples.
Expressions for the gradient and Hessian of the log likelihood for the logit and probit case are shown
in Table 18.2. At convergence, the Laplace approximation of the posterior takes the following form:
p(fX|D) ≈ q(fX) = N (fˆ,(K−1
X,X + Λ)
−1
) (18.104)
where fˆ is the MAP estimate. See [RW06, Sec 3.4] for further details.
For improved accuracy, we can use variational inference, in which we assume q(fX) = N (fX|m, S);
we then optimize m and S using (stochastic) gradient descent, rather than assuming S is the Hessian
at the mode. See Section 18.5.4 for the details.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.4. GPS WITH NON-GAUSSIAN LIKELIHOODS
4 3 2 1 0 1 2 3 4
4
3
2
1
0
1
2
3
4
3.16**2 * RBF(length_scale=0.5)
(a)
4 3 2 1 0 1 2 3 4
4
3
2
1
0
1
2
3
4
4.79**2 * RBF(length_scale=1.19)
(b)
Figure 18.9: Contours of the posterior predictive probability for a binary classifier generated by a GP with an
SE kernel. (a) Manual kernel parameters: short length scale, ℓ = 0.5, variance 3.162 ≈ 9.98. (b) Learned
kernel parameters: long length scale, ℓ = 1.19, variance 4.792 ≈ 22.9. Generated by gpc_demo_2d.ipynb.
Once we have a Gaussian posterior q(fX|D), we can then use standard GP prediction to compute
q(f∗|x∗, D). Finally, we can approximate the posterior predictive distribution over binary labels
using
π∗ = p(y∗ = 1|x∗, D) = Z
p(y∗ = 1|f∗)q(f∗|x∗, D)df∗ (18.105)
This 1d integral can be computed using the probit approximation from Section 15.3.6. In this case
we have π∗ ≈ σ(κ(v)E [f∗]), where v = V [f∗] and κ
2
(v) = (1 + πv/8)−1
.
In Figure 18.9, we show a synthetic binary classification problem in 2d. We use an SE kernel.
On the left, we show predictions using hyper-parameters set by hand; we use a short length scale,
hence the very sharp turns in the decision boundary. On the right, we show the predictions using the
learned hyper-parameters; the model favors more parsimonious explanation of the data.
18.4.2 Multiclass classification
The multi-class case is somewhat harder, since the function now needs to return a vector of C logits
to get p(yn|xn) = Cat(yn|softmax(fn)), where fn = (f
1
n
, . . . , f C
n
), It is standard to assume that
f
c ∼ GP(0, Kc). Thus we have one latent function per class, which are a priori independent, and
which may use different kernels.
We can derive a Laplace approximation for this model as discussed in [RW06, Sec 3.5]. Alternatively,
we can use a variational approach, using the local variational bound to the multinomial softmax in
[Cha12]. An alternative variational method, based on data augmentation with auxiliary variables, is
described in [Wen+19b; Liu+19a; GFWO20].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license696
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−2 0 2
x
0.0
2.5
5.0
7.5
counts
data
true rate
(a)
−2 0 2
x
0
5
10
counts
data
true rate
MCMC inferred rate
95% Confidence
(b)
−2 0 2
x
0
5
10
15
counts
data
true rate
VI inferred rate
95% Confidence
(c)
Figure 18.10: Poisson regression with a GP. (a) Observed data (black dots) and true log rate function (yellow
line). (b) Posterior predictive distribution (shading shows 1 and 2 σ bands) from MCMC. (c) Posterior
predictive distribution from SVI. Generated by gp_poisson_1d.ipynb.
18.4.3 GPs for Poisson regression (Cox process)
In this section, we illustrate Poisson regression where the underlying log rate function is modeled by
a GP. This is known as a Cox process. We can perform approximate posterior inference in this
model using Laplace, MCMC, or SVI (stochastic variational inference). In Figure 18.10 we give a 1d
example, where we use a Matérn 5
2
kernel. We apply MCMC and SVI. In the VI case, we additionally
have to specify the form of the posterior; we use a Gaussian approximation for the variational GP
posterior p(f|X, y), and a point estimate for the kernel parameters.
An interesting application of this is to spatial disease mapping. For example, [VPV10] discuss
the problem of modeling the relative risk of heart attack in different regions in Finland. The data
consists of the heart attacks in Finland from 1996–2000 aggregated into 20km × 20km lattice cells.
The likelihood has the following form: yn ∼ Poi(enrn), where en is the known expected number of
deaths (related to the population of cell n and the overall death rate), and rn is the relative risk of
cell n which we want to infer. Since the data counts are small, we regularize the problem by sharing
information with spatial neighbors. Hence we assume f , log(r) ∼ GP(0, K). We use a Matérn
kernel (Section 18.2.1.3) with ν = 3/2, and a length scale and magnitude that are estimated from
data.
Figure 18.11 gives an example of this method in action (using Laplace approximation). On the left
we plot the posterior mean relative risk (RR), and on the right, the posterior variance. We see that
the RR is higher in eastern Finland, which is consistent with other studies. We also see that the
variance in the north is higher, since there are fewer people living there.
18.4.4 Other likelihoods
Many other likelihoods are possible. For example, [VJV09] uses a Student t likelihood in order to
perform robust regression. A general method for performing approximate variational inference in
GPs with such non-conjugate likelihoods is discussed in [WSS21].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.5. SCALING GP INFERENCE TO LARGE DATASETS
5 10 15 20 25 30 35
10
20
30
40
50
60
Mean
1
0
1
2
3
4
5
(a)
5 10 15 20 25 30 35
10
20
30
40
50
60
Variance
1
2
3
4
5
6
7
8
(b)
Figure 18.11: We show the relative risk of heart disease in Finland using a Poisson GP fit to 911 data points.
Left: posterior mean. Right: posterior variance. Generated by gp_spatial_demo.ipynb.
Method Cost Section
Cholesky O(N3
) Section 18.3.6
Conj. Grad. O(CN2
) Section 18.5.5
Inducing O(NM2 + M3 + DNM) Section 18.5.3
Variational O(NM2 + M3 + DNM) Section 18.5.4
SVGP O(BM2 + M3 + DNM) Section 18.5.4.3
KISS-GP O(CN + CDMD log M) Section 18.5.5.3
SKIP O(DLN + DLM log M + L
3N log D + CL2N) Section 18.5.5.3
Table 18.3: Summary of time to compute the log marginal likelihood of a GP regression model. Notation: N is
number of training examples, M is number of inducing points, B is size of minibatch, D is dimensionality of
input vectors (assuming X = R
D), C is number of conjugate gradient iterations, and L is number of Lanczos
iterations. Based on Table 2 of [Gar+18a].
18.5 Scaling GP inference to large datasets
In Section 18.3.6, we saw that the best way to perform GP inference and training is to compute a
Cholesky decomposition of the N × N Gram matrix. Unfortunately, this takes O(N3
) time. In this
section, we discuss methods to scale up GPs to handle large N. See Table 18.3 for a summary, and
[Liu+20c] for more details.1
18.5.1 Subset of data
The simplest approach to speeding up GP inference is to throw away some of the data. Suppose we
keep a subset of M examples. In this case, exact inference will take O(M3
) time. This is called the
1. We focus on efficient methods for evaluating the marginal likelihood and the posterior predictive distribution. For
an efficient method for sampling a function from the posterior, see [Wil+20a].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license698
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
subset-of-data approach.
The key question is: how should we choose the subset? The simplest approach is to pick random
examples (this method was recently analyzed in [HIY19]). However, intuitively it makes more sense
to try to pick a subset that in some sense “covers” the original data, so it contains approximately
the same information (up to some tolerance) without the redundancy. Clustering algorithms are
one heuristic approach, but we can also use coreset methods, which can provably find such an
information-preserving subset (see e.g., [Hug+19] for an application of this idea to GPs).
18.5.1.1 Informative vector machine
Clustering and coreset methods are unsupervised, in that they only look at the features xi and
not the labels yi
, which can be suboptimal. The informative vector machine [HLS03] uses a
greedy strategy to iteratively add the labeled example (xj , yj ) that maximally reduces the entropy
of the function’s posterior, ∆j = H (p(fj )) − H (p
new(fj )), where p
new(fj ) is the posterior of f
at xj after conditioning on yj . (This is very similar to active learning.) To compute ∆j , let
p(fj ) = N (µj , vj ), and p(fj |yj ) ∝ p(fj )N (yj |fj , σ2
) = N (fj |µ
new
j
, vnew
j
), where (v
new
j
)
−1 = v
−1
j +σ
−2
.
Since H (N (µ, v)) = log(2πev)/2, we have ∆j = 0.5 log(1 +vj/σ2
). Since this is a monotonic function
of vj , we can maximize it by choosing the site with the largest variance. (In fact, entropy is a
submodular function, so we can use submodular optimization algorithms to improve on the IVM, as
shown in [Kra+08].)
18.5.1.2 Discussion
The main problem with the subset of data approach is that it ignores some of the data, which can
reduce predictive accuracy and increase uncertainty about the true function. Fortunately there
are other scalable methods that avoid this problem, essentially by approximately representing (or
compressing) the training data, as we discuss below.
18.5.2 Nyström approximation
Suppose we had a rank M approximation to the N × N matrix gram matrix of the following form:
KX,X ≈ UΛUT
(18.106)
where Λ is a diagonal matrix of the M leading eigenvalues, and U is the matrix of the corresponding
M eigenvectors, each of size N. In this case, we can use the matrix inversion lemma to write
K−1
σ = (KX,X + σ
2
IN )
−1 ≈ σ
−2
IN + σ
−2U(σ
2Λ
−1 + UTU)
−1UT
(18.107)
which takes O(NM2
) time. Similarly, one can show (using the Sylvester determinant lemma) that
|Kσ| ≈ |Λ||σ
2Λ
−1 + UTU| (18.108)
which also takes O(NM2
) time.
Unfortunately, directly computing such an eigendecomposition takes O(N3
) time, which does not
help. However, suppose we pick a subset Z of M < N points. We can partition the Gram matrix as
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.5. SCALING GP INFERENCE TO LARGE DATASETS
follows (where we assume the chosen points come first, and then the remaining points):
KX,X =

KZ,Z KZ,X−Z
KX−Z,Z KX−Z,X−Z

,

KZ,Z KZ,X˜
KX,Z ˜ KX, ˜ X˜

(18.109)
where X˜ = X − Z. We now compute an eigendecomposition of KZ,Z to get the eigenvalues {λi}M
i=1
and eigenvectors {ui}M
i=1. We now use these to approximate the full matrix as shown below, where
the scaling constants are chosen so that ku˜ik ≈ 1:
λ˜
i ,
N
M
λi (18.110)
u˜ ,
r
M
N
1
λi
KX,Z ˜ ui (18.111)
KX,X ≈
X
M
i=1
λ˜
iu˜iu˜
T
i
(18.112)
=
X
M
i=1
N
M
λi
r
M
N
1
λi
KX,Z ˜ ui
r
M
N
1
λi
u
T
i KT
X,Z ˜
(18.113)
= KX,Z ˜
 X
M
i=1
1
λi
uiu
T
i
!
KX,Z ˜ (18.114)
= KX,Z ˜ K−1
Z,ZKT
X,Z ˜
(18.115)
This is known as the Nyström approximation [WS01]. If we define
QA,B , KA,ZK−1
Z,ZKZ,B (18.116)
then we can write the approximate Gram matrix as QX,X. We can then replace Kσ with Qˆ X,X =
QX,X + σ
2
IN . Computing the eigendecomposition takes O(M3
) time, and computing Qˆ −1
X,X takes
O(NM2
) time. Thus complexity is now linear in N instead of cubic.
If we are approximating only Kˆ X,X in µ∗|X in Equation (18.52) and Σ∗|X in Equation (18.53),
then this is inconsistent with the other un-approximated kernel function evaluations in these formulae,
and can result in the predictive variance being negative. One solution to this is to use the same Q
approximation for all terms.
18.5.3 Inducing point methods
In this section, we discuss an approximation method based on inducing points, also called pseu￾doinputs, which are like a learned summary of the training data that we can condition on, rather
than conditioning on all of it.
Let X be the observed inputs, and fX = f(X) be the unknown vector of function values (for which
we have noisy observations y). Let f∗ be the unknown function values at one or more test points
X∗. Finally, let us assume we have M additional inputs, Z, with unknown function values fZ (often
denoted by u). The exact joint prior has the form
p(fX, f∗) = Z
p(f∗, fX, fZ)dfZ =
Z
p(f∗, fX|fZ)p(fZ)dfZ = N

0,

KX,X KX,∗
K∗,X K∗,∗
 (18.117)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license700
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
￾
￾
￾
￾
￾￾
✁
✁
✁
✁
✁
✁
❆
❆
❆
❆
❆
❆
◗
◗
◗
◗
◗
◗
◗
◗
u
f1 f2
r r r fn f∗
r r
(a)
￾
￾
￾
￾
￾￾
✁
✁
✁
✁
✁
✁
❆
❆
❆
❆
❆
❆
◗
◗
◗
◗
◗
◗
◗
◗
u
f1 f2
r r r fn f∗
r r
(b)
Figure 18.12: Illustration of the graphical model for a GP on n observations, f1:n, and one test case, f∗, with
inducing variables u. The thick lines indicate that all variables are fully interconnected. The observations
yi (not shown) are locally connected to each fi. (a) no approximations are made. (b) we assume f∗ is
conditionally independent of fX given u. From Figure 1 of [QCR05]. Used with kind permission of Joaquin
Quiñonero Candela.
(We write p(fX, f∗) instead of p(fX, f∗|X, X∗), since the inputs can be thought of as just indices
into the random function f.)
We will choose fZ in such a way that it acts as a sufficient statistic for the data, so that we can
predict f∗ just using fZ instead of fX, i.e., we assume f∗ ⊥ fX|fZ. Thus we approximate the prior
as follows:
p(f∗, fX, fZ) = p(f∗|fX, fZ)p(fX|fZ)p(fZ) ≈ p(f∗|fZ)p(fX|fZ)p(fZ) (18.118)
See Figure 18.12 for an illustration of this assumption, and Section 18.5.3.4 for details on how to
choose the inducing set Z. (Note that this method is often called a “sparse GP”, because it makes
predictions for f∗ using a subset of the training data, namely fZ, instead of all of it, fX.)
From this, we can derive the following train and test conditionals
p(fX|fZ) = N (fX|KX,ZK−1
Z,ZfZ, KX,X − QX,X) (18.119)
p(f∗|fZ) = N (f∗|K∗,ZK−1
Z,ZfZ, K∗,∗ − Q∗,∗) (18.120)
The above equations can be seen as exact inference on noise-free observations fZ. To gain compu￾tational speedups, we will make further approximations to the terms Q˜ X,X = KX,X − QX,X and
Q˜
∗,∗ = K∗,∗ − Q∗,∗, as we discuss below. We can then derive the approximate prior q(fX, f∗) =
R
q(fX|fZ)q(f∗|fZ)p(fZ)dfZ, which we then condition on the observations in the usual way.
All of the approximations we discuss below result in an initial training cost of O(M3 + NM2
),
and then take O(M) time for the predictive mean for each test case, and O(M2
) time for the
predictive variance. (Compare this to O(N3
) training time and O(N) and O(N2
) testing time for
exact inference.)
18.5.3.1 SOR/DIC
Suppose we assume Q˜ X,X = 0 and Q˜
∗,∗ = 0, so the conditionals are deterministic. This is called the
deterministic inducing conditional (DIC) approximation [QCR05], or the subset of regressors
(SOR) approximation [Sil85; SB01]. The corresponding joint prior has the form
qSOR(fX, f∗) = N (0,

QX,X QX,∗
Q∗,X Q∗,∗

(18.121)
Draft of “Probabilistic Machine Learning: Advanced Topics”. A1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.5. SCALING GP INFERENCE TO LARGE DATASETS
Let us define Qˆ X,X = QX,X + σ
2
IN , and Σ = (σ
−2KZ,XKX,Z + KZ,Z)
−1
. Then the predictive
distribution is
qSOR(f∗|y) = N (f∗|Q∗,XQˆ −1
X,Xy, Q∗,∗ − Q∗,XQˆ −1
X,XQX,∗) (18.122)
= N (f∗|σ
−2K∗,ZΣKZ,Xy, K∗,ZΣKZ,∗) (18.123)
This is equivalent to the usual one for GPs except we have replaced KX,X by QX,X. This is equivalent
to performing GP inference with the following kernel function
KSOR(xi
, xj ) = K(xi
, Z) K−1
Z,Z K(Z, xj ) (18.124)
The kernel matrix has rank M, so the GP is degenerate. Furthermore, the kernel will be near 0
when xi or xj is far from one of the chosen points Z, which can result in an underestimate of the
predictive variance.
18.5.3.2 DTC
One way to overcome the overconfidence of DIC is to only assume Q˜ X,X = 0, but let Q˜
∗,∗ =
K∗,∗ − Q∗,∗ be exact. This is called the deterministic training conditional or DTC method
[SWL03].
The corresponding joint prior has the form
qdtc(fX, f∗) = N (0,

QX,X QX,∗
Q∗,X K∗,∗

(18.125)
Hence the predictive distribution becomes
qdtc(f∗|y) = N (f∗|Q∗,XQˆ −1
X,Xy, K∗,∗ − Q∗,XQˆ −1
X,XQX,∗) (18.126)
= N (f∗|σ
−2K∗,ZΣKZ,Xy, K∗,∗ − Q∗,∗ + K∗,ZΣKZ,∗) (18.127)
The predictive mean is the same as in SOR, but the variance is larger (since K∗,∗ − Q∗,∗ is positive
definite) due to the uncertainty of f∗ given fZ.
18.5.3.3 FITC
A widely used approximation assumes q(fX|fZ) is fully factorized, i.e,
q(fX|fZ) = Y
N
n=1
p(fn|fZ) = N (fX|KX,ZK−1
Z,ZfZ, diag(KX,X − QX,X)) (18.128)
This is called the fully independent training conditional or FITC assumption, and was first
proposed in [SG06a]. This throws away less uncertainty that the SOR and DTC methods, since it
does not make any deterministic assumptions about the relationship between fX and fZ.
The joint prior has the form
qfitc(fX, f∗) = N (0,

QX,X − diag(QX,X − KX,X) QX,∗
Q∗,X K∗,∗

(18.129)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license702
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The predictive distribution for a single test case is given by
qfitc(f∗|y) = N (f∗|k∗,ZΣKZ,XΛ
−1y, k∗∗ − q∗∗ + k∗,ZΣkZ,∗) (18.130)
where Λ , diag(KX,X − QX,X + σ
2
IN ), and Σ , (KZ,Z + KZ,XΛ
−1KX,Z)
−1
. If we have a batch
of test cases, we can assume they are conditionally independent (an approach known as fully
independent conditional or FIC), and multiply the above equation.
The computational cost is the same as for SOR and DTC, but the approach avoids some of the
pathologies due to a non-degenerate kernel. In particular, one can show that the FIC method is
equivalent to exact GP inference with the following non-degenerate kernel:
Kfic(xi
, xj ) = (
K(xi
, xj ) if i = j
KSOR(xi
, xj ) if i 6= j
(18.131)
18.5.3.4 Learning the inducing points
So far, we have not specified how to choose the inducing points or pseudoinputs Z. We can treat
these like kernel hyperparameters, and choose them so as to maximize the log marginal likelihood,
given by
log q(y|X, Z) = log Z Z p(y|fX)q(fX|X, fZ)p(fZ|Z)dfZdf (18.132)
= log Z
p(y|fX)q(fX|X, Z)dfX (18.133)
= −
1
2
log |QX,X + Λ| −
1
2
y
T
(QX,X + Λ)
−1y −
n
2
log(2π) (18.134)
where the definition of Λ depends on the method, namely ΛSOR = Λdtc = σ
2
IN , and Λfitc =
diag(KX,X − QX,X) + σ
2
IN .
If the input domain is R
d
, we can optimize Z ∈ RMd using gradient methods. However, one of
the appeals of kernel methods is that they can handle structured inputs, such as strings and graphs
(see Section 18.2.3). In this case, we cannot use gradient methods to select the inducing points.
A simple approach is to select the inducing points from the training set, as in the subset of data
approach in Section 18.5.1, or using the efficient selection mechanism in [Cao+15]. However, we can
also use discrete optimization methods, such as simulated annealing (Section 12.9.1), as discussed in
[For+18a]. See Figure 18.13 for an illustration.
18.5.4 Sparse variational methods
In this section, we discuss a variational approach to GP inference called the sparse variational GP
or SVGP approximation, also known as the variational free energy or VFE approach [Tit09;
Mat+16]. This is similar to the inducing point methods in Section 18.5.3, except it approximates
the posterior, rather than approximating the prior. The variational approach can also easily handle
non-conjugate likelihoods, as we will see. For more details, see e.g., [BWR16; Lei+20]. (See also
[WKS21] for connections between SVGP and the Nyström method.)
To explain the idea behind SVGP/ VFE, let us assume, for simplicity, that the function f is defined
over a finite set X of possible inputs, which we partition into three subsets: the training set X, a set
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.5. SCALING GP INFERENCE TO LARGE DATASETS
ACTG
AACC
CTAG
CTGG
AAAT
 ...
data
inducing
points
kernel
Figure 18.13: Illustration of how to choose inducing points from a discrete input domain (here DNA sequences
of length 4) to maximize the log marginal likelihood. From Figure 1 of [For+18a]. Used with kind permission
of Vincent Fortuin.
of inducing points Z, and all other points (which we can think of as the test set), X∗. (We assume
these sets are disjoint.) Let fX, fZ and f∗ represent the corresponding unknown function values
on these points, and let f = [fX, fZ, f∗] be all the unknowns. (Here we work with a fixed-length
vector f, but the result generalizes to Gaussian processes, as explained in [Mat+16].) We assume
the function is sampled from a GP, so p(f) = N (m(X ), K(X , X )).
The inducing point methods in Section 18.5.3 approximates the GP prior by assuming p(f∗, fX, fZ) ≈
p(f∗|fZ)p(fX|fZ)p(fZ). The inducing points fZ are chosen to maximize the likelihood of the ob￾served data. We then perform exact inference in this approximate model. By contrast, in this
section, we will keep the model unchanged, but we will instead approximate the posterior p(f|y)
using variational inference.
In the VFE view, the inducing points Z and inducing variables fZ (often denoted by u) are
variational parameters, rather than model parameters, which avoids the risk of overfitting. Further￾more, one can show that as the number of inducing points m increases, the quality of the posterior
consistently improves, eventually recovering exact inference. By contrast, in the classical inducing
point method, increasing m does not always result in better performance [BWR16].
In more detail, the VFE approach tries to find an approximate posterior q(f) to minimize
DKL (q(f) k p(f|y)). The key assumption is that q(f) = q(f∗, fX, fZ) = p(f∗, fX|fZ)q(fZ), where
p(f∗, fX|fZ) is computed exactly using the GP prior, and q(fZ) is learned, by minimizing K(q) =
DKL (q(f) k p(f|y)).
2
Intuitively, q(fZ) acts as a “bottleneck” which “absorbs” all the observations
from y; posterior predictions for elements of fX or f∗ are then made via their dependence on fZ,
rather than their dependence on each other.
2. One can show that DKL (q(f) k p(f|y)) = DKL (q(fX, fZ ) k p(fX, fZ |y)), which is the original objective from
[Tit09].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license704
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We can derive the form of the loss, which is used to compute the posterior q(fZ), as follows:
K(q) = DKL (q(f∗, fX, fZ) k p(f∗, fX, fZ|y)) (18.135)
=
Z
q(f∗, fX, fZ) log q(f∗, fX, fZ)
p(f∗, fX, fZ|y)
df∗ dfX dfZ (18.136)
=
Z
p(f∗, fX|fZ)q(fZ) log ✭✭✭✭✭✭ p(f∗|fX, fZ)✘p(f✘✘✘ X|fZ)q(fZ)p(y)
✭✭✭✭✭✭ p(f∗|fX, fZ)✘p(f✘✘✘ X|fZ)p(fZ)p(y|fX)
df∗ dfX dfZ (18.137)
=
Z
p(f∗, fX|fZ)q(fZ) log q(fZ)p(y)
p(fZ)p(y|fX)
df∗ dfX dfZ (18.138)
=
Z
q(fZ) log q(fZ)
p(fZ)
dfZ −
Z
p(fX|fZ)q(fZ) log p(y|fX)dfX dfZ + C (18.139)
= DKL (q(fZ) k p(fZ)) − Eq(fX)
[log p(y|fX)] + C (18.140)
where C = log p(y) is an irrelevant constant.
We can alternatively write the objective as an evidence lower bound that we want to maximize:
log p(y) = K(q) + Eq(fX)
[log p(y|fX)] − DKL (q(fZ) k p(fZ)) (18.141)
≥ Eq(fX)
[log p(y|fX)] − DKL (q(fZ) k p(fZ)) , L(q) (18.142)
Now suppose we choose a Gaussian posterior approximation, q(fZ) = N (fZ|m, S). Since p(fZ) =
N (fZ|0, K(Z, Z)), we can compute the KL term in closed form using the formula for KL divergence
between Gaussians (Equation (5.77)). To compute the expected log-likelihood term, we first need to
compute the induced posterior over the latent function values at the training points:
q(fX|m, S) = Z
p(fX|fZ, X, Z)q(fZ|m, S)dfZ = N (fX|µ˜, Σ˜ ) (18.143)
µ˜i = m(xi) + α(xi)
T
(m − m(Z)) (18.144)
Σ˜
ij = K(xi
, xj ) − α(xi)
T
(K(Z, Z) − S)α(xj ) (18.145)
α(xi) = K(Z, Z)
−1K(Z, xi) (18.146)
Hence the marginal at a single point is q(fn) = N (fn|µ˜n, Σ˜
nn), which we can use to compute the
expected log likelihood:
Eq(fX)
[log p(y|fX)] = X
N
n=1
Eq(fn)
[log p(yn|fn)] (18.147)
We discuss how to compute these expectations below.
18.5.4.1 Gaussian likelihood
If we have a Gaussian observation model, we can compute the expected log likelihood in closed form.
In particular, if we assume m(x) = 0, we have
Eq(fn)

log N (yn|fn, β−1
)

= log N (yn|k
T
nK−1
Z,Zm, β−1
) −
1
2
β˜knn −
1
2
tr(SΛn) (18.148)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.5. SCALING GP INFERENCE TO LARGE DATASETS
where ˜knn = knn − k
T
nK−1
Z,Zkn, kn is the n’th column of KZ,X and Λn = βK−1
Z,Zknk
T
nK−1
Z,Z.
Hence the overall ELBO has the form
L(q) = log N (y|KX,ZK−1
Z,Zm, β−1
IN ) −
1
2
βtr(KX,ZK−1
Z,ZSK−1
Z,ZKZ,X) (18.149)
−
1
2
βtr(KX,X − QX,X) − DKL (q(fZ) k p(fZ)) (18.150)
where QX,X = KX,ZK−1
Z,ZKZ,X.
To compute the gradients of this, we leverage the following result [OA09]:
∂
∂µEN(x|µ,σ2)
[h(x)] = EN(x|µ,σ2)

∂
∂xh(x)

(18.151)
∂
∂σ2
EN(x|µ,σ2)
[h(x)] = 1
2
EN(x|µ,σ2)

∂
2
∂x2
h(x)

(18.152)
We then substitute h(x) with log p(yn|fn). Using this, one can show
∇mL(q) = βK−1
Z,ZKZ,Xy − Λm (18.153)
∇SL(q) = 1
2
S
−1 −
1
2
Λ (18.154)
Setting the derivatives to zero gives the optimal solution:
S = Λ
−1
(18.155)
Λ = βK−1
Z,ZKZ,XKX,ZK−1
Z,Z + K−1
Z,Z (18.156)
m = βΛ
−1K−1
Z,ZKZ,Xy (18.157)
This is called sparse GP regression or SGPR [Tit09].
With these parameters, the lower bound on the log marginal likelihood is given by
log p(y) ≥ log N (y|0, KX,ZK−1
Z,ZKZ,X + β
−1
I) −
1
2
βtr(KX,X − QX,X) (18.158)
(This is called the “collapsed” lower bound, since we have marginalized out fZ.) If Z = X, then
KZ,Z = KZ,X = KX,X, so the bound becomes tight, and we have log p(y) = log N (y|0, KX,X +β
−1
I).
Equation (18.158) is almost the same as the log marginal likelihood for the DTC model in
Equation (18.134), except for the trace term; it is this latter term that prevents overfitting, due to
the fact that we treat fZ as variational parameters of the posterior rather than model parameters of
the prior.
18.5.4.2 Non-Gaussian likelihood
In this section, we briefly consider the case of non-Gaussian likelihoods, which arise when using GPs
for classification or for count data (see Section 18.4). We can compute the gradients of the expected
log likelihood by defining h(fn) = log p(yn|fn) and then using a Monte Carlo approximation to
Equation (18.151) and Equation (18.152). In the case of a binary classifier, we can use the results in
Table 18.2 to compute the inner ∂
∂fn
h(fn) and ∂
2
∂f2
n
h(fn) terms. Alternatively, we can use numerical
integration techniques, such as those discussed in Section 8.5.1.4. (See also [WSS21].)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license706
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.5.4.3 Minibatch SVI
Computing the optimal variational solution in Section 18.5.4.1 requires solving a batch optimization
problem, which takes O(M3 + NM2
) time. This may still be too slow if N is large, unless M is
small, which compromises accuracy.
An alternative approach is to perform stochastic optimization of the VFE objective, instead of
batch optimization. This is known as stochastic variational inference (see Section 10.1.4). The
key observation is that the log likelihood in Equation (18.147) is a sum of N terms, which we can
approximate with minibatch sampling to compute noisy estimates of the gradient, as proposed in
[HFL13].
In more detail, the objective becomes
L(q) = "
N
B
X
B
b=1
1
|Bb|
X
n∈Bb
Eq(fn)
[log p(yn|fn)]#
− DKL (q(fZ) k (p(fZ)) (18.159)
where Bb is the b’th batch, and B is the number of batches. Since the GP model (with Gaussian
likelihoods) is in the exponential family, we can efficiently compute the natural gradient (Section 6.4)
of Equation (18.159) wrt the canonical parameters of q(fZ); this converges much faster than following
the standard gradient. See [HFL13] for details.
18.5.5 Exploiting parallelization and structure via kernel matrix multiplies
It takes O(N3
) time to compute the Cholesky decomposition of KX,X, which is needed to solve the
linear system Kσα = y and to compute |KX,X|. An alternative to Cholesky decomposition is to
use linear algebra methods, often called Krylov subspace methods based just on matrix vector
multiplication or MVM. These approaches are often much faster.
In short, if the kernel matrix KX,X has special algebraic structure, which is often the case through
either the choice of kernel or the structure of the inputs, then it is typically easier to exploit this
structure in performing fast matrix multiplies. Moreover, even if the kernel matrix does not have
special structure, matrix multiplies are trivial to parallelize, and can thus be greatly accelerated by
GPUs, unlike Cholesky based methods which are largely sequential. Algorithms based on matrix
multiplies are in harmony with modern hardware advances, which enable significant parallelization.
18.5.5.1 Using conjugate gradient and Lanczos methods
We can solve the linear system Kσα = y using conjugate gradients (CG). The key computational
step in CG is the ability to perform MVMs. Let τ (Kσ) be the time complexity of a single MVM
with Kσ. For a dense n × n matrix, we have τ (Kσ) = n
2
; however, we can speed this up if Kσ is
sparse or structured, as we discuss below.
Even if Kσ is dense, we may still be able to save time by solving the linear system approximately.
In particular, if we perform C iterations, CG will take O(Cτ (Kσ)) time. If we run for C = n, and
τ (Kσ) = n
2
, it gives the exact solution in O(n
3
) time. However, often we can use fewer iterations
and still get good accuracy, depending on the condition number of Kσ.
We can compute the log determinant of a matrix using the MVM primitive with a similar iterative
method known as stochastic Lanczos quadrature [UCS17; Don+17a]. This takes O(Lτ (Kσ))
time for L iterations.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.5. SCALING GP INFERENCE TO LARGE DATASETS
0 10000 20000 30000 40000
Subsampled dataset size
0.12
0.13
0.14
0.15
0.16
RMSE
KEGGU (n=40708)
Subsampled (Exact GP)
Full Dataset (SGPR m= 512)
Full Dataset (SVGP m= 1024)
Full Dataset (Exact GP)
0 100000 200000
Subsampled dataset size
0.2
0.4
0.6
3DRoad (n=278319)
0 100000 200000 300000
Subsampled dataset size
0.75
0.80
0.85
0.90
0.95
1.00
Song (n=329820)
Figure 18.14: RMSE on test set as a function of training set size using a GP with Matern 3/2 kernel with
shared lengthscale across all dimensions. Solid lines: exact inference. Dashed blue: SGPR method (closed-form
batch solution to the Gaussian variational approximation) of Section 18.5.4.1 with M = 512 inducing points.
Dashed orange: SVGP method (SGD on Gaussian variational approxiation) of Section 18.5.4.3 with M = 1024
inducing points. Number of input dimensions: KEGGU D = 27, 3DRoad D = 3, Song D = 90. From Figure
4 of [Wan+19a]. Used with kind permission of Andrew Wilson.
These methods have been used in the blackbox matrix-matrix multiplication (BBMM)
inference procedure of [Gar+18a], which formulates a batch approach to CG that can be effectively
parallelized on GPUs. Using 8 GPUs, this enabled the authors of [Wan+19a] to perform exact
inference for a GP regression model on N ∼ 104 datapoints in seconds, N ∼ 105 datapoints in
minutes, and N ∼ 106 datapoints in hours.
Interestingly, Figure 18.14 shows that exact GP inference on a subset of the data can often
outperform approximate inference on the full data. We also see that performance of exact GPs
continues to significantly improve as we increase the size of the data, suggesting that GPs are not only
useful in the small-sample setting. In particular, the BBMM is an exact method, and so will preserve
the non-parametric representation of a GP with a non-degenerate kernel. By contrast, standard
scalable approximations typically operate by replacing the exact kernel with an approximation that
corresponds to a parametric model. The non-parametric GPs are able to grow their capacity with
more data, benefiting more significantly from the structure present in large datasets.
18.5.5.2 Kernels with compact support
Suppose we use a kernel with compact support, where K(x, x
′
) = 0 if kx − x
′k > ǫ for some
threshold ǫ (see e.g., [MR09]), then Kσ will be sparse, so τ (Kσ) will be O(N). We can also induce
sparsity and structure in other ways, as we discuss in Section 18.5.5.3.
18.5.5.3 KISS
One way to ensure that MVMs are fast is to force the kernel matrix to have structure. The structured
kernel interpolation (SKI) method of [WN15] does this as follows. First it assumes we have a set
of inducing points, with Gram matrix KZ,Z. It then interpolates these values to predict the entries
of the full kernel matrix using
KX,X ≈ WXKZ,ZWT
X (18.160)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license708
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where WX is a sparse matrix containing interpolation weights. If we use cubic interpolation, each
row only has 4 nonzeros. Thus we can compute (WXKZ,ZWT
X)v for any vector v in O(N + M2
)
time.
Note that the SKI approach generalizes all inducing point methods. For example, we can recover the
subset of regressors method (SOR) method by setting the interpolation weights to W = KX,ZK−1
Z,Z.
We can identify this procedure as performing a global Gaussian process interpolation strategy on the
user specified kernel. See [WN15] and [WDN15] for more details.
In 1d, we can further reduce the running time by choosing the inducing points to be on a regular
grid, so that KZ,Z is a Toeplitz matrix. In higher dimensions, we need to use a multidimensional grid
of points, resulting in KZ,Z being a Kronecker product of Toeplitz matrices. This enables matrix
vector multiplication in O(N + M log M) time and O(N + M) space. The resulting method is called
KISS-GP [WN15], which stands for “kernel interpolation for scalable, structured GPs”.
Unfortunately, the KISS method can take exponential time in the input dimensions D when
exploiting Kronecker structure in KZ,Z, due to the need to create a fully connected multidimensional
lattice. In [Gar+18b], they propose a method called SKIP, which stands for “SKI for products”.
The idea is to leverage the fact that many kernels (including ARD) can be written as a product of 1d
kernels: K(x, x
′
) = QD
d=1 Kd
(x, x
′
). This can be combined with the 1d SKI method to enable fast
MVMs. The overall running time to compute the log marginal likelihood (which is the bottleneck
for kernel learning) using C iterations of CG and a Lanczos decomposition of rank L, becomes
O(DL(N + M log M) + L
3N log D + CL2N). Typical values are L ∼ 101 and C ∼ 102
.
18.5.5.4 Tensor train methods
Consider the Gaussian VFE approach in Section 18.5.4. We have to estimate the covariance S and
the mean m. We can represent S efficiently using Kronecker structure, as used by KISS. Additionally,
we can represent m efficiently using the tensor train decomposition [Ose11] in combination with
SKI [WN15]. The resulting TT-GP method can scale efficiently to billions of inducing points, as
explained in [INK18].
18.5.6 Converting a GP to an SSM
Consider a function defined on a 1d scalar input, such as a time index. For many stationary
1d kernels, the corresponding GP can be modeled using a linear time invariant (LTI) stochastic
differential equation (SDE)3
; this SDE can then be converted to a linear-Gaussian state space
model (Section 29.1) as first proposed in [HS10]. For example, consider the exponential kernel in
Equation (18.14), K(t, t′
) = q
2λ
exp(−λ|t − t
′
|), which corresponds to a Matérn kernel with ν = 1/2.
The corresponding SDE is the Orstein-Uhlenbeck process which has the form dx(t)
dt = −λx(t) + w(t),
where w(t) is a white noise process with spectral density q [SS19, p258].4 For other kernels (such
as Matérn with ν = 3/2), we need to use multiple latent states in order to capture higher order
3. The condition is that the spectral density of the covariance function has to be a rational function. This includes
many kernels, such as the Matérn kernel, but excludes the squared exponential (RBF) kernel. However the latter can
be approximated by an SDE, as explained in [SS19, p261].
4. This is sometimes written as dx = −λx dt + dβ, where β(t) is a Brownian noise process, and w(t) = dβ(t)
dt , as
explained in [SS19, p45].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.6. LEARNING THE KERNEL
derivative terms (see Supplementary Section 18.2 for details). Furthermore, for higher dimensional
inputs, we need to use even more latent states, to enforce the Markov property [DSP21].
Once we have converted the GP to LG-SSM form, we can perform exact inference in O(N) time
using Kalman smoothing, as explained in Section 8.2.3. Furthermore, if we have access to a highly
parallel processor, such as a GPU, we can reduce the time to log(N) [CZS22], as explained in
Section 8.2.3.4.
18.6 Learning the kernel
In [Mac98], David MacKay asked: “How can Gaussian processes replace neural networks? Have we
thrown the baby out with the bathwater?” This remark was made in the late 1990s, at the end of
the second wave of neural networks. Researchers and practitioners had grown weary of the design
decisions associated with neural networks — such as activation functions, optimization procedures,
architecture design — and the lack of a principled framework to make these decisions. Gaussian
processes, by contrast, were perceived as flexible and principled probabilistic models, which naturally
followed from Radford Neal’s results on infinite neural networks [Nea96], which we discuss in more
depth in Section 18.7.
However, MacKay [Mac98] noted that neural networks could discover rich representations of data
through adaptive hidden basis functions, while Gaussian processes with standard kernel functions,
such as the RBF kernel, are essentially just smoothing devices. Indeed, the generalization properties
of Gaussian processes hinge on the suitability of the kernel function. Learning the kernel is how
we do representation learning with Gaussian processes, and in many cases will be crucial for good
performance — especially when we wish to perform extrapolation, making predictions far away from
the data [WA13; Wil+14].
As we will see, learning a kernel is in many ways analogous to training a neural network. Moreover,
neural networks and Gaussian processes can be synergistically combined through approaches such as
deep kernel learning (see Section 18.6.6) and NN-GPs (Section 18.7.2).
18.6.1 Empirical Bayes for the kernel parameters
Suppose, as in Section 18.3.2, we are performing 1d regression using a GP with an RBF kernel. Since
the data has observation noise, the kernel has the following form:
Ky(xp, xq) = σ
2
f
exp(−
1
2ℓ
2
(xp − xq)
2
) + σ
2
y
δpq (18.161)
Here ℓ is the horizontal scale over which the function changes, σ
2
f
controls the vertical scale of
the function, and σ
2
y
is the noise variance. Figure 18.15 illustrates the effects of changing these
parameters. We sampled 20 noisy datapoints from the SE kernel using (ℓ, σf , σy) = (1, 1, 0.1), and
then made predictions various parameters, conditional on the data. In Figure 18.15(a), we use
(ℓ, σf , σy) = (1, 1, 0.1), and the result is a good fit. In Figure 18.15(b), we increase the length scale
to ℓ = 3; now the function looks smoother, but we are arguably underfitting.
To estimate the kernel parameters θ (sometimes called hyperparameters), we could use exhaustive
search over a discrete grid of values, with validation loss as an objective, but this can be quite slow.
(This is the approach used by nonprobabilistic methods, such as SVMs, to tune kernels.) Here we
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license710
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−10 −5 0 5 10
x
−2
0
2
4
f
(l, σf , σy) =1.0, 1.0, 0.1
Mean
Data
Confidence
(a)
−10 −5 0 5 10
x
−2
0
2
4
f
(l, σf , σy) =3.0, 1.16, 0.89
Mean
Data
Confidence
(b)
Figure 18.15: Some 1d GPs with RBF kernels but different hyper-parameters fit to 20 noisy observations.
The hyper-parameters (ℓ, σf , σy) are as follows: (a) (1, 1, 0.1) (b) (3.0, 1.16, 0.89). Adapted from Figure 2.5
of [RW06]. Generated by gpr_demo_change_hparams.ipynb.
consider an empirical Bayes approach, which will allow us to use continuous optimization methods,
which are much faster. In particular, we will maximize the marginal likelihood
p(y|X, θ) = Z
p(y|f, X)p(f|X, θ)df (18.162)
(The reason it is called the marginal likelihood, rather than just likelihood, is because we have marginal￾ized out the latent Gaussian vector f.) Since p(f|X) = N (f|0, K), and p(y|f) = QN
n=1 N (yn|fn, σ2
y
),
the marginal likelihood is given by
log p(y|X, θ) = log N (y|0, Kσ) = −
1
2
yK−1
σ y −
1
2
log |Kσ| − N
2
log(2π) (18.163)
where the dependence of Kσ on θ is implicit. The first term is a data fit term, the second term is a
model complexity term, and the third term is just a constant. To understand the tradeoff between
the first two terms, consider a SE kernel in 1d, as we vary the length scale ℓ and hold σ
2
y fixed.
Let J(ℓ) = − log p(y|X, ℓ). For short length scales, the fit will be good, so y
TK−1
σ y will be small.
However, the model complexity will be high: K will be almost diagonal, since most points will not
be considered “near” any others, so the log |Kσ| will be large. For long length scales, the fit will be
poor but the model complexity will be low: K will be almost all 1’s, so log |Kσ| will be small.
We now discuss how to maximize the marginal likelihood. One can show that
∂
∂θj
log p(y|X, θ) = 1
2
y
TK−1
σ
∂Kσ
∂θj
K−1
σ y −
1
2
tr(K−1
σ
∂Kσ
∂θj
) (18.164)
=
1
2
tr 
(αα
T − K−1
σ
)
∂Kσ
∂θj

(18.165)
where α = K−1
σ y. It takes O(N3
) time to compute K−1
σ
, and then O(N2
) time per hyper-parameter
to compute the gradient.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.6. LEARNING THE KERNEL
10−1
100
101
length scale (log scale)
10−1
100
noise std dev
(log scale)
(a)
−5 0 5
x
−2.5
0.0
2.5
5.0
y
Data
Mean
Confidence
(b)
−5 0 5
x
−1
0
1
2
3
y
Data
Mean
Confidence
(c)
Figure 18.16: Illustration of local minima in the marginal likelihood surface. (a) We plot the log marginal
likelihood vs σ
2
y and ℓ, for fixed σ
2
f = 1, using the 7 datapoints shown in panels b and c. (b) The function
corresponding to the lower left local minimum, (ℓ, σ2
n) ≈ (1, 0.2). This is quite “wiggly” and has low noise. (c)
The function corresponding to the top right local minimum, (ℓ, σ2
n) ≈ (10, 0.8). This is quite smooth and has
high noise. The data was generated using (ℓ, σ2
n) = (1, 0.1). Adapted from Figure 5.5 of [RW06]. Generated
by gpr_demo_marglik.ipynb.
The form of ∂Kσ
∂θj
depends on the form of the kernel, and which parameter we are taking derivatives
with respect to. Often we have constraints on the hyper-parameters, such as σ
2
y ≥ 0. In this case, we
can define θ = log(σ
2
y
), and then use the chain rule.
Given an expression for the log marginal likelihood and its derivative, we can estimate the kernel
parameters using any standard gradient-based optimizer. However, since the objective is not convex,
local minima can be a problem, as we illustrate below, so we may need to use multiple restarts.
18.6.1.1 Example
Consider Figure 18.16. We use the SE kernel in Equation (18.161) with σ
2
f = 1, and plot
log p(y|X, ℓ, σ2
y
) (where X and y are the 7 datapoints shown in panels b and c as we vary ℓ
and σ
2
y
. The two local optima are indicated by + in panel a. The bottom left optimum corresponds
to a low-noise, short-length scale solution (shown in panel b). The top right optimum corresponds
to a high-noise, long-length scale solution (shown in panel c). With only 7 datapoints, there is not
enough evidence to confidently decide which is more reasonable, although the more complex model
(panel b) has a marginal likelihood that is about 60% higher than the simpler model (panel c). With
more data, the more complex model would become even more preferred.
Figure 18.16 illustrates some other interesting (and typical) features. The region where σ
2
y ≈ 1
(top of panel a) corresponds to the case where the noise is very high; in this regime, the marginal
likelihood is insensitive to the length scale (indicated by the horizontal contours), since all the data
is explained as noise. The region where ℓ ≈ 0.5 (left hand side of panel a) corresponds to the case
where the length scale is very short; in this regime, the marginal likelihood is insensitive to the noise
level (indicated by the vertical contours), since the data is perfectly interpolated. Neither of these
regions would be chosen by a good optimizer.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license712
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
log(length−scale)
log(magnitude)
z
1
z
2
2.8 3 3.2 3.4
−3
−2.5
−2
−1.5
−1
−0.5
(a)
log(length−scale)
log(magnitude)
2.8 3 3.2 3.4
−3
−2.5
−2
−1.5
−1
−0.5
(b)
log(length−scale)
log(magnitude)
2.8 3 3.2 3.4
−3
−2.5
−2
−1.5
−1
−0.5
(c)
Figure 18.17: Three different approximations to the posterior over hyper-parameters: grid-based, Monte Carlo,
and central composite design. From Figure 3.2 of [Van10]. Used with kind permission of Jarno Vanhatalo.
18.6.2 Bayesian inference for the kernel parameters
When we have a small number of datapoints (e.g., when using GPs for blackbox optimization, as
we discuss in Section 6.6), using a point estimate of the kernel parameters can give poor results
[Bul11; WF14]. As a simple example, if the function values that have been observed so far are all
very similar, then we may estimate σˆ ≈ 0, which will result in overly confident predictions.5
To overcome such overconfidence, we can compute a posterior over the kernel parameters. If the
dimensionality of θ is small, we can compute a discrete grid of possible values, centered on the MAP
estimate θˆ (computed as above). We can then approximate the posterior using
p(f|D) = X
S
s=1
p(f|D, θs)p(θs|D)ws (18.166)
where ws denotes the weight for grid point s.
In higher dimensions, a regular grid suffers from the curse of dimensionality. One alternative is
place grid points at the mode, and at a distance ±1sd from the mode along each dimension, for a
total of 2|θ| + 1 points. This is called a central composite design [RMC09]. See Figure 18.17 for
an illustration.
In higher dimensions, we can use Monte Carlo inference for the kernel parameters when computing
Equation (18.166). For example, [MA10] shows how to use slice sampling (Section 12.4.1) for this task,
[Hen+15] shows how to use HMC (Section 12.5), and [BBV11a] shows how to use SMC (Chapter 13).
In Figure 18.18, we illustrate the difference between kernel optimization vs kernel inference. We fit
a 1d dataset using a kernel of the form
K(r) = σ
2
1KSE(r; τ )Kcos(r; ρ1) + σ
s
2K32(r; ρ2) (18.167)
where KSE(r; ℓ) is the squared exponential kernel (Equation (18.12)), Kcos(r; ρ1) is the cosine kernel
(Equation (18.19)), and K32(r; ρ2) is the Matérn 3
2
kernel (Equation (18.15)). We then compute a
5. In [WSN00; BBV11b], they show how we can put a conjugate prior on σ
2 and integrate it out, to generate a Student
version of the GP, which is more robust.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.6. LEARNING THE KERNEL
0 2 4 6 8 10
x [day]
−2
0
2
y [ppm]
Maximum likelihood
predictive mean
truth
(a)
0 2 4 6 8 10
x [day]
−2
0
2
y [ppm]
Posterior inference
predictive mean
95% confidence
truth
(b)
Figure 18.18: Difference between estimation and inference for kernel hyper-parameters. (a) Empirical
Bayes approach based on optimization. We plot the posterior predicted mean given a plug-in estimate,
E
h
f(x)|D, θˆ
i
. (b) Bayesian approach based on HMC. We plot the posterior predicted mean, marginalizing
over hyper-parameters, E [f(x)|D]. Generated by gp_kernel_opt.ipynb.
point-estimate of the kernel parameters using empirical Bayes, and posterior samples using HMC.
We then predicting the posterior mean of f on a 1d test set by plugging in the MLE or averaging
over samples. We see that the latter captures more uncertainty (beyond the uncertainty captured by
the Gaussian itself).
18.6.3 Multiple kernel learning for additive kernels
A special case of kernel learning arises when the kernel is a sum of B base kernels
K(x, x
′
) = X
B
b=1
wbKb(x, x
′
) (18.168)
Optimizing the weights wb > 0 using structural risk minimization is known as multiple kernel
learning; see e.g., [Rak+08] for details.
Now suppose we constrain the base kernels to depend on a subset of the variables. Furthermore,
suppose we enforce a hierarchical inclusion property (e.g., including the kernel k123 means we must
also include k12, k13 and k23), as illustrated in Figure 18.19(left). This is called hierarchical kernel
learning. We can find a good subset from this model class using convex optimization [Bac09];
however, this requires the use of cross validation to estimate the weights. A more efficient approach
is to use the empirical Bayes approach described in [DNR11].
In many cases, it is common to restrict attention to first order additive kernels:
K(x, x
′
) = X
D
d=1
Kd(xd, x′
d
) (18.169)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license714
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
1234
123 124 134 234
12 13 23 14 24 34
1 2 3 4
φ
(a)
1234
123 124 134 234
12 13 23 14 24 34
1 2 3 4
φ
(b)
Figure 18.19: Comparison of different additive model classes for a 4d function. Circles represent different
interaction terms, ranging from first-order to fourth-order. Left: hierarchical kernel learning uses a nested
hierarchy of terms. Right: additive GPs use a weighted sum of additive kernels of different orders. Color
shades represent different weighting terms. Adapted from Figure 6.2 of [Duv14].
The resulting function then has the form
f(x) = f1(x1) + . . . + fD(xD) (18.170)
This is called a generalized additive model or GAM.
Figure 18.20 shows an example of this, where each base kernel has the form Kd(xd, x′
d
) =
σ
2
d
SE(xd, x′
d
|ℓd), In Figure 18.20, we see that the σ
2
d
terms for the coarse and fine features are
set to zero, indicating that these inputs have no impact on the response variable.
[DBW20] considers additive kernels operating on different linear projections of the inputs:
K(x, x
′
) = X
B
b=1
wbKb(Pbx, Pbx
′
) (18.171)
Surprisingly, they show that these models can match or exceed the performance of kernels operating
on the original space, even when the projections are into a single dimension, and not learned. In
other words, it is possible to reduce many regression problems to a single dimension without loss
in performance. This finding is particularly promising for scalable inference, such as KISS (see
Section 18.5.5.3), and active learning, which are greatly simplified in a low dimensional setting.
More recently, [LBH22] has proposed the orthogonal additive kernel (OAK), which imposes
an orthogonality constraint on the additive functions. This ensures an identifiable, low-dimensional
representation of the functional relationship, and results in improved performance.
18.6.4 Automatic search for compositional kernels
Although the above methods can estimate the hyperparameters of a specified set of kernels, they do
not choose the kernels themselves (other than the special case of selecting a subset of kernels from a
set). In this section, we describe a method, based on [Duv+13], for sequentially searching through
the space of increasingly complex GP models so as to find a parsiminous description of the data.
(See also [BHB22] for a review.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.6. LEARNING THE KERNEL
Figure 18.20: Predictive distribution of each term im a GP-GAM model applied to a dataset with 8 continuous
inputs and 1 continuous output, representing the strength of some concrete. From Figure 2.7 of [Duv14].
Used with kind permission of David Duvenaud.
No structure
SE RQ Lin Per
SE + RQ ... Per + RQ ... Per × RQ
SE + Per + RQ ... SE × (Per + RQ) ...
... ... ...
Figure 18.21: Example of a search tree over kernel expressions. Adapted from Figure 3.2 of [Duv14].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license716
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 18.22: Top row: airline dataset and posterior distribution of the model discovered after a search of
depth 10. Subsequent rows: predictions of the individual components. From Figure 3.5 of [Duv14], based on
[Llo+14]. Used with kind permission of David Duvenaud.
We start with a simple kernel, such as the white noise kernel, and then consider replacing it
with a set of possible alternative kernels, such as an SE kernel, RQ kernel, etc. We use the BIC
score (Section 3.8.7.2) to evaluate each candidate model (choice of kernel) m. This has the form
BIC(m) = log p(D|m)−
1
2
|m| log N, where p(D|m) is the marginal likelihood, and |m| is the number of
parameters. The first term measures fit to the data, and the second term is a complexity penalty. We
can also consider replacing a kernel by the addition of two kernels, k → (k + k
′
), or the multiplication
of two kernels, k → (k × k
′
). See Figure 18.21 for an illustration of the search space.
Searching through this space is similar to what a human expert would do. In particular, if we
find structure in the residuals, such as periodicity, we can propose a certain “move” through the
space. We can also start with some structure that is assumed to hold globally, such as linearity, but
if we find this only holds locally, we can multiply the kernel by an SE kernel. We can also add input
dimensions incrementally, to capture higher order interactions.
Figure 18.22 shows the output of this process applied to a dataset of monthly totals of international
airline passengers. The input to the GP is the set of time stamps, x = 1 : t; there are no other
features.
The observed data lies in between the dotted vertical lines; curves outside of this region are
extrapolations. We see that the system has discovered a fairly interpretable set of patterns in the
data. Indeed, it is possible to devise an algorithm to automatically convert the output of this search
process to a natural language summary, as shown in [Llo+14]. In this example, it summarizes the
data as being generated by the addition of 4 underlying trends: a linearly increasing function; an
approximately periodic function with a period of 1.0 years, and with linearly increasing amplitude; a
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.6. LEARNING THE KERNEL
0 1 2 3 4 5
τ
−1
0
1
2
k(τ )
true kernel
inferred kernel
(a)
0 5 10
x
−2.5
0.0
2.5
y
data
prediction
(b)
Figure 18.23: Illustration of a GP with a spectral mixture kernel in 1d. (a) Learned vs true kernel. (b)
Predictions using learned kernel. Generated by gp_spectral_mixture.ipynb.
smooth function; and uncorrelated noise with linearly increasing standard deviation.
Recently, [Sun+18] showed how to create a DNN which learns the kernel given two input vectors.
The hidden units are defined as sums and products of elementary kernels, as in the above search
based approach. However, the DNN can be trained in a differentiable way, so is much faster.
18.6.5 Spectral mixture kernel learning
Any shift-invariant (stationary) kernel can be converted via the Fourier transform to its dual form,
known as its spectral density. This means that learning the spectral density is equivalent to
learning any shift-invariant kernel. For example, if we take the Fourier transform of an RBF kernel,
we get a Gaussian spectral density centered at the origin. If we take the Fourier transform of a
Matérn kernel, we get a Student spectral density centred at the origin. Thus standard approaches to
multiple kernel learning, which typically involve additive compositions of RBF and Matérn kernels
with different length-scale parameters, amount to density estimation with a scale mixture of Gaussian
or Student distributions at the origin. Such models are very inflexible for density estimation, and
thus also very limited in being able to perform kernel learning.
On the other hand, scale-location mixture of Gaussians can model any density to arbitrary precision.
Moreover, with even a small number of components these mixtures of Gaussians are highly flexible.
Thus a spectral density corresponding to a scale-location mixture of Gaussians forms an expressive
basis for all shift-invariant kernels. One can evaluate the inverse Fourier transform for a Gaussian
mixture analytically, to derive the spectral mixture kernel [WA13], which we can express for
one-dimensional inputs x as:
K(x, x′
) = X
i
wicos((x − x
′
)(2πµi)) exp(−2π
2
(x − x
′
)
2
vi) (18.172)
The mixture weights wi
, as well as the means µi and variances vi of the Gaussians in the spectral
density, can be learned by empirical Bayes optimization (Section 18.6.1) or in a fully-Bayesian
procedure (Section 18.6.2) [Jan+17]. We illustrate the former approach in Figure 18.23.
By learning the parameters of the spectral mixture kernel, we can discover representations that
enable extrapolation — to make reasonable predictions far away from the data. For example, in Sec￾Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license718
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 18.24: Extrapolations (point predictions and 95% credible set) on CO2 and airline datasets using
Gaussian processes with Matérn, rational quadratic, periodic, RBF (SE), and spectral mixture kernels, each
with hyperparameters learned using empirical Bayes. From [Wil14].
tion 18.8.1, compositions of kernels are carefully hand-crafted to extrapolate CO2 concentrations. But
in this instance, the human statistician is doing all of the interesting representation learning. Figure
Figure 18.24 shows Gaussian processes with learned spectral mixture kernels instead automatically
extrapolating on CO2 and airline passenger problems.
These kernels can also be used to extrapolate higher dimensional large-scale spatio-temporal
patterns. Large datasets can provide relatively more information for expressive kernel learning.
However, scaling an expressive kernel learning approach poses different challenges than scaling a
standard Gaussian process model. One faces additional computational constraints, and the need
to retain significant model structure for expressing the rich information available in a large dataset.
Indeed, in Figure 18.24 we can separately understand the effects of the kernel learning approach and
scalable inference procedure, in being able to discover structure necessary to extrapolate textures.
An expressive kernel model and a scalable inference approach that preserves a non-parametric
representation are needed for good performance.
Structure exploiting inference procedures, such as Kronecker methods, as well as KISS-GP and
conjugate gradient based approaches, are appropriate for these tasks — since they generally preserve
or exploit existing structure, rather than introducing approximations that corrupt the structure.
Spectral mixture kernels combined with these scalable inference techniques have been used to great
effect for spatiotemporal extrapolation problems, including land-surface temperature forecasting,
epidemiological modeling, and policy-relevant applications.
18.6.6 Deep kernel learning
Deep kernel learning [SH07; Wil+16] combines the structural properties of neural networks with
the non-parametric flexibility and uncertainty representation provided by Gaussian processes. For
example, we can define a “deep RBF kernel” as follows:
Kθ(x, x
′
) = exp 
−
1
2σ
2
||h
L
θ
(x) − h
L
θ
(x
′
)||
2

(18.173)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.6. LEARNING THE KERNEL
x1
xD
Input layer h
(1)
1
h
(1)
A
. . .
. . .
h
(2)
1
h
(2)
B
h
(L)
1
h
(L)
C
W(1)
W(2)
W(L)
h1(θ)
h∞(θ)
Hidden layers
∞ layer
y1
yP
Output layer
. . .
. . .
. . .
. . .
. . . . . . . . .
. . .
Figure 18.25: Deep kernel learning: a Gaussian process with a deep kernel maps D dimensional inputs x
through L parametric hidden layers followed by a hidden layer with an infinite number of basis functions,
with base kernel hyperparameters θ. Overall, a Gaussian process with a deep kernel produces a probabilistic
mapping with an infinite number of adaptive basis functions parameterized by γ = {w, θ}. All parameters γ
are learned through the marginal likelihood of the Gaussian process. From Figure 1 of [Wil+16].
−1.5 −1.0 −0.5 0.0 0.5 1.0 1.5
x
−1
0
1
y
truth
data
model
(a)
−1.5 −1.0 −0.5 0.0 0.5 1.0 1.5
x
−1
0
1
y
truth
data
model
(b)
Figure 18.26: Modeling a discontinuous function with (a) a GP with a “shallow” Matérn 3
2
kernel, and (b) a
GP with a “deep” MLP + Matérn kernel. Generated by gp_deep_kernel_learning.ipynb.
where h
L
θ
(x) are the outputs of layer L from a DNN. We can then learning the parameters θ by
maximizing the marginal likelihood of the Gaussian processes.
This framework is illustrated in Figure 18.25. We can understand the neural network features as
inputs into a base kernel. The neural network can either be (1) pre-trained, (2) learned jointly with
the base kernel parameters, or (3) pre-trained and then fine-tuned through the marginal likelihood.
This approach can be viewed as a “last-layer” Bayesian model, where a Gaussian process is applied
to the final layer of a neural network. The base kernel often provides a good measure of distance in
feature space, desirably encouraging predictions to have high uncertainty as we move far away from
the data.
We can use deep kernel learning to help the GP learn discontinuous functions, as illustrated in
Figure 18.26. On the left we show the results of a GP with a standard Matérn 3
2
kernel. It is clear
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license720
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 18.27: Left: the learned covariance matrix of a deep kernel with spectral mixture base kernel on a set
of test cases for the Olivetti faces dataset, where the test samples are ordered according to the orientations
of the input faces. Middle: the respective covariance matrix using a deep kernel with RBF base kernel. Right:
the respective covariance matrix using a standard RBF kernel. From Figure 5 of [Wil+16].
that the out-of-sample predictions are poor. On the right we show the results of the same model
where we first transform the input through a learned 2 layer MLP (with 15 and 10 hidden units). It
is clear that the model is working much better.
As a more complex example, we consider a regression problem where we wish to map faces (vectors
of pixel intensities) to a continuous valued orientation angle. In Figure 18.27, we evaluate the deep
kernel matrix (with RBF and spectral mixture base kernels, discussed in Section 18.6.5) on data
ordered by orientation angle. We can see that the learned deep kernels, in the left two panels, have a
pronounced diagonal band, meaning that they have discovered that faces with similar orientation
angles are correlated. On the other hand, in the right panel we see that the entries even for a learned
RBF kernel are highly diffuse. Since the RBF kernel essentially uses Euclidean distance as a metric
for similarity, it is unable to learn a representation that effectively solves this problem. In this case,
one must do highly non-Euclidean metric learning.
However, [ORW21] show that the approach to DKL based on maximizing the marginal likelihood
can result in overfitting that is worse than standard DNN learning. They propose a fully Bayesian
approach, in which they use SGLD (Section 12.7.1) to sample the DNN weights as well as the GP
hyperparameters.
18.7 GPs and DNNs
In Section 18.6.6, we showed how we can combine the structural properties of neural networks with
GPs. In Section 18.7.1 we show that, in the limit of infinitely wide networks, a neural network defines
a GP with a certain kernel. These kernels are fixed, so the method is not performing representation
learning, as a standard neural network would (see e.g., [COB18; Woo+19]). Nonetheless, these kernels
are interesting in their own right, for example in modelling non-stationary covariance structure.
In Section 18.7.2, we discuss the connection between SGD training of DNNs and GPs. And in
Section 18.7.3, we discuss deep GPs, which are similar to DNNs in that they consist of many layers
of functions which are composed together, but each layer is a nonparametric function.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.7. GPS AND DNNS
18.7.1 Kernels derived from infinitely wide DNNs (NN-GP)
In this section, we show that an MLP with one hidden layer, whose width goes to infinity, and which
has a Gaussian prior on all the parameters, converges to a Gaussian process with a well-defined
kernel.6 This result was first shown for in [Nea96; Wil98], and was later extended to deep MLPs in
[DFS16; Lee+18], to CNNs in [Nov+19], and to general DNNs in [Yan19]. The resulting kernel is
called the NN-GP kernel [Lee+18].
We will consider the following model:
fk(x) = bk +
X
H
j=1
vjkhj (x), hj (x) = ϕ(u0j + x
Tuj ) (18.174)
where H is the number of hidden units, and ϕ() is some nonlinear activation function, such as ReLU.
We will assume Gaussian priors on the parameters:
bk ∼ N (0, σb), vjk ∼ N (0, σv), u0j ∼ N (0, σ0),uj ∼ N (0, Σ) (18.175)
Let θ = {bk, vjk, u0j ,uj} be all the parameters. The expected output from unit k when applied to
one input vector is given by
Eθ [fk(x)] = Eθ

bk +
X
H
j=1
vjkhj (x)

 = Eθ [bk]
| {z }
=0
+
X
H
j=1
Eθ [vjk]
| {z }
=0
Eu [hj (x)] = 0 (18.176)
The covariance in the output for unit k when the function is applied to two different inputs is given
by the following:7
Eθ [fk(x)fk(x
′
)] = Eθ



bk +
X
H
j=1
vjkhj (x)



bk +
X
H
j=1
vjkhj (x)



 (18.177)
= σ
2
b +
X
H
j=1
Eθ

v
2
jk
Eu [hj (x)hj (x
′
)] = σ
2
b + σ
2
vHEu [hj (x)hj (x
′
)] (18.178)
Now consider the limit H → ∞. We scale the magnitude of the output by defining σ
2
v = ω/H.
Since the input to k’th output unit is an infinite sum of random variables (from the hidden units
hj (x)), we can use the central limit theorem to conclude that the output converges to a Gaussian
with mean and variance given by
E [fk(x)] = 0, V [fk(x)] = σ
2
b + ωEu

h(x)
2

(18.179)
Furthermore, the joint distribution over {fk(xn) : n = 1 : N} for any N ≥ 2 converges to a
multivariate Gaussian with covariance given by
E [fk(x)fk(x
′
)] = σ
2
b + ωEu [h(x)h(x
′
)] , K(x, x
′
) (18.180)
6. Our presentation is based on http://cbl.eng.cam.ac.uk/pub/Intranet/MLG/ReadingGroup/presentation_
matthias.pdf.
7. We are using the fact that u ∼ N (0, σ2
) implies E

u
2

= V [u] = σ
2
.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license722
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
h(x˜) C(x˜, x˜
′
)
erf(x˜
Tu˜)
2
π
arcsin(f1(x˜, x˜
′
))
I
￾
x˜
Tu˜ ≥ 0

π − θ(x˜, x˜
′
)
ReLU(x˜
Tu˜)
f2(x˜,x˜
′
)
π
sin(θ(x˜, x˜
′
)) + π−θ(x˜,x˜
′
)
π
x˜
TΣ˜ x˜
′
Table 18.4: Some neural net GP kernels. Here we define f1(x˜, x˜
′
) = 2x˜
TΣ˜ x˜
′ √
(1+2x˜TΣ˜ x˜)(1+2(x˜′)TΣ˜ x˜′)
, f2(x˜, x˜
′
) =
||Σ˜
1
2 x˜|| ||Σ˜
1
2 x˜
′
||, f3(x˜, x˜
′
) = q
(x˜
TΣ˜ x˜)((x˜
′)
TΣ˜ x˜
′), and θ(x˜, x˜
′
) = arccos(f3(x˜, x˜
′
)). Results are derived in
[Wil98; CS09].
−4 −2 0 2 4
−1.0
−0.5
0.0
0.5
1.0
σ0 = 0
σ = 1
σ = 3
σ = 10
−4 −2 0 2 4
−2
−1
0
1
σ0 = 5
σ = 1
σ = 3
σ = 10
Figure 18.28: Sample output from a GP with an NNGP kernel derived from an infinitely wide one layer MLP
with activation function of the form h(x) = erf(x · u + u0) where u ∼ N (0, σ) and u0 ∼ N (0, σ0). Generated
by nngp_1d.ipynb. Used with kind permission of Matthias Bauer.
Thus the MLP converges to a GP. To compute the kernel function, we need to evaluate
C(x, x
′
) = Eu

h(u0 + u
Tx)h(u0 + u
Tx
′
)

= Eu

h(u˜
Tx˜)h(u˜
Tx˜
′
)

(18.181)
where we have defined x˜ = (1, x) and u˜ = (u0,u). Let us define
Σ˜ =

σ
2
0 0
0 Σ

(18.182)
Then we have
C(x, x
′
) = Z
h(u˜
Tx˜)h(u˜
T ˜x
′
)N (u˜|0, Σ˜ )du˜ (18.183)
This can be computed in closed form for certain activation functions, as shown in Table 18.4.
This is sometimes called the neural net kernel. Note that this is a non-stationary kernel, and
sample paths from it are nearly discontinuous and tend to constant values for large positive or
negative inputs, as illustrated in Figure 18.28.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.7. GPS AND DNNS
18.7.2 Neural tangent kernel (NTK)
In Section 18.7.1 we derived the NN-GP kernel, under the assumption that all the weights are random.
A natural question is: can we derive a kernel from a DNN after it has been trained, or more generally,
while it is being trained. It turns out that this can be done, as we show below.
Let f = [f(xn; θ)]N
n=1 be the N × 1 prediction vector, let ∇fL = [ ∂L
∂f(xn)
]
N
n=1 be the N × 1 loss
gradient vector, let θ = [θp]
P
p=1 be the P × 1 vector of parameters, and let ∇θf = [ ∂f(xn)
∂θp
] be the
P × N matrix of partials. Suppose we perform continuous time gradient descent with fixed learning
rate η. The parameters evolve over time as follows:
∂tθt = −η∇θL(ft) = −η∇θft · ∇fL(ft) (18.184)
Thus the function evolves over time as follows:
∂tft = ∇θf
T
t ∂tθt = −η∇θf
T
t ∇θft · ∇fL(ft) = −ηTt · ∇fL(ft) (18.185)
where Tt is the N × N kernel matrix
Tt(x, x
′
) , ∇θft(x) · ∇θft(x
′
) = X
P
p=1
∂f(x; θ)
∂θp


θt
∂f(x
′
; θ)
∂θp


θt
(18.186)
If we let the learning rate η become infinitesimally small, and the widths go to infinity, one can show
that this kernel converges to a constant matrix, this is known as the neural tangent kernel or
NTK [JGH18]:
T (x, x
′
) , ∇θf(x; θ∞) · ∇θf(x
′
; θ∞) (18.187)
Details on how to compute this kernel for various models, such as CNNs, graph neural nets, and
general neural nets, can be found in [Aro+19; Du+19; Yan19]. A software libary to compute the
NN-GP kernel and NTK is available in [Ano19].
The assumptions behind the NTK results in the parameters barely changing from their initial
values (which is why a linear approximation around the starting parameters is valid). This can
still lead to a change in the final predictions (and zero final training error), because the final layer
weights can learn to use the random features just like in kernel regression. However, this phenomenon
— which has been called “lazy training” [COB18] — is not representative of DNN behavior in
practice [Woo+19], where parameters often change a lot. Fortunately it is possible to use a different
parameterization which does result in feature learning in the infinite width limit [YH21].
18.7.3 Deep GPs
A deep Gaussian process or DGP is a composition of GPs [DL13]. More formally, a DGP of L
layers is a hierachical model of the form
DGP(x) = fL ◦ · · · ◦ f1(x), fi(·) = [f
(1)
i
(·), . . . , f(Hi)
i
(·)], f(j)
i ∼ GP(0, Ki(·, ·)) (18.188)
This is similar to a deep neural network, except the hidden nodes are now hidden functions.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license724
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
1960 1970 1980 1990
year
320
330
340
350
360
CO2 in ppm
Data
(a)
1960 1980 2000 2020
year
320
340
360
380
400
CO2 in ppm
Data
Mean
Confidence
(b)
Figure 18.29: (a) The observed Mauna Loa CO2 time series. (b) Forecasts from a GP. Generated by
gp_mauna_loa.ipynb.
A natural question is: what is gained by this approach compared to a standard GP? Although
conventional single-layer GPs are nonparametric, and can model any function (assuming the use of a
non-degenerate kernel) with enough data, in practice their performance is limited by the choice of
kernel. It is tempting to think that deep kernel learning (Section 18.6.6) can solve this problem, but
in theory a GP on top of a DNN is still just a GP. However, one can show that a composition of GPs
is strictly more general. Unfortunately, inference in deep GPs is rather complicated, so we leave the
details to Supplementary Section 18.1. See also [Jak21] for a recent survey on this topic.
18.8 Gaussian processes for time series forecasting
It is possible to use Gaussian processes to perform time series forecasting (see e.g., [Rob+13]). The
basic idea is to model the unknown output as a function of time, f(t), and to represent a prior about
the form of f as a GP; we then update this prior given the observed evidence, and forecast into the
future. Naively this would take O(T
3
) time. However, for certain stationary kernels, it is possible to
reformulate the problem as a linear-Gaussian state space model, and then use the Kalman smoother
to perform inference in O(T) time, as explained in [SSH13; SS19; Ada+20]. This conversion can be
done exactly for Matérn kernels and approximately for Gaussian (RBF) kernels (see [SS19, Ch. 12]).
In [SGF21], they describe how to reduce the linear dependence on T to log(T) time using a parallel
prefix scan operator, that can be run efficiently on GPUs (see Section 8.2.3.4).
18.8.1 Example: Mauna Loa
In this section, we use the Mauna Loa CO2 dataset from Section 29.12.5.1. We show the raw
data in Figure 18.29(a). We see that there is periodic (or quasi-periodic) signal with a year-long
period superimposed on a long term trend. Following [RW06, Sec 5.4.3], we will model this with a
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
18.8. GAUSSIAN PROCESSES FOR TIME SERIES FORECASTING
composition of kernels:
K(r) = K1(r) + K2(r) + K3(r) + K4(r) (18.189)
where Ki(t, t′
) = Ki(t − t
′
) for the i’th kernel.
To capture the long term smooth rising trend, we let K1 be a squared exponential (SE) kernel,
where θ0 is the amplitude and θ1 is the length scale:
K1(r) = θ
2
0
exp 
−
r
2
2 θ
2
1

(18.190)
To model the periodicity, we can use a periodic or exp-sine-squared kernel from Equation (18.18)
with a period of 1 year. However, since it is not clear if the seasonal trend is exactly periodic, we
multiply this periodic kernel with another SE kernel to allow for a decay away from periodicity; the
result is K2, where θ2 is the magnitude, θ3 is the decay time for the periodic component, θ4 = 1 is
the period, and θ5 is the smoothness of the periodic component.
K2(r) = θ
2
2
exp 
−
r
2
2 θ
2
3
− θ5 sin2

π r
θ4
 (18.191)
To model the (small) medium term irregularitries, we use a rational quadratic kernel (Equa￾tion (18.20)):
K3(r) = θ
2
6

1 +
r
2
2 θ
2
7
θ8
−θ8
(18.192)
where θ6 is the magnitude, θ7 is the typical length scale, and θ8 is the shape parameter.
The magnitude of the independent noise can be incorporated into the observation noise of the
likelihood function. For the correlated noise, we use another SE kernel:
K4(r) = θ
2
9
exp 
−
r
2
2 θ
2
10

(18.193)
where θ9 is the magnitude of the correlated noise, and θ10 is the length scale. (Note that the
combination of K1 and K4 is non-identifiable, but this does not affect predictions.)
We can fit this model by optimizing the marginal likelihood wrt θ (see Section 18.6.1). The
resulting forecast is shown in Figure 18.29(b).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license19 Beyond the iid assumption
19.1 Introduction
The standard approach to supervised ML assumes the training and test sets both contain independent
and identically distributed (iid) samples from the same distribution. However, there are many
settings in which the test distribution may be different from the training distribution; this is known
as distribution shift, as we discuss in Section 19.2.
In some cases, we may have data from multiple related distributions, not just train and test, as
we discuss in Section 19.6. We may also encounter data in a streaming setting, where the data
distribution may be changing continuously, or in a piecewise constant fashion, as we discuss in
Section 19.7. Finally, in Section 19.8, we discuss settings in which the test distribution is chosen by
an adversary to minimize performance of a prediction system.
19.2 Distribution shift
Suppose we have a labeled training set from a source distribution p(x, y) which we use to fit a
predictive model p(y|x). At test time we encounter data from the target distribution q(x, y).
If p 6= q, we say that there has been a distribution shift or datatset shift [QC+08; BD+10].
This can adversely affect the performance of predictive models, as we illustrate in Section 19.2.1.
In Section 19.2.2 we give a taxonomy of some kinds of distribution shift using the language of
causal graphical models. We then proceed to discuss a variety of strategies that can be adopted to
ameliorate the harm caused by distribution shift. In particular, in Section 19.3, we discuss techniques
for detecting shifts, so that we can abstain from giving an incorrect prediction if the model is not
confident. In Section 19.4, we discuss techniques to improve robustness to shifts; in particular, given
labeled data from p(x, y), we aim to create a model that approximates q(y|x). In Section 19.5, we
discuss techniques to adapt the model to the target distribution given some labeled or unlabeled
data from the target.
19.2.1 Motivating examples
Figure 19.1 shows how shifting the test distribution slightly, by adding a small amount of Gaussian
noise, can hurt performance of an otherwise high accuracy image classifier. Similar effects occur with
other kinds of common corruptions, such as image blurring [HD19]. Analogous problems can also
occur in the text domain [Ryc+19], and the speech domain (see e.g., male vs female speakers in728
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 19.1: Effect of Gaussian noise of increasing magnitude on an image classifier. The model is a
ResNet-50 CNN trained on ImageNet. From Figure 23 of [For+19]. Used with kind permission of Justin
Gilmer.
(A) Cow: 0.99, Pasture: 0.99,
Grass: 0.99, No Person: 0.98,
Mammal: 0.98
(B) No Person: 0.99, Water: 0.98,
Beach: 0.97, Outdoors: 0.97,
Seashore: 0.97
(C) No Person: 0.97, Mammal:
0.96, Water: 0.94, Beach: 0.94, Two:
0.94
Figure 19.2: Illustration of how image classifiers generalize poorly to new environments. (a) In the training
data, most cows ocur on grassy backgrounds. (b-c) In these test image, the cow occurs “out of context”, namely
on a beach. The background is considered a “spurious correlation”. In (b), the cow is not detected. In (c), it is
classified with a generic “mammal” label. Top five labels and their confidences are produced by ClarifAI.com,
which is a state of the art commerical vision system. From Figure 1 of [BVHP18]. Used with kind permission
of Sara Beery.
Figure 34.3). These examples illustrate that high performing predictive models can be very sensitive
to small changes in the input distribution.
Performance can also drop on “clean” images, but which exhibit other kinds of shift. Figure 19.2
gives an amusing example of this. In particular, it illustrates how the performance of a CNN image
classifier can be very accurate on in-domain data, but can be very inaccurate on out-of-domain
data, such as images with a different background, or taken at a different time or location (see e.g.,
[Koh+20b]) or from a novel viewing angle (see e.g., [KH22])).
The root cause of many of these problems is the fact that discriminative models often leverage
features that are predictive of the output in the training set, but which are not reliable in general.
For example, in an image classification dataset, we may find that green grass in the background
is very predictive of the class label “cow”, but this is not a feature that is stable across different
distributions; these are called spurious correlations or shortcut features. Unfortunately, such
features are often easier for models to learn, for reasons explained in [Gei+20a; Xia+21b; Sha+20;
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.2. DISTRIBUTION SHIFT
w
s
yn
xn
yn
xn
yn
w
t
xn
yˆn y
∗
n
xn Ln
ψ
s ψ
t
Dt D l
s
l Dt
u Dt
test
(a)
π
s
yn
xn
yn
xn
yn
π
t
xn
yˆn y
∗
n
xn Ln
φ
s φ
t
Dt D l
s
l Dt
u Dt
test
Nt N l
s
l Nt
u Nt
test
(b)
Figure 19.3: Models for distribution shift from source s to target t. Here D
s
L is the labeled training set from
the source, D
t
L is an optional labeled training set from the target, D
t
U is an optional unlabeled training set
from the target, and D
t
test is a labeled test set from the target. In the latter case, yˆn is the prediction on
the n’th test case (generated by the model), y
∗
n is the true value, and ℓn = ℓ(y
∗
n, yˆn) is the corresponding
loss. (Note that we don’t evaluate the loss on the source distribution.) (a) Discriminative (causal) model. (b)
Generative (anticausal).
Pez+21].
Relying on these shortcuts can have serious real-world consequences. For example, [Zec+18a]
found that a CNN trained to recognize pneumonia was relying on hospital-specific metal tokens in
the chest X-ray scans, rather than focusing on the lungs themselves, and thus the model did not
generalize to new hospitals.
Analogous problems arise with other kinds of ML models, as well as other data types, such as
text (e.g., changing “he” to “she” can flip the output of a sentiment analysis system), audio (e.g.,
adding background noise can easily confuse speech recognition systems), and medical records [Ros22].
Furthermore, the changes to the input needed to change the output can often be imperceptible, as
we discuss in the section on adversarial robustness (Section 19.8).
19.2.2 A causal view of distribution shift
In the sections below, we briefly summarize some canonical kinds of distribution shift. We adopt
a causal view of the problem, following [Sch+12a; Zha+13b; BP16; Mei18a; CWG20; Bud+21;
SCS22]).1
(See Section 4.7 for a brief discussion of causal DAGs, and Chapter 36 for more details.)
We assume the inputs to the model (the covariates) are X and the outputs to be predicted (the
labels) are Y . If we believe that X causes Y , denoted X → Y , we call it causal prediction or
discriminative prediction. If we believe that Y causes X, denoted Y → X, we call it anticausal
prediction or generative prediction. [Sch+12a].
1. In the causality literature, the question of whether a model can generalize to a new distribution is called the question
of external validity. If a model is externally valid, we say that it is transportable from one distribution to another
[BP16].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license730
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Original Data Label Shift 
p(y) changes p(y | X) changes 
Covariate Shift Concept Shift 
No Data Shift p(x) changes
Figure 19.4: Illustration of the 4 main kinds of distribution shift for a 2d binary classification problem.
Adapted from Figure 1 of [al21].
The decision about which model to use depends on our assumptions about the underlying data
generating process. For example, suppose X is a medical image, and Y is an image segmentation
created by a human expert or an algorithm. If we change the image, we will change the annotation,
and hence X → Y . Now suppose X is a medical image and Y is the ground truth disease state of
the patient, as estimated by some other means (e.g., a lab test). In this case, we have Y → X, since
changing the disease state will change the appearance of the image. As another example, suppose X
is a text review of a movie, and Y is a measure of how informative the review is. Clearly we have
X → Y . Now suppose Y is the star rating of the movie, representing the degree to which the user
liked it; this will affect the words that they write, and hence Y → X.
Based on the above discussion, we can factor the joint distribution in two possible ways. One way
is to define a discriminative model:
pθ(x, y) = pψ(x)pw(y|x) (19.1)
See Figure 19.3a. Alternatively we can define a generative model:
pθ(x, y) = pπ(y)pφ(x|y) (19.2)
See Figure 19.3b. For each of these 2 models model types, different parts of the distribution may
change from source to target. This gives rise to 4 canonical type of shift, as we discuss in Section 19.2.3.
19.2.3 The four main types of distribution shift
The four main types of distribution shift are summarized in Section 19.2 and are illustrated in
Figure 19.4. We give more details below (see also [LP20]).
19.2.3.1 Covariate shift
In a causal (discriminative) model, if pψ(x) changes (so ψ
s
6= ψ
t
), we call it covariate shift, also
called domain shift. For example, the training distribution may be clean images of coffee pots, and
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.2. DISTRIBUTION SHIFT
Name Source Target Joint
Covariate/domain shift p(X)p(Y |X) q(X)p(Y |X) Discriminative
Concept shift p(X)p(Y |X) p(X)q(Y |X) Discriminative
Label (prior) shift p(Y )p(X|Y ) q(Y )p(X|Y ) Generative
Manifestation shift p(Y )p(X|Y ) p(Y )q(X|Y ) Generative
Table 19.1: The 4 main types of distribution shift.
the test distribution may be images of coffee pots with Gaussian noise, as shown in Figure 19.1; or the
training distribution may be photos of objects in a catalog, with uncluttered white backgrounds, and
the test distribution may be photos of the same kinds of objects collected “in the wild”; or the training
data may be synthetically generated images, and the test distribution may be real images. Similar
shifts can occur in the text domain; for example, the training distribution may be movie reviews
written in English, and the test distribution may be translations of these reviews into Spanish.
Some standard strategies to combat covariate shift include importance weighting (Section 19.5.2)
and domain adaptation (Section 19.5.3).
19.2.3.2 Concept shift
In a causal (discriminative) model, if pw(y|x) changes (so ws 6= wt
), we call it concept shift, also
called annotation shift. For example, consider the medical imaging context: the conventions for
annotating images might be different between the training distribution and test distribution. Another
example of concept shift occurs when a new label can occur in the target distribution that was not
part of the source distribution. This is related to open world recognition, discussed in Section 19.3.4.
Since concept shift is a change in what we “mean” by a label, it is impossible to fix this problem
without seeing labeled examples from the target distribution, which defines each label by means of
examples.
19.2.3.3 Label/prior shift
In a generative model, if pπ(y) changes (i.e., π
s 6= π
t
), we call it label shift, also called prior shift
or prevalence shift. For example, consider the medical imaging context, where Y = 1 if the patient
has some disease and Y = 0 otherwise. If the training distribution is an urban hospital and the test
distribution is a rural hospital, then the prevalence of the disease, represented by p(Y = 1), might
very well be different.
Some standard strategies to combat label shift are to reweight the output of a discriminative
classifier using an estimate of the new label distribution, as we discuss in Section 19.5.4.
19.2.3.4 Manifestation shift
In a generative model, if pφ(x|y) changes (i.e., φ
s
6= φ
t
), we call manifestation shift [CWG20],
or conditional shift [Zha+13b]. This is, in some sense, the inverse of concept shift. For example,
consider the medical imaging context: the way that the same disease Y manifests itself in the shape
of a tumor X might be different. This is usually due to the presence of a hidden confounding factor
that has changed between source and target (e.g., different age of the patients).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license732
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 19.5: Causal diagrams for different sample selection strategies. Undirected edges can be oriented in
either direction. The selection variable S is set to 1 its parent nodes match the desired criterion; only these
samples are included in the dataset. (a) No selection. (b) Selection on X. (c) Selection on Y . (d) Selection
on X and Y . Adapted from Figure 4 of [CWG20].
19.2.4 Selection bias
In some cases, we may induce a shift in the distribution just due to the way the data is collected,
without any changes to the underlying distributions. In particular, let S = 1 if a sample from the
population is included in the training set, and S = 0 otherwise. Thus the source distribution is
p(X, Y ) = p(X, Y |S = 1) but the target distribution is q(X, Y ) = p(X, Y |S ∈ {0, 1}) = p(X, Y ), so
there is no selection.
In Figure 19.5 we visualize the four kinds of selection. For example, suppose we select based on X
meeting certain criteria, e.g., images of a certain quality, or exhibiting a certain pattern; this can
induce domain shift or covariate shift. Now suppose we select based on Y meeting certain criteria,
e.g., we are more likely to select rare examples where Y = 1, in order to balance the dataset (for
reasons of computational efficiency); this can induce label shift. Finally, suppose we select based on
both X and Y ; this can induce non-causal dependencies between X and Y , a phenomenon known as
selection bias (see Section 4.2.4.2 for details).
19.3 Detecting distribution shifts
In general it will not be possible to make a model robust to all of the ways a distribution can shift
at test time, nor will we always have access to test samples at training time. As an alternative, it
may be sufficient for the model to detect that a shift has happened, and then to respond in the
appropriate way. There are several ways of detecting distribution shift, some of which we summarize
below. (See also Section 29.5.6, where we discuss changepoint detection in time series data.) The
main distinction between methods is based on whether we have a set of samples from the target
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.3. DETECTING DISTRIBUTION SHIFTS
distribution, or just a single sample, and whether the test samples are labeled or unlabeled. We
discuss these different scenarios below.
19.3.1 Detecting shifts using two-sample testing
Suppose we collect a set of samples from the source and target distribution. We can then use standard
techniques for two-sample testing to estimate if the null hypothesis, p(x, y) = q(x, y), is true or
not. (If we have unlabeled samples, we just test if p(x) = q(x).) For example, we can use MMD
(Section 2.7.3) to measure the distance between the set of input samples (see e.g., [Liu+20a]). Or we
can measure (Euclidean) distances in the embedding space of a classifier trained on the source (see
e.g., [KM22]).
In some cases it may be possible to just test if the distribution of the labels p(y) has changed, which
is an easier problem than testing for changes in the distribution of inputs p(x). In particular, if the
label shift assumption (Section 19.2.3.3) holds (i.e., q(x|y) = p(x|y)), plus some other assumptions,
then we can use the blackbox shift estimation technique from Section 19.5.4 to estimate q(y). If
we find that q(y) = p(y), then we can conclude that q(x, y) = p(x, y). In [RGL19], they showed
experimentally that this method worked well for detecting distribution shifts even when the label
shift assumption does not hold.
It is also possible to use conformal prediction (Section 14.3) to develop “distribution free” methods
for detecting covariate shift, given only acccess to a calibration set and some conformity scoring
function [HL20].
19.3.2 Detecting single out-of-distribution (OOD) inputs
Now suppose we just have one unlabeled sample from the target distribution, x ∼ q, and we want to
know if x is in-distribution (ID) or out-of-distribution (OOD). We will call this problem out-of￾distribution detection, although it is also called anomaly detection, and novelty detection.
2
The OOD detection problem requires making a binary decision about whether the test sample is ID
or OOD. If it is ID, we may optionally require that we return its class label, as shown in Figure 19.6.
In the sections below, we give a brief overview of techniques that have been proposed for tackling
this problem, but for more details, see e.g., [Pan+21; Ruf+21; Bul+20; Yan+21; Sal+21; Hen+19b].
19.3.2.1 Supervised ID/OOD methods (outlier exposure)
The simplest method for OOD detection assumes we have access to labeled ID and OOD samples at
training time. Then we just fit a binary classifier to distinguish the OOD or background class (called
“known unknowns”) from the ID class (called “known knowns”) This technique is called outlier
exposure (see e.g., [HMD19; Thu+21; Bit+21]) and can work well. However, in most cases we will
not have enough examples from the OOD distribution, since the OOD set is basically the set of all
possible inputs except for the ones of interest.
2. The task of outlier detection is somewhat different from anomaly or OOD detection, despite the similar name.
In the outlier detection literature, the assumption is that there is a single unlabeled dataset, and the goal is to identify
samples which are “untypical” compared to the majority. This is often used for data cleaning. (Note that this is a
transductive learning task, where the model is trained and evaluated on the same data. We focus on inductive
tasks, where we train a model on one dataset, and then test it on another.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license734
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
OOD?
{squirrel, chipmunk {
yes
no
O
"I've never seen 
anything like this before!"
"I'm 90% certain this is 
a squirrel or a chipmunk."
Figure 19.6: Illustration of a two-stage decision problem. First we must decide if the input image is out-of￾distribution (OOD) or not. If it is not, we must return the set of class labels that have high probabilitiy. From
[AB21]. Used with kind permission of Anastasios Angelopoulos.
19.3.2.2 Classification confidence methods
Instead of trying to solve the binary ID/OOD classification problem, we can directly try to predict
the class of the input. Let the probabilities over the C labels be pc = p(y = c|x), and let the logits be
ℓc = log pc. We can derive a confidence score or uncertainty metric in a variety of ways from
these quantities, e.g., the max probability s = maxc pc, the margin s = maxc ℓc − max2
c
ℓc (where
max2 means the second largest element), the entropy s = H(p1:C )
3
, the “energy score” s =
P
c
ℓc
[Liu+21b], etc. In [Mil+21; Vaz+22] they show that the simple max probability baseline performs
very well in practice.
19.3.2.3 Conformal prediction
It is possible to create a method for OOD detection and ID classification that has provably bounded
risk using conformal prediction (Section 14.3). The details are in [Ang+21], but we sketch the basic
idea here.
We want to solve the two-stage decision problems illustrated in Figure 19.6. We define the
prediction set as follows:
Tλ(x) = (
∅ if OOD(x) > λ1
APS(x) otherwise
(19.3)
where OOD(x) is some heuristic OOD score (such as max class probability), and APS(x) is the
adaptive prediction set method of Section 14.3.1, which returns the set of the top K class labels,
such that the sum of their probabilities exceeds threshold λ2. (Formally, APS(x) = {π1, . . . , πK}
where π sorts f(x)1:C in descending order, and K = min{K′
:
PK′
c=1 f(x)c > λ2}.)
We choose the thresholds λ1 and λ2 using a calibration set and a frequentist hypothesis testing
3. [Kir+21] argues against using entropy, since it confuses uncertainty about which of the C labels to use with
uncertainty about whether any of the labels is suitable, compared to a “none-of-the-above” option.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.3. DETECTING DISTRIBUTION SHIFTS
0.0 0.1 0.2 0.3 0.4 0.5 0.6
p(x|)
Normalized empirical KDE
CIFAR10 (Train)
CIFAR10 (Test)
TrafficSign (Test)
SVHN (Test)
Figure 19.7: Likelihoods from a Glow normalizing flow model (Section 23.2.1) trained on CIFAR10 and
evaluated on different test sets. The SVHN street sign dataset has lower visual complexity, and hence higher
likelihood. Qualitatively similar results are obtained for other generative models and datasets. From Figure 1
of [Ser+20]. Used with kind permission of Joan Serrà.
method (see [Ang+21]). The resulting thresholds will jointly minimize the following risks:
R1(λ) = p(Tλ(x) = ∅) (19.4)
R2(λ) = p(y 6∈ Tλ(x)|Tλ(x) 6= ∅) (19.5)
where p(x, y) is the true but unknown source distribution (of ID samples, no OOD samples required),
R1 is the chance that an ID sample will be incorrectly rejected as OOD (type-I error), and R2 is the
chance (conditional on the decision to classify) that the true label is not in the predicted set. The goal
is to set λ1 as large as possible (so we can detect OOD examples when they arise) while controlling
the type-I error (e.g., we may want to ensure that we falsely flag (as OOD) no more than 10% of
in-distribution samples). We then set λ2 in the usual way for the APS method in Section 14.3.1.
19.3.2.4 Unsupervised methods
If we don’t have labeled examples, a natural approach to OOD detection is to fit an unconditional
density model (such as a VAE) to the ID samples, and then to evaluate the likelihood p(x) and
compare this to some threshold value. Unfortunately for many kinds of deep model and datasets, we
sometimes find that p(x) is lower for samples that are from the source distribution than from a novel
target distribution. For example, if we train a pixel-CNN model (Section 22.3.2) or a normalizing-flow
model (Chapter 23) on Fashion-MNIST and evaluate it on MNIST, we find it gives higher likelihood
to the MNIST samples [Nal+19a; Ren+19; KIW20; ZGR21]. This phenomenon occurs for several
other models and datasets (see Figure 19.7).
One solution to this is to use log a likelihood ratio relative to a baseline density model, R(x) =
log p(x)/q(x), as opposed to the raw log likelihood, L(x) = log p(x). (This technique was explored
in [Ren+19], amongst other papers.) An important advantage of this is that the ratio is invariant to
transformations of the data. To see this, let x
′ = φ(x) be some invertible, but possibly nonlinear,
transformation. By the change of variables, we have p(x
′
) = p(x)| det Jac(φ
−1
)(x)|. Thus L(x
′
) will
differ from L(x) in a way that depends on the transformation. By contrast, we have R(x) = R(x
′
),
regardless of φ, since
R(x
′
) = log p(x
′
) − log q(x
′
) = log p(x) + log | det Jac(φ
−1
)(x)| − log q(x) − log | det Jac(φ
−1
)(x)|
(19.6)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license736
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Various other strategies have been proposed, such as computing the log-likelihood adjusted by a
measure of the complexity (coding length computed by a lossless compression algorithm) of the input
[Ser+20], computing the likelihood of model features instead of inputs [Mor+21a], etc.
A closely related technique relies on reconstruction error. The idea is to fit an autoencoder or
VAE (Section 21.2) to the ID samples, and then measure the reconstruction error of the input: a
sample that is OOD is likely to incur larger error (see e.g., [Pol+19]). However, this suffers from the
same problems as density estimation methods.
An alternative to trying to estimate the likelihood, or reconstruct the output, is to use a GAN
(Chapter 26) that is trained to discriminate “real” from “fake” data. This has been extended to the
open set recognition setting in the OpenGAN method of [KR21b].
19.3.3 Selective prediction
Suppose the system has a confidence level of p that an input is OOD (see Section 19.3.4 for a
discussion of some ways to compute such confidence scores). If p is below some threshold, the system
may choose to abstain from classifying it with a specific label. By varying the threshold, we can
control the tradeoff between accuracy and abstention rate. This is called selective prediction (see
e.g., [EW10; GEY19; Ziy+19; JKG18]), and is useful for applications where an error can be more
costly than asking a human expert for help (e.g., medical image classification).
19.3.3.1 Example: SGLD vs SGD for MLPs
One way to improve performance of OOD detection is to “be Bayesian” about the parameters of the
model, so that the uncertainty in their values is reflected in the posterior predictive distribution.
This can result in better performance in selective prediction tasks.
In this section, we give a simple example of this, where we fit a shallow MLP to the MNIST dataset
using either standard SGD (specifically RMSprop) or stochastic gradient Langevin dynamics (see
Section 12.7.1), which is a form of MCMC inference. We use 6,000 training steps, where each step
uses a minibatch of size 1,000. After fitting the model to the training set, we evaluate its predictions
on the test set. To assess how well calibrated the model is, we select a subset of predictions whose
confidence is above a threshold t. (The confidence value is just the probability assigned to the MAP
class.) As we increase the threshold t from 0 to 1, we make predictions on fewer examples, but the
accuracy should increase. This is shown in Figure 19.8: the green curve is the fraction of the test set
for which we make a prediction, and the blue curve is the accuracy. On the left we show SGD, and
on the right we show SGLD. In this case, performance is quite similar, although SGD has slightly
higher accuracy. However, the story changes somewhat when there is distribution shift.
To study the effects under distribution shift, we apply both models to FashionMNIST data. We
show the results in Figure 19.9. The accuracy of both models is very low (less than the chance level
of 10%), but SGD remains quite confident in many more of its predictions than SGLD, which is
more conservative. To see this, consider a confidence threshold of 0.5: the SGD approach predicts on
about 97% of the examples (recall that the green curve corresponds to the right hand axis), whereas
the SGLD only predicts on about 70% of the examples.
More details on the behavior of Bayesian neural networks under distribution shift can be found in
Section 17.4.6.2.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.4. ROBUSTNESS TO DISTRIBUTION SHIFTS
0.00 0.25 0.50 0.75 1.00
certainty threshold
0.980
0.985
0.990
0.995
1.000
accuracy
0.00
0.25
0.50
0.75
1.00
Certainty Accuracy
pct of certain preds
Test accuracy
(a)
0.00 0.25 0.50 0.75 1.00
certainty threshold
0.92
0.94
0.96
0.98
1.00
0.00
0.25
0.50
0.75
1.00
pct
(b)
Figure 19.8: Accuracy vs confidence plots for an MLP fit to the MNIST training set, and then evaluated on
one batch from the MNIST test set. Scale for blue accuracy curve is on the left, scale for green percentage
predicted curve is on the right. (a) Plugin approach, computed using SGD. (b) Bayesian approach, computed
using 10 samples from SGLD. Generated by bnn_mnist_sgld.ipynb.
0.00 0.25 0.50 0.75 1.00
certainty threshold
0.065
0.075
0.085
accuracy
0.00
0.25
0.50
0.75
1.00
Certainty Accuracy
pct of certain preds
Test accuracy
(a)
0.00 0.25 0.50 0.75 1.00
certainty threshold
0.02
0.04
0.06
0.00
0.25
0.50
0.75
1.00
pct
(b)
Figure 19.9: Similar to Figure 19.8, except that performance is evaluated on the Fashion MNIST dataset. (a)
SGD. (b) SGLD. Generated by bnn_mnist_sgld.ipynb.
19.3.4 Open set and open world recognition
In Section 19.3.3, we discussed methods that “refuse to classify” if the system is not confident enough
about its predicted output. If the system detects that this lack of confidence is due to the input
coming from a novel class, rather than just being a novel instance of an existing class, we call the
problem open set recognition (see e.g., [GHC20] for a review).
Rather than “flagging” novel classes as OOD, we can instead allow the set of classes to grow over
time; this is called open world classification [BB15a]. Note that open world classification is most
naturally tackled in the context of a continual learning system, which we discuss in Section 19.7.3.
19.4 Robustness to distribution shifts
In this section, we discuss techniques to improve the robustness of a model to distribution shifts.
In particular, given labeled data from p(x, y), we aim to create a model that approximates q(y|x).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license738
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.4.1 Data augmentation
A simple approach to potentially increasing the robustness of a predictive model to distribution shifts
is to simulate samples from the target distribution by modifying the source data. This is called data
augmentation, and is widely used in the deep learning community. For example, it is standard to
apply small perturbations to images (e.g., shifting them or rotating them), while keeping the label
the same (assuming that the label should be invariant to such changes); see e.g., [SK19; Hen+20] for
details. Similarly, in NLP (natural language processing), it is standard to change words that should
not affect the label (e.g., replacing “he” with “she” in a sentiment analysis system), or to use back
translation (from a source language to a target language and back) to generate paraphrases; see
e.g., [Fen+21] for a review of such techniques. For a causal perspective on data augmentation, see
e.g., [Kau+21].
19.4.2 Distributionally robust optimization
We can make a discriminative model that is robust to (some forms of) covariate shift by solving the
following distributionally robust optimization (DRO) problem:
min
f∈F
max
w∈W
1
N
X
N
n=1
wnℓ(f(xn), yn) (19.7)
where the samples are from the source distribution, (xn, yn) ∼ p. This is an example of a min-max
optimization problem, in which we want to minimize the worst case risk. The specification of the
robustness set, W, is a key factor that determines how well the method works, and how difficult the
optimization problem is. Typically it is specified in terms of an ℓ2 ball around the inputs, but this
could also be defined in a feature (embedding space) It is also possible to define the robustness set
in terms of local changes to a structural causal model [Mei18a]. For more details on DRO, see e.g.,
[CP20a; LFG21; Sag+20; RM22].
19.5 Adapting to distribution shifts
In this section, we discuss techniques to adapt the model to the target distribution. If we have some
labeled data from the target distribution, we can use transfer learning, as we discuss in Section 19.5.1.
However, getting labeled data from the target distribution is often not an option. Therefore, in the
other sections, we discuss techniques that just rely on unlabeled data from the target distribution.
19.5.1 Supervised adaptation using transfer learning
Suppose we have labeled training data from a source distribution, Ds = {(xn, yn) ∼ p : n = 1 : Ns},
and also some labeled data from the target distribution, Dt = {(xn, yn) ∼ q : n = 1 : Nt}. Our goal
is to minimize the risk on the target distibution q, which can be computed using
R(f, q) = Eq(x,y)
[ℓ(y, f(x))] (19.8)
We can approximate the risk empirically using
Rˆ(f, D
t
) = 1
|Dt
|
X
(xn,yn)∈Dt
ℓ(yn, f(xn)) (19.9)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.5. ADAPTING TO DISTRIBUTION SHIFTS
If Dt
is large enough, we can directly optimize this using standard empirical risk minimization (ERM).
However, if Dt
is small, we might want to use Ds
somehow as a regularizer. This is called transfer
learning, since we hope to “transfer knowledge” from p to q. There are many approaches to transfer
learning (see e.g., [Zhu+21] for a review). We briefly mention a few below.
19.5.1.1 Pre-train and fine-tune
The simplest and most widely used approach to transfer learning is the pre-train and fine-tune
approach. We first fit a model to the source distribution by computing f
s = argminf Rˆ(f, Ds
). (Note
that the source data may be unlabeled, in which case we can use self-supervised learning methods.)
We then adapt the model to work on the target distribution by computing
f
t = argmin
f
Rˆ(f, D
t
) + λ||f − f
s
|| (19.10)
where ||f −f
s
|| is some distance between the functions, and λ ≥ 0 controls the degree of regularization.
Since we assume that we have very few samples from the target distribution, we typically “freeze”
most of the parameters of the source model. (This makes an implicit assumption that the features that
are useful for the source distribution also work well for the target.) We can then solve Equation (19.10)
by “chopping off the head” from f
s and replacing it with a new linear layer, to map to the new set of
labels for the target distribution, and then compute a new MAP estimate for the parameters on the
target distribution. (We can also compute a prior for the parameters of the source model, and use it
to compute a posterior for the parameters of the target model, as discussed in Section 17.2.3.)
This approach is very widely used in practice, since it is simple and effective. In particular, it is
common to take a large pre-trained model, such as a transformer, that has been trained (often using
self supervised learning, Section 32.3.3) on a lot of data, such as the entire web, and then to use this
model as a feature extractor (see e.g., [Kol+20]). The features are fed to the downstream model,
which may be a linear classifier or a shallow MLP, which is trained on the target distribution.
19.5.1.2 Prompt tuning (in-context learning)
Recently another approach to transfer learning has been developed, that leverages large models, such
as transformers (Section 22.4), which are trained on massive web datasets, usually in an unsupervised
way, and then adapted to a small, task-specific target distribution. The interesting thing about
this approach is the parameters of the original model are not changed; instead, the model is simply
“conditioned” on new training data, usually in the form of a text prompt z. That is, we compute
f
t
(x) = f
s
(x ∪ z) (19.11)
where we (manually or automatically) optimize z while keeping f
s
frozen. This approach is called
prompt tuning or in-context learning (see e.g., [Liu+21a]), and is an instance of few-shot
learning (see Figure 22.4 for an example).
Here z acts like a small training dataset, and f
s uses attention (Section 16.2.7) to “look at” all
its inputs, comparing x with the examples in z, and uses this to make a prediction. This works
because the text training data often has a similar hierarchical structure (see [Xie+22] for a Bayesian
interpretation).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license740
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.5.2 Weighted ERM for covariate shift
In this section we reconsider the risk minimization objective in Equation (19.8), but leverage unlabeled
data from the target distribution to estimate it. If we make the covariate shift assumption (i.e.,
q(x, y) = q(x)p(y|x)), then we have
R(f, q) = Z
q(x)q(y|x)ℓ(y, f(x))dxdy (19.12)
=
Z
q(x)p(y|x)ℓ(y, f(x))dxdy (19.13)
=
Z
q(x)
p(x)
p(x)p(y|x)ℓ(y, f(x))dxdy (19.14)
≈
1
N
X
(xn,yn)∈Ds
L
wnℓ(yn, f(xn)) (19.15)
where the weights are given by the ratio
wn = w(xn) = q(xn)
p(xn)
(19.16)
Thus we can solve the covariate shift problem by using weighted ERM [Shi00a; SKM07].
However, this raises two questions. First, why do we need to use this technique, since a discriminative
model p(y|x) should work for any input x, regardless of which distribution it comes from? Second,
given that we do need to use this method, in practice how should we estimate the weights wn =
w(xn) = q(xn)
p(xn)
? We discuss these issues below.
19.5.2.1 Why is covariate shift a problem for discriminative models?
For a discriminative model of the form p(y|x), it might seem that such a change in p(x) will not
affect the predictions. If the predictor p(y|x) is the correct model for all parts of the input space x,
then this conclusion is warranted. However, most models will only be accurate in certain parts of the
input space. This is illustrated in Figure 19.10b, where we show that a linear model fit to the source
distribution may perform much worse on the target distribution than a model that weights target
points more heavily during training.
19.5.2.2 How should we estimating the ERM weights?
One approach to estimating the ERM weights wn = w(xn) = q(xn)
p(xn)
is to learn a density model for
the source and target. However, density esimation is difficult for high dimensional features. An
alternative approach is to try to approximate the density ratio, by fitting a binary classifier to
distinguish the two distributions, as discussed in Section 2.7.5. In particular, suppose we have an
equal number of samples from p(x) and q(x). Let us label the first set with c = −1 and the second
set with c = 1. Then we have
p(c = 1|x) = q(x)
q(x) + p(x)
(19.17)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.5. ADAPTING TO DISTRIBUTION SHIFTS
(a) (b)
Figure 19.10: (a) Illustration of covariate shift. Light gray represents training distribution, dark gray
represents test distribution. We see the test distribution has shifted to the right but the underlying input-output
function is constant. (b) Dashed line: fitting a linear model across the full support of X. Solid black line:
fitting the same model only on parts of input space that have high likelihood under the test distribution. From
Figures 1–2 of [Sto09]. Used with kind permission of Amos Storkey.
and hence p(c=1|x)
p(c=−1|x) =
q(x)
p(x)
. If the classifier has the form f(x) = p(c = 1|x) = σ(h(x)) = 1
1+exp(−h(x)) ,
where h(x) is the prediction function that returns the logits, then the importance weights are given
by
wn =
1/(1 + exp(−h(xn)))
exp(−h(xn))/(1 + exp(−h(xn))) = exp(h(xn)) (19.18)
Of course this method requires that x values that may occur in the test distribution should also
be possible in the training distribution, i.e., q(x) > 0 =⇒ p(x) > 0. Hence there are no guarantees
about this method being able to interpolate beyond the training distribution.
19.5.3 Unsupervised domain adaptation for covariate shift
We now turn to methods that only need access to unlabeled examples from the target distribution.
The technique of unsupervised domain adaptation or UDA assumes access to a labeled
dataset from the source distribution, D1 = Ds
L ∼ p(x, y) and an unlabeled dataset from the target
distribution, D2 = Dt
U ∼ q(x). It then uses the unlabeled target data to improve robustness or
invariance of the predictor, rather than using a weighted ERM method.
There are many forms of UDA (see e.g., [KL21; CB20] for reviews). Here we just focus on one
method, called domain adversarial learning [Gan+16a]. Let fα : X1 ∪ X2 → H be a feature
extractor defined on the two input domains, let cβ : H → {1, 2} be a classifier that maps from the
feature space to the domain from which the input was taken, either domain 1 or 2 (source or target),
and let gγ : H → Y be a classifier that maps from the feature space to the label space. We want
to train the feature extractor so that it cannot distinguish whether the input is coming from the
source or target distribution; in this case, it will only be able to use features that are common to
both domains. Hence we optimize
min
γ
max
α,β
1
N1 + N2
X
xn∈D1,D2
ℓ(dn, cβ(fα(xn))) + 1
N1
X
(xn,yn)∈D1
ℓ(yn, gγ(fα(xn))) (19.19)
The objective in Equation (19.19) minimizes the loss on the desired task of classifying y, but maximizes
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license742
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
the loss on the auxiliary task of classifying the domain label d. This can be implemented by the
gradient sign reversal trick, and is related to GANs (Section 26.7.6).
19.5.4 Unsupervised techniques for label shift
In this section, we describe an approach known as blackbox shift estimation, due to [LWS18],
which can be used to tackle the label shift problem in an unsupervised way. We assume that the
only thing that changes in the target distribution is the label prior, i.e., if the source distribution is
denoted by p(x, y) and target distribution is denoted by q(x, y), we assume q(x, y) = p(x|y)q(y).
First note that, for any deterministic function f : X → Y, we have
p(x|y) = q(x|y) =⇒ p(f(x)|y) = q(f(x)|y) =⇒ p(ˆy|y) = q(ˆy|y) (19.20)
where yˆ = f(x) is the predicted label. Let µi = q(yˆ = i) be the empirical fraction of times the model
predicts class i on the test set, and let q(y = i) be the true but unknown label distribution on the
test set, and let Cij = p(yˆ = i|y = j) be the class confusion matrix estimated on the training set.
Then we have
µyˆ =
X
y
q(ˆy|y)q(y) = X
y
p(ˆy|y)q(y) = X
y
p(ˆy, y)
q(y)
p(y)
(19.21)
We can write this in matrix-vector form as follows:
µi =
X
i
Cij qj , =⇒ µ = Cq (19.22)
Hence we can solve q = C−1µ, providing that C is not singular (this will be the case if C is strongly
diagonal, i.e., the model predicts class yi correctly more often than any other class yj ). We also
require that for every q(y) > 0 we have p(y) > 0, which means we see every label at training time.
Once we know the new label distribution, q(y), we can adjust our discriminative classifier to take
the new label prior into account as follows:
q(y|x) = q(x|y)q(y)
q(x)
=
p(x|y)q(y)
q(x)
=
p(y|x)p(x)
p(y)
q(y)
q(x)
= p(y|x)
q(y)
p(y)
p(x)
q(x)
(19.23)
We can safely ignore the p(x)
q(x)
term, which is constant wrt y, and we can plug in our estimates of the
label distributions to compute the q(y)
p(y)
.
In summary, there are three requirements for this method: (1) the confusion matrix is invertible; (2)
no new labels at test time; (3) the only thing that changes is the label prior. If these three conditions
hold, the above approach is a valid estimator. See [LWS18] for more details, and [Gar+20] for an
alternative approach, based on maximum likelihood (rather than moment matching) for estimating
the new marginal label distribution.
19.5.5 Test-time adaptation
In some settings, it is possible to continuously update the model parameters. This allows the model
to adapt to changes in the input distribution. This is called test time adaptation or TTA. The
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.6. LEARNING FROM MULTIPLE DISTRIBUTIONS
difference from the unsupervised domain adaptation methods of Section 19.5.3 is that, in the online
setting, we just have the model which was trained on the source, and not the source distribution.
In [Sun+20] they proposed an approach called TTT (“test-time training”) for adapting a discrimi￾native model. In this approach, a self-supervised proxy task is used to create proxy-labels, which
can then be used to adapt the model at run time. In more detail, suppose we create a Y-structured
network, where we first perform feature extraction, x → h, and then use h to predict the output y
and some proxy output r, such as the angle of rotation of the input image. The rotation angle is
known if we use data augmentation. Hence we can apply this technique at test time, even if y is
unknown, and update the x → h → r part of the network, which influences the prediction for y via
the shared bottleneck (feature layer) h.
Of course, if the proxy output, such as the rotation angle, is not known, we cannot use proxy￾supervised learning methods such as TTT. In [Wan+20a], they propose an approach, inspired by
semi-supervised learning methods, which they call TENT, which stands for “test-time adaptation by
entropy minimization”. The idea is to update the classifier parameters to minimize the entropy of
the predictive distribution on a batch of test examples. In [Goy+22], they give a justification for this
heuristic from the meta-learning perspective. In [ZL21], they present a Bayesian version of TENT,
which they call BACS, which stands for “Bayesian adaptation under covariate shift”. In [ZLF21],
they propose a method called MEMO (“marginal entropy minimization with one test point”) that
can be used for any architecture. The idea is, once again, to apply data augmentation at test time to
the input x, to create a set of inputs, x˜1, . . . , x˜B. Now we update the parameters so as to minimize
the predictive entropy produced by the averaged distribution
p(y|x, w) = 1
B
X
B
b=1
p(y|x˜b, w) (19.24)
This ensures that the model gives the same predictions for each perturbation of the input, and that
the predictions are confident (low entropy).
An alternative to entropy based methods is to use pseudolabels (predicted outputs on the
unlaneled target generated by the source model), and then to self-train on these (see e.g., [KML20;
LHF20; Che+22]), often with additional regularizers to prevent over-fitting.
19.6 Learning from multiple distributions
In Section 19.2, we discussed the setting in which a model is trained on a single source distribution,
and then evaluated on a distinct target distribution. In this section, we generalize this to a setting in
which the model is trained on data from J ≥ 2 source distributions, before being tested on data from
a target distribution. This includes a variety of different problem settings, depending on the value of
J, as we summarize in Figure 19.11.
19.6.1 Multitask learning
In multi-task learning (MTL) [Car97], we have labeled data from J different distributions, Dj =
{(x
j
n
, y
j
n
) : n = 1 : Nj}, and the goal is to learn a model that predicts well on all J of them
simultaneously, where f(x, j) : X → Yj is the output for the j’th task. For example, we might want
to map a color image of size H × W × 3 to a set of semantic labels per pixel, Y
1 = {1, . . . , C}
HW , as
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license744
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
One 
distribution
Two 
distributions
n>2
distributions
Target distribution = 
source distribution
(Un)supervised 
source + supervised 
target data 
Supervised source 
data + unsupervised 
target data
All distributions are 
available
Target distribution is 
unavailable
Distributions are 
arriving continuously
Standard iid methods
Transfer learning 
(fine-tuning)
Unsupervised 
domain adaptation
Multi-task learning
Domain 
generalization
Continual learning
Problem set-up Family of Solutions
Source model + 
unsupervised target 
data
Test time adaptation
Figure 19.11: Schematic overview of techniques for learning from 1 or more different distributions. Adapted
from slide 3 of [Sca21].
well as a set of predicted depth values per pixel, Y
2 = R
HW . We can do this using ERM where we
have multiple samples for each task:
f
∗ = argmin
f
X
J
j=1
X
Nj
n=1
ℓj (y
j
n
, f(x
j
n
, j)) (19.25)
where ℓj is the loss function for task j (suitably scaled).
There are many approaches to solving MTL. The simplest is to fit a single model with multiple
“output heads”, as illustrated in Figure 19.12. This is called a “shared trunk network”. Unfortu￾nately this often leads to worse performance than training J single task networks. In [Mis+16], they
propose to take a weighted combination of the activations of each single task network, an approach
they called “cross-stitch networks”. See [ZY21] for a more detailed review of neural approaches,
and [BLS11] for a theoretical analysis of this problem.
Note that multi-task learning does not always help performance on each task because sometimes
there can be “task interference” or “negative transfer” (see e.g., [MAP17; Sta+20; WZR20]).
In such cases, we should use separate networks, rather than using one model with multiple output
heads.
19.6.2 Domain generalization
The problem of domain generalization assumes we train on J different labeled source distributions
or “environments” (also called “domains”), and then test on a new target distribution (denoted by
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.6. LEARNING FROM MULTIPLE DISTRIBUTIONS
X
w
1
w
j
w0 : shared parameters
task specific parameters
y
1
y
j
Figure 19.12: Illustration of multi-headed network for multi-task learning.
w
0
w
1 w
J w
t
y
1
n y
J
n
yˆn y
∗
n
x
1
n x
J
n x
t
n Ln
φ
1 φ
J φ
t
φ
0
...
Figure 19.13: Hierarchical Bayesian discriminative model for learning from J different environments (distri￾butions), and then testing on a new target distribution t = J + 1. Here yˆn is the prediction for test example
xn, y
∗
n is the true output, and ℓn = ℓ(y
t
n, y
∗
n) is the associated loss. The parameters of the distribution over
input features pφ(x) are shown with dotted edges, since these distributions do not need to be learned in a
discriminative model.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license746
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 19.14: Illustration of invariant causal prediction. The hammer symbol represents variables whose
distribution is perturbed in the given environment. An invariant predictor must use features {X2, X4}.
Considering indirect causes instead of direct ones (e.g. {X2, X5}) or an incomplete set of direct causes (e.g.,
{X4}) may not be sufficient to guarantee invariant prediction. From Figure 1 of [PBM16b]. Used with kind
permission of Jonas Peters.
t = J + 1). In some cases each environment is just identified with a meaningless integer id. In more
realistic settings, each different distribution has associated meta-data or context variables that
characterizes the environment in which the data was collected, such as the time, location, imaging
device, etc.
Domain generalization (DG) is similar to multi-task learning, but differs in what we want to
predict. In particular, in DG, we only care about prediction accuracy on the target distribution, not
the J training distribution. Furthermore, we assume we don’t have any labeled data from the target
distribution. We therefore have to make some assumptions about how p
t
(x, y) relates to p
j
(x, y) for
j = 1 : J.
One way to formalize this is to create a hierarchical Bayesian model, as proposed in [Bax00], and
illustrated in Figure 19.13. This encodes the assumption that p
t
(x, y) = p(x|φ
t
)p(y|x, wt
) where
wt
is derived from a common “population level” model w0
, shared across all distributions, and
similarly for φ
t
. (Note, however, that in a discriminative model, we don’t need to model p(x|φ
t
).)
See Section 15.5 for discussion of hierarchical Bayesian GLMs, and Section 17.6 for discussion of
hierarchical Bayesian MLPs.
Many other techniques have been proposed for DG. Note, however, that [GLP21] found that none
of these methods worked consistently better than the baseline approach of performing empirical
risk minimization across all the provided datasets. For more information, see e.g., [GLP21; She+21;
Wan+21; Chr+21].
19.6.3 Invariant risk minimization
One approach to domain generalization that has received a lot of attention is called invariant
risk minimization or IRM [Arj+19]. The goal is to learn a predictor that works well across all
environments, yet is less prone to depending on the kinds of “spurious features” we discussed in
Section 19.2.1.
IRM is an extension of an earlier method called invariant causal prediction (ICP) [PBM16b].
This uses hypothesis testing methods to find the set of predictors (features) that directly cause the
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.6. LEARNING FROM MULTIPLE DISTRIBUTIONS
outcome in each environment, rather than features that are indirect causes, or are just correlated
with the outcome. See Figure 19.14 for an illustration.
In [Arj+19], they proposed an extension of ICP to handle the case of high dimensional inputs,
where the individual variables do not have any causal meaning (e.g., they correspond to pixels).
Their approach requires finding a predictor that works well on average, across all environments, while
also being optimal for each individual environment. That is, we want to find
f
∗ = argmin
f∈F
X
J
j=1
1
Nj
X
Nj
n=1
ℓ(y
j
n
, f(x
j
n
)) (19.26)
such that f ∈ arg min
g∈F
1
Nj
X
Nj
n=1
ℓ(y
j
n
, g(x
j
n
)) for all j ∈ E (19.27)
where E is the set of environments, and F is the set of prediction functions. The intuition behind
this is as follows: there may be many functions that achieve low empirical loss on any given
environment, since the problem may be underspecified, but if we pick the one that also works well on
all environments, it is more likely to rely on causal features rather than spurious features.
Unfortunately, more recent work has shown that the IRM principle often does not work well for
covariate shift, both in theory [RRR21] and practice [GLP21], although it can work well in some
anti-causal (generative) models [Ahu+21].
19.6.4 Meta learning
The goal of meta-learning is to “learn the learning algorithm” [TP97]. A common way to do this is
to provide the meta-learner with a set of datasets from different distributions. This is very similar
to domain generalization (Section 19.6.2), except that we partition each training distribution into
training and test, so we can “practice” learning to generalize from a training set to a test set. A
general review of meta-learning can be found in [Hos+20a]. Here we present a unifying summary
based on the hierarchical Bayesian framework proposed in [Gor+19].
19.6.4.1 Meta-learning as probabilistic inference for prediction
We assume there are J tasks (distributions), each of which has a training set D
j
train = {(x
j
n
, y
j
n
) :
n = 1 : Nj} and a test set D
j
test = {(x˜
j
m, y˜
j
m) : m = 1 : Mj}. In addition, wj are the task specific
parameters, and w0 are the shared parameters, as shown in Figure 19.15. This is very similar to
the domain generalization model in Figure 19.13, except for two differences: first there is the trivial
difference due to the use of plate notation; second, in meta learning, we have both training and test
partitions for all distributions, whereas in DG, we only have a test set for the target distribution.
We will learn a point estimate for the global parameters w0
, since it is shared across all datasets,
and thus has little uncertainty. However, we will compute an approximate posterior for wj
, since
each task often has little data. We denote this posterior by p(wj
|Dj
train, w0
). From this, we can
compute the posterior predictive distribution for each task:
p(y˜
j
|x˜
j
, D
j
train, w0
) = Z
p(y˜
j
|x˜
j
, wj
)p(wj
|Dj
train, w0
)dwj
(19.28)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license748
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
w
0
y
j x n
j
n
n = 1, ..., Nj
D
j
train
w
j y˜
j
m x˜
j
m
m = 1, ..., Mj
D
j
test
Figure 19.15: Hierarchical Bayesian model for meta-learning. There are J tasks, each of which has a training
set D
j = {(x
j
n, y
j
n) : n = 1 : N
j
} and a test set D
j
test = {(x˜
j
m, y˜
j
m) : m = 1 : Mj
}. wj
are the task specific
parameters, and θ are the shared parameters. Adapted from Figure 1 of [Gor+19].
Since computing the posterior is in general intractable, we will learn an amortized approximation
(see Section 10.1.5) to the predictive distribution, denoted by qφ(y˜
j
|x˜
j
, D
j
train, w0
). We choose the
parameters of the prior w0 and the inference network φ to make this predictive posterior as accurate
as possible for any given input dataset:
φ
∗ = argmin
φ
Ep(Dtrain,x˜)

DKL ￾
p(y˜|x˜, Dtrain, w0
) k qφ(y˜|x˜, Dtrain, w0
)
 (19.29)
= argmin
φ
Ep(Dtrain,x˜)

Ep(y˜|x˜,Dtrain,w0)

log qφ(y˜|x˜, Dtrain, w0
)
 (19.30)
= argmin
φ
Ep(Dtrain,x˜,y˜)

log Z
p(y˜|x˜, w)qφ(w|Dtrain, w0
)dw

(19.31)
where we made the approximation p(y˜|x˜, Dtrain, w0
) ≈ p(y˜|x˜, Dtrain). We can then make a Monte
Carlo approximation to the outer expectation by sampling J tasks (distributions) from p(D), each
of which gets partitioned into a train and test set, {(D
j
train, D
j
test) ∼ p(D) : j = 1 : J}, where
D
j
test = {(x˜m, y˜m}. We can make an MC approximation to the inner expectation (the integral) by
drawing S samples from the task-specific parameter posterior wj
s ∼ qφ(wj
|Dj
, w0
). The resulting
objective has the following form (where we assume each test set has M samples for notational
simplicity):
Lmeta(w0
, φ) = 1
MJ
X
M
m=1
X
J
j=1
log 
1
S
X
S
s=1
p(y˜
j
m|x˜
j
m, wj
s
)
!
(19.32)
Note that this is different from standard (amortized) variational inference, that focuses on ap￾proximating the expected accuracy of the parameter posterior given all of the data for a task,
D
j
all = D
j
train ∪ Dj
test, rather than focusing on predictive accuracy of a test set given a training set.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.6. LEARNING FROM MULTIPLE DISTRIBUTIONS
Indeed, the standard objective has the form
LVI(w0
, φ) = 1
J
X
J
j=1


X
(x,y)∈Dj
all
"
1
S
X
S
s=1
log p(y˜
j
|x˜
j
, wj
s
)
#
− DKL

qφ(wj
|Dj
all, w0
) k p(wj
|w0
)



(19.33)
where wj
s ∼ qφ(wj
|Dj
all). We see that the standard formulation takes the average of a log, but the
meta-learning formulation takes the log of an average. The latter can give provably better predictive
accuracy, as pointed out in [MAD20]. Another difference is that the meta-learning formulation
optimizes the forward KL, not reverse KL. Finally, in the meta-learning formulation, we do not have
the KL penalty term on the parameter posterior.
Below we show how this framework includes several common approaches to meta-learning.
19.6.4.2 Neural processes
In the special case that the task-specific inference network computes a point estimate, q(wj
|Dj
, w0
) =
δ(wj − Aφ(Dj
, w0
)), the posterior predictive distribution becomes
q(y˜
j
|x˜
j
, D
j
, w0
) = Z
p(y˜
j
|x˜
j
, wj
)q(wj
|Dj
, w0
)dwj = p(y˜
j
|x˜
j
, Aφ(D
j
, w0
), w0
) (19.34)
where Aφ(Dj
, w0
) is a function that takes in a set, and returns some parameters. We can evaluate
this predictive distribution empirically, and directly optimize it (wrt φ and w0
) using standard
supervised maximum likelihood methods. This approach is called a neural process [Gar+18e;
Gar+18d; Dub20; Jha+22]).
19.6.4.3 Gradient-based meta-learning (MAML)
In gradient-based meta-learning, we define the task specific inference procedure as follows:
wˆ
j = A(D
j
, w0
) = w0 + η∇w logX
Nj
n=1
p(y
j
n
|x
j
n
, w)|w0 (19.35)
That is, we set the task specific parameters to be shared parameters w0
, modified by one step along the
gradient of the log conditional likelihood. This approach is called model-agnostic meta-learning
or MAML [FAL17]. It is also possible to take multiple gradient steps, by feeding the gradient into
an RNN [RL17].
19.6.4.4 Metric-based few-shot learning (prototypical networks)
Now suppose w0
correspond to the parameters of a shared neural feature extractor, hw0 (x), and
the task specific parameters are the weights and biases of the last linear layer of a classifier,
wj = {wj
c
, bj
c}
C
c=1. Let us compute the average of the feature vectors for each class in each task’s
training set:
µ
j
c =
1
|Dj
c |
X
xc
n∈Dj
c
hw0 (x
c
n
) (19.36)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license750
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Now define the task specific inference procedure as follows. We first compute the vector containing
the centroid and norm for each class:
wˆ
j = A(D
j
, w0
) = [µ
j
c
, −
1
2
||µ
j
c
||2
]
C
c=1 (19.37)
The predictive distribution becomes
q(˜y
j = c|x˜
j
, D
j
, w0
) ∝ exp ￾
−d(hw0 (x˜), µ
j
c
)

= exp 
hw0 (x˜)
Tµ
j
c −
1
2
||µ
j
c
||2

(19.38)
where d(u, v) is the Euclidean distance. This is equivalent to the technique known as prototypical
networks [SSZ17].
19.7 Continual learning
In this section, we discuss continual learning (see e.g., [Had+20; Del+21; Qu+21; LCR21; Mai+22;
Wan+23]), also called life-long learning (see e.g., [Thr98; CL18]), in which the system learns from
a sequence of different distributions, p1, p2, . . .. In particular, at each time step t, the model receives
a batch of labeled data,
Dt = {(xn, yn) ∼ pt(x, y) : n = 1 : Nt} (19.39)
where pt(x, y) is the unknown data distribution, which we represent as pt(x, y) = pt(x)p(y|ft(x)),
where ft : Xt → Yt is the unknown prediction function. Each distribution defines a different task.
The learner is then expected to update its belief state about the underlying distribution, and to use
its beliefs to make predictions on an independent test set,
D
test
t = {(xn, yn) ∼ p
test
t
(x, y) : n = 1 : N
test
t } (19.40)
Depending on how we assume pt(x, y) evolve over time, and how the test set is defined, we can
create a variety of different CL scenarios. In particular, if the test distribution at time t contains
samples from all the tasks up to (and including) time t, then we require that the model not “forget”
past data, which can be tricky for many methods, as discussed in Section 19.7.4. By contrast, if the
test distribution at time t is same as the current distribution, as in online learning (Section 19.7.5),
then we just require that the learner adapt to changes, but it need not remember the past. (Note
that we focus on supervised problems, but non-stationarity also arises in reinforcement learning;
in particular, the input distribution changes due to the agent’s changing policy, and the desired
prediction function changes due to the value function for that policy being updated.)
19.7.1 Domain drift
The problem of domain drift refers to the setting in which pt(x) changes over time (i.e., covariate
shift), but the functional mapping ft : X → Y is constant. For example, the vision system of a
self driving car may have to classify cars vs pedestrians under shifting lighting conditions (see e.g.,
[Sun+22]).
To evaluate such a model, we assume f
test
t = ft and define p
test
t
(x) to be the current input
distribution pt (e.g., if it is currently night time, we want the detector to work well on dark images).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.7. CONTINUAL LEARNING
Train 1 Train 2 Test 
distribution
...
Time
...
Figure 19.16: An illustration of domain drift.
Train 1 Train 2
...
Time
...
Figure 19.17: An illustration of concept drift.
Alternatively we can define p
test
t
(x) to be the union of all the input distributions seen so far,
p
test
t = ∪
T
s=1ps (e.g., we want the detector to work well on dark and light images)/ This latter
assumption is illustrated in Figure 19.16.
19.7.2 Concept drift
The problem of concept drift refers to the setting where the functional mapping ft : X → Y changes
over time, but the input distribution pt(x) is constant [WK96]. For example, we can imagine a
setting in which people engage in certain behaviors, and at step t some of these are classified as
illegal, and at step t
′ > t, the definition of what is legal changes, and hence the decision boundary
changes. This is illustrated in Figure 19.17.
As another example, we might initially be faced with a sort-by-color task, where red objects go on
the left and blue objects on the right, and then a sort-by-shape task, where square objects go on the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license752
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Task 1 Task 2 Test
distribution
...
Time
Empirical 
Distribution
Figure 19.18: An illustration of class incremental learning. Adapted from Figure 1 of [LCR21].
left and circular objects go on the right.4 We can think of this as a problem where p(y|x,task) is
stationary, but the task is unobserved, so p(y|x) changes.
In the concept drift scenario, we see that the prediction for the same underlying input point x ∈ X
will change depending on when the prediction is performed. This means that the test distribution
also needs to change over time for meaningful identification. Alternatively, we can “tag” each input
with the corresponding time stamp or task id.
19.7.3 Class incremental learning
A very widely studied form of continual learning focuses on the setting in which new class labels are
“revealed” over time. That is, there is assumed to be a true static prediction function f : X → Y,
but at step t, the learner only sees samples from (X , Yt), where Yt ⊂ Y. For example, consider the
problem of digit classification from images. Y1 might be {0, 1}, and Y2 might be {2, . . . , 9}. Learning
to classify with an increasing number of categories is called class incremental learning (see e.g.,
[Mas+20]). See Figure 19.18 for an illustration.
The problem of class incremental learning has been studied under a variety of different assumptions,
as discussed in [Hsu+18; VT18; FG18; Del+21]. The most common scenarios are shown in Figure 19.19.
If we assume there are no well defined boundaries between tasks, we have continuous task-agnostic
learning (see e.g., [SKM21; Zen+21]). If there are well defined boundaries (i.e., discontinuous changes
of the training distribution), then we can distinguish two subcases. If the boundaries are not known
during training (similar to detecting distribution shift), we have discrete task-agnostic learning.
Finally, if the boundaries are given to the training algorithm, we have a task-aware learning
problem.
A common experimental setup in the task-aware setting is to define each task to be a different
version of the MNIST dataset, e.g., with all 10 classes present but with the pixels randomly permuted
(this is called permuted MNIST) or with a subset of 2 classes present at each step (this is called
split MNIST).5
In the task-aware setting, the task label may or may not be known at test time.
4. This example is from Mike Mozer.
5. In the split MNIST setup, for task 1, digits (0,1) get labeled as (0,1), but in task 2, digits (2,3) get labeled as (0,1).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.7. CONTINUAL LEARNING
Defined task 
boundaries?
Task identity known 
during training?
Continous 
task-agnostic 
learning 
Discrete 
task-agnostic 
learning 
Task identity known 
during testing?
Multi-task learning
YES NO
YES NO
YES NO
Generally more challenging scenario(less information)
Discrete 
task-aware 
learning
Figure 19.19: Different kinds of incremental learning. Adapted from Figure 1 of [Zen+18].
If it is, the problem is essentially equivalent to multi-task learning (see Section 19.6.1). If it is not,
the model must predict the task and corresponding class label within that task (which is a standard
supervised problem with a hierarchical label space); this is commonly done by using a multi-headed
DNN, with CT outputs, where C is the number of classes, and T is the number of tasks.
In the multi-headed approach, the number of “heads” is usually specified as input to the algorithm,
because the softmax imposes a sum-to-one constraint that prevents incremental estimation of the
output weights in the open-class setting. An alternative approach is to wait until a new class label
is encountered for the first time, and then train the model with an enlarged output head. This
requires storing past data from each class, as well as data for the new class (see e.g., [PTD20]).
Alternatively, we can use generative classifiers where we do not need to worry about “output heads”. If
we use a “deep” nearest neighbor classifier, with a shared feature extractor (embedding function), the
main challenge is to efficiently update the stored prototypes for past classes as the feature extractor
parameters change (see e.g., [DLT21]). If we fit a separate generative model per class (e.g., a VAE,
as in [VLT21]), then online learning becomes easier, but the method may be less sample efficient.
At the time of writing, most of the CL literature focuses on the task-aware setting. However, from
a practical point of view, the assumption that task boundaries are provided at training or test time is
very unrealistic. For example, consider the problem of training a robot to perform various activities:
The data just streams in, and the robot must learn what to do, without anyone telling it that it is
now being given an example from a new task or distribution (see e.g., [Fon+21; Woł+21]). Thus
future research should focus on the task-agnostic setting, with either discrete or continuous changes.
So the “meaning” of the output label depends on what task we are solving. Thus the output space is really hierarchical,
namely the cross product of task id and class label.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license754
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Time Task1 Task1 Task1 Performance
(a)
Time Task1 Task1 Task1 Performance
(b)
Figure 19.20: Some failure modes in class incremental learning. We train on task 1 (blue) and evaluate on
tasks 1–3 (blue, orange, yellow); we then train on task 2 and evaluate on tasks 1–3; etc. (a) Catastrophic
forgetting refers to the phenomenon in which performance on a previous task drops when trained on a new
task. (b) Too little plasticity (e.g., due to too much regularization) refers to the phenomenon in which only
the first task is learned. Adapted from Figure 2 of [Had+20].
Time Task1 Task1 Task1 Performance
(a)
Time Task1 Task1 Task1 Performance
(b)
Time Task1 Task1 Task1 Performance
(c)
Figure 19.21: What success looks like for class incremental learning. We train on task 1 (blue) and evaluate
on tasks 1–3 (blue, orange, yellow); we then train on task 2 and evaluate on tasks 1–3; etc. (a) No forgetting
refers to the phenomenon in which performance on previous tasks does not degrade over time. (b) Forwards
transfer refers to the phenomenon in which training on past tasks improves performance on future tasks beyond
what would have been obtained by training from scratch. (c) Backwards transfer refers to the phenomenon in
which training on future tasks improves performance on past tasks beyond what would have been obtained by
training from scratch. Adapted from Figure 2 of [Had+20].
19.7.4 Catastrophic forgetting
In the class incremental learning literature, it is common to train on a sequence of tasks, but to
test (at each step) on all tasks. In this scenario, there are two main possible failure modes. The
first possible problem is called “catastrophic forgetting” (see e.g., [Rob95b; Fre99; Kir+17]). This
refers to the phenomenon in which performance on a previous task drops when trained on a new task
(see Figure 19.20(a)). Another possible problem is that only the first task is learned, and the model
does not adapt to new tasks (see Figure 19.20(b)).
If we avoid these problems, we should expect to see the performance profile in Figure 19.21(a),
where performance of incremental training is equal to training on each task separately. However, we
might hope to do better by virtue of the fact that we are training on multiple tasks, which are often
assumed to be related. In particular, we might hope to see forwards transfer, in which training on
past tasks improves performance on future tasks beyond what would have been obtained by training
from scratch (see Figure 19.21(b)). Additionally, we might hope to see backwards transfer, in
which training on future tasks improves performance on past tasks (see Figure 19.21(c)).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.7. CONTINUAL LEARNING
We can quantify the degree of transfer as follows, following [LPR17]. If Rij is the performance on
task j after it was trained on task i, Rind
j
is the performance on task j when trained just on j, and
there are T tasks, then the amount of forwards transfer is
FWT =
1
T
X
T
j=1
Rj,j − R
ind
j
(19.41)
and the amount of backwards transfer is
BWT =
1
T
X
T
j=1
RT ,j − Rj,j (19.42)
There are many methods that have been devised to overcome the problem of catastrophic forgetting,
but we can group them into three main types. The first is regularization methods, which add a
loss to preserve information that is relevant to old tasks. (For example, online Bayesian inference is
of this type, since the posterior for the parameters is derived from the new data and the past prior;
see e.g., the elastic weight consolidation method discussed in Section 17.5.1, or the variational
continual learning method discussed in Supplementary Section 10.2). The second is memory
methods, which rely on some kind of experience replay or rehearsal of past data (see e.g.,
[Hen+21]), or some kind of generative model of past data. The third is architectural methods,
that add capacity to the network whenever a task boundary is encountered, such as a new class label
(see e.g., [Rus+16]).
Of course, these techniques can be combined. For example, we can create a semi-parametric model,
in which we store some past data (exemplars) while also learning parameters online in a Bayesian
(regularized) way (see e.g., [Kur+20]). The “right” method depends, as usual, on what inductive bias
you want to use, and want your computational budget is in terms of time and memory.
19.7.5 Online learning
The problem of online learning is similar to continual learning, except the loss metric is different,
and we usually assume that learning and evaluation occur at each step. More precisely, we assume
the data generating distribution, p
∗
t
(x, y) = p(x|φt
)p(y|x, wt), evolves over time, as shown in
Figure 19.22. At each step t nature generates a data sample, (xt, yt) ∼ p
∗
t
. The agent sees xt and is
asked to predict yt by computing the posterior predictive distribution
pˆt|t−1 = p(y|xt, D1:t−1) (19.43)
where D1:t−1 = {(xs, ys) : s = 1 : t − 1} is all past data. It then incurs a loss of
Lt = ℓ(ˆpt|t−1, yt) (19.44)
See Figure 19.22. This approach is called prequential prediction [DV99; GSR13], and also forms
the basis of online conformal prediction [VGS22].
In contrast to the continual learning scenarios studied above, the loss incurred at each step is what
matters, rather than loss on a fixed test set. That is, we want to minimize L =
PT
t=1 Lt. In the
case of log-loss, this is equal to the (conditional) log marginal likelihood of the data, log p(D1:T ) =
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license756
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
w0 w1 w2
yˆ1
y1
x1
φ1
yˆ2
y2
x2
φ2
L1 L2
· · ·
· · ·
Figure 19.22: Online learning illustrated as an influence diagram (Section 34.2). Here yˆt =
argmaxy p(y|xt, D1:t−1) is the action (MAP predicted output) at time t, and Lt = ℓ(yt, yˆt) is the corre￾sponding loss (utility) function. We then update the parameters of the model, θt = (wt, φt
), given the input
and true output (xt, yt). The parameters of the world model can change arbitrarily over time.
log p(y1:T |x1:T ). This can be used to compute the prequential minimum description length (MDL)
of a model [BLH22], which is useful for model selection.
Another metric that is widely used, especially if it assumed that the distributions can be generated
by an adversary, is to compare the cumulative loss to the optimal value one could have obtained in
hindsight. This yields a quantity called the regret:
regret =
X
T
t=1

ℓ(ˆpt|t−1, yt) − ℓ(ˆpt|T , yt)

(19.45)
where pˆt|t−1 = p(y|xt, D1:t−1) is the online prediction, and pˆt|T = p(y|xt, D1:T ) is the optimal
estimate at the end of training. Bounds on the regret can be derived when the loss is convex [Ora19;
Haz22]. It is possible to convert bounds on regret, which are backwards looking, into bounds on risk
(i.e., expected future loss), which is forwards looking. See [HT15] for details.
Online learning is very useful for decision and control problems, such as multi-armed bandits
(Section 34.4) and reinforcement learning (see Chapter 35), where the agent “lives forever”, and where
there is no fixed training phase followed by a test phase. (See e.g., Section 17.5 where we discuss
online Bayesian inference for neural networks.)
The previous continual learning scenarios can be derived as special cases of online learning: we use
a different distribution (task) per time step, and provide a set of examples as input, instead of a
single example. On odd time steps, we train on the data from the current distribution, and incur a
loss of 0; and on even time steps, we evaluate on the test distribution, which may consist of the union
of all previously seen tasks, and return the empirical loss. (Thus doing well on old distributions
is relevant because we assume such distributions keep recurring.) Typically in CL the amount of
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.8. ADVERSARIAL EXAMPLES
Figure 19.23: Example of an adversarial attack on an image classifier. Left column: original image which is
correctly classified. Middle column: small amount of structured noise which is added to the input (magnitude
of noise is magnified by 10×). Right column: new image, which is confidently misclassified as a “gibbon”,
even though it looks just like the original “panda” image. Here ǫ = 0.007. From Figure 1 of [GSS15]. Used
with kind permission of Ian Goodfellow.
data per task is large, whereas online learning is more concerned with fast adaptation to slowly (or
piecewise continuously) changing distributions using small amounts of data per time step.
19.8 Adversarial examples
This section is coauthored with Justin Gilmer.
In Section 19.2, we discussed what happens to a predictive model when the input distribution
shifts for some reason. In this section, we consider the case where an adversary deliberately chooses
inputs to minimize the performance of a predictive model. That is, suppose an input x is classified
as belonging to class c. We then choose a new input xadv which minimizes the probability of this
label, subject to the constraint that xadv is “perceptually similar” to the original input x. This gives
rise to the following objective:
xadv = argmin
x′∈∆(x)
log p(y = c|x
′
) (19.46)
where ∆(x) is the set of images that are “similar” to x (we discuss different notions of similarity
below).
Equation (19.46) is an example of an adversarial attack. We illustrate this in Figure 19.23. The
input image x is on the left, and is predicted to be a panda with probability 57%. By adding a tiny
amount of carefully chosen noise (shown in the middle) to the input, we generate the adversarial
image xadv on the right: this “looks like” the input, but is now classified as a gibbon with probability
99%.
The ability to create adversarial images was first noted in [Sze+14]. It is suprisingly easy to create
such examples, which seems paradoxical, given the fact that modern classifiers seem to work so well
on normal inputs, and the perturbed images “look” the same to humans. We explain this paradox in
Section 19.8.5.
The existence of adversarial images also raises security concerns. For example, [Sha+16] showed
they could force a face recognition system to misclassify person A as person B, merely by asking
person A to wear a pair of sunglasses with a special pattern on them, and [Eyk+18] show that is
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license758
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
possible to attach small “adversarial stickers” to traffic signs to classify stop signs as speed limit
signs.
Below we briefly discuss how to create adversarial attacks, why they occur, and how we can try to
defend against them. We focus on the case of deep neural nets for images, although it is important
to note that many other kinds of models (including logistic regression and generative models) can
also suffer from adversarial attacks. Furthermore, this is not restricted to the image domain, but
occurs with many kinds of high dimensional inputs. For example, [Li+19] contains an audio attack
and [Dal+04; Jia+19] contains a text attack. More details on adversarial examples can be found in
e.g., [Wiy+19; Yua+19].
19.8.1 Whitebox (gradient-based) attacks
To create an adversarial example, we must find a “small” perturbation δ to add to the input x to
create xadv = x + δ so that f(xadv) = y
′
, where f() is the classifier, and y
′
is the label we want to
force the system to output. This is known as a targeted attack. Alternatively, we may just want
to find a perturbation that causes the current predicted label to change from its current value to any
other value, so that f(x + δ) 6= f(x), which is known as untargeted attack.
In general, we define the objective for the adversary as maximizing the following loss:
xadv = argmax
x′∈∆(x)
L(x
′
, y; θ) (19.47)
where y is the true label. For the untargeted case, we can define L(x
′
, y; θ) = − log p(y|x
′
), so we
minimize the probability of the true label; and for the targeted case, we can define L(x
′
, y; θ) =
log p(y
′
|x
′
), where we maximize the probability of the desired label y
′ 6= y.
To define what we mean by “small” perturbation, we impose the constraint that xadv ∈ ∆(x),
which is the set of “perceptually similar” images to the input x. Most of the literature has focused
on a simplistic setting in which the adversary is restricted to making bounded lp perturbations of a
clean input x, that is
∆(x) = {x
′
: ||x
′ − x||p < ǫ} (19.48)
Typically people assume p = 1 or p = 0. We will discuss more realistic threat models in Section 19.8.3.
In this section, we assume that the attacker knows the model parameters θ; this is called a
whitebox attack, and lets us use gradient based optimization methods. We relax this assumption
in Section 19.8.2.)
To solve the optimization problem in Equation (19.47), we can use any kind of constrained
optimization method. In [Sze+14] they used bound-constrained BFGS. [GSS15] proposed the more
efficient fast gradient sign (FGS) method, which performs iterative updates of the form
xt+1 = xt + δt (19.49)
δt = ǫ sign(∇x log p(y
′
|x, θ)|xt
) (19.50)
where ǫ > 0 is a small learning rate. (Note that this gradient is with respect to the input pixels, not
the model parameters.) Figure 19.23 gives an example of this process.
More recently, [Mad+18] proposed the more powerful projected gradient descent (PGD)
attack; this can be thought of as an iterated version of FGS. There is no “best” variant of PGD for
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.8. ADVERSARIAL EXAMPLES
Figure 19.24: Images that look like random noise but which cause the CNN to confidently predict a specific
class. From Figure 1 of [NYC15]. Used with kind permission of Jeff Clune.
Figure 19.25: Synthetic images that cause the CNN to confidently predict a specific class. From Figure 1 of
[NYC15]. Used with kind permission of Jeff Clune.
solving 19.47. Instead, what matters more is the implementation details, e.g. how many steps are
used, the step size, and the exact form of the loss. To avoid local minima, we may use random restarts,
choosing random points in the constraint space ∆ to initialize the optimization. The algorithm
should be carefully tuned to the specific problem, and the loss should be monitored to check for
optimization issues. For best practices, see [Car+19].
19.8.2 Blackbox (gradient-free) attacks
In this section, we no longer assume that the adversary knows the parameters θ of the predictive model
f. This is known as a black box attack. In such cases, we must use derivative-free optimization
(DFO) methods (see Section 6.7).
Evolutionary algorithms (EA) are one class of DFO solvers. These were used in [NYC15] to create
blackbox attacks. Figure 19.24 shows some images that were generated by applying an EA to a
random noise image. These are known as fooling images, as opposed to adversarial images, since
they are not visually realistic. Figure 19.25 shows some fooling images that were generated by
applying EA to the parameters of a compositional pattern-producing network (CPPN) [Sta07].6 By
suitably perturbing the CPPN parameters, it is possible to generate structured images with high
fitness (classifier score), but which do not look like natural images [Aue12].
6. A CPPN is a set of elementary functions (such as linear, sine, sigmoid, and Gaussian) which can be composed in
order to specify the mapping from each coordinate to the desired color value. CPPN was originally developed as a way
to encode abstract properties such as symmetry and repetition, which are often seen during biological development.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license760
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 19.26: An adversarially modified image to evade spam detectors. The image is constructed from
scratch, and does not involve applying a small perturbation to any given image. This is an illustrative example
of how large the space of possible adversarial inputs ∆ can be when the attacker has full control over the input.
From [Big+11]. Used with kind permission of Battista Biggio.
In [SVK19], they used differential evolution to attack images by modifying a single pixel. This is
equivalent to bounding the ℓ0 norm of the perturbation, so that ||xadv − x||0 = 1.
In [Pap+17], they learned a differentiable surrogate model of the blackbox, by just querying its
predictions y for different inputs x. They then used gradient-based methods to generate adversarial
attacks on their surrogate model, and then showed that these attacks transferred to the real model.
In this way, they were able to attack various the image classification APIs of various cloud service
providers, including Google, Amazon, and MetaMind.
19.8.3 Real world adversarial attacks
Typically, the space of possible adversarial inputs ∆ can be quite large, and will be difficult to exactly
define mathematically as it will depend on semantics of the input based on the attacker’s goals
[BR18]. (The set of variations ∆ that we want the model to be invariant to is called the threat
model.)
Consider for example of the content constrained threat model discussed in [Gil+18a]. One instance
of this threat model involves image spam, where the attacker wishes to upload an image attachment
in an email that will not be classified as spam by a detection model. In this case ∆ is incredibly
large as it consists of all possible images which contain some semantic concept the attacker wishes to
upload (in this case an advertisement). To explore ∆, spammers can utilize different fonts, word
orientations or add random objects to the background as is the case of the adversarial example in
Figure 19.26 (see [Big+11] for more examples). Of course, optimization based methods may still be
used here to explore parts of ∆. However, in practice it may be preferable to design an adversarial
input by hand as this can be significantly easier to execute with only limited-query black-box access
to the underlying classifier.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
19.8. ADVERSARIAL EXAMPLES
19.8.4 Defenses based on robust optimization
As discussed in Section 19.8.3, securing a system against adversarial inputs in more general threat
models seems extraordinarily difficult, due to the vast space of possible adversarial inputs ∆. However,
there is a line of research focused on producing models which are invariant to perturbations within
a small constraint set ∆(x), with a focus on lp-robustness where ∆(x) = {x
′
: ||x − x
′
||p < ǫ}.
Although solving this toy threat model has little application to security settings, enforcing smoothness
priors has in some cases improved robustness to random image corruptions [SHS], led to models which
transfer better [Sal+20], and has biased models towards different features in the data [Yin+19a].
Perhaps the most straightforward method for improving lp-robustness is to directly optimize for
it through robust optimization [BTEGN09], also known as adversarial training [GSS15]. We
define the adversarial risk to be
min
θ
E(x,y)∼p(x,y)

max
x′∈∆(x)
L(x
′
, y; θ)

(19.51)
The min max formulation in equation 19.51 poses unique challenges from an optimization perspective
— it requires solving both the non-concave inner maximization and the non-convex outer minimization
problems. Even worse, the inner max is NP-hard to solve in general [Kat+17]. However, in practice it
may be sufficient to compute the gradient of the outer objective ∇θL(xadv, y, ; θ) at an approximately
maximal point in the inner problem xadv ≈ argmaxx′ L(x
′
, y; θ) [Mad+18]. Currently, best practice
is to approximate the inner problem using a few steps of PGD.
Other methods seek to certify that a model is robust within a given region ∆(x). One method
for certification uses randomized smoothing [CRK19] — a technique for converting a model robust
to random noise into a model which is provably robust to bounded worst-case perturbations in
the l2-metric. Another class of methods applies specifically for networks with ReLU activations,
leveraging the property that the model is locally linear, and that certifying in region defined by linear
constraints reduces to solving a series of linear programs, for which standard solvers can be applied
[WK18].
19.8.5 Why models have adversarial examples
The existence of adversarial inputs is paradoxical, since modern classifiers seem to do so well on
normal inputs. However, the existence of adversarial examples is a natural consequence of the
general lack of robustness to distribution shift discussed in Section 19.2. To see this, suppose a
model’s accuracy drops on some shifted distribution of inputs pte(x) that differs from the training
distribution ptr(x); in this case, the model will necessarily be vunerable to an adversarial attack:
if errors exist, there must be a nearest such error. Furthermore, if the input distribution is high
dimensional, then we should expect the nearest error to be significantly closer than errors which are
sampled randomly from some out-of-distribution pte(x).
A cartoon illustration of what is going on is shown in Figure 19.27a, where x0 is the clean input
image, B is an image corrupted by Gaussian noise, and A is an adversarial image. If we assume a
linear decision boundary, then the error set E is a half space a certain distance from x0. We can
relate the distance to the decision boundary d(x0, E) with the error rate in noise at some input x0,
denoted by µ = Pδ∼N(0,σI)
[x0 + δ ∈ E]. With a linear decision boundary the relationship between
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license762
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 19.27: (a) When the input dimension n is large and the decision boundary is locally linear, even a
small error rate in random noise will imply the existence of small adversarial perturbations. Here, d(x0, E)
denotes the distance from a clean input x0 to an adversarial example (A) while the distance from x0 to a
random sample N(0; σ
2
I (B) will be approximately σ
√
n. As n → ∞ the ratio of d(x0, A) to d(x0, B) goes
to 0. (b) A 2d slice of the InceptionV3 decision boundary through three points: a clean image (black), an
adversarial example (red), and an error in random noise (blue). The adversarial example and the error
in noise lie in the same region of the error set which is misclassified as “miniature poodle”, which closely
resembles a halfspace as in a. Used with kind permission of Justin Gilmer.
these two quantities is determined by
d(x0, E) = −σΦ
−1
(µ) (19.52)
where Φ
−1 denotes the inverse cdf of the gaussian distribution. When the input dimension is large,
this distance will be significantly smaller than the distance to a randomly sampled noisy image
x0 + δ for δ ∼ N(0, σI), as the noise term will with high propbability have norm ||δ||2 ≈ σ
√
d. As a
concrete example consider the ImageNet dataset, where d = 224 × 224 × 3 and suppose we set σ = .2.
Then if the error rate in noise is just µ = .01, equation 19.52 will imply that d(x0, E) = .5. Thus the
distance to an adversarial example will be more than 100 times closer than the distance to a typical
noisy images, which will be σ
√
d ≈ 77.6. This phenomenon of small volume error sets being close
to most points in a data distribution p(x) is called concentration of measure, and is a property
common among many high dimensional data distributions [MDM19; Gil+18b].
In summary, although the existence of adversarial examples is often discussed as an unexpected
phenomenon, there is nothing special about the existence of worst-case errors for ML classifiers —
they will always exist as long as errors exist.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2023Part IV
Generation20 Generative models: an overview
20.1 Introduction
A generative model is a joint probability distribution p(x), for x ∈ X . In some cases, the model
may be conditioned on inputs or covariates c ∈ C, which gives rise to a conditional generative
model of the form p(x|c).
There are many kinds of generative model. We give a brief summary in Section 20.2, and go into
more detail in subsequent chapters. See also [Tom22] for a recent book on this topic that goes into
more depth.
20.2 Types of generative model
There are many kinds of generative model, some of which we list in Table 20.1. At a high level,
we can distinguish between deep generative models (DGM) — which use deep neural network
to learn a complex mapping from a single latent vector z to the observed data x — and more
“classical” probabilistic graphical models (PGM), that map a set of interconnected latent variables
z1, . . . , zL to the observed variables x1, . . . , xD using simpler, often linear, mappings. Of course,
many hybrids are possible. For example, PGMs can use neural networks, and DGMs can use
structured state spaces. We discuss PGMs in general terms in Chapter 4, and give examples in
Chapter 28, Chapter 29, Chapter 30. In this part of the book, we mostly focus on DGMs.
The main kinds of DGM are: variational autoencoders (VAE), autoregressive models
(ARM) models, normalizing flows, diffusion models, energy based models (EBM), and
generative adversarial networks (GAN). We can categorize these models in terms of the following
criteria (see Figure 20.1 for a visual summary):
• Density: does the model support pointwise evaluation of the probability density function p(x),
and if so, is this fast or slow, exact, approximate or a bound, etc? For implicit models, such
as GANs, there is no well-defined density p(x). For other models, we can only compute a lower
bound on the density (VAEs), or an approximation to the density (EBMs, UPGMs).
• Sampling: does the model support generating new samples, x ∼ p(x), and if so, is this fast or slow,
exact or approximate? Directed PGMs, VAEs, and GANs all support fast sampling. However,
undirected PGMs, EBMs, ARM, diffusion, and flows are slow for sampling.
• Training: what kind of method is used for parameter estimation? For some models (such as AR,
flows and directed PGMs), we can perform exact maximum likelihood estimation (MLE), although766
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Model Chapter Density Sampling Training Latents Architecture
PGM-D Section 4.2 Exact, fast Fast MLE Optional Sparse DAG
PGM-U Section 4.3 Approx, slow Slow MLE-A Optional Sparse graph
VAE Chapter 21 LB, fast Fast MLE-LB R
L Encoder-Decoder
ARM Chapter 22 Exact, fast Slow MLE None Sequential
Flows Chapter 23 Exact, slow/fast Slow MLE R
D Invertible
EBM Chapter 24 Approx, slow Slow MLE-A Optional Discriminative
Diffusion Chapter 25 LB Slow MLE-LB R
D Encoder-Decoder
GAN Chapter 26 NA Fast Min-max R
L Generator-Discriminator
Table 20.1: Characteristics of common kinds of generative model. Here D is the dimensionality of the observed
x, and L is the dimensionality of the latent z, if present. (We usually assume L ≪ D, although overcomplete
representations can have L ≫ D.) Abbreviations: Approx = approximate, ARM = autoregressive model,
EBM = energy based model, GAN = generative adversarial network, MLE = maximum likelihood estimation,
MLE-A = MLE (approximate), MLE-LB = MLE (lower bound), NA = not available, PGM = probabilistic
graphical model, PGM-D = directed PGM, PGM-U = undirected PGM, VAE = variational autoencoder.
0/1
... ... ...
Discriminator
Encoder
Generator
Flow
Decoder
Inverse
GAN: 
Adversarial
training
VAE: Maximize 
variational lower 
bound
Flow-based Model: 
Invertible transform of 
distributions
Diffusion Model: 
Gradually add 
Gaussian noise and 
then reverse
R
Energy EBM: 
Approximate 
Maximum 
likelihood
... ... ...
Autoregressive 
model: Learn 
conditional of each 
variable given past
Figure 20.1: Summary of various kinds of deep generative model. Here x is the observed data, z is the latent
code, and x
′
is a sample from the model. AR models do not have a latent code z. For diffusion models and
flow models, the size of z is the same as x. For AR models, x
d
is the d’th dimension of x. R represents
real-valued output, 0/1 represents binary output. Adapted from Figure 1 of [Wen21].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
20.3. GOALS OF GENERATIVE MODELING
the objective is usually non-convex, so we can only reach a local optimum. For other models, we
cannot tractably compute the likelihood. In the case of VAEs, we maximize a lower bound on the
likelihood; in the case of EBMs and UGMs, we maximize an approximation to the likelihood. For
GANs we have to use min-max training, which can be unstable, and there is no clear objective
function to monitor.
• Latents: does the model use a latent vector z to generate x or not, and if so, is it the same size as
x or is it a potentially compressed representation? For example, ARMs do not use latents; flows
and diffusion use latents, but they are not compressed.1 Graphical models, including EBMs, may
or may not use latents.
• Architecture: what kind of neural network should we use, and are there restrictions? For flows,
we are restricted to using invertible neural networks where each layer has a tractable Jacobian.
For EBMs, we can use any model we like. The other models have different restrictions.
20.3 Goals of generative modeling
There are several different kinds of tasks that we can use generative models for, as we discuss below.
20.3.1 Generating data
One of the main goals of generative models is to generate (create) new data samples. This is
sometimes called generative AI (see e.g., [GBGM23] for a recent survey). For example, if we fit
a model p(x) to images of faces, we can sample new faces from it, as illustrated in Figure 25.10.
2
Similar methods can be used to create samples of text, audio, etc. When this technology is abused
to make fake content, they are called deep fakes (see e.g., [Ngu+19]). Genrative models can also be
used to create synthetic data for training discriminative models (see e.g., [Wil+20; Jor+22]).
To control what is generated, it is useful to use a conditional generative model of the form
p(x|c). Here are some examples:
• c = text prompt, x = image. This is a text-to-image model (see Figure 20.2, Figure 20.3 and
Figure 22.6 for examples).
• c = image, x = text. This is an image-to-text model, which is useful for image captioning.
• c = image, x = image. This is an image-to-image model, and can be used for image colorization,
inpainting, uncropping, JPEG artefact restoration, etc. See Figure 20.4 for examples.
• c = sequence of sounds, x = sequence of words. This is a speech-to-text model, which is useful
for automatic speech recognition (ASR).
• c = sequence of English words, x = sequence of French words. This is a sequence-to-sequence
model, which is useful for machine translation.
1. Flow models define a latent vector z that has the same size as x, although the internal deterministic computation
may use vectors that are larger or smaller than the input (see e.g., the DenseFlow paper [GGS21]).
2. These images were made with a technique called score-based generative modeling (Section 25.3), although similar
results can be obtained using many other techniques. See for example https://this-person-does-not-exist.com/en
which shows results from a GAN model (Chapter 26).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license768
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) Teddy bears swimming at the
Olympics 400m Butterfly event.
(b) A cute corgi lives in a house
made out of sushi.
(c) A cute sloth holding a small trea￾sure chest. A bright golden glow is
coming from the chest.
Figure 20.2: Some 1024 × 1024 images generated from text prompts by the Imagen diffusion model (Sec￾tion 25.6.4). From Figure 1 of [Sah+22b]. Used with kind permission of William Chan.
Figure 20.3: Some images generated from the Parti transformer model (Section 22.4.2) in response to a
text prompt. We show results from models of increasing size (350M, 750M, 3B, 20B). Multiple samples are
generated, and the highest ranked one is shown. From Figure 10 of [Yu+22]. Used with kind permission of
Jiahui Yu.
• c = initial prompt, x = continuation of the text. This is another sequence-to-sequence model,
which is useful for automatic text generation (see Figure 22.5 for an example).
Note that, in the conditional case, we sometimes denote the inputs by x and the outputs by y. In
this case the model has the familiar form p(y|x). In the special case that y denotes a low dimensional
quantity, such as a integer class label, y ∈ {1, . . . , C}, we get a predictive (discriminative) model.
The main difference beween a discriminative model and a conditional generative model is this: in a
discriminative model, we assume there is one correct output, whereas in a conditional generative
model, we assume there may be multiple correct outputs. This makes it harder to evaluate generative
models, as we discuss in Section 20.4.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
20.3. GOALS OF GENERATIVE MODELING
Input Output Original
Colorization Inpainting Uncropping JPEG restoration
Figure 20.4: Illustration of some image-to-image tasks using the Palette conditional diffusion model (Sec￾tion 25.6.4). From Figure 1 of [Sah+22a]. Used with kind permission of Chitwan Saharia.
20.3.2 Density estimation
The task of density estimation refers to evaluating the probablity of an observed data vector,
i.e., computing p(x). This can be useful for outlier detection (Section 19.3.2), data compression
(Section 5.4), generative classifiers, model comparison, etc.
A simple approach to this problem, which works in low dimensions, is to use kernel density
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license770
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−5 0 5 10
x
0.0
0.1
0.2
0.3
Density function
unif, h=1
(a)
−5.0 −2.5 0.0 2.5 5.0 7.5 10.0
x
0.0
0.1
0.2
0.3
unif, h=2
(b)
−5 0 5 10
x
0.00
0.05
0.10
0.15
Density function
gauss, h=1
(c)
−5.0 −2.5 0.0 2.5 5.0 7.5 10.0
x
0.00
0.05
0.10
0.15
gauss, h=2
(d)
Figure 20.5: A nonparametric (Parzen) density estimator in 1d estimated from 6 datapoints, denoted by x.
Top row: uniform kernel. Bottom row: Gaussian kernel. Left column: bandwidth parameter h = 1. Right
column: bandwidth parameter h = 2. Adapted from http: // en. wikipedia. org/ wiki/ Kernel_ density_
estimation . Generated by parzen_window_demo.ipynb.
estimation or KDE, which has the form
p(x|D) = 1
N
X
N
n=1
Kh (x − xn) (20.1)
Here D = {x1, . . . , xN } is the data, and Kh is a density kernel with bandwidth h, which is a
function K : R → R+ such that R
K(x)dx = 1 and R
xK(x)dx = 0. We give a 1d example of this in
Figure 20.5: in the top row, we use a uniform (boxcar) kernel, and in the bottom row, we use a
Gaussian kernel.
In higher dimensions, KDE suffers from the curse of dimensionality (see e.g., [AHK01]), and
we need to use parametric density models pθ(x) of some kind.
20.3.3 Imputation
The task of imputation refers to “filling in” missing values of a data vector or data matrix. For
example, suppose X is an N × D matrix of data (think of a spreadsheet) in which some entries, call
them Xm, may be missing, while the rest, Xo, are observed. A simple way to fill in the missing
data is to use the mean value of each feature, E [xd]; this is called mean value imputation, and is
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
20.3. GOALS OF GENERATIVE MODELING
NA NA
NA
NA
Data sample A B C A B C
1
2
3
4
5
6
6
6
0
6
10 10 10
10 10 10
6 10 10 10
Average
Variables Missing values 
replaced by means 
2
6
6
0
6
10 10 10
10 10 10
10 10 10
9 8 7.5 9 8 7.5
9
9
7.5
7.5
Figure 20.6: Missing data imputation using the mean of each column.
illustrated in Figure 20.6. However, this ignores dependencies between the variables within each row,
and does not return any measure of uncertainty.
We can generalize this by fitting a generative model to the observed data, p(Xo), and then
computing samples from p(Xm|Xo). This is called multiple imputation. A generative model can
be used to fill in more complex data types, such as in-painting occluded pixels in an image (see
Figure 20.4).
See Section 3.11 for a more general discussion of missing data.
20.3.4 Structure discovery
Some kinds of generative models have latent variables z, which are assumed to be the “causes”
that generated the observed data x. We can use Bayes’ rule to invert the model to compute
p(z|x) ∝ p(z)p(x|z). This can be useful for discovering latent, low-dimensional patterns in the data.
For example, suppose we perturb various proteins in a cell and measure the resulting phosphorylation
state using a technique known as flow cytometry, as in [Sac+05]. An example of such a dataset is
shown in Figure 20.7(a). Each row represents a data sample xn ∼ p(·|an, z), where x ∈ R
11 is a
vector of outputs (phosphorylations), a ∈ {0, 1}
6
is a vector of input actions (perturbations) and z is
the unknown cellular signaling network structure. We can infer the graph structure p(z|D) using
graphical model structure learning techhniques (see Section 30.3). In particular, we can use the
dynamic programming method described in [EM07] to get the result is shown in Figure 20.7(b). Here
we plot the median graph, which includes all edges for which p(zij = 1|D) > 0.5. (For a more recent
approach to this problem, see e.g., [Bro+20b].)
20.3.5 Latent space interpolation
One of the most interesting abilities of certain latent variable models is the ability to generate samples
that have certain desired properties by interpolating between existing datapoints in latent space.
To explain how this works, let x1 and x2 be two inputs (e.g., images), and let z1 = e(x1) and
z2 = e(x2) be their latent encodings. (The method used for computing these will depend on the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license772
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a)
B2cAMP
f
erk
akt
jnk
Psitect AKT inh U0126
PMA
p38
G06967 mek12
raf
pkc
pip3
plcy
pip2
pka
Present
Missing
Int. edge
(b)
Figure 20.7: (a) A design matrix consisting of 5400 datapoints (rows) measuring the state (using flow
cytometry) of 11 proteins (columns) under different experimental conditions. The data has been discretized
into 3 states: low (black), medium (grey), and high (white). Some proteins were explicitly controlled using
activating or inhibiting chemicals. (b) A directed graphical model representing dependencies between various
proteins (blue circles) and various experimental interventions (pink ovals), which was inferred from this data.
We plot all edges for which p(Gij = 1|D) > 0.5. Dotted edges are believed to exist in nature but were not
discovered by the algorithm (1 false negative). Solid edges are true positives. The light colored edges represent
the effects of intervention. From Figure 6d of [EM07].
Start Image 0.2 0.4 0.6 0.8 End Image
Figure 20.8: Interpolation between two MNIST images in the latent space of a β-VAE (with β = 0.5).
Generated by mnist_vae_ae_comparison.ipynb.
Start Image 0.2 0.4 0.6 0.8 End Image
Figure 20.9: Interpolation between two CelebA images in the latent space of a β-VAE (with β = 0.5).
Generated by celeba_vae_ae_comparison.ipynb.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
20.3. GOALS OF GENERATIVE MODELING
Original -2 -1 0 1 2
Figure 20.10: Arithmetic in the latent space of a β-VAE (with β = 0.5). The first column is an input
image, with embedding z. Subsequent columns show the decoding of z + s∆, where s ∈ {−2, −1, 0, 1, 2} and
∆ = z
+ − z
− is the difference in the average embeddings of images with or without a certain attribute (here,
wearing sunglasses). Generated by celeba_vae_ae_comparison.ipynb.
type of model; we discuss the details in later chapters.) We can regard z1 and z2 as two “anchors” in
latent space. We can now generate new images that interpolate between these points by computing
z = λz1 + (1 − λ)z2, where 0 ≤ λ ≤ 1, and then decoding by computing x
′ = d(z), where d() is the
decoder. This is called latent space interpolation, and will generate data that combines semantic
features from both x1 and x2. (The justification for taking a linear interpolation is that the learned
manifold often has approximately zero curvature, as shown in [SKTF18]. However, sometimes it is
better to use nonlinear interpolation [Whi16; MB21; Fad+20].)
We can see an example of this process in Figure 20.8, where we use a β-VAE model (Section 21.3.1)
fit to the MNIST dataset. We see that the model is able to produce plausible interpolations between
the digit 7 and the digit 2. As a more interesting example, we can fit a β-VAE to the CelebA
dataset [Liu+15].3 The results are shown in Figure 20.9, and look reasonable. (We can get much
better quality if we use a larger model trained on more data for a longer amount of time.)
It is also possible to perform interpolation in the latent space of text models, as illustrated in
Figure 21.7.
20.3.6 Latent space arithmetic
In some cases, we can go beyond interpolation, and can perform latent space arithmetic, in which
we can increase or decrease the amount of a desired “semantic factor of variation”. This was first
shown in the word2vec model [Mik+13], but it also is possible in other latent variable models. For
example, consider our VAE model fit to the CelebA dataset, which has faces of celebrities and some
corresponding attributes. Let X+
i
be a set of images which have attribute i, and X−
i
be a set of
images which do not have this attribute. Let Z
+
i
and Z
−
i
be the corresponding embeddings, and z
+
i
and z
−
i
be the average of these embeddings. We define the offset vector as ∆i = z
+
i − z
−
i
. If we
add some positive multiple of ∆i to a new point z, we increase the amount of the attribute i; if we
subtract some multiple of ∆i
, we decrease the amount of the attribute i [Whi16].
We give an example of this in Figure 20.10. We consider the attribute of wearing sunglasses. The
j’th reconstruction is computed using xˆj = d(z + sj∆), where z = e(x) is the encoding of the
original image, and sj is a scale factor. When sj > 0 we add sunglasses to the face. When sj < 0 we
3. CelebA contains about 200k images of famous celebrities. The images are also annotated with 40 attributes. We
reduce the resolution of the images to 64 × 64, as is conventional.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license774
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
remove sunglasses; but this also has the side effect of making the face look younger and more female,
possibly a result of dataset bias.
20.3.7 Generative design
Another interesting use case for (deep) generative models is generative design, in which we use
the model to generate candidate objects, such as molecules, which have desired properties (see
e.g., [RNA22]). One approach is to fit a VAE to unlabeled samples, and then to perform Bayesian
optimization (Section 6.6) in its latent space, as discussed in Section 21.3.5.2.
20.3.8 Model-based reinforcement learning
We discuss reinforcement learning (RL) in Chapter 35. The main success stories of RL to date have
been in computer games, where simulators exist and data is abundant. However, in other areas, such
as robotics, data is expensive to acquire. In this case, it can be useful to learn a generative “world
model”, so the agent can do planning and learning “in it’s head”. See Section 35.4 for more details.
20.3.9 Representation learning
Representation learning refers to learning (possibly uninterpretable) latent factors z that generate
the observed data x. The primary goal is for these features to be used in “downstream” supervised
tasks. This is discussed in Chapter 32.
20.3.10 Data compression
Models which can assign high probability to frequently occuring data vectors (e.g., images, sentences),
and low probability to rare vectors, can be used for data compression, since we can assign shorter
codes to the more common items. Indeed, the optimal coding length for a vector x from some
stochastic source p(x) is l(x) = − log p(x), as proved by Shannon. See Section 5.4 for details.
20.4 Evaluating generative models
This section is written by Mihaela Rosca, Shakir Mohamed, and Balaji Lakshminarayanan.
Evaluating generative models requires metrics which capture
• sample quality — are samples generated by the model a part of the data distribution?
• sample diversity — are samples from the model distribution capturing all modes of the data
distribution?
• generalization — is the model generalizing beyond the training data?
There is no known metric which meets all these requirements, but various metrics have been proposed
to capture different aspects of the learned distribution, some of which we discuss below.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
20.4. EVALUATING GENERATIVE MODELS
20.4.1 Likelihood-based evaluation
A standard way to measure how close a model q is to a true distribution p is in terms of the KL
divergence (Section 5.1):
DKL (p k q) = Z
p(x) log p(x)
q(x)
= − H (p) + Hce (p, q) (20.2)
where H (p) is a constant, and Hce (p, q) is the cross entropy. If we approximate p(x) by the empirical
distribution, we can evaluate the cross entropy in terms of the empirical negative log likelihood
on the dataset:
NLL = −
1
N
X
N
n=1
log q(xn) (20.3)
Usually we care about negative log likelihood on a held-out test set.4
20.4.1.1 Computing the log-likelihood
For models of discrete data, such as language models, it is easy to compute the (negative) log
likelihood. However, it is common to measure performance using a quantity called perplexity, which
is defined as 2
H, where H = NLL is the cross entropy or negative log likelihood.
For image and audio models, one complication is that the model is usually a continuous distribution
p(x) ≥ 0 but the data is usually discrete (e.g., x ∈ {0, . . . , 255}
D if we use one byte per pixel).
Consequently the average log likelihood can be arbitrary large, since the pdf can be bigger than
1. To avoid this it is standard pratice to use uniform dequantization [TOB16], in which we add
uniform random noise to the discrete data, and then treat it as continuous-valued data. This gives a
lower bound on the average log likelihood of the discrete model on the original data.
To see this, let z be a continuous latent variable, and x be a vector of binary observations computed
by rounding, so p(x|z) = δ(x − round(z)), computed elementwise. We have p(x) = R
p(x|z)p(z)dz.
Let q(z|x) be a probabilistic inverse of x, that is, it has support only on values where p(x|z) = 1. In
this case, Jensen’s inequality gives
log p(x) ≥ Eq(z|x)
[log p(x|z) + log p(z) − log q(z|x)] (20.4)
= Eq(z|x)
[log p(z) − log q(z|x)] (20.5)
Thus if we model the density of z ∼ q(z|x), which is a dequantized version of x, we will get a lower
bound on p(x).
20.4.1.2 Likelihood can be hard to compute
Unfortunately, for many models, computing the likelihood can be computationally expensive, since
it requires knowing the normalization constant of the probability model. One solution is to use
variational inference (Chapter 10), which provides a way to efficiently compute lower (and sometimes
4. In some applications, we report bits per dimension, which is the log likelihood using log base 2, divided by the
dimensionality of x. To compute this metric, recall that log2 L =
loge L
loge 2
, and hence bpd = NLL loge
(2) 1
|x|
.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license776
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
upper) bounds on the log likelihood. Another solution is to use annealed importance sampling
(Section 11.5.4.1), which provides a way to estimate the log likelihood using Monte Carlo sampling.
However, in the case of implicit generative models, such as GANs (Chapter 26), the likelihood is not
even defined, so we need to find evaluation metrics that do not rely on likelihood.
20.4.1.3 Likelihood is not related to sample quality
A more subtle concern with likelihood is that it is often uncorrelated with the perceptual quality of
the samples, at least for real-valued data, such as images and sound. In particular, a model can have
great log-likelihood but create poor samples and vice versa.
To see why a model can have good likelihoods but create bad samples, consider the following
argument from [TOB16]. Suppose q0 is a density model for D-dimensional data x which performs
arbitrarily well as judged by average log-likelihood, and suppose q1 is a bad model, such as white
noise. Now consider samples generated from the mixture model
q2(x) = 0.01q0(x) + 0.99q1(x) (20.6)
Clearly 99% of the samples will be poor. However, the log-likelihood per pixel will hardly change
between q2 and q0 if D is large, since
log q2(x) = log[0.01q0(x) + 0.99q1(x)] ≥ log[0.01q0(x)] = log q0(x) − 2 (20.7)
For high-dimensional data, | log q0(x)| ∼ D ≫ 100, so log q2(x) ≈ log q0(x), and hence mixing in the
poor sampler does not significantly impact the log likelihood.
Now consider a case where the model has good samples but bad likelihoods. To achieve this,
suppose q is a GMM centered on the training images:
q(x) = 1
N
X
N
n=1
N (x|xn, ǫ2
I) (20.8)
If ǫ is small enough that the Gaussian noise is imperceptible, then samples from this model will look
good, since they correspond to the training set of real images. But this model will almost certainly
have poor likelihood on the test set due to overfitting. (In this case we say the model has effectively
just memorized the training set.)
20.4.2 Distances and divergences in feature space
Due to the challenges associated with comparing distributions in high dimensional spaces, and the
desire to compare distributions in a semantically meaningful way, it is common to use domain-specific
perceptual distance metrics, that measure how similar data vectors are to each other or to the
training data. However, most metrics used to evaluate generative models do not directly compare
raw data (e.g., pixels) but use a neural network to obtain features from the raw data and compare
the feature distribution obtained from model samples with the feature distribution obtained from
the dataset. The neural network used to obtain features can be trained solely for the purpose of
evaluation, or can be pretrained; a common choice is to use a pretrained classifier (see e.g., [Sal+16;
Heu+17b; Bin+18; Kyn+19; SSG18a]).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
20.4. EVALUATING GENERATIVE MODELS
The Inception score [Sal+16] measures the average KL divergence between the marginal distri￾bution of class labels obtained from the samples pθ(y) = R
pdisc(y|x)pθ(x)dx (where the integral is
approximated by sampling images x from a fixed dataset) and the distribution p(y|x) induced by
samples from the model, x ∼ pθ(x). (The term comes from the “Inception” model [Sze+15b] that is
often used to define pdisc(y|x).) This leads to the following score:
IS = exp 
Epθ(x)DKL (pdisc(Y |x) k pθ(Y ))
(20.9)
To understand this, let us rewrite the log score as follows:
log(IS) = H(pθ(Y )) − Epθ(x)
[H(pdisc(Y |x))] (20.10)
Thus we see that a high scoring model will be equally likely to generate samples from all classes,
thus maximizing the entropy of pθ(Y ), while also ensuring that each individual sample is easy to
classify, thus minimizing the entropy of pdisc(Y |x).
The Inception score solely relies on class labels, and thus does not measure overfitting or sample
diversity outside the predefined dataset classes. For example, a model which generates one perfect
example per class would get a perfect Inception score, despite not capturing the variety of examples
inside a class, as shown in Figure 20.11a. To address this drawback, the Fréchet Inception
distance or FID score [Heu+17b] measures the Fréchet distance between two Gaussian distributions
on sets of features of a pre-trained classifier. One Gaussian is obtained by passing model samples
through a pretrained classifier, and the other by passing dataset samples through the same classifier.
If we assume that the mean and covariance obtained from model features are µm and Σm and those
from the data are µd and Σd, then the FID is
FID = kµm − µdk
2
2 + tr
Σd + Σm − 2(ΣdΣm)
1/2

(20.11)
Since it uses features instead of class logits, the Fréchet distance captures more than modes captured
by class labels, as shown in Figure 20.11b. Unlike the Inception score, a lower score is better since
we want the two distributions to be as close as possible.
Unfortunately, the Fréchet distance has been shown to have a high bias, with results varying
widely based on the number of samples used to compute the score. To mitigate this issue, the kernel
Inception distance has been introduced [Bin+18], which measures the squared MMD (Section 2.7.3)
between the features obtained from the data and features obtained from model samples.
20.4.3 Precision and recall metrics
Since the FID only measures the distance between the data and model distributions, it is difficult
to use it as a diagnostic tool: a bad (high) FID can indicate that the model is not able to generate
high quality data, or that it puts too much mass around the data distribution, or that the model
only captures a subset of the data (e.g., in Figure 26.6). Trying to disentangle between these two
failure modes has been the motivation to seek individual precision (sample quality) and recall (sample
diversity) metrics in the context of generative models [LPO17; Kyn+19]. (The diversity question is
especially important in the context of GANs, where mode collapse (Section 26.3.3) can be an issue.)
A common approach is to use nearest neighbors in the feature space of a pretrained classifier to
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license778
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 20.11: (a) Model samples with good (high) inception score are visually realistic. (b) Model samples
with good (low) FID score are visually realistic and diverse.
define precision and recall [Kyn+19]. To formalize this, let us define
fk(φ, Φ) = (
1 if ∃φ
′ ∈ Φs.t. kφ − φ
′k
2
2 ≤ kφ
′ − NNk(φ
′
, Φ)k
2
2
0 otherwise
(20.12)
where Φ is a set of feature vectors and NNk(φ
′
, Φ) is a function returning the k’th nearest neighbor
of φ
′
in Φ. We now define precision and recall as follows:
precision(Φmodel, Φdata) = 1
|Φmodel|
X
φ∈Φmodel
fk(φ, Φdata); (20.13)
recall(Φmodel, Φdata) = 1
|Φdata|
X
φ∈Φdata
fk(φ, Φmodel); (20.14)
Precision and recall are always between 0 and 1. Intuitively, the precision metric measures whether
samples are as close to data as data is to other data examples, while recall measures whether data
is as close to model samples as model samples are to other samples. The parameter k controls
how lenient the metrics will be — the higher k, the higher both precision and recall will be. As in
classification, precision and recall in generative models can be used to construct a trade-off curve
between different models which allows practitioners to make an informed decision regarding which
model they want to use.
20.4.4 Statistical tests
Statistical tests have long been used to determine whether two sets of samples have been generated
from the same distribution; these types of statistical tests are called two sample tests. Let us
define the null hypothesis as the statement that both set of samples are from the same distribution.
We then compute a statistic from the data and compare it to a threshold, and based on this we
decide whether to reject the null hypothesis. In the context of evaluating implicit generative models
such as GANs, statistics based on classifiers [Saj+18] and the MMD [Liu+20b] have been used. For
use in scenarios with high dimensional input spaces, which are ubiquitous in the era of deep learning,
two sample tests have been adapted to use learned features instead of raw data.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
20.4. EVALUATING GENERATIVE MODELS
Like all other evaluation metrics for generative models, statistical tests have their own advantages
and disadvantages: while users can specify Type 1 error — the chance they allow that the null
hypothesis is wrongly rejected — statistical tests tend to be computationally expensive and thus
cannot be used to monitor progress in training; hence they are best used to compare fully trained
models.
20.4.5 Challenges with using pretrained classifiers
While popular and convenient, evaluation metrics that rely on pretrained classifiers (such as IS, FID,
nearest neighbors in feature space, and statistical tests in feature space) have significant drawbacks.
One might not have a pretrained classifier available for the dataset at hand, so classifiers trained on
other datasets are used. Given the well known challenges with neural network generalization (see
Section 17.4), the features of a classifier trained on images from one dataset might not be reliable
enough to provide a fine grained signal of quality for samples obtained from a model trained on a
different dataset. If the generative model is trained on the same dataset as the pre-trained classifier
but the model is not capturing the data distribution perfectly, we are presenting the pre-trained
classifier with out-of-distribution data and relying on its features to obtain score to evaluate our
models. Far from being purely theoretical concerns, these issues have been studied extensively and
have been shown to affect evaluation in practice [RV19; BS18].
20.4.6 Using model samples to train classifiers
Instead of using pretrained classifiers to evaluate samples, one can train a classifier on samples from
conditional generative models, and then see how good these classifiers are at classifying data. For
example, does adding synthetic (sampled) data to the real data help? This is closer to a reliable
evaluation of generative model samples, since ultimately, the performance of generative models is
dependent on the downstream task they are trained for. If used for semisupervised learning, one
should assess how much adding samples to a classifier dataset helps with test accuracy. If used for
model based reinforcement learning, one should assess how much the generative model helps with
agent performance. For examples of this approach, see e.g., [SSM18; SSA18; RV19; SS20b; Jor+22].
20.4.7 Assessing overfitting
Many of the metrics discussed so far capture the sample quality and diversity, but do not capture
overfitting to the training data. To capture overfitting, often a visual inspection is performed: a set
of samples is generated from the model and for each sample its closest K nearest neighbors in the
feature space of a pretrained classifier are obtained from the dataset. While this approach requires
manually assessing samples, it is a simple way to test whether a model is simply memorizing the
data. We show an example in Figure 20.12: since the model sample in the top left is quite different
than its neighbors from the dataset (remaining images), we can conclude the sample is not simply
memorised from the dataset. Similarly, sample diversity can be measured by approximating the
support of the learned distribution by looking for similar samples in a large sample pool — as in the
pigeonhole principle — but it is expensive and often requires manual human assessment[AZ17].
For likelihood-based models — such as variational autoencoders (Chapter 21), autoregressive
models (Chapter 22), and normalizing flows (Chapter 23) — we can assess memorization by seeing
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license780
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 20.12: Illustration of nearest neighbors in feature space: in the top left we have the query sample
generated using BigGAN, and the rest of the images are its nearest neighbors from the dataset. The nearest
neighbors search is done in the feature space of a pretrained classifier. From Figure 13 of [BDS18]. Used with
kind permission of Andy Brock.
how much the log-likelihood of a model changes when a sample is included in the model’s training
set or not [BW21].
20.4.8 Human evaluation
One approach to evaluate generative models is to use human evaluation, by presenting samples from
the model alongside samples from the data distribution, and ask human raters to compare the quality
of the samples [Zho+19b]. Human evaluation is a suitable metric if the model is used to create art or
other data for human display, or if reliable automated metrics are hard to obtain. However, human
evaluation can be difficult to standardize, hard to automate, and can be expensive or cumbersome to
set up.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 202321 Variational autoencoders
21.1 Introduction
In this chapter, we discuss generative models of the form
z ∼ pθ(z) (21.1)
x|z ∼ Expfam(x|dθ(z)) (21.2)
where p(z) is some kind of prior on the latent code z, dθ(z) is a deep neural network, known as the
decoder, and Expfam(x|η) is an exponential family distribution, such as a Gaussian or product of
Bernoullis. This is called a deep latent variable model or DLVM. When the prior is Gaussian
(as is often the case), this model is called a deep latent Gaussian model or DLGM.
Posterior inference (i.e., computing pθ(z|x)) is computationally intractable, as is computing the
marginal likelihood
pθ(x) = Z
pθ(x|z)pθ(z) dz (21.3)
Hence we need to resort to approximate inference. For most of this chapter, we will use amortized
inference, which we discussed in Section 10.1.5. This trains another model, qφ(z|x), called the
recognition network or inference network, simultaneously with the generative model to do
approximate posterior inference. This combination is called a variational autoencoder or VAE
[KW14; RMW14b; KW19a], since it can be thought of as a probabilistic version of a deterministic
autoencoder, discussed in Section 16.3.3.
In this chapter, we introduce the basic VAE, as well as some extensions. Note that the literature
on VAE-like methods is vast1
, so we will only discuss a small subset of the ideas that have been
explored.
21.2 VAE basics
In this section, we discuss the basics of variational autoencoders.782
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 21.1: Schematic illustration of a VAE. From a figure in [Haf18]. Used with kind permission of Danijar
Hafner.
21.2.1 Modeling assumptions
In the simplest setting, a VAE defines a generative model of the form
pθ(z, x) = pθ(z)pθ(x|z) (21.4)
where pθ(z) is usually a Gaussian, and pθ(x|z) is usually a product of exponential family distributions
(e.g., Gaussians or Bernoullis), with parameters computed by a neural network decoder, dθ(z). For
example, for binary observations, we can use
pθ(x|z) = Y
D
d=1
Ber(xd|σ(dθ(z)) (21.5)
In addition, a VAE fits a recognition model
qφ(z|x) = q(z|eφ(x)) ≈ pθ(z|x) (21.6)
to perform approximate posterior inference. Here qφ(z|x) is usually a Gaussian, with parameters
computed by a neural network encoder eφ(x):
qφ(z|x) = N (z|µ, diag(exp(ℓ))) (21.7)
(µ, ℓ) = eφ(x) (21.8)
where ℓ = log σ. The model can be thought of as encoding the input x into a stochastic latent
bottleneck z and then decoding it to approximately reconstruct the input, as shown in Figure 21.1.
The idea of training an inference network to “invert” a generative network, rather than running
an optimization algorithm to infer the latent code, is called amortized inference, and is discussed in
Section 10.1.5. This idea was first proposed in the Helmholtz machine [Day+95]. However, that
paper did not present a single unified objective function for inference and generation, but instead
used the wake-sleep (Section 10.6) method for training. By contrast, the VAE optimizes a variational
lower bound on the log-likelihood, which means that convergence to a locally optimal MLE of the
parameters is guaranteed.
We can use other approaches to fitting the DLGM (see e.g., [Hof17; DF19]). However, learning an
inference network to fit the DLGM is often faster and can have some regularization benefits (see e.g.,
[KP20]).2
1. For example, the website https://github.com/matthewvowels1/Awesome-VAEs lists over 900 papers.
2. Combining a generative model with an inference model in this way results in what has been called a “monference”,
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.2. VAE BASICS
21.2.2 Model fitting
We can fit a VAE using amortized stochastic variational inference, as we discuss in Section 10.2.1.6.
For example, suppose we use a VAE with a diagonal Bernoulli likelihood model, and a full covariance
Gaussian as our variational posterior. Then we can use the methods discussed in Section 10.2.1.2 to
derive the fitting algorith. See Algorithm 21.1 for the corresponding pseudocode.
Algorithm 21.1: Fitting a VAE with Bernoulli likelihood and full covariance Gaussian
posterior. Based on Algorithm 2 of [KW19a].
1 Initialize θ, φ
2 repeat
3 Sample x ∼ pD
4 Sample ǫ ∼ q0
5 (µ, log σ,L
′
) = eφ(x)
6 M = np.triu(np.ones(K), −1)
7 L = M⊙ L
′ + diag(σ)
8 z = Lǫ + µ
9 pp = dθ(z)
10 Llogqz = −
PK
k=1 
1
2
ǫ
2
k +
1
2
log(2π) + log σk

// from qφ(z|x) in Equation (10.47)
11 Llogpz = −
PK
k=1 
1
2
z
2
k +
1
2
log(2π)

// from pθ(z) in Equation (10.48)
12 Llogpx = −
PD
d=1 [xd log pd + (1 − xd) log(1 − pd)] // from pθ(x|z)
13 L = Llogpx + Llogpz − Llogqz
14 Update θ := θ − η∇θL
15 Update φ := φ − η∇φL
16 until converged
21.2.3 Comparison of VAEs and autoencoders
VAEs are very similar to deterministic autoencoders (AE). There are 2 main differences: in the AE,
the objective is the log likelihood of the reconstruction without any KL term; and in addition, the
encoding is deterministic, so the encoder network just needs to compute E [z|x] and not V [z|x]. In
view of these similarities, one can use the same codebase to implement both methods. However, it
is natural to wonder what the benefits and potential drawbacks of the VAE are compared to the
deterministic AE.
We shall answer this question by fitting both models to the CelebA dataset. Both models have the
same convolutional structure with the following number of hidden channels per convolutional layer in
the encoder: (32, 64, 128, 256, 512). The spatial size of each layer is as follows: (32, 16, 8, 4, 2). The
final 2 × 2 × 512 convolutional layer then gets reshaped and passed through a linear layer to generate
the mean and (marginal) variance of the stochastic latent vector, which has size 256. The structure
i.e., model-inference hybrid. See the blog by Jacob Andreas, http://blog.jacobandreas.net/monference.html, for
further discussion.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license784
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 21.2: Illustration of unconditional image generation using (V)AEs trained on CelebA. Row 1:
deterministic autoencoder. Row 2: β-VAE with β = 0.5. Row 3: VAE (with β = 1). Generated by
celeba_vae_ae_comparison.ipynb.
of the decoder is the mirror image of the decoder. Each model is trained for 5 epochs with a batch
size of 256, which takes about 20 minutes on a GPU.
The main advantage of a VAE over a deterministic autoencoder is that it defines a proper generative
model, that can create sensible-looking novel images by decoding prior samples z ∼ N (0, I). By
contrast, an autoencoder only knows how to decode latent codes derived from the training set, so
does poorly when fed random inputs. This is illustrated in Figure 21.2.
We can also use both models to reconstruct a given input image. In Figure 21.3, we see that both
AE and VAE can reconstruct the input images reasonably well, although the VAE reconstructions are
somewhat blurry, for reasons we discuss in Section 21.3.1. We can reduce the amount of blurriness
by scaling down the KL penalty term by a factor of β; this is known as the β-VAE, and is discussed
in more detail in Section 21.3.1.
21.2.4 VAEs optimize in an augmented space
In this section, we derive several alternative expressions for the ELBO which shed light on how VAEs
work.
First, let us define the joint generative distribution
pθ(x, z) = pθ(z)pθ(x|z) (21.9)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.2. VAE BASICS
Figure 21.3: Illustration of image reconstruction using (V)AEs trained and applied to CelebA. Row 1: original
images. Row 2: deterministic autoencoder. Row 3: β-VAE with β = 0.5. Row 4: VAE (with β = 1).
Generated by celeba_vae_ae_comparison.ipynb.
from which we can derive the generative data marginal
pθ(x) = Z
z
pθ(x, z)dz (21.10)
and the generative posterior
pθ(z|x) = pθ(x, z)/pθ(x) (21.11)
Let us also define the joint inference distribution
qD,φ(z, x) = pD(x)qφ(z|x) (21.12)
where
pD(x) = 1
N
X
N
n=1
δ(xn − x) (21.13)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license786
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
is the empirical distribution. From this we can derive the inference latent marginal, also called the
aggregated posterior:
qD,φ(z) = Z
x
qD,φ(x, z)dx (21.14)
and the inference likelihood
qD,φ(x|z) = qD,φ(x, z)/qD,φ(z) (21.15)
See Figure 21.4 for a visual illustration.
Having defined our terms, we can now derive various alternative versions of the ELBO, following
[ZSE19]. First note that the ELBO averaged over all the data is given by
Ł(θ, φ|D) = EpD(x)

Eqφ(z|x)
[log pθ(x|z)]
− EpD(x)
[DKL (qφ(z|x) k pθ(z))] (21.16)
= EqD,φ(x,z)
[log pθ(x|z) + log pθ(z) − log qφ(z|x)] (21.17)
= EqD,φ(x,z)

log pθ(x, z)
qD,φ(x, z)
+ log pD(x)

(21.18)
= −DKL (qD,φ(x, z) k pθ(x, z)) + EpD(x)
[log pD(x)] (21.19)
If we define c= to mean equal up to additive constants, we can rewrite the above as
Ł(θ, φ|D)
c= −DKL (qφ(x, z) k pθ(x, z)) (21.20)
c= −DKL (pD(x) k pθ(x)) − EpD(x)
[DKL (qφ(z|x) k pθ(z|x))] (21.21)
Thus maximizing the ELBO requires minimizing the two KL terms. The first KL term is minimized
by MLE, and the second KL term is minimized by fitting the true posterior. Thus if the posterior
family is limited, there may be a conflict between these objectives.
Finally, we note that the ELBO can also be written as
Ł(θ, φ|D)
c= −DKL (qD,φ(z) k pθ(z)) − EqD,φ(z)
[DKL (qφ(x|z) k pθ(x|z))] (21.22)
We see from Equation (21.22) that VAEs are trying to minimize the difference between the inference
marginal and generative prior, DKL (qφ(z) k pθ(z)), while simultaneously minimizing reconstruction
error, DKL (qφ(x|z) k pθ(x|z)) Since x is typically of much higher dimensionality than z, the latter
term usually dominates. Consequently, if there is a conflict between these two objectives (e.g., due to
limited modeling power), the VAE will favor reconstruction accuracy over posterior inference. Thus
the learned posterior may not be a very good approximation to the true posterior (see [ZSE19] for
further discussion).
21.3 VAE generalizations
In this section, we discuss some variants of the basic VAE model.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.3. VAE GENERALIZATIONS
Decoder: pθ(x|z)
Prior distribution: pθ(z)
Marginal: pθ(x)
x-space
z-space
Encoder: qφ(z|x)
Marginal: qφ(z)
Data distribution: qD(x)
ML objective = - DKL( qD(x) || pθ(x) ) 
 ELBO objective = - DKL( qD,φ(x,z) || pθ(x,z) )
qD,φ(x,z) = qD(x) qφ(z|x) pθ(x,z) = pθ(z) pθ(x|z)
Figure 21.4: The maximum likelihood (ML) objective can be viewed as the minimization of DKL (pD(x) k pθ(x)).
(Note: in the figure, pD(x) is denoted by qD(x).) The ELBO objective is minimization of
DKL (qD,φ(x, z) k pθ(x, z)), which upper bounds DKL (qD(x) k pθ(x)). From Figure 2.4 of [KW19a]. Used
with kind permission of Durk Kingma.
21.3.1 β-VAE
It is often the case that VAEs generate somewhat blurry images, as illustrated in Figure 21.3,
Figure 21.2 and Figure 20.9. This is not the case for models that optimize the exact likelihood, such
as pixelCNNs (Section 22.3.2) and flow models (Chapter 23). To see why VAEs are different, consider
the common case where the decoder is a Gaussian with fixed variance, so
log pθ(x|z) = −
1
2σ
2
||x − dθ(z)||2
2 + const (21.23)
Let eφ(x) = E [qφ(z|x)] be the encoding of x, and X (z) = {x : eφ(x) = z} be the set of inputs that
get mapped to z. For a fixed inference network, the optimal setting of the generator parameters,
when using squared reconstruction loss, is to ensure dθ(z) = E [x : x ∈ X (z)]. Thus the decoder
should predict the average of all inputs x that map to that z, resulting in blurry images.
We can solve this problem by increasing the expressive power of the posterior approximation
(avoiding the merging of distinct inputs into the same latent code), or of the generator (by adding
back information that is missing from the latent code), or both. However, an even simpler solution is
to reduce the penalty on the KL term, making the model closer to a deterministic autoencoder:
Lβ(θ, φ|x) = −Eqφ(z|x)
[log pθ(x|z)]
| {z }
LE
+β DKL (qφ(z|x) k pθ(z))
| {z }
LR
(21.24)
where LE is the reconstruction error (negative log likelihood), and LR is the KL regularizer. This is
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license788
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
called the β-VAE objective [Hig+17a]. If we set β = 1, we recover the objective used in standard
VAEs; if we set β = 0, we recover the objective used in standard autoencoders.
By varying β from 0 to infinity, we can reach different points on the rate distortion curve, as
discussed in Section 5.4.2. These points make different tradeoffs between reconstruction error (distor￾tion) and how much information is stored in the latents about the input (rate of the corresponding
code). By using β < 1, we store more bits about each input, and hence can reconstruct images in a
less blurry way. If we use β > 1, we get a more compressed representation.
21.3.1.1 Disentangled representations
One advantage of using β > 1 is that it encourages the learning of a latent representation that is
“disentangled”. Intuitively this means that each latent dimension represents a different factor of
variation in the input. This is often formalized in terms of the total correlation (Section 5.3.5.1),
which is defined as follows:
TC(z) = X
k
H (zk) − H (z) = DKL 
p(z) k
Y
k
pk(zk)
!
(21.25)
This is zero iff the components of z are all mutually independent, and hence disentangled. In [AS18],
they prove that using β > 1 will decrease the TC.
Unfortunately, in [Loc+18] they prove that nonlinear latent variable models are unidentifiable, and
therefore for any disentangled representation, there is an equivalent fully entangled representation
with exactly the same likelihood. Thus it is not possible to recover the correct latent representation
without choosing the appropriate inductive bias, via the encoder, decoder, prior, dataset, or learning
algorithm, i.e., merely adjusting β is not sufficient. See Section 32.4.1 for more discussion.
21.3.1.2 Connection with information bottleneck
In this section, we show that the β-VAE is an unsupervised version of the information bottleneck
(IB) objective from Section 5.6. If the input is x, the hidden bottleneck is z, and the target outputs
are x˜, then the unsupervised IB objective becomes
LUIB = β I(z; x) − I(z; x˜) (21.26)
= βEp(x,z)

log p(x, z)
p(x)p(z)

− Ep(z,x˜)

log p(z, x˜)
p(z)p(x˜)

(21.27)
where
p(x, z) = pD(x)p(z|x) (21.28)
p(z, x˜) = Z
pD(x)p(z|x)p(x˜|z)dx (21.29)
Intuitively, the objective in Equation (21.26) means we should pick a representation z that can
predict x˜ reliably, while not memorizing too much information about the input x. The tradeoff
parameter is controlled by β.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.3. VAE GENERALIZATIONS
From Equation (5.181), we have the following variational upper bound on this unsupervised
objective:
LUVIB = −EqD,φ(z,x)
[log pθ(x|z)] + βEpD(x)
[DKL (qφ(z|x) k pθ(z))] (21.30)
which matches Equation (21.24) when averaged over x.
21.3.2 InfoVAE
In Section 21.2.4, we discussed some drawbacks of the standard ELBO objective for training VAEs,
namely the tendency to ignore the latent code when the decoder is powerful (Section 21.4), and the
tendency to learn a poor posterior approximation due to the mismatch between the KL terms in
data space and latent space (Section 21.2.4). We can fix these problems to some degree by using a
generalized objective of the following form:
Ł(θ, φ|x) = −λDKL (qφ(z) k pθ(z)) − Eqφ(z)
[DKL (qφ(x|z) k pθ(x|z))] + α Iq(x; z) (21.31)
where α ≥ 0 controls how much we weight the mutual information Iq(x; z) between x and z, and
λ ≥ 0 controls the tradeoff between z-space KL and x-space KL. This is called the InfoVAE objective
[ZSE19]. If we set α = 0 and λ = 1, we recover the standard ELBO, as shown in Equation (21.22).
Unfortunately, the objective in Equation (21.31) cannot be computed as written, because of the
intractable MI term:
Iq(x; z) = Eqφ(x,z)

log qφ(x, z)
qφ(x)qφ(z)

= −Eqφ(x,z)

log qφ(z)
qφ(z|x)

(21.32)
However, using the fact that qφ(x|z) = pD(x)qφ(z|x)/qφ(z), we can rewrite the objective as follows:
Ł = Eqφ(x,z)

−λ log qφ(z)
pθ(z)
− log qφ(x|z)
pθ(x|z)
− α log qφ(z)
qφ(z|x)

(21.33)
= Eqφ(x,z)

log pθ(x|z) − log
qφ(z)
λ+α−1pD(x)
pθ(z)
λqφ(z|x)
α−1

(21.34)
= EpD(x)

Eqφ(z|x)
[log pθ(x|z)]
− (1 − α)EpD(x)
[DKL (qφ(z|x) k pθ(z))]
− (α + λ − 1)DKL (qφ(z) k pθ(z)) − EpD(x)
[log pD(x)] (21.35)
where the last term is a constant we can ignore. The first two terms can be optimized using the
reparameterization trick. Unfortunately, the last term requires computing qφ(z) = R
x
qφ(x, z)dx,
which is intractable. Fortunately, we can easily sample from this distribution, by sampling x ∼ pD(x)
and z ∼ qφ(z|x). Thus qφ(z) is an implicit probability model, similar to a GAN (see Chapter 26).
As long as we use a strict divergence, meaning D(q, p) = 0 iff q = p, then one can show that this
does not affect the optimality of the procedure. In particular, proposition 2 of [ZSE19] tells us the
following:
Theorem 1. Let X and Z be continuous spaces, and α < 1 (to bound the MI) and λ > 0. For any
fixed value of Iq(x; z), the approximate InfoVAE loss, with any strict divergence D(qφ(z), pθ(z)), is
globally optimized if pθ(x) = pD(x) and qφ(z|x) = pθ(z|x).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license790
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.3.2.1 Connection with MMD VAE
If we set α = 1, the InfoVAE objective simplifies to
Ł
c= EpD(x)

Eqφ(z|x)
[log pθ(x|z)]
− λDKL (qφ(z) k pθ(z)) (21.36)
The MMD VAE3
replaces the KL divergence in the above term with the (squared) maximum mean
discrepancy or MMD divergence defined in Section 2.7.3. (This is valid based on the above theorem.)
The advantage of this approach over standard InfoVAE is that the resulting objective is tractable. In
particular, if we set λ = 1 and swap the sign we get
L = EpD(x)

Eqφ(z|x)
[− log pθ(x|z)]
+ MMD(qφ(z), pθ(z)) (21.37)
As we discuss in Section 2.7.3, we can compute the MMD as follows:
MMD(p, q) = Ep(z),p(z′)
[K(z, z
′
)] + Eq(z),q(z′)
[K(z, z
′
)] − 2Ep(z),q(z′)
[K(z, z
′
)] (21.38)
where K() is some kernel function, such as the RBF kernel, K(z, z
′
) = exp(−
1
2σ2 ||z−z
′
||2
2
). Intuitively
the MMD measures the similarity (in latent space) between samples from the prior and samples from
the aggregated posterior.
In practice, we can implement the MMD objective by using the posterior predicted mean zn =
eφ(xn) for all B samples in the current minibatch, and comparing this to B random samples from
the N (0, I) prior.
If we use a Gaussian decoder with fixed variance, the negative log likelihood is just a squared error
term:
− log pθ(x|z) = ||x − dθ(z)||2
2
(21.39)
Thus the entire model is deterministic, and just predicts the means in latent space and visible space.
21.3.2.2 Connection with β-VAEs
If we set α = 0 and λ = 1, we get back the original ELBO. If λ > 0 is freely chosen, but we use
α = 1 − λ, we get the β-VAE.
21.3.2.3 Connection with adversarial autoencoders
If we set α = 1 and λ = 1, and D is chosen to be the Jensen-Shannon divergence (which can be
minimized by training a binary discriminator, as explained in Section 26.2.2), then we get a model
known as an adversarial autoencoder [Mak+15a].
21.3.3 Multimodal VAEs
It is possible to extend VAEs to create joint distributions over different kinds of variables, such as
images and text. This is sometimes called a multimodal VAE or MVAE. Let us assume there are
3. Proposed in https://ermongroup.github.io/blog/a-tutorial-on-mmd-variational-autoencoders/.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.3. VAE GENERALIZATIONS
z
x1 x2
(a)
…
PoE
x1
µ1 σ1
E1
µ0 σ0 µ2 σ2
x2
E2
µN σN
xN
EN
µ σ
z
(b)
…
PoE
µ0
missing
σ0 µ2 σ2
x2
x1 E2
µN σN
xN
EN
µ σ
z
(c)
Figure 21.5: Illustration of multi-modal VAE. (a) The generative model with N = 2 modalities. (b) The
product of experts (PoE) inference network is derived from N individual Gaussian experts Ei. µ0 and σ0 are
parameters of the prior. (c) If a modality is missing, we omit its contribution to the posterior. From Figure 1
of [WG18]. Used with kind permission of Mike Wu.
M modalities. We assume they are conditionally independent given the latent code, and hence the
generative model has the form
pθ(x1, . . . , xM, z) = p(z)
Y
M
m=1
pθ(xm|z) (21.40)
where we treat p(z) as a fixed prior. See Figure 21.5(a) for an illustration.
The standard ELBO is given by
Ł(θ, φ|X) = Eqφ(z|X)
"X
m
log pθ(xm|z)
#
− DKL (qφ(z|X) k p(z)) (21.41)
where X = (x1, . . . , xM) is the observed data. However, the different likelihood terms p(xm|z) may
have different dynamic ranges (e.g., Gaussian pdf for pixels, and categorical pmf for text), so we
introduce weight terms λm ≥ 0 for each likelihood. In addition, let β ≥ 0 control the amount of KL
regularization. This gives us a weighted version of the ELBO, as follows:
Ł(θ, φ|X) = Eqφ(z|X)
"X
m
λm log pθ(xm|z)
#
− βDKL (qφ(z|X) k p(z)) (21.42)
Often we don’t have a lot of paired (aligned) data from all M modalities. For example, we may
have a lot of images (modality 1), and a lot of text (modality 2), but very few (image, text) pairs.
So it is useful to generalize the loss so it fits the marginal distributions of subsets of the features. Let
Om = 1 if modality m is observed (i.e., xm is known), and let Om = 0 if it is missing or unobserved.
Let X = {xm : Om = 1} be the visible features. We now use the following objective:
Ł(θ, φ|X) = Eqφ(z|X)
" X
m:Om=1
λm log pθ(xm|z)
#
− βDKL (qφ(z|X) k p(z)) (21.43)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license792
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The key problem is how to compute the posterior qφ(z|X) given different subsets of features. In
general this can be hard, since the inference network is a discriminative model that assumes all
inputs are available. For example, if it is trained on (image, text) pairs, qφ(z|x1, x2), how can we
compute the posterior just given an image, qφ(z|x1), or just given text, qφ(z|x2)? (This issue arises
in general with VAE when we have missing inputs.)
Fortunately, based on our conditional independence assumption between the modalities, we can
compute the optimal form for qφ(z|X) given set of inputs by computing the exact posterior under
the model, which is given by
p(z|X) = p(z)p(x1, . . . , xM|z)
p(x1, . . . , xM)
=
p(z)
p(x1, . . . , xM)
Y
M
m=1
p(xm|z) (21.44)
=
p(z)
p(x1, . . . , xM)
Y
M
m=1
p(z|xm)p(xm)
p(z)
(21.45)
∝ p(z)
Y
M
m=1
p(z|xm)
p(z)
≈ p(z)
Y
M
m=1
q˜(z|xm) (21.46)
This can be viewed as a product of experts (Section 24.1.1), where each q˜(z|xm) is an “expert” for
the m’th modality, and p(z) is the prior. We can compute the above posterior for any subset of
modalities for which we have data by modifying the product over m. If we use Gaussian distributions
for the prior p(z) = N (z|µ0
, Λ
−1
0
) and marginal posterior ratio q˜(z|xm) = N (z|µm, Λ
−1
m ), then we
can compute the product of Gaussians using the result from Equation (2.154):
Y
M
m=0
N (z|µm, Λ
−1
m ) ∝ N (z|µ, Σ), Σ = (X
m
Λm)
−1
, µ = Σ(
X
m
Λmµm) (21.47)
Thus the overall posterior precision is the sum of individual expert posterior precisions, and the
overall posterior mean is the precision weighted average of the individual expert posterior means.
See Figure 21.5(b) for an illustration. For a linear Gaussian (factor analysis) model, we can ensure
q(z|xm) = p(z|xm), in which case the above solution is the exact posterior [WN18], but in general it
will be an approximation.
We need to train the individual expert recognition models q(z|xm) as well as the joint model
q(z|X), so the model knows what to do with fully observed as well as partially observed inputs at
test time. In [Ved+18], they propose a somewhat complex “triple ELBO” objective. In [WG18], they
propose the simpler approach of optimizing the ELBO for the fully observed feature vector, all the
marginals, and a set of J randomly chosen joint modalities:
Ł(θ, φ|X) = Ł(θ, φ|()x1, . . . , xM) + X
M
m=1
Ł(θ, φ|xm) + X
j∈J
Ł(θ, φ|Xj ) (21.48)
This generalizes nicely to the semi-supervised setting, in which we only have a few aligned
(“labeled”) examples from the joint, but have many unaligned (“unlabeled”) examples from the
individual marginals. See Figure 21.5(c) for an illustration.
Note that the above scheme can only handle the case of a fixed number of missingness patterns;
we can generalize to allow for arbitrary missingness as discussed in [CNW20]. (See also Section 3.11
for a more general discussion of missing data.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.3. VAE GENERALIZATIONS
21.3.4 Semisupervised VAEs
In this section, we discuss how to extend VAEs to the semi-supervised learning setting in which
we have both labeled data, DL = {(xn, yn)}, and unlabeled data, DU = {(xn)}. We focus on the
M2 model, proposed in [Kin+14a].
The generative model has the following form:
pθ(x, y) = pθ(y)pθ(x|y) = pθ(y)
Z
pθ(x|y, z)pθ(z)dz (21.49)
where z is a latent variable, pθ(z) = N (z|0, I) is the latent prior, pθ(y) = Cat(y|π) the label prior,
and pθ(x|y, z) = p(x|fθ(y, z)) is the likelihood, such as a Gaussian, with parameters computed by f
(a deep neural network). The main innovation of this approach is to assume that data is generated
according to both a latent class variable y as well as the continuous latent variable z. The class
variable y is observed for labeled data and unobserved for unlabled data.
To compute the likelihood for the labeled data, pθ(x, y), we need to marginalize over z, which we
can do by using an inference network of the form
qφ(z|y, x) = N (z|µφ(y, x), diag(σφ(y, x)) (21.50)
We then use the following variational lower bound
log pθ(x, y) ≥ Eqφ(z|x,y)
[log pθ(x|y, z) + log pθ(y) + log pθ(z) − log qφ(z|x, y)] = −L(x, y) (21.51)
as is standard for VAEs (see Section 21.2). The only difference is that we observe two kinds of data:
x and y.
To compute the likelihood for the unlabeled data, pθ(x), we need to marginalize over z and y,
which we can do by using an inference network of the form
qφ(z, y|x) = qφ(z|x)qφ(y|x) (21.52)
qφ(z|x) = N (z|µφ(x), diag(σφ(x)) (21.53)
qφ(y|x) = Cat(y|πφ(x)) (21.54)
Note that qφ(y|x) acts like a discriminative classifier, that imputes the missing labels. We then use
the following variational lower bound:
log pθ(x) ≥ Eqφ(z,y|x)
[log pθ(x|y, z) + log pθ(y) + log pθ(z) − log qφ(z, y|x)] (21.55)
= −
X
y
qφ(y|x)L(x, y) + H (qφ(y|x)) = −U(x) (21.56)
Note that the discriminative classifier qφ(y|x) is only used to compute the log-likelihood of the
unlabeled data, which is undesirable. We can therefore add an extra classification loss on the
supervised data, to get the following overall objective function:
L(θ) = E(x,y)∼DL
[L(x, y)] + Ex∼DU
[U(x)] + αE(x,y)∼DL
[− log qφ(y|x)] (21.57)
where DL is the labeled data, DU is the unlabeled data, and α is a hyperparameter that controls the
relative weight of generative and discriminative learning.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license794
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Decoder
RNN
Decoder
RNN
Decoder
RNN
Decoder
RNN
z
Decoder
RNN
H Forward
Encoder
RNN
H→ 0
X 
Forward
Encoder
RNN
X 
Forward
Encoder
RNN
Forward
Encoder
RNN
Forward
Encoder
RNN
y y y y y
Backward
Encoder
RNN
Backward
Encoder
RNN
Backward
Encoder
RNN
Backward
Encoder
RNN
Backward
Encoder
RNN
H
μ
σ
Normal(0, 1)
sample
z 
tanh
GMM, softmax
sample
z z z z
τ
GMM, softmax
sample
τ
GMM, softmax
sample
τ
GMM, softmax
sample
τ
GMM, softmax
sample
τ
Latent Vector z encoded from Input Sequence X
Output Sequence X' conditionally generated from z
B
H1
B
H2
B
H HNs-1
B
Ns Ns-1 X Ns-2 X 2 X 1
X X 1 2 X 3 X Ns-1 X Ns
H H← 0
F
H1
F
H2
F
H0
F
HNs-1
F
X X 0 1 X 2 X Nmax-2 X Nmax-1
' ' ' '
X 1 X 2 X 3 X Nmax-1
' ' ' '
0 1 2 Nmax-2 Nmax-1
H0 H1 H2 HNs-1
X Nmax
'
Decoder
RNN
Decoder
RNN
Decoder
RNN
Decoder
RNN
z
Decoder
RNN
h Backward
Encoder
RNN
h← 0
S 
Backward
Encoder
RNN
S 
Backward
Encoder
RNN
Backward 
Encoder
RNN
Backward
Encoder
RNN
y y y y y
Forward
Encoder
RNN
Forward
Encoder
RNN
Forward
Encoder
RNN
Forward
Encoder
RNN
Forward
Encoder
RNN
h
σ
N(0, I)
sample
z 
tanh
GMM, softmax
sample
z z z z
τ
GMM, softmax
sample
τ
GMM, softmax
sample
τ
GMM, softmax
sample
τ
GMM, softmax
sample
τ
Latent Vector z encoded
from Input Sequence S
Output Sequence S' conditionally generated from z
B
h 1
B
h 2
B
hNs-1
B
Ns Ns-1 S Ns-2 S 2 S 1
S S 1 2 S 3 S Ns-1 S Ns
h h→ 0
F
h 1
F
h 2
F
hNs-1
F
S S 0 1 S 2 S Nmax-2 S Nmax-1
S 1 S 2 S 3 S Nmax-1
' ' ' '
1 2 3 Nmax-1 Nmax
h 0 h 1 h 2 hNs-1
S Nmax
'
μ
' ' ' '
Figure 21.6: Illustration of a VAE with a bidirectional RNN encoder and a unidirectional RNN decoder. The
output generator can use a GMM and/or softmax distribution. From Figure 2 of [HE18]. Used with kind
permission of David Ha.
21.3.5 VAEs with sequential encoders/decoders
In this section, we discuss VAEs for sequential data, such as text and biosequences, in which the
data x is a variable-length sequence, but we have a fixed-sized latent variable z ∈ R
K. (We consider
the more general case in which z is a variable-length sequence of latents — known as sequential
VAE or dynamic VAE — in Section 29.13.) All we have to do is modify the decoder p(x|z) and
encoder q(z|x) to work with sequences.
21.3.5.1 Models
If we use an RNN for the encoder and decoder of a VAE, we get a model which is called a VAE-RNN,
as proposed in [Bow+16a]. In more detail, the generative model is p(z, x1:T ) = p(z)RNN(x1:T |z),
where z can be injected as the initial state of the RNN, or as an input to every time step. The
inference model is q(z|x1:T ) = N (z|µ(h), Σ(h)), where h = [h→
T
, h←
1
] is the output of a bidirectional
RNN applied to x1:T . See Figure 21.6 for an illustration.
More recently, people have tried to combine transformers with VAEs. For example, in the Optimus
model of [Li+20], they use a BERT model for the encoder. In more detail, the encoder q(z|x) is
derived from the embedding vector associated with a dummy token corresponding to the “class label”
which is appended to the input sequence x. The decoder is a standard autoregressive model (similar
to GPT), with one additional input, namely the latent vector z. They consider two ways of injecting
the latent vector. The simplest approach is to add z to the embedding layer of every token in the
decoding step, by defining h
′
i = hi + Wz, where hi ∈ R
H is the original embedding for the i’th
token, and W ∈ R
H×K is a decoding matrix, where K is the size of the latent vector. However, they
get better results in their experiments by letting all the layers of the decoder attend to the latent
code z. An easy way to do this is to define the memory vector hm = Wz, where W ∈ R
LH×K,
where L is the number of layers in the decoder, and then to append hm ∈ R
L×H to all the other
embeddings at each layer.
An alternative approach, known as transformer VAE, was proposed in [Gre20]. This model uses
a funnel transformer [Dai+20b] as the encoder, and the T5 [Raf+20a] conditional transformer for
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.3. VAE GENERALIZATIONS
he was silent for a long moment .
he was silent for a moment .
it was quiet for a moment .
it was dark and cold .
there was a pause .
it was my turn .
(a)
i went to the store to buy some groceries .
i store to buy some groceries .
i were to buy any groceries .
horses are to buy any groceries .
horses are to buy any animal .
horses the favorite any animal .
horses the favorite favorite animal .
horses are my favorite animal .
(b)
Figure 21.7: (a) Samples from the latent space of a VAE text model, as we interpolate between two sentences
(on first and last line). Note that the intermediate sentences are grammatical, and semantically related to
their neighbors. From Table 8 of [Bow+16b]. (b) Same as (a), but now using a deterministic autoencoder
(with the same RNN encoder and decoder). From Table 1 of [Bow+16b]. Used with kind permission of Sam
Bowman.
the decoder. In addition, it uses an MMD VAE (Section 21.3.2.1) to avoid posterior collapse.
21.3.5.2 Applications
In this section, we discuss some applications of VAEs to sequence data.
Text
In [Bow+16b], they apply the VAE-RNN model to natural language sentences. (See also [MB16;
SSB17] for related work.) Although this does not improve performance in terms of the standard
perplexity measures (predicting the next word given the previous words), it does provide a way to
infer a semantic representation of the sentence. This can then be used for latent space interpolation,
as discussed in Section 20.3.5. The results of doing this with the VAE-RNN are illustrated in
Figure 21.7a. (Similar results are shown in [Li+20], using a VAE-transformer.) By contrast, if we use
a standard deterministic autoencoder, with the same RNN encoder and decoder networks, we learn
a much less meaningful space, as illustrated in Figure 21.7b. The reason is that the deterministic
autoencoder has “holes” in its latent space, which get decoded to nonsensical outputs.
However, because RNNs (and transformers) are powerful decoders, we need to address the problem
of posterior collapse, which we discuss in Section 21.4. One common way to avoid this problem is to
use KL annealing, but a more effective method is to use the InfoVAE method of Section 21.3.2, which
includes adversarial autoencoders (used in [She+20] with an RNN decoder) and MMD autoencoders
(used in [Gre20] with a transformer decoder).
Sketches
In [HE18], they apply the VAE-RNN model to generate sketches (line drawings) of various animals
and hand-written characters. They call their model sketch-rnn. The training data records the
sequence of (x, y) pen positions, as well as whether the pen was touching the paper or not. The
emission model used a GMM for the real-valued location offsets, and a categorical softmax distribution
for the discrete state.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license796
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 21.8: Conditional generation of cats from sketch-RNN model. We increase the temperature parameter
from left to right. From Figure 5 of [HE18]. Used with kind permission of David Ha.
Figure 21.8 shows some samples from various class-conditional models. We vary the temperature
parameter τ of the emission model to control the stochasticity of the generator. (More precisely, we
multiply the GMM variances by τ , and divide the discrete probabilities by τ before renormalizing.)
When the temperature is low, the model tries to reconstruct the input as closely as possible. However,
when the input is untypical of the training set (e.g., a cat with three eyes, or a toothbrush), the
reconstruction is “regularized” towards a canonical cat with two eyes, while still keeping some features
of the input.
Molecular design
In [GB+18], they use VAE-RNNs to model molecular graph structure, represented as a string using
the SMILES representation.4
It is also possible to learn a mapping from the latent space to some
scalar quantity of interest, such as the solubility or drug efficacy of a molecule. We can then perform
gradient-based optimization in the continuous latent space to try to generate new graphs which
maximize this quantity. See Figure 21.9 for a sketch of this approach.
The main problem is to ensure that points in latent space decode to valid strings/molecules. There
are various solutions to this, including using a grammar VAE, where the RNN decoder is replaced
by a stochastic context free grammar. See [KPHL17] for details.
21.4 Avoiding posterior collapse
If the decoder pθ(x|z) is sufficiently powerful (e.g., a pixel CNN, or an RNN for text), then the VAE
does not need to use the latent code z for anything. This is called posterior collapse or variational
4. See https://en.wikipedia.org/wiki/Simplified_molecular-input_line-entry_system.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.4. AVOIDING POSTERIOR COLLAPSE
Figure 21.9: Application of VAE-RNN to molecule design. (a) The VAE-RNN model is trained on a sequence
representation of molecules known as SMILES. We can fit an MLP to map from the latent space to properties
of the molecule, such as its “fitness” f(z). (b) We can perform gradient ascent in f(z) space, and then decode
the result to a new molecule with high fitness. From Figure 1 of [GB+18]. Used with kind permission of
Rafael Gomez-Bombarelli.
overpruning (see e.g., [Che+17b; Ale+18; Hus17a; Phu+18; TT17; Yeu+17; Luc+19; DWW19;
WBC21]). To see why this happens, consider Equation (21.21). If there exists a parameter setting for
the generator θ
∗
such that pθ∗ (x|z) = pD(x) for every z, then we can make DKL (pD(x) k pθ(x)) = 0.
Since the generator is independent of the latent code, we have pθ(z|x) = pθ(z). The prior pθ(z) is
usually a simple distribution, such as a Gaussian, so we can find a setting of the inference parameters
so that qφ∗ (z|x) = pθ(z), which ensures DKL (qφ(z|x) k pθ(z|x)) = 0. Thus we have succesfully
maximized the ELBO, but we have not learned any useful latent representation of the data, which is
one of the goals of latent variable modeling.5 We discuss some solutions to posterior collapse below.
21.4.1 KL annealing
A common approach to solving this problem, proposed in [Bow+16a], is to use KL annealing, in
which the KL penalty term in the ELBO is scaled by β, which is increased from 0.0 (corresponding
to an autoencoder) to 1.0 (which corresponds to standard MLE training). (Note that, by contrast,
the β-VAE model in Section 21.3.1 uses β > 1.)
KL annealing can work well, but requires tuning the schedule for β. A standard practice [Fu+19]
is to use cyclical annealing, which repeats the process of increasing β multiple times. This ensures
the progressive learning of more meaningful latent codes, by leveraging good representations learned
in a previous cycle as a way to warmstart the optimization.
5. Note that [Luc+19; DWW20] show that posterior collapse can also happen in linear VAE models, where the ELBO
corresponds to the exact marginal likelihood, so the problem is not only due to powerful (nonlinear) decoders, but is
also related to spurious local maxima in the objective.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license798
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.4.2 Lower bounding the rate
An alternative approach is to stick with the original unmodified ELBO objective, but to prevent the
rate (i.e., the DKL (q k p) term) from collapsing to 0, by limiting the flexibility of q. For example,
[XD18; Dav+18] use a von Mises-Fisher (Section 2.2.5.3) prior and posterior, instead of a Gaussian,
and they constrain the posterior to have a fixed concentration, q(z|x) = vMF(z|µ(x), κ). Here
the parameter κ controls the rate of the code. The δ-VAE method [Oor+19] uses a Gaussian
autoregressive prior and a diagonal Gaussian posterior. We can ensure the rate is at least δ by
adjusting the regression parameter of the AR prior.
21.4.3 Free bits
In this section, we discuss the method of free bits [Kin+16], which is another way of lower bounding
the rate. To explain this, consider a fully factorized posterior in which the KL penalty has the form
LR =
X
i
DKL (qφ(zi
|x) k pθ(zi)) (21.58)
where zi
is the i’th dimension of z. We can replace this with a hinge loss, that will give up driving
down the KL for dimensions that are already beneath a target compression rate λ:
L
′
R =
X
i
max(λ, DKL (qφ(zi
|x) k pθ(zi))) (21.59)
Thus the bits where the KL is sufficiently small “are free”, since the model does not have to “pay” to
encode them according to the prior.
21.4.4 Adding skip connections
One reason for latent variable collapse is that the latent variables z are not sufficiently “connected to”
the observed data x. One simple solution is to modify the architecture of the generative model by
adding skip connections, similar to a residual network (Section 16.2.4), as shown in Figure 21.10.
This is called a skip-VAE [Die+19a].
21.4.5 Improved variational inference
The posterior collapse problem is caused in part by the poor approximation to the posterior. In
[He+19], they proposed to keep the model and VAE objective unchanged, but to more aggressively
update the inference network before each step of generative model fitting. This enables the inference
network to capture the current true posterior more faithfully, which will encourage the generator to
use the latent codes when it is useful to do so.
However, this only addresses the part of posterior collapse that is due to the amortization gap
[CLD18], rather than the more fundamental problem of variational pruning, in which the KL term
penalizes the model if its posterior deviates too far from the prior, which is often too simple to match
the aggregated posterior.
Another way to ameliorate variational pruning is to use lower bounds that are tighter than the
vanilla ELBO (Section 10.5.1), or more accurate posterior approximations (Section 10.4), or more
accurate (hierarchical) generative models (Section 21.5).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.5. VAES WITH HIERARCHICAL STRUCTURE
Figure 21.10: (a) VAE. (b) Skip-VAE. From Figure 1 of [Die+19a]. Used with kind permission of Adji Dieng.
21.4.6 Alternative objectives
An alternative to the above methods is to replace the ELBO objective with other objectives, such as
the InfoVAE objective discussed in Section 21.3.2, which includes adversarial autoencoders and MMD
autoencoders as special cases. The InfoVAE objective includes a term to explicitly enforce non-zero
mutual information between x and z, which effectively solves the problem of posterior collapse.
21.5 VAEs with hierarchical structure
We define a hierarchical VAE or HVAE, with L stochastic layers, to be the following generative
model:6
pθ(x, z1:L) = pθ(zL)
" Y
1
l=L−1
pθ(zl
|zl+1)
#
pθ(x|z1) (21.60)
We can improve on the above model by making it non-Markovian, i.e., letting each zl depend on all
the higher level stochastic variables, zl+1:L, not just the preceeding level, i.e.,
pθ(x, z) = pθ(zL)
" Y
1
l=L−1
pθ(zl
|zl+1:L)
#
pθ(x|z1:L) (21.61)
Note that the likelihood is now pθ(x|z1:L) instead of just pθ(x|z1). This is analogous to adding skip
connections from all preceeding variables to all their children. It is easy to implement this by using
a deterministic “backbone” of residual connections, that accumulates all stochastic decisions, and
propagates them down the chain, as illustrated in Figure 21.11(left). We discuss how to perform
inference and learning in such models below.
6. There is a split in the literature about whether to label the top level as zL or z1. We adopt the former convention,
since we view lower numbered layers, such as z1, as being “closer to the data”, and higher numbered layers, such as zL,
as being “more abstract”.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license800
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
+
+
+
sample
sample
sample
+
h
r
+
r
sample
sample
r
r
r
+
+
bottom-up model
shared top-down model
h
r
r
r
shared top-down model
Figure 21.11: Hierarchical VAEs with 3 stochastic layers. Left: generative model. Right: inference network.
Diamond is a residual network, ⊕ is feature combination (e.g., concatenation), and h is a trainable parameter.
We first do bottom-up inference, by propagating x up to z3 to compute z
s
3 ∼ qφ(z3|x), and then we perform
top-down inference by computing z
s
2 ∼ qφ(z2|x, z
s
3) and then z
s
1 ∼ qφ(z1|x, z
s
2:3). From Figure 2 of [VK20a].
Used with kind permission of Arash Vahdat.
21.5.1 Bottom-up vs top-down inference
To perform inference in a hierarchical VAE, we could use a bottom-up inference model of the
form
qφ(z|x) = qφ(z1|x)
Y
L
l=2
qφ(zl
|x, z1:l−1) (21.62)
However, a better approach is to use a top-down inference model of the form
qφ(z|x) = qφ(zL|x)
Y
1
l=L−1
qφ(zl
|x, zl+1:L) (21.63)
Inference for zl combines bottom-up information from x with top-down information from higher
layers, z>l = zl+1:L. See Figure 21.11(right) for an illustration.7
7. Note that it is also possible to have a stochastic bottom-up encoder and a stochastic top-down encoder, as discussed
in the BIVA paper [Maa+19]. (BIVA stands for “bidirectional-inference variational autoencoder”.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.5. VAES WITH HIERARCHICAL STRUCTURE
With the above model, the ELBO can be written as follows (using the chain rule for KL):
Ł(θ, φ|x) = Eqφ(z|x)
[log pθ(x|z)] − DKL (qφ(zL|x) k pθ(zL)) (21.64)
−
X
1
l=L−1
Eqφ(z>l|x)
[DKL (qφ(zl
|x, z>l) k pθ(zl
|z>l))] (21.65)
where
qφ(z>l|x) = Y
L
i=l+1
qφ(zi
|x, z>i) (21.66)
is the approximate posterior above layer l (i.e., the parents of zl).
The reason the top-down inference model is better is that it more closely approximates the true
posterior of a given layer, which is given by
pθ(zl
|x, zl+1:L) ∝ pθ(zl
|zl+1:L)pθ(x|zl
, zl+1:L) (21.67)
Thus the posterior combines the top-down prior term pθ(zl
|zl+1:L) with the bottom-up likelihood
term pθ(x|zl
, zl+1:L). We can approximate this posterior by defining
qφ(zl
|x, zl+1:L) ∝ pθ(zl
|zl+1:L)˜qφ(zl
|x, zl+1:L) (21.68)
where q˜φ(zl
|x, zl+1:L) is a learned Gaussian approximation to the bottom-up likelihood. If both prior
and likelihood are Gaussian, we can compute this product in closed form, as proposed in the ladder
network paper [Sn+16; Søn+16].8 A more flexible approach is to let qφ(zl
|x, zl+1:L) be learned,
but to force it to share some of its parameters with the learned prior pθ(zl
|zl+1:L), as proposed in
[Kin+16]. This reduces the number of parameters in the model, and ensures that the posterior and
prior remain somewhat close.
21.5.2 Example: very deep VAE
There have been many papers exploring different kinds of HVAE models (see e.g., [Kin+16; Sn+16;
Chi21a; VK20a; Maa+19]), and we do not have space to discuss them all. Here we focus on the
“very deep VAE” or VD-VAE model of [Chi21a], since it is simple but yields state of the art
results (at the time of writing).
The architecture is a simple convolutional VAE with bidrectional inference, as shown in Figure 21.12.
For each layer, the prior and posterior are diagonal Gaussians. The author found that nearest-neighbor
upsampling (in the decoder) worked much better than transposed convolution, and avoided posterior
collapse. This enabled training with the vanilla VAE objective, without needing any of the tricks
discussed in Section 21.5.4.
The low-resolution latents (at the top of the hierarchy) capture a lot of the global structure of
each image; the remaining high-resolution latents are just used to fill in details, that make the image
look more realistic, and improve the likelihood. This suggests the model could be useful for lossy
8. The term “ladder network” arises from the horizontal “rungs” in Figure 21.11(right). Note that a similar idea was
independently proposed in [Sal16].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license802
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
pool
res block
res block
res block
Input
Bottom-up path Top-down path
Reconstruction
unpool
topdown block
topdown block
topdown block
topdown block
res block
conv 1x1
conv 1x1
(input)
conv 3x3
conv 3x3
(input)
conv 1x1
concat
conv 3x3
conv 3x3
conv 1x1
conv 1x1
conv 3x3
conv 3x3
conv 1x1
z
conv 1x1
q(z | x)
p(z)
(from bottom-up)
res block
Figure 21.12: The top-down encoder used by the hierarchical VAE in [Chi21a]. Each convolution is preceded
by the GELU nonlinearity. The model uses average pooling and nearest-neighbor upsampling for the pool and
unpool layers. The posterior qφ and prior pθ are diagonal Gaussians. From Figure 3 of [Chi21a]. Used with
kind permission of Rewon Child.
Figure 21.13: Samples from a VDVAE model (trained on FFHQ dataset) from different levels of the hierarchy.
From Figure 1 of [Chi21a]. Used with kind permission of Rewon Child.
compression, since a lot of the low-level details can be drawn from the prior (i.e., “hallucinated”),
rather than having to be sent by the encoder.
We can also use the model for unconditional sampling at multiple resolutions. This is illustrated
in Figure 21.13, using a model with 78 stochastic layers trained on the FFHQ-256 dataset.9
.
21.5.3 Connection with autoregressive models
Until recently, most hierarchical VAEs only had a small number of stochastic layers. Consequently
the images they generated have not looked as good, or had as high likelihoods, as images produced
by other models, such as the autoregressive PixelCNN model (see Section 22.3.2). However, by
endowing VAEs with many more stochastic layers, it is possible to outperform AR models in terms of
9. This is a 2562 version of the Flickr-Faces High Quality dataset from https://github.com/NVlabs/ffhq-dataset,
which has 80k images at 10242
resoution.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.5. VAES WITH HIERARCHICAL STRUCTURE
Input
Latent variables are identical to observed variables
Output Input
Latent variables allow for parallel generation
Output
Figure 21.14: Left: a hierarchical VAE which emulates an autoregressive model using an identify encoder,
autoregressive prior, and identity decoder. Right: a hierarchical VAE with a 2 layer hierarchical latent code.
The bottom hidden nodes (black) are conditionally independent given the top layer. From Figure 2 of [Chi21a].
Used with kind permission of Rewon Child.
likelihood and sample quality, while using fewer parameters and much less computing power [Chi21a;
VK20a; Maa+19].
To see why this is possible, note that we can represent any AR model as a degenerate VAE, as
shown in Figure 21.14(left). The idea is simple: the encoder copies the input into latent space
by setting z1:D = x1:D (so qφ(zi = xi
|z>i, x) = 1), then the model learns an autoregressive prior
pθ(z1:D) = Q
d
p(zd|z1:d−1), and finally the likelihood function just copies the latent vector to output
space, so pθ(xi = zi
|z) = 1. Since the encoder computes the exact (albeit degenerate) posterior, we
have qφ(z|x) = pθ(z|x), so the ELBO is tight and reduces to the log likelihood,
log pθ(x) = log pθ(z) = X
d
log pθ(xd|x<d) (21.69)
Thus we can emulate any AR model with a VAE providing it has at least D stochastic layers, where
D is the dimensionality of the observed data.
In practice, data usually lives in a lower-dimensional manifold (see e.g., [DW19]), which can allow
for a much more compact latent code. For example, Figure 21.14(right) shows a hierarchical code
in which the latent factors at the lower level are conditionally independent given the higher level,
and hence can be generated in parallel. Such a tree-like structure can enable sample generation in
O(log D) time, whereas an autoregressive model always takes O(D) time. (Recall that for an image
D is the number of pixels, so it grows quadratically with image resolution. For example, even a tiny
32 × 32 image has D = 3072.)
In addition to speed, hierarchical models also require many fewer parameters than “flat” models.
The typical architecture used for generating images is a multi-scale approach: the model starts from
a small, spatially arranged set of latent variables, and at each subsequent layer, the spatial resolution
is increased (usually by a factor of 2). This allows the high level to capture global, long-range
correlations (e.g., the symmetry of a face, or overall skin tone), while letting lower levels capture
fine-grained details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license804
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.5.4 Variational pruning
A common problem with hierarchical VAEs is that the higher level latent layers are often ignored, so
the model does not learn interesting high level semantics. This is caused by variational pruning.
This problem is analogous to the issue of latent variable collapse, which we discussed in Section 21.4.
A common heuristic to mitigate this problem is to use KL balancing coefficients [Che+17b], to
ensure that an equal amount of information is encoded in each layer. That is, we use the following
penalty:
X
L
l=1
γlEqφ(z>l|x)
[DKL (qφ(zl
|x, z>l) k pθ(zl
|z>l))] (21.70)
The balancing term γl
is set to a small value when the KL penalty is small (on the current minibatch),
to encourage use of that layer, and is set to a large value when the KL term is large. (This is only
done during the “warm up period”.) Concretely, [VK20a] proposes to set the coefficients γl to be
proportional to the size of the layer, sl
, and the average KL loss:
γl ∝ slEx∼B 
Eqφ(z>l|x)
[DKL (qφ(zl
|x, z>l) k pθ(zl
|z>l))]
(21.71)
where B is the current minibatch.
21.5.5 Other optimization difficulties
A common problem when training (hierarchical) VAEs is that the loss can become unstable. The
main reason for this is that the KL term is unbounded (can become infinitely large). In [Chi21a], they
tackle the problem in two ways. First, ensure the initial random weights of the final convolutional
layer in each residual bottleneck block get scaled by 1/
√
L. Second, skip an update step if the norm
of the gradient of the loss exceeds some threshold.
In the Nouveau VAE method of [VK20a], they use some more complicated measures to ensure
stability. First, they use batch normalization, but with various tweaks. Second, they use spectral
regularization for the encoder. Specifically they add the penalty β
P
i
λi
, where λi
is the largest
singular value of the i’th convolutional layer (estimated using a single power iteration step), and
β ≥ 0 is a tuning parameter. Third, they use inverse autoregressive flows (Section 23.2.4.3) in each
layer, instead of a diagonal Gaussian approximation. Fourth, they represent the posterior using a
residual representation. In particular, let us assume the prior for the i’th variable in layer l is
pθ(z
i
l
|z>l) = N (z
i
l
|µi(z>l), σi(z>l)) (21.72)
They propose the following posterior approximation:
qφ(z
i
l
|x, z>l) = N
￾
z
i
l
|µi(z>l) + ∆µi(z>l, x), σi(z>l) · ∆σi(z>l, x)

(21.73)
where the ∆ terms are the relative changes computed by the encoder. The corresponding KL penalty
reduces to the following (dropping the l subscript for brevity):
DKL ￾
qφ(z
i
|x, z>l) k pθ(z
i
|z>l)

=
1
2

∆µ
2
i
σ
2
i
+ ∆σ
2
i − log ∆σ
2
i − 1

(21.74)
So as long as σi
is bounded from below, the KL term can be easily controlled just by adjusting the
encoder parameters.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 201
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.6. VECTOR QUANTIZATION VAE
Figure 21.15: Autoencoder for MNIST using 256 binary latents. Top row: input images. Middle
row: reconstruction. Bottom row: latent code, reshaped to a 16 × 16 image. Generated by quan￾tized_autoencoder_mnist.ipynb.
21.6 Vector quantization VAE
In this section, we describe VQ-VAE, which stands for “vector quantized VAE” [OVK17; ROV19].
This is like a standard VAE except it uses a set of discrete latent variables.
21.6.1 Autoencoder with binary code
The simplest approach to the problem is to construct a standard VAE, but to add a discretization
layer at the end of the encoder, ze(x) ∈ {0, . . . , S − 1}
K, where S is the number of states, and K
is the number of discrete latents. For example, we can binarize the latent vector (using S = 2) by
clipping z to lie in {0, 1}
K. This can be useful for data compression (see e.g., [BLS17]).
Suppose we assume the prior over the latent codes is uniform. Since the encoder is deterministic,
the KL divergence reduces to a constant, equal to log K. This avoids the problem with posterior
collapse (Section 21.4). Unfortunately, the discontinuous quantization operation of the encoder
prohibits the direct use of gradient based optimization. The solution proposed in [OVK17] is to use
the straight-through estimator, which we discuss in Section 6.3.8. We show a simple example of this
approach in Figure 21.15, where we use a Gaussian likelihood, so the loss function has the form
L = ||x − d(e(x))||2
2
(21.75)
where e(x) ∈ {0, 1}
K is the encoder, and d(z) ∈ R
28×28 is the decoder.
21.6.2 VQ-VAE model
We can get a more expressive model by using a 3d tensor of discrete latents, z ∈ R
H×W×K, where
K is the number of discrete values per latent variable. Rather than just binarizing the continuous
vector ze(x)ij , we compare it to a codebook of embedding vectors, {ek : k = 1 : K, ek ∈ R
L}, and
then set zij to the index of the nearest codebook entry:
q(zij = k|x) = (
1 if k = argmink′ ||ze(x)i,j,: − ek′ ||2
0 otherwise
(21.76)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license806
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 21.16: VQ-VAE architecture. From Figure 1 of [OVK17]. Used with kind permission of Aäron van
den Oord.
When reconstructing the input we replace each discrete code index by the corresponding real-valued
codebook vector:
(zq)ij = ek where zij = k (21.77)
These values are then passed to the decoder, p(x|zq), as usual. See Figure 21.16 for an illustration of
the overall architecture. Note that although zq is generated from a discrete combination of codebook
vectors, the use of a distributed code makes the model very expressive. For example, if we use a
grid of 32 × 32, with K = 512, then we can generate 51232×32 = 29216 distinct images, which is
astronomically large.
To fit this model, we can minimize the negative log likelihood (reconstruction error) using the
straight-through estimator, as before. This amounts to passing the gradients from the decoder
input zq(x) to the encoder output ze(x), bypassing Equation (21.76), as shown by the red arrow in
Figure 21.16. Unfortunately this means that the codebook entries will not get any learning signal.
To solve this, the authors proposed to add an extra term to the loss, known as the codebook loss,
that encourages the codebook entries e to match the output of the encoder. We treat the encoder
ze(x) as a fixed target, by adding a stop gradient operator to it; this ensures ze is treated normally
in the forwards pass, but has zero gradient in the backwards pass. The modified loss (dropping the
spatial indices i, j) becomes
L = − log p(x|zq(x)) + ||sg(ze(x)) − e||2
2
(21.78)
where e refers to the codebook vector assigned to ze(x), and sg is the stop gradient operator.
An alternative way to update the codebook vectors is to use moving averages. To see how this
works, first consider the batch setting. Let {zi,1, . . . , zi,ni } be the set of ni outputs from the encoder
that are closest to the dictionary item ei
. We can update ei to minimize the MSE
Xni
j=1
||zi,j − ei
||2
2
(21.79)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.6. VECTOR QUANTIZATION VAE
which has the closed form update
ei =
1
ni
Xni
j=1
zi,j (21.80)
This is like the M step of the EM algorithm when fitting the mean vectors of a GMM. In the minibatch
setting, we replace the above operations with an exponentially moving average, as follows:
N
t
i = γNt−1
i + (1 − γ)n
t
i
(21.81)
mt
i = γmt−1
i + (1 − γ)
X
j
z
t
i,j (21.82)
e
t
i =
mt
i
Nt
i
(21.83)
The authors found γ = 0.9 to work well.
The above procedure will learn to update the codebook vectors so it matches the output of the
encoder. However, it is also important to ensure the encoder does not “change its mind” too often
about what codebook value to use. To prevent this, the authors propose to add a third term to
the loss, known as the commitment loss, that encourages the encoder output to be close to the
codebook values. Thus we get the final loss:
L = − log p(x|zq(x)) + ||sg(ze(x)) − e||2
2 + β||ze(x) − sg(e)||2
2
(21.84)
The authors found β = 0.25 to work well, although of course the value depends on the scale of the
reconstruction loss (NLL) term. (A probabilistic interpretation of this loss can be found in [Hen+18].)
Overall, the decoder optimizes the first term only, the encoder optimizes the first and last term, and
the embeddings optimize the middle term.
21.6.3 Learning the prior
After training the VQ-VAE model, it is possible to learn a better prior, to match the aggregated
posterior. To do this, we just apply the encoder to a set of data, {xn}, thus converting them to
discrete sequences, {zn}. We can then learn a joint distribution p(z) using any kind of sequence
model. In the original VQ-VAE paper [OVK17], they used the causal convolutional PixelCNN model
(Section 22.3.2). More recent work has used transformer decoders (Section 22.4). Samples from this
prior can then be decoded using the decoder part of the VQ-VAE model. We give some examples of
this in the sections below.
21.6.4 Hierarchical extension (VQ-VAE-2)
In [ROV19], they extend the original VQ-VAE model by using a hierarchical latent code. The model
is illustrated in Figure 21.17. They applied this to images of size 256 × 256 × 3. The first latent layer
maps this to a quantized representation of size 64 × 64, and the second latent layer maps this to a
quantized representation of size 32 × 32. This hierarchical scheme allows the top level to focus on
high level semantics of the image, leaving fine visual details, such as texture, to the lower level. (See
Section 21.5 for more discussion of hierarchical VAEs.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license808
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
VQ
VQ
Encoder
Encoder Decoder
Decoder
Original Reconstruction
Bottom
Level
Top
Level
0 255
Condition
Decoder
Generation
0 255
VQ-VAE Encoder and Decoder Training Image Generation
Figure 21.17: Hierarchical extension of VQ-VAE. (a) Encoder and decoder architecture. (b) Combining a
Pixel-CNN prior with the decoder. From Figure 2 of [ROV19]. Used with kind permission of Aaron van den
Oord.
After fitting the VQ-VAE, they learn a prior over the top level code using a PixelCNN model
augmented with self-attention (Section 16.2.7) to capture long-range dependencies. (This hybrid
model is known as PixelSNAIL [Che+17c].) For the lower level prior, they just use standard PixelCNN,
since attention would be too expensive. Samples from the model can then be decoded using the
VQ-VAE decoder, as shown in Figure 21.17.
21.6.5 Discrete VAE
In VQ-VAE, we use a one-hot encoding for the latents, q(z = k|x) = 1 iff k = argmink
||ze(x) − ek||2,
and then set zq = ek. This does not capture any uncertainty in the latent code, and requires the use
of the straight-through estimator for training.
Various other approaches to fitting VAEs with discrete latent codes have been investigated. In the
DALL-E paper (Section 22.4.2), they use a fairly simple method, based on using the Gumbel-softmax
relaxation for the discrete variables (see Section 6.3.6). In brief, let q(z = k|x) be the probability
that the input x is assigned to codebook entry k. We can exactly sample wk ∼ q(z = k|x) from this
by computing wk = argmaxk
gk + log q(z = k|x), where each gk is from a Gumbel distribution. We
can now “relax” this by using a softmax with temperature τ > 0 and computing
wk =
exp( gk+log q(z=k|x)
τ
)
PK
j=1 exp(
gj+log q(z=j|x)
τ
)
(21.85)
We now set the latent code to be a weighted sum of the codebook vectors:
zq =
X
K
k=1
wkek (21.86)
In the limit that τ → 0, the distribution over weights w converges to a one-hot disribution, in which
case z becomes equal to one of the codebook entries. But for finite τ , we “fill in” the space between
the vectors.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
21.6. VECTOR QUANTIZATION VAE
Figure 21.18: Illustration of the VQ-GAN. From Figure 2 of [ERO21]. Used with kind permission of Patrick
Esser.
This allows us to express the ELBO in the usual differentiable way:
L = −Eq(z|x)
[log p(x|z)] + βDKL (q(z|x) k p(z)) (21.87)
where β > 0 controls the amount of regularization. (Unlike VQ-VAE, the KL term is not a constant,
because the encoder is stochastic.) Furthermore, since the Gumbel noise variables are sampled from
a distribution that is independent of the encoder parameters, we can use the reparameterization trick
(Section 6.3.5) to optimize this.
21.6.6 VQ-GAN
One drawback of VQ-VAE is that it uses mean squared error in its reconstruction loss, which can
result in blurry samples. In the VQ-GAN paper [ERO21], they replace this with a (patch-wise)
GAN loss (see Chapter 26), together with a perceptual loss; this results in much higher visual fidelity.
In addition, they use a transformer (see Section 16.3.5) to model the prior on the latent codes. See
Figure 21.18 for a visualization of the overall model. In [Yu+21], they replace the CNN encoder and
decoder of the VQ-GAN model with transformers, yielding improved results; they call this VIM
(vector-quantized image modeling).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license22 Autoregressive models
22.1 Introduction
By the chain rule of probability, we can write any joint distribution over T variables as follows:
p(x1:T ) = p(x1)p(x2|x1)p(x3|x2, x1)p(x4|x3, x2, x1). . . =
Y
T
t=1
p(xt|x1:t−1) (22.1)
where xt ∈ X is the t’th observation, and we define p(x1|x1:0) = p(x1) as the initial state distribution.
This is called an autoregressive model or ARM. This corresponds to a fully connected DAG, in
which each node depends on all its predecessors in the ordering, as shown in Figure 22.1. The models
can also be conditioned on arbitrary inputs or context c, in order to define p(x|c), although we omit
this for notational brevity.
We could of course also factorize the joint distribution “backwards” in time, using
p(x1:T ) = Y
1
t=T
p(xt|xt+1:T ) (22.2)
However, this “anti-causal” direction is often harder to learn (see e.g., [PJS17]).
Although the decomposition in Equation (22.1) is general, each term in this expression (i.e., each
conditional distribution p(xt|x1:t−1)) becomes more and more complex, since it depends on an
increasing number of arguments, which makes the terms slow to compute, and makes estimating
their parameters more data hungry (see Section 2.6.3.2).
One approach to solving this intractability is to make the (first-order) Markov assumption,
which gives rise to a Markov model p(xt|x1:t−1) = p(xt|xt−1), which we discuss in Section 2.6.
(This is also called an auto-regressive model of order 1.) Unfortunately, the Markov assumption is
very limiting. One way to relax it, and to make xt depend on all the past x1:t−1 without explicitly
regressing on them, is to assume the past can be compressed into a hidden state zt. If zt is a
deterministic function of the past observations x1:t−1, the resulting model is known as a recurrent
neural network, discussed in Section 16.3.4. If zt is a stochastic function of the past hidden state,
zt−1, the resulting model is known as a hidden Markov model, which we discuss in Section 29.2.
Another approach is to stay with the general AR model of Equation (22.1), but to use a restricted
functional form, such as some kind of neural network, for the conditionals p(xt|x1:t−1). Thus rather
than making conditional independence assumptions, or explicitly compressing the past into a sufficient812
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
x1 x2 x3 x4
Figure 22.1: A fully-connected auto-regressive model.
statistic, we implicitly learn a compact mapping from the past to the future. In the sections below,
we discuss different functional forms for these conditional distributions.
The main advantage of such AR models is that it is easy to compute, and optimize, the exact
likelihood of each sequence (data vector). The main disadvantage is that generating samples is
inherently sequential, which can be slow. In addition, the method does not learn a compact latent
representation of the data.
22.2 Neural autoregressive density estimators (NADE)
A simple way to represent each conditional probability distribution p(xt|x1:t−1) is to use a generalized
linear model, such as logistic regression, as proposed in [Fre98]. We can make the model be more
powerful by using a neural network. The resulting model is called the neural auto-regressive
density estimator or NADE model [LM11].
If we let p(xt|x1:t−1) be a conditional mixture of Gaussians, we get a model known as RNADE
(“real-valued neural autoregressive density estimator”) of [UML13]. More precisely, this has the form
p(xt|x1:t−1) = X
K
k=1
πt,kN (xt|µt,k, σ2
t,k) (22.3)
where the parameters are generated by a network, (µt
,σt,πt) = ft(x1:t−1; θt).
Rather than using separate neural networks, f1, . . . , fT , it is more efficient to create a single
network with T inputs and T outputs. This can be done using masking, resulting in a model called
the MADE (“masked autoencoder for density estimation”) model [Ger+15].
One disadvantage of NADE-type models is that they assume the variables have a natural linear
ordering. This makes sense for temporal or sequential data, but not for more general data types,
such as images or graphs. An orderless extension to NADE was proposed in [UML14; Uri+16].
22.3 Causal CNNs
One approach to representing the distribution p(xt|x1:t−1) is to try to identify patterns in the past
history that might be predictive of the value of xt. If we assume these patterns can occur in any
location, it makes sense to use a convolutional neural network to detect them. However, we need
to make sure we only apply the convolutional mask to past inputs, not future ones. This can be done
using masked convolution, also called causal convolution. We discuss this in more detail below.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
22.3. CAUSAL CNNS
Figure 22.2: Illustration of the wavenet model using dilated (atrous) convolutions, with dilation factors of 1,
2, 4 and 8. From Figure 3 of [oor+16]. Used with kind permission of Aäron van den Oord.
22.3.1 1d causal CNN (convolutional Markov models)
Consider the following convolutional Markov model for 1d discrete sequences:
p(x1:T ) = Y
T
t=1
p(xt|x1:t−1; θ) = Y
T
t=1
Cat(xt|softmax(ϕ(
Xt−k
τ=1
wTxτ:τ+k))) (22.4)
where w is the convolutional filter of size k, and we have assumed a single nonlinearity ϕ and
categorical output, for notational simplicity. This is like regular 1d convolution except we “mask out”
future inputs, so that xt only depends on the past values. We can of course use deeper models, and
we can condition on input features c.
In order to capture long-range dependencies, we can use dilated convolution (see [Mur22, Sec
14.4.1]). This model has been successfully used to create a state of the art text to speech (TTS)
synthesis system known as wavenet [oor+16]. See Figure 22.2 for an illustration.
The wavenet model is a conditional model, p(x|c), where c is a set of linguistic features derived
from an input sequence of words, and x is raw audio. The tacotron system [Wan+17c] is a fully
end-to-end approach, where the input is words rather than linguistic features.
Although wavenet produces high quality speech, it is too slow for use in production systems. How￾ever, it can be “distilled” into a parallel generative model [Oor+18], as we discuss in Section 23.2.4.3.
22.3.2 2d causal CNN (PixelCNN)
We can extend causal convolutions to 2d, to get an autoregressive model of the form
p(x|θ) = Y
R
r=1
Y
C
c=1
p(xr,c|fθ(x1:r−1,1:C , xr,1:c−1)) (22.5)
where R is the number of rows, C is the number of columns, and we condition on all previously
generated pixels in a raster scan order, as illustrated in Figure 22.3. This is called the pixelCNN
model [Oor+16]. Naive sampling (generation) from this model takes O(N) time, where N = RC is
the number of pixels, but [Ree+17] shows how to use a multiscale approach to reduce the complexity
to O(log N).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license814
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 22.3: Illustration of causal 2d convolution in the PixelCNN model. The red histogram shows the
empirical distribution over discretized values for a single pixel of a single RGB channel. The red and green
5 × 5 array shows the binary mask, which selects the top left context, in order to ensure the convolution is
causal. The diagrams on the right illustrate how we can avoid blind spots by using a vertical context stack,
that contains all previous rows, and a horizontal context stack, that just contains values from the current row.
From Figure 1 of [Oor+16]. Used with kind permission of Aaron van den Oord.
Various extensions of this model have been proposed. The pixelCNN++ model of [Sal+17c]
improved the quality by using a mixture of logistic distributions, to capture the multimodality
of p(xi
|x1:i−1). The pixelRNN of [OKK16] combined masked convolution with an RNN to get
even longer range contextual dependencies. The Subscale Pixel Network of [MK19] proposed to
generate the pixels such that the higher order bits are sampled before lower order bits, which allows
high resolution details to be sampled conditioned on low resolution versions of the whole image,
rather than just the top left corner.
22.4 Transformers
We introduced transformers in Section 16.3.5. They can be used for encoding sequences (as in BERT),
or for decoding (generating) sequences. We can also combine the two, using an encoder-decoder
combination, for conditional generation from p(y|c). Alternatively, we can define a joint sequence
model p(c, y), where c is the conditioning or context prompt, and then just condition the joint model,
by giving it as the initial context.
The decoder (generator) works as follows. At each step t, the model applies masked (causal) self
attention (Section 16.2.7) to the first t inputs, y1:t, to compute a set of attention weights, a1:t. From
this it computes an activation vector zt =
Pt
τ=1 atyt. This is then passed through a feed-forward
layer to compute ht = MLP(zt). This process is repeated for each layer in the model. Finally the
output is used to predict the next element in the sequence, yt+1 ∼ Cat(softmax(Wht)).
At training time, all predictions can happen in parallel, since the target generated sequence is
already available. That is, the t’th output yt can be predicted given inputs y1:t−1, and this can be
done for all t simultaneously. However, at test time, the model must be applied sequentially, so the
output generated at t + 1 is fed back into the model to predict t + 2, etc. Note that the running time
of transformers is O(T
2
), although a variety of more efficient versions have been developed (see e.g.,
[Mur22, Sec 15.6] for details).
Transformers are the basis of many popular (conditional) generative models for sequences. We
give some examples below.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
22.4. TRANSFORMERS
Figure 22.4: Illustration of few shot learning with GPT-3. The model is asked to create an example sentence
using a new word whose meaning is provided in the prompt. Boldface is GPT-3’s completions, light gray is
human input. From Figure 3.16 of [Bro+20d].
22.4.1 Text generation (GPT, etc.)
In [Rad+18], OpenAI proposed a model called GPT, which is short for “Generative Pre-training
Transformer”. This is a decoder-only transformer model that uses causal (masked) attention. In
[Rad+19], they propose GPT-2, which is a larger version of GPT (1.5 billion parameters, or 6.5GB,
for the XL version), trained on a large web corpus (8 million pages, or 40GB). They also simplify the
training objective, and just train it using maximum likelihood.
After GPT-2, OpenAI released GPT-3 [Bro+20d], which is an even larger version of GPT-2 (175
billion parameters), trained on even more data (300 billion words), but based on the same principles.
(Training was estimated to take 355 GPU years and cost $4.6M.) Due to the large size of the data
and model, GPT-3 shows even more remarkable abilities to generate novel text. In particular, the
output can be (partially) controlled by just changing the conditioning prompt. This enables the
model to perform tasks that it has never been trained on, just by giving it some examples in the
prompt. This is called “in-context learning”. See Figure 22.4 for an example, and Section 19.5.1.2
for more details.
More recently, OpenAI released ChatGPT [Ope], which is an improved version of GPT-3 which has
been trained to have interactive dialogs by using a technique called reinforcement learning from
human feedback or RLHF, a technique first introduced in the InstructGPT paper [Ouy+22].
This uses RL techniques such as PPO (Section 35.3.4) to fine tune the model so that it generates
responses that are more “aligned” with human intent, as estimated by a ranking model, which is
pre-trained on supervised data.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license816
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(JAX):
Yo, PyTorch, you think you’re hot stuff.
But JAX is where it’s at, no need to bluff.
Your popularity might be on the rise
But when it comes to performance, we’re the guys.
With automatic differentation, we’re a breeze
Training neural nets with ease
Our functional approach is innovative and unique
PyTorch can’t touch our speed, try and keep up, meek
(PyTorch):
Hold up, JAX, you might be fast
But PyTorch is the one that’s built to last
We may not have the fancy functional flair
But our flexibility sets us above the pair
Our community is strong and growing each day
Suppporting us in every single way
We may not be the newest on the block
But we’lll always be the torch that leads the flock
Figure 22.5: ChatGPT response to the prompt “Write a rap battle about PyTorch and JAX”. Used with kind per￾mission of Paige Bailey. From https: // twitter. com/ DynamicWebPaige/ status/ 1601743574369902593 .
Despite the impressive performance of these large language models or LLMs (see Figure 22.5 for
an example), there are several open problems with them, such as: they often confidently hallucinate
incorrect answers to questions (see e.g., [Ji+22]); they can generate biased or toxic output (see e.g.,
[Lia+]); and they are very resource intensive to train and serve. Indeed, these concerns are why
Google has not (at the time of writing) released its version of ChatGPT, known as LaMDA [Col21].
The basic ideas behind LLMs are quite simple (maximum likelihood training of an autoregresssive
transformer), and they can be implemented in about 300 lines of code.1 However, just by scaling up
the size of the models and datasets, it seems that qualitatively new capabilities can emerge (see e.g.,
[Wei+22]). Nevertheless, although this approach is good at learning formal linguistic competence
(surface form), it is not clear if it is sufficient to learn functional linguistic competence, which requires
a deeper, non-linguistic understanding of the world derived from experience [Mah+23].
22.4.2 Image generation (DALL-E, etc.)
The DALL-E model2
from OpenAI [Ram+21a] can generate images of remarkable quality and
diversity given text prompts, as shown in Figure 22.6. The methodology is conceptually quite
straightforward, and most of the effort went into data collection (they scraped the web for 250 million
image-text pairs) and scaling up the training (they fit a model with 12 billion parameters). Here we
just focus on the algorithmic methods.
The basic idea is to transform an image x into a sequence of discrete tokens z using a discrete
1. See e.g., https://github.com/karpathy/nanoGPT.
2. The name is derived from the artist Salvador Dalí and Pixar’s movied “WALL-E”
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
22.4. TRANSFORMERS
(a) an armchair in the shape of an avo￾cado.
(b) an illustration of a baby hedgehog in
a christmas sweater walking a dog
Figure 22.6: Some images generated by the DALL-E model in response to a text prompt. (a) “An armchair in
the shape of an avocado”. (b) “An illustration of a baby hedgehog in a christmas sweater walking a dog”. From
https: // openai. com/ blog/ dall-e . Used with kind permission of Aditya Ramesh.
VAE model (Section 21.6.5). We then fit a transformer to the concatentation of the image tokens z
and text tokens y to get a joint model of the form p(z, y).
To sample an image x given a text prompt y, we sample a latent code z ∼ p(z|y) by conditioning
the transformer on the prompt y, and then we feed z into the VAE decoder to get the image
x ∼ p(x|z). Multiple images are generated for each prompt, and these are then ranked according to
a pre-trained critic, which gives them scores depending on how well the generated image matches
the input text: sn = critic(xn, yn). The critic they used was the contrastive CLIP model (see
Section 32.3.4.1). This discriminative reranking significantly improves the results.
Some sample results are shown in Figure 22.6, and more can be found online at https://openai.
com/blog/dall-e/. The image on the right of Figure 22.6 is particularly interesting, since the
prompt — “An illustration of a baby hedgehog in a christmas sweater walking a dog” — arguably
requires that the model solve the “variable binding problem”. This refers to the fact that the
sentence implies the hedgehog should be wearing the sweater and not the dog. We see that the model
sometimes interprets this correctly, but not always: sometimes it draws both animals with Christmas
sweaters. In addition, sometimes it draws a hedgehog walking a smaller hedgehog. The quality of
the results can also be sensitive to the form of the prompt.
The PARTI model [Yu+22] from Google follows similar high level ideas to DALL-E, but has been
scaled to an even larger size. The larger models perform qualitatively much better, as shown in
Figure 20.3.
Other recent approaches to (conditional) image generation — such as DALL-E 2 [Ram+22] from
Open-AI, Imagen [Sah+22b] from Google, and Stable diffusion [Rom+22] from Stability.AI — are
based on diffusion rather than applying a transformer to discretized image patches. See Section 25.6.4
for details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license818
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
22.4.3 Other applications
Transformers have been used to generate many other kinds of (discrete) data, such as midi music
sequences [Hua+18a], protein sequences [Gan+23], etc.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 202323 Normalizing flows
This chapter is written by George Papamakarios and Balaji Lakshminarayanan.
23.1 Introduction
In this chapter we discuss normalizing flows, a class of flexible density models that can be
easily sampled from and whose exact likelihood function is efficient to compute. Such models
can be used for many tasks, such as density modeling, inference and generative modeling. We
introduce the key principles of normalizing flows and refer to recent surveys by Papamakarios et al.
[Pap+19] and Kobyzev, Prince, and Brubaker [KPB19] for readers interested in learning more. See
also https://github.com/janosh/awesome-normalizing-flows for a list of papers and software
packages.
23.1.1 Preliminaries
Normalizing flows create complex probability distributions p(x) by passing random variables u ∈ R
D,
drawn from a simple base distribution p(u) through a nonlinear but invertible transformation
f : R
D → R
D. That is, p(x) is defined by the following process:
x = f(u) where u ∼ p(u). (23.1)
The base distribution is typically chosen to be simple, for example standard Gaussian or uniform, so
that we can easily sample from it and compute the density p(u). A flexible enough transformation
f can induce a complex distribution on the transformed variable x even if the base distribution is
simple.
Sampling from p(x) is straightforward: we first sample u from p(u) and then compute x = f(u).
To compute the density p(x), we rely on the fact that f is invertible. Let g(x) = f
−1
(x) = u be
the inverse mapping, which “normalizes” the data distribution by mapping it back to the base
distribution (which is often a normal distribution). Using the change-of-variables formula for random
variables from Equation (2.257), we have
px(x) = pu(g(x))| det J(g)(x)| = pu(u)| det J(f)(u)|
−1
, (23.2)
where J(f)(u) = ∂f
∂u
|u is the Jacobian matrix of f evaluated at u. Taking logs of both sides of
Equation (23.2), we get
log px(x) = log pu(u) − log | det J(f)(u)|. (23.3)820
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
As discussed above, p(u) is typically easy to evaluate. So, if one can use flexible invertible transforma￾tions f whose Jacobian determinant det J(f)(u) can be computed efficiently, then one can construct
complex densities p(x) that allow exact sampling and efficient exact likelihood computation. This is
in contrast to latent variable models, which require methods like variational inference to lower-bound
the likelihood.
One might wonder how flexible are the densities p(x) obtained by transforming random variables
sampled from simple p(u). It turns out that we can use this method to approximate any smooth
distribution. To see this, consider the scenario where the base distribution p(u) is a one-dimensional
uniform distribution. Recall that inverse transform sampling (Section 11.3.1) samples random
variables from a uniform distribution and transforms them using the inverse cumulative distribution
function (cdf) to generate samples from the desired density. We can use this method to sample
from any one-dimensional density as long as the transformation f is powerful enough to model the
inverse cdf (which is a reasonable assumption for well-behaved densities whose cdf is invertible and
differentiable). We can further extend this argument to multiple dimensions by first expressing the
density p(x) as a product of one-dimensional conditionals using the chain rule of probability, and then
applying inverse transform sampling to each one-dimensional conditional. The result is a normalizing
flow that transforms a product of uniform distributions into any desired distribution p(x). We refer
to [Pap+19] for a more detailed proof.
How do we define flexible invertible mappings whose Jacobian determinant is easy to compute?
We discuss this topic in detail in Section 23.2, but in summary, there are two main ways. The first
approach is to define a set of simple transformations that are invertible by design, and whose Jacobian
determinant is easy to compute; for instance, if the Jacobian is a triangular matrix, its determinant
can be computed efficiently. The second approach is to exploit the fact that a composition of invertible
functions is also invertible, and the overall Jacobian determinant is just the product of the individual
Jacobian determinants. More precisely, if f = fN ◦ · · · ◦ f1 where each fi
is invertible, then f is also
invertible, with inverse g = g1 ◦ · · · ◦ gN and log Jacobian determinant given by
log | det J(g)(x)| =
X
N
i=1
log | det J(gi)(ui)| (23.4)
where ui = fi ◦ · · · ◦ f1(u) is the i’th intermediate output of the flow. This allows us to create
complex flows from simple components, just as graphical models allow us to create complex joint
distributions from simpler conditional distributions.
Finally, a note on terminology. An invertible transformation is also known as a bijection. A
bijection that is differentiable and has a differentiable inverse is known as a diffeomorphism. The
transformation f of a flow model is a diffeomorphism, although in the rest of this chapter we will refer
to it as a “bijection” for simplicity, leaving the differentiability implicit. The density px(x) of a flow
model is also known as the pushforward of the base distribution pu(u) through the transformation
f, and is sometimes denoted as px = f∗pu. Finally, in mathematics the term “flow” refers to any
family of diffeomorphisms ft indexed by a real number t such that t = 0 indexes the identity function,
and t1 + t2 indexes ft2
◦ ft1
(in physics, t often represents time). In machine learning we use the term
“flow” by analogy to the above meaning, to highlight the fact that we can create flexible invertible
transformations by composing simpler ones; in this sense, the index t is analogous to the number i of
transformations in fi ◦ · · · ◦ f1.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
23.1. INTRODUCTION
23.1.2 How to train a flow model
There are two common applications of normalizing flows. The first one is density estimation of
observed data, which is achieved by fitting pθ(x) to the data and using it as an estimate of the
data density, potentially followed by generating new data from pθ(x). The second one is variational
inference, which involves sampling from and evaluating a variational posterior qθ(z|x) parameterized
by the flow model. As we will see below, these applications optimize different objectives and impose
different computational constraints on the flow model.
23.1.2.1 Density estimation
Density estimation requires maximizing the likelihood function in Equation (23.2). This requires that
we can efficiently evaluate the inverse flow u = f
−1
(x) and its Jacobian determinant det J(f
−1
)(x)
for any given x. After optimizing the model, we can optionally use it to generate new data. To
sample new points, we require that the forwards mapping f be tractable.
23.1.2.2 Variational inference
Normalizing flows are commonly used for variational inference to parameterize the approximate
posterior distribution in latent variable models, as discussed in Section 10.4.3. Consider a latent
variable model with continuous latent variables z and observable variables x. For simplicity, we
consider the model parameters to be fixed as we are interested in approximating the true posterior
p
∗
(z|x) with a normalizing flow qθ(z|x).
1 As discussed in Section 10.1.1.2, the variational parameters
are trained by maximizing the evidence lower bound (ELBO), given by
L(θ) = Eqθ(z|x)
[log p(x|z) + log p(z) − log qθ(z|x)] (23.5)
When viewing the ELBO as a function of θ, it can be simplified as follows (note we drop the
dependency on x for simplicity):
L(θ) = Eqθ(z)
[ℓθ(z)] . (23.6)
Let qθ(z) denote a normalizing flow with base distribution q(u) and transformation z = fθ(u). Then
the reparameterization trick (Section 6.3.5) allows us to optimize the parameters using stochastic
gradients. To achieve this, we first write the expectation with respect to the base distribution:
L(θ) = Eqθ(z)
[ℓθ(z)] = Eq(u)
[ℓθ(fθ(u))] . (23.7)
Then, since the base distribution does not depend on θ, we can obtain stochastic gradients as follows:
∇θL(θ) = Eq(u)
[∇θℓθ(fθ(u))] ≈
1
N
X
N
n=1
∇θℓθ(fθ(un)), (23.8)
where {un}
N
n=1 are samples from q(u).
1. We denote the parameters of the variational posterior by θ here, which should not be confused with the model
parameters which are also typically denoted by θ elsewhere.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license822
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
As we can see, in order to optimize this objective, we need to be able to efficiently sample
from qθ(z|x) and evaluate the probability density of these samples during optimization. (See
Section 23.2.4.3 for details on how to do this.) This is contrast to the MLE approach in Section 23.1.2.1,
which requires that we be able to compute efficiently the density of arbitrary training datapoints,
but it does not require samples during optimization.
23.2 Constructing flows
In this section, we discuss how to compute various kinds of flows that are invertible by design and
have efficiently computable Jacobian determinants.
23.2.1 Affine flows
A simple choice is to use an affine transformation x = f(u) = Au + b. This is a bijection if and
only if A is an invertible square matrix. The Jacobian determinant of f is det A, and its inverse is
u = f
−1
(x) = A−1
(x − b). A flow consisting of affine bijections is called an affine flow, or a linear
flow if we ignore b.
On their own, affine flows are limited in their expressive power. For example, suppose the base
distribution is Gaussian, p(u) = N (u|µ, Σ). Then the pushforward distribution after an affine
bijection is still Gaussian, p(x) = N (x|Aµ+b, AΣAT). However, affine bijections are useful building
blocks when composed with the non-affine bijections we discuss later, as they encourage “mixing” of
dimensions through the flow.
For practical reasons, we need to ensure the Jacobian determinant and the inverse of the flow are
fast to compute. In general, computing det A and A−1
explicitly takes O(D3
) time. To reduce the
cost, we can add structure to A. If A is diagonal, the cost becomes O(D). If A is triangular, the
Jacobian determinant is the product of the diagonal elements, so it takes O(D) time; inverting the
flow requires solving the triangular system Au = x − b, which can be done with backsubstitution in
O(D2
) time.
The result of a triangular transformation depends on the ordering of the dimensions. To reduce
sensitivity to this, and to encourage “mixing” of dimensions, we can multiply A with a permutation
matrix, which has an absolute determinant of 1. We often use a permutation that reverses the indices
at each layer or that randomly shuffles them. However, usually the permutation at each layer is fixed
rather than learned.
For spatially structured data (such as images), we can define A to be a convolution matrix. For
example, GLOW [KD18b] uses 1 × 1 convolution; this is equivalent to pointwise linear transformation
across feature dimensions, but regular convolution across spatial dimensions. Two more general meth￾ods for modeling d × d convolutions are presented in [HBW19], one based on stacking autoregressive
convolutions, and the other on carrying out the convolution in the Fourier domain.
23.2.2 Elementwise flows
Let h : R → R be a scalar-valued bijection. We can create a vector-valued bijection f : R
D → R
D
by applying h elementwise, that is, f(u) = (h(u1), . . . , h(uD)). The function f is invertible, and
its Jacobian determinant is given by QD
i=1
dh
dui
. A flow composed of such bijections is known as an
elementwise flow.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
23.2. CONSTRUCTING FLOWS
−5 0 5
x
−5
0
5
y
a
−5 0 5
x, y
density
b c
−2 0 2
y1
−2
0
2
y
2
Figure 23.1: Non-linear squared flow (NLSq). Left: an invertible mapping consisting of 4 NLSq layers.
Middle: red is the base distribution (Gaussian), blue is the distribution induced by the mapping on the left.
Right: density of a 5-layer autoregressive flow using NLSq transformations and a Gaussian base density,
trained on a mixture of 4 Gaussians. From Figure 5 of [ZR19b]. Used with kind permission of Zachary
Ziegler.
On their own, elementwise flows are limited, since they do not model dependencies between the
elements. However, they are useful building blocks for more complex flows, such as coupling flows
(Section 23.2.3) and autoregressive flows (Section 23.2.4), as we will see later. In this section, we
discuss techniques for constructing scalar-valued bijections h : R → R for use in elementwise flows.
23.2.2.1 Affine scalar bijection
An affine scalar bijection has the form h(u; θ) = au + b, where θ = (a, b) ∈ R
2
. (This is a scalar
version of an affine flow.) Its derivative dh
du is equal to a. It is invertible if and only if a 6= 0. In
practice, we often parameterize a to be positive, for example by making it the exponential or the
softplus of an unconstrained parameter. When a = 1, h(u; θ) = u + b is often called an additive
scalar bijection.
23.2.2.2 Higher-order perturbations
The affine scalar bijection is simple to use, but limited. We can make it more flexible by adding
higher-order perturbations, under the constraint that invertibility is preserved. For example, Ziegler
and Rush [ZR19b] propose the following, which they term non-linear squared flow:
h(u; θ) = au + b +
c
1 + (du + e)
2
, (23.9)
where θ = (a, b, c, d, e) ∈ R
5
. When c = 0, this reduces to the affine case. When c 6= 0, it adds an
inverse-quadratic perturbation, which can induce multimodality as shown in Figure 23.1. Under the
constraints a > 9
8
√
3
cd and d > 0 the function becomes invertible, and its inverse can be computed
analytically by solving a quadratic polynomial.
23.2.2.3 Combinations of strictly monotonic scalar functions
A strictly monotonic scalar function is one that is always increasing (has positive derivative everywhere)
or always decreasing (has negative derivative everywhere). Such functions are invertible. Many
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license824
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
activation functions, such as the logistic sigmoid σ(u) = 1/(1 + exp(−u)), are strictly monotonic.
Using such activation functions as a starting point, we can build more flexible monotonic functions
via conical combination (linear combination with positive coefficients) and function composition.
Suppose h1, . . . , hK are strictly increasing; then the following are also strictly increasing:
• a1h1 + · · · + aKhK + b with ak > 0 (conical combination with a bias),
• h1 ◦ · · · ◦ hK (function composition).
By repeating the above two constructions, we can build arbitrarily complex increasing functions. For
example, a composition of conical combinations of logistic sigmoids is just an MLP where all weights
are positive [Hua+18b].
The derivative of such a scalar bijection can be computed by repeatedly applying the chain rule,
and in practice can be done with automatic differentiation. However, the inverse is not typically
computable in closed form. In practice we can compute the inverse using bisection search, since the
function is monotonic.
23.2.2.4 Scalar bijections from integration
A simple way to ensure a scalar function is strictly monotonic is to constrain its derivative to be
positive. Let h
′ =
dh
du be this derivative. Wehenkel and Louppe [WL19] directly parameterize h
′ with
a neural network whose output is made positive via an ELU activation function shifted up by 1.
They then integrate the derivative numerically to get the bijection:
h(u) = Z u
0
h
′
(t)dt + b, (23.10)
where b is a bias. They call this approach unconstrained monotonic neural networks.
The above integral is generally not computable in closed form. It can be, however, if h
′
is
constrained appropriately. For example, Jaini, Selby, and Yu [JSY19] take h
′
to be a sum of K
squared polynomials of degree L:
h
′
(u) = X
K
k=1 X
L
ℓ=0
akℓ u
ℓ
!2
. (23.11)
This makes h
′ a non-negative polynomial of degree 2L. The integral is analytically tractable, and
makes h an increasing polynomial of degree 2L + 1. For L = 0, h
′
is constant, so h reduces to an
affine scalar bijection.
In these approaches, the derivative of the bijection can just be read off. However, the inverse is not
analytically computable in general. In practice, we can use bisection search to compute the inverse
numerically.
23.2.2.5 Splines
Another way to construct monotonic scalar functions is using splines. These are piecewise-polynomial
or piecewise-rational functions, parameterized in terms of K + 1 knots (uk, xk) through which the
spline passes. That is, we set h(uk) = xk, and define h on the interval (uk−1, uk) by interpolating
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
23.2. CONSTRUCTING FLOWS
Figure 23.2: Illustration of a coupling layer x = f(u). A bijection, with parameters determined by u
B, is
applied to u
A to generate x
A; meanwhile x
B = u
B is passed through unchanged, so the mapping can be
inverted. From Figure 3 of [KPB19]. Used with kind permission of Ivan Kobyzev.
from xk−1 to xk with a polynomial or rational function (ratio of two polynomials). By increasing the
number of knots we can create arbitrarily flexible monotonic functions.
Different ways to interpolate between knots give different types of spline. A simple choice is
to interpolate linearly [Mül+19a]. However, this makes the derivative discontinuous at the knots.
Interpolating with quadratic polynomials [Mül+19a] gives enough flexibility to make the derivative
continuous. Interpolating with cubic polynomials [Dur+19], ratios of linear polynomials [DEL20],
or ratios of quadratic polynomials [DBP19] allows the derivatives at the knots to be arbitrary
parameters.
The spline is strictly increasing if we take uk−1 < uk, xk−1 < xk, and make sure the interpolation
between knots is itself increasing. Depending on the flexibility on the interpolating function, more
than one interpolation may exist; in practice we choose one that is guaranteed to be always increasing
(see references above for details).
An advantage of splines is that they can be inverted analytically if the interpolating functions
only contain low-degree polynomials. In this case, we compute u = h
−1
(x) as follows: first, we use
binary search to locate the interval (xk−1, xk) in which x lies; then, we analytically solve the resulting
low-degree polynomial for u.
23.2.3 Coupling flows
In this section we describe coupling flows, which allow us to model dependencies between dimensions
using arbitrary non-linear functions (such as deep neural networks). Consider a partition of the input
u ∈ R
D into two subspaces, (u
A,u
B) ∈ R
d × R
D−d
, where d is an integer between 1 and D − 1.
Assume a bijection ˆf(·; θ) : R
d → R
d parameterized by θ and acting on the subspace R
d
. We define
the function f : R
D → R
D given by x = f(u) as follows:
x
A =ˆf(u
A; Θ(u
B)) (23.12)
x
B = u
B. (23.13)
See Figure 23.2 for an illustration. The function f is called a coupling layer [DKB15; DSDB17],
because it “couples” u
A and u
B together though ˆf and Θ. We refer to flows consisting of coupling
layers as coupling flows.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license826
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The parameters of ˆf are computed by θ = Θ(u
B), where Θ is an arbitrary function called the
conditioner. Unlike affine flows, which mix dimensions linearly, and elementwise flows, which do
not mix dimensions at all, coupling flows can mix dimensions with a flexible non-linear conditioner Θ.
In practice we often implement Θ as a deep neural network; any architecture can be used, including
MLPs, CNNs, ResNets, etc.
The coupling layer f is invertible, and its inverse is given by u = f
−1
(x), where
u
A =ˆf
−1
(x
A; Θ(x
B)) (23.14)
u
B = x
B. (23.15)
That is, f
−1
is given by simply replacing ˆf with ˆf
−1
. Because x
B does not depend on u
A, the
Jacobian of f is block triangular:
J(f) = 
∂x
A/∂u
A ∂x
A/∂u
B
∂x
B/∂u
A ∂x
B/∂u
B

=

J(
ˆf) ∂x
A/∂u
B
0 I 
. (23.16)
Thus, det J(f) is equal to det J(
ˆf).
We often define ˆf to be an elementwise bijection, so that ˆf
−1 and det J(
ˆf) are easy to compute.
That is, we define:
ˆf(u
A; θ) = ￾
h(u
A
1
; θ1), . . . , h(u
A
d
; θd)

, (23.17)
where h(·; θi) is a scalar bijection parameterized by θi
. Any of the scalar bijections described in
Section 23.2.2 can be used here. For example, h(·; θi) can be an affine bijection with θi
its scale and
shift parameters (Section 23.2.2.1); or it can be a monotonic MLP with θi
its weights and biases
(Section 23.2.2.3); or it can be a monotonic spline with θi
its knot coordinates (Section 23.2.2.5).
There are many ways to define the partition of u into (u
A,u
B). A simple way is just to partition
u into two halves. We can also exploit spatial structure in the partitioning. For example, if u is an
image, we can partition its pixels using a “checkerboard” pattern, where pixels in “black squares” are
in u
A and pixels in “white squares” are in u
B [DSDB17]. Since only part of the input is transformed
by each coupling layer, in practice we typically employ different partitions along a coupling flow, to
ensure all variables get transformed and are given the opportunity to interact.
Finally, if ˆf is an elementwise bijection, we can implement arbitrary partitions easily using a binary
mask b as follows:
x = b ⊙ u + (1 − b) ⊙ˆf(u; Θ(b ⊙ u)), (23.18)
where ⊙ denotes elementwise multiplication. A value of 0 in b indicates that the corresponding
element in u is transformed (belongs to u
A); a value of 1 indicates that it remains unchanged (belongs
to u
B).
As an example, we fit a masked coupling flow, created from piecewise rational quadratic splines, to
the two moons dataset. Samples from each layer of the fitted model are shown in Figure 23.3.
23.2.4 Autoregressive flows
In this section we discuss autoregressive flows, which are flows composed of autoregressive bijections.
Like coupling flows, autoregressive flows allow us to model dependencies between variables with
arbitrary non-linear functions, such as deep neural networks.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
23.2. CONSTRUCTING FLOWS
(a) (b) (c) (d)
(e) (f) (g) (h)
Figure 23.3: (a) Two moons dataset. (b) Samples from a normalizing flow fit to this dataset. Generated by
two_moons_nsf_normalizing_flow.ipynb.
Suppose the input u contains D scalar elements, that is, u = (u1, . . . , uD) ∈ R
D. We define an
autoregressive bijection f : R
D → R
D, its output denoted by x = (x1, . . . , xD) ∈ R
D, as follows:
xi = h(ui
; Θi(x1:i−1)), i = 1, . . . , D. (23.19)
Each output xi depends on the corresponding input ui and all previous outputs x1:i−1 = (x1, . . . , xi−1).
The function h(·; θ) : R → R is a scalar bijection (for example, one of those described in Section 23.2.2),
and is parameterized by θ. The function Θi
is a conditioner that outputs the parameters θi that
yield xi
, given all previous outputs x1:i−1. Like in coupling flows, Θi can be an arbitrary non-linear
function, and is often parameterized as a deep neural network.
Because h is invertible, f is also invertible, and its inverse is given by:
ui = h
−1
(xi
; Θi(x1:i−1)), i = 1, . . . , D. (23.20)
An important property of f is that each output xi depends on u1:i = (u1, . . . , ui), but not on
ui+1:D = (ui+1, . . . , uD); as a result, the partial derivative ∂xi/∂uj is identically zero whenever j > i.
Therefore, the Jacobian matrix J(f) is triangular, and its determinant is simply the product of its
diagonal entries:
det J(f) = Y
D
i=1
∂xi
∂ui
=
Y
D
i=1
dh
dui
. (23.21)
In other words, the autoregressive structure of f leads to a Jacobian determinant that can be
computed efficiently in O(D) time.
Although invertible, autoregressive bijections are computationally asymmetric: evaluating f is
inherently sequential, whereas evaluating f
−1
is inherently parallel. That is because we need x1:i−1 to
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license828
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 23.4: (a) Affine autoregressive flow with one layer. In this figure, u is the input to the flow (sample
from the base distribution) and x is its output (sample from the transformed distribution). (b) Inverse of the
above. From [Jan18]. Used with kind permission of Eric Jang.
compute xi
; therefore, computing the components of x must be done sequentially, by first computing
x1, then using it to compute x2, then using x1 and x2 to compute x3, and so on. On the other hand,
computing the inverse can be done in parallel for each ui
, since u does not appear on the right-hand
side of Equation (23.20). Hence, in practice it is often faster to compute f
−1
than to compute f,
assuming h and h
−1 have similar computational cost.
23.2.4.1 Affine autoregressive flows
For a concrete example, we can take h to be an affine scalar bijection (Section 23.2.2.1) parameterized
by a log scale α and a bias µ. Such autoregressive flows are known as affine autoregressive flows.
The parameters of the i’th component, αi and µi
, are functions of x1:i−1, so f takes the following
form:
xi = ui exp(αi(x1:i−1)) + µi(x1:i−1). (23.22)
This is illustrated in Figure 23.4(a). We can invert this by
ui = (xi − µi(x1:i−1)) exp(−αi(x1:i−1)). (23.23)
This is illustrated in Figure 23.4(b). Finally, we can calculate the log absolute Jacobian determinant
by
log |det J(f)| = log





Y
D
i=1
exp(αi(x1:i−1))





=
X
D
i=1
αi(x1:i−1). (23.24)
Let us look at an example of an affine autoregressive flow on a 2d density estimation problem.
Consider an affine autoregressive flow x = (x1, x2) = f(u), where u ∼ N (0, I) and f is a single
autoregressive bijection. Since x1 is an affine transformation of u1 ∼ N (0, 1), it is Gaussian with
mean µ1 and standard deviation σ1 = exp α1. Similarly, if we consider x1 fixed, x2 is an affine
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
23.2. CONSTRUCTING FLOWS
(a) (b) (c)
Figure 23.5: Density estimation with affine autoregressive flows, using a Gaussian base distribution. (a) True
density. (b) Estimated density using a single autoregressive layer with ordering (x1, x2). On the left (contour
plot) we show p(x). On the right (green dots) we show samples of u = f
−1
(x), where x is sampled from the
true density. (c) Same as (b), but using 5 autoregressive layers and reversing the variable ordering after each
layer. Adapted from Figure 1 of [PPM17]. Used with kind permission of Iain Murray.
transformation of u2 ∼ N (0, 1), so it is conditionally Gaussian with mean µ2(x1) and standard
deviation σ2(x1) = exp α2(x1). Thus, a single affine autoregressive bijection will always produce a
distribution with Gaussian conditionals, that is, a distribution of the following form:
p(x1, x2) = p(x1) p(x2|x1) = N (x1|µ1, σ2
1
) N (x2|µ2(x1), σ2(x1)
2
) (23.25)
This result generalizes to an arbitrary number of dimensions D.
A single affine bijection is not very powerful, regardless of how flexible the functions α2(x1) and
µ2(x1) are. For example, suppose we want to fit the cross-shaped density shown in Figure 23.5(a)
with such a flow. The resulting maximum-likelihood fit is shown in Figure 23.5(b). The red contours
show the predictive distribution, pˆ(x), which clearly fails to capture the true distribution. The green
dots show transformed versions of the data samples, p(u); we see that this is far from the Gaussian
base distribution.
Fortunately, we can obtain a better fit by composing multiple autoregressive bijections (layers),
and reversing the order of the variables after each layer. For example, Figure 23.5(c) shows the
results of an affine autoregressive flow with 5 layers applied to the same problem. The red contours
show that we have matched the empirical distribution, and the green dots show we have matched the
Gaussian base distribution.
Note that another way to obtain a better fit is to replace the affine bijection h with a more flexible
one, such as a monotonic MLP (Section 23.2.2.3) or a monotonic spline (Section 23.2.2.5).
23.2.4.2 Masked autoregressive flows
As we have seen, the conditioners Θi can be arbitrary non-linear functions. The most straightforward
way to parameterize them is separately for each i, for example by using D separate neural networks.
However, this can be parameter-inefficient for large D.
In practice, we often share parameters between conditioners by combining them into a single
model Θ that takes in x and outputs (θ1, . . . , θD). For the bijection to remain autoregressive, we
must constrain Θ so that θi depends only on x1:i−1 and not on xi:D. One way to achieve this is to
start with an arbitrary neural network (an MLP, a CNN, a ResNet, etc.), and drop connections (for
example, by zeroing out weights) until θi
is only a function of x1:i−1.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license830
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 23.6: Inverse autoregressive flow that uses affine scalar bijections. In this figure, u is the input to the
flow (sample from the base distribution) and x is its output (sample from the transformed distribution) From
[Jan18]. Used with kind permission of Eric Jang.
An example of this approach is the masked autoregressive flow (MAF) model of [PPM17].
This model is an affine autoregressive flow combined with permutation layers, as we described in
Section 23.2.4.1. MAF implements the combined conditioner Θ as follows: it starts with an MLP,
and then multiplies (elementwise) the weight matrix of each layer with a binary mask of the same
size (different masks are used for different layers). The masks are constructed using the method of
[Ger+15]. This ensures that all computational paths from xj to θi are zeroed out whenever j ≥ i,
effectively making θi only a function of x1:i−1. Still, evaluating the masked conditioner Θ has the
same computational cost as evaluating the original (unmasked) MLP.
The key advantage of MAF (and of related models) is that, given x, all parameters (θ1, . . . , θD)
can be computed efficiently with one neural network evaluation, so the computation of the inverse
f
−1
is fast. Thus, we can efficiently evaluate the probability density of the flow model for arbitrary
datapoints. However, in order to compute f, the conditioner Θ must be called a total of D times,
since not all entries of x are available to start with. Thus, generating new samples from the flow is
D times more expensive than evaluating its probability density function. This makes MAF suitable
for density estimation, but less so for data generation.
23.2.4.3 Inverse autoregressive flows
As we have seen, the parameters θi that yield the i’th output xi are functions of the previous outputs
x1:i−1. This ensures that the Jacobian J(f) is triangular, and so its determinant is efficient to
compute.
However, there is another possibility: we can make θi a function of the previous inputs instead,
that is, a function of u1:i−1. This leads to the following bijection, which is known as inverse
autoregressive:
xi = h(ui
; Θi(u1:i−1)), i = 1, . . . , D. (23.26)
Like its autoregressive counterpart, this bijection has a triangular Jacobian whose determinant is
also given by det J(f) = QD
i=1
dh
dui
. Figure 23.6 illustrates an inverse autoregressive flow, for the case
where h is affine.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
23.2. CONSTRUCTING FLOWS
To see why this bijection is called “inverse autoregressive”, compare Equation (23.26) with Equa￾tion (23.20). The two formulas differ only notationally: we can get from one to the other by swapping
u with x and h with h
−1
. In other words, the inverse autoregressive bijection corresponds to a direct
parameterization of the inverse of an autoregressive bijection.
Since inverse autoregressive bijections swap the forwards and inverse directions of their autore￾gressive counterparts, they also swap their computational properties. This means that the forward
direction f of an inverse autoregressive flow is inherently parallel and therefore fast, whereas its
inverse direction f
−1
is inherently sequential and therefore slow.
An example of an inverse autoregressive flow is their namesake IAF model of [Kin+16]. IAF uses
affine scalar bijections, masked conditioners, and permutation layers, so it is precisely the inverse of
the MAF model described in Section 23.2.4.2. Using IAF, we can generate u in parallel from the
base distribution (using, for example, a diagonal Gaussian), and then sample each element of x in
parallel. However, evaluating p(x) for an arbitrary datapoint x is slow, because we have to evaluate
each element of u sequentially. Fortunately, evaluating the likelihood of samples generated from IAF
(as opposed to externally provided samples) incurs no additional cost, since in this case the ui terms
will already have been computed.
Although not so suitable for density estimation or maximum-likelihood training, IAFs are well￾suited for parameterizing variational posteriors in variational inference. This is because in order to
estimate the variational lower bound (ELBO), we only need samples from the variational posterior
and their associated probability densities, both of which are efficient to obtain. See Section 23.1.2.2
for details.
Another useful application of IAFs is training them to mimic models whose probability density is
fast to evaluate but which are slow to sample from. A notable example is the parallel wavenet
model of [Oor+18]. This model is an IAF ps that it trained to mimic a pretrained wavenet model pt
by minimizing the KL divergence DKL (ps k pt). This KL can be easily estimated by first sampling
from ps and then evaluating log ps and log pt at those samples, operations which are all efficient for
these models. After training, we obtain an IAF that can generate audio of similar quality as the
original wavenet, but can do so much faster.
23.2.4.4 Connection with autoregressive models
Autoregressive flows can be thought of as generalizing autoregressive models of continuous random
variables, discussed in Section 22.1. Specifically, any continuous autoregressive model can be
reparameterized as a one-layer autoregressive flow, as we describe below.
Consider a general autoregressive model over a continuous random variable x = (x1, . . . , xD) ∈ R
D
written as
p(x) = Y
D
i=1
pi(xi
|θi) where θi = Θi(x1:i−1). (23.27)
In the above expression, pi(xi
|θi) is the i’th conditional distribution of the autoregressive model,
whose parameters θi are arbitrary functions of the previous variables x1:i−1. For example, pi(xi
|θi)
can be a mixture of one-dimensional Gaussian distributions, with θi representing the collection of its
means, variances, and mixing coefficients.
Now consider sampling a vector x from the autoregressive model, which can be done by sampling
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license832
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
one element at a time as follows:
xi ∼ pi(xi
|Θi(x1:i−1)) for i = 1, . . . , D. (23.28)
Each conditional can be sampled from using inverse transform sampling (Section 11.3.1). Let U(0, 1)
be the uniform distribution on the interval [0, 1], and let CDFi(xi
|θi) be the cumulative distribution
function of the i’th conditional. Sampling can be written as:
xi = CDF−1
i
(ui
|Θi(x1:i−1)) where ui ∼ U(0, 1). (23.29)
Comparing the above expression with the definition of an autoregressive bijection in Equation (23.19),
we see that the autoregressive model has been expressed as a one-layer autoregressive flow whose base
distribution is uniform on [0, 1]D and whose scalar bijections correspond to the inverse conditional
cdf’s. Viewing autoregressive models as flows this way has an important advantage, namely that it
allows us to increase the flexibility of an autoregressive model by composing multiple instances of it
in a flow, without sacrificing the overall tractability.
23.2.5 Residual flows
A residual network is a composition of residual connections, which are functions of the form
f(u) = u + F(u). The function F : R
D → R
D is called the residual block, and it computes the
difference between the output and the input, f(u) − u.
Under certain conditions on F, the residual connection f becomes invertible. We will refer to flows
composed of invertible residual connections as residual flows. In the following, we describe two
ways the residual block F can be constrained so that the residual connection f is invertible.
23.2.5.1 Contractive residual blocks
One way to ensure the residual connection is invertible is to choose the residual block to be a
contraction. A contraction is a function F whose Lipschitz constant is less than 1; that is, there
exists 0 ≤ L < 1 such that for all u1 and u2 we have:
kF(u1) − F(u2)k ≤ Lku1 − u2k. (23.30)
The invertibility of f(u) = u + F(u) can be shown as follows. Consider the mapping g(u) =
x − F(u). Because F is a contraction, g is also a contraction. So, by Banach’s fixed-point theorem,
g has a unique fixed point u∗. Hence we have
u∗ = x − F(u∗) (23.31)
⇒ u∗ + F(u∗) = x (23.32)
⇒ f(u∗) = x. (23.33)
Because u∗ is unique, it follows that u∗ = f
−1
(x).
An example of a residual flow with contractive residual blocks is the iResNet model of [Beh+19].
The residual blocks of iResNet are convolutional neural networks, that is, compositions of convolutional
layers with non-linear activation functions. Because the Lipschitz constant of a composition is less or
equal to the product of the Lipschitz constants of the individual functions, it is enough to ensure the
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
23.2. CONSTRUCTING FLOWS
convolutions are contractive, and to use increasing activation functions with slope less or equal to 1.
The iResNet model ensures the convolutions are contractive by applying spectral normalization to
their weights [Miy+18a].
In general, there is no analytical expression for the inverse f
−1
. However, we can approximate
f
−1
(x) using the following iterative procedure:
un = g(un−1) = x − F(un−1). (23.34)
Banach’s fixed-point theorem guarantees that the sequence u0,u1,u2, . . . will converge to u∗ = f
−1
(x)
for any choice of u0, and it will do so at a rate of O(L
n), where L is the Lipschitz constant of g
(which is the same as the Lipschitz constant of F). In practice, it is convenient to choose u0 = x.
In addition, there is no analytical expression for the Jacobian determinant, whose exact computation
costs O(D3
). However, there is a computationally efficient stochastic estimator of the log Jacobian
determinant. The idea is to express the log Jacobian determinant as a power series. Using the fact
that f(x) = x + F(x), we have
log | det J(f)| = log | det(I + J(F))| =
X∞
k=1
(−1)k+1
k
tr
J(F)
k

. (23.35)
This power series converges when the matrix norm of J(F) is less than 1, which here is guaranteed
exactly because F is a contraction. The trace of J(F)
k
can be efficiently approximated using
Jacobian-vector products via the Hutchinson trace estimator [Ski89; Hut89; Mey+21]:
tr
J(F)
k

≈ v
⊤J(F)
kv, (23.36)
where v is a sample from a distribution with zero mean and unit covariance, such as N (0, I).
Finally, the infinite series can be approximated by a finite one either by truncation [Beh+19], which
unfortunately yields a biased estimator, or by employing the Russian-roulette estimator [Che+19],
which is unbiased.
23.2.5.2 Residual blocks with low-rank Jacobian
There is an efficient way of computing the determinant of a matrix which is a low-rank perturbation
of an identity matrix. Suppose A and B are matrices, where A is D × M and B is M × D. The
following formula is known as the Weinstein-Aronszajn identity2
, and is a special case of the
more general matrix determinant lemma:
det(ID + AB) = det(IM + BA). (23.37)
We write ID and IM for the D × D and M × M identity matrices respectively. The significance of
this formula is that it turns a D × D determinant that costs O(D3
) into an M × M determinant
that costs O(M3
). If M is smaller than D, this saves computation.
With some restrictions on the residual block F : R
D → R
D, we can apply this formula to compute
the determinant of a residual connection efficiently. The trick is to create a bottleneck inside F. We
do that by defining F = F2 ◦ F1, where F1 : R
D → RM, F2 : RM → R
D and M ≪ D. The chain
2. See https://en.wikipedia.org/wiki/Weinstein-Aronszajn_identity.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license834
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
rule gives J(F) = J(F2)J(F1), where J(F2) is D × M and J(F1) is M × D. Now we can apply our
determinant formula as follows:
det J(f) = det(ID + J(F)) = det(ID + J(F2)J(F1)) = det(IM + J(F1)J(F2)). (23.38)
Since the final determinant costs O(M3
), we can make the Jacobian determinant efficient by reducing
M, that is, by narrowing the bottleneck.
An example of the above is the planar flow of [RM15]. In this model, each residual block is an
MLP with one hidden layer and one hidden unit. That is,
f(u) = u + vσ(w⊤u + b), (23.39)
where v ∈ R
D, w ∈ R
D and b ∈ R are the parameters, and σ is the activation function. The residual
block is the composition of F1(u) = w⊤u + b and F2(z) = vσ(z), so M = 1. Their Jacobians
are J(F1)(u) = w⊤ and J(F2)(z) = vσ
′
(z). Substituting these in the formula for the Jacobian
determinant we obtain:
det J(f)(u) = 1 + w⊤vσ
′
(w⊤u + b), (23.40)
which can be computed efficiently in O(D). Other examples include the circular flow of [RM15]
and the Sylvester flow of [Ber+18].
This technique gives an efficient way of computing determinants of residual connections with
bottlenecks, but in general there is no guarantee that such functions are invertible. This means that
invertibility must be satisfied on a case-by-case basis. For example, the planar flow is invertible when
σ is the hyperbolic tangent and w⊤v > −1, but otherwise it may not be.
23.2.6 Continuous-time flows
So far we have discussed flows that consist of a sequence of bijections f1, . . . , fN . Starting from some
input x0 = u, this creates a sequence of outputs x1, . . . , xN where xn = fn(xn−1). However, we can
also have flows where the input is transformed into the final output in a continuous way. That is,
we start from x0 = x(0), create a continuously-indexed sequence x(t) for t ∈ [0, T] with some fixed
T, and take x(T) to be the final output. Thinking of t as analogous to time, we refer to these as
continuous-time flows.
The sequence x(t) is defined as the solution to a first-order ordinary differential equation (ODE)
of the form:
dx
dt (t) = F(x(t), t). (23.41)
The function F : R
D × [0, T] → R
D is a time-dependent vector field that parameterizes the ODE. If
we think of x(t) as the position of a particle in D dimensions, the vector F(x(t), t) determines the
particle’s velocity at time t.
The flow (for time T) is a function f : R
D → R
D that takes in an input x0, solves the ODE
with initial condition x(0) = x0, and returns x(T). The function f is a well-defined bijection if the
solution to the ODE exists for all t ∈ [0, T] and is unique. These conditions are not generally satisfied
for arbitrary F, but they are if F(·, t) is Lipschitz continuous with a Lipschitz constant that does not
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
23.2. CONSTRUCTING FLOWS
depend on t. That is, f is a well-defined bijection if there exists a constant L such that for all x1, x2
and t ∈ [0, T] we have:
kF(x1, t) − F(x2, t)k ≤ Lkx1 − x2k. (23.42)
This result is a consequence of the Picard-Lindelöf theorem for ODEs.3
In practice, we can
parameterize F using any choice of model, provided the Lipschitz condition is met.
Usually the ODE cannot be solved analytically, but we can solve it approximately by discretizing
it. A simple example is Euler’s method, which corresponds to the following discretization for some
small step size ǫ > 0:
x(t + ǫ) = x(t) + ǫF(x(t), t). (23.43)
This is equivalent to a residual connection with residual block ǫF(·, t), so the ODE solver can be
thought of as a deep residual network with O(T /ǫ) layers. A smaller step size leads to a more
accurate solution, but also to more computation. There are several other solution methods varying
in accuracy and sophistication, such as those in the broader Runge-Kutta family, some of which use
adaptive step sizes.
The inverse of f can be easily computed by solving the ODE in reverse. That is, to compute
f
−1
(xT ) we solve the ODE with initial condition x(T) = xT , and return x(0). Unlike some other
flows (such as autoregressive flows) which are more expensive to compute in one direction than in
the other, continuous-time flows require the same amount of computation in either direction.
In general, there is no analytical expression for the Jacobian determinant of f. However, we can
express it as the solution to a separate ODE, which we can then solve numerically. First, we define
ft : R
D → R
D to be the flow for time t, that is, the function that takes x0, solves the ODE with
initial condition x(0) = x0 and returns x(t). Clearly, f0 is the identity function and fT = f. Let us
define L(t) = log | det J(ft)(x0)|. Because f0 is the identity function, L(0) = 0, and because fT = f,
L(T) gives the Jacobian determinant of f that we are interested in. It can be shown that L satisfies
the following ODE:
dL
dt (t) = tr

J(F(·, t))(x(t))
. (23.44)
That is, the rate of change of L at time t is equal to the Jacobian trace of F(·, t) evaluated at x(t). So
we can compute L(T) by solving the above ODE with initial condition L(0) = 0. Moreover, we can
compute x(T) and L(T) simultaneously, by combining their two ODEs into a single ODE operating
on the extended space (x, L).
An example of a continuous-time flow is the neural ODE model of [Che+18c], which uses a
neural network to parameterize F. To avoid backpropagating gradients through the ODE solver,
which can be computationally demanding, they use the adjoint sensitivity method to express the
time evolution of the gradient with respect to x(t) as a separate ODE. Solving this ODE gives the
required gradients, and can be thought of as the continuous-time analog of backpropagation.
Another example is the FFJORD model of [Gra+19]. This is similar to the neural ODE model,
except that it uses the Hutchinson trace estimator to approximate the Jacobian trace of F(·, t).
This usage of the Hutchinson trace estimator is analogous to that in contractive residual flows
(Section 23.2.5.1), and it speeds up computation in exchange for a stochastic (but unbiased) estimate.
See also Section 25.4.4, where we discuss continuous time diffusion models.
3. See https://en.wikipedia.org/wiki/Picard-Lindel%C3%B6f_theorem
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license836
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
23.3 Applications
In this section, we highlight some applications of flows for canonical probabilistic machine learning
tasks.
23.3.1 Density estimation
Flow models allow exact density computation and can be used to fit multi-modal densities to
observed data. (see Figure 23.3 for an example). An early example is Gaussianization [CG00] who
applied this idea to fit low-dimensional densities. Tabak and Vanden-Eijnden [TVE10] and Tabak
and Turner [TT13] introduced the modern idea of flows (including the term ‘normalizing flows’),
describing a flow as a composition of simpler maps. Deep density models [RA13] was one of the
first to use neural networks for flows to parameterize high-dimensional densities. There has been a
rich line of follow-up work including NICE [DKB15] and Real NVP [DSDB17]. (NVP stands for
“non-volume-preserving”, which refers to the fact that the Jacobian of the transform is not unity.)
Masked autoregressive flows (Section 23.2.4.2) further improved performance on unconditional and
conditional density estimation tasks.
Flows can be used for hybrid models which model the joint density of inputs and targets p(x, y), as
opposed to discriminative classification models which just model the conditional p(y|x) and density
models which just model the marginal p(x). Nalisnick et al. [Nal+19b] proposed a flow-based hybrid
model using invertible mappings for representation learning and showed that the joint density p(x, y)
can be computed efficiently, which can be useful for downstream tasks such as anomaly detection,
semi-supervised learning and selective classification. Flow-based hybrid models are memory-efficient
since most of the parameters are in the invertible representation which are shared between the
discriminative and generative models; furthermore, the density p(x, y) can be computed in a single
forwards pass leading to computational savings. Residual flows [Che+19] use invertible residual
mappings [Beh+19] for hybrid modeling which further improves performance. Flows have also been
used to fit densities to embeddings [Zha+20b; CZG20] for anomaly detection tasks.
23.3.2 Generative modeling
Another task is generation, which involves generating novel samples from a fitted model p
∗
(x).
Generation is a popular downstream task for normalizing flows, which have been applied for different
data modalities including images, video, audio, text, and structured objects such as graphs and point
clouds. Images are arguably the most popular modality for deep generative models: GLOW [KD18b]
was one of the first flow-based models to generate compelling high-dimensional images, and has been
extended to video to produce RGB frames [Kum+19b]; residual flows [Che+19] have also been shown
to produce sharp images.
Oord et al. [Oor+18] used flows for audio synthesis by distilling WaveNet into an IAF (Sec￾tion 23.2.4.3), which enables faster sampling than WaveNet. Other flow models for audio include
WaveFLOW [PVC19] and FlowWaveNet [Kim+19], which directly speed up WaveNet using coupling
layers.
Flows have been also used for text. Tran et al. [Tra+19] define a discrete flow over a vocabulary
for language-modeling tasks. Another popular approach is to define a latent variable model with
discrete observation space but a continuous latent space. For example, Ziegler and Rush [ZR19a] use
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
23.3. APPLICATIONS
normalizing flows in latent space for language modeling.
23.3.3 Inference
Normalizing flows have been used for probabilistic inference. Rezende and Mohamed [RM15]
popularized normalizing flows in machine learning, and showed how they can be used for modeling
variational posterior distributions in latent variable models. Various extensions such as Householder
flows [TW16], inverse autoregressive flows [Kin+16], multiplicative normalizing flows [LW17], and
Sylvester flows [Ber+18] have been proposed for modeling the variational posterior for latent variable
models, as well as posteriors for Bayesian neural networks.
Flows have been used as complex proposal distributions for importance sampling; examples include
neural importance sampling [Mül+19b] and Boltzmann generators [Noé+19]. Hoffman et al. [Hof+19]
used flows to improve the performance of Hamiltonian Monte Carlo (Section 12.5) by defining bijective
transformations to transform random variables to simpler distributions and performing HMC in that
space instead.
Finally, flows can be used in the context of simulation-based inference, where the likelihood function
of the parameters is not available, but simulating data from the model is possible. The main idea is
to train a flow on data simulated from the model in order to approximate the posterior distribution
or the likelihood function. The flow model can also be used to guide simulations in order to make
inference more efficient [PSM19; GNM19]. This approach has been used for inference of simulation
models in cosmology [Als+19] and computational neuroscience [Gon+20].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license24 Energy-based models
This chapter is co-authored with Yang Song and Durk Kingma.
24.1 Introduction
We have now seen several ways of defining deep generative models, including VAEs (Chapter 21),
autoregressive models (Chapter 22), and normalizing flows (Chapter 23). All of the above models
can be formulated in terms of directed graphical models (Chapter 4), where we generate the data
one step at a time, using locally normalized distributions. In some cases, it is easier to specify a
distribution in terms of a set of constraints that valid samples must satisfy, rather than a generative
process. This can be done using an undirected graphical model (Chapter 4).
Energy-based models or EBM can be written as a Gibbs distribution as follows:
pθ(x) = exp(−Eθ(x))
Zθ
(24.1)
where Eθ(x) ≥ 0 is known as the energy function with parameters θ, and Zθ is the partition
function:
Zθ =
Z
exp(−Eθ(x)) dx (24.2)
This is constant wrt x but is a function of θ. Since EBMs do not usually make any Markov
assumptions (unlike graphical models), evaluating this integral is usually intractable. Consequently
we usually need to use approximate methods, such as annealed importance sampling, discussed in
Section 11.5.4.1.
The advantage of an EBM over other generative models is that the energy function can be any
kind of function that returns a non-negative scalar; it does not need to integrate to 1. This allows
one to use a variety of neural network architectures for defining the energy. As such, EBMs have
found wide applications in many fields of machine learning, including image generation [Ngi+11;
Xie+16; DM19b], discriminative learning [Gra+20b], natural processing [Mik+13; Den+20], density
estimation [Wen+19a; Son+19], and reinforcement learning [Haa+17; Haa+18a], to list a few. (More
examples can be found at https://github.com/yataobian/awesome-ebm.)840
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
energy A energy B energy A + B
Figure 24.1: Combining two energy functions in 2d by summation, which is equivalent to multiplying the
corresponding probability densities. We also illustrate some sampled trajectories towards high probability (low
energy) regions. From Figure 14 of [DM19a]. Used with kind permission of Yilun Du.
24.1.1 Example: products of experts (PoE)
As an example of why energy based models are useful, suppose we want to create a generative model
of proteins that are thermally stable at room temperature, and which bind to the COVID-19 spike
receptor. Suppose p1(x) can generate stable proteins and p2(x) can generate proteins that bind.
(For example, both of these models could be autoregressive sequence models, trained on different
datasets.) We can view each of these models as “experts” about a particular aspect of the data.
On their own, they are not an adequate model of the data that we have (or want to have), but we
can then combine them, to represent the conjunction of features, by computing a product of
experts (PoE) [Hin02]:
p12(x) =
1
Z12
p1(x)p2(x) (24.3)
This will assign high probability to proteins that are stable and which bind, and low probability to
all others. By contrast, a mixture of experts would either generate from p1 or from p2, but would
not combine features from both.
If the experts are represented as energy based models (EBM), then the PoE model is also an EBM,
with an energy given by
E12(x) = E1(x) + E2(x) (24.4)
Intuitively, we can think of each component of energy as a “soft constraint” on the data. This idea
is illustrated in Figure 24.1.
24.1.2 Computational difficulties
Although the flexibility of EBMs can provide significant modeling advantages, computation of the
likelihood and drawing samples from the model are generally intractable. In this chapter, we will
discuss a variety of approximate methods to solve these problems.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
24.2. MAXIMUM LIKELIHOOD TRAINING
24.2 Maximum likelihood training
The de facto standard for learning probabilistic models from iid data is maximum likelihood estimation
(MLE). Let pθ(x) be a probabilistic model parameterized by θ, and pD(x) be the underlying data
distribution of a dataset. We can fit pθ(x) to pD(x) by maximizing the expected log-likelihood
function over the data distribution, defined by
ℓ(θ) = Ex∼pD(x)
[log pθ(x)] (24.5)
as a function of θ. Here the expectation can be easily estimated with samples from the dataset.
Maximizing likelihood is equivalent to minimizing the KL divergence between pD(x) and pθ(x),
because
ℓ(θ) = −DKL (pD(x) k pθ(x)) + const (24.6)
where the constant is equal to Ex∼pD(x)
[log pD(x)] which does not depend on θ.
We cannot usually compute the likelihood of an EBM because the normalizing constant Zθ
is often intractable. Nevertheless, we can still estimate the gradient of the log-likelihood with
MCMC approaches, allowing for likelihood maximization with stochastic gradient ascent [You99]. In
particular, the gradient of the log-probability of an EBM decomposes as a sum of two terms:
∇θ log pθ(x) = −∇θEθ(x) − ∇θ log Zθ. (24.7)
The first gradient term, −∇θEθ(x), is straightforward to evaluate with automatic differentiation. The
challenge is in approximating the second gradient term, ∇θ log Zθ, which is intractable to compute
exactly. This gradient term can be rewritten as the following expectation:
∇θ log Zθ = ∇θ log Z
exp(−Eθ(x))dx (24.8)
(i)
=
Z
exp(−Eθ(x))dx
−1
∇θ
Z
exp(−Eθ(x))dx (24.9)
=
Z
exp(−Eθ(x))dx
−1 Z
∇θ exp(−Eθ(x))dx (24.10)
(ii)
=
Z
exp(−Eθ(x))dx
−1 Z
exp(−Eθ(x))(−∇θEθ(x))dx (24.11)
=
Z Z
exp(−Eθ(x))dx
−1
exp(−Eθ(x))(−∇θEθ(x))dx (24.12)
(iii)
=
Z
1
Zθ
exp(−Eθ(x))(−∇θEθ(x))dx (24.13)
(iv)
=
Z
pθ(x)(−∇θEθ(x))dx (24.14)
= Ex∼pθ(x)
[−∇θEθ(x)] , (24.15)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license842
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where steps (i) and (ii) are due to the chain rule of gradients, and (iii) and (iv) are from definitions
in Equations (24.1) and (24.2). Thus, we can obtain an unbiased Monte Carlo estimate of the
log-likelihood gradient by using
∇θ log Zθ ≃ −
1
S
X
S
s=1
∇θEθ(x˜s), (24.16)
where x˜s ∼ pθ(x), i.e., a random sample from the distribution over x given by the EBM. Therefore,
as long as we can draw random samples from the model, we have access to an unbiased Monte
Carlo estimate of the log-likelihood gradient, allowing us to optimize the parameters with stochastic
gradient ascent.
Much of the literature has focused on methods for efficient MCMC sampling from EBMs. We
discuss some of these methods below.
24.2.1 Gradient-based MCMC methods
Some efficient MCMC methods, such as Langevin MCMC (Section 12.5.6) or Hamiltonian Monte
Carlo (Section 12.5), make use of the fact that the gradient of the log-probability wrt x (known
as the score function) is equal to the (negative) gradient of the energy, and is therefore easy to
calculate:
∇x log pθ(x) = −∇xEθ(x) − ∇x log Zθ
| {z }
=0
= −∇xEθ(x). (24.17)
For example, when using Langevin MCMC to sample from pθ(x), we first draw an initial sample x
0
from a simple prior distribution, and then simulate an overdamped Langevin diffusion process for K
steps with step size ǫ > 0:
x
k+1 ← x
k +
ǫ
2
2
∇x log pθ(x
k
)
| {z }
=−∇xEθ(x)
+ǫz
k
, k = 0, 1, · · · , K − 1. (24.18)
where z
k ∼ N (0, I) is a Gaussian noise term. We show an example of this process in Figure 25.5d.
When ǫ → 0 and K → ∞, x
K is guaranteed to distribute as pθ(x) under some regularity conditions.
In practice we have to use a small finite ǫ, but the discretization error is typically negligible, or
can be corrected with a Metropolis-Hastings step (Section 12.2), leading to the Metropolis-adjusted
Langevin algorithm (Section 12.5.6).
24.2.2 Contrastive divergence
Running MCMC till convergence to obtain a sample x ∼ pθ(x) can be computationally expensive.
Therefore we typically need approximations to make MCMC-based learning of EBMs practical. One
popular method for doing so is contrastive divergence (CD) [Hin02]. In CD, one initializes the
MCMC chain from the datapoint x, and proceeds to perform MCMC for a fixed number of steps.
One can show that T steps of CD minimizies the following objective:
CDT = DKL (p0 k p∞) − DKL (pT k p∞) (24.19)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
24.2. MAXIMUM LIKELIHOOD TRAINING
where pT is the distribution over x after T MCMC updates, and p0 is the data distribution. Typically
we can get good results with a small value of T, sometimes just T = 1. We give the details below.
24.2.2.1 Fitting RBMs with CD
CD was initially developed to fit a special kind of latent variable EBM known as a restricted
Boltzmann machine (Section 4.3.3.2). This model was specifically designed to support fast block
Gibbs sampling, which is required by CD (and can also be exploited by standard MCMC-based
learning methods [AHS85].)
For simplicity, we will assume the hidden and visible nodes are binary, and we use 1-step contrastive
divergence. As discussed in Supplementary Section 4.3.1, the binary RBM has the following energy
function:
E(x, z; θ) = X
D
d=1
X
K
k=1
xdzkWdk +
X
D
d=1
xdbd +
X
K
k=1
zkck (24.20)
(Henceforth we will drop the unary (bias) terms, which can be emulated by clamping zk = 1 or xd = 1.)
This is a loglinear model where we have one binary feature per edge. Thus from Equation (4.135) the
gradient of the log-likelihood is given by the clamped expectations minus the unclamped expectations:
∂ℓ
∂wdk
=
1
N
X
N
n=1
E [xdzk|xn, θ] − E [xdzk|θ] (24.21)
We can rewrite the above gradient in matrix-vector form as follows:
∇w ℓ = EpD(x)p(z|x,θ)

xzT

− Ep(z,x|θ)

xzT

(24.22)
(We can derive a similar expression for the gradient of the bias terms by setting xd = 1 or zk = 1.)
The first term in the expression for the gradient in Equation (24.21), when x is fixed to a data
case, is sometimes called the clamped phase, and the second term, when x is free, is sometimes
called the unclamped phase. When the model expectations match the empirical expectations, the
two terms cancel out, the gradient becomes zero and learning stops.
We can also make a connection to the principle of Hebbian learning in neuroscience. In particular,
Hebb’s rule says that the strength of connection between two neurons that are simultaneously active
should be increased. (This theory is often summarized as “Cells that fire together wire together”.1
)
The first term in Equation (24.21) is therefore considered a Hebbian term, and the second term an
anti-Hebbian term, due to the sign change.
We can leverage the Markov structure of the bipartite graph to approximate the expectations as
follows:
zn ∼ p(z|xn, θ) (24.23)
x
′
n ∼ p(x|zn, θ) (24.24)
z
′
n ∼ p(z|x
′
n
, θ) (24.25)
1. See https://en.wikipedia.org/wiki/Hebbian_theory.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license844
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
...
Latent (Hidden) Variables
t = 0 (data) t = 1 (one-step reconstructions) T = (equilibrium samples)
Visible Variables
Figure 24.2: Illustration of contrastive divergence sampling for an RBM. The visible nodes are initialized
at an example drawn from the dataset. Then we sample a hidden vector, then another visible vector, etc.
Eventually (at “infinity”) we will be producing samples from the joint distribution p(x, z|θ).
We can think of x
′
n as the model’s best attempt at reconstructing xn after being encoded and then
decoded by the model. Such samples are sometimes called fantasy data. See Figure 24.2 for an
illustration. Given these samples, we then make the approximation
Ep(·|θ)

xzT

≈ xn(z
′
n
)
T
(24.26)
In practice, it is common to use E [z|x
′
n
] instead of a sampled value z
′
n
in the above expression, since
this reduces the variance. However, it is not valid to use E [z|xn] instead of sampling zn ∼ p(z|xn) in
Equation (24.23), because then each hidden unit would be able to pass more than 1 bit of information,
so it would not act as much of a bottleneck.
The whole procedure is summarized in Algorithm 24.1. For more details, see [Hin10; Swe+10].
Algorithm 24.1: CD-1 training for an RBM with binary hidden and visible units
1 Initialize weights W ∈ R
D×K randomly
2 for t = 1, 2, . . . do
3 for each minibatch of size B do
4 Set minibatch gradient to zero, g := 0
5 for each case xn in the minibatch do
6 Compute µn = E [z|xn,W]
7 Sample zn ∼ p(z|xn,W)
8 Sample x
′
n ∼ p(x|zn,W)
9 Compute µ
′
n = E [z|x
′
n
,W]
10 Compute gradient ∇W = (xn)(µn)
T − (x
′
n
)(µ
′
n
)
T
11 Accumulate g := g + ∇W
12 Update parameters W := W + ηt
1
B
g
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
24.2. MAXIMUM LIKELIHOOD TRAINING
24.2.2.2 Persistent CD
One variant of CD that sometimes performs better is persistent contrastive divergence (PCD)
[Tie08; TH09; You99]. In this approach, a single MCMC chain with a persistent state is employed
to sample from the EBM. In PCD, we do not restart the MCMC chain when training on a new
datapoint; rather, we carry over the state of the previous MCMC chain and use it to initialize a new
MCMC chain for the next training step. See Line 12 for some pseudocode. Hence there are two
dynamical processes running at different time scales: the states x change quickly, and the parameters
θ change slowly.
Algorithm 24.2: Persistent MCMC-SGD for fitting an EBM
1 Initialize parameters θ randomly
2 Initialize chains x˜1:S randomly
3 Initialize learning rate η
4 for t = 1, 2, . . . do
5 for xb in minibatch of size B do
6 gb = ∇θEθ(xb)
7 for sample s = 1 : S do
8 Sample x˜s ∼ MCMC(target = p(·|θ), init = x˜s, nsteps = N)
9 g˜s = ∇θEθ(x˜s)
10 gt = −(
1
B
PB
b=1 gb) − (
1
S
PS
s=1 g˜s)
11 θ := θ + ηgt
12 Decrease step size η
A theoretical justification for this was given in [You89], who showed that we can start the MCMC
chain at its previous value, and just take a few steps, because p(x|θt) is likely to be close to p(x|θt−1),
since we only changed the parameters by a small amount in the intervening SGD step.
24.2.2.3 Other methods
PCD can be further improved by keeping multiple historical states of the MCMC chain in a replay
buffer and initialize new MCMC chains by randomly sampling from it [DM19b]. Other variants of
CD include mean field CD [WH02], and multi-grid CD [Gao+18].
EBMs trained with CD may not capture the data distribution faithfully, since truncated MCMC
can lead to biased gradient updates that hurt the learning dynamics [SMB10; FI10; Nij+19]. There
are several methods that focus on removing this bias for improved MCMC training. For example, one
line of work proposes unbiased estimators of the gradient through coupled MCMC [JOA17; QZW19];
and Du et al. [Du+20] propose to reduce the bias by differentiating through the MCMC sampling
algorithm and estimating an entropy correction term.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license846
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
24.3 Score matching (SM)
If two continuously differentiable real-valued functions f(x) and g(x) have equal first derivatives
everywhere, then f(x) ≡ g(x) + constant. When f(x) and g(x) are log probability density functions
(pdf’s) with equal first derivatives, the normalization requirement (Equation (24.1)) implies that
R
exp(f(x))dx =
R
exp(g(x))dx = 1, and therefore f(x) ≡ g(x). As a result, one can learn an EBM
by (approximately) matching the first derivatives of its log-pdf to the first derivatives of the log
pdf of the data distribution. If they match, then the EBM captures the data distribution exactly.
The first-order gradient function of a log pdf wrt its input, ∇x log pθ(x), is called the (Stein) score
function. (This is distinct from the Fisher score, ∇θ log pθ(x).) For training EBMs, it is useful to
transform the equivalence of distributions to the equivalence of scores, because the score of an EBM
can be easily obtained as follows:
sθ(x) , ∇x log pθ(x) = −∇xEθ(x) (24.27)
We see that this does not involve the typically intractable normalizing constant Zθ.
Let pD(x) be the underlying data distribution, from which we have a finite number of iid samples
but do not know its pdf. The score matching objective [Hyv05] minimizes a discrepancy between
two distributions called the Fisher divergence:
DF (pD(x) k pθ(x)) = EpD(x)

1
2
k∇x log pD(x) − ∇x log pθ(x)k
2

. (24.28)
The expectation wrt pD(x), in this objective and its variants below, admits a trivial unbiased Monte
Carlo estimator using the empirical mean of samples x ∼ pD(x). However, the second term of
Equation (24.28), ∇x log pD(x), is generally impractical to calculate since it requires knowing the
pdf of pD(x). We discuss a solution to this below.
24.3.1 Basic score matching
Hyvärinen [Hyv05] shows that, under certain regularity conditions, the Fisher divergence can be
rewritten using integration by parts, with second derivatives of Eθ(x) replacing the unknown first
derivatives of pD(x):
DF (pD(x) k pθ(x)) = EpD(x)
"
1
2
X
d
i=1

∂Eθ(x)
∂xi
2
−
∂
2Eθ(x)
∂x2
i
#
+ constant (24.29)
= EpD(x)

1
2
||sθ(x)||2 + tr(Jxsθ(x))
+ constant (24.30)
where d is the dimensionality of x, and Jxsθ(x) is the Jacobian of the score function. The constant
does not affect optimization and thus can be dropped for training. It is shown by [Hyv05] that
estimators based on score matching are consistent under some regularity conditions, meaning that
the parameter estimator obtained by minimizing Equation (24.28) converges to the true parameters
in the limit of infinite data. See Figure 25.5 for an example.
An important downside of the objective Equation (24.30) is that it takes O(d
2
) time to compute
the trace of the Jacobian. For this reason, the implicit SM formulation of Equation (24.30) has only
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
24.3. SCORE MATCHING (SM)
been applied to relatively simple energy functions where computation of the second derivatives is
tractable.
Score Matching assumes a continuous data distribution with positive density over the space, but it
can be generalized to discrete or bounded data distributions [Hyv07b; Lyu12]. It is also possible to
consider higher-order gradients of log pdf’s beyond first derivatives [PDL+12].
24.3.2 Denoising score matching (DSM)
The Score Matching objective in Equation (24.30) requires several regularity conditions for log pD(x),
e.g., it should be continuously differentiable and finite everywhere. However, these conditions may
not always hold in practice. For example, a distribution of digital images is typically discrete and
bounded, because the values of pixels are restricted to the range {0, 1, · · · , 255}. Therefore, log pD(x)
in this case is discontinuous and is negative infinity outside the range, and thus SM is not directly
applicable.
To alleviate this, one can add a bit of noise to each datapoint: x˜ = x + ǫ. As long as the noise
distribution p(ǫ) is smooth, the resulting noisy data distribution q(x˜) = R
q(x˜ | x)pD(x)dx is also
smooth, and thus the Fisher divergence DF (q(x˜) k pθ(x˜)) is a proper objective. [KL10] showed that
the objective with noisy data can be approximated by the noiseless Score Matching objective of
Equation (24.30) plus a regularization term; this regularization makes Score Matching applicable to
a wider range of data distributions, but still requires expensive second-order derivatives.
[Vin11] proposed an elegant and scalable solution to the above difficulty, by showing that:
DF (q(x˜) k pθ(x˜)) = Eq(x˜)

1
2
k∇x log pθ(x˜) − ∇x log q(x˜)k
2
2

(24.31)
= Eq(x,x˜)

1
2
k∇x log pθ(x˜) − ∇x log q(x˜|x)k
2
2

+ constant (24.32)
=
1
2
Eq(x,x˜)
"



sθ(x˜) +
(x˜ − x)
σ
2




2
2
#
(24.33)
where sθ(x˜) = ∇x log pθ(x˜) is the estimated score function, and
∇x log q(x˜|x) = ∇x log N (x˜|x, σ2
I) = (x˜ − x)
σ
2
(24.34)
The expectation can be approximated by sampling from pD(x) and then sampling the noise term x˜.
(The constant term does not affect optimization and can be ignored without changing the optimal
solution.)
This estimation method is called denoising score matching (DSM) by [Vin11]. Similar formula￾tions were also explored by Raphan and Simoncelli [RS07; RS11] and can be traced back to Tweedie’s
formula (Supplementary Section 3.3) and Stein’s unbiased risk estimation [Ste81].
24.3.2.1 Difficulties
The major drawback of adding noise to data arises when pD(x) is already a well-behaved distribution
that satisfies the regularity conditions required by score matching. In this case, DF (q(x˜) k pθ(x˜)) 6=
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license848
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
DF (pD(x) k pθ(x)), and DSM is not a consistent objective because the optimal EBM matches the
noisy distribution q(x˜), not pD(x). This inconsistency becomes non-negligible when q(x˜) significantly
differs from pD(x).
One way to attenuate the inconsistency of DSM is to choose q ≈ pD, i.e., use a small noise
perturbation. However, this often significantly increases the variance of objective values and hinders
optimization. As an example, suppose q(x˜ | x) = N (x˜ | x, σ2
I) and σ ≈ 0. The corresponding DSM
objective is
DF (q(x˜) k pθ(x˜)) = EpD(x)Ez∼N(0,I)

1
2



z
σ
+ ∇x log pθ(x + σz)



2
2

≃
1
2N
X
N
i=1




z
(i)
σ
+ ∇x log pθ(x
(i) + σz
(i)
)




2
2
, (24.35)
where {x
(i)}
N
i=1
i.i.d. ∼ pD(x), and {z
(i)}
N
i=1
i.i.d. ∼ N (0, I). When σ → 0, we can leverage Taylor series
expansion to rewrite the Monte Carlo estimator in Equation (24.35) to
1
2N
X
N
i=1

2
σ
(z
(i)
)
T∇x log pθ(x
(i)
) +

z
(i)


2
2
σ
2

+ constant. (24.36)
When estimating the above expectation with samples, the variances of (z
(i)
)
T∇x log pθ(x
(i)
)/σ and

z
(i)


2
2
/σ2 will both grow unbounded as σ → 0 due to division by σ and σ
2
. This enlarges the
variance of DSM and makes optimization challenging. Various methods have been proposed to reduce
this variance (see e.g., [Wan+20d]).
24.3.3 Sliced score matching (SSM)
By adding noise to data, DSM avoids the expensive computation of second-order derivatives. However,
as mentioned before, the optimal EBM that minimizes the DSM objective corresponds to the
distribution of noise-perturbed data q(x˜), not the original noise-free data distribution pD(x). In
other words, DSM does not give a consistent estimator of the data distribution, i.e., one cannot
directly obtain an EBM that exactly matches the data distribution even with unlimited data.
Sliced score matching (SSM) [Son+19] is one alternative to Denoising Score Matching that is
both consistent and computationally efficient. Instead of minimizing the Fisher divergence between
two vector-valued scores, SSM randomly samples a projection vector v, takes the inner product
between v and the two scores, and then compares the resulting two scalars. More specifically, sliced
ccore matching minimizes the following divergence called the sliced Fisher divergence:
DSF (pD(x)||pθ(x)) = EpD(x)Ep(v)

1
2
(v
T∇x log pD(x) − v
T∇x log pθ(x))
2

, (24.37)
where p(v) denotes a projection distribution such that Ep(v)
[vvT] is positive definite. Similar to
Fisher divergence, sliced Fisher divergence has an implicit form that does not involve the unknown
∇x log pD(x), which is given by
DSF (pD(x)kpθ(x)) = EpD(x)Ep(v)


1
2
X
d
i=1

∂Eθ(x)
∂xi
vi
2
+
X
d
i=1
X
d
j=1
∂
2Eθ(x)
∂xi∂xj
vivj

 + C. (24.38)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
24.3. SCORE MATCHING (SM)
All expectations in the above objective can be estimated with empirical means, and again the
constant term C can be removed without affecting training. The second term involves second-order
derivatives of Eθ(x), but contrary to SM, it can be computed efficiently with a cost linear in the
dimensionality d. This is because
X
d
i=1
X
d
j=1
∂
2Eθ(x)
∂xi∂xj
vivj =
X
d
i=1
∂
∂xi
X
d
j=1
∂Eθ(x)
∂xj
vj

| {z }
:=f(x)
vi
, (24.39)
where f(x) is the same for different values of i. Therefore, we only need to compute it once with
O(d) computation, plus another O(d) computation for the outer sum to evaluate Equation (24.39),
whereas the original SM objective requires O(d
2
) computation.
For many choices of p(v), part of the SSM objective (Equation (24.38)) can be evaluated in closed
form, potentially leading to lower variance. For example, when p(v) = N (0, I), we have
EpD(x)Ep(v)
"
1
2
X
d
i=1

∂Eθ(x)
∂xi
vi
2
#
= EpD(x)
"
1
2
X
d
i=1

∂Eθ(x)
∂xi
2
#
(24.40)
and as a result,
DSF (pD(x)kpθ(x)) = EpD(x)Ev∼N(0,I)


1
2
X
d
i=1

∂Eθ(x)
∂xi
2
+
X
d
i=1
X
d
j=1
∂
2Eθ(x)
∂xi∂xj
vivj

 + C (24.41)
= EpD(x)Ev∼N(0,I)

1
2
(v
T
sθ(x))2 + v
T
[Jv]

(24.42)
where J = Jxsθ(x). (Note that Jv can be computed using a Jacobian vector product operation.)
The above objective Equation (24.41) can also be obtained by approximating the sum of second-order
gradients in the standard SM objective (Equation (24.30)) with the Hutchinson trace estimator [Ski89;
Hut89; Mey+21]. It often (but not always) has lower variance than Equation (24.38), and can
perform better in some applications [Son+19].
24.3.4 Connection to contrastive divergence
Though score matching and contrastive divergence (Section 24.2.2) are seemingly very different
approaches, they are closely connected to each other. In fact, score matching can be viewed as
a special instance of contrastive divergence in the limit of a particular MCMC sampler [Hyv07a].
Moreover, the Fisher divergence optimized by Score Matching is related to the derivative of KL
divergence [Cov99], which is the underlying objective of Contrastive Divergence.
Contrastive divergence requires sampling from the EBM Eθ(x), and one popular method for doing
so is Langevin MCMC. Recall from Section 24.2.1 that given any initial datapoint x
0
, the Langevin
MCMC method executes the following
x
k+1 ← x
k −
ǫ
2
∇xEθ(x
k
) + √
ǫ z
k
, (24.43)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license850
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
iteratively for k = 0, 1, · · · , K − 1, where z
k ∼ N (0, I) and ǫ > 0 is the step size.
Suppose we only run one-step Langevin MCMC for contrastive divergence. In this case, the
gradient of the log-likelihood is given by
EpD(x)
[∇θ log pθ(x)] = −EpD(x)
[∇θEθ(x)] + Ex∼pθ(x)
[∇θEθ(x)]
≃ −EpD(x)
[∇θEθ(x)] + Epθ(x),z∼N(0,I)

∇θEθ

x −
ǫ
2
2
∇xEθ
′ (x) + ǫ z




θ
′=θ

. (24.44)
After Taylor series expansion with respect to ǫ followed by some algebraic manipulations, the above
equation can be transformed to the following [Hyv07a]:
ǫ
2
2
∇θDF (pD(x) k pθ(x)) + o(ǫ
2
). (24.45)
When ǫ is sufficiently small, it corresponds to the re-scaled gradient of the score matching objective.
In general, score matching minimizes the Fisher divergence DF (pD(x) k pθ(x)), whereas Contrastive
Divergence minimizes an objective related to the KL divergence DKL(pD(x) k pθ(x)), as shown in
Equation (24.19). The above connection of score matching and Contrastive Divergence is a natural
consequence of the connection between those two statistical divergences, as characterized by de
Bruijin’s identity [Cov99; Lyu12]:
d
dtDKL(qt(x˜) k pθ,t(x˜)) = −
1
2
DF (qt(x˜) k pθ,t(x˜)).
Here qt(x˜) and pθ,t(x˜) denote smoothed versions of pD(x) and pθ(x), resulting from adding Gaussian
noise to x with variance t; i.e., x˜ ∼ N (x, tI).
24.3.5 Score-based generative models
We have seen how to use score matching to fit EBMs by learning the scalar energy function Eθ(x).
We can alternatively directly learn the score function, sθ(x) = ∇x log pθ(x); this is called a score￾based generative model, and is discussed in Section 25.3. Such unconstrained score models are not
guaranteed to output a conservative vector field, meaning they do not correspond to the gradient of
any function. However, both methods seem to give comparable results [SH21].
24.4 Noise contrastive estimation
Another principle for learning the parameters of EBMs is Noise contrastive estimation (NCE),
introduced by [GH10]. It is based on the idea that we can learn an EBM by contrasting it with
another distribution with known density.
Let pD(x) be our data distribution, and let pn(x) be a chosen distribution with known density,
called a noise distribution. This noise distribution is usually simple and has a tractable pdf, like
N (0, I), such that we can compute the pdf and generate samples from it efficiently. Strategies exist
to learn the noise distribution, as referenced below. Furthermore, let y be a binary variable with
Bernoulli distribution, which we use to define a mixture distribution of noise and data: pn,data(x) =
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
24.4. NOISE CONTRASTIVE ESTIMATION
p(y = 0)pn(x) + p(y = 1)pD(x). According to Bayes’ rule, given a sample x from this mixture, the
posterior probability of y = 0 is
pn,data(y = 0 | x) = pn,data(x | y = 0)p(y = 0)
pn,data(x)
=
pn(x)
pn(x) + νpD(x)
(24.46)
where ν = p(y = 1)/p(y = 0).
Let our EBM pθ(x) be defined as:
pθ(x) = exp(−Eθ(x))/Zθ (24.47)
Contrary to most other EBMs, Zθ is treated as a learnable (scalar) parameter in NCE. Given this
model, similar to the mixture of noise and data above, we can define a mixture of noise and the
model distribution: pn,θ(x) = p(y = 0)pn(x) + p(y = 1)pθ(x). The posterior probability of y = 0
given this noise/model mixture is:
pn,θ(y = 0 | x) = pn(x)
pn(x) + νpθ(x)
(24.48)
In NCE, we indirectly fit pθ(x) to pD(x) by fitting pn,θ(y | x) to pn,data(y | x) through a standard
conditional maximum likelihood objective:
θ
∗ = argmin
θ
Epn,data(x)
[DKL(pn,data(y | x) k pn,θ(y | x))] (24.49)
= argmax
θ
Epn,data(x,y)
[log pn,θ(y | x)], (24.50)
which can be solved using stochastic gradient ascent. Just like any other deep classifier, when the
model is sufficiently powerful, pn,θ
∗ (y | x) will match pn,data(y | x) at the optimum. In that case:
pn,θ
∗ (y = 0 | x) ≡ pn,data(y = 0 | x) (24.51)
⇐⇒
pn(x)
pn(x) + νpθ
∗ (x)
≡
pn(x)
pn(x) + νpD(x)
(24.52)
⇐⇒ pθ
∗ (x) ≡ pD(x) (24.53)
Consequently, Eθ
∗ (x) is an unnormalized energy function that matches the data distribution pD(x),
and Zθ
∗ is the corresponding normalizing constant.
As one unique feature that contrastive divergence and score matching do not have, NCE provides
the normalizing constant of an Energy-Based Model as a by-product of its training procedure. When
the EBM is very expressive, e.g., a deep neural network with many parameters, we can assume
it is able to approximate a normalized probability density and absorb Zθ into the parameters
of Eθ(x) [MT12], or equivalently, fixing Zθ = 1. The resulting EBM trained with NCE will be
self-normalized, i.e., having a normalizing constant close to 1.
In practice, choosing the right noise distribution pn(x) is critical to the success of NCE, especially
for structured and high-dimensional data. As argued in Gutmann and Hirayama [GH12], NCE
works the best when the noise distribution is close to the data distribution (but not exactly the
same). Many methods have been proposed to automatically tune the noise distribution, such
as Adversarial Contrastive Estimation [BLC18], Conditional NCE [CG18] and Flow Contrastive
Estimation [Gao+20]. NCE can be further generalized using Bregman divergences (Section 5.1.10),
where the formulation introduced here reduces to a special case.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license852
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
24.4.1 Connection to score matching
Noise contrastive estimation provides a family of objectives that vary for different pn(x) and ν. This
flexibility may allow adaptation to special properties of a task with hand-tuned pn(x) and ν, and
may also give a unified perspective for different approaches. In particular, when using an appropriate
pn(x) and a slightly different parameterization of pn,θ(y | x), we can recover score matching from
NCE [GH12].
Specifically, we choose the noise distribution pn(x) to be a perturbed data distribution: given a
small (deterministic) vector v, let pn(x) = pD(x − v). It is efficient to sample from this pn(x), since
we can first draw any datapoint x
′ ∼ pD(x
′
) and then compute x = x
′ + v. It is, however, difficult
to evaluate the density of pn(x) because pD(x) is unknown. Since the original parameterization of
pn,θ(y | x) in NCE (Equation (24.48)) depends on the pdf of pn(x), we cannot directly apply the
standard NCE objective. Instead, we replace pn(x) with pθ(x − v) and parameterize pn,θ(y = 0 | x)
with the following form
pn,θ(y = 0 | x) := pθ(x − v)
pθ(x) + pθ(x − v)
(24.54)
In this case, the NCE objective (Equation (24.50)) reduces to:
θ
∗ = argmin
θ
EpD(x)
[log(1 + exp(Eθ(x) − Eθ(x − v)) + log(1 + exp(Eθ(x) − Eθ(x + v))]
(24.55)
At θ
∗
, we have a solution where:
pn,θ
∗ (y = 0 | x) ≡ pn,data(y = 0 | x) (24.56)
=⇒
pθ
∗ (x − v)
pθ
∗ (x) + pθ
∗ (x − v)
≡
pD(x − v)
pD(x) + pD(x − v)
(24.57)
which implies that pθ
∗ (x) ≡ pD(x), i.e., our model matches the data distribution.
As noted in Gutmann and Hirayama [GH12] and Song et al. [Son+19], when kvk2 ≈ 0, the NCE
objective Equation (24.50) has the following equivalent form by Taylor expansion
argmin
θ
1
4
EpD(x)


1
2
X
d
i=1

∂Eθ(x)
∂xi
vi
2
+
X
d
i=1
X
d
j=1
∂
2Eθ(x)
∂xi∂xj
vivj

 + 2 log 2 + o(kvk
2
2
). (24.58)
Comparing against Equation (24.38), we immediately see that the above objective equals that of
SSM, if we ignore small additional terms hidden in o(kvk
2
2
) and take the expectation with respect to
v over a user-specified distribution p(v).
24.5 Other methods
Aside from MCMC-based training, score matching and noise contrastive estimation, there are also
other methods for learning EBMs. Below we briefly survey some examples of them. Interested readers
can learn more details from references therein.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
24.5. OTHER METHODS
24.5.1 Minimizing Differences/Derivatives of KL Divergences
The overarching strategy for learning probabilistic models from data is to minimize the KL divergence
between data and model distributions. However, because the normalizing constants of EBMs are
typically intractable, it is hard to directly evaluate the KL divergence when the model is an EBM (see
the discussion in Section 24.2.1). One generic idea that has frequently circumvented this difficulty
is to consider differences/derivatives of KL divergences. It turns out that the unknown partition
functions of EBMs are often cancelled out after taking the difference of two closely related KL
divergences, or computing the derivatives.
Typical examples of this strategy include minimum velocity learning [Mov08; Wan+20d], minimum
probability flow [SDBD11], and minimum KL contraction [Lyu11], to name a few. In minimum
velocity learning and minimum probability flow, a Markov chain is designed such that it starts from
the data distribution pD(x) and converges to the EBM distribution pθ(x) = e
−Eθ(x)/Zθ. Specifically,
the Markov chain satisfies p0(x) ≡ pD(x) and p∞(x) ≡ pθ(x), where we denote by pt(x) the state
distribution at time t ≥ 0.
This Markov chain will evolve towards pθ(x) unless pD(x) ≡ pθ(x). Therefore, we can fit the EBM
distribution pθ(x) to pD(x) by minimizing the modulus of the “velocity” of this evolution, defined by
d
dt
DKL(pt(x) k pθ(x))




t=0
or
d
dt
DKL(pD(x) k pt(x))




t=0
(24.59)
in minimum velocity learning and minimum probability flow respectively. These objectives typically
do not require computing the normalizing constant Zθ.
In minimum KL contraction [Lyu11], a distribution transformation Φ is chosen such that
DKL(p(x) k q(x)) ≥ DKL(Φ{p(x)} k Φ{q(x)}) (24.60)
with equality if and only if p(x) = q(x). We can leverage this Φ to train an EBM, by minimizing
DKL(pD(x) k pθ(x)) − DKL(Φ{pD(x)} k Φ{pθ(x)}). (24.61)
This objective does not require computing the partition function Zθ whenever Φ is linear.
Minimum velocity learning, minimum probability flow, and minimum KL contraction can all
be viewed as generalizations to score matching and noise contrastive estimation [Mov08; SDBD11;
Lyu11].
24.5.2 Minimizing the Stein discrepancy
We can train EBMs by minimizing the Stein discrepancy, defined by
DStein(pD(x) k pθ(x)) := sup
f∈F
EpD(x)
[∇x log pθ(x)
T
f(x) + trace(∇xf(x))], (24.62)
where F is a family of vector-valued functions, and ∇xf(x) denotes the Jacobian of f(x). With
some regularity conditions [GM15; LLJ16], we have DS(pD(x) k pθ(x)) ≥ 0, where the equality
holds if and only if pD(x) ≡ pθ(x). Similar to score matching (Equation (24.30)), the objective
Equation (24.62) only involves the score function of pθ(x), and does not require computing the EBM’s
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license854
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
partition function. Still, the trace term in Equation (24.62) may demand expensive computation,
and does not scale well to high dimensional data.
There are two common methods that sidestep this difficulty. Gorham and Mackey [GM15] and
Liu, Lee, and Jordan [LLJ16] discovered that when F is a unit ball in a reproducing kernel Hilbert
space (RKHS) with a fixed kernel, the Stein discrepancy becomes kernelized Stein discrepancy, where
the trace term is a constant and does not affect optimization. Otherwise, trace(∇xf(x)) can be
approximated with the Skilling-Hutchinson trace estimator [Ski89; Hut89; Gra+20c].
24.5.3 Adversarial training
Recall from Section 24.2.1 that when training EBMs with maximum likelihood estimation (MLE),
we need to sample from the EBM per training iteration. However, sampling using multiple MCMC
steps is expensive and requires careful tuning of the Markov chain. One way to avoid this difficulty
is to use non-MLE methods that do not need sampling, such as score matching and noise contrastive
estimation. Here we introduce another family of methods that sidestep costly MCMC sampling by
learning an auxiliary model through adversarial training, which allows fast sampling.
Using the definition of EBMs, we can rewrite the maximum likelihood objective by introducing a
variational distribution qφ(x) parameterized by φ:
EpD(x)
[log pθ(x)] = EpD(x)
[−Eθ(x)] − log Zθ
= EpD(x)
[−Eθ(x)] − log Z
e
−Eθ(x)dx
= EpD(x)
[−Eθ(x)] − log Z
qφ(x)
e
−Eθ(x)
qφ(x)
dx
(i)
≤ EpD(x)
[−Eθ(x)] −
Z
qφ(x)log e
−Eθ(x)
qφ(x)
dx
= EpD(x)
[−Eθ(x)] − Eqφ(x)
[−Eθ(x)] − H(qφ(x)), (24.63)
where H(qφ(x)) denotes the entropy of qφ(x). Step (i) is due to Jensen’s inequality. Equation (24.63)
provides an upper bound to the expected log-likelihood. For EBM training, we can first minimize the
upper bound Equation (24.63) with respect to qφ(x) so that it is closer to the likelihood objective,
and then maximize Equation (24.63) with respect to Eθ(x) as a surrogate for maximizing likelihood.
This amounts to using the following maximin objective
max
θ
min
φ
Eqφ(x)
[Eθ(x)] − EpD(x)
[Eθ(x)] − H(qφ(x)). (24.64)
Optimizing the above objective is similar to training GANs (Chapter 26), and can be achieved by
adversarial training. The variational distribution qφ(x) should allow both fast sampling and efficient
entropy evaluation to make Equation (24.64) tractable. This limits the model family of qφ(x), and
usually restricts our choice to invertible probabilistic models, such as inverse autoregressive flow
(Section 23.2.4.3). See Dai et al. [Dai+19b] for an example on designing qφ(x) and training EBMs
with Equation (24.64).
Kim and Bengio [KB16] and Zhai et al. [Zha+16] propose to represent qφ(x) with neural samplers,
like the generator of GANs. A neural sampler is a deterministic mapping gφ that maps a random
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
24.5. OTHER METHODS
Gaussian noise z ∼ N (0, I) directly to a sample x = gφ(z). When using a neural sampler as qφ(x),
it is efficient to draw samples through the deterministic mapping, but H(qφ(x)) is intractable since
the density of qφ(x) is unknown. Kim and Bengio [KB16] and Zhai et al. [Zha+16] propose several
heuristics to approximate this entropy function. Kumar et al. [Kum+19c] propose to estimate
the entropy through its connection to mutual information: H(qφ(z)) = I(gφ(z), z), which can be
estimated from samples with variational lower bounds [NWJ10b; NCT16b]. Dai et al. [Dai+19a]
noticed that when defining pθ(x) = p0(x)e
−Eθ(x)/Zθ, with p0(x) being a fixed base distribution, the
entropy term −H(qφ(x)) in Equation (24.64) can be replaced by DKL(qφ(x) k p0(x)), which can
also be approximated with variational lower bounds using samples from qφ(x) and p0(x), without
requiring the density of qφ(x).
Grathwohl et al. [Gra+20a] represent qφ(x) as a noisy neural sampler, where samples are obtained
via gφ(z) + σǫ, assuming z, ǫ ∼ N (0, I). With a noisy neural sampler, ∇φH(qφ(x)) becomes
particularly easy to estimate, which allows gradient-based optimization for the minimax objective in
Equation (24.63). A related approach is proposed in Xie et al. [Xie+18], where authors train a noisy
neural sampler with samples obtained from MCMC, and initialize new MCMC chains with samples
generated from the neural sampler. This cooperative sampling scheme improves the convergence of
MCMC, but may still require multiple MCMC steps for sample generation. It does not optimize the
objective in Equation (24.63).
When using both adversarial training and MCMC sampling, Yu et al. [Yu+20] noticed that EBMs
can be trained with an arbitrary f-divergence, including KL, reverse KL, total variation, Hellinger,
etc. The method proposed by Yu et al. [Yu+20] allows us to explore the trade-offs and inductive bias
of different statistical divergences for more flexible EBM training.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license25 Diffusion models
25.1 Introduction
In this chapter, we consider a class of models called diffusion models. This class of models has
recently generated a lot of interest, due to its ability to generate diverse, high quality, samples, and
the relative simplicity of the training scheme, which allows very large models to be trained at scale.
Diffusion models are closely related to VAEs (Chapter 21), normalizing flows (Chapter 23), and
EBMs (Chapter 24), as we will see.
The basic idea behind these models is based on the observation that it is hard to convert noise
into structured data, but it is easy to convert structured data into noise. In particular, we can
use a forwards process or diffusion process to gradually convert the observed data x0 into a
noisy version xT by passing the data through T steps of a stochastic encoder q(xt|xt−1). After
enough steps, we have xT ∼ N (0, I), or some other convenient reference distribution. We then learn
a reverse process to undo this, by passing the noise through T steps of a decoder pθ(xt−1|xt)
until we generate x0. See Figure 25.1 for an overall sketch of the approach. In the following
sections, we discuss this class of models in more detail. Our presentation is based in part on
the excellent tutorial [KGV22]. More details can be found in the recent review papers [Yan+22;
Cao+22], as well as specialized papers, such as [Kar+22]. There are also many other excellent
resources online, such as https://github.com/heejkoo/Awesome-Diffusion-Models and https:
//scorebasedgenerativemodeling.github.io/. For a detailed tutorial on the underlying math,
see [McA23].
25.2 Denoising diffusion probabilistic models (DDPMs)
In this section, we discuss denoising diffusion probabilistic models or DDPMs, introduced in
[SD+15b], and then extended in [HJA20; Kin+21] and many other works. We can think of the
DDPM as similar to a hierarchical variational autoencoder (Section 21.5), except that all the latent
states (denoted xt for t = 1 : T) have the same dimensionality as the input x0. (In this respect,
a DDPM is similar to a normalizing flow (Chapter 23); however, in a diffusion model, the hidden
layers are stochastic, and do not need to use invertible transformations.) In addition, the encoder
network q is a simple linear Gaussian model, rather than being learned1
, and the decoder network p
is shared across all time steps. These restrictions result in a very simple training objective, which
1. Later we will discuss some extensions in which the noise level of the encoder can also be learned. Nevertheless, the
encoder remains simple, by design.858
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 25.1: Denoising diffusion probabilistic model. The forwards diffusion process, q(xt|xt−1), implements
the (non-learned) inference network; this just adds Gaussian noise at each step. The reverse diffusion process,
pθ(xt−1|xt), implements the decoder; this is a learned Gaussian model. From Slide 16 of [KGV22]. Used
with kind permission of Arash Vahdat.
xt
q(x0
) q(x1
) q(x2
) q(x3
) q(xT
)
Diffused Data Distributions
…
Data Noise
Figure 25.2: Illustration of a diffusion model on 1d data. The forwards diffusion process gradually transforms
the empirical data distribution q(x0) into a simple target distribution, here q(xT ) = N (0, I). To generate
from the model, we sample a point xT ∼ N (0, I), and then run the Markov chain backwards, by sampling
xt ∼ pθ(xt|xt+1) until we get a sample in the original data space, x0. From Slide 19 of [KGV22]. Used with
kind permission of Arash Vahdat.
allows deep models to be easily trained without any risk of posterior collapse (Section 21.4). In
particular, in Section 25.2.3, we will see that training reduces to a series of weighted nonlinear least
squares problems.
25.2.1 Encoder (forwards diffusion)
The forwards encoder process is defined to be a simple linear Gaussian model:
q(xt|xt−1) = N (xt|
p
1 − βtxt−1, βtI) (25.1)
where the values of βt ∈ (0, 1) are chosen according to a noise schedule (see Section 25.2.4). The
joint distribution over all the latent states, conditioned on the input, is given by
q(x1:T |x0) = Y
T
t=1
q(xt|xt−1) (25.2)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
25.2. DENOISING DIFFUSION PROBABILISTIC MODELS (DDPMS)
Since this defines a linear Gaussian Markov chain, we can compute marginals of it in closed form. In
particular, we have
q(xt|x0) = N (xt|
√
αtx0,(1 − αt)I) (25.3)
where we define
αt , 1 − βt, αt =
Yt
s=1
αs (25.4)
We choose the noise schedule such that αT ≈ 0, so that q(xT |x0) ≈ N (0, I).
The distribution q(xt|x0) is known as the diffusion kernel. Applying this to the input data
distribution and then computing the result unconditional marginals is equivalent to Gaussian
convolution:
q(xt) = Z
q0(x0)q(xt|x0)dx0 (25.5)
As t increases, the marginals become simpler, as shown in Figure 25.2. In the image domain, this
process will first remove high-frequency content (i.e., low-level details, such as texture), and later will
remove low-frequency content (i.e., high-level or “semantic” information, such as shape), as shown in
Figure 25.1.
25.2.2 Decoder (reverse diffusion)
In the reverse diffusion process, we would like to invert the forwards diffusion process. If we know
the input x0, we can derive the reverse of one forwards step as follows:2
q(xt−1|xt, x0) = N (xt−1|µ˜t(xt, x0), β˜
tI) (25.6)
µ˜t(xt, x0) =
√
αt−1βt
1 − αt
x0 +
√
αt(1 − αt−1)
1 − αt
xt (25.7)
β˜
t =
1 − αt−1
1 − αt
βt (25.8)
Of course, when generating a new datapoint, we do not know x0, but we will train the generator
to approximate the above distribution averaged over x0. Thus we choose the generator to have the
form
pθ(xt−1|xt) = N (xt−1|µθ
(xt, t), Σθ(xt, t)) (25.9)
We often set Σθ(xt, t) = σ
2
t
I. We discuss how to learn σ
2
t
in Section 25.2.4, but two natural choices
are σ
2
t = βt and σ
2
t = β˜
t; these correspond to upper and lower bounds on the reverse process entropy,
as shown in [HJA20].
The corresponding joint distribution over all the generated variables is given by pθ(x0:T ) =
p(xT )
QT
t=1 pθ(xt−1|xt), where we set p(xT ) = N (0, I). We can sample from this distribution using
the pseudocode in Algorithm 25.2.
2. We just need to use Bayes’ rule for Gaussians. See e.g., https://lilianweng.github.io/posts/
2021-07-11-diffusion-models/ for a detailed derivation.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license860
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
25.2.3 Model fitting
We will fit the model by maximizing the evidence lower bound (ELBO), similar to how we train
VAEs (see Section 21.2). In particular, for each data example x0 we have
log pθ(x0) = log Z
dx1:T q(x1:T |x0)
pθ(x0:T )
q(x1:T |x0)

(25.10)
≥
Z
dx1:T q(x1:T |x0) log 
p(xT )
Y
T
t=1
pθ(xt−1|xt)
q(xt|xt−1)
!
(25.11)
= Eq
"
log p(xT ) +
X
T
t=1
log pθ(xt−1|xt)
q(xt|xt−1)
#
, Ł(x0) (25.12)
We now discuss how to compute the terms in the ELBO. By the Markov property we have
q(xt|xt−1) = q(xt|xt−1, x0), and by Bayes’ rule, we have
q(xt|xt−1, x0) = q(xt−1|xt, x0)q(xt|x0)
q(xt−1|x0)
(25.13)
Plugging Equation (25.13) into the ELBO we get
Ł(x0) = Eq(x1:T |x0)





log p(xT ) +X
T
t=2
log pθ(xt−1|xt)
q(xt−1|xt, x0)
+
X
T
t=2
log q(xt−1|x0)
q(xt|x0)
| {z }
∗
+ log pθ(x0|x1)
q(x1|x0)





(25.14)
The term marked * is a telescoping sum, and can be simplified as follows:
∗ = log q(xT −1|x0) + · · · + log q(x2|x0) + log q(x1|x0) (25.15)
− log q(xT |x0) − log q(xT −1|x0) − · · · − log q(x2|x0) (25.16)
= − log q(xT |x0) + log q(x1|x0) (25.17)
Hence the negative ELBO (variational upper bound) becomes
L(x0) = −Eq(x1:T |x0)
"
log p(xT )
q(xT |x0)
+
X
T
t=2
log pθ(xt−1|xt)
q(xt−1|xt, x0)
+ log pθ(x0|x1)
#
(25.18)
= DKL (q(xT |x0) k p(xT ))
| {z }
LT (x0)
(25.19)
+
X
T
t=2
Eq(xt|x0) DKL (q(xt−1|xt, x0) k pθ(xt−1|xt))
| {z }
Lt−1(x0)
− Eq(x1|x0)
log pθ(x0|x1)
| {z }
L0(x0)
(25.20)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
25.2. DENOISING DIFFUSION PROBABILISTIC MODELS (DDPMS)
Each of these KL terms can be computed analytically, since all the distributions are Gaussian.
Below we focus on the Lt−1 term. Since xt =
√
αtx0 +
p
(1 − αt)ǫ, we can write
µ˜t
(xt, x0) = 1
√
αt

xt −
βt √
1 − αt
ǫ

(25.21)
Thus instead of training the model to predict the mean of the denoised version of xt−1 given its
noisy input xt, we can train the model to predict the noise, from which we can compute the mean:
µθ
(xt, x0) = 1
√
αt

xt −
βt √
1 − αt
ǫθ(xt, t)

(25.22)
With this parameterization, the loss (averaged over the dataset) becomes
Lt−1 = Ex0∼q0(x0),ǫ∼N(0,I)





β
2
t
2σ
2
t αt(1 − αt)
| {z }
λt
||ǫ − ǫθ


√
αtx0 +
√
1 − αtǫ
| {z }
xt
, t

 ||2





(25.23)
The time dependent weight λt ensures that the training objective corresponds to maximum likelihood
training (assuming the variational bound is tight). However, it has been found empirically that the
model produces better looking samples if we set λt = 1. The resulting simplified loss (also averaging
over time steps t in the model) is given by
Lsimple = Ex0∼q0(x0),ǫ∼N(0,I),t∼Unif(1,T)

||ǫ − ǫθ


√
αtx0 +
√
1 − αtǫ
| {z }
xt
, t

 ||2

 (25.24)
The overall training procedure is shown in Algorithm 25.1. We can improve the perceptual quality of
samples using more advanced weighting schemes, are discussed in [Cho+22]. Conversely, if the goal
is to improve likelihood scores, we can optimize the noise schedule, as discussed in Section 25.2.4.
Algorithm 25.1: Training a DDPM model with Lsimple.
1 while not converged do
2 x0 ∼ q0(x0)
3 t ∼ Unif({1, . . . , T})
4 ǫ ∼ N (0, I)
5 Take gradient descent step on ∇θ||ǫ − ǫθ
￾√
αtx0 +
√
1 − αtǫ, t
||2
After the model is trained, we can generate data using ancestral sampling, as shown in Algo￾rithm 25.2.
25.2.4 Learning the noise schedule
In this section, we describe a way to optimize the noise schedule used by the encoder so as to
maximize the ELBO; this approach is called a variational diffusion model or VDM [Kin+21].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens862
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Algorithm 25.2: Sampling from a DDPM model.
1 xT ∼ N (0, I)
2 foreach t = T, . . . , 1 do
3 ǫt ∼ N (0, I)
4 xt−1 = √
1
αt

xt − √
1−αt
1−αt
ǫθ(xt, t)

+ σtǫt
5 Return x0
We will use the following parameterization of the encoder:
q(xt|x0) = N (xt|αˆtx0, σˆ
2
t
I) (25.25)
(Note that αˆt and σˆt are different to the parameters αt and σt in Section 25.2.1.) Rather than
working with αˆt and σˆ
2
t
separately, we will learn to predict their ratio, which is known as the signal
to noise ratio:
R(t) = ˆα
2
t /σˆ
2
t
(25.26)
This should be monotonically decreasing in t. This can be ensured by defining R(t) = exp(−γφ(t)),
where γφ(t) is a monotonic neural network. We usually set αˆt =
p
1 − σ
2
t
, to corresponde to the
variance preserving SDE discussed in Section 25.4.
Following the derivation in Section 25.2.3, the negative ELBO (variational upper bound) can be
written as
L(x0) = DKL (q(xT |x0) k p(xT ))
| {z }
prior loss
+ Eq(x1|x0)
[− log pθ(x0|x1)]
| {z }
reconstruction loss
+ LD(x0)
| {z }
diffusion loss
(25.27)
where the first two terms are similar to a standard VAE, and the final diffusion loss is given below:3
LD(x0) = 1
2
Eǫ∼N(0,I)
Z 1
0
R
′
(t) kx0 − xˆθ(zt, t)k
2
2
dt (25.28)
where R′
(t) is the derivative of the SNR function, and zt = αtx0 + σtǫt. (See [Kin+21] for the
derivation.)
Since the SNR functon is invertible, due to the monotonicity assumtion, we can perform a change of
variables, and make everything a function of v = R(t) instead of t. In particular, let zv = αvx0 + σvǫ,
and x˜θ(z, v) = xˆθ(z, R−1
(v)). Then we can rewrite Equation (25.28) as
LD(x0) = 1
2
Eǫ∼N(0,I)
Z Rmax
Rmin
kx0 − x˜θ(zv, v)k
2
2
dv (25.29)
where Rmin = R(1) and Rmax = R(0). Thus we see that the shape of the SNR schedule does not
matter, except for its value at the two end points.
3. We present a simplified form of the loss that uses the continuous time limit, which we discuss in Section 25.4.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
25.2. DENOISING DIFFUSION PROBABILISTIC MODELS (DDPMS)
Figure 25.3: Illustration of the U-net architecture used in the denoising step. From Slide 26 of [KGV22].
Used with kind permission of Arash Vahdat.
(a) (b) (c)
Figure 25.4: Some sample images generated by a small variational diffusion model trained on EMNIST for
about 30 minutes on a K40 GPU. (a) Unconditional sampling. (b) Conditioned on class label. (c) Using
classifier-free guidance (see Section 25.6.3). Generated by diffusion_emnist.ipynb. Used with kind permission
of Alex Alemi.
The integral in Equation (25.29) can be estimated by sampling a timestep uniformly at random.
When processing a minibatch of k examples, we can produce a lower variance estimate of the variational
bound by using a low-discrepancy sampler (cf., Section 11.6.5). In this approach, instead of
sampling the timesteps independently, we sample a single uniform random number u0 ∼ Unif(0, 1),
and then set t
i = mod (u0 + i/k, 1) for the i’th sample. We can also optimize the noise schedule
wrt the variance of the diffusion loss.
25.2.5 Example: image generation
Diffusion models are often used to generate images. The most common architecture for image
generation is based on the U-net model [RFB15], as shown in Figure 25.3. The time step t is
encoded as a vector, using sinusoidal positional encoding or random Fourier features, and is then
fed into the residual blocks, using either simple spatial addition or by conditioning the group norm
layers [DN21a]. Of course, other architectures besides U-net are possible. For example, recently
[PX22; Li+22; Bao+22a] have proposed the use of transformers, to replace the convolutional and
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license864
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
deconvolutional layers.
The results of training a small U-net VDM on EMNIST images are shown in Figure 25.4. By
training big models (billions of parameters) for a long time (days) on lots of data (millions of images),
diffusion models can be made to generate very high quality images (see Figure 20.2). Results can
be further improved by using conditional diffusion models, where guidance is provided about what
kinds of images to generate (see Section 25.6).
25.3 Score-based generative models (SGMs)
This section is written with Yang Song and Durk Kingma.
In Section 24.3, we discussed how to fit energy based models (EBMs) using score matching. This
adjusts the parameters of the EBM so that the score function of the model, ∇x log pθ(x), matches
the score function of the data, ∇x log pD(x). An alternative to fitting a scalar energy function and
computing its score is to directly learn the score function. This is called a score-based generative
model or SGM [SE19; SE20b; Son+21b]. We can optimize the score function sθ(x) using basic
score matching (Section 24.3.1), sliced score matching (Section 24.3.3 or denoising score matching
(Section 24.3.2). We discuss this class of models in more detail below. (For a comparison with EBMs,
see [SH21].)
25.3.1 Example
In Figure 25.5a, we show the Swiss roll dataset. We estimate the score function by fitting an MLP
with 2 hidden layers, each with 128 hidden units, using basic score matching. In Figure 25.5b, we
show the output of the network after training for 10,000 steps of SGD. We see that there are no
major false negatives (since wherever the density of the data is highest, the gradient field is zero),
but there are some false positives (since some regions of zero gradient do not correspond to data
regions). The comparison of the predicted outputs with the empirical data density is shown more
clearly in Figure 25.5c. In Figure 25.5d, we show some samples from the learned model, generated
using Langevin sampling.
25.3.2 Adding noise at multiple scales
In general, score matching can have difficulty when there are regions of low data density. To see this,
suppose pD(x) = πp0(x) + (1 − π)p1(x). Let S0 := {x | p0(x) > 0} and S1 := {x | p1(x) > 0} be the
supports of p0(x) and p1(x) respectively. When they are disjoint from each other, the score of pD(x)
is given by
∇x log pD(x) = (
∇x log p0(x), x ∈ S0
∇x log p1(x), x ∈ S1,
(25.30)
which does not depend on the weight π. Hence score matching cannot correctly recover the true
distribution. Furthermore, Langevin sampling will have difficulty traversing between modes. (In
practice this will happen even when the different modes only have approximately disjoint supports.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
25.3. SCORE-BASED GENERATIVE MODELS (SGMS)
(a) (b)
(c) (d)
Figure 25.5: Fitting a score-based generative model to the 2d Swiss roll dataset. (a) Training set. (b) Learned
score function trained using the basic score matching. (c) Superposition of learned score function and empirical
density. (d) Langevin sampling applied to the learned model. We show 3 different trajectories, each of length
25. Generated by score_matching_swiss_roll.ipynb.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license866
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Song and Ermon [SE19; SE20b] and Song et al. [Son+21b] overcome this difficulty by perturbing
training data with different scales of noise. Specifically, they use
qσ(x˜|x) = N (x˜|x, σ2
I) (25.31)
qσ(x˜) = Z
pD(x)qσ(x˜|x)dx (25.32)
For a large noise perturbation, different modes are connected due to added noise, and the estimated
weights between them are therefore accurate. For a small noise perturbation, different modes are
more disconnected, but the noise-perturbed distribution is closer to the original unperturbed data
distribution. Using a sampling method such as annealed Langevin dynamics [SE19; SE20b; Son+21b]
or diffusion sampling [SD+15a; HJA20; Son+21b], we can sample from the most noise-perturbed
distribution first, then smoothly reduce the magnitude of noise scales until reaching the smallest one.
This procedure helps combine information from all noise scales, and maintains the correct estimation
of weights from higher noise perturbations when sampling from smaller ones.
In practice, all score models share weights and are implemented with a single neural network
conditioned on the noise scale; this is called a noise conditional score network, and has the form
sθ(x, σ). Scores of different scales are estimated by training a mixture of score matching objectives,
one per noise scale. If we use the denoising score matching objective in Equation (24.33), we get
L(θ; σ) = Eq(x,x˜)

1
2
k∇x log pθ(x˜, σ) − ∇x log qσ(x˜|x)k
2
2

(25.33)
=
1
2
EpD(x)Ex˜∼N(x,σ2I)
(



sθ(x˜, σ) + (x˜ − x)
σ
2




2
2
)
(25.34)
where we used the fact that, for a Gaussian, the score is given by
∇x log N (x˜|x, σ2
I) = −∇x
1
2σ
2
(x − x˜)
T
(x − x˜) = x − x˜
σ
2
(25.35)
If we have T different noise scales, we can combine the losses in a weighted fashion using
L(θ; σ1:T ) = X
T
t=1
λtL(θ; σt) (25.36)
where we choose σ1 > σ2 > · · · > σT , and the weighting term satisfies λt > 0.
25.3.3 Equivalence to DDPM
We now show that the above score-based generative model training objective is equivalent to the
DDPM loss. To see this, first let us replace pD(x) with q0(x0), x˜ with xt, and sθ(x˜, σ) with sθ(xt, t).
We will also compute a stochastic approximation to Equation (25.36) by sampling a time step
uniformly at random. Then Equation (25.36) becomes
L = Ex0∼q0(x0),xt∼q(xt|x0),t∼Unif(1,T)
"
λt




sθ(xt, t) + (xt − x0)
σ
2
t




2
2
#
(25.37)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
25.4. CONTINUOUS TIME MODELS USING DIFFERENTIAL EQUATIONS
If we use the fact that xt = x0 + σtǫ, and if we define sθ(xt, t) = −
ǫθ(xt,t)
σt
, we can rewrite this as
L = Ex0∼q0(x0),ǫ∼N(0,I),t∼Unif(1,T)

λt
σ
2
t
kǫ − ǫθ(xt, t)k
2
2

(25.38)
If we set λt = σ
2
t
, we recover Lsimple loss in Equation (25.24).
25.4 Continuous time models using differential equations
In this section, we consider a DDPM model in the limit of an infinite number of hidden layers, or
equivalently, an SGM in the limit of an infinite number of noise levels. This requires switching from
discrete time to continuous time, which complicates the mathematics. The advantage is that we can
leverage the large existing literature on solvers for ordinary and stochastic differential equations to
enable faster generation, as we will see.
25.4.1 Forwards diffusion SDE
Let us first consider a diffusion process where the noise level βt gets rewritten as β(t)∆t, where ∆t is
a step size:
xt =
p
1 − βtxt−1 +
p
βtN (0, I) = p
1 − β(t)∆txt−1 +
p
β(t)∆tN (0, I) (25.39)
If ∆t is small, we can approximate the first term with a first-order Taylor series expansion to get
xt ≈ xt−1 −
β(t)∆t
2
xt−1 +
p
β(t)∆tN (0, I) (25.40)
Hence for small ∆t we have
xt − xt−1
∆t
≈ −
β(t)
2
xt−1 +
p
β(t)
√
∆t
N (0, I) (25.41)
We can now switch to the continuous time limit, and write this as the following stochastic
differential equation or SDE:
dx(t)
dt = −
1
2
β(t)x(t) + p
β(t)
dw(t)
dt (25.42)
where w(t) represents a standard Wiener process, also called Brownian noise. More generally,
we can write such SDEs as follows, where we use Itô calculus notation (see e.g., [SS19]):
dx = f(x, t)
| {z }
drift
dt + g(t)
|{z}
diffusion
dw (25.43)
The first term in the above SDE is called the drift coefficient, and the second term is called the
diffusion coefficient.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license868
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 25.6: Illustration of the forwards diffusion process in continuous time. Yellow lines are sample paths
from the SDE. Heat map represents the marginal distribution computed using the probability flow ODE. From
Slide 43 of [KGV22]. Used with kind permission of Karsten Kreis.
We can gain some intuition for these processes by looking at the 1d example in Figure 25.6. We
can draw multiple paths as follows: sample an initial state from the data distribution, and then
integrate over time using Euler-Maruyama integration:
x(t + ∆t) = x(t) + f(x(t), t)∆t + g(t)
√
∆tN (0, I) (25.44)
We can see how the data distributiom at t = 0, on the left hand side, gradually gets transformed to a
pure noise distribution at t = 1, on the right hand side.
In [Son+21b], they show that the SDE corresponding to DDPMs, in the T → ∞ limit, is given by
dx = −
1
2
β(t)xdt +
p
β(t)dω (25.45)
where β(t/T) = T βt. Here the drift term is proportional to −x, which encourages the process to
return to 0. Consequently, DDPM corresponds to a variance preserving process. By contrast, the
SDE corresponding to SGMs is given by the following:
dx =
r
d[σ(t)
2]
dt dω (25.46)
where σ(t/T) = σt. This SDE has zero drift, so corresponds to a variance exploding process.
25.4.2 Forwards diffusion ODE
Instead of adding Gaussian noise at every step, we can just sample the initial state, and then let it
evolve deterministically over time according to the following ordinary differential equation or
ODE:
dx =

f(x, t) −
1
2
g(t)
2∇x log pt(x)

| {z }
h(x,t)
dt (25.47)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
25.4. CONTINUOUS TIME MODELS USING DIFFERENTIAL EQUATIONS
(a) (b)
Figure 25.7: Illustration of the reverse diffusion process. (a) Sample paths from the SDE. (b) Deterministic
trajectories from the probability flow ODE. From Slide 65 of [KGV22]. Used with kind permission of Karsten
Kreis.
This is called the probability flow ODE [Son+21b, Sec D.3]. We can compute the state at any
moment in time using any ODE solver:
x(t) = x(0) + Z t
0
h(x, τ )dτ (25.48)
See Figure 25.7b for a visualization of a sample trajectory. If we start the solver from different
random states x(0), then the induced distribution over paths will have the same marginals as the
SDE model. See the heatmap in Figure 25.6 for an illustration.
25.4.3 Reverse diffusion SDE
To generate samples from this model, we need to be able to reverse the SDE. In a remarkable result,
[And82] showed that any forwards SDE of the form in Equation (25.43) can be reversed to get the
following reverse-time SDE:
dx =

f(x, t) − g(t)
2∇x log qt(x)

dt + g(t)dw (25.49)
where w is the standard Wiener process when time flows backwards, dt is an infinitesimal negative
time step, and ∇x log qt(x) is the score function.
In the case of the DDPM, the reverse SDE has the following form:
dxt =

−
1
2
β(t)xt − β(t)∇xt
log qt(xt)

dt +
p
β(t)dwt (25.50)
To estimate the score function, we can use denoising score matching as we discussed in Section 25.3,
to get
∇xt
log qt(xt) ≈ sθ(xt, t) (25.51)
(In practice, it is advisable to use variance reduction techniques, such as importance sampling, as
discussed in [Son+21a].) The SDE becomes
dxt = −
1
2
β(t) [xt + 2sθ(xt, t)] dt +
p
β(t)dwt (25.52)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license870
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 25.8: Comparing the first 100 dimensions of the latent code obtained for a random CIFAR-100 image.
“Model A” and “Model B” are separately trained with different architectures. From Figure 7 of [Son+21b].
Used with kind permission of Yang Song.
After fitting the score network, we can sample from it using ancestral sampling (as in Section 25.2),
or we can use the Euler-Maruyama integration scheme in Equation (25.44), which gives
xt−1 = xt +
1
2
β(t) [xt + 2sθ(xt, t)] ∆t +
p
β(t)∆tN (0, I) (25.53)
See Figure 25.7a for an illustration.
25.4.4 Reverse diffusion ODE
Based on the results in Section 25.4.2, we can derive the probability flow ODE from the reverse-time
SDE in Equation (25.49) to get
dxt =

f(x, t) −
1
2
g(t)
2
sθ(xt, t)

dt (25.54)
If we set f(x, t) = −
1
2
β(t) and g(t) = p
β(t), as in DDPM, this becomes
dxt = −
1
2
β(t) [xt + sθ(xt,t)] dt (25.55)
See Figure 25.7b for an illustration. A simple way to solve this ODE is to use Euler’s method:
xt−1 = xt +
1
2
β(t) [xt + sθ(xt,t)] ∆t (25.56)
However, in practice one can get better results using higher-order ODE solvers, such as Heun’s
method [Kar+22].
This model is a special case of a neural ODE, also called a continuous normalizing flow (see
Section 23.2.6). Consequently we can derive the exact log marginal likelihood. However, instead of
maximizing this directly (which is expensive), we use score matching to fit the model.
Another advantage of the deterministic ODE approach is that it guarantees that the generative
model is identifiable. To see this, note that the ODE (in both forwards and reverse directions) is
deterministic, and is uniquely determined by the score function. If the architecture is sufficiently
flexible, and if there is enough data, then score matching will recover the true score function of the
data generating process. Thus, after training, a given datapoint will map to a unique point in latent
space, regardless of the model architecture or initialization (see Figure 25.8).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
25.5. SPEEDING UP DIFFUSION MODELS
Figure 25.9: Generatng from the reverse diffusion process using 4 steps. (Top) Deterministic sampling.
(Bottom) A mix of deterministic and stochastic sampling. Used with kind permission of Ruiqi Gao.
Furthermore, since every point in latent space decodes to a unique image, we can perform “semantic
interpolation” in the latent space to generate images with properties that are in between two input
examples (cf., Figure 20.9).
25.4.5 Comparison of the SDE and ODE approach
In Section 25.4.3 we described the reverse diffusion process as an SDE, and in Section 25.4.4, we
described it as an ODE. We can see the connection between these methods by rewriting the SDE in
Equation (25.49) as follows:
dxt = −
1
2
β(t)[xt + sθ(xt, t)]dt
| {z }
probability flow ODE
−
1
2
β(t)sθ(xt, t)dt +
p
β(t)dwt
| {z }
Langevin diffusion SDE
(25.57)
The continuous noise injection can compensate for errors introduced by the numerical integration of
the ODE term. Consequently, the resulting samples often look better. However, the ODE approach
can be faster. Fortunately it is possible to combine these techniques, as proposed in [Kar+22]. The
basic idea is illustrated in Figure 25.9: we alternate between performing a deterministic step using
an ODE solver, and then adding a small amount noise to the result. This can be repeated for some
number of steps. (We discuss ways to reduce the number of required steps in Section 25.5.)
25.4.6 Example
A simple JAX implementation of the above ideas, written by Winnie Xu, can be found in diffu￾sion_mnist.ipynb. This fits a small model to MNIST images using denoising score matching. It then
generates from the model by solving the probability flow ODE using the diffrax library. By scaling
this kind of method up to a much larger model, and training for a much longer time, it is possible to
produce very impressive looking results, as shown in Figure 25.10.
25.5 Speeding up diffusion models
One of the main disadvantages of diffusion models is that generating from them takes many small
steps, which can be slow. While it is possible to just take fewer, larger steps, the results are much
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license872
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 25.10: Synthetic faces from a score-based generative model trained on CelebA-HQ-256 images. From
Figure 12 of [Son+21b]. Used with kind permission of Yang Song.
worse. In this section, we briefly mention a few techniques that have been proposed to tackle this
important problem. Many other techniques are mentioned in the recent review papers [UAP22;
Yan+22; Cao+22].
25.5.1 DDIM sampler
In this section, we describe the denoising diffusion implicit model or DDIM of [SME21], which can
be used for efficient deterministic generation. The first step is to use a non-Markovian forwards
diffusion process, so it always conditions on the input in addition to the previous step:
q(xt−1|xt, x0) = N (
p
αt−1x0 +
q
1 − αt−1 − σ˜
2
t
xt −
√
αtx0
√
1 − αt
, σ˜
2
t
I) (25.58)
The corresponding reverse process is
pθ(xt−1|xt) = N (
p
αt−1xˆ0 +
q
1 − αt−1 − σ˜
2
t
xt −
√
αtxˆ0
√
1 − αt
, σ˜
2
t
I) (25.59)
where xˆ0 = xˆθ(xt, t) is the predicted output from the model. By setting σ˜
2
t = 0, the reverse process
becomes fully deterministic, given the initial prior sample (whose variance is controlled by σ˜
2
T
). The
resulting probability flow ODE gives better results when using a small number of steps compared to
the methods discussed in Section 25.4.4.
Note that the weighted negative VLB for this model is the same as Lsimple in Section 25.2, so the
DDIM sampler can be applied to a trained DDPM model.
25.5.2 Non-Gaussian decoder networks
If the reverse diffusion process takes larger steps, then the induced distribution over clean outputs
given a noisy input will become multimodal, as illustrated in Figure 25.11. This requires more
complicated forms for the distribution pθ(xt−1|xt). In [Gao+21], they use an EBM to fit this
distribution. However, this still requires the use of MCMC to draw a sample. In [XKV22], they
use a GAN (Chapter 26) to fit this distribution. This enables us to easily draw a sample by passing
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
25.5. SPEEDING UP DIFFUSION MODELS
Figure 25.11: Illustration of why taking larger steps in the reverse diffusion process needs more complex,
mulit-modal conditional distributions. From Slide 90 of [KGV22]. Used with kind permission of Arash Vahdat.
Figure 25.12: Progressive distillation. From Figure 1 of [SH22]. Used with kind permission of Tim Salimans.
Gaussian noise through the generator. The benefits over a single stage GAN is that both the generator
and discriminator are solving a much simpler problem, resulting in increased mode coverage, and
better training stability. The benefit over a standard diffusion model is that we can generate high
quality samples in many fewer steps.
25.5.3 Distillation
In this section, we discuss the progressive distillation method of [SH22], which provides a way to
create a diffusion model that only needs a small number of steps to create high quality samples. The
basic idea is follows. First we train a DDPM model in the usual way, and sample from it using the
DDIM method; we treat this as the “teacher” model. We use this to generate intermediate latent
states, and train a “student” model to predict the output of the teacher on every second step, as
shown in Figure 25.12. After the student has been trained, it can generate results that are as good as
the teacher, but in half the number of steps. This student can then teach a new generation of even
faster students. See Algorithm 25.4 for the pseudocode, which should be compared to Algorithm 25.3
for the standard training procedure. Note that each round of teaching becomes faster, because the
teachers become smaller, so the total time to perform the distillation is relatively small. The resulting
model can generate high quality samples in as few as 4 steps.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license874
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Semantic 
 Map
crossattention
Latent Space Conditioning 
Text
Diffusion Process
denoising step switch skip connection
Repres 
entations
Pixel Space
Images
Denoising U-Net
concat
Figure 25.13: Combining a VAE with a diffusion model. Here E and D are the encoder and decoder of the
VAE. The diffusion model conditions on the inputs either by using concatentation or by using a cross-attention
mechanism. From Figure 3 of [Rom+22]. Used with kind permission of Robin Rombach.
Algorithm 25.3: Standard training
Input: Model xˆθ(zt) to be trained
Input: Dataset D
Input: Loss weight function w
1 while not converged do
2 x ∼ D
3 t ∼ Unif(0, 1)
4 ǫ ∼ N (0, I)
5 zt = αtx + σtǫ
6 x˜ = x (Clean data is target)
7 λt = log(α
2
t
/σ2
t
) (Log SNR)
8 Lθ = w(λt) kx˜ − xˆθ(zt)k
2
2
9 θ := θ − γ∇θLθ
Algorithm 25.4: Progressive distilla￾tion
Input: Trained teacher model xˆη(zt)
Input: Dataset D
Input: Loss weight function w
Input: Student sampling steps N
1 foreach K iterations do
2 θ := η (Assign student)
3 while not converged do
4 x ∼ D
5 t = i/N, i ∼ Cat(1, 2, . . . , N)
6 ǫ ∼ N (0, I)
7 zt = αtx + σtǫ
8 t
′ = t − 0.5/N, t
′′ = t − 1/N
9 zt
′ = αt
′xˆη(zt) + σt
′
σt
(zt − αtxˆη(zt))
10 zt
′′ =
αt
′′xˆη(zt
′ ) + σt
′′
σt
′
(zt
′ − αt
′xˆη(zt
′ ))
11 x˜ =
zt
′′ −(σt
′′ /σt)zt
αt
′′ −(σt
′′ /σt)αt
(Teacher is target)
12 λt = log(α
2
t
/σ2
t
)
13 Lθ = w(λt) kx˜ − xˆθ(zt)k
2
2
14 θ := θ − γ∇θLθ
15 η : − = θ (Student becomes next teacher)
16 N := N/2 (Halve number of sampling steps)
25.5.4 Latent space diffusion
Another approach to speeding up diffusion models for images is to first embed the images into a
lower dimensional space, and then fit the diffusion model to the embeddings. This idea has been
pursued in several papers.
In the latent diffusion model (LDM) of [Rom+22], they adopt a two-stage training scheme, in
which they first fit the VAE, augmented with a perceptual loss, and then fit the diffusion model to
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
25.6. CONDITIONAL GENERATION
the embedding. The architecture is illustrated in Figure 25.13. The LDM forms the foundation of the
very popular stable diffusion system created by Stability AI. In the latent score-based generative
model (LSGM) of [VKK21], they first train a hierarchical VAE, and then jointly train the VAE and
a diffusion model.
In addition to speed, an additional advantage of combining diffusion models with autoencoders is
that it makes it simple to apply diffusion to many different kinds of data, such as text and graphs: we
just need to define a suitable architecture to embed the input domain into a continuous space. Note,
however, that it is also possible to define diffusion directly on discrete state spaces, as we discuss in
Section 25.7.
So far we have discussed applying diffusion “on top of” a VAE. However, we can also do the reverse,
and fit a VAE on top of a DDPM model, where we use the diffusion model to “post process” blurry
samples coming from the VAE. See [Pan+22] for details.
25.6 Conditional generation
In this section, we discuss how to generate samples from a diffusion model where we condition on
some side information c, such as a class label or text prompt.
25.6.1 Conditional diffusion model
The simplest way to control the generation from a generative model is to train it on (c, x) pairs so as
to maximize the conditional likelihood, p(x|c). If the conditioning signal c is a scalar (e.g., a class
label), it can be mapped to an embedding vector, and then incorporated into the network by spatial
addition, or by using it to modular the group normalization layers. If the input c is another image,
we can simply concatenate it with xt as an extra set of channels. If the input c is a text prompt, we
can embed it, and then use spatial addition or cross-attention (see Figure 25.13 for an illustration).
25.6.2 Classifier guidance
One problem with conditional diffusion models is that we need to retrain them for each kind of
conditioning that we want to perform. An alternative approach, known as classifier guidance was
proposed in [DN21b], and allows us to leverage pre-trained discriminative classifiers of the form
pφ(c|x) to control the generation process. The idea is as follows. First we use Bayes’ rule to write
log p(x|c) = log p(c|x) + log p(x) − log p(c) (25.60)
from which the score function becomes
∇x log p(x|c) = ∇x log p(x) + ∇x log p(c|x) (25.61)
We can now use this conditional score to generate samples, rather than the unconditional score. We
can further amplify the influence of the conditioning signal by scaling it by a factor w > 1:
∇x log pw(x|c) = ∇x log p(x) + w∇x log p(c|x) (25.62)
In practice, this can be achieved as follows by generating samples from
xt−1 ∼ N (µ + wΣg, Σ), µ = µθ
(xt, t), Σ = Σθ(xt, t), g = ∇xt
log pφ(c|xt) (25.63)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license876
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Text
Frozen Text Encoder
Text-to-Image
Diffusion Model
Text Embedding
Super-Resolution
Diffusion Model
64 × 64 Image
Super-Resolution
Diffusion Model
256 × 256 Image
1024 × 1024 Image
“A Golden Retriever dog wearing a blue
checkered beret and red dotted turtleneck.”
Figure 25.14: Cascaded diffusion model used by the Imagen text-to-image system. From Figure A.5 of
[Sah+22b]. Used with kind permission of Saurabh Saxena.
25.6.3 Classifier-free guidance
Unfortunately, p(c|xt) is a discriminative model, that may ignore many details of the input xt. Hence
optimizing along the directions specified by ∇xt
log p(c|xt) can give poor results, similar to what
happens when we create adversarial images. In addition, we need to train a classifier for each time
step, since xt will differ in its blurriness.
In [HS21], they proposed a technique called classifier-free guidance, which derives the classifier
from the generative model, using p(c|x) = p(x|c)p(c)
p(x)
, from which we get
log p(c|x) = log p(x|c) + log p(c) − log p(x) (25.64)
This requires learning two generative models, namely p(x|c) and p(x). However, in practice we can
use the same model for this, and simply set c = ∅ to represent the unconditional case. We then use
this implicit classifier to get the following modified score function:
∇x[log p(x|c) + w log p(c|x)] = ∇x[log p(x|c) + w(log p(x|c) − log p(x))] (25.65)
= ∇x[(1 + w) log p(x|c) − w log p(x)] (25.66)
Larger guidance weight usually results in better individual sample quality, but lower diversity.
25.6.4 Generating high resolution images
In order to generate high resolution images, [Ho+21] proposed to use cascaded generation, in
which we first train a model to generate 64 × 64 images, and then train a separate super-resolution
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
25.7. DIFFUSION FOR DISCRETE STATE SPACES
Figure 25.15: Multinomial diffusion model, applied to semantic image segmentation. The input image is
on the right, and gets diffused to the noise image on the left. From Figure 1 of [Aus+21]. Used with kind
permission of Emiel Hoogeboom.
model to map this to 256 × 256 or 1024 × 1024. This approach is used in Google’s Imagen model
[Sah+22b], which is a text-to-image system (see Figure 25.14). Imagen uses large pre-trained text
encoder, based on T5-XXL [Raf+20a], combined with a VDM model (Section 25.2.4) based on the
U-net architecture, to generate impressive-looking images (see Figure 20.2).
In addition to conditioning on text, it is possible to condition on another image to create a model
for image-to-image translation. For example, we can learn map a gray-scale image c to a color
image x, or a corrupted or occluded image c to a clean version x. This can be done by training a
multi-task conditional diffusion model, as explained in [Sah+22a]. See Figure 20.4 for some sample
outputs.
25.7 Diffusion for discrete state spaces
So far in this chapter, we have focused on Gaussian diffusion for generating real-valued data. However
it is also possible to define diffusion models for discrete data, such as text or semantic segmentation
labels, either by using a continuous latent embedding space (see Section 25.5.4), or by defining
diffusion operations directly on the discrete state space, as we discuss beow.
25.7.1 Discrete Denoising Diffusion Probabilistic Models
In this section we discuss the Discrete Denoising Diffusion Probabilistic Model (D3PM) of [Aus+21],
which defines a discrete time diffusion process directly on the discrete state space. (This builds on
prior work such as multinomial diffusion [Hoo+21], and the original diffusion paper of [SD+15b].)
The basic idea is illustrated in Figure 25.15 in the context of semantic segmentation, which
associates a categorical label to each pixel in an image. On the right we illustrate some sample
images, and the corresponding categorical distribution that they induce over a single pixel. We
gradually transform these pixel-wise distributions to the uniform distribution, using a stochastic
sampling process that we describe below. We then learn a neural network to invert this process, so it
can generate discrete data from noise; in the diagram, this corresponds to moving from left to right.
To ensure efficient training, we require that we can efficiently sample from q(xt|x0) for an
abritrary timestep t, so we can randomly sample time steps when optimizing the variational bound
in Equation (25.27). In addition, we require that q(xt−1|xt, x0) have a tractable form, so we can
efficiently compute the KL terms
Lt−1(x0) = Eq(xt|x0)DKL (q(xt−1|xt, x0) k pθ(xt−1|xt)) (25.67)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license878
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 25.16: D3PM forward and (learned) reverse proccess applied to a quantized Swiss roll. Each dot
represents a 2d categorical variable. Top: samples from the uniform, discretized Gaussian, and absorbing
state models, along with corresponding transition matrices Q. Bottom: samples from a learned discretized
Gaussian reverse process. From Figure 1 of [Aus+21]. Used with kind permission of Jacob Austin.
Finally, it is useful if the forwards process converges to a known stationary distribution, π(xT ), which
we can use for our generative prior p(xT ); this ensures DKL (q(xT |x0) k p(xT )) = 0.
To satisfy the above criteria, we assume the state consists of D independent blocks, each representing
a categorical variable, xt ∈ {1, . . . , K}; we represent this by the one-hot row vector x0. In general,
this will represent a vector of probabilities. We then define the forwards diffusion kernel as follows:
q(xt|xt−1) = Cat(xt|xt−1Qt) (25.68)
where [Qt]ij = q(xt = j|xt−1 = k) is a row stochastic transition matrix. (We discuss how to define
Qt in Section 25.7.2.)
We can derive the t-step marginal of the forwards process as follows:
q(xt|x0) = Cat(xt|x0Qt
), Qt = Q1Q2 · · · Qt (25.69)
Similarly, we can reverse the forwards process as follows:
q(xt−1|xt, x0) = q(xt|xt−1,✟x✟0)q(xt−1|x0)
q(xt|x0)
= Cat 
xt−1|
xtQT
t ⊙ x0Qt−1
x0Qtx
T
t
!
(25.70)
We discuss how to define the generative process pθ(xt−1|xt) in Section 25.7.3. Since both distrbutions
factorize, we can easily compute the KL distributions in Equation (25.67) by summing the KL for
each dimension.
25.7.2 Choice of Markov transition matrices for the forward processes
In this section, we give some examples of how to represent the transition matrix Qt.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
25.7. DIFFUSION FOR DISCRETE STATE SPACES
One simple approach is to use Qt = (1 − βt)I + βt/K, which we can write in scalar form as follows:
[Qt]ij =
(
1 −
K−1
K
βt if i = j
1
K
βt if i 6= j
(25.71)
Intuïtively, this adds a little amount of uniform noise over the K classes, and with a large probability,
1 − βt, we sample from xt−1. We call this the uniform kernel. Since this is a doubly stochastic
matrix with strictly positive entries, the stationary distributon is uniform. See Figure 25.16 for an
illustration.
In the case of the uniform kernel, one can show [Hoo+21] that the marginal distribution is given
by
q(xt|x0) = Cat(xt|αtx0 + (1 − αt)/K) (25.72)
where αt = 1 − βt and αt =
Qt
τ=1 ατ . This is similar to the Gaussian case discussed in Section 25.2.
Furthermore, we can derive the posterior distribution as follows:
q(xt−1|xt, x0) = Cat(xt−1|θpost(xt, θ0)), θpost(xt, θ0) = θ˜/
X
K
k=1
˜θk (25.73)
θ˜ = [αtxt + (1 − αt)/K] ⊙ [αt−1x0 + (1 − αt−1)/K] (25.74)
Another option is to define a special absorbing state m, representing a MASK token, which we
transition into with probability βt. Formally, we have Qt = (1 − βt)I + βt1e
T
m, or, in scalar form,
[Qt]ij =



1 if i = j = m
1 − βt if i = j 6= m
βt if j = m, i 6= m
(25.75)
This converges to a point-mass distribution on state m. See Figure 25.16 for an illustration.
Another option, suitable for quantized ordinal values, is to use a discretized Gaussian, that
transitions to other nearby states, with a probability that depends on how similar the states are in
numerical value. If we ensure the transition matrix is doubly stochastic, the resulting stationary
distribution will again be uniform. See Figure 25.16 for an illustration.
25.7.3 Parameterization of the reverse process
While it is possible to directly predict the logits pθ(xt−1|xt) using a neural network fθ(xt), it is
preferable to directly predict the logits of the output, using p˜θ(x˜0|xt); we can then combine this
with the analytical expression for q(xt−1|xt, x0) to get
pθ(xt−1|xt) ∝
X
x˜0
q(xt−1|xt, x˜0)˜pθ(x˜0|xt) (25.76)
(The sum over x˜0 takes O(DK) time, if there are D dimensions, each with K values.) One advantage
of this approach, compared to directly learning pθ(xt−1|xt), is that the model will automatically
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license880
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
satisfy any sparsity constraints in Qt. In addition, we can perform inference with k steps at a time,
by predicting
pθ(xt−k|xt) ∝
X
x˜0
q(xt−k|xt, x˜0)˜pθ(x˜0|xt) (25.77)
Note that, in the multi-step Gaussian case, we require more complex models to handle multimodaility
(see Section 25.5.2). By contrast, discrete distributions already have this flexibility built in.
25.7.4 Noise schedules
In this section we discuss how to choose the noise schedule for βt. For discretized Gaussian diffusion,
[Aus+21] propose to linearly increase the variance of the Gaussian noise before the discretization step.
For uniform diffusion, we can use a cosine schedule of the form αt = cos(
t/T +s
1+s
π
2
), where s = 0.08, as
proposed in [ND21]. (Recall that βt = 1 − αt, so the noise increases over time.) For masked diffusion,
we can use a schedule of the form βt = 1/(T − t + 1), as proposed in [SD+15b].
25.7.5 Connections to other probabilistic models for discrete sequences
There are interesting connections between D3PM and other probabilistic text models. For example,
suppose we define the transition matrix as a combination of the unifrom transition matrix and an
absorbing MASK state, i.e., Q = α1e
T
m + β11T
/K + (1 − α − β)I. For a one-step diffusion process
in which q(x1|x0) replaces α = 10% of the tokens with MASK, and β = 5% uniformly at random,
we recover the same objective that is used to train the BERT language model, namely
L0(x0) = −Eq(x1|x0)
log pθ(x0|x1) (25.78)
(This follows since LT = 0, and there are no other time steps used in the variational bound in
Equation (25.27).)
Now consider a diffusion process that deterministically masks tokens one-by-one. For a se￾quence of length N = T, we have q([xt]i
|x0) = [x0]i
if i < N − t (pass through), else [xt]i
is set to MASK. Because this is a deterministic process, the posterior q(xt−1|xt, x0) is a delta
function on the xt with one fewer mask tokens. One can then show that the KL term becomes
DKL (q([xt]i
|xt, x0) k pθ([xt−1]i
|xt)) = − log pθ([x0]i
|xt), which is the standard cross-entropy loss
for an autoregressive model.
Finally one can show that generative masked language models, such as [WC19; Gha+19], also
correspond to discrete diffusion processes: the sequence starts will all locations masked out, and
each step, a set of tokens are generated, given the previous sequence. The MaskGIT method of
[Cha+22] uses a similar procedure in the image domain, after applying vector quantization to image
patches. These parallel, iterative decoders are much faster than sequential autoregressive decoders.
See Figure 25.17 for an illustration.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
25.7. DIFFUSION FOR DISCRETE STATE SPACES




	
...
t = 0 t = 1 t = 2 t = 7





t = 3 t = 4 t = 5 t = 6
...
t = 0 t = 1 t = 120 t = 200 t = 255
...
Figure 25.17: Comparison of sequential image generation with a transformer (top) vs parallel generation with
MaskGIT (bottom). All pixels start out in the MASK state, denoted by light gray. In the transformer, we
generate one pixel at a time, so it takes 256 steps for the whole image. In the MaskGIT method, multiple states
are generated in parallel, which only takes 8 steps. From Figure 2 of [Cha+22]. Used with kind permission of
Huiwen Chang.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license26 Generative adversarial networks
This chapter is written by Mihaela Rosca, Shakir Mohamed, and Balaji Lakshminarayanan.
26.1 Introduction
In this chapter, we focus on implicit generative models, which are a kind of probabilistic model
without an explicit likelihood function [ML16]. This includes the family of generative adversarial
networks or GANs [Goo16]. In this chapter, we provide an introduction to this topic, focusing on
a probabilistic perspective.
To develop a probabilistic formulation for GANs, it is useful to first distinguish between two types of
probabilistic models: “prescribed probabilistic models” and “implicit probabilistic models”
[DG84]. Prescribed probabilistic models, which we will call explicit probabilistic models, provide
an explicit parametric specification of the distribution of an observed random variable x, specifying
a log-likelihood function log qθ(x) with parameters θ. Most models we encountered in this book thus
far are of this form, whether they be state-of-the-art classifiers, large-vocabulary sequence models,
or fine-grained spatio-temporal models. Alternatively, we can specify an implicit probabilistic
model that defines a stochastic procedure to directly generate data. Such models are the natural
approach for problems in climate and weather, population genetics, and ecology, since the mechanistic
understanding of such systems can be used to directly describe the generative model. We illustrate
the difference between implicit and explicit models in Figure 26.1.
The form of implicit generative models we focus on in this chapter can be expressed as a probabilistic
latent variable model, similar to VAEs (Chapter 21). Implicit generative models use a latent variable
z and transform it using a deterministic function Gθ that maps from R
m → R
d using parameters θ.
Implicit generative models do not include a likelihood function or observation model. Instead, the
generating procedure defines a valid density on the output space that forms an effective likelihood
function:
x = Gθ(z
′
); z
′ ∼ q(z) (26.1)
qθ(x) = ∂
∂x1
. . .
∂
∂xd
Z
{Gθ(z)≤x}
q(z)dz, (26.2)
where q(z) is a distribution over latent variables that provides the external source of randomness.
Equation (26.2) is the definition of the transformed density qθ(x) defined as the derivative of a
cumulative distribution function, and hence integrates the distribution q(z) over all events defined884
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
data
model density
(a) Prescribed generative model.
data
model samples
(b) Implicit generative model.
Figure 26.1: Visualizing the difference between prescribed and implicit generative models. Prescribed mod￾els provide direct access to the learned density (sometimes unnormalized). Implicit models only provide
access to a simulator which can be used to generate samples from an implied density. Generated by
genmo_types_implicit_explicit.ipynb
by the set {Gθ(z) ≤ x}. When the latent and data dimension are equal (m = d) and the function
Gθ(z) is invertible or has easily characterized roots, we recover the rule for transformations of
probability distributions. This transformation of variables property is also used in normalizing flows
(Chapter 23). In diffusion models (Chapter 25), we also transform noise into data and vice versa, but
the transformation is not strictly invertible.
We can develop more general and flexible implicit generative models where the function G is
a non-linear function with d > m, e.g., specified by a deep network. Such models are sometimes
called generator networks or generative neural samplers; they can also be throught of as
differentiable simulators. Unfortunately the integral (26.2) is intractable in these kinds of models,
and we may not even be able to determine the set {Gθ(z) ≤ x}. Of course, intractability is also a
challenge for explicit latent variable models such as VAEs (Chapter 21), but in the GAN case, the
lack of a likelihood term makes the learning problem even harder. Therefore this problem is called
likelihood-free inference or simulation-based inference.
Likelihood-free inference also forms the basis of the field known as approximate Bayesian
computation or ABC, which we briefly discuss in Section 13.6.5. ABC and GANs give us two
different algorithmic frameworks for learning in implicit generative models. Both approaches rely on
a learning principle based on comparing real and simulated data. This type of learning by comparison
instantiates a core principle of likelihood-free inference, and expanding on this idea is the focus of
the next section. The subsequent sections will then focus on GANs specifically, to develop a more
detailed foundation and practical considerations. (See also https://poloclub.github.io/ganlab/
for an interactive tutorial.)
26.2 Learning by comparison
In most of this book, we rely on the principle of maximum likelihood for learning. By maximizing
the likelihood we effectively minimize the KL divergence between the model qθ (with parameters θ)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.2. LEARNING BY COMPARISON
Learning By 
Comparison
Differences
Integral Probability 
Metrics Moment Matching
Ratios
Class-probability 
Estimation f-Divergences
Figure 26.2: Overview of approaches for learning in implicit generative models
and the unknown true data distribution p
∗
. Recalling equation (26.2), in implicit models we cannot
evaluate qθ(x), and thus cannot use maximum likelihood training. As implicit models provide a
sampling procedure, we instead are searching for learning principles that only use samples from the
model.
The task of learning in implicit models is to determine, from two sets of samples, whether their
distributions are close to each other and to quantify the distance between them. We can think of
this as a ‘two sample’ or likelihood-free approach to learning by comparison. There are many ways of
doing this, including using distributional divergences or distances through binary classification, the
method of moments, and other approaches. Figure 26.2 shows an overview of different approaches
for learning by comparison.
26.2.1 Guiding principles
We are looking for objectives D(p
∗
, q) that satisfy the following requirements:
1. Provide guarantees about learning the data distribution: argminq D(p
∗
, q) = p
∗
.
2. Can be evaluated only using samples from the data and model distribution.
3. Are computationally cheap to evaluate.
Many distributional distances and divergences satisfy the first requirement, since by definition they
satisfy the following:
D(p
∗
, q) ≥ 0; D(p
∗
, q) = 0 ⇐⇒ p
∗ = q (26.3)
Many distributional distances and divergences, however, fail to satisfy the other two requirements:
they cannot be evaluated only using samples — such as the KL divergence, or are computationally
intractable — such as the Wasserstein distance. The main approach to overcome these challenges is
to approximate the desired quantity through optimization by introducing a comparison model, often
called a discriminator or a critic D, such that:
D(p
∗
, q) = argmax
D
F(D, p∗
, q) (26.4)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license886
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where F is a functional that depends on p
∗ and q only through samples. For the cases we discuss, both
the model and the critic are parametric with parameters θ and φ respectively; instead of optimizing
over distributions or functions, we optimize with respect to parameters. For the critic, this results in
the optimization problem argmaxφ F(Dφ, p∗
, qθ). For the model parameters θ, the exact objective
D(p
∗
, qθ) is replaced with the tractable approximation provided through the use of Dφ.
A convenient approach to ensure that F(Dφ, p∗
, qθ) can be estimated using only samples from the
model and the unknown data distribution is to depend on the two distributions only in expectation:
F(Dφ, p∗
, qθ) = Ep∗(x)f(x, φ) + Eqθ(x)g(x, φ) (26.5)
where f and g are real valued functions whose choice will define F. In the case of implicit generative
models, this can be rewritten to use the sampling path x = Gθ(z), z ∼ q(z):
F(Dφ, p∗
, qθ) = Ep∗(x)f(x, φ) + Eq(z)g(Gθ(z), φ) (26.6)
which can be estimated using Monte Carlo estimation
F(Dφ, p∗
, qθ) ≈
1
N
X
N
i=1
f(xbi
, φ) + 1
M
X
M
i=1
g(Gθ(zbi), φ); xbi ∼ p
∗
(x); zbi ∼ q(z) (26.7)
Next, we will see how to instantiate these guiding principles in order to find the functions f and g
and thus the objective F which can be used to train implicit models: class probability estimation
(Section 26.2.2), bounds on f-divergences (Section 26.2.3), integral probability metrics (Section 26.2.4),
and moment matching (Section 26.2.5).
26.2.2 Density ratio estimation using binary classifiers
One way to compare two distributions p
∗ and qθ is to compute their density ratio r(x) = p
∗
(x)
qθ(x)
. The
distributions are the same if and only if the ratio is 1 everywhere in the support of qθ. Since we
cannot evaluate the densities of implicit models, we must instead develop techniques to compute the
density ratio from samples alone, following the guiding principles established above.
Fortunately, we can use the trick from Section 2.7.5 which converts density estimation into a binary
classification problem to write
p
∗
(x)
qθ(x)
=
D(x)
1 − D(x)
(26.8)
where D(x) is the discriminator or critic which is trained to distinguish samples coming from p
∗ vs
qθ.
For parametric classification, we can learn discriminators Dφ(x) ∈ [0, 1] with parameters φ. Using
knowledge and insight about probabilistic classification, we can learn the parameters by minimizing
any proper scoring rule [GR07b] (see also Section 14.2.1). For the familiar Bernoulli log-loss (or
binary cross entropy loss), we obtain the objective:
V (qθ, p∗
) = arg max
φ
Ep(x|y)p(y)
[y log Dφ(x) + (1 − y) log(1 − Dφ(x))]
= arg max
φ
Ep(x|y=1)p(y=1) log Dφ(x) + Ep(x|y=0)p(y=0) log(1 − Dφ(x)) (26.9)
= arg max
φ
1
2
Ep∗(x)
log Dφ(x) +
1
2
Eqθ(x)
log(1 − Dφ(x)). (26.10)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.2. LEARNING BY COMPARISON
Loss Objective Function (D := D(x; φ) ∈ [0, 1])
Bernoulli loss Ep∗(x)
[log D] + Eqθ(x)
[log(1 − D)]
Brier score Ep∗(x)
[−(1 − D)
2
] + Eqθ(x)
[−D2
]
Exponential loss Ep∗(x)
h￾
−
1−D
D
 1
2
i
+ Eqθ(x)

−
D
1−D
 1
2

Misclassification Ep∗(x)
[−I[D ≤ 0.5]] + Eqθ(x)
[−I[D > 0.5]]
Hinge loss Ep∗(x)
h
− max 
0, 1 − log D
1−D
i + Eqθ(x)
h
− max 
0, 1 + log D
1−D
i
Spherical Ep∗(x)
[αD] + Eqθ(x)
[α(1 − D)] ; α = (1 − 2D + 2D2
)
− 1
2
Table 26.1: Proper scoring rules that can be maximized in class probability-based learning of implicit generative
models. Based on [ML16].
The same procedure can be extended beyond the Bernoulli log-loss to other proper scoring rules
used for binary classification, such as those presented in Table 26.1, adapted from [ML16]. The
optimal discriminator D is p
∗
(x)
p∗(x)+qθ(x)
, since:
p
∗
(x)
qθ(x)
=
D∗
(x)
1 − D∗(x)
=⇒ D∗
(x) = p
∗
(x)
p
∗(x) + qθ(x)
(26.11)
By substituting the optimal discriminator into the scoring rule (26.10), we can show that the objective
V can also be interpreted as the minimization of the Jensen-Shannon divergence.
V
∗
(qθ, p∗
) = 1
2
Ep∗(x)
[log p
∗
(x)
p
∗(x) + qθ(x)
] +
1
2
Eqθ(x)
[log(1 −
p
∗
(x)
p
∗(x) + qθ(x)
)] (26.12)
=
1
2
Ep∗(x)
[log p
∗
(x)
p∗(x)+qθ(x)
2
] + 1
2
Eqθ(x)
[log(
qθ(x)
p∗(x)+qθ(x)
2
)] − log 2 (26.13)
=
1
2
DKL 
p
∗
k
p
∗+ qθ
2

+
1
2
DKL 
qθ k
p
∗+ qθ
2

− log 2 (26.14)
= JSD(p
∗
, qθ) − log 2 (26.15)
where JSD denotes the Jensen-Shannon divergence:
JSD(p
∗
, qθ) = 1
2
DKL 
p
∗
k
p
∗+ qθ
2

+
1
2
DKL 
qθ k
p
∗+ qθ
2

(26.16)
This establishes a connection between optimal binary classification and distributional divergences.
By using binary classification, we were able to compute the distributional divergence using only
samples, which is the important property needed for learning implicit generative models; as expressed
in the guiding principles (Section 26.2.1), we have turned an intractable estimation problem — how
to estimate the JSD divergence, into an optimization problem — how to learn a classifier which can
be used to approximate that divergence.
We would like to train the parameters θ of generative model to minimize the divergence:
min
θ
JSD(p
∗
, qθ) = min
θ
V
∗
(qθ, p∗
) + log 2 (26.17)
= min
θ
1
2
Ep∗(x)
log D∗
(x) +
1
2
Eqθ(x)
log(1 − D∗
(x)) + log 2 (26.18)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens888
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Since we do not have access to the optimal classifier D∗ but only to the neural approximation Dφ
obtained using the optimization in (26.10) , this results in a min-max optimization problem:
min
θ
max
φ
1
2
Ep∗(x)
[log Dφ(x)] + 1
2
Eqθ(x)
[log(1 − Dφ(x))] (26.19)
By replacing the generating procedure (26.1) in (26.19) we obtain the objective in terms of the
latent variables z of the implicit generative model:
min
θ
max
φ
1
2
Ep∗(x)
[log Dφ(x)] + 1
2
Eq(z)
[log(1 − Dφ(Gθ(z)))], (26.20)
which recovers the definition proposed in the original GAN paper [Goo+14]. The core principle
behind GANs is to train a discriminator, in this case a binary classifier, to approximate a distance
or divergence between the model and data distributions, and to then train the generative model to
minimize this approximation of the divergence or distance.
Beyond the use of the Bernoulli scoring rule used above, other scoring rules have been used to
train generative models via min-max optimization. The Brier scoring rule, which under discriminator
optimality conditions can be shown to correspond to minimizing the Pearson χ
2 divergence via
similar arguments as the ones shown above has lead to LS-GAN [Mao+17]. The hinge scoring rule
has become popular [Miy+18b; BDS18], and under discriminator optimality conditions corresponds
to minimizing the total variational distance [NWJ+09].
The connection between proper scoring rules and distributional divergences allows the construction
of convergence guarantees for the learning criteria above, under infinite capacity of the discriminator
and generator: since the minimizer of distributional divergence is the true data distribution (Equa￾tion 26.3), if the discriminator is optimal and the generator has enough capacity, it will learn the
data distribution. In practice however, this assumption will not hold, as discriminators are rarely
optimal; we will discuss this at length in Section 26.3.
26.2.3 Bounds on f-divergences
As we saw with the appearance of the Jensen-Shannon divergence in the previous section, we can
consider directly using a measure of distributional divergence to derive methods for learning in
implicit models. One general class of divergences are the f-divergences (Section 2.7.1) defined as:
Df [p
∗
(x)kqθ(x)] = Z
qθ(x)f

p
∗
(x)
qθ(x)

dx (26.21)
where f is a convex function such that f(1) = 0. For different choices of f, we can recover known
distributional divergences such as the KL, reverse KL, and Jensen-Shannon divergence. We discuss
such connections in Section 2.7.1, and provide a summary in Table 26.2.
To evaluate Equation (26.21) we will need to evaluate the density of the data p
∗
(x) and the model
qθ(x), neither of which are available. In the previous section we overcame the challenge of evaluating
the density ratio by transforming it into a problem of binary classification. In this section, we will
instead look towards the role of lower bounds on f-divergences, which is an approach for tractability
that is also used for variational inference (Chapter 10).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.2. LEARNING BY COMPARISON
Divergence f f
† Optimal Critic
KL u log u e
u−1 1 + log r(x)
Reverse KL − log u −1 − log(−u) −1/r(x)
JSD u log u − (u + 1)log u+1
2 − log(2 − e
u
)
2
1+1/r(x)
)
Pearson χ
2
(u − 1)2 1
4
u
2 + u
p
r(x) − 1
 p
1/r(x)
Table 26.2: Standard divergences as f divergences for various choices of f. The optimal critic is written as a
function of the density ratio r(x) = p
∗(x)
qθ(x)
.
f-divergences have a widely-developed theory in convex analysis and information theory. Since the
function f in Equation (26.21) is convex, we know that we can find a tangent that bounds it from
below. The variational formulation of the f-divergence is [NWJ10b; NCT16c]:
Df [p
∗
(x)kqθ(x)] = Z
qθ(x)f

p
∗
(x)
qθ(x)

dx (26.22)
=
Z
qθ(x) sup
t:X→R

t(x)
p
∗
(x)
qθ(x)
− f
†
(t(x))
dx (26.23)
=
Z
sup
t:X→R
p
∗
(x)t(x) − qθ(x)f
†
(t(x))dx (26.24)
≥ sup
t∈T
Ep∗(x)
[t(x)] − Eqθ(x)
[f
†
(t(x))]. (26.25)
In the second line we use the result from convex analysis, discussed Supplementary Section 6.3, that
re-expresses the convex function f using f(u) = supt ut − f
†
(t), where f
†
is the convex conjugate of
the function f, and t is a parameter we optimize over. Since we apply f at u =
p
∗
(x)
qθ(x)
for all x ∈ X ,
we make the parameter t be a function t(x). The final inequality comes from replacing the supremum
over all functions from the data domain X to R with the supremum over a family of functions T
(such as the family of functions expressible by a neural network architecture), which might not be
able to capture the true supremum. The function t takes the role of the discriminator or critic.
The final expression in Equation (26.25) follows the general desired form of Equation 26.5: it is the
difference of two expectations, and these expectations can be computed by Monte Carlo estimation
using only samples, as in Equation (26.7); despite starting with an objective (Equation 26.21) which
contravened the desired principles for training implicit generative models, variational bounds have
allowed us to construct an approximation which satisfies all desiderata.
Using bounds on the f-divergence, we obtain an objective (26.25) that allows learning both the
generator and critic parameters. We use a critic D with parameters φ to estimate the bound, and
then optimize the parameters θ of the generator to minimize the approximation of the f-divergence
provided by the critic (we replace t above with Dφ, to retain standard GAN notation):
min
θ
Df (p
∗
, qθ) ≥ min
θ
max
φ
Ep∗(x)
[Dφ(x)] − Eqθ(x)
[f
†
(Dφ(x))] (26.26)
= min
θ
max
φ
Ep∗(x)
[Dφ(x)] − Eq(z)
[f
†
(Dφ(Gθ(z)))] (26.27)
This approach to train an implicit generative model leads to f-GANs [NCT16c]. It is worth noting
that there exists an equivalence between the scoring rules in the previous section and bounds on
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license890
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
f-divergences [RW11]: for each scoring rule we can find an f-divergence that leads to the same
training criteria and the same min-max game of Equation 26.27. An intuitive way to grasp the
connection between f-divergences and proper scoring rules is through their use of density ratios:
in both cases the optimal critic approximates a quantity directly related to the density ratio (see
Table 26.2 for f-divergences and Equation (26.11) for scoring rules).
26.2.4 Integral probability metrics
Instead of comparing distributions by using their ratio as we did in the previous two sections, we
can instead study their difference. A general class of measure of difference is given by the Integral
Probability Metrics (Section 2.7.2) defined as:
IF (p
∗
(x), qθ(x)) = sup
f∈F

Ep∗(x)f(x) − Eqθ(x)f(x)


. (26.28)
The function f is a test or witness function that will take the role of the discriminator or critic. To
use IPMs we must define the class of real valued, measurable functions F over which the supremum
is taken, and this choice will lead to different distances, just as choosing different convex functions f
leads to different f-divergences. Integral probability metrics are distributional distances: beyond
satisfying the conditions for distributional divergences D(p
∗
, q) ≥ 0; D(p
∗
, q) = 0 ⇐⇒ p
∗ = q
(Equation (26.3)), they are also symmetric D(p, q) = D(q, p) and satisfy the triangle inequality
D(p, q) ≤ D(p, r) + D(r, q).
Not all function families satisfy these conditions of create a valid distance IF . To see why consider
the case where F = {z} where z is the function z(x) = 0. This choice of F entails that regardless of
the two distributions chosen, the value in Equation 26.28 would be 0, violating the requirement that
distance between two distributions be 0 only if the two distributions are the same. A popular choice
of F for which IF satisfies the conditions of a valid distributional distance is the set of 1-Lipschitz
functions, which leads to the Wasserstein distance [Vil08]:
W1(p
∗
(x), qθ(x)) = sup
f:kfkLip≤1
Ep∗(x)f(x) − Eqθ(x)f(x) (26.29)
We show an example of a Wasserstein critic in Figure 26.3a. The supremum over the set of
1-Lipschitz functions is intractable for most cases, which again suggests the introduction of a learned
critic:
W1(p
∗
(x), qθ(x)) = sup
f:kfkLip≤1
Ep∗(x)f(x) − Eqθ(x)f(x) (26.30)
≥ max
φ:kDφkLip≤1
Ep∗(x)Dφ(x) − Eqθ(x)Dφ(x), (26.31)
where the critic Dφ has to be regularized to be 1-Lipschitz (various techniques for Lipschitz regular￾ization via gradient penalties or spectral normalization methods have been used [ACB17; Gul+17]).
As was the case with f-divergences, we replace an intractable quantity which requires a supremum
over a class of functions with a bound obtained using a subset of this function class, a subset which
can be modeled using neural networks.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.2. LEARNING BY COMPARISON
p
*
q( ) f
(a) Optimal Wasserstein critic.
p
*
q( ) f
(b) Optimal MMD critic.
Figure 26.3: Optimal critics in Integral Probability Metrics (IPMs). Generated by ipm_divergences.ipynb
To train a generative model, we again introduce a min max game:
min
θ
W1(p
∗
(x), qθ(x)) ≥ min
θ
max
φ:kDφkLip≤1
Ep∗(x)Dφ(x) − Eqθ(x)Dφ(x) (26.32)
= min
θ
max
φ:kDφkLip≤1
Ep∗(x)Dφ(x) − Eq(z)Dφ(Gθ(z)) (26.33)
This leads to the popular WassersteinGAN [ACB17].
If we replace the choice of function family F to that of functions in an RKHS (Section 18.3.7.1)
with norm one, we obtain the maximum mean discrepancy (MMD) discussed in Section 2.7.3:
MMD(p
∗
(x), qθ(x)) = sup
f:kfkRKHS=1
Ep∗(x)f(x) − Eqθ(x)f(x). (26.34)
We show an example of an MMD critic in Figure 26.3b. It is often more convenient to use the
square MMD loss [LSZ15; DRG15], which can be evaluated using the kernel K (Section 18.3.7.1):
MMD2
(p
∗
, qθ) = Ep∗(x)Ep∗(x′)K(x, x
′
) − 2Ep∗(x)Eqθ(y)K(x, y) + Eqθ(y)Eqθ(y′)K(y, y
′
) (26.35)
= Ep∗(x)Ep∗(x′)K(x, x
′
) − 2Ep∗(x)Eq(z)K(x, Gθ(z)) + Eq(z)Eq(z′)K(Gθ(z), Gθ(z
′
))
(26.36)
The MMD can be directly used to learn a generative model, often called a generative matching
network [LSZ15]:
min
θ
MMD2
(p
∗
, qθ) (26.37)
The choice of kernel is important. Using a fixed or predefined kernel such as a radial basis function
(RBF) kernel might not be appropriate for all data modalities, such as high dimensional images.
Thus we are looking for a way to learn a feature function ζ such that K(ζ(x), ζ(x
′
)) is a valid kernel;
luckily, we can use that for any characteristic kernel K(x, x
′
) and injective function ζ, K(ζ(x), ζ(x
′
)))
is also a characteristic kernel. While this tells us that we can use feature functions in the MMD
objective, it does not tell us how to learn the features. In order to ensure that the learned features
are sensitive to differences between the data distribution p
∗
(x) and the model distribution qθ(x), the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license892
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
kernel parameters are trained to maximize the square MMD. This again casts the problem into a
familiar min max objective by learning the projection ζ with parameters φ [Li+17b]:
min
θ
MMDζ
2
(pD, qθ) (26.38)
= min
θ
max
φ
Ep∗(x)Ep∗(x′)K(ζφ(x), ζφ(x
′
))
− 2Ep∗(x)Eqθ(y)K(ζφ(x), ζφ(y)) (26.39)
+ Eqθ(y)Eqθ(y′)K(ζφ(y), ζφ(y
′
))
where ζφ is regularized to be injective, though this is sometimes relaxed [Bin+18]. Unlike the
Wasserstein distance and f-divergences, Equation (26.39) can be estimated using Monte Carlo
estimation, without requiring a lower bound on the original objective.
26.2.5 Moment matching
More broadly than distances defined by integral probability metrics, for a set of test statistics s, one
can define a moment matching criteria [Pea36], also known as the method of moments:
min
θ

Ep∗(x)s(x) − Eqθ(x)s(x)


2
2
(26.40)
where m(θ) = Eqθ(x)s(x) is the moment function. The choice of statistic s(x) is crucial, since as with
distributional divergences and distances, we would like to ensure that if the objective is minimized
and reaches the minimal value 0, the two distributions are the same p
∗
(x) = qθ(x). To see that not
all functions s satisfy this requirement consider the function s(x) = x: simply matching the means of
two distributions is not sufficient to match higher moments (such as variance). For likelihood based
models the score function s(x) = log qθ(x) satisfies the above requirement and leads to a consistent
estimator [Vaa00], but this choice of s is not available for implicit generative models.
This motivates the search for other approaches of integrating the method of moments for implicit
models. The MMD can be seen as a moment matching criteria, by matching the means of the two
distributions after lifting the data into the feature space of an RHKS. But moment matching can go
beyond integral probability metrics: Ravuri et al. [Rav+18] show that one can learn useful moments by
using s as the set of features containing the gradients of a trained discriminator classifier Dφ together
with the features of the learned critic: sφ(x) = [∇φDφ(x), h1(x), . . . , hn(x)] where h1(x), . . . , hn(x)
are the hidden activations of the learned critic. Both features and gradients are needed: the gradients
∇φDφ(x) are required to ensure the estimator for the parameters θ is consistent, since the number
of moments s(x) needs to be larger than the number of parameters θ, which will be true if the critic
will have more parameters than the model; the features hi(x) are added since they have been shown
empirically to improve performance, thus showcasing the importance of the choice of test statistics s
used to train implicit models.
26.2.6 On density ratios and differences
We have seen how density ratios (Sections 26.2.2 and 26.2.3) and density differences (Section 26.2.4)
can be used to define training objectives for implicit generative models. We now explore some of the
distinctions between using ratios and differences for learning by comparison, as well as explore the
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.2. LEARNING BY COMPARISON
p
*
q( 1) q( 2)
(a) Failure of the KL divergence to distinguish
between distributions with non-overlapping support:
DKL ￾
p
∗ k qθ1

= DKL ￾
p
∗ k qθ2

= ∞, despite qθ2
being
closer to p
∗ than qθ1
.
p
*
xD (x)
q( )
D
p
*
q( )
p
*
q( )
(b) The density ratio p
∗
qθ
used by the KL divergence and
a smooth estimate given by an MLP, together with the
gradient it provides with respect to the input variable.
Figure 26.4: The KL divergence cannot provide learning signal for distributions without overlapping support
(left), while the smooth approximation given by a learned decision surface like an MLP can (right). Generated
by ipm_divergences.ipynb
effects of using approximations to these objectives using function classes such as neural networks has
on these distinctions.
One often stated downside of using divergences that rely on density ratios (such as f-divergences)
is their poor behavior when the distributions p
∗ and qθ do not have overlapping support. For
non-overlapping support, the density ratio p
∗
qθ
will be ∞ in the parts of the space where p
∗
(x) > 0
but qθ(x) = 0, and 0 otherwise. In that case, the DKL (p
∗ k qθ) = ∞ and the JSD(p
∗
, qθ) = log 2,
regardless of the value of θ. Thus f-divergences cannot distinguish between different model distributions
when they do not have overlapping support with the data distribution, as visualized in Figure 26.4a.
This is in contrast with difference based methods such as IPMs such as the Wasserstein distance and
the MMD, which have smoothness requirements built in the definition of the method, by constraining
the norm of the critic (Equations (26.29) and (26.34)). We can see the effect of these constraints
in Figure 26.3: both the Wasserstein distance and the MMD provide useful signal in the case of
distributions with non-overlapping support.
While the definition of f-divergences relies on density ratios (Equation (26.21)), we have seen that
to train implicit generative models we use approximations to those divergences obtained using a
parametric critic Dφ. If the function family of the critic used to approximate the divergence (via the
bound or class probability estimation) contains only smooth functions, it will not be able to model
the sharp true density ratio, which jumps from 0 to ∞, but it can provide a smooth approximation.
We show an example in Figure 26.4b, where we show the density ratio for two distributions without
overlapping support and an approximation provided by an MLP trained to approximate the KL
divergence using Equation 26.25. Here, the smooth decision surface provided by the MLP can be
used to train a generative model while the underlying KL divergence cannot be; the learned MLP
provides the gradient signal on how to move distribution mass to areas with more density under
the data distribution, while the KL divergence provides a zero gradient almost everywhere in the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licen894
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
space. This ability of approximations to f-divergences to overcome non-overlapping support issues is
a desirable property of generative modeling training criteria, as it allows models to learn the data
distribution regardless of initialization [Fed+18]. Thus while the case of non-overlapping support
provides an important theoretical difference between IPMs and f-divergences, it is less significant in
practice since bounds on f-divergences or class probability estimation are used with smooth critics
to approximate the underlying divergence.
Some density ratio and density difference based approaches also share commonalities: bounds are
used both for f-divergences (variational bounds in Equation 26.25) and for the Wasserstein distance
(Equation (26.31)). These bounds to distributional divergence and distances have their own set of
challenges: since the generator minimizes a lower bound of the underlying divergence or distance,
minimizing this objective provides no guarantees that the divergence will decrease in training. To see
this, we can look at Equation 26.26: its RHS can get arbitrarily low without decreasing the LHS,
the divergence we are interested in minimizing; this is unlike variational upper bound on the KL
divergence used to train variational autoencoders Chapter 21.
26.3 Generative adversarial networks
We have looked at different learning principles that do not require the use of explicit likelihoods, and
thus can be used to train implicit models. These learning principles specify training criteria, but do
not tell us how to train models or parameterize models. To answer these questions, we now look at
algorithms for training implicit models, where the models (both the discriminator and generator) are
deep neural networks; this leads us to generative adversarial networks (GANs). We cover how to
turn learning principles into loss functions for training GANs (Section 26.3.1); how to train models
using gradient descent (Section 26.3.2); how to improve GAN optimization (Section 26.3.4) and how
to assess GAN convergence (Section 26.3.5).
26.3.1 From learning principles to loss functions
In Section 26.2 we discussed learning principles for implicit generative models: class probability
estimation, bounds on f-divergences, integral probability metrics and moment matching. These
principles can be used to formulate loss functions to train the model parameters θ and the critic
parameters φ. Many of these objectives use zero-sum losses via a min-max formulation: the
generator’s goal is to minimize the same function the discriminator is maximizing. We can formalize
this as:
min max V (φ, θ) (26.41)
As an example, we recover the original GAN with the Bernoulli log-loss (Equation (26.19)) when
V (φ, θ) = 1
2
Ep∗(x)
[log Dφ(x)] + 1
2
Eqθ(x)
[log(1 − Dφ(x))]. (26.42)
The reason most of the learning principles we have discussed lead to zero-sum losses is due to
their underlying structure: the critic maximizes a quantity in order to approximate a divergence
or distance — such as an f-divergence or Integral Probability Metric — and the model minimizes
this approximation to the divergence or distance. That need not be the case, however. Intuitively,
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.3. GENERATIVE ADVERSARIAL NETWORKS
the discriminator training criteria needs to ensure that the discriminator can distinguish between
data and model samples, while the generator loss function needs to ensure that model samples are
indistinguishable from data according to the discriminator.
To construct a GAN that is not zero-sum, consider the zero-sum criteria in the original GAN
(Equation 26.42), induced by the Bernoulli scoring rule. The discriminator tries to distinguish between
data and model samples by classifying the data as real (label 1) and samples as fake (label 0), while
the goal of the generator is to minimize the probability that the discriminator classifies its samples
as fake: minθ Eqθ(x)
log(1 − Dφ(x)). An equally intuitive goal for the generator is to maximize
the probability that the discriminator classifies its samples as real. While the difference might
seem subtle, this loss, known as the “nonsaturating loss” [Goo+14], defined as Eqθ(x) − log Dφ(x),
enjoys better gradient properties early in training, as shown in Figure 26.5: the non-saturating loss
provides a stronger learning signal (via the gradient) when the generator is performing poorly, and
the discriminator can easily distinguish its samples from data, i.e., D(G(z)) is low; more on the
gradients properties the saturating and non-saturating losses can be found in [AB17; Fed+18].
There exist many other GAN losses which are not zero-sum, including formulations of LS￾GAN [Mao+17], GANs trained using the hinge loss [LY17], and RelativisticGANs [JM18]. We
can thus generally write a GAN formulation as follows:
min
φ
LD(φ, θ); min
θ
LG(φ, θ). (26.43)
We recover the zero-sum formulations if −LD(φ, θ) = LG(φ, θ) = V (φ, θ). Despite departing from
the zero-sum structure, the nested form of the optimization remains in the general formulation, as
we will discuss in Section 26.3.2.
The loss functions for the discriminator and generator, LD and LG respectively, follow the general
form in Equation 26.5, which allows them to be used to efficiently train implicit generative models.
The majority of loss functions considered here can thus be written as follows:
LD(φ, θ) = Ep∗(x)g(Dφ(x)) + Eqθ(x)h(Dφ(x)) = Ep∗(x)g(Dφ(x)) + Eq(z)h(Dφ(Gθ(z))) (26.44)
LG(φ, θ) = Eqθ(x)
l(Dφ(x)) = Eq(z)
l(Dφ(Gθ(z)) (26.45)
where g, h, l : R → R. We recover the original GAN for g(t) = − log t, h(t) = − log(1 − t) and
l(t) = log(1 − t); the non-saturating loss for g(t) = − log t, h(t) = − log(1 − t) and l(t) = − log(t);
the Wasserstein distance formulation for g(t) = t, h(t) = −t and l(t) = t; for f-divergences g(t) = t,
h(t) = −f
†
(t) and l(t) = f
†
(t).
26.3.2 Gradient descent
GANs employ the learning principles discussed above in conjunction with gradient based learning
for the parameters of the discriminator and generator. We assume a general formulation with a
discriminator loss function LD(φ, θ) and a generator loss function LG(φ, θ). Since the discriminator
is often introduced to approximate a distance or divergence D(p
∗
, qθ) (Section 26.2), for the generator
to minimize a good approximation of that divergence one should solve the discriminator optimization
fully for each generator update. That would entail that for each generator update one would first
find the optimal discriminator parameters φ
∗ = argminφ LD(φ, θ) in order to perform a gradient
update given by ∇θLG(φ
∗
, θ). Fully solving the inner optimization problem φ
∗ = argminφ LD(φ, θ)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license896
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0.0 0.2 0.4 0.6 0.8 1.0
D(G(z))
−5
0
5
Generator Loss
log (1 − D(G(z)))
− log D(G(z))
(a) Generator loss as a function of
discriminator score.
0.0 0.2 0.4 0.6 0.8 1.0
D(G(z))
−200
0
200
Loss Gradient
wrt
D(G(z))
log (1 − D(G(z)))
− log D(G(z))
(b) The gradients of the generator loss with respect
to the discriminator score.
Figure 26.5: Saturating log(1 − D(G(z))) vs non-saturating − log D(G(z)) loss functions. The non-saturating
loss provides stronger gradients when the discriminator is easily detecting that generated samples are fake.
Generated by gan_loss_types.ipynb
for each optimization step of the generator is computationally prohibitive, which motivates the use
of alternating updates: performing a few gradient steps to update the discriminator parameters,
followed by a generator update. Note that when updating the discriminator, we keep the generator
parameters fixed, and when updating the generator, we keep the discriminator parameters fixed. We
show a general algorithm for these alternative updates in Algorithm 26.1.
Algorithm 26.1: General GAN training algorithm with alternating updates
1 Initialize φ, θ
2 for each training iteration do
3 for K steps do
4 Update the discriminator parameters φ using the gradient ∇φLD(φ, θ);
5 Update the generator parameters θ using the gradient ∇θLG(φ, θ)
6 Return φ, θ
We are thus interested in computing ∇φLD(φ, θ) and ∇θLG(φ, θ). Given the choice of loss
functions follows the general form in Equations 26.44 and 26.45 both for the discriminator and
generator, we can compute the gradients that can be used for training. To compute the discriminator
gradients, we write:
∇φLD(φ, θ) = ∇φ

Ep∗(x)g(Dφ(x)) + Eqθ(x)h(Dφ(x))
(26.46)
= Ep∗(x)∇φg(Dφ(x)) + Eqθ(x)∇φh(Dφ(x)) (26.47)
where ∇φg(Dφ(x)) and ∇φh(Dφ(x)) can be computed via backpropagation, and each expectation
can be estimated using Monte Carlo estimation. For the generator, we would like to compute the
gradient:
LG(φ, θ) = ∇θEqθ(x)
l(Dφ(x)) (26.48)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.3. GENERATIVE ADVERSARIAL NETWORKS
Here we cannot change the order of differentiation and integration since the distribution under
the integral depends on the differentiation parameter θ. Instead, we will use that qθ(x) is the
distribution induced by an implicit generative model (also known as the “reparameterization trick”,
see Section 6.3.5):
∇θLG(φ, θ) = ∇θEqθ(x)
l(Dφ(x)) = ∇θEq(z)
l(Dφ(Gθ(z))) = Eq(z)∇θl(Dφ(Gθ(z))) (26.49)
and again use Monte Carlo estimation to approximate the gradient using samples from the prior
q(z). Replacing the choice of loss functions and Monte Carlo estimation in Algorithm 26.1 leads to
Algorithm 26.2, which is often used to train GANs.
Algorithm 26.2: GAN training algorithm
1 Initialize φ, θ
2 for each training iteration do
3 for K steps do
4 Sample minibatch of M noise vectors zm ∼ q(z)
5 Sample minibatch of M examples xm ∼ p
∗
(x)
6 Update the discriminator by performing stochastic gradient descent using this gradient:
∇φ
1
M
PM
m=1 [g(Dφ(xm)) + ∇φh(Dφ(Gθ(zm)))].
7 Sample minibatch of M noise vectors zm ∼ q(z)
8 Update the generator by performing stochastic gradient descent using this gradient:
∇θ
1
M
PM
m=1 l(Dφ(Gθ(zm)).
9 Return φ, θ
26.3.3 Challenges with GAN training
Due to the adversarial game nature of GANs the optimizing dynamics of GANs are both hard to
study in theory, and to stabilize in practice. GANs are known to suffer from mode collapse, a
phenomenon where the generator converges to a distribution which does not cover not all the modes
(peaks) of the data distribution, thus the model underfits the distribution. We show an example in
Figure 26.6: while the data is a mixture of Gaussians with 16 modes, the model converges only to
a few modes. Alternatively, another problematic behavior is mode hopping, where the generator
“hops” between generating different modes of the data distribution. An intuitive explanation for
this behavior is as follows: if the generator becomes good at generating data from one mode, it will
generate more from that mode. If the discriminator cannot learn to distinguish between real and
generated data in this mode, the generator has no incentive to expand its support and generate data
from other modes. On the other hand, if the discriminator eventually learns to distinguish between
the real and generated data inside this mode, the generator can simply move (hop) to a new mode,
and this game of cat and mouse can continue.
While mode collapse and mode hopping are often associated with GANs, many improvements have
made GAN training more stable, and these behaviors more rare. These improvements include using
large batch sizes, increasing the discriminator neural capacity, using discriminator and generator
regularization, as well as more complex optimization methods.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license898
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) Data
Disc Loss: 1.252
Gen Loss: 0.753
(b) 2000 iterations
Disc Loss: 1.136
Gen Loss: 0.740
(c) 4000 iterations
Disc Loss: 0.892
Gen Loss: 1.852
(d) 8000 iterations
Disc Loss: 0.457
Gen Loss: 3.258
(e) 12000 iterations
Disc Loss: 0.305
Gen Loss: 3.016
(f) 14000 iterations
Figure 26.6: Illustration of mode collapse and mode hopping in GAN training. (a) The dataset, a mixture of
16 Gaussians in 2 dimensions. (b-f ) Samples from the model after various amounts of training. Generated by
gan_mixture_of_gaussians.ipynb.
26.3.4 Improving GAN optimization
Hyperparameter choices such as the choice of momentum can be crucial when training GANs, with
lower momentum values being preferred compared to the usual high momentum used in supervised
learning. Algorithms such as Adam [KB14a] provide a great boost in performance [RMC16a]. Many
other optimization methods have been successfully applied to GANs, such as those which target
variance reduction [Cha+19c]; those which backpropagate through gradient steps, thus ensuring that
generator does well against the discriminator after it has been updated [Met+16]; or using a local
bilinear approximation of the two player game [SA19]. While promising, these advanced optimization
methods tend to have a higher computational cost, making them harder to scale to large models or
large datasets compared to less efficient optimization methods.
26.3.5 Convergence of GAN training
The challenges with GAN optimization make it hard to quantify when convergence has occurred. In
Section 26.2 we saw how global convergence guarantees can be provided under optimality conditions for
multiple objectives constructed starting with different distributional divergences and distances: if the
discriminator is optimal, the generator is minimizing a distributional divergence or distance between
the data and model distribution, and thus under infinite capacity and perfect optimization can learn
the data distribution. This type of argument has been used since the original GAN paper [Goo+14]
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.3. GENERATIVE ADVERSARIAL NETWORKS
to connect GANs to standard objectives in generative models, and obtain the associated theoretical
guarantees. From a game theory perspective, this type of convergence guarantee provides an existence
proof of a global Nash equilibrium for the GAN game, though under strong assumptions. A Nash
equilibrium is achieved when both players (the discriminator and generator) would incur a loss if
they decide to act by changing their parameters. Consider the original GAN defined by the objective
in Equation 26.19; then qθ = p
∗ and Dφ(x) = p
∗
(x)
p∗(x)+qθ(x) =
1
2
is a global Nash equilibrium, since
for a given qθ, the ratio p
∗
(x)
p∗(x)+qθ(x)
is the optimal discriminator (Equation 26.11), and given an
optimal discriminator, the data distribution is the optimal generator as it is the minimizer of the
Jensen-Shannon divergence (Equation 26.15).
While these global theoretical guarantees provide useful insights about the GAN game, they do
not account for optimization challenges that arise with accounting for the optimization trajectories of
the two players, or for neural network parameterization since they assume infinite capacity both for
the discriminator and generator. In practice GANs do not decrease a distance or divergence at every
optimization step [Fed+18] and global guarantees are difficult to obtain when using optimization
methods such as gradient descent. Instead, the focus shifts towards local convergence guarantees,
such as reaching a local Nash equilibrium. A local Nash equilibrium requires that both players are at
a local, not global minimum: a local Nash equilibrium is a stationary point (the gradients of the two
loss functions are zero, i.e ∇φLD(φ, θ) = 0 and ∇θLG(φ, θ) = 0), and the eigenvalues of the Hessian
of each player (∇φ∇φLD(φ, θ) and ∇θ∇θLG(φ, θ)) are non-negative; for a longer discussion on
Nash equilibria in continuous games, see [RBS16]. For the general GAN game, it is not guaranteed
that a local Nash equilibrium always exists [FO20], and weaker conditions such as stationarity or
locally stable stationarity have been studied [Ber+19]; other equilibrium definitions inspired by game
theory have also been used [JNJ20; HLC19].
To motivate why convergence analysis is important in the case of GANs, we visualize an example
of a GAN that does not converge trained with gradient descent. In DiracGAN [MGN18a] the data
distribution p
∗
(x) is the Dirac delta distribution with mass at zero. The generator is modeling a
Dirac delta distribution with parameter θ: Gθ(z) = θ and the discriminator is a linear function of the
input with learned parameter φ: Dφ(x) = φx. We also assume a GAN formulation where g = h = −l
in the general loss functions LD and LG defined above, see Equations (26.44) and (26.45). This
results in the zero-sum game given by:
LD = Ep∗(x) − l(Dφ(x)) + Eqθ(x) − l(Dφ(x)) = −l(0) − l(θφ) (26.50)
LG = Ep∗(x)
l(Dφ(x)) + Eqθ(x)
l(Dφ(x)) = +l(0) + l(θφ) (26.51)
where l depends on the GAN formulation used (l(z) = − log(1 + e
−z
) for instance). The unique
equilibrium point is θ = φ = 0. We visualize the DiracGAN problem in Figure 26.7 and show that
DiracGANs with alternating gradient descent (Algorithm 26.1) do not reach the equilibrium point,
but instead takes a circular trajectory around the equilibrium.
There are two main theoretical approaches taken to understand GAN convergence behavior around
an equilibrium: by analyzing either the discrete dynamics of gradient descent, or the underlying
continuous dynamics of the game using approaches such as stability analysis. To understand the
difference between the two approaches, consider the discrete dynamics defined by gradient descent
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license900
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
x
Dϕ(x) = ϕx
p
*
qθ
(a) The DiracGAN problem.
ϕ
θ
equilibruim (0, 0)
Alternating gradient descent
(b) Alternating gradient descent on
DiracGAN.
Figure 26.7: Visualizing divergence using a simple GAN: DiracGAN. Generated by dirac_gan.ipynb
with learning rates αh and λh, either via alternating updates (as we have seen in Algorithm 26.1):
φt = φt−1 − αh∇φLD(φt−1
, θt−1), (26.52)
θt = θt−1 − λh∇θLG(φt
, θt−1) (26.53)
or simultaneous updates, where instead of alternating the gradient updates between the two players,
they are both updated simultaneously:
φt = φt−1 − αh∇φLD(φt−1
, θt−1), (26.54)
θt = θt−1 − λh∇θLG(φt−1
, θt−1) (26.55)
The above dynamics of gradient descent are obtained using Euler numerical integration from the
ODEs that describes the game dynamics of the two players:
φ˙ = −∇φLD(φ, θ), (26.56)
θ˙ = −∇θLG(φ, θ) (26.57)
One approach to understand the behavior of GANs is to study these underlying ODEs, which,
when discretized, result in the gradient descent updates above, rather than directly studying the
discrete updates. These ODEs can be used for stability analysis to study the behavior around an
equilibrium. This entails finding the eigenvalues of the Jacobian of the game
J =

−∇φ∇φLD(φ, θ) −∇θ∇φLD(φ, θ)
−∇φ∇θLG(φ, θ) −∇θ∇θLG(φ, θ)

(26.58)
evaluated at a stationary point (i.e., where ∇φLD(φ, θ) = 0 and ∇θLG(φ, θ) = 0). If the eigenvalues
of the Jacobian all have negative real parts, then the system is asymptotically stable around the
equilibrium; if at least one eigenvalue has positive real part, the system is unstable around the
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.3. GENERATIVE ADVERSARIAL NETWORKS
ϕ
θ
equilibruim (0, 0)
Continuous dynamics
ϕ
θ
equilibruim (0, 0)
Simultaneous gradient descent
Figure 26.8: Continuous (left) and discrete dynamics (right) take different trajectories in DiracGAN. Generated
by dirac_gan.ipynb
equilibrium. For the DiracGAN, the Jacobian evaluated at the equilibrium θ = φ = 0 is:
J =

∇φ∇φl(θφ) + l(0) ∇θ∇φl(θφ) + l(0)
−∇φ∇θ (l(θφ) + l(0)) −∇θ∇θ (l(θφ) + l(0))
=

0 l
′
(0)
−l
′
(0) 0 
(26.59)
where eigenvalues of this Jacobian are λ± = ±il′
(0). This is interesting, as the real parts of the
eigenvalues are both 0; this result tells us that there is no asymptotic convergence to an equilibrium,
but linear convergence could still occur. In this simple case we can reach the conclusion that
convergence does not occur as we observe that there is a preserved quantity in this system, as θ
2 + φ
2
does not change in time (Figure 26.8, left):
d
￾
θ
2 + φ
2

dt = 2θ
dθ
dt + 2φ
dφ
dt = −2θl′
(θφ)φ + 2φl′
(θφ)θ = 0.
Using stability analysis to understand the underlying continuous dynamics of GANs around
an equilibrium has been used to show that explicit regularization can help convergence [NK17;
Bal+18]. Alternatively, one can directly study the updates of simultaneous gradient descent shown
in Equations 26.54 and 26.55. Under certain conditions, [MNG17b] prove that GANs trained with
simultaneous gradient descent reach a local Nash equilibrium. Their approach relies on assessing the
convergence of series of the form F
k
(x) resulting from the repeated application of gradient descent
update of the form F(x) = x + hG(x), where h is the learning rate. Since the function F depends
on the learning rate h, their convergence results depend on the size of the learning rate, which is not
the case for continuous time approaches.
Both continuous and discrete approaches have been useful in understanding and improving GAN
training; however, both approaches still leave a gap between our theoretical understanding and the
most commonly used algorithms to train GANs in practice, such as alternating gradient descent
or more complex optimizers used in practice, like Adam. Far from only providing different proof
techniques, these approaches can reach different conclusions about the convergence of a GAN: we
show an example in Figure 26.8, where we see that simultaneous gradient descent and the continuous
dynamics behave differently when a large enough learning rate is used. In this case, the discretization
error — the difference between the behavior of the continuous dynamics in Equations 26.56 and 26.57
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens902
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
and the gradient descent dynamics in Equations 26.54 and 26.55 — makes the analysis of gradient
descent using continuous dynamics reach the wrong conclusion about DiracGAN [Ros+21]. This
difference in behavior has been a motivator to train GANs with higher order numerical integrators
such as RungeKutta4, which to more closely follow the underlying continuous system compared to
gradient descent [Qin+20].
While optimization convergence analysis is an indispensable step in understanding GAN training
and has led to significant practical improvements, it is worth noting that ensuring converge to
an equilibrium does not ensure the model has learned a good fit of the data distribution. The
loss landscape determined by the choice of LD and LG, as well as the parameterization of the
discriminator and generator can lead to equilibria which do not capture the data distribution. The
lack of distributional guarantees provided by game equilibria showcases the need to complement
convergence analysis with work looking at the effect of gradient based learning in this game setting
on the learned distribution.
26.4 Conditional GANs
We have thus far discussed how to use implicit generative models to learn a true unconditional
distribution p
∗
(x) from which we only have samples. It is often useful, however, to be able to learn
conditional distributions of the from p
∗
(x|y). This requires having paired data, where each input
xn is paired with a corresponding set of covariates yn, such as a class label, or a set of attributes
or words, so D = {(xn, yn) : n = 1 : N}, as in standard supervised learning. The conditioning
variable can be discrete, like a class label, or continuous, such as an embedding which encodes other
information. Conditional generative models are appealing since we can specify that we want the
generated sample to be associated with conditioning information y, making them very amenable to
real world applications, as we discuss in Section 26.7.
To be able to learn implicit conditional distributions qθ(x|y), we require datasets that specify the
conditioning information associated with data, and we have to adapt the model architectures and
loss functions. In the GAN case, changing the loss function for the generative model can be done by
changing the critic, since the critic is part of the loss function of the generator; it is important for the
critic to provide learning signal accounting for conditioning information, by penalizing a generator
which provides realistic samples but which ignore the provided conditioning.
If we do not change the form of the min-max game, but provide the conditioning information to
the two players, a conditional GAN can be created from the original GAN game [MO14]:
min
θ
max
φ
1
2
Ep(y)Ep∗(x|y)
[log Dφ(x, y)] + 1
2
Ep(y)Eqθ(x|y)
[log(1 − Dφ(x, y))] (26.60)
In the case of implicit latent variable models, the embedding information becomes an additional
input to the generator, together with the latent variable z:
min
θ
max
φ
L(θ, φ) = 1
2
Ep(y)Ep∗(x|y)
[log Dφ(x, y)] + 1
2
Ep(y)Eq(z)
[log(1 − Dφ(Gθ(z, y), y))] (26.61)
For discrete conditioning information such as labels, one can also add a new loss function, by
training a critic which does not only learn to distinguish between real and fake data, but learns
to classify both data and generated samples as pertaining to one of the K classes provided in the
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.5. INFERENCE WITH GANS
features data
z G G(z)
E(x) E x
G(z), z
x, E(x)
D P(y)
Figure 26.9: Learning an implicit posterior using an adversarial approach, as done in BiGAN. From Figure 1
of [DKD16]. Used with kind permission of Jeff Donahue.
dataset [OOS17]:
Lc(θ, φ) = −

1
2
Ep(y)Ep∗(x|y)
[log Dφ(y|x)] + 1
2
Ep(y)Eqθ(x|y)
[log(Dφ(y|x))]
(26.62)
Note that while we could have two critics, one unsupervised critic and one supervised which
maximizes the equation above, in practice the same critic is used, to aid shaping the features used in
both decision surfaces. Unlike the adversarial nature of the unsupervised game, it is in the interest
of both players to minmize the classification loss Lc. Thus together with the adversarial dynamics
provided by L, the two players are trained as follows:
max
φ
L(θ, φ) − Lc(θ, φ) min
θ
L(θ, φ) + Lc(θ, φ) (26.63)
In the case of conditional latent variable models, the latent variable controls the sample variability
inside the mode specified by the conditioning information. In early conditional GANs, the conditioning
information was provided as additional input to the discriminator and generator, for example by
concatenating the conditioning information to the latent variable z in the case of the generator; it
has been since observed that it is important to provide the conditioning information at various layers
of the model, both for the generator and the discriminator [DV+17; DSK16] or use a projection
discriminator [MK18].
26.5 Inference with GANs
Unlike other latent variable models such as variational autoencoders, GANs do not define an inference
procedure associated with the generative model. To deploy the principles behind GANs to find
a posterior distribution p(z|x), multiple approaches have been taken, from combining GANs and
variational autoencoders via hybrid methods [MNG17a; Sri+17; Lar+16; Mak+15b] to constructing
inference methods catered to implicit variable models [Dum+16; DKD16; DS19]. An overview of
these methods can be found in [Hus17b].
GAN based methods which perform inference and learn implicit posterior distribution p(z|x)
introduce changes to the GAN algorithm to do so. An example of such a method is BiGAN
(bidirectional GAN) [DKD16] or ALI (adversarialy learned inference) [Dum+16], which trains an
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license904
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
implicit parameterized encoder Eζ to map input x to latent variables z. To ensure consistency between
the encoder Eζ and the generator Gθ, an adversarial approach is introduced with a discriminator
Dφ learning to distinguish between pairs of data and latent samples: Dφ learns to consider pairs
(x, Eζ(x)) with x ∼ p
∗ as real, while (Gθ(z), z) with z ∼ q(z) is considered fake. This approach,
shown in Figure 26.9, ensures that the joint distributions are matched, and thus the marginal
distribution qθ(x) given by Gθ should learn p
∗
(x), while the conditional distribution pζ(z|x) given by
Eζ should learn qθ(z|x) = qθ(x,z)
qθ(x) ∝ qθ(x|z)q(z). This joint GAN loss can be used both to train the
generator Gθ and the encoder Eζ, without requiring a reconstruction loss common in other inference
methods. While not using a reconstruction loss, this objective retains the property that under
global optimality conditions the encoder and decoder are inverses of each other: Eθ(Gζ(z)) = z and
Gζ(Eθ(x)) = x. (See also Section 21.2.4 for a discussion of how VAEs learn to ensure p
∗
(x)pζ(z|x)
matches p(z)pθ(x|z) using an explicit model of the data.)
26.6 Neural architectures in GANs
We have so far discussed the learning principles, algorithms, and optimization methods that can
be used to train implicit generative models parameterized by deep neural networks. We have not
discussed, however, the importance of the choice of neural network architectures for the model and
the critic, choices which have fueled the progress in GAN generation since their conception. We will
look at a few case studies which show the importance of information about data modalities into
the critic and the generator (Section 26.6.1), employing the right inductive biases (Section 26.6.2),
incorporating attention in GAN models (Section 26.6.3), progressive generation (Section 26.6.4),
regularization (Section 26.6.5), and using large scale architectures (Section 26.6.6).
26.6.1 The importance of discriminator architectures
Since the discriminator or critic is rarely optimal — either due to the use of alternating gradient
descent or the lack of capacity of the neural discriminator — GANs do not perform distance or
divergence minimization in practice. Instead, the critic acts as part of a learned loss function
for the model (the generator). Every time the critic is updated, the loss function for the generative
model changes; this is in stark contrast with divergence minimization such maximum likelihood
estimation, where the loss function stays the same throughout the training of the model. Just as
learning features of data instead of handcrafting them is a reason for the success of deep learning
methods, learning loss functions advanced the state of the art of generative modeling. Critics that
take data modalities into account — such as convolutional critics for images and recurrent critics
for sequential data such as text or audio — become part of data modality dependent loss functions.
This in turn provides modality-specific learning signal to the model, for example by penalizing blurry
images and encouraging sharp edges, which is achieved due to the convolutional parameterization of
the critic. Even within the same data modality, changes to critic architectures and regularization
have been one of the main drivers in obtaining better GANs, since they affect the generator’s loss
function, and thus also the gradients of the generator and have a strong effect on optimization.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.6. NEURAL ARCHITECTURES IN GANS
512
256
128
3
64
64
32
16
32
16
8
8
5
5
5
5
5
5
100 z
Project and reshape Deconv 1
Deconv 2
Deconv 3
Stride 2
Stride 2
Stride 2
G(z)
1024
4
4
5
5
Stride 2
Deconv 4
Figure 26.10: DCGAN convolutional generator. From Figure 1 of [RMC15]. Used with kind permission of
Alec Radford.
10 256
10 128
10 64
32
32
16
8
16
8
4
4
5
5
5
5
5
5
Conv 3
Conv 2
Conv 1
Stride 2
Stride 2
Stride 2
3
1
10
D(x|y)
D(G(z|y)|y) 
Flatten and 
concatenate y 
4096
10
Figure 26.11: DCGAN convolutional discrimiantor. From Figure 1 of [RMC15]. Used with kind permission
of Alec Radford.
26.6.2 Architectural inductive biases
While the original GAN paper used convolutions only sparingly, deep convolutional GAN (DC￾GAN) [RMC15] performed an extensive study on what architectures are most useful for GAN
training, resulting in a set of useful guidelines that led to a substantial boost in performance. Without
changing the learning principles behind GANs, DCGAN was able to obtain better results on image
data by using convolutional generators (Figure 26.10) and critics, using BatchNormalization for both
the generator and critic, replacing pooling layers with strided convolutions, using ReLU activation
networks in the generator, and LeakyReLU activations in the discriminator. Many of these principles
are still in use today, for larger architectures and with various loss functions. Since DCGAN, residual
convolutional layers have become a key staple of both models and critics for image data [Gul+17],
and recurrent architectures are used for sequence data such as text [SSG18b; Md+19].
26.6.3 Attention in GANs
Attention mechanisms are explained in detail in Section 16.2.7. In this section, we discuss how to
use them for both the GAN generator and discriminator; this is called the self attention GAN or
SAGAN model [Zha+19c]. The advantage of self attention is that it ensures that both discriminator
and generator have access to a global view of other units of the same layer, unlike convolutional
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license906
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 26.12: Attention queries used by a SAGAN model, showcasing the global span of attention. Each row
first shows the input image and a set of color coded query locations in the image. The subsequent images
show the attention maps corresponding to each query location in the first image, with the query color coded
location being shown, and arrows from it to the attention map are used to highlight the most attended regions.
From Figure 1 of [Zha+19c]. Used with kind permission of Han Zhang.
layers. This is illustrated in Figure 26.12, which visualizes the global span of attention: query points
can attend to various other areas in the image.
The self-attention mechanism for convolutional features reshaped to h ∈ R
C×N is defined by
f = Wfh, g = Wgh, S = f
T g, where Wf ∈ R
C
′×C , Wg ∈ R
C
′×C , where C
′ ≤ C is a hyperparameter.
From S ∈ R
N×N , a probability row matrix β is obtained by applying the softmax operator for each
row, which is then used to attend to a linear transformation of the features o = Wo(Whh)β
T ∈ RC×N ,
using learned operators Wh ∈ R
C
′×C , Wo ∈ R
C×C
′
. An output is then created by y = γo + h, where
γ ∈ R is a learned parameter.
Beyond providing global signal to the players, it is worth noting the flexibility of the self attention
mechanism. The learned parameter γ ensures that the model can decide not to use the attention
layer, and thus adding self attention does not restrict the set of possible models an architecture
can learn. Moreover, self attention significantly increases the number of parameters of the model
(each attention layer introduced 4 learned matrices Wf ,Wg,Wh,Wo), an approach that has been
observed as a fruitful way to improve GAN training.
26.6.4 Progressive generation
One of the first successful approaches to generating higher resolution, color images from a GAN
is via an iterative process, by first generating a lower dimensional sample, and then using that as
conditioning information to generate a higher dimensional sample, and repeating the process until the
desired resolution is reached. LapGAN [DCF+15] uses a Laplacian pyramid as the iterative building
block, by first upsampling the lower dimensional samples using a simple upsampling operation, such
as smoothed upsampling, and then using a conditional generator to produce a residual to be added
to the upsampled version to produce the higher resolution sample. In turn, this higher resolution
sample can then be provided to another LapGAN layer to produce another, even higher resolution
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.6. NEURAL ARCHITECTURES IN GANS
G2
~
I3
G3
z2
~
h2
z3
G1
z1
G0
z0
~
I2
l2
~
I0
h0
~
I1
~
~
h1
l1
l0
Figure 26.13: LapGAN generation algorithm: the generation process starts with a low dimension sample,
which gets upscaled and residually added to the output of a generator at a higher resolution. The process gets
repeated multiple times. From Figure 1 of [DCF+15]. Used with kind permission of Emily Denton.
4x4
G
D
4x4
8x8
Reals
4x4
4x4
Reals
8x8
4x4
Latent
Reals
4x4
…
Training progresses
Latent Latent
1024x1024
1024x1024
Figure 26.14: ProgressiveGAN training algorithm. The input to the discriminator at the bottom of the figure
is either a generated image, or a real image (denotes as ‘Reals’ in the figure) at the corresponding resolution.
From Figure 1 of [Kar+18]. Used with kind permission of Tero Karras.
sample, and so on — this process is shown in Figure 26.13. In LapGAN, a different generator
and critic are trained for each iterative block of the model; in ProgressiveGAN [Kar+18] the lower
resolution generator and critic are “grown”, by becoming part of the generator and critic used to
learn to generate higher resolution samples. The higher resolution generator is obtained by adding
new layers on top of the last layer of the lower resolution generator. A residual connection between
an upscaled version of the lower dimensional sample and the output of the newly created higher
resolution generator is added, which is annealed from 0 to 1 in training — transitioning from using
the upscaled version of the lower dimensional sample early in training, to only using the sample of
the higher resolution generator at the end of training. A similar change is done to the discriminator.
Figure 26.14 shows the growing generator and discriminators in ProgressiveGAN training.
26.6.5 Regularization
Regularizing both the discriminator and the generator has by now a long tradition in GAN training.
Regularizing GANs can be justified from multiple perspectives: theoretically, as it has been shown to
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license908
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
be tied to convergence analysis [MGN18b]; empirically, as it has been shown to help performance and
stability in practice [RMC15; Miy+18c; Zha+19c; BDS18]; and intuitively, as it can be used to avoid
overfitting in the discriminator and generator. Regularization approaches include adding noise to the
discriminator input [AB17], adding noise to the discriminator and generator hidden features [ZML16],
using BatchNorm for the two players [RMC15], adding dropout in the discriminator [RMC15],
spectral normalization [Miy+18c; Zha+19c; BDS18], and gradient penalties (penalizing the norm
of the discriminator gradient with respect to its input k∇xDφ(x)k
2
) [Arb+18; Fed+18; ACB17;
Gul+17]. Often regularization methods help training regardless of the type of loss function used,
and have been shown to have effects both on training performance as well as the stability of the
GAN game. However, improving stability and improving performance in GAN training can be at
odds with each other, since too much regularization can make the models very stable but reduce
performance [BDS18].
26.6.6 Scaling up GAN models
By combining many of the architectural tricks discussed thus far — very large residual networks, self
attention, spectral normalization both in the discriminator and the generator, BatchNormalization
in the generator — one can train GANs to generating diverse, high quality data, as done with
BigGAN [BDS18], StyleGAN [Kar+20c], and alias-free GAN [Kar+21]. Beyond combining carefully
chosen architectures and regularization, creating large scale GANs also require changes in optimization,
with large batch sizes being a key component. This furthers the view that the key components of the
GAN game — the losses, the parameterization of the models, and the optimization method — have
to be viewed collectively rather than in isolation.
26.7 Applications
The ability to generate new plausible data enables a wide range of applications for GANs. This
section will look at a set of applications that aim to demonstrate the breadth of GANs across different
data modalities, such as images (Section 26.7.1), video (Section 26.7.2), audio (Section 26.7.3), and
text (Section 26.7.4), and include applications such as imitation learning (Section 26.7.5), domain
adapation (Section 26.7.6), and art (Section 26.7.7).
26.7.1 GANs for image generation
The most widely studied application area is in image generation. We focus on the translation of one
image to another using either paired or unpaired datasets. There are many other topics related to
image GANs that we do not cover, and a more complete overview can be found in other sources,
such as [Goo16] for the theory and [Bro19] for the practice. A JAX notebook which uses a small
pretrained GAN to generate some face images can be found at GAN_JAX_CelebA_demo.ipynb.
We show the progression of quality in sample generation of faces using GANs in Figure 26.15. There
is also increasing need to consider the generation of images with regards to the potential risks they
can have when used in other domains, which involve discussions of synthetic media and deep fakes,
and sources for discussion include [Bru+18; Wit].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.7. APPLICATIONS
Figure 26.15: Increasingly realistic synthetic faces generated by different kinds of GAN, specifically (from
left to right): original GAN [Goo+14], DCGAN [RMC15], CoupledGAN [LT16], ProgressiveGAN [Kar+18],
StyleGAN [KLA19]. Used with kind permission of Ian Goodfellow. An online demo, which randomly generates
face images using StyleGAN, can be found at https: // thispersondoesnotexist. com .
26.7.1.1 Conditional image generation
Class-conditional image generation using GANs has become a very fruitful endeavor. BigGAN [BDS18]
carries out class-conditional generation of ImageNet samples across a variety of categories, from
dogs and cats to volcanoes and hamburgers. StyleGAN [KLA19] is able to generate high quality
images of faces at high resolution by learning a conditioning style vector and the ProgressiveGAN
architecture discussed in Section 26.6.4. By learning the conditioning vector they are able to generate
samples which interpolate between the styles of other samples, for example by preserving coarser
style elements such as pose or face shape from one sample, and smaller scale style elements such as
hair style from another; this provides fine grained control over the style of the generated images.
26.7.1.2 Paired image-to-image generation
We have discussed in Section 26.4 how using paired data of the form (xn, yn) can be used to build
conditional generative models of p(x|y). In some cases, the conditioning variable y has the same
size and shape as the output variable x. The resulting model pθ(x|y) can then be used to perform
image to image translation, as illustrated in Figure 26.16, where y is drawn from the source
domain, and x from the target domain. Collecting paired data of this form can be expensive,
but in some cases, we can acquire it automatically. One such example is image colorization, where
a paired dataset can easily be obtained by processing color images into grayscale images (see e.g.,
[Jas]).
A conditional GAN used for paired image-to-image translation was proposed in [Iso+17], and
is known as the pix2pix model. It uses a U-net style architecture for the generator, as used for
semantic segmentation tasks. However, they replace the batch normalization layers with instance
normalization, as in neural style transfer.
For the discriminator, pix2pix uses a patchGAN model, that tries to classify local patches as
being real or fake (as opposed to classifying the whole image). Since the patches are local, the
discriminator is forced to focus on the style of the generated patches, and ensure they match the
statistics of the target domain. A patch-level discriminator is also faster to train than a whole-image
discriminator, and gives a denser feedback signal. This can produce results similar to Figure 26.16
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license910
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Labels to Facade BW to Color
Aerial to Map
Labels to Street Scene
Edges to Photo
input output input
input input
input output
output
output output
input output
Day to Night
Figure 26.16: Example results on several image-to-image translation problems as generated by the pix2pix
conditional GAN. From Figure 1 of [Iso+17]. Used with kind permission of Phillip Isola.
(depending on the dataset).
26.7.1.3 Unpaired image-to-image generation
A major drawback of conditional GANs is the need to collect paired data. It is often much easier
to collect unpaired data of the form Dx = {xn : n = 1 : Nx} and Dy = {yn : n = 1 : Ny}. For
example, Dx might be a set of daytime images, and Dy a set of night-time images; it would be
impossible to collect a paired dataset in which exactly the same scene is recorded during the day and
night (except using a computer graphics engine, but then we wouldn’t need to learn a generator).
We assume that the datasets Dx and Dy come from the marginal distributions p(x) and p(y)
respectively. We would then like to fit a joint model of the form p(x, y), so that we can compute
conditionals p(x|y) and p(y|x) and thus translate from one domain to another. This is called
unsupervised domain translation.
In general, this is an ill-posed problem, since there are an infinite number of different joint
distributions that are consistent with a set of marginals p(x) and p(y). We can try, however, to learn
a joint distribution such that samples from it satisfy additional constraints. For example, if G is a
conditional generator that maps a sample from X to Y, and F maps a sample from Y to X , it is
reasonable to require that these be inverses of each other, i.e., F(G(x)) = x and G(F(y)) = y. This
is called a cycle consistency loss [Zhu+17]. We can encourage G and F to satisfy this constraint
by using a penalty term on the difference between the starting image and the image we get after
going through this cycle:
Lcycle = Ep(x)
||F(G(x)) − x||1 + Ep(y)
||G(F(y)) − y||1 (26.64)
To ensure that the outputs of G are samples from p(y) and those of F are samples from p(x), we
use a standard GAN approach, introducing discriminators DX and DY , which can be done using
any choice of GAN loss LGAN, as visualized in Figure 26.17. Finally, we can optionally check that
applying the conditional generator to images from its own domain does not change them:
Lidentity = Ep(x)kx − F(x)k1 + Ep(y)ky − G(y)k1 (26.65)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.7. APPLICATIONS
X Y
G
F
DX DY
G
F
Yˆ
X Y
(
X Y
(
G
F
Xˆ
(a) (b) (c)
cycle-consistency
loss
cycle-consistency
loss
DY DX
x xˆ y yˆ
Figure 26.17: Illustration of the CycleGAN training scheme. (a) Illustration of the 4 functions that are
trained. (b) Forwards cycle consistency from X back to X . (c) Backwards cycle consistency from Y back to
Y. From Figure 3 of [Zhu+17]. Used with kind permission of Jun-Yan Zhu.
Zebras Horses
horse zebra
zebra horse
Summer Winter
summer winter
winter summer
Photograph Monet Van Gogh Cezanne Ukiyo-e
Monet Photos
Monet photo
photo Monet
Figure 26.18: Some examples of unpaired image-to-image translation generated by the CycleGAN model.
From Figure 1 of [Zhu+17]. Used with kind permission of Jun-Yan Zhu.
We can combine all three of these consistency losses to train the translation mappings F and G,
using hyperparameters λ1 and λ2:
L = LGAN + λ1Lcycle + λ2Lidentity (26.66)
CycleGAN results on various datasets are shown in Figure 26.18. The bottom row shows how
CycleGAN can be used for style transfer.
26.7.2 Video generation
The GAN framework can be expanded from individual images (frames) to videos; the techniques
used to generate realistic images can also be applied to generate videos, with additional techniques
required to ensure spatio-temporal consistency. Spatio-temporal consistency is obtained by ensuring
that the discriminator has access to the real data and generated sequences in order, thus penalizing
the generator when generating realistic individual frames without respecting temporal order [SMS17;
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license912
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Sai+20; CDS19; Tul+18]. Another discriminator can be employed to additionally ensure each frame
is realistic [Tul+18; CDS19]. The generator itself needs to have a temporal element, which is often
implemented through a recurrent component. As with images, the generation framework can be
expanded to video-to-video translation [Ban+18; Wan+18], encompassing applications such as motion
transfer [Cha+19a].
26.7.3 Audio generation
Generative models have been demonstrated in the tasks of generating audio waveforms, as well
as for the task of text-to-speech (TTS) generation. Other types of generative models, such as
autoregressive models, such as WaveNet [oor+16] and WaveRNN [Kal+18b] have been developed for
these applications, although autoregressive models are difficult to parallelize over time since they
predict each time step of the audio sequentially and can be computationally expensive and too slow
to be used in practice. GANs provide an alternative approach for these tasks and other paths for
addressing these concerns.
Many different GAN architectures have been developed for audio-only generation, including
generation of single note recordings from instruments by GANSynth, a vocoder model that uses
GANs to generate magnitude spectrograms from mel-spectrograms [Eng+18], in voice conversion
using a modified CycleGAN discussed above [Kan+20], and the direct generation of raw audio in
WaveGAN [DMP18].
Initial work on GANs for TTS was developed [Yan+17] whose approach is similar to conditional
GANs for image generation (see Section 26.7.1.2), but uses 1d convolution instead of 2d. More
recent GANs such as GAN-TTS [Biń+19] use more advanced architectures and discriminators that
operate at multiple frequency scales that have performance that now matches the best performing
autoregressive models when assessed using mean opinion scores. In both the direct-audio generation,
the ability of GANs to allow faster generation and different types of context is the advantage that
makes them advantageous compared to other models.
26.7.4 Text generation
Similar to image and audio domains, there are several tasks for text data for which GAN-based
approaches have been developed, including conditional text generation and text-style transfer. Text
data are often represented as discrete values, at either the character level or the word-level, indicating
membership within a set of a particular vocabulary size (alphabet size, or number of words). Due to
the discrete nature of text, GAN models trained on text are explicit, since they explicitly model the
probability distribution of the output, rather than modeling the sampling path. This is unlike most
GAN models of continuous data such as images that we have discussed in the chapter so far, though
explicit GANs of continuous data do exist [Die+19b].
The discrete nature of text is why maximum likelihood is one of the most common methods of
learning generative models of text. However, models trained with maximum likelihood are often
limited to autoregressive models, while like in the audio case, GANs make it possible to generate
text in a non-autoregressive manner, making other tasks possible, such as one-shot feedforward
generation [Gul+17].
The difficulty of generating discrete data such as text using GANs can be seen looking at their
loss function, such as in Equations (26.19), (26.21) and (26.28). GAN losses contain terms of
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.7. APPLICATIONS
the form Eqθ(x)f(x), which we not only need to evaluate, but also backpropagate through, by
computing ∇θEqθ(x)f(x). In the case of implicit distributions given by latent variable models, we
used the reparameterization trick to compute this gradient (Equation 26.49). In the discrete case, the
reparameterization trick is not available and we have to look for other ways to estimate the desired
gradient. One approach is to use the score function estimator, discussed in Section 6.3.4. However,
the score function estimator exhibits high gradient variance, which can destabilize training. One
common approach to avoid this issue is to pre-train the language model generator using maximum
likelihood, and then to fine-tune with a GAN loss which gets backpropagated into the generator
using the score-function estimator, as done by Sequence GAN [Yu+17], MaliGAN [Che+17], and
RankGAN [Lin+17a]. While these methods spearheaded the use of GANs for text, they do not
address the inherent instabilities of score function estimation and thus have to limit the amount of
adversarial fine tuning to a small number of epochs and often use a small learning rate, keeping their
performance close to that of the maximum-likelihood solution [SSG18a; Cac+18].
An alternative to maximum likelihood pretraining is to use other approaches to stabilize the score
function estimator or to use continuous relaxations for backpropagation. ScratchGAN is a word-level
model that uses large batch sizes and discriminator regularization to stabilize score function training
(these techniques are the same that we have seen as stabilizers for training image GANs) [Md+19].
[Pre+17b] completely avoid the score function estimator and develop a character level model without
pre-training, by using continuous relaxations and curriculum learning. These training approaches
can also benefit from other architectural advances, e.g., [NNP19] showed that language GANs can
benefit from complex architectures such as relation networks [San+17].
Finally, unsupervised text style transfer, mimicking image style transfer, have been proposed by
[She+17; Fu+17] using adversarial classifiers to decode to a different style/language, or like [Pra+18]
who trains different encoders, one per style, by combining the encoder of a pre-trained NMT and
style classifiers, among other approaches.
26.7.5 Imitation learning
Imitation learning takes advantage of observations of expert demonstrations to learn action policies
and reward functions of unknown environments by minimizing some form of discrepancy between
the learned and the expert behaviors. There are many approaches available, including behavioral
cloning [PPG91] that treats this problem as one of supervised learning, and inverse reinforcement
learning [NR00b]. GANs are appealing for imitation learning since they provide a way to avoid the
difficulty of designing good discrepancy functions for behaviors, and instead learn these discrepancy
functions using a discriminator between trajectories generated by a learned agent and observed
demonstrations.
This approach, known as generative adversarial imitation learning (GAIL) [HE16a] demonstrates
the ability to use GANs for complex behaviors in high-dimensional environments. GAIL jointly
learns a generator, which forms a stochastic policy, along with a discriminator that acts as a reward
signal. Like we saw in the probabilistic development of GANs in the earlier sections, GAIL can
also be generalized to multiple f-divergences, rather than the standard Jensen-Shannon divergence
used as the standard loss in GANs. This has led to a family of other GAIL variants that use
other f-divergences [Ke+19a; Fin+16; Bro+20c], including f-GAIL that aims to also learn the
best f-divergence to use [Zha+20e], as well as new analytical insight into the computation and
generalization of such approaches [Che+20b].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license914
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
26.7.6 Domain adaptation
An important task in machine learning is to correct for shifts in the data distribution over time,
minimizing some measure of domain shift, as we discuss in Section 19.5.3. Like with the other
applications, GANs are popular as ways of avoiding the choice of distance or degree of shift. Both
the supervised and unsupervised approaches for image generation we reviewed earlier looked at pixel￾level domain adaptation models that perform distribution alignment in raw pixel space, translating
source data to the style of a target domain, as with pix2pix and CycleGAN. Extensions of these
approaches for the general problem of domain adaptation seek to do this not only in the observed
data space (e.g., with pixels), but also at the feature level. One general approach is domain￾adversarial training of neural networks [Gan+16b] or adversarial discriminative domain adaptation
(ADDA) [Tze+17]. The CyCADA approach of [Hof+18] extends CycleGAN by enforcing both
structural and semantic consistency during adaptation using a cycle-consistency loss and semantics
losses based on a particular visual recognition task. There are also many extensions that include
class conditional information [Tsa+18; Lon+18] or adaptation when the modes to be matched have
different frequencies in the source and target domains [BHC19].
26.7.7 Design, art and creativity
Generative models, particularly of images, have added to approaches in the more general area of
algorithmic art. The applications in image and audio generation with transfer can also be considered
aspects of artistic image generation. In these cases, the goal of training is not generalization, but to
create appealing images across different types of visual aesthetics [Sar18]. One example takes style
transfer GANs to create visual experiences, in which objects placed under a video are re-rendered
using other visual styles in real time [AFG19]. The generation ability has been used to explore
alternative designs and fabrics in fashion [Kat+19], and have now also become part of major drawing
software to provide new tools to support designers [Ado]. And beyond images, creative and artistic
expression using GANs include areas in music, voice, dance, and typography [AI 19].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2023Part V
Discovery27 Discovery methods: an overview
27.1 Introduction
We have seen in Part III how to create probabilistic models that can make predictions about outputs
given inputs, using supervised learning methods (conditional likelihood maximization). And we have
seen in Part IV how to create probabilistic models that can generate outputs unconditionally, using
unsupervised learning methods (unconditional likelihood maximization). However, in some settings,
our goal is to try to understand a given dataset. That is, we want to discover something “interesting”,
and possibly “actionable”. Prediction and generation are useful subroutines for discovery, but are not
sufficient on their own. In particular, although neural networks often implicitly learn useful features
from data, they are often hard to interpret, and the results can be unstable and sensitive to arbitrary
details of the training protocol (e.g., SGD learning rates, or random seeds).
In this part of the book, we focus on learning models that create an interpretable representation of
high dimensional data. A common approach is to use a latent variable model, in which we make
the assumption that the observed data x was caused by, or generated by, some underlying (often
low dimensional) latent factors z, which represents the “true” state of the world. Crucially, these
latent variables are assumed to be meaningful to the end user of the model. (Thus evaluating such
models will generally require domain expertise.)
For example, suppose we want to interpret an image x in terms of an underlying 3d scene, z,
which is represented in terms of objects and surfaces. The forwards mapping from z to x is often
many-to-one, i.e., different latent values, say z and z
′
, may give rise to the same observation x,
due to limitations of the sensor. (This is called perceptual aliasing.) Consequently the inverse
mapping, from x to z, is ill-posed. In such cases, we need to impose a prior, p(z), to make our
estimate well-defined. In simple settings, we can use a point estimate, such as the MAP estimate
zˆ(x) = argmax
z
p(z|x) = argmax
z
log p(z) + log p(x|z) (27.1)
In the context of computer vision, this approach is known as vision as inverse graphics or analysis
by synthesis [KMY04; YK06; Doy+07; MC19]. See Figure 27.1 for an illustration.
This approach to inverse modeling is widely used in science and engineering, where z represents the
underlying state of the world which we want to estimate, and x is just a noisy or partial manifestation
of this true state. In some cases, we know both the prior p(z|θ) and the likelihood p(x|z, θ), and we
just need to solve the inference problem for z. But more commonly, the model parameters θ are
also (partially) unknown, and need to be inferred from observable samples D = {xn : n = 1 : N}. In
some cases, the structure of the model itself is unknown and needs to be learned.918
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 27.1: Vision as inverse graphics. The agent (here represented by a human head) has to infer the scene
z given the image x using an estimator. From Figure 1 of [Rao99]. Used with kind permission of Rajesh Rao.
27.2 Overview of Part V
In Chapter 28, we discuss simple latent variable models where typically the observed data is a fixed￾dimensional vector such as x ∈ R
D. In Chapter 29 we extend these models to work with sequences
of correlated vectors, x = x1:T , such as speech, video, genomics data, etc. It is straightforward to
make parts of these model be nonlinear (“deep”), as we discuss. These models can also be extended
to the spatio-temporal setting. In Chapter 30, we extend these models to work with general graphs.
In Chapter 31, we discuss non-parametric Bayesian models, which allow us to represent uncertainty
about many aspects of a model, such as the number of hidden states, the structure of the model,
the form of a functional dependency, etc. Thus the complexity of the learned representation can
grow dynamically, depending on the quantity and quality (informativeness) of the data. This is
important when performing discovery tasks, and helps us maintain flexibility while still retaining
interpretability.
In Chapter 32, we discuss representation learning using neural networks. This can be tackled
using latent variable modeling, but there are also a variety of other estimation methods one can use.
Finally, in Chapter 33, we discuss how to interpret the behavior of a predictive model (typically a
neural network).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 202328 Latent factor models
28.1 Introduction
A latent variable model (LVM) is any probabilistic model in which some variables are always
latent or hidden. A simple example is a mixture model (Section
P
28.2), which has the form p(x) =
k
p(x|z = k)p(z = k), where z is an indicator variable that specifies which mixture component to
use for generating x. However, we can also use continuous latent variables, or a mixture of discrete
and continuous. And we can also have multiple latent variables, which are interconnected in complex
ways.
In this chapter, we discuss a very simple kind of LVM that has the following form:
z ∼ p(z) (28.1)
x|z ∼ Expfam(x|f(z)) (28.2)
where f(z) is known as the decoder, and p(z) is some kind of prior. We assume that z is a single
“layer” of hidden random variables, corresponding to a set of “latent factors”. We call these latent
factor models. In this chapter, we assume the decoder f is a simple linear model; we consider
nonlinear extensions in Chapter 21. Thus the overall model is similar to a GLM (Section 15.1),
except the input to the model is hidden.
We can create a large variety of different “classical” models by changing the form of the prior p(z)
and/or the likelihood p(x|z), as we show in Table 28.1. We will give the details in the following
sections. (Note that, although we are discussing generative models, our focus is on posterior inference
of meaningful latents (discovery), rather than generating realistic samples of data.)
28.2 Mixture models
One way to create more complex probability models is to take a convex combination of simple
distributions. This is called a mixture model. This has the form
p(x|θ) = X
K
k=1
πkpk(x) (28.3)
where pk is the k’th mixture component, and πk are the mixture weights which satisfy 0 ≤ πk ≤ 1
and PK
k=1 πk = 1.
We can re-express this model as a hierarchical model, in which we introduce the discrete latent
variable z ∈ {1, . . . , K}, which specifies which distribution to use for generating the output x. The920
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Model p(z) p(x|z) Section
FA/PCA N (z|0, I) N (x|Wz, Ψ) Section 28.3.1
GMM P
c Cat(c|π)N (z|µc
, Σc) N (x|Wz, Ψ) Section 28.2.4
MixFA Cat(c|π)N (z|0, I) N (x|Wcz + µc
, Ψc) Section 28.3.3.5
NMF Q
k Ga(zk|αk, βk)
Q
d Poi(xd| exp(wT
d
z))) Section 28.4.1
Simplex FA (mPCA) Dir(z|α)
Q
d Cat(xd|Wdz) Section 28.4.2
LDA Dir(z|α)
Q
d Cat(xd|Wz) Section 28.5
ICA Q
d Laplace(zd|λ)
Q
d
δ(xd − wT
d
z) Section 28.6
Sparse coding Q
k Laplace(zk|λ)
Q
d N (xd|wT
d
z, σ2
) Section 28.6.5
Table 28.1: Some popular “shallow” latent factor models. Abbreviations: FA = factor analysis, PCA =
principal components analysis, GMM = Gaussian mixture model, NMF = non-negative matrix factorization,
mPCA = multinomial PCA, LDA = latent Dirichlet allocation, ICA = independent components analysis.
k = 1 : L ranges over latent dimensions, d = 1 : D ranges over observed dimensions. (For ICA, we have the
constraint that L = D.)
prior on this latent variable is p(z = k) = πk, and the conditional is p(x|z = k) = pk(x) = p(x|θk).
That is, we define the following joint model:
p(z|θ) = Cat(z|π) (28.4)
p(x|z = k, θ) = p(x|θk) (28.5)
The “generative story” for the data is that we first sample a specific component z, and then we
generate the observations x using the parameters chosen according to the value of z. By marginalizing
out z, we recover Equation (28.3):
p(x|θ) = X
K
k=1
p(z = k|θ)p(x|z = k, θ) = X
K
k=1
πkp(x|θk) (28.6)
We can create different kinds of mixture model by varying the base distribution pk, as we illustrate
below.
28.2.1 Gaussian mixture models (GMMs)
A Gaussian mixture model or GMM, also called a mixture of Gaussians (MoG), is defined
as follows:
p(x) = X
K
k=1
πkN (x|µk
, Σk) (28.7)
In Figure 28.1 we show the density defined by a mixture of 3 Gaussians in 2d. Each mixture
component is represented by a different set of elliptical contours. If we let the number of mixture
components grow sufficiently large, a GMM can approximate any smooth distribution over R
D.
GMMs are often used for unsupervised clustering of real-valued data samples xn ∈ R
D. This
works in two stages. First we fit the model, usually by computing the MLE θˆ = argmax log p(D|θ),
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.2. MIXTURE MODELS
0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
0.2
0.3
0.4
0.5
0.6
0.7
0.8
(a) (b)
Figure 28.1: A mixture of 3 Gaussians in 2d. (a) We show the contours of constant probability for each
component in the mixture. (b) A surface plot of the overall density. Adapted from Figure 2.23 of [Bis06].
Generated by gmm_plot_demo.ipynb.
8 6 4 2 0 2 4
2
0
2
4
(a)
8 6 4 2 0 2 4
2
0
2
4
(b)
Figure 28.2: (a) Some data in 2d. (b) A possible clustering using K = 5 clusters computed using a GMM.
Generated by gmm_2d.ipynb.
where D = {xn : n = 1 : N} (e.g., using EM or SGD). Then we associate each datapoint xn with
a discrete latent or hidden variable zn ∈ {1, . . . , K} which specifies the identity of the mixture
component or cluster which was used to generate xn. These latent identities are unknown, but we
can compute a posterior over them using Bayes’ rule:
rnk , p(zn = k|xn, θ) = p(zn = k|θ)p(xn|zn = k, θ)
PK
k′=1 p(zn = k
′
|θ)p(xn|zn = k
′
, θ)
(28.8)
The quantity rnk is called the responsibility of cluster k for datapoint n. Given the responsibilities,
we can compute the most probable cluster assignment as follows:
zˆn = arg max
k
rnk = arg max
k
[log p(xn|zn = k, θ) + log p(zn = k|θ)] (28.9)
This is known as hard clustering. (If we use the responsibilities to fractionally assign each datapoint
to different clusters, it is called soft clustering.) See Figure 28.2 for an example.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license922
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0.05 0.04 0.06 0.06 0.02
0.03 0.06 0.01 0.04 0.08
0.07 0.06 0.08 0.06 0.07
0.04 0.02 0.03 0.06 0.03
Figure 28.3: We fit a mixture of 20 Bernoullis to the binarized MNIST digit data. We visualize the estimated
cluster means µˆk
. The numbers on top of each image represent the estimated mixing weights πˆk. No labels
were used when training the model. Generated by mix_bernoulli_em_mnist.ipynb.
If we have a uniform prior over zn, and we use spherical Gaussians with Σk = I, the hard clustering
problem reduces to
zn = argmin
k
||xn − µˆk
||2
2
(28.10)
In other words, we assign each datapoint to its closest centroid, as measured by Euclidean distance.
This is the basis of the K-means clustering algorithm (see the prequel to this book).
28.2.2 Bernoulli mixture models
If the data is binary valued, we can use a Bernoulli mixture model (BMM), also called a mixture
of Bernoullis, where each mixture component has the following form:
p(x|z = k, θ) = Y
D
d=1
Ber(yd|µdk) = Y
D
d=1
µ
yd
dk(1 − µdk)
1−yd
(28.11)
Here µdk is the probability that bit d turns on in cluster k.
For example, consider fitting a mixture of Bernoullis using K = 20 components to the MNIST
dataset. The resulting parameters for each mixture component (i.e., µk and πk) are shown in
Figure 28.3. We see that the model has “discovered” a representation of each type of digit. (Some
digits are represented multiple times, since the model does not know the “true” number of classes.
See Section 3.8.1 for information on how to choose the number K of mixture components.)
28.2.3 Gaussian scale mixtures (GSMs)
A Gaussian scale mixture or GSM [AM74; Wes87] is like an “infinite” mixture of Gaussians, each
with a different scale (variance). More precisely, let x = ǫz, where z ∼ N (0, σ2
0
) and ǫ ∼ p(ǫ). We can
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.2. MIXTURE MODELS
think of this as multiplicative noise being applied to the Gaussian rv z. We have x|ǫ ∼ N (0, ǫ2σ
2
0
).
Marginalizing out the scale ǫ gives
p(x) = Z
N (x|0, σ2
0
ǫ
2
)p(ǫ)dǫ (28.12)
By changing the prior p(ǫ), we can create various interesting distributions. We give some examples
below.
The main advantage of this approach is that it is often computationally more convenient to
work with the expanded parameterization, in which we explicitly include the scale term ǫ, since,
conditional on that, the distribution is Gaussian. We use this formulation in Section 6.5.5, where we
discuss robust regression.
28.2.3.1 Student-t distribution as a GSM
We can represent the Student distribution as a GSM as follows:
T (x|0, σ2
, ν) = Z ∞
0
N (x|0, zσ2
)IG(z|
ν
2
,
ν
2
)dz =
Z ∞
0
N (x|0, zσ2
)χ
−2
(z|ν, 1)dz (28.13)
where IG is the inverse Gamma distribution (Section 2.2.3.4). Thus we can think of the Student as an
infinite superposition of Gaussians of different widths; marginalizing this out induces a distribution
with wider tails than a Gaussian with the same variance. This result also explains why the Student
distribution approaches a Gaussian as the dof gets large, since when ν = ∞, the inverse Gamma
distribution becomes a delta function.
28.2.3.2 Laplace distribution as a GSM
Similarly one can show that the Laplace distribution is an infinite weighted sum of Gaussians, where
the precision comes from a gamma distribution:
Laplace(x|0, λ) = Z
N (x|0, τ 2
)Ga(τ
2
|1,
λ
2
2
)dτ 2
(28.14)
28.2.3.3 Spike and slab distribution
Suppose ǫ ∼ Ber(π). (Note that ǫ
2 = ǫ, since ǫ ∈ {0, 1}.) In this case we have
x =
X
ǫ∈{0,1}
N (x|0, σ2
0
ǫ)p(ǫ) = πN (x|0, σ2
0
) + (1 − π)δ0(x) (28.15)
This is known as the spike and slab distribution, since the δ0(x) is a “spike” at 0, and the N (x|0, σ2
0
)
acts like a uniform “slab” for large enough σ0. This distribution is useful in sparse modeling.
28.2.3.4 Horseshoe distribution
Suppose ǫ ∼ C+(1), which is the half-Cauchy distribution (see Section 2.2.2.4). Then the induced
distribution p(x) is called the horseshoe distribution [CPS10]. This has a spike at 0, like the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license924
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
(c) (d)
(e) (f)
Figure 28.4: Example of recovering a clean image (right) from a corrupted version (left) using MAP estimation
with a GMM patch prior and Gaussian likelihood. First row: image denoising. Second row: image deblurring.
Third row: image inpainting. From [RW15] and [ZW11]. Used with kind permission of Dan Rosenbaum and
Daniel Zoran.
Student and Laplace distributions, but has heavy tails that do not asymptote to zero. This makes it
useful as a sparsity promoting prior, that “kills off” small parameters, but does not overregularize
large parameters.
28.2.4 Using GMMs as a prior for inverse imaging problems
In this section, we consider using GMMs as a blackbox density model to regularize the inversion of a
many-to-one mapping. Specifically, we consider the problem of inferring a “clean” image x from a
corrupted version y. We use a linear-Gaussian forwards model of the form
p(y|x) = N (y|Wx, σ2
I) (28.16)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.2. MIXTURE MODELS
where σ
2
is the variance of the measurement noise. The form of the matrix W depends on the nature
of the corruption, which we assume is known, for simplicity. Here are some common examples of
different kinds of corruption we can model in our approach:
• If the corruption is due to additive noise (as in Figure 28.4a), we can set W = I. The resulting
MAP estimate can be used for image denoising, as in Figure 28.4b.
• If the corruption is due to blurring (as in Figure 28.4c), we can set W to be a fixed convolu￾tional kernel [KF09b]. The resulting MAP estimate can be used for image deblurring, as in
Figure 28.4d.
• If the corruption is due to occlusion (as in Figure 28.4e), we can set W to be a diagonal matrix,
with 0s in the locations corresponding to the occluders. The resulting MAP estimate can be used
for image inpainting, as in Figure 28.4f.
• If the corruption is due to downsampling, we can set W to a convolutional kernel. The resulting
MAP estimate can be used for image super-resolution.
Thus we see that the linear-Gaussian likelihood model is surprisingly flexible. Given the model,
our goal is to invert it, by computing the MAP estimate xˆ = argmax p(x|y). However, the problem
of inverting this model is ill-posed, since there are many possible latent images x that map to the
same observed image y. Therefore we need to use a prior to regularize the inversion process.
In [ZW11], they propose to partition the image into patches, and to use a GMM prior of the form
p(xi) = P
k
p(ci = k)N (xi
|µk
, Σk) for each patch i. They use K = 200 mixture components, and
they fit the GMM on a dataset of 2M clean image patches.
To compute the MAP mixture component, c
∗
i
, we can marginalize out xi and use Equation (2.129)
to compute the marginal likelihood
c
∗
i = argmax
c
p(c)p(yi
|c) = argmax
c
p(c)N (yi
|Wµc
, σ2
I + WΣcWT
) (28.17)
We can then approximate the MAP for the latent patch xi by using the approximation
p(xi
|yi) ≈ p(xi
|yi
, c∗
i
) ∝ N (xi
|µc
∗
i
, Σc
∗
i
)N (yi
|Wxi
, σ2
I) (28.18)
If we know c
∗
i
, we can compute the above using Bayes’ rule for Gaussians in Equation (2.121).
To apply this method to full images, [ZW11] optimize the following objective
E(x|y) = 1
2σ
2
||Wx − y||2 − EPLL(x) (28.19)
where EPLL is the “expected patch log likelihood”, given by
EPLL(x) = X
i
log p(Pix) (28.20)
where xi = Pix is the i’th patch computed by projection matrix Pi
. Since these patches overlap,
this is not a valid likelihood, since it overcounts the pixels. Nevertheless, optimizing this objective
(using a method called “half quadratic splitting”) works well empirically. See Figure 28.4 for some
examples of this process in action.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license926
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 28.5: Illustration of the parameters learned by a GMM applied to image patches. Each of the 3 panels
corresponds to a different mixture component k. Within each panel, we show the eigenvectors (reshaped as
images) of the covariance matrix Σk in decreasing order of eigenvalue. We see various kinds of patterns,
including ones that look like the ones learned from PCA (see Figure 28.34), but also ones that look like edges
and texture. From Figure 6 of [ZW11]. Used with kind permission of Daniel Zoran.
A more principled solution to the overlapping patch problem is to use a multiscale model, as
proposed in [PE16]. Another approach, proposed in [FW21], uses Gibbs sampling to combine samples
from overlapping patches. This approach has the additional advantage of computing posterior samples
from p(x|y), which can look much better than the posterior mean or mode computed by optimization
methods. (For example, if the corruption process removes the color from the latent image x to
create a gray scale y, then the posterior MAP estimate of x will also be a gray scale image, whereas
posterior samples will be color images.) See also Section 28.3.3.5 where we show how to extend the
GMM model to a mixture of low rank Gaussians, which lets us directly model images instead of
image patches.
28.2.4.1 Why does the method work?
To understand why such a simple model of image patches works so well, note that the log prior for a
single latent image patch xi using mixture component k can be written as follows:
log p(xi
|ci = k) = log N (xi
|0, Σk) = −x
T
i Σ
−1
k xi + ak (28.21)
where ak is a constant that depends on k but is independent of xi
. Let Σk = VkΛkVT
k
be an
eigendecomposition of Σk, where λk,d is the d’th eigenvalue of Σk, and vk,d is the d’th eigenvector.
Then we can rewrite the above as follows:
log p(xi
|ci = k) = −
X
D
d=1
1
λk,d
(v
T
k,dxi)
2 + ak (28.22)
Thus we see that the eigenvectors are acting like templates. Each mixture component has a different
set of templates, each with their own weight (eigenvalue), as illustrated in Figure 28.5. By mixing
these together, we get a powerful model for the statistics of natural image patches. (See [ZW12] for
more analysis of why this simple model works so well, based on the “dead leaves” model of image
formation.)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.2. MIXTURE MODELS
28.2.4.2 Speeding up inference using discriminative models
Although simple and effective, computing f(y) = argmaxx p(x|y) for each image patch can be slow
if the image is large. However, every time we solve this problem, we can store the result, and build
up a dataset of (y, f(y)) pairs. We can then train an amortized inference network (Section 10.1.5)
to learn this y → f(y) mapping, to speed up future inferences, as proposed in [RW15]. (See also
[Par+19] for further speedup tricks.)
An alternative approach is to dispense with the generative model, and to train on an artificially
created dataset of the form (y, x), where x is a clean natural image, and y = C(x) is an artificial
corruption of it. We can then train a discriminative model ˆf(y) directly from (y, x) pairs. This
technique works very well (see e.g., [Luc+18]), but is limited by the form of corruptions C it is trained
on. This means we need to train a different network for every linear operator W, and sometimes
even for every different noise level σ
2
.
28.2.4.3 Blind inverse problems
In the discussion above, we assumed the forwards model had the form p(y|x, θ) = N (y|Wx, σ2
I),
where W is known. If W is not known, then computing p(x|y) is known as a blind inverse
problem.
Such problems are much harder to solve. One approach is to estimate the parameters of the
forwards model, W, and the latent image, x, using an EM-like method from a set of images coming
from the same likelihood function. That is, we alternate between estimating xˆ = argmaxx p(x|y,Wˆ )
in the E step, and estimating Wˆ = argmaxW p(y|xˆ,W) in the M step. Some encouraging results of
this approach are shown in [Ani+18]. (They use a GAN prior for p(x) rather than a GMM.)
In cases where we get two independent noisy samples, y1 and y2, generated from the same
underlying image x, then we can avoid having to explicitly learn an image prior p(x), and can instead
directly learn an estimator for the posterior mode, f(y) = argmaxx p(x|y), without needing access
to the latent image x, by exploiting a form of cycle consistency; see [XC19] for details.
28.2.5 Using mixture models for classification problems
It is possible to use mixture models to define the class-conditional density p(x|y = c) in a generative
classifier. We can then derive the class posterior using Bayes’ rule:
p(y = c|x) = p(y = c)p(x|y = c)
P
c
′ p(y = c)p(x|y = c)
=
p(y = c)p(x|y = c)
Z
(28.23)
where p(y = c) = πc is the prior on class label c, Z is the normalization constant, and the form of
p(x|y = c) depends on the kind of data we have. For real-valued features, it is common to use a
GMM:
p(x|y = c) = X
Kc
k=1
αc,kN (x|µc,k, Σc,k) (28.24)
Using a generative model to perform classification can be useful when we have missing data, since
we can compute p(x
v
|y = c) = P
xm p(x
m, x
v
|y = c) to compute the marginal likelihood of the
visible features x
v
. It is also useful for semi-supervised learning, since we can optimize the model to
fit P
n
log p(x
l
n
, yl
n
) on the labeled data and P
n
log p(x
u
n
) on the unlabeled data.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license928
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.2.5.1 Hybrid generative/discriminative training
Unfortunately the classification accuracy of generative models of the form p(x, y) can be much worse
than discriminative (conditional) models of the form p(y|x), since the latter are directly optimized to
predict the labels given the features, and don’t “waste” capacity on modeling irrelevant details of the
inputs. (For a more in-depth discussion of generative vs discriminative classifiers, see e.g., [Mur22,
Sec 9.4].)
Fortunately it is possible to train generative models in a discriminative fashion, which can close
the performance gap with conditional models, while maintaining the advantages of generative models.
In particular, we can optimize the following hybrid objective, proposed in [BT04; Rot+18]:
L(θ) = −λ
X
N
n=1
log p(xn, yn|θ)
| {z }
Lgen(θ)
−(1 − λ)
X
N
n=1
log p(yn|xn, θ)
| {z }
Ldis(θ)
(28.25)
where 0 ≤ λ ≤ 1 controls the tradeoff between generative and discriminative modeling.
If we have unlabeled data, we can modify the generative loss as shown below:
Lgen(θ) = κ
X
Nl
n=1
log p(x
l
n
, yl
n
|θ) + (1 − κ)
X
Nu
n=1
log p(x
u
n
|θ) (28.26)
Here we have introduced an extra trade-off parameter 0 ≤ κ ≤ 1 to prevent the unlabeled data from
overwhelming the labeled data (if Nu ≫ Nl), as proposed in [Nig+00].
An alternative to changing the objective function is to change the model itself, so that we
parameterize the joint using p(x, y) = p(y|x, θ)p(x|θ˜), and then define different kinds of joint priors
p(θ, θ˜); see [LBM06; BL07a] for details.
28.2.5.2 Optimization issues
To optimize the loss, we need to reparameterize the model into unconstrained form. For the class
prior, we can use π1:C = softmax(π˜1:C ), and optimize wrt the logits π˜1:C . Similarly for the mixture
weights αc,1:K. The means µck are already unconstrained. For the covariance matrices, we will use a
diagonal plus low-rank representation, to reduce the number of parameters:
Σc,k = diag(dc,k) + Sc,kS
T
c,k (28.27)
where Sc,k is an unconstrained D × R matrix, where R ≪ D is the rank of the approximation. (For
numerical stability, we usually add ǫI to the above expression, to ensure Σc,k is positive definite for
all parameter settings.) To ensure positivity of the diagonal term, we can use the softplus transform,
dc,k = log(1 + exp( ˜dc,k)), and optimize wrt the ˜dc,k terms.
28.2.5.3 Numerical issues
To compute the class conditional log likelihood, ℓc = log p(x|y = c), we can use the log-sum-exp
trick to avoid numerical underflow. Define α˜ck = log αck and ℓck = log N (x|µck, Σck). Then we
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.3. FACTOR ANALYSIS
have
ℓc = log p(x|y = c) = logX
k
e
α˜ck+ℓck (28.28)
= e
M logX
k
e
α˜ck+ℓck−M , logsumexp({α˜ck + ℓck}k) (28.29)
where M = maxk α˜ck + ℓck.
We can use a similar method to compute the posterior over classes. We have
p(y = c|x) = πce
lc
Z
=
πce
lc−L
e−LZ
=
πce
˜lc
Z˜
(28.30)
where L = maxc lc,
˜lc = lc − L, and Z˜ =
P
c
πce
˜lc
. This lets us combine the class prior probability
πc with the scaled class conditional log likelihood ˜lc to get the class posterior in a stable way. (We
can also compute the log normalization constant, log p(x) = log Z = log(Z˜) + L.)
To compute a single Gaussian log density, ℓck = log N (x|µck, Σck), we need to evaluate log det(Σck)
and Σ
−1
ck . To make this efficient, we can use the matrix determinant lemma to compute
det(A + SST
) = det(I + S
TA−1S) det(A) (28.31)
where A = diag(d) + ǫI, and the matrix inversion lemma to compute
(A + SST
)
−1 = A−1 − A−1S(I + S
TA−1S)
−1S
TA−1
(28.32)
(See also the discussion of mixture of factor analyzers in Section 28.3.3.)
28.3 Factor analysis
In this section, we discuss a simple latent factor model in which the prior p(z) is Gaussian, and the
likelihood p(x|z) is also Gaussian, using a linear decoder for the mean. This family includes many
important special cases, such as PCA, as we discuss below. We also briefly discuss some simple
extensions.
28.3.1 Factor analysis: the basics
Factor analysis corresponds to the following linear-Gaussian latent variable generative model:
p(z) = N (z|µ0
, Σ0) (28.33)
p(x|z, θ) = N (x|Wz + µ, Ψ) (28.34)
where W is a D × L matrix, known as the factor loading matrix, and Ψ is a diagonal D × D
covariance matrix.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license930
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.3.1.1 FA as a Gaussian with low-rank plus diagonal covariance
FA can be thought of as a low-rank version of a Gaussian distribution. To see this, note that the
induced marginal distribution p(x|θ) is a Gaussian (see Equation (2.129) for the derivation):
p(x|θ) = Z
N (x|Wz + µ, Ψ)N (z|µ0
, Σ0)dz (28.35)
= N (x|Wµ0 + µ, Ψ + WΣ0WT
) (28.36)
The first and second moments can be derived as follows:
E [x] = Wµ0 + µ
Cov [x] = WCov [z]WT + Ψ = WΣ0WT + Ψ
(28.37)
From this, we see that we can set µ0 = 0 without loss of generality, since we can always absorb
Wµ0
into µ. Similarly, we can set Σ0 = I without loss of generality, since we can always absorb a
correlated prior by using a new weight matrix, W˜ = WΣ− 1
2
0
, since then
Cov [x] = WΣ0WT + Ψ = W˜ W˜ T + Ψ (28.38)
Finally, we see that we should restrict Ψ to be diagonal, otherwise we could set W˜ = 0, thus ignoring
the latent factors, while still being able to model any covariance. After these simplifications we have
the final model:
p(z) = N (z|0, I) (28.39)
p(x|z) = N (x|Wz + µ, Ψ) (28.40)
from which we get
p(x) = N (x|µ,WWT + Ψ) (28.41)
For example, suppose where L = 1, D = 2 and Ψ = σ
2
I. We illustrate the generative process in
this case in Figure 28.6. We can think of this as taking an isotropic Gaussian “spray can”, representing
the likelihood p(x|z), and “sliding it along” the 1d line defined by wz + µ as we vary the 1d latent
prior z. This induces an elongated (and hence correlated) Gaussian in 2d. That is, the induced
distribution has the form p(x) = N (x|µ, wwT + σ
2
I).
In general, FA approximates the covariance matrix of the visible vector using a low-rank decompo￾sition:
C = Cov [x] = WWT + Ψ (28.42)
This only uses O(LD) parameters, which allows a flexible compromise between a full covariance
Gaussian, with O(D2
) parameters, and a diagonal covariance, with O(D) parameters.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.3. FACTOR ANALYSIS
Z
[
[
[
[
]
S] S[
ȝ
]_Z_
S[_]
ȝ
Figure 28.6: Illustration of the FA generative process, where we have L = 1 latent dimension generating
D = 2 observed dimensions; we assume Ψ = σ
2
I. The latent factor has value z ∈ R, sampled from
p(z); this gets mapped to a 2d offset δ = zw, where w ∈ R
2
, which gets added to µ to define a Gaussian
p(x|z) = N (x|µ + δ, σ2
I). By integrating over z, we “slide” this circular Gaussian “spray can” along the
principal component axis w, which induces elliptical Gaussian contours in x space centered on µ. Adapted
from Figure 12.9 of [Bis06].
28.3.1.2 Computing the posterior
We can compute the posterior over the latent codes, p(z|x), using Bayes’ rule for Gaussians. In
particular, from Equation (2.121), we have
p(z|x) = N (z|µz|x
, Σz|x) (28.43)
Σz|x = (I + WTΨ−1W)
−1 = I − WT
(WWT + Ψ)
−1W (28.44)
µz|x = Σz|x[WTΨ−1
(x − µ)] = WT
(WWT + Ψ)
−1
(x − µ) (28.45)
We can avoid inverting the D × D matrix C = WWT + Ψ by using the matrix inversion lemma:
C−1 = (WWT + Ψ)
−1
(28.46)
= Ψ−1 − Ψ−1W(I + WTΨ−1W)
−1
| {z }
L−1
WTΨ−1
(28.47)
where L = I + WTΨ−1W is L × L.
28.3.1.3 Computing the likelihood
In this section, we discuss how to efficiently compute the log (marginal) likelihood, which is given by
log p(x|µ, C) = −
1
2

D log(2π) + log det(C) + x˜
TC−1x˜

(28.48)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license932
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where x˜ = x − µ, and C = WWT + Ψ. Using Equation (28.47), the Mahalanobis distance can be
computed using
x˜
TC−1x˜ = x˜
T

Ψ−1x˜ − Ψ−1WL−1
(WTΨ−1x˜)

(28.49)
which takes O(L
3 + LD) to compute. From the matrix determinant lemma, the log determinant is
given by
log det(C) = log det(L) + log det(Ψ) (28.50)
which takes O(L
3 + D) to compute. (See also Section 28.2.5, where we discuss fitting low-rank GMM
classifiers discriminatively, which requires similar computations.)
28.3.1.4 Model fitting using EM
We can compute the MLE for the FA model either by performing gradient ascent on the log likelihood
in Equation (28.48), or by using the EM algorithm [RT82; GH96b]. The latter can converge faster,
and automatically satisfies positivity constraints on Ψ. We give the details below, assuming that the
observed data is standardized, so µ = 0 for notational simplicity.
In the E step, we compute the following expected sufficient statistics:
Ex,z =
X
N
n=1
xnE [z|xn]
T
(28.51)
Ez,z =
X
N
n=1
E

zzT
|xn

(28.52)
Ex,x =
X
N
n=1
xnx
T
n
(28.53)
where
E [z|x] = Bx (28.54)
E

zzT
|x

= Cov [z|x] + E [z|x] E [z|x]
T = I − BW + BxxTB
T
(28.55)
B , WT
(Ψ + WWT
)
−1 = WTC−1
(28.56)
In the M step, we have
Wnew = Ex,zE
−1
z,z
(28.57)
Ψnew =
1
N
diag ￾
Ex,x − WnewE
T
x,z

(28.58)
28.3.1.5 Handling missing data
We can also perform posterior inference in the presence of missing data (if we make the missing at
random assumption — see Section 3.11 for discussion). In particular, let us partition x = (x1, x2),
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.3. FACTOR ANALYSIS
W = [W1,W2], and µ = [µ1
, µ2
], and suppose x2 is missing (unknown). From Supplementary Sec￾tion 2.1.1, we have
p(z|x1) = N (z|µz|1
, Σz|1) (28.59)
Σ
−1
z|1 = I + WT
1Σ
−1
11 W1 (28.60)
µz|1 = Σz|1[WT
1Σ
−1
11 (x1 − µ1
)] (28.61)
where Σ11 is the top left block of Ψ.
We can modify the EM algorithm to fit the model in the presence of missing data in the obvious
way.
28.3.1.6 Unidentifiability of the parameters
The parameters of a FA model are unidentifiable. To see this, consider a model with weights W and
observation covariance Ψ. We have
Cov [x] = WE

zzT
WT + E

ǫǫT

= WWT + Ψ (28.62)
where ǫ ∼ N (0, Ψ) is the observation noise. Now consider a different model with weights W˜ = WR,
where R is an arbitrary orthogonal rotation matrix, satisfying RRT = I. This has the same likelihood,
since
Cov [x] = W˜ E

zzT
W˜ T + E

ǫǫT

= WRRTWT + Ψ = WWT + Ψ (28.63)
Geometrically, multiplying W by an orthogonal matrix is like rotating z before generating x; but
since z is drawn from an isotropic Gaussian, this makes no difference to the likelihood. Consequently,
we cannot uniquely identify W, and therefore cannot uniquely identify the latent factors, either.
This is called the “factor rotations problem” (see e.g., [Dar80]).
To break this symmetry, several solutions can be used, as we discuss below.
• Forcing W to have orthogonal columns.. In (P)PCA, we force W to have orthogonal columns.
and to sort the dimensions in order of decreasing eigenvalue (of WWT). However, this still does
not ensure identifiability, since we can always multiply W by another orthogonal matrix without
changing the likelihood.
• Forcing W to be lower triangular. One way to resolve permutation unidentifiability, which
is popular in the Bayesian community (e.g., [LW04]), is to ensure that the first visible feature is
only generated by the first latent factor, the second visible feature is only generated by the first
two latent factors, and so on. For example, if L = 3 and D = 4, the correspond factor loading
matrix is given by
W =


w11 0 0
w21 w22 0
w31 w32 w33
w41 w42 w43


(28.64)
We also require that wkk > 0 for k = 1 : L. The total number of parameters in this constrained
matrix is D + DL − L(L − 1)/2, which is equal to the number of uniquely identifiable parameters
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license934
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
in FA (excluding the mean).1 The disadvantage of this method is that the first L visible variables,
known as the founder variables, affect the interpretation of the latent factors, and so must be
chosen carefully.
• Sparsity promoting priors on the weights. Instead of pre-specifying which entries in W are
zero, we can encourage the entries to be zero, using ℓ1 regularization [ZHT06], ARD [Bis99; AB08],
or spike-and-slab priors [Rat+09]. This is called sparse factor analysis. This does not necessarily
ensure a unique MAP estimate, but it does encourage interpretable solutions.
• Choosing an informative rotation matrix. There are a variety of heuristic methods that try
to find rotation matrices R which can be used to modify W (and hence the latent factors) so as
to try to increase the interpretability, typically by encouraging them to be (approximately) sparse.
One popular method is known as varimax [Kai58].
• Use of non-Gaussian priors for the latent factors. If we replace the prior on the latent
variables, p(z), with a non-Gaussian distribution, we can sometimes uniquely identify W, as well
as the latent factors. See e.g., [KKH20] for details.
28.3.2 Probabilistic PCA
In this section, we consider a special case of the factor analysis model in which W has orthogonal
columns and Ψ = σ
2
I, so p(x) = N (x|µ, C) where C = WWT + σ
2
I. This model is called
probabilistic principal components analysis (PPCA) [TB99], or sensible PCA [Row97].
The advantage of PPCA over factor analysis is that the MLE has a closed form solution, as we
show in Section 28.3.2.2. The advantage of PPCA over non-probabilistic PCA is that the model
defines a proper likelihood function, which makes it easier to extend in various ways e.g., by creating
mixtures of PPCA models (see Section 28.3.3).
28.3.2.1 Derivation of the MLE
The log likelihood for PPCA is given by
log p(X|µ,W, σ2
) = −
ND
2
log(2π) −
N
2
log |C| − 1
2
X
N
n=1
(xn − µ)
TC−1
(xn − µ) (28.65)
The MLE for µ is x. Plugging in gives
log p(X|µ,W, σ2
) = −
N
2

D log(2π) + log |C| + tr(C−1S)

(28.66)
where S =
1
N
PN
n=1(xn − x)(xn − x)
T is the empirical covariance matrix.
In [TB99; Row97] they show that the maximum of this objective must satisfy
Wˆ = UL(ΛL − σ
2
I)
1
2 R (28.67)
1. We get D parameters for Ψ and DL for W, but we need to remove L(L − 1)/2 degrees of freedom coming from R,
since that is the dimensionality of the space of orthogonal matrices of size L × L. To see this, note that there are L − 1
free parameters in R in the first column (since the column vector must be normalized to unit length), there are L − 2
free parameters in the second column (which must be orthogonal to the first), and so on.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.3. FACTOR ANALYSIS
where UL is a D × L matrix whose columns are given by the L eigenvectors of S with largest
eigenvalues, ΛL is the L × L diagonal matrix of corresponding eigenvalues, and R is an arbitrary
L × L orthogonal matrix, which (WLOG) we can take to be R = I.
If we plug in the MLE for W, we find the covariance for the predictive distribution to be
C = WWT + σ
2
I = UL(ΛL − σ
2
I)UT
L + σ
2
I (28.68)
The MLE for the observation variance is
σ
2 =
1
D − L
X
D
i=L+1
λi (28.69)
which is the average distortion associated with the discarded dimensions. If L = D, then the
estimated noise is 0, since the model collapses to z = x.
28.3.2.2 PCA is recovered in the noise-free limit
In the noise-free limit, where σ
2 = 0, we see that the MLE (for R = I) is
Wˆ = ULΛ
1
2
L
(28.70)
so
Cˆ = Wˆ Wˆ T = ULΛ
1
2
LΛ
1
2
LUT
L = SL (28.71)
where SL is the rank L approximation to S. This is the same as standard PCA.
28.3.2.3 Computing the posterior
To use PPCA as an alternative to PCA, we need to compute the posterior mean E [z|x], which is the
equivalent of the PCA encoder model. Using the factor analysis results from Section 28.3.1.2, we
have
p(z|x) = N (z|σ
−2ΣWT
(x − µ), Σ) (28.72)
where
Σ
−1 = I + σ
−2WTW =
1
σ
2
(σ
2
I + WTW)
| {z }
M
(28.73)
Hence
p(z|x) = N (z|M−1WT
(x − µ), σ2M−1
) (28.74)
In the σ
2 = 0 limit, we have M = WTW and so
E [z|x] = (WTW)
−1WT
(x − x) (28.75)
This is the orthogonal projection of the data into the latent space, as in standard PCA.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license936
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.3.2.4 Model fitting using EM
In Section 28.3.2.2, we showed how to fit the PCA model using an eigenvector method. We can also
use EM, by leveraging the probabilistic formulation of PPCA in the zero noise limit, σ
2 = 0, as
shown by [Row97].
In particular, let Z˜ = Z
T be an L × N matrix storing the posterior means (low-dimensional
representations) along its columns. Similarly, let x˜n = xn − µˆ be the centered examples stored along
the columns of X˜ . From Equation (28.75), when σ
2 = 0, we have
Z˜ = (WTW)
−1WTX˜ (28.76)
This constitutes the E step. Notice that this is just an orthogonal projection of the data.
From Equation (28.57), the M step is given by
Wˆ =
"X
n
x˜nE [zn|x˜n]
T
# "X
n
E [zn|x˜n] E [zn|x˜n]
T
#−1
(28.77)
where we exploited the fact that Σ = Cov [z|x˜] = 0I when σ
2 = 0.
In summary, here is the entire algorithm:
Z˜ = (WTW)
−1WTX˜ (E step) (28.78)
W = X˜ Z˜
T
(Z˜Z˜
T
)
−1
(M step) (28.79)
It is worth comparing this expression to the MLE for multi-output linear regression, which has the
form W = (P
n
ynx
T
n
)(P
n xnx
T
n
)
−1
. Thus we see that the M step is like linear regression where we
replace the observed inputs by the expected values of the latent variables.
[TB99] showed that the only stable fixed point of the EM algorithm is the globally optimal solution.
That is, the EM algorithm converges to a solution where W spans the same linear subspace as that
defined by the first L eigenvectors of S. However, if we want W to be orthogonal, and to contain the
eigenvectors in descending order of eigenvalue, we have to orthogonalize the resulting matrix (which
can be done quite cheaply). Alternatively, we can modify EM to give the principal basis directly
[AO03].
28.3.3 Mixture of factor analyzers
The factor analysis model (Section 28.3.1) assumes the observed data can be modeled as arising from
a linear mapping from a low-dimensional set of Gaussian factors. One way to relax this assumption is
to assume the model is only locally linear, so the overall model becomes a (weighted) combination of
FA models; this is called a mixture of factor analyzers or MFA [GH96b]. The overall model for
the data is a mixture of linear manifolds, which can be used to approximate an overall curved manifold.
Another way to think of this model is a mixture of Gaussians, where each mixture component has a
covariance matrix which is diagonal plus low-rank.
28.3.3.1 Model definition
The generative story is as follows. First we sample a discrete latent indicator mn ∈ {1, . . . , K} from
discrete distribution Cat(·|π) to specify which subspace (cluster) we should use to generate the data.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.3. FACTOR ANALYSIS
Ψ
π
Wc
µc
xn
cn zn
N C
Figure 28.7: Mixture of factor analyzers as a PGM.
If mn = k, we sample zn from a Gaussian prior and pass it through the Wk matrix, where Wk
maps from the L-dimensional subspace to the D-dimensional visible space.2 Finally we add Gaussian
observation noise sampled from N (µk
, Ψ). Thus the model is as follows:
p(xn|zn, mn = k, θ) = N (xn|µk + Wkzn, Ψ) (28.80)
p(zn|θ) = N (zn|0, I) (28.81)
p(mn|θ) = Cat(mn|π) (28.82)
The corresponding distribution in the visible space is given by
p(x|θ) = X
k
p(m = k)
Z
p(z|c)p(x|z, m) dz (28.83)
=
X
k
πk
Z
N (z|0, I)N (x|Wkz + µk
, Ψ) dz (28.84)
=
X
k
πkN (x|µk
, Ψ + WkWT
k
) (28.85)
In the special case that Ψ = σ
2
I, we get a mixture of PPCA models. See Figure 28.8 for an example
of the method applied to some 2d data.
We can think of this as a low-rank version of a mixture of Gaussians. In particular, this model
needs O(KLD) parameters instead of the O(KD2
) parameters needed for a mixture of full covariance
Gaussians. This can reduce overfitting.
28.3.3.2 Model fitting using EM
We can fit this model using EM, extending the results of Section 28.3.1.4 (see [GH96b] for the derivation,
and [ZY08] for a faster ECM version). In the E step, we compute the posterior responsibility of
cluster j for datapoint i using
rij , p(mi = j|xi
, θ) ∝ πjN (xi
|µj
,WjWT
j + Ψ) (28.86)
2. If we allow zn to depend on mn, we can let each subspace have a different dimensionality, as suggested in [KS15].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license938
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−2 −1.5 −1 −0.5 0 0.5 1 1.5 2
−1.5
−1
−0.5
0
0.5
1
1.5
(a)
−2 −1.5 −1 −0.5 0 0.5 1 1.5 2
−1.5
−1
−0.5
0
0.5
1
1.5
(b)
Figure 28.8: Mixture of PPCA models fit to a 2d dataset, using L = 1 latent dimensions. (a) K = 1 mixture
components. (b) K = 10 mixture components. Generated by mix_ppca_demo.ipynb.
We also compute the following expected sufficient statistics, where we define wj = I(m = j) and
Bj = WT
j
(Ψ + WjWT
j
)
−1
:
E [wjz|xi
] = E [wj |xi
] E [z|wj , xi
] = rijBj (xi − µj
) (28.87)
E

wjzzT
|xi

= E [wj |xi
] E

zzT
|wj , xi

= rij (I − BjWj + Bj (x − µj
)(x − µj
)
TB
T
j
) (28.88)
In the M step, we compute the following parameter update for the augmented factor loading
matrix:
[Wnew
j µ
new
j
] , W˜ new
j = (X
i
rijxiE [z˜|xi
, wj ]
T
)(X
i
rijE

z˜z˜
T
|xi
, wj

)
−1
(28.89)
where z˜ = [z; 1],
E [z˜|xi
, wj ] = 
E [z|xi
, wj ]
1

(28.90)
E

z˜z˜
T
|xi
, wj

=

E

z˜z˜
T|xi
, wj

E [z˜|xi
, wj ]
E [z˜|xi
, wj ]
T
1

(28.91)
The new covariance matrix is given by
Ψnew =
1
N
diag


X
ij
rij (xi − W˜ new
j E [z˜|xi
, wj ])x
T
i

 (28.92)
And the new mixing weights are given by
π
new
j =
1
N
X
N
i=1
rij (28.93)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.3. FACTOR ANALYSIS
(a) (b) (c)
(d) (e) (f)
Figure 28.9: Illustration of estimating the effective dimensionalities in a mixture of factor analysers using
variational Bayes EM with an ARD prior. Black are negative values, white are positive, gray is 0. The blank
columns have been forced to 0 via the ARD mechanism, reducing the effective dimensionality. The data was
generated from 6 clusters with intrinsic dimensionalities of 7, 4, 3, 2, 2, 1, which the method has successfully
estimated. From Figure 4.4 of [Bea03]. Used with kind permission of Matt Beal.
28.3.3.3 Model fitting using SGD
We can also fit mixture models using SGD, as shown in [RW18]. This idea can be combined with
an inference network (see Section 10.1.5) to efficiently approximate the posterior over the latent
variables. [Zon+18] use this approach to jointly learn a GMM applied to a deep autoencoder to
provide a nonlinear extension of MFA; they show good results on anomaly detection.
28.3.3.4 Model selection
To choose the number of mixture components K, and the number of latent dimensions L, we can
use discrete search combined with objectives such as the marginal likelihood or validation likelihood.
However, we can also use numerical optimization methods to optimize L, which can be faster. We
initially assume that Nc is known. To estimate L, we set the model to its maximal size, and then use
a technique called automatic relevance determination or ARD to automatically prune out irrelevant
weights (see Section 15.2.8). This can be implemented using variational Bayes EM (Section 10.3.5);
for details, see [Bis99; GB00].
Figure 28.9 illustrates this approach applied to a mixture of FA models fit to a small synthetic
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license940
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
number of points 
 per cluster		 1	 7	 4	 3	 2	 2
	 8		 	 2			 1
	 8		 1			 2
	 16		 1		 4			 2
	 32		 1	 6	 3	 3	 2	 2
	 64		 1	 7	 4	 3	 2	 2
	 128		 1	 7	 4	 3	 2	 2
intrinsic dimensionalities
Figure 28.10: We show the estimated number of clusters, and their estimated dimensionalities, as a function
of sample size. The ARD algorithm found two different solutions when N = 8. Note that more clusters, with
larger effective dimensionalities, are discovered as the sample sizes increases. From Table 4.1 of [Bea03].
Used with kind permission of Matt Beal.
dataset. The figures visualize the weight matrices for each cluster, using Hinton diagrams, where
where the size of the square is proportional to the value of the entry in the matrix. We see that
many of them are sparse. Figure 28.10 shows that the degree of sparsity depends on the amount of
training data, in accord with the Bayesian Occam’s razor. In particular, when the sample size is
small, the method automatically prefers simpler models, but as the sample size gets sufficiently large,
the method converges on the “correct” solution, which is one with 6 subspaces of dimensionality 1, 2,
2, 3, 4 and 7.
Although the ARD method can estimate the number of latent dimensions L, it still needs to
perform discrete search over the number of mixture components Nc. This is done using “birth” and
“death” moves [GB00]. An alternative approach is to perform stochastic sampling in the space of
models. Traditional approaches, such as [LW04], are based on reversible jump MCMC, and also use
birth and death moves. However, this can be slow and difficult to implement. More recent approaches
use non-parametric priors, combined with Gibbs sampling, see e.g., [PC09].
28.3.3.5 MixFA for image generation
In this section, we use the MFA model as a generative model for images, following [RW18]. This is
equivalent to using a mixture of Gaussians, where each mixture component has a low-rank covariance
matrix. Surprisingly, the results are competitive with deep generative models such as those in Part IV,
despite the fact that no neural networks are used in the model.
In [RW18], they fit the MFA model to the CelebA dataset, which is a dataset of faces of celebrities
(movie stars). They use K = 300 components, each of latent dimension L = 10; the observed data
has dimension D = 64 × 64 × 3 = 12, 288. They fit the model using SGD, using the methods from
Section 28.3.1.3 to efficiently compute the log likelihood, despite the high dimensionality. The µk
parameters are initialized using K-means clustering, and the Wk parameters are initialized using
factor analysis for each component separately. Then the model is fine-tuned end-to-end.
Figure 28.11 shows some images generated from the fitted model. The results are suprisingly good
for such a simple locally linear model. The reason the method works is similar to the discussion
in Section 28.2.4.1: essentially the Wk matrix learns a set of L-dimensional basis functions for the
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.3. FACTOR ANALYSIS
Figure 28.11: Random samples from the MixFA model fit to CelebA. Generated by mix_ppca_celebA.ipynb.
Adapted from Figure 4 of [RW18]. Used with kind permission of Yair Weiss.
(a) (b)
Figure 28.12: (a) Visualization of the parameters learned by the MFA model. The top row shows the mean
µk and noise variance Ψk, reshaped from 12,288-dimensional vectors to 64 × 64 × 3 images, for two mixture
components k. The next 5 rows show the first 5 (of 10) basis functions (columns of Wk) as images. On
row i, left column, we show µk − Wk[:, i]; in the middle, we show 0.5 + Wk[:, i], and on the right we show
µk + Wk[:, i]. (b) Images generated by computing µk + z1Wk[:, i] + z2Wk[:, j], for some component k and
dimensions i, j, where (z1, z2) are drawn from the grid [−1 : 1, −1 : 1], so the central image is just µk
. From
Figure 6 of [RW18]. Used with kind permission of Yair Weiss.
subset of face images that get mapped to cluster k. See Figure 28.12 for an illustration.
There are several advantages to this model compared to VAEs and GANs. First, [RW18], showed
that this MixFA model captures more of the modes of the data distribution than more sophisticated
generative models, such as VAEs (Section 21.2) and GANs (Chapter 26). Second, we can compute
the exact likelihood p(x), so we can compute outliers or unusual images. This is illustrated in
Figure 28.13.
Third, we can perform image imputation from partially observed images given arbitrary missingness
patterns. To see this, let us partition x = (x1, x2), where x1 (of size D1) is observed and x2 (of size
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license942
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 28.13: Samples from the 100 CelebA images with lowest likelihood under the MFA model. Generated
by mix_ppca_celebA.ipynb. Adapted from Figure 7a of [RW18]. Used with kind permission of Yair Weiss.
Figure 28.14: Illustration of image imputation using an MFA. Left column shows 4 original images. Subsequent
pairs of columns show an occluded input, and a predicted output. Generated by mix_ppca_celebA.ipynb.
Adapted from Figure 7b of [RW18]. Used with kind permission of Yair Weiss.
D2 = D − D1) is missing. We can compute the most probable cluster using
k
∗ =
K
argmax
k=1
p(c = k)p(x1|c = k) (28.94)
where
log p(x1|µk
, Ck) = −
1
2
h
D1 log(2π) + log det(Ck,11) + x˜
T
1C
−1
k,11x˜1
i
(28.95)
where Ck,11 is the top left D1 × D1 block of WkWT
k + Ψk, and x˜1 = x1 − µk
[1 : D1]. Once we know
which discrete mixture component to use, we can compute the Gaussian posterior p(z|x1, k∗
) using
Equation (28.59). Let zˆ = E [z|x1, k∗
]. Given this, we can compute the predicted output for the full
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.3. FACTOR ANALYSIS
xi yi
zi
Wx Wy
N
(a)
xi yi
z
s z i
x
i
Bx
Wx Wy
N
(b)
Figure 28.15: Gaussian latent factor models for paired data. (a) Supervised PCA. (b) Partial least squares.
image:
xˆ = Wk∗ zˆ + µk∗ (28.96)
We then use the estimate x
′ = [x1, xˆ2], so the observed pixels are not changed. This is an example of
image imputation, and is illustrated in Figure 28.14. Note that we can condition on an arbitrary
subset of pixels, and fill in the rest, whereas some other models (e.g., autoregressive models) can only
predict the bottom right given the top left (since they assume a generative model which works in
raster-scan order).
28.3.4 Factor analysis models for paired data
In this section, we discuss linear-Gaussian factor analysis models when we have two kinds of observed
variables, x ∈ R
Dx and y ∈ R
Dy , which are paired. These often correspond to different sensors or
modalities (e.g., images and sound). We follow the presentation of [Vir10].
28.3.4.1 Supervised PCA
If we have two observed signals, we can model the joint p(x, y) using a shared low-dimensional
representation using the following linear Gaussian model:
p(zn) = N (zn|0, IL) (28.97)
p(xn|zn, θ) = N (xn|Wxzn, σ2
x
IDx
) (28.98)
p(yn|zn, θ) = N (yn|Wyzn, σ2
y
IDy
) (28.99)
This is illustrated as a graphical model in Figure 28.15a. The intuition is that zn is a shared latent
subspace, that captures features that xn and yn have in common. The variance terms σx and σy
control how much emphasis the model puts on the two different signals.
The above model is called supervised PCA [Yu+06]. If we put a prior on the parameters
θ = (Wx,Wy, σx, σy), it is called Bayesian factor regression [Wes03].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license944
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We can marginalize out zn to get p(yn|xn, θ). If yn is a scalar, this becomes
p(yn|xn, θ) = N (yn|x
T
nv, wT
yCwy + σ
2
y
) (28.100)
C = (I + σ
−2
x WT
xWx)
−1
(28.101)
v = σ
−2
x CWxwy (28.102)
To apply this to the classification setting, we can replace the Gaussian p(y|z) with a logistic
regression model:
p(yn|zn, θ) = Ber(yn|σ(wT
y zn)) (28.103)
In this case, we can no longer compute the marginal posterior predictive p(yn|xn, θ) in closed form,
but we can use techniques similar to exponential family PCA (see [Guo09] for details).
The above model is completely symmetric in x and y. If our goal is to predict y from x via
the latent bottleneck z, then we might want to upweight the likelihood term for y, as proposed in
[Ris+08]. This gives
p(X, Y, Z|θ) = p(Y|Z,Wy)p(X|Z,Wx)
α
p(Z) (28.104)
where α ≤ 1 controls the relative importance of modeling the two sources. The value of α can be
chosen by cross-validation.
28.3.4.2 Partial least squares
We now consider an asymmetric or more “discriminative” form of supervised PCA. The key idea is to
allow some of the (co)variance in the input features to be explained by its own subspace, z
x
i
, and to
let the rest of the subspace, z
s
i
, be shared between input and output. The model has the form
p(zi) = N (z
s
i
|0, ILs
)N (z
x
i
|0, ILx
) (28.105)
p(yi
|zi) = N (Wyz
s
i + µy
, σ2
IDy
) (28.106)
p(xi
|zi) = N (Wxz
s
i + Bxz
x
i + µx
, σ2
IDx
) (28.107)
See Figure 28.15b. The corresponding induced distribution on the visible variables has the form
p(vi
|θ) = Z
N (vi
|Wzi + µ, σ2
I)N (zi
|0, I)dzi = N (vi
|µ,WWT + σ
2
I) (28.108)
where vi = (yi
; xi), µ = (µy
; µx
) and
W =
Wy 0
Wx Bx

(28.109)
WWT =
WyWT
y WyWT
x
WxWT
y WxWT
x + BxBT
x

(28.110)
We should choose L large enough so that the shared subspace does not capture covariate-specific
variation.
MLE in this model is equivalent to the technique of partial least squares (PLS) [Gus01; Nou+02;
Sun+09]. This model can be also be generalized to discrete data using the exponential family [Vir10].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.3. FACTOR ANALYSIS
xi yi
z
s z i
x
i z
y
i
Bx By
Wx Wy
N
Figure 28.16: Canonical correlation analysis as a PGM.
28.3.4.3 Canonical correlation analysis
We now consider a symmetric unsupervised version of PLS, in which we allow each view to have
its own “private” subspace, but there is also a shared subspace. If we have two observed variables,
xi and yi
, then we have three latent variables, z
s
i ∈ R
Ls which is shared, z
x
i ∈ R
Lx and z
y
i ∈ R
Ly
which are private. We can write the model as follows [BJ05]:
p(zi) = N (z
s
i
|0, ILs
)N (z
x
i
|0, ILx
)N (z
y
i
|0, ILy
) (28.111)
p(xi
|zi) = N (xi
|Bxz
x
i + Wxz
s
i + µx
, σ2
IDx
) (28.112)
p(yi
|zi) = N (yi
|Byz
y
i + Wyz
s
i + µy
, σ2
IDy
) (28.113)
See Figure 28.16 The corresponding observed joint distribution has the form
p(vi
|θ) = Z
N (vi
|Wzi + µ, σ2
I)N (zi
|0, I)dzi = N (vi
|µ,WWT + σ
2
ID) (28.114)
where
W =
Wx Bx 0
Wy 0 By

(28.115)
WWT =
WxWT
x + BxBT
x WxWT
y
WyWT
x WyWT
y + ByBT
y

(28.116)
[BJ05] showed that MLE for this model is equivalent to a classical statistical method known as
canonical correlation analysis or CCA [Hot36]. However, the PGM perspective allows us to
easily generalize to multiple kinds of observations (this is known as generalized CCA [Hor61]) or
to nonlinear models (this is known as deep CCA [WLL16; SNM16]), or exponential family CCA
[KVK10]. See [Uur+17] for further discussion of CCA and its extensions, and Section 32.2.2.2 for
more details.
28.3.5 Factor analysis with exponential family likelihoods
So far we have assumed the observed data is real-valued, so xn ∈ R
D. If we want to model other
kinds of data (e.g., binary or categorical), we can simply replace the Gaussian output distribution
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license946
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
W1 WD
xn,1 xn,D
zn
µ Σ
Figure 28.17: Exponential family PCA model as a DPGM.
with a suitable member of the exponential family, where the natural parameters are given by a linear
function of zn. That is, we use
p(xn|zn) = exp(T (x)
Tθ + h(x) − g(θ)) (28.117)
where the N × D matrix of natural parameters is assumed to be given by the low rank decomposition
Θ = ZW, where Z is N × L and W is L × D. The resulting model is called exponential family
factor analysis
Unlike the linear-Gaussian FA, we cannot compute the exact posterior p(zn|xn,W) due to the
lack of conjugacy between the expfam likelihood and the Gaussian prior. Furthermore, we cannot
compute the exact marginal likelihood either, which prevents us from finding the optimal MLE.
[CDS02] proposed a coordinate ascent method for a deterministic variant of this model, known as
exponential family PCA. This alternates between computing a point estimate of zn and W. This
can be regarded as a degenerate version of variational EM, where the E step uses a delta function
posterior for zn. [GS08] present an improved algorithm that finds the global optimum, and [Ude+16]
presents an extension called generalized low rank models, that covers many different kinds of
loss function.
However, it is often preferable to use a probabilistic version of the model, rather than computing
point estimates of the latent factors. In this case, we must represent the posterior using a non￾degenerate distribution to avoid overfitting, since the number of latent variables is proportional to
the number of data cases [WCS08]. Fortunately, we can use a non-degenerate posterior, such as a
Gaussian, by optimizing the variational lower bound. We give some examples of this below.
28.3.5.1 Example: binary PCA
Consider a factored Bernoulli likelihood:
p(x|z) = Y
d
Ber(xd|σ(wT
dz)) (28.118)
Suppose we observe N = 150 bit vectors of length D = 16. Each example is generated by choosing
one of three binary prototype vectors, and then by flipping bits at random. See Figure 28.18(a)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.3. FACTOR ANALYSIS
(a) (b)
(c) (d)
Figure 28.18: (a) 150 synthetic 16 dimensional bit vectors. (b) The 2d embedding learned by binary PCA, fit
using variational EM. We have color coded points by the identity of the true “prototype” that generated them.
(c) Predicted probability of being on. (d) Thresholded predictions. Generated by binary_fa_demo.ipynb.
for the data. We can fit this using the variational EM algorithm (see [Tip98] for details). We
use L = 2 latent dimensions to allow us to visualize the latent space. In Figure 28.18(b), we plot
E
h
zn|xn,Wˆ
i
. We see that the projected points group into three distinct clusters, as is to be expected.
In Figure 28.18(c), we plot the reconstructed version of the data, which is computed as follows:
p(ˆxnd = 1|xn) = Z
dzn p(zn|xn)p(ˆxnd|zn) (28.119)
If we threshold these probabilities at 0.5 (corresponding to a MAP estimate), we get the “denoised”
version of the data in Figure 28.18(d).
28.3.5.2 Example: categorical PCA
We can generalize the model in Section 28.3.5.1 to handle categorical data by using the following
likelihood:
p(x|z) = Y
d
Cat(xd|softmax(Wdz)) (28.120)
We call this categorical PCA (CatPCA). A variational EM algorithm for fitting this is described
in [Kha+10].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license948
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.3.6 Factor analysis with DNN likelihoods (VAEs)
The FA model assumes the observed data can be modeled as arising from a linear mapping from a
low-dimensional set of Gaussian factors. One way to relax this assumption is to let the mapping
from z to x be a nonlinear model, such as a neural network. That is, the likelihood becomes
p(x|z) = N (x|f(w; θ), σ2
I) (28.121)
We call this “nonlinear factor analysis”. (We can of course replace the Gaussian likelihood with
other distributions, such as categorical, in which case we get nonlinear exponential family factor
analysis.) Unfortunately we can no longer compute the posterior or the MLE exactly, so we need to
use approximate methods. In Chapter 21, we discuss the variational autoencoder, which fits this
nonlinear FA model using amortized variational inference. However, it is also possible to fit the same
model using other inference methods, such as MCMC (see e.g., [Hof17]).
28.3.7 Factor analysis with GP likelihoods (GP-LVM)
In this section we discuss a nonlinear version of factor analysis in which we replace the linear decoder
f(z) = Wz used in the likelihood p(y|z) = N (y|f(z), σ2
I) with a nonlinear function, represented by
a Gaussian process (Chapter 18), one per output dimension. This is known as a GP-LVM, which
stands for “Gaussian process latent variable model” [Law05]. (Note that we switch notation a bit
from standard FA and define the observed output variable by y, to be consistent with standard
supervised GP notation; the inputs to the GP will be latent variables z.)
To explain the method in more detail, we start with PPCA (Section 28.3.2). Recall that the PPCA
model is as follows:
p(zi) = N (zi
|0, I) (28.122)
p(yi
|zi
, θ) = N (yi
|Wzi
, σ2
I) (28.123)
We can fit this model by maximum likelihood, by integrating out the zi and maximizing wrt W (and
σ
2
). The objective is given by
p(Y|W, σ2
) = (2π)
−DN/2
|C|
−N/2
exp 
−
1
2
tr(C−1YTY)

(28.124)
where C = WWT + σ
2
I. As we showed in Section 28.3.2, the MLE for W can be computed in terms
of the eigenvectors of YTY.
Now we consider the dual problem, whereby we maximize wrt Z and integrate out W. We will use
a prior of the form p(W) = Q
j N (wj |0, I). The corresponding likelihood becomes
p(Y|Z, σ2
) = Y
D
d=1
N (Y:,d|0, ZZT + σ
2
I) (28.125)
= (2π)
−DN/2
|Kz|
−D/2
exp 
−
1
2
tr(K−1
σ YYT
)

(28.126)
where Kσ = K + σ
2
I, and K = ZZT. The MLE for Z can be computed in terms of the eigenvectors
of Kσ, and gives the same results as PPCA (see [Law05] for the details).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.4. LFMS WITH NON-GAUSSIAN PRIORS
2 1 0 1 2 3
2
1
0
1
2
3
Latent Space
jumping motion
walking motion
Pose A
Pose B
Pose A Pose B
Figure 28.19: Illustration of a 2d embedding of human motion-capture data using a GP-LVM. We show two
poses and their corresponding embeddings. Generated by gplvm_mocap.ipynb. Used with kind permission of
Aditya Ravuri.
To understand what this process is doing, consider modeling the prior on f : Z → Y with a GP
with a linear kernel:
K(zi
, zj ) = z
T
i zj + σ
2
δij (28.127)
The corresponding covariance matrix has the form K = ZZT + σ
2
I. Thus Equation (28.126) is
equivalent to the likelihood of a product of independent GPs. Just as factor analysis is like linear
regression with unknown inputs, so GP-LVM is like GP regression with unknown inputs. The goal
is then to compute a point estimate of these unknown inputs, i.e., Zˆ. (We can also use Bayesian
inference.)
The advantage of the dual formulation is that we can use a more general kernel for K instead of
the linear kernel. That is, we can set Kij = K(zi
, zj ) for any Mercer kernel. The MLE for Z is no
longer be available via eigenvalue methods, but can be computed using gradient-based optimization.
In Figure 28.19, we illustrate the model (with an ARD kernel) applied to some motion capture
data, from the CMU mocap database at http://mocap.cs.cmu.edu/. Each person has 41 markers,
whose motion in 3d is tracked using 12 infrared cameras. Each datapoint corresponds to a different
body pose. When projected to 2d, we see that similar poses are clustered nearby.
28.4 LFMs with non-Gaussian priors
In this section, we discuss (linear) latent factor models with non-Gaussian priors. See Table 28.1 for
a summary of the models we will discuss.
28.4.1 Non-negative matrix factorization (NMF)
Suppose that we use a gamma distribution for the latents: p(z) = Q
k Ga(zk|αk, βk). This results in
a sparse, non-negative hidden representation, which can help interpretability. This is particularly
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license950
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
W1 WD
xn,1
...
xn,D
zn,1
...
zn,K
N
α1 β1
...
αK βK
(a)
W1 WD
xn,1 xn,D
zn
α
(b)
Figure 28.20: (a) Gaussian-Poisson (GAP) model as a DPGM. Here zn,k ∈ R
+ and xn,d ∈ Z≥0. (b) Simplex
FA model as a DPGM. Here zn ∈ SK and xn,d ∈ {1, . . . , V }.
useful when the data is also sparse and non-negative, such as word counts. In this case, it makes
sense to use a Poisson likelihood: p(x|z) = QD
d=1 Poi(xd|wT
d
z). The overall model has the form
p(z, x) = p(z)p(x|z) = "Y
k
Ga(zk|αk, βk)
# "Y
D
d=1
Poi(xd|wT
dz)
#
(28.128)
The resulting model is called the GaP (gamma-Poisson) model [Can04]. See Figure 28.20a for the
graphical model.
The parameters αk and βk control the sparsity of the latent representation zn. If we set αk = βk = 0,
and compute the MLE for W, we recover non-negative matrix factorization (NMF) [PT94;
LS99; LS01], as shown in [BJ06].
Figure 28.21 illustrates the result of applying NMF to a dataset of image patches of faces, where
the data correspond to non-negative pixel intensities. We see that the learned basis functions are
small localized parts of faces. Also, the coefficient vector z is sparse and positive. For PCA, the
coefficient vector has negative values, and the resulting basis functions are global, not local. For
vector quantization (i.e., GMM model), z is a one-hot vector, with a single mixture component
turned on; the resulting weight vectors correspond to entire image prototypes. The reconstruction
quality is similar in each case, but the nature of the learned latent representation is quite different.
28.4.2 Multinomial PCA
Suppose we use a Dirichlet prior for the latents, p(z) = Dir(z|α), so z ∈ SK, which is the K￾dimensional probability simplex. As in Section 28.4.1, the vector z will be sparse and non-negative,
but in addition it will satsify the constraint PK
k=1 zk = 1, so the components are not independent.
Now suppose our data is categorical, xd ∈ {1, . . . , V }, so our likelihood has the form p(x|z) =
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.4. LFMS WITH NON-GAUSSIAN PRIORS
Figure 28.21: Illustrating the difference between non-negative matrix factorization (NMF), vector quantization
(VQ), and principal components analysis (PCA). Left column: filters (columns of W) learned from a set of
2429 faces images, each of size 19 × 19. There are 49 basis functions in total, shown in a 7 × 7 montage;
each filter is reshaped to a 19 × 19 image for display purposes. (For PCA, negative weights are red, positive
weights are black.) Middle column: the 49 latent factors z when the model is applied to the original face
image shown at the top. Right column: reconstructed face image. From Figure 1 of [LS99].
Q
d Cat(xd|Wdz). The overall model is therefore
p(z, x) = Dir(z|α)
Y
D
d=1
Cat(xd|Wdz) (28.129)
See Figure 28.20b for the DPGM. This model (or small variants of it) has multiple names: user
rating profile model [Mar03], admixture model [PSD00], mixed membership model [EFL04],
multinomial PCA (mPCA) [BJ06], or simplex factor analysis (sFA) [BD11].
28.4.2.1 Example: roll call data
Let us consider the example from [BJ06], who applied this model to analyze some roll call data
from the US Senate in 2003. Specifically, the data has the form xn,d ∈ {+1, −1, 0} for n = 1 : 100
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license952
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Boxer (D−CA)
Harkin (D−IA)
Sarbanes (D−MD)
Levin (D−MI)
Leahy (D−VT)
Reed (D−RI)
Lautenberg (D−NJ)
Clinton (D−NY)
Durbin (D−IL)
Kennedy (D−MA)
Mikulski (D−MD)
Corzine (D−NJ)
Stabenow (D−MI)
Kerry (D−MA)
Schumer (D−NY)
Edwards (D−NC)
Murray (D−WA)
Graham (D−FL)
Akaka (D−HI)
Rockefeller (D−WV)
Cantwell (D−WA)
Dodd (D−CT)
Reid (D−NV)
Byrd (D−WV)
Daschle (D−SD)
Kohl (D−WI)
Lieberman (D−CT)
Johnson (D−SD)
Feingold (D−WI)
Inouye (D−HI)
Dayton (D−MN)
Bingaman (D−NM)
Wyden (D−OR)
Dorgan (D−ND)
Feinstein (D−CA)
Nelson (D−FL)
Biden (D−DE)
Hollings (D−SC)
Conrad (D−ND)
Pryor (D−AR)
Jeffords (I−VT)
Bayh (D−IN)
Carper (D−DE)
Lincoln (D−AR)
Landrieu (D−LA)
Baucus (D−MT)
Breaux (D−LA)
Nelson (D−NE)
Outcome
Miller (D−GA)
Democrats
1
2
3
4
5
(a) Democrats.
Chafee (R−RI)
Snowe (R−ME)
Collins (R−ME)
Outcome
McCain (R−AZ)
Specter (R−PA)
Campbell (R−CO)
Gregg (R−NH)
Smith (R−OR)
DeWine (R−OH)
Murkowski (R−AK)
Voinovich (R−OH)
Hutchison (R−TX)
Coleman (R−MN)
Fitzgerald (R−IL)
Ensign (R−NV)
Stevens (R−AK)
Warner (R−VA)
Lugar (R−IN)
Sununu (R−NH)
Graham (R−SC)
Hagel (R−NE)
Brownback (R−KS)
Shelby (R−AL)
Roberts (R−KS)
Domenici (R−NM)
Bond (R−MO)
Talent (R−MO)
Grassley (R−IA)
Dole (R−NC)
Santorum (R−PA)
Hatch (R−UT)
Bennett (R−UT)
Lott (R−MS)
Allen (R−VA)
Chambliss (R−GA)
Burns (R−MT)
Frist (R−TN)
Inhofe (R−OK)
Cochran (R−MS)
Allard (R−CO)
Alexander (R−TN)
McConnell (R−KY)
Sessions (R−AL)
Bunning (R−KY)
Cornyn (R−TX)
Crapo (R−ID)
Kyl (R−AZ)
Craig (R−ID)
Enzi (R−WY)
Nickles (R−OK)
Thomas (R−WY)
Republicans
1
2
3
4
5
(b) Republicans.
Figure 28.22: The simplex factor analysis model applied to some roll call data from the US Senate collected
in 2003. The senators have been sorted from left to right using the binary PCA method of [Lee06]. See text
for details. From Figures 8–9 of [BJ06]. Used with kind permission of Wray Buntine.
and d = 1 : 459, where xnd is the vote of the n’th senator on the d’th bill, where +1 means in favor,
−1 means against, and 0 means not voting. In addition, we have the overall outcome, which we
denote by x101,d ∈ {+1, −1}, where +1 means the bill was passed, and -1 means it was rejected.
We fit the mPCA model to this data using 5 latent factors using variational EM. Figure 28.22
plots E [znk|xn] ∈ [0, 1], which is the degree to which senator n belongs to latent component or “bloc”
k. We see that component 5 is the Democractic majority, and block 2 is the Republican majority.
See [BJ06] for further details.
28.4.2.2 Advantage of Dirichlet prior over Gaussian prior
The main advantage of using a Dirichlet prior compared to a Gaussian prior is that the latent factors
are more interpretable. To see this, note that the mean parameters for d’th output distribution have
the form µnd = Wdzn, and hence
p(xnd = v|zn) = X
k
znkw
d
vk (28.130)
Thus the latent variables can be additively combined to compute the mean parameters, aiding
interpretability. By contrast, the CatPCA model in Section 28.3.5.2 uses a Gaussian prior, so Wdzn
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.5. TOPIC MODELS
can be negative; consequently it must pass this vector through a softmax, to convert from natural
parameters to mean parameters; this makes zn harder to interpret.
28.4.2.3 Connection to mixture models
If zn were a one-hot vector, rather than any point in the probability simplex, then the mPCA model
would be equivalent to selecting a single column from Wd corresponding to the discrete hidden state.
This is equivalent to a finite mixture of categorical distributions (see Section 28.2.2), and corresponds
to the assumption that x is generated by a single cluster. However, the mPCA model does not require
that zn be one-hot, and instead allows xn to partially belong to multiple clusters. For this reason,
this model is also known as an admixture mixture or mixed membership model [EFL04].
28.5 Topic models
In this section, we show how to modify the multinomial PCA model of Section 28.4.2 to create latent
variable models for sequences of discrete tokens, such as words in text documents, or genes in a DNA
sequence. The basic idea is to assume that the words are conditionally independent given a latent
topic vector z. Rather than being a single discrete cluster label, z is a probability distribution over
clusters, and each word is sampled from its own “local” cluster. In the NLP community, this kind of
model is called a topic model (see e.g., [BGHM17]).
28.5.1 Latent Dirichlet allocation (LDA)
In this section, we discuss the most common kind of topic model known as latent Dirichlet
allocation or LDA [BNJ03a; Ble12]. (This usage of the term “LDA” is not to be confused with
linear discriminant analysis.) In the genetic community, this model is known as an admixture
model [PSD00].
28.5.1.1 Model definition
We can define the LDA model as follows. Let xnl ∈ {1, . . . , V } be the identity of the l’th word in
document n, where l can now range from 1 to Ln, the length of the document, and V is the size of
the vocabulary. The probability of word v at location l is given by
p(xnl = v|zn) = X
k
znkwkv (28.131)
where 0 ≤ znk ≤ 1 is the proportion of “topic” k in document n, and zn ∼ Dir(α).
We can rewrite this model by associating a discrete latent variable mnl ∈ {1, . . . , Nz} with each
word in each document, with distribution p(mnl|zn) = Cat(mnl|zn). Thus mnl specifies the topic to
use for word l in document n. The full joint model becomes
p(xn, zn,mn) = Dir(zn|α)
Y
Ln
l=1
Cat(mnl|zn)Cat(xnl|W[mnl, :]) (28.132)
where W[k, :] = wk is the distribution over words for the k’th topic. See Figure 28.23 for the
corresponding DPGM.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license954
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
β
W
xn,1 xn,Ln
cn,1 cn,Ln
zn
α
(a)
N
Ln
xnl
cnl
zn
α
K
wk
β
(b)
Figure 28.23: Latent Dirichlet allocation (LDA) as a DPGM. (a) Unrolled form. (b) Plate form.
We typically use a Dirichlet prior the topic parameters, p(wk) = Dir(wk|β1V ); by setting β small
enough, we can encourage these topics to be sparse, so that each topic only predicts a subset of the
words. In addition, we use a Dirichlet prior on the latent factors, p(zn) = Dir(zn|α1Nz
). If we set α
small enough, we can encourage the topic distribution for each document to be sparse, so that each
document only contains a subset of the topics. See Figure 28.24 for an illustration.
Note that an earlier version of LDA, known as probabilistic LSA, was proposed in [Hof99].
(LSA stands for “latent semantic analysis”, and refers to the application of PCA to text data; see
[Mur22, Sec 20.5.1.2] for details.) The likelihood function, p(x|z), is the same as in LDA, but pLSA
does not specify a prior for z, since it is designed for posterior analysis of a fixed corpus (similar to
LSA), rather than being a true generative model.
28.5.1.2 Polysemy
Each topic is a distribution over words that co-occur, and which are therefore semantically related.
For example, Figure 28.25 shows 3 topics which were learned from an LDA model fit to the TASA
corpus3
. These seem to correspond to 3 different senses of the word “play”: playing an instrument,
a theatrical play, and playing a sports game.
We can use the inferred document-level topic distribution to overcome polysemy, i.e., to disam￾biguate the meaning of a particular word. This is illustrated in Figure 28.26, where a subset of the
words are annotated with the topic to which they were assigned (i.e., we show argmaxk p(mnl = k|xn).
In the first document, the word “music” makes it clear that the musical topic (number 77) is present
in the document, which in turn makes it more likely that mnl = 77 where l is the index corresponding
to the word “play”.
3. The TASA corpus is an untagged collection of educational materials consisting of 37,651 documents and 12,190,931
word tokens. Words appearing in fewer than 5 documents were replaced with an asterisk, but punctuation was included.
The combined vocabulary was of size 37,202 unique words.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.5. TOPIC MODELS
Figure 28.24: Illustration of latent Dirichlet allocation (LDA). We have color coded certain words by the topic
they have been assigned to: yellow represents the genetics cluster, pink represents the evolution cluster, blue
represent the data analysis cluster, and green represents the neuroscience cluster. Each topic is in turn defined
as a sparse distribution over words. This article is not related to neuroscience, so no words are assigned to
the green topic. The overall distribution over topic assignments for this document is shown in the right as a
sparse histogram. Adapted from Figure 1 of [Ble12]. Used with kind permission of David Blei.
word prob. word prob. word prob.
MUSIC .090 LITERATURE .031 PLAY .136
DANCE .034 POEM .028 BALL .129
SONG .033 POETRY .027 GAME .065
PLAY .030 POET .020 PLAYING .042
SING .026 PLAYS .019 HIT .032
SINGING .026 POEMS .019 PLAYED .031
BAND .026 PLAY .015 BASEBALL .027
PLAYED .023 LITERARY .013 GAMES .025
SANG .022 WRITERS .013 BAT .019
SONGS .021 DRAMA .012 RUN .019
DANCING .020 WROTE .012 THROW .016
PIANO .017 POETS .011 BALLS .015
PLAYING .016 WRITER .011 TENNIS .011
RHYTHM .015 SHAKESPEARE .010 HOME .010
ALBERT .013 WRITTEN .009 CATCH .010
MUSICAL .013 STAGE .009 FIELD .010
Topic 77 Topic 82 Topic 166
Figure 28.25: Three topics related to the word play. From Figure 9 of [SG07]. Used with kind permission of
Tom Griffiths.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license956
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Document #29795 
Bix beiderbecke, at age060 fifteen207
, sat174 on the slope071 of a bluff055 overlooking027 the mississippi137 river137
. He
was listening077 to music077 coming009 from a passing043 riverboat. The music077 had already captured006 his heart157
as well as his ear119
. It was jazz077
. Bix beiderbecke had already had music077 lessons077
. He showed002 promise134 on
the piano077
, and his parents035 hoped268 he might consider118 becoming a concert077 pianist
077
. But bix was
interested268 in another kind050 of music077
. He wanted268 to play077 the cornet. And he wanted268 to play077 jazz077
... 
Document #1883 
There is a simple050 reason106 why there are so few periods078 of really great theater082 in our whole western046 world.
Too many things300 have to come right at the very same time. The dramatists must have the right actors082
, the
actors082 must have the right playhouses, the playhouses must have the right audiences082
. We must remember288 that
plays082 exist143
to be performed077
, not merely050 to be read254
. ( even when you read254 a play082 to yourself, try288 to
perform062 it, to put174 it on a stage078
, as you go along.) as soon028 as a play082 has to be performed082
, then some 
kind126 of theatrical082
... 
Document #21359 
Jim296 has a game166 book254
. Jim296 reads254 the book254
. Jim296 sees081 a game166 for one. Jim296 plays166 the game
166
.
Jim296 likes081 the game166 for one. The game166 book254 helps
081 jim296
. Don180 comes040 into the house038
. Don180 and
jim
296 read254 the game166 book254
. The boys
020 see a game166 for two. The two boys020 play166 the game166
. The
boys020 play166 the game
166 for two. The boys020 like the game166
. Meg282 comes040
into the house282
. Meg282 and
don180 and jim296 read254 the book254
. They see a game166 for three. Meg282 and don180 and jim296 play166 the game166
.
They play166
... 
Figure 28.26: Three documents from the TASA corpus containing different senses of the word play. Grayed
out words were ignored by the model, because they correspond to uninteresting stop words (such as “and”, “the”,
etc.) or very low frequency words. From Figure 10 of [SG07]. Used with kind permission of Tom Griffiths.
28.5.1.3 Posterior inference
Many algorithms have been proposed to perform approximate posterior inference in the LDA model.
In the original LDA paper, [BNJ03a], they use variational mean field inference (see Section 10.3). In
[HBB10], they use stochastic VI (see Supplementary Section 28.1.2). In [GS04], they use collapsed
Gibbs sampling, which marginalizes out the discrete latents (see Supplementary Section 28.1.1).
In [MB16; SS17b] they discuss how to learned amortized inference networks to perform VI for the
collapsed model.
Recently, there has been considerable interest in spectral methods for fitting LDA-like models
which are fast and which come with provable guarantees about the quality of the solution they obtain
(unlike MCMC and variational methods, where the solution is just an approximation of unknown
quality). These methods make certain (reasonable) assumptions beyond the basic model, such as the
existence of some anchor words, which uniquely the topic for a document. See [Aro+13] for details.
28.5.1.4 Determining the number of topics
Choosing Nz, the number of topics, is a standard model selection problem. Here are some approaches
that have been taken:
• Use annealed importance sampling (Section 11.5.4) to approximate the evidence [Wal+09].
• Cross validation, using the log likelihood on a test set.
• Use the variational lower bound as a proxy for log p(D|Nz).
• Use non-parametric Bayesian methods [Teh+06].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.5. TOPIC MODELS
28.5.2 Correlated topic model
One weakness of LDA is that it cannot capture correlation between topics. For example, if a document
has the “business” topic, it is reasonable to expect the “finance” topic to co-occcur. The source
of the problem is the use of a Dirichlet prior for zn. The problem with the Dirichlet it that it is
characterized by just a mean vector α, but its covariance is fixed (Σij = −αiαj ), rather than being a
free parameter.
One way around this is to replace the Dirichlet prior with the logistic normal distribution, which
is defined as follows:
p(z) = Z
Cat(z|softmax(ǫ))N (ǫ|µ, Σ)dǫ (28.133)
This is known as the correlated topic model [BL07b];
The difference from categorical PCA discussed in Section 28.3.5.2 is that CTM uses a logistic
normal to model the mean parameters, so zn is sparse and non-negative, whereas CatPCA uses a
normal to model the natural parameters, so zn is dense and can be negative. More precisely, the
CTM defines xnl ∼ Cat(Wsoftmax(ǫn)), but CatPCA defines xnd ∼ Cat(softmax(Wdzn)).
Fitting the CTM model is tricky, since the prior for ǫn is no longer conjugate to the multinomial
likelihood for mnl. However, we can derive a variational mean field approximation, as described in
[BL07b].
Having fit the model, one can then convert Σˆ to a sparse precision matrix Σˆ −1
by pruning
low-strength edges, to get a sparse Gaussian graphical model. This allows you to visualize the
correlation between topics. Figure 28.27 shows the result of applying this procedure to articles from
Science magazine, from 1990–1999.
28.5.3 Dynamic topic model
In LDA, the topics (distributions over words) are assumed to be static. In some cases, it makes sense
to allow these distributions to evolve smoothly over time. For example, an article might use the topic
“neuroscience”, but if it was written in the 1900s, it is more likely to use words like “nerve”, whereas if
it was written in the 2000s, it is more likely to use words like “calcium receptor” (this reflects the
general trend of neuroscience towards molecular biology).
One way to model this is to assume the topic distributions evolve according to a Gaussian random
walk, as in a state space model (see Section 29.1). We can map these Gaussian vectors to probabilities
via the softmax function, resulting in the following model:
wt
k
|w
t−1
k ∼ N (wt−1,k, σ21Nw ) (28.134)
z
t
n ∼ Dir(α1Nz
) (28.135)
mt
nl|z
t
n ∼ Cat(z
t
n
) (28.136)
x
t
nl|mt
nl = k,Wt ∼ Cat(softmax(wt
k
)) (28.137)
This is known as a dynamic topic model [BL06]. See Figure 28.28 for the DPGM.
One can perform approximate inference in this model using a structured mean field method
(Section 10.4.1), that exploits the Kalman smoothing algorithm (Section 8.2.2) to perform exact
inference on the linear-Gaussian chain between the wt
k
nodes (see [BL06] for details). Figure 28.29
illustrates a typical output of the system when applied to 100 years of articles from Science.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license958
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
wild type
mutant
mutations
mutants
mutation
plants
plant
gene
genes
arabidopsis
p53
cell cycle
activity
cyclin
regulation
amino acids
cdna
sequence
isolated
protein
gene
disease
mutations
families
mutation
rna
dna
rna polymerase
cleavage
site
cells
cell
expression
cell lines
bone marrow
united states
women
universities
students
education
science
scientists
says
research
people
research
funding
support
nih
program
surface
tip
image
sample
device
laser
optical
light
electrons
quantum
materials
organic
polymer
polymers
molecules
volcanic
deposits
magma
eruption
volcanism
mantle
crust
upper mantle
meteorites
ratios
earthquake
earthquakes
fault
images
data
ancient
found
impact
million years ago
africa
climate
ocean
ice
changes
climate change
cells
proteins
researchers
protein
found
patients
disease
treatment
drugs
clinical
genetic
population
populations
differences
variation
fossil record
birds
fossils
dinosaurs
fossil
sequence
sequences
genome
dna
sequencing
bacteria
bacterial
host
resistance
parasite
development
embryos
drosophila
genes
expression
species
forest
forests
populations
ecosystems
synapses
ltp
glutamate
synaptic
neurons
neurons
stimulus
motor
visual
cortical
ozone
atmospheric
measurements
stratosphere
concentrations
sun
solar wind
earth
planets
planet
co2
carbon
carbon dioxide
methane
water
receptor
receptors
ligand
ligands
apoptosis
proteins
protein
binding
domain
domains
activated
tyrosine phosphorylation
activation
phosphorylation
kinase
magnetic
magnetic field
spin
superconductivity
superconducting
physicists
particles
physics
particle
experiment surface
liquid
surfaces
fluid
model reaction
reactions
molecule
molecules
transition state
enzyme
enzymes
iron
active site
reduction
pressure
high pressure
pressures
core
inner core
brain
memory
subjects
left
task
computer
problem
information
computers
problems
stars
astronomers
universe
galaxies
galaxy
virus
hiv
aids
infection
viruses
mice
antigen
t cells
antigens
immune response
Figure 28.27: Output of the correlated topic model (with K = 50 topics) when applied to articles from Science.
Nodes represent topics, with the 5 most probable phrases from each topic shown inside. Font size reflects
overall prevalence of the topic. See http: // www. cs. cmu. edu/ ~lemur/ science/ for an interactive version
of this model with 100 topics. Used with kind permission of Figure 2 of [BL07b]. Used with kind permission
of David Blei.
It is also possible to use amortized inference, and to learn embeddings for each word, which works
much better with rare words. This is called the dynamic embedded topic model [DRB19].
28.5.4 LDA-HMM
The Latent dirichlet allocation (LDA) model of Section 28.5.1 assumes words are exchangeable, and
thus ignores word order. A simple way to model sequential dependence between words is to use an
HMM. The trouble with HMMs is that they can only model short-range dependencies, so they cannot
capture the overall gist of a document. Hence they can generate syntactically correct sentences, but
not semantically plausible ones.
It is possible to combine LDA with HMM to create a model called LDA-HMM [Gri+04]. This
model uses the HMM states to model function or syntactic words, such as “and” or “however”, and uses
the LDA to model content or semantic words, which are harder to predict. There is a distinguished
HMM state which specifies when the LDA model should be used to generate the word; the rest of
the time, the HMM generates the word.
More formally, for each document n, the model defines an HMM with states hnl ∈ {0, . . . , H}. In
addition, each document has an LDA model associated with it. If hnl = 0, we generate word xnl
from the semantic LDA model, with topic specified by mnl; otherwise we generate word xnl from the
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.5. TOPIC MODELS
wt−1
k
x
t−1
nl
s
t−1
nl
z
t−1
n
Nt−1
wt
k
x
t
nl
s
t
nl
z
t
n
Nt
wt+1
k
x
t+1
nl
s
t+1
nl
z
t+1
n
Nt+1
Nz
α
Figure 28.28: The dynamic topic model as a DPGM.
"Neuroscience"
 1881
brain
movement
action
right
eye
hand
left
muscle
nerve
sound 
 1890
movement
eye
right
hand
brain
left
action
muscle
sound
experiment
 1900
brain
eye
movement
right
left
hand
nerve
vision
sound
muscle 
 1910
movement
brain
sound
nerve
active
muscle
left
eye
right
nervous 
 1920
movement
sound
muscle
active
nerve
stimulate
fiber
reaction
brain
response 
 1930
stimulate
muscle
sound
movement
response
nerve
frequency
fiber
active
brain 
 1940
record
nerve
stimulate
response
muscle
electrode
active
brain
fiber
potential
 1950
respons
record
stimulate
nerve
muscle
active
frequency
electrode
potential
study 
 1960
response
stimulate
record
condition
active
potential
stimulus
nerve
subject
eye 
 1970
respons
cell
potential
stimul
neuron
active
nerve
eye
record
abstract 
 1980
cell
neuron
response
active
brain
stimul
muscle
system
nerve
receptor 
 1990
cell
channel
neuron
ca2
active
brain
receptor
muscle
respons
current 
 2000
neuron
active
brain
cell
fig
response
channel
receptor
synapse
signal 
1880 1900 1920 1940 1960 1980 2000
ca2
neuron
nerve
1887 Mental Science
1900 Hemianopsia in Migraine
1912 A Defence of the ``New Phrenology''
1921 The Synchronal Flashing of Fireflies
1932 Myoesthesis and Imageless Thought
1943 Acetylcholine and the Physiology of the Nervous System
1952 Brain Waves and Unit Discharge in Cerebral Cortex
1963 Errorless Discrimination Learning in the Pigeon
1974 Temporal Summation of Light by a Vertebrate Visual Receptor
1983 Hysteresis in the Force-Calcium Relation in Muscle
1993 GABA-Activated Chloride Channels in Secretory Nerve Endings
Figure 28.29: Part of the output of the dynamic topic model when applied to articles from Science. At the top,
we show the top 10 words for the neuroscience topic over time. On the bottom left, we show the probability of
three words within this topic over time. On the bottom right, we list paper titles from different years that
contained this topic. From Figure 4 of [BL06]. Used with kind permission of David Blei.
syntactic HMM model. The DPGM is shown in Figure 28.30. The CPDs are as follows:
p(zn) = Dir(zn|α1Nz
) (28.138)
p(mnl = k|zn) = znk (28.139)
p(hn,l = j|hn,l−1 = i) = Aij (28.140)
p(xnl = d|mnl = k, hnl = j) = 
Wkd if j = 0
Bjd if j > 0
(28.141)
where W is the usual topic-word matrix, B is the state-word HMM emission matrix, and A is the
state-state HMM transition matrix.
Inference in this model can be done with collapsed Gibbs sampling, analytically integrating out all
the continuous quantities. See [Gri+04] for the details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license960
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
A B
W
hn,t−1 hn,t hn,t+1. . .
xn,t−1 xn,t xn,t+1
. . .
cn,t−1 cn,t cn,t+1
. . .
zn
α
ND
Figure 28.30: LDA-HMM model as a DPGM.
the the the the the a the the the
blood , , of a the , , ,
, and and , of of of a a
of of of to , , a of in
body a in in in in and and game
heart in land and to water in drink ball
and trees to classes picture is story alcohol and
in tree farmers government film and is to team
to with for a image matter to bottle to
is on farm state lens are as in play
blood forest farmers government light water story drugs ball
heart trees land state eye matter stories drug game
pressure forests crops federal lens molecules poem alcohol team
body land farm public image liquid characters people *
lungs soil food local mirror particles poetry drinking baseball
oxygen areas people act eyes gas character person players
vessels park farming states glass solid author effects football
arteries wildlife wheat national object substance poems marijuana player
* area farms laws objects temperature life body field
breathing rain corn department lenses changes poet use basketball
the in he * be said can time ,
a for it new have made would way ;
his to you other see used will years (
this on they first make came could day :
their with i same do went may part )
these at she great know found had number
your by we good get called must kind
her from there small go do place
my as this little take have
some into who old find did
Table 28.2: Upper row: topics extracted by the LDA model when trained on the combined Brown and TASA
corpora. Middle row: topics extracted by LDA part of LDA-HMM model. Bottom row: topics extracted by
HMM part of LDA-HMM model. Each column represents a single topic/class, and words appear in order of
probability in that topic/class. Since some classes give almost all probability to only a few words, a list is
terminated when the words account for 90% of the probability mass. From Figure 2 of [Gri+04]. Used with
kind permission of Tom Griffiths.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.5. TOPIC MODELS
1.
In contrast to this approach, we study here how the overall network activity can control single cell
parameters such as input resistance, as well as time and space constants, parameters that are crucial for
excitability and spariotemporal (sic) integration.
The integrated architecture in this paper combines feed forward control and error feedback adaptive
control using neural networks.
2.
In other words, for our proof of convergence, we require the softassign algorithm to return a doubly
stochastic matrix as *sinkhorn theorem guarantees that it will instead of a matrix which is merely close
to being doubly stochastic based on some reasonable metric.
The aim is to construct a portfolio with a maximal expected return for a given risk level and time
horizon while simultaneously obeying *institutional or *legally required constraints.
3.
The left graph is the standard experiment the right from a training with # samples.
The graph G is called the *guest graph, and H is called the host graph.
Figure 28.31: Function and content words in the NIPS corpus, as distinguished by the LDA-HMM model.
Graylevel indicates posterior probability of assignment to LDA component, with black being highest. The boxed
word appears as a function word in one sentence, and as a content word in another sentence. Asterisked
words had low frequency, and were treated as a single word type by the model. From Figure 4 of [Gri+04].
Used with kind permission of Tom Griffiths.
The results of applying this model (with Nz = 200 LDA topics and H = 20 HMM states) to the
combined Brown and TASA corpora4 are shown in Table 28.2. We see that the HMM generally is
responsible for syntactic words, and the LDA for semantics words. If we did not have the HMM, the
LDA topics would get “polluted” by function words (see top of figure), which is why such words are
normally removed during preprocessing.
The model can also help disambiguate when the same word is being used syntactically or semanti￾cally. Figure 28.31 shows some examples when the model was applied to the NIPS corpus.5 We see
that the roles of words are distinguished, e.g., “we require the algorithm to return a matrix” (verb) vs
“the maximal expected return” (noun). In principle, a part of speech tagger could disambiguate these
two uses, but note that (1) the LDA-HMM method is fully unsupervised (no POS tags were used),
and (2) sometimes a word can have the same POS tag, but different senses, e.g., “the left graph” (a
synactic role) vs “the graph G” (a semantic role).
More recently, [Die+17] proposed topic-RNN, which is similar to LDA-HMM, but replaces the
HMM model with an RNN, which is a much more powerful model.
4. The Brown corpus consists of 500 documents and 1,137,466 word tokens, with part-of-speech tags for each token.
The TASA corpus is an untagged collection of educational materials consisting of 37,651 documents and 12,190,931
word tokens. Words appearing in fewer than 5 documents were replaced with an asterisk, but punctuation was included.
The combined vocabulary was of size 37,202 unique words.
5. NIPS stands for “Neural Information Processing Systems”. It is one of the top machine learning conferences. The
NIPS corpus volumes 1–12 contains 1713 documents.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license962
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−1
0
1
−2.5
0.0
2.5
−1.5
0.0
1.5
0 100 200 300 400 500
0
4
(a) Truth (Latent signals)
0
4
−3
0
3
−3
0
3
0 100 200 300 400 500
0
3
(b) Observations
0
4
0
4
−2.5
0.0
2.5
0 100 200 300 400 500
0
3
(c) PCA estimate
0.0
0.2
−0.06
0.00
0.06
−0.1
0.0
0.1
0 100 200 300 400 500
−0.08
0.00
0.08
(d) ICA estimate
Figure 28.32: Illustration of ICA applied to 500 iid samples of a 4d source signal. This matches the true
sources, up to permutation of the dimension indices. Generated by ica_demo.ipynb.
28.6 Independent components analysis (ICA)
Consider the following situation. You are in a crowded room and many people are speaking. Your
ears essentially act as two microphones, which are listening to a linear combination of the different
speech signals in the room. Your goal is to deconvolve the mixed signals into their constituent
parts. This is known as the cocktail party problem, or the blind source separation (BSS)
problem, where “blind” means we know “nothing” about the source of the signals. Besides the obvious
applications to acoustic signal processing, this problem also arises when analyzing EEG and MEG
signals, financial data, and any other dataset (not necessarily temporal) where latent sources or
factors get mixed together in a linear way. See Figure 28.32 for an example.
28.6.1 Noiseless ICA model
We can formalize the problem as follows. Let xn ∈ R
D be the vector of observed responses, at “time”
n, where D is the number of sensors/microphones. Let zn ∈ R
D be the hidden vector of source
signals at time n, of the same dimensionality as the observed signal. We assume that
xn = Azn (28.142)
where A is an invertible D × D matrix known as the mixing matrix or the generative weights.
The prior has the form p(zn) = QD
j=1 pj (zj ). Typically we assume this is a sparse prior, so only a
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.6. INDEPENDENT COMPONENTS ANALYSIS (ICA)
−2 0 2
−2
0
2
(a) Uniform data
−2 0 2
−2
0
2
(b) Uniform data after linear mixing
−2 0 2
−2
0
2
(c) PCA estimate
−2 0 2
−2
0
2
(d) ICA estimate
Figure 28.33: Illustration of ICA and PCA applied to 100 iid samples of a 2d source signal with a uniform
distribution. Generated by ica_demo_uniform.ipynb.
subset of the signals are active at any one time (see Section 28.6.2 for further discussion of priors for
this model). This model is called independent components analysis or ICA, since we assume
that each observation xn is a linear combination of independent components represented by sources
zn, i.e,
xnj =
X
i
Aij znj (28.143)
Our goal is to infer the source signals, p(zn|xn, A). Since the model is noiseless, we have
p(zn|xn, A) = δ(zn − Bxn) (28.144)
where B = A−1 are the recognition weights. (We discuss how to estimate these weights in
Section 28.6.3.)
28.6.2 The need for non-Gaussian priors
Since x = Az, we have E [x] = AE [z] and Cov [x] = Cov [Az] = ACov [z] AT. Without loss of
generality, we can assume E [z] = 0, since we can always center the data. Similarly, we can assume
Cov [z] = I, since AAT can capture any correlation in x. Thus z is a set of D unit variance,
uncorrelated variables, as in factor analysis (Section 28.3.1).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license964
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
However, this is not sufficient to uniquely identify A and hence z, as we explained in Section 28.3.1.6.
So we need to go beyond an uncorrelated prior and enforce an independent, and non-Gaussian, prior.
To illustrate this, suppose we have two independent sources with uniform distributions, as shown
in Figure 28.33(a). Now suppose we have the following mixing matrix
A = 0.3

2 3
2 1
(28.145)
Then we observe the data shown in Figure 28.33(b) (assuming no noise). The full-rank PCA model
(where K = D) is equivalent to ICA, except it uses a factored Gaussian prior for z. The result of
using PCA is shown in Figure 28.33(c). This corresponds to a whitening or sphering of the data,
in which Cov [z] = I. To uniquely recover the sources, we need to perform an additional rotation.
The trouble is, there is no information in the symmetric Gaussian posterior to tell us which angle to
rotate by. In a sense, PCA solves “half” of the problem, since it identifies the linear subspace; all
that ICA has to do is then to identify the appropriate rotation. To do this, ICA uses an independent,
but non-Gaussian, prior. The result is shown in Figure 28.33(d). This shows that ICA can recover
the source variables, up to a permutation of the indices and possible sign change.
We typically use a prior which is a super-Gaussian distribution, meaning it has heavy tails; this
helps with identifiability. One option is to use a Laplace prior. For mean zero and variance 1, this
has a log pdf given by
log p(z) = −
√
2|z| − log(√
2) (28.146)
However, since the Laplace prior is not differentiable at the origin, in ICA it is more common to
use the logistic distribution, discussed in Section 15.4.1. If we set the mean to 0 and the variance
to 1, we have µ = 0 and s =
√
3
π
, so the log pdf becomes the following (using the relationship
sech(x) = 1/ cosh(x)):
log p(z) = log sech2
(z/2s) − log(4s) = −2 log cosh( π
2
√
3
z) − log 4
√
3
π
(28.147)
28.6.3 Maximum likelihood estimation
In this section, we discuss how to estimate the mixing matrix A using maximum likelohood. By the
change of variables formula we have
px(x) = pz(z)| det(A−1
)| = pz(Bx)| det(B))| (28.148)
where B = A−1
. We can simplify the problem by first whitening the data by computing x˜ =
S
− 1
2 UT(x − x), where Σ = USUT is the SVD of the covariance matrix. We can now replace the
general matrix B with an orthogonal matrix V. Hence the likelihood becomes
px(x˜) = pz(Vx˜)| det(V)| (28.149)
Since we are constraining V to be orthogonal, the | det(V)| term is a constant, so we can drop it.
In addition, we drop the tilde symbol, for brevity. Thus the average negative log likelihood can be
written as
NLL(V) = −
1
N
log p(X|V) = −
1
N
X
L
j=1
X
N
n=1
log pj (v
T
j xn) (28.150)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.6. INDEPENDENT COMPONENTS ANALYSIS (ICA)
where vj is the j’th row of V, and the prior is factored, so p(z) = Q
j
pj (zj ). We can also replace
the sum over n with an expectation wrt the empirical distribution to get the following objective
NLL(V) = X
j
E [Gj (zj )] (28.151)
where zj = v
T
j x and Gj (zj ) , − log pj (zj ). We want to minimize this (nonconvex) objective subject
to the constraint that V is an orthogonal matrix.
It is straightforward to derive a (projected) gradient descent algorithm to fit this model. (For some
JAX code, see https://github.com/tuananhle7/ica). One can also derive a faster algorithm that
follows the natural gradient; see e.g., [Mac03, ch 34] for details. However, the most popular method
is to use an approximate Newton method, known as fast ICA [HO00]. This was used to produce
Figure 28.32.
28.6.4 Alternatives to MLE
In this section, we discuss various alternatives estimators for ICA that have been proposed over the
years. We will show that they are equivalent to MLE. However, they bring interesting perspectives
to the problem.
28.6.4.1 Maximizing non-Gaussianity
An early approach to ICA was to find a matrix V such that the distribution z = Vx is as far from
Gaussian as possible. (There is a related approach in statistics called projection pursuit [FT74].)
One measure of non-Gaussianity is kurtosis, but this can be sensitive to outliers. Another measure is
the negentropy, defined as
negentropy(z) , H
￾
N (µ, σ2
)

− H (z) (28.152)
where µ = E [z] and σ
2 = V [z]. Since the Gaussian is the maximum entropy distribution (for a fixed
variance), this measure is always non-negative and becomes large for distributions that are highly
non-Gaussian.
We can define our objective as maximizing
J(V) = X
j
negentropy(zj ) = X
j
H
￾
N (µj , σ2
j
)

− H (zj ) (28.153)
where z = Vx. Since we assume E [z] = 0 and Cov [z] = I, the first term is a constant. Hence
J(V) = X
j
− H (zj ) + const = X
j
E [log p(zj )] + const (28.154)
which we see is equal (up to a sign change, and irrelevant constants) to the log-likelihood in
Equation (28.151).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licen966
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.6.4.2 Minimizing total correlation
In Section 5.3.5.1, we show that the total correlation of z is given by
TC(z) = X
j
H (zj ) − H (z) = DKL

p(z) k
Y
j
pk(zj )

 (28.155)
This is zero iff the components of z are all mutually independent. In Section 21.3.1.1, we show that
minimizing this results in a representation that is disentangled.
Now since z = Vx, we have
TC(z) = X
j
H(zj ) − H(Vx) (28.156)
Since we constrain V to be orthogonal, we can drop the last term, since H(Vx) = H(x) = const, since
multiplying by V does not change the shape of the distribution. Hence we have TC(z) = P
k H(zk).
Minimizing this is equivalent to maximizing the negentropy, which is equivalent to maximum
likelihood.
28.6.4.3 Maximizing mutual information (InfoMax)
Let zj = φ(v
T
j x) + ǫ be the noisy output of an encoder, where φ is some nonlinear scalar function,
and ǫ ∼ N (0, 1). It seems reasonable to try to maximize the information flow through this system, a
principle known as infomax [Lin88b; BS95a]. That is, we want to maximize the mutual information
between z (the internal neural representation) and x (the observed input signal). We have I(x; z) =
H(z) − H(z|x), where the latter term is constant if we assume the noise has constant variance. One
can show that we can approximate the former term as follows
H(z) = X
j
E

log φ
′
(v
T
j x)

+ log | det(V)| (28.157)
where, as usual, we can drop the last term if V is orthogonal. If we define φ(z) to be a cdf, then
φ
′
(z) is its pdf, and the above expression is equivalent to the log likelihood. In particular, if we
use a logistic nonlinearity, φ(z) = σ(z), then the corresponding pdf is the logistic distribution, and
log φ
′
(z) = log cosh(z), which matches Equation (28.147) (ignoring irrelevant constants). Thus we
see that infomax is equivalent to maximum likelihood.
28.6.5 Sparse coding
In this section, we consider an extension of ICA to the case where we allow for observation noise
(using a Gaussian likelihood), and we allow for a non-square mixing matrix W. We also use a Laplace
prior for z. The resulting model is as follows:
p(z, x) = p(z)p(x|z) = "Y
k
Laplace(zk|0, 1/λ)
#
N (x|Wz, σ2
I) (28.158)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
28.6. INDEPENDENT COMPONENTS ANALYSIS (ICA)
Thus each observation x is approximated by a sparse combination of columns of W, known as basis
functions; the sparse vector of weights is given by z. (This can be thought of as a form of sparse
factor analysis, except the sparsity is in the latent code z, not the weight matrix W.)
Not all basis functions will be active for any given observation, due to the sparsity penalty.
Hence we can allow for more latent factors K than observations D. This is called overcomplete
representation.
If we have a batch of N examples, stored in the rows of X, the negative log joint becomes
− log p(X, Z|W) = 1
2σ
2
X
N
n=1
||xn − Wzn||2
2 + λ||zn||1 + const (28.159)
=
1
2σ
2
||X − WZ||
2
F + λ||Z||1,1 + const (28.160)
The MAP inference problem consists of estimating Z for a fixed W; this is known as sparse coding,
and can be solved using standard algorithms for sparse linear regression (see Section 15.2.6).6
,
The learning problem consists of estimating W, marginalizing out Z. This is called dictionary
learning. Since this is computationally difficult, it is common to jointly optimize W and Z (thus
“maxing out” wrt Z instead of marginalizing it out). We can do this by applying alternating
optimization to Equation (28.160): estimating Z given W is a sparse linear regression problem, and
estimating W given Z is a simple least squares problem. (For faster algorithms, see [Mai+10].)
Figure 28.34(a) illustrates the results of dictionary learning when applied to a dataset of natural
image patches. (Each patch is first centered and normalized to unit norm.) We see that the method
has learned bar and edge detectors that are similar to the simple cells in the primary visual cortex
of the mammalian brain [OF96]. By contrast, PCA results in sinusoidal gratings, as shown in
Figure 28.34(b).7
28.6.6 Nonlinear ICA
There are various ways to extend ICA to the nonlinear case. The resulting methods are similar to
variational autoencoders (Chapter 21). For details, see e.g., [KKH20].
6. Solving an ℓ1 optimization problem for each data example can be slow. However, it is possible to train a neural
network to approximate the outcome of this process; this is known as predictive sparse decomposition [KRL08;
GL10].
7. The reason PCA discovers sinusoidal grating patterns is because it is trying to model the covariance of the data, which,
in the case of image patches, is translation invariant. This means Cov [I(x, y), I(x
′
, y′
)] = f

(x − x
′
)
2 + (y − y
′
)
2

for
some function f, where I(x, y) is the image intensity at location (x, y). One can show (see e.g., [HHH09, p125]) that
the eigenvectors of a matrix of this kind are always sinusoids of different phases, i.e., PCA discovers a Fourier basis.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license968
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 28.34: Illustration of the filters learned by various methods when applied to natural image patches. (a)
Sparse coding. (b) PCA. Generated by sparse_dict_demo.ipynb.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 202329 State-space models
29.1 Introduction
A state-space model (SSM) is a partially observed Markov model, in which the hidden state,
zt, evolves over time according to a Markov process (Section 2.6), and each hidden state generates
some observations yt at each time step. (We focus on discrete time systems.) The main goal is to
infer the hidden states given the observations. However, we may also be interested in using the model
to predict future observations (e.g., for time-series forecasting).
An SSM can be represented as a stochastic discrete time nonlinear dynamical system of the form
zt = f(zt−1,ut, qt) (29.1)
yt = h(zt,ut, y1:t−1, rt) (29.2)
where zt ∈ R
Nz are the hidden states, ut ∈ R
Nu are optional observed inputs, yt ∈ R
Ny are observed
outputs, f is the transition function, qt is the process noise, h is the observation function,
and rt is the observation noise.
Rather than writing this as a deterministic function of random noise, we can represent it as a
probabilistic model as follows:
p(zt|zt−1,ut) = p(zt|f(zt−1,ut)) (29.3)
p(yt|zt,ut, y1:t−1) = p(yt|h(zt,ut, y1:t−1)) (29.4)
where p(zt|zt−1,ut) is the transition model, and p(yt|zt,ut, y1:t−1) is the observation model.
Unrolling over time, we get the following joint distribution:
p(y1:T , z1:T |u1:T ) = "
p(z1|u1)
Y
T
t=2
p(zt|zt−1,ut)
# "Y
T
t=1
p(yt|zt,ut, y1:t−1)
#
(29.5)
If we assume the current observation yt only depends on the current hidden state, zt, and the
previous observation, yt−1, we get the graphical model in Figure 29.1(a). (This is called an auto￾regressive state-space model.) However, by using a sufficient expressive hidden state zt, we can
implicitly represent all the past observations, y1:t−1. Thus it is more common to assume that the
observations are conditionally independent of each other (rather than having Markovian dependencies)
given the hidden state. In this case the joint simplifies to
p(y1:T , z1:T |u1:T ) = "
p(z1|u1)
Y
T
t=2
p(zt|zt−1,ut)
# "Y
T
t=1
p(yt|zt,ut)
#
(29.6)970
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
yt−1 yt
zt−1 zt
ut−1 ut
(a)
yt−1 yt
zt−1 zt
(b)
Figure 29.1: State-space model represented as a graphical model. (a) Generic form, with inputs ut, hidden
state zt, and observations yt. We assume the observation likelihood is first-order auto-regressive. (b) Simplified
form, with no inputs, and Markovian observations.
Sometimes there are no external inputs, so the model further simplifies to the following unconditional
generative model:
p(y1:T , z1:T ) = "
p(z1)
Y
T
t=2
p(zt|zt−1)
# "Y
T
t=1
p(yt|zt)
#
(29.7)
See Figure 29.1(b) for the simplified graphical model.
29.2 Hidden Markov models (HMMs)
In this section, we discuss the hidden Markov model or HMM, which is an SSM in which the
hidden states are discrete, so zt ∈ {1, . . . , K}. The observations may be discrete, yt ∈ {1, . . . , Ny},
or continuous, yt ∈ R
Ny , or some combination, as we illustrate below. More details on HMMs can be
found in Supplementary Chapter 29, as well as other references, such as [Rab89; Fra08; CMR05]. For
an interactive introduction, see https://nipunbatra.github.io/hmm/.
29.2.1 Conditional independence properties
The HMM graphical model is shown in Figure 29.1(b). This encodes the assumption that the hidden
states are Markovian, and the observations are iid conditioned on the hidden states. All that remains
is to specify the form of the conditional probability distributions of each node.
29.2.2 State transition model
The initial state distribution is denoted by
p(z1 = j) = πj (29.8)
where π is a discrete distribution over the K states.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.2. HIDDEN MARKOV MODELS (HMMS)
0
4
observable
8
0 100 200 300 400
time
0
2
4
state
Figure 29.2: Some samples from an HMM with 10 Bernoulli observables. Generated by
bernoulli_hmm_example.ipynb.
The transition model is denoted by
p(zt = j|zt−1 = i) = Aij (29.9)
Here the i’th row of A corresponds to the outgoing distribution from state i. This is a row stochastic
matrix, meaning each row sums to one. We can visualize the non-zero entries in the transition
matrix by creating a state transition diagram, as shown in Figure 2.15.
29.2.3 Discrete likelihoods
The observation model p(yt|zt = j) can take multiple forms, depending on the type of data. For
discrete observations we can use
p(yt = k|zt = j) = yjk (29.10)
For example, see the casino HMM example in Section 9.2.1.1.
If we have D discrete observations per time step, we can use a factorial model of the form
p(yt|zt = j) = Y
D
d=1
Cat(ytd|yd,j,:) (29.11)
In the special case of binary observations, this becomes
p(yt|zt = j) = Y
D
d=1
Ber(ytd|yd,j ) (29.12)
In Figure 29.2, we give an example of an HMM with 5 hidden states and 10 Bernoulli observables.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license972
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
1.0 0.5 0.0 0.5 1.0
y1
1.0
0.5
0.0
0.5
1.0
y
2
Generating HMM
(a)
0 25 50 75 100 125 150 175 200
time
y1
y2
Simulated data from an HMM
(b)
Figure 29.3: (a) Some 2d data sampled from a 5 state HMM. Each state emits from a 2d Gaussian. (b) The
hidden state sequence is shown by the colors. We superimpose the observed 2d time series (note that we have
shifted the vertical scale so the values don’t overlap). Generated by gaussian_hmm_2d.ipynb.
29.2.4 Gaussian likelihoods
If yt is continuous, it is common to use a Gaussian observation model:
p(yt|zt = j) = N (yt|µj
, Σj ) (29.13)
As a simple example, suppose we have an HMM with 3 hidden states, each of which generates a 2d
Gaussian. We can represent these Gaussian distributions as 2d ellipses, as shown in Figure 29.3(a).
We call these “lily pads”, because of their shape. We can imagine a frog hopping from one lily
pad to another. (This analogy is due to the late Sam Roweis.) It will stay on a pad for a while
(corresponding to remaining in the same discrete state zt), and then jump to a new pad (corresponding
to a transition to a new state). See Figure 29.3(b). The data we see are just the 2d points (e.g.,
water droplets) coming from near the pad that the frog is currently on. Thus this model is like a
Gaussian mixture model (Section 28.2.1), in that it generates clusters of observations, except now
there is temporal correlation between the datapoints.
We can also use more flexible observation models. For example, if we use a M-component GMM,
then we have
p(yt|zt = j) = X
M
k=1
wjkN (yt|µjk, Σjk) (29.14)
This is called a GMM-HMM.
29.2.5 Autoregressive likelihoods
The standard HMM assumes the observations are conditionally independent given the hidden state.
In practice this is often not the case. However, it is straightforward to have direct arcs from yt−1 to
yt as well as from zt to yt, as in Figure 29.1(a). This is known as an auto-regressive HMM.
For continuous data, we can use an observation model of the form
p(yt|yt−1, zt = j, θ) = N (yt|Ejyt−1 + µj
, Σj ) (29.15)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.2. HIDDEN MARKOV MODELS (HMMS)
5 0 5
y1
5
0
5
y
2
5 0 5
y1
5
0
5
5 0 5
y1
5
0
5
5 0 5
y1
5
0
5
5 0 5
y1
5
0
5
Figure 29.4: Illustration of the observation dynamics for each of the 5 hidden states. The attractor point corre￾sponds to the steady state solution for the corresponding autoregressive process. Generated by hmm_ar.ipynb.
This is a linear regression model, where the parameters are chosen according to the current hidden
state. (We could also use a nonlinear model, such as a neural network.) Such models are widely
used in econometrics, where they are called regime switching Markov model [Ham90]. Similar
models can be defined for discrete observations (see e.g., [SJ99]).
We can also consider higher-order extensions, where we condition on the last L observations:
p(yt|yt−L:t−1, zt = j, θ) = N (yt|
X
L
ℓ=1
Wj,ℓyt−ℓ + µj
, Σj ) (29.16)
The AR-HMM essentially combines two Markov chains, one on the hidden variables, to capture long
range dependencies, and one on the observed variables, to capture short range dependencies [Ber99].
Since all the visible nodes are observed, adding connections between them just changes the likelihood,
but does not complicate the task of posterior inference (see Section 9.2.3).
Let us now consider a 2d example of this, due to Scott Linderman. We use a left-to-right transition
matrix with 5 states. In addition, the final state returns to first state, so we just cycle through the
states. Let yt ∈ R
2
, and suppose we set Ej to a rotation matrix with a small angle of 7 degrees, and
we set each µj
to 72-degree separated points on a circle about the origin, so each state rotates 1/5
of the way around the circle. If the model stays in the same state j for a long time, the observed
dynamics will converge to the steady state y∗,j , which satisfies y∗,j = Ejy∗,j + µj
; we can solve for
the steady state vector using y∗,j = (I − Ej )
−1µj
. We can visualize the induced 2d flow for each of
the 5 states as shown in Figure 29.4.
In Figure 29.5(a), we show a trajectory sampled from this model. We see that the two components
of the observation vector undergo different dynamics, depending on the underlying hidden state. In
Figure 29.5(b), we show the same data in a 2d scatter plot. The first observation is the yellow dot
(from state 2) at (−0.8, 0.5). The dynamics converge to the stationary value of y∗,2 = (−2.0, 3.8).
Then the system jumps to the green state (state 3), so it adds an offset of µ3
to the last observation,
and then converges to the stationary value of y∗,3 = (−4.3, −0.8). And so on.
29.2.6 Neural network likelihoods
For higher dimensional data, such as images, it can be useful to use a normalizing flow (Chapter 23),
one per latent state (see e.g., [HNBK18; Gho+21]), as the class-conditional generative model. However,
it is also possible to use discriminative neural network classifiers, which are much easier to train. In
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license974
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 25 50 75 100 125 150 175 200
time
y1
y2
(a)
4 3 2 1 0 1 2 3
y1
4
3
2
1
0
1
2
3
y
2
0
1
2
3
4
5 6 78 9
10
11
0
1
2
3
4
5
6
7
8
9
10
11
0
1
2
3
4
5
6
7
89
10
11
0
1
2
3
4
5
6
87
9 1110
0
1
2
3
4
5
6
7
89
10
11
(b)
Figure 29.5: Samples from the 2d AR-HMM. (a) Time series plot of yt,1 and yt,2. (The latter are shifted up
vertically by 4.7) The background color is the generating state. The dotted lines represent the stationary value
for that component of the observation. (b) Scatter plot of observations. Colors denote the generating state.
We show the first 12 samples from each state. Generated by hmm_ar.ipynb.
particular, note that the likelihood per state can be rewritten as follows:
p(yt|zt = j) = p(zt = j|yt)p(yt)
p(zt = j)
∝
p(zt = j|yt)
p(zt = j)
(29.17)
where we have dropped the p(yt) term since it is independent of the state zt. Here p(zt = j|yt) is
the output of a classifier, and p(zt = j) is the probability of being in state j, which can be computed
from the stationary distribution of the Markov chain (or empirically, if the state sequence is known).
We can thus use discriminative classifiers to define the likelihood function when using gradient-based
training. This is called the scaled likelihood trick [BM93; Ren+94]. [Guo+14] used this to create
a hybrid CNN-HMM model for estimatng sequences of digits based on street signs.
29.3 HMMs: applications
In this section, we discuss some applications of HMMs.
29.3.1 Time series segmentation
In this section, we give a variant of the casino example from Section 9.2.1.1, where our goal is to
segment a time series into different regimes, each of which corresponds to a different statistical
distribution. In Figure 29.6a we show the data, corresponding to counts generated from some process
(e.g., visits to a web site, or number of infections). We see that the count rate seems to be roughly
constant for a while, and then changes at certain points. We would like to segment this data stream
into K different regimes or states, each of which is associated with a Poisson observation model with
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.3. HMMS: APPLICATIONS
0 10 20 30 40 50 60 70
0
10
20
30
40
50
60
70
(a)
0 10 20 30 40 50 60 70
time
0
10
20
30
40
50
60
70
latent rate
Inferred latent rate over time
(b)
Figure 29.6: (a) A sample time series dataset of counts. (b) A segmentation of this data using a 4 state
HMM. Generated by poisson_hmm_changepoint.ipynb.
0 20 40 60
time
0
20
40
60
latent rate
1-state model
inferred rate
observed counts
0 20 40 60
time
0
20
40
60
latent rate
2-state model
inferred rate
observed counts
0 20 40 60
time
0
20
40
60
latent rate
3-state model
inferred rate
observed counts
0 20 40 60
time
0
20
40
60
latent rate
4-state model
inferred rate
observed counts
0 20 40 60
time
0
20
40
60
latent rate
5-state model
inferred rate
observed counts
0 20 40 60
time
0
20
40
60
latent rate
6-state model
inferred rate
observed counts
Figure 29.7: Segmentation of the time series using HMMs with 1–6 states. Generated by pois￾son_hmm_changepoint.ipynb.
rate λk:
p(yt|zt = k) = Poi(yt|λk) (29.18)
We use a uniform prior over the initial states. For the transition matrix, we assume the Markov
chain stays in the same state with probability p = 0.95, and otherwise transitions to one of the other
K − 1 states uniformly at random:
z1 ∼ Categorical 1
4
,
1
4
,
1
4
,
1
4
 (29.19)
zt|zt−1 ∼ Categorical  p if zt = zt−1
1−p
4−1
otherwise  (29.20)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license976
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
1 2 3 4 5 6
number of latent states
400
375
350
325
300
275
250
225
200
marginal likelihood 
p
(
x
)
Model selection on latent states
Figure 29.8: Marginal likelihood vs number of states K in the Poisson HMM. Generated by pois￾son_hmm_changepoint.ipynb.
We compute a MAP estimate for the parameters λ1:K using a log-Normal(5,5) prior. We optimize
the log of the Poisson rates using gradient descent, initializing the parameters at a random value
centered on the log of the overall count means. We show the results in Figure 29.6b. See that the
method has successfully partitioned the data into 4 regimes, which is in fact how it was generated.
(The generating rates are λ = (40, 3, 20, 50), with the changepoints happening at times (10, 30, 35).)
In general we don’t know the optimal number of states K. To solve this, we can fit many different
models, as shown in Figure 29.7, for K = 1 : 6. We see that after K ≥ 3, the model fits are very
similar, since multiple states get associated to the same regime. We can pick the “best” K to be the
one with the highest marginal likelihood. Rather than summing over both discrete latent states and
integrating over the unknown parameters λ, we just maximize over the parameters (empirical Bayes
approximation):
p(y1:T |K) ≈ max
λ
X
z
p(y1:T , z1:T |λ, K) (29.21)
We show this plot in Figure 29.8. We see the peak is at K = 3 or K = 4; after that it starts to go
down, due to the Bayesian Occam’s razor effect.
29.3.2 Protein sequence alignment
An important application of HMMs is to the problem of protein sequence alignment [Dur+98].
Here the goal is to determine if a test sequence y1:T belongs to a protein family or not, and if so,
how it aligns with the canonical representation of that family. (Similar methods can be used to align
DNA and RNA sequences.)
To solve the alignment problem, let us initially assume we have a set of aligned sequences from
a protein family, from which we can generate a consensus sequence. This defines a probability
distribution over symbols at each location t in the string; denote each position-specific scoring
matrix (PSSM) by θt(v) = p(yt = v). These parameters can be estimated by counting.
Now we turn the PSSM into an HMM with 3 hidden states, representing the events that the
location t matches the consensus sequence, zt = M, or inserts its own unique symbol, zt = I, or
deletes (skips) the corresponding consensus symbol, zt = D. We define the observation models for
these 3 events as follows. For matches, we use the PSSM p(yt = v|zt = M) = θt(v). For insertions
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.3. HMMS: APPLICATIONS
M
0
Begin MMM End
IIII
D D D
0 2 1 3 4
Figure 29.9: State transition diagram for a profile HMM. From Figure 5.7 of [Dur+98]. Used with kind
permission of Richard Durbin.
Figure 29.10: Example of multiple sequence alignment. We show the first 90 positions of the acidic ribosomal
protein P0 from several organisms. Colors represent functional properties of the corresponding amino acid.
Dashes represent insertions or deletions. From https: // en. wikipedia. org/ wiki/ Multiple_ sequence_
alignment . Used with kind permission of Wikipedia author Miguel Andrade.
we use the uniform distribution p(yt = v|zt = I) = 1/V , where V is the size of the vocabulary. For
deletions, we use p(yt = −|zt = D), where “-” is a special deletion symbol used to pad the generated
sequence to the correct length. The corresponding state transition matrix is shown in Figure 29.9:
we see that matches and deletions advance one location along the consensus sequence, but insertions
stay in the same location (represented by the self-transition from I to I). This model is known as a
profile HMM.
Given a profile HMM with consensus parameters θ, we can compute p(y1:T |θ) in O(T) time using
the forwards algorithm, as described in Section 9.2.2. This can be used to decide if the sequence
belongs to this family or not, by thresholding the log-odds score, L(y) = log p(y|θ)/p(y|M0), where
M0 is a baseline model, such as the uniform distribution. If the string matches, we can compute an
alignment to the consensus using the Viterbi algorithm, as described in Section 9.2.6. See Figure 29.10
for an illustration of such a multiple sequence alignment. If we don’t have an initial set of aligned
sequences from which to compute the consensus sequence θ, we can use the Baum-Welch algorithm
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license978
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(Section 29.4.1) to compute the MLE for the parameters θ from a set of unaligned sequences. For
details, see e.g., [Dur+98, Ch.6].
29.3.3 Spelling correction
In this section, we illustrate how to use an HMM for spelling correction. The goal is to infer the
sequence of words z1:T that the user meant to type, given observations of what they actually did
type, y1:T .
29.3.3.1 Baseline model
We start by using a simple unigram language model, so p(z1:T ) = Q
1:T
p(zt), where p(zt = k) is the
prior probability of word k being used. These probabilities can be estimated by simply normalizing
word frequency counts from a large training corpus. We ignore any Markov structure.
Now we turn to the observation model, p(yt = v|zt = k), which is the probability the user types
word v when they meant to type word k. For this, we use a noisy channel model, in which the
“message” zt gets corrupted by one of four kinds of error: substitution error, where we swap one
letter for another (e.g., “government” mistyped as “govermment”); transposition errors, where we
swap the order of two adjacent letters (e.g., “government” mistyped as “govermnent”); deletion errors,
where we omit one letter (e.g., “government” mistyped as “goverment”); and insertion errors, where
we add an extra latter (e.g., “government” mistyped as “governmennt”). If y differs from z by d such
errors, we say that y and z have an edit distance of d. Let D(y, d) be the set of words that are edit
distance d away from y. We can then define the following likelihood function:
p(y|z) =



p1 y = z
p2 y ∈ D(z, 1)
p3 y ∈ D(z, 2)
p4 otherwise
(29.22)
where p1 > p2 > p3 > p4.
We can combine the likelihood with the prior to get the overall score for each hypothesis (i.e.,
candidate correction). This simple model, which was proposed by Peter Norvig1
, can work can quite
well. However, it also has some flaws. For example, the error model assumes that the smaller the edit
distance, the more likely the word, but this is not always valid. For example, “reciet” gets corrected
to “recite” instead of “receipt”, and “adres” gets corrected to “acres” not “address”. We can fix this
problem by learning the parameters of the noise model based on a labeled corpus of (z, x) pairs
derived from actual spelling errors. One possible way to get such a corpus is to look at web search
behavior: if a user types query q1 and then quickly changes it to q2 followed by a click on a link, it
suggests that q2 is a manual correction for q1, so we can set (z = q2, y = q1). This heuristic has been
used in the Etsy search engine.2
It is also possible to manually collect such data (see e.g., [Hag+17]),
or to algorithmically create (z, y) pairs, where y is an automatically generated misspelling of z (see
e.g., [ECM18]).
1. See his excellent tutorial at http://norvig.com/spell-correct.html.
2. See this blogpost by Mohit Nayyar for details: https://codeascraft.com/2017/05/01/
modeling-spelling-correction-for-search-at-etsy/.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.3. HMMS: APPLICATIONS
Figure 29.11: Illustration of an HMM applied to spelling correction. The top row, labeled “query”, represents
the search query y1:T typed by the user, namely ”goverment home page of illinoisstate”. The bottom row,
labeled “state path”, represents the most probable assignment to the hidden states, z1:T , namely ”government
homepage of illinois state”. (The NULL state is a silent state, that is needed to handle the generation of two
tokens from a single hidden state.) The middle row, labeled “emission”, represents the words emitted by each
state, which match the observed data. From Figure 1 of [LDZ11].
29.3.3.2 HMM model
The baseline model can work well, but has room for improvement. In particular, many errors will
be hard to correct without context. For example, suppose the user typed “advice”: did they mean
“advice” or “advise”? It depends on whether they intended to use a noun or a verb, which is hard
to tell without looking at the sequence of words. To do this, we will “upgrade” our model to an
HMM. We just have to replace our independence prior p(z1:T ) = Q
t
p(zt) by a standard first-order
language model on words, p(z1:T ) = Q
t
p(zt|zt−1). The parameters of this model can be estimated
by counting bigrams in a large corpus of “clean” text (see Section 2.6.3.1). The observation model
p(yt|zt) can remain unchanged.
Given this model, we can compute the top N most likely hidden sequences in O(NTK2
) time,
where K is the number of hidden states, and T is the length of the sequence, as explained in
Section 9.2.6.5. In a naive implementation, the number of hidden states K is the number of words in
the vocabulary, which would make the method very slow. However, we can exploit sparsity of the
likelihood function (i.e., the fact that p(y|z) is 0 for most values of z) to generate small candidate
lists of hidden states for each location in the sequence. This gives us a sparse belief state vector αt.
29.3.3.3 Extended HMM model
We can extend the HMM model to handle higher level errors, in addition to misspellings of individual
words. In particular, [LDZ11; LDZ12] proposed modeling the following kinds of errors:
• Two words merged into one, e.g., “home page” → “homepage”.
• One word split into two, e.g., “illinoisstate” → “illinois state”.
• Within-word errors, such as substitution, transposition, insertion and deletion of letters, as we
discussed in Section 29.3.3.2.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license980
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We can model this with an HMM, where we augment the state space with a silent state, that
does not emit any symbols. Figure 29.11 illustrates how this model can “denoise” the observed query
”goverment home page of illinoisstate” into the correctly formulated query ”government homepage of
illinois state”.
An alternative to using HMMs is to use supervised learning to fit a sequence-to-sequence translation
model, using RNNs or transformers. This can work very well, but often needs much more training
data, which can be problematic for low-resource languages [ECM18].
29.4 HMMs: parameter learning
In this section, we discuss how to compute a point estimate or the full posterior over the model
parameters of an HMM given a set of partially observed sequences.
29.4.1 The Baum-Welch (EM) algorithm
In this section, we discuss how to compute an approximate MLE for the parameters of an HMM
using the EM algorithm which is an iterative bound optimization algorithm (see Section 6.5.3 for
details). When applied to HMMs, the resulting method is known as the Baum-Welch algorithm
[Bau+70].
29.4.1.1 Log likelihood
The joint probability of a single sequence is given by
p(y1:T , z1:T |θ) = [p(z1|π)] "Y
T
t=2
p(zt|zt−1, A)
# "Y
T
t=1
p(yt|zt, B)
#
(29.23)
=
"Y
K
k=1
π
I(z1=k)
k
# 

Y
T
t=2
Y
K
j=1
Y
K
k=1
A
I(zt−1=j,zt=k)
jk


"Y
T
t=1
Y
K
k=1
p(yt|Bk)
I(zt=k)
#
(29.24)
where θ = (π, A, B). Of course, we cannot compute this objective, since z1:T is hidden. So instead
we will optimize the expected complete data log likelihood, where expectations are taken using the
parameters from the previous iteration of the algorithm:
Q(θ, θ
old) = Ep(z1:T |y1:T ,θold)
[log p(y1:T , z1:T |θ)] (29.25)
This can be easily summed over N sequences. See Figure 29.12 for the graphical model.
The above objective is a lower bound on the observed data log likelihood, log p(y1:T |θ), so the
entire procedure is a bound optimization method that is guaranteed to converge to a local optimum.
(In fact, if suitably initialized, the method can be shown to converge to (close to) one of the global
optima [YBW15].)
29.4.1.2 E step
Let Ajk = p(zt = k|zt−1 = j) be the K × K transition matrix. For the first time slice, let
πk = p(z1 = k) be the initial state distribution. Let θk represent the parameters of the observation
model for state k.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.4. HMMS: PARAMETER LEARNING
N
yn,1 yn,2 yn,Tn
zn,1 zn,2 zn,Tn
B
π A
b b b
b b b
Figure 29.12: HMM with plate notation. A are the parameters for the state transition matrix p(zt|zt−1) and
B are the parameters for the discrete observation model p(xt|zt). Tn is the length of the n’th sequence.
To compute the expected sufficient statistics, we first run the forwards-backwards algorithm on
each sequence (see Section 9.2.3). This returns the following node and edge marginals:
γn,t(j) , p(zt = j|yn,1:Tn
, θ
old) (29.26)
ξn,t(j, k) , p(zt−1 = j, zt = k|yn,1:Tn
, θ
old) (29.27)
where Tn is the length of sequence n. We can then derive the expected counts as follows (note that we
pool the sufficient statistics across time, since the parameters are tied, as well as across sequences):
E

N
1
k

=
X
N
n=1
γn,1(k), E [Nk] = X
N
n=1
X
Tn
t=2
γn,t(k), E [Njk] = X
N
n=1
X
Tn
t=2
ξn,t(j, k) (29.28)
Given the above quantities, we can compute the expected complete data log likelihood as follows:
Q(θ, θ
old) = X
K
k=1
E

N
1
k

log πk +
X
K
j=1
X
K
k=1
E [Njk] log Ajk
+
X
N
n=1
X
Tn
t=1
X
K
k=1
p(zt = k|yn,1:Tn
, θ
old) log p(yn,t|θk) (29.29)
29.4.1.3 M step
We can estimate the transition matrix and initial state probabilities by maximizing the objective
subject to the sum to one constraint. The result is just a normalized version of the expected counts:
Aˆ
jk =
E [Njk]
P
k′ E [Njk′ ]
, πˆk =
E

N1
k

N
(29.30)
This result is quite intuitive: we simply add up the expected number of transitions from j to k, and
divide by the expected number of times we transition from j to anything else.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license982
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
For a categorical observation model, the expected sufficient statistics are
E [Mkv] = X
N
n=1
X
Tn
t=1
γn,t(k)I(yn,t = v) = X
N
n=1
X
t:yn,t=v
γn,t(k) (29.31)
The M step has the form
Bˆ
kv =
E [Mkv]
E [Nk]
(29.32)
This result is quite intuitive: we simply add up the expected number of times we are in state k and
we see a symbol v, and divide by the expected number of times we are in state k. See Algorithm 11
for the pseudocode.
For a Gaussian observation model, the expected sufficient statistics are given by
yk =
X
N
n=1
X
Tn
t=1
γn,t(k)yn,t, yyT
k =
X
N
n=1
X
Tn
t=1
γn,t(k)yn,ty
T
n,t (29.33)
The M step becomes
µˆk =
yk
E [Nk]
(29.34)
Σˆ
k =
yyT
k − E [Nk] µˆkµˆ
T
k
E [Nk]
(29.35)
In practice, we often need to add a log prior to these estimates to ensure the resulting Σˆ
k estimate is
well-conditioned. See [Mur22, Sec 4.5.2] for details.
Algorithm 29.1: Baum-Welch algorithm for (discrete observation) HMMs
1 Initialize parameters θ
2 for each iteration do
3 // E step
4 Initialize expected counts: E [Nk] = 0, E [Njk] = 0, E [Mkv] = 0
5 for each datacase n do
6 Use forwards-backwards algorithm on yn to compute γn,t and ξn,t
(Equations 29.26–29.27)
7 E [Nk] := E [Nk] +
PTn
t=2 γn,t(k)
8 E [Njk] := E [Njk] + PTn
t=2 ξn,t(j, k)
9 E [Mkv] := E [Mkv] + P
t:xn,t=v
γn,t(k)
10 // M step
11 Compute new parameters θ = (A, B,π) using Equations 29.30
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.4. HMMS: PARAMETER LEARNING
State 1
Obs 1 0.17
Obs 2 0.17
Obs 3 0.17
Obs 4 0.17
Obs 5 0.17
Obs 6 0.17
0.95
State 2
Obs 1 0.10
Obs 2 0.10
Obs 3 0.10
Obs 4 0.10
Obs 5 0.10
Obs 6 0.50
0.05
0.10
0.90
(a)
State 1
Obs 1 0.10
Obs 2 0.11
Obs 3 0.10
Obs 4 0.11
Obs 5 0.09
Obs 6 0.50
0.91
State 2
Obs 1 0.16
Obs 2 0.17
Obs 3 0.16
Obs 4 0.17
Obs 5 0.17
Obs 6 0.16
0.09
0.05
0.95
(b)
State 1
Obs 1 0.09
Obs 2 0.11
Obs 3 0.10
Obs 4 0.10
Obs 5 0.09
Obs 6 0.51
0.92
State 2
Obs 1 0.16
Obs 2 0.17
Obs 3 0.17
Obs 4 0.17
Obs 5 0.16
Obs 6 0.16
0.08
0.05
0.95
(c)
Figure 29.13: Illustration of the casino HMM. (a) True parameters used to generate the data. (b) Estimated
parameters using EM. (c) Estimated parameters using SGD. Generated by casino_hmm_training.ipynb.
29.4.1.4 Initialization
As usual with EM, we must take care to ensure that we initialize the parameters carefully, to minimize
the chance of getting stuck in poor local optima. There are several ways to do this, such as:
• Use some fully labeled data to initialize the parameters.
• Initially ignore the Markov dependencies, and estimate the observation parameters using the
standard mixture model estimation methods, such as K-means or EM.
• Randomly initialize the parameters, use multiple restarts, and pick the best solution.
Techniques such as deterministic annealing [UN98; RR01a] can help mitigate the effect of local
minima. Also, just as K-means is often used to initialize EM for GMMs, so it is common to initialize
EM for HMMs using Viterbi training. The Viterbi algorithm is explained in Section 9.2.6, but
basically it is an algorithm to compute the single most probable path. As an approximation to
the E step, we can replace the sum over paths with the statistics computed using this single path.
Sometimes this can give better results [AG11].
29.4.1.5 Example: casino HMM
In this section, we fit the casino HMM from Section 9.2.1.1. The true generative model is shown in
Figure 29.13a. We used this to generate 4 sequences of length 5000, totalling 20,000 observations.
We initialized the model with random parameters. We ran EM for 200 iterations and got the results
in Figure 29.13b. We see that the learned parameters are close to the true parameters, modulo label
switching of the states, due to unidentifiability.
29.4.2 Parameter estimation using SGD
Although the EM algorithm is the “traditional” way to fit HMMs, it is inherently a batch algorithm,
so it does not scale well to large datasets (with many sequences). Although it is possible to extend
bound optimization to the online case (see e.g., [Mai15]), this can take a lot of memory.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license984
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0 25 50 75 100 125 150 175 200
1.75
1.80
1.85
1.90
1.95
EM Algorithm
(a)
0 25 50 75 100 125 150 175 200
1.75
1.80
1.85
1.90
1.95
Stochastic Gradient Descent
(b)
0 25 50 75 100 125 150 175 200
1.75
1.80
1.85
1.90
1.95
Full Batch Gradient Descent
(c)
Figure 29.14: Average negative log likelihood per learning step the casino HMM. (a) EM. (b) SGD with
minibatch size 1. (b) Full batch gradient descent. Generated by casino_hmm_training.ipynb.
A simple alternative is to optimize log p(y1:T |θ) using SGD. We can compute this objective using
the forwards algorithm, as shown in Equation (8.7):
log p(y1:T |θ) = X
T
t=1
log p(yt|y1:t−1, θ) = X
T
t=1
log Zt (29.36)
where the normalization constant for each time step is given by
Zt , p(yt|y1:t−1) = X
K
j=1
p(zt = j|y1:t−1)p(yt|zt = j) (29.37)
Of course, we need to ensure the transition matrix remains a valid row stochastic matrix, i.e., that
0 ≤ Aij ≤ 1 and P
j Aij = 1. Similarly, if we have categorical observations, we need to ensure Bjk
is a valid row stochastic matrix, and if we have Gaussian observations, we need to ensure Σk is a
valid psd matrix. These constraints are automatically taken care of in EM. When using SGD, we can
reparameterize to an unconstrained form, as proposed in [BC94].
29.4.2.1 Example: casino HMM
In this section, we use SGD to fit the casino HMM using the same data as in Section 29.4.1.5. We
show the learning the learning curves in Figure 29.14. We see that SGD converges slightly more
slowly than EM, and is not monotonic in how it decreases the NLL loss, even in the full batch case.
However, the final parameters are similar, as shown in Figure 29.13.
29.4.3 Parameter estimation using spectral methods
Fitting HMMs using maximum likelihood is difficult, because the log likelihood is not convex. Thus
there are many local optima, and EM and SGD can give poor results. An alternative approach is to
marginalize out the hidden variables, and work instead with predictive distributions in the visible
space. For discrete observation HMMs, with observation matrix Bjk = p(yt = k|zt = j), such a
distribution has the form
[yt]k , p(yt = k|y1:t−1) (29.38)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.4. HMMS: PARAMETER LEARNING
This is called a predictive state representation [SJR04].
Suppose there are m possible hidden states, and n possible visible symbols, where n ≥ m. One can
show [HKZ12; Joh12] that the PSR vectors lie in a subspace in R
n with a dimensionality of m ≤ n.
Intuitively this is because the linear operator A defining the hidden state update in Equation (9.8),
combined with the mapping to observables via B, induces low rank structure in the output space.
Furthermore, we can estimate a basis for this low rank subspace using SVD applied to the observable
matrix of co-occurrence counts:
[P2]ij = p(yt = i, yt−1 = j) (29.39)
We also need to estimate the third order statistics
[P3]ijk = p(yt = i, yt−1 = j, yt−2 = k) (29.40)
Using these quantities, it possible to perform recursive updating of our predictions while working
entirely in visible space. This is called spectral estimation, or tensor decomposition [HKZ12;
AHK12; Rod14; Ana+14; RSG17].
We can use spectral methods to get a good initial estimate of the parameters for the latent variable
model, which can then be refined using EM (see e.g., [Smi+00]). Alternatively, we can use them “as
is”, without needing EM at all. See [Mat14] for a comparison of these methods. See also Section 29.8.2
where we discuss spectral methods for fitting linear dynamical systems.
29.4.4 Bayesian HMMs
MLE methods can easily overfit, and can suffer from numerical problems, especially when sample
sizes are small. In this section, we briefly discuss some approaches to inferring the posterior over
the parameters, p(θ|D). By adopting a Bayesian approach, we can also allow the number of states
to be unbounded by using a hierarchical Dirichlet process (Supplementary Section 31.1) to get a
HDP-HMM [Fox+08].
There are various algorithms we can use to perform posterior inference, such as variational Bayes
EM [Bea03] or blocked Gibbs sampling (see Section 29.4.4.1), that alternates between sampling
latent sequences z
s
1:T ,1:N using the forwards filtering backwards sampling algorithm (Section 9.2.7)
and sampling the parameters from their full conditionals, p(θ|y1:T , z
s
1:T ,1:N ). Unfortuntely, the high
correlation between z and θ makes this coordinate-wise approach rather slow.
A faster approach is to marginalize out the discrete latents (using the forwards algorithm), and
then to use MCMC [Fot+14] or SVI [Obe+19] to sample from the following log posterior:
log p(θ, D) = log p(θ) + X
N
n=1
log p(y1:T ,n|θ) (29.41)
This is a form of “collapsed” inference.
29.4.4.1 Blocked Gibbs sampling for HMMs
This section is written by Xinglong Li.
In this section, we discuss Bayesian inference for HMMs using blocked Gibbs sampling [Sco02].
For the observation model, we consider the first-order auto-regressive HMM model in Section 29.2.5,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license986
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
so p(yt|yt−1, zt = j, θ) = N (yt|Ejyt−1 + µj
, Σj ). For a model with K hidden states, the unknown
parameters are θ = {π, A, E1, . . . , EK, Σ1, . . . , ΣK}, where we assume (for notational simplicity)
that µj of each autoregressive model is known, and that we condition the observations on y1.
We alternate between sampling from p(z1:T |y1:T , θ) using the forwards filtering backwards sampling
algorithm (Section 9.2.7), and sampling from p(θ|z1:T , y1:T ). Sampling from p(θ|z1:T , y1:T ) is easy
if we use conjugate priors. Here we use a Dirichlet prior for π and each row Aj· of the transition
matrix, and choose the matrix normal inverse Wishart distribution as the prior for {Ej , Σj} of each
autoregressive model, similar to Bayesian multivariate linear regression Section 15.2.9. In particular,
the prior distributions of θ are:
π ∼ Dir(`απ) Aj· ∼ Dir(`αA) (29.42)
Σj ∼ IW(`νj ,
`
Ψj ) Ej |Σj ∼ MN (
`Mj , Σj ,
`
Vj ) (29.43)
where `απ,k=
`απ /K and `αA,k=
`αA /K. The log prior probability is
log p(θ) =c +
X
K
k=1
`απ
K
log πk +
X
K
j=1
X
K
k=1
`αA
K
log Ajk −
X
K
j=1
 `νj +Ny + 1
2
log|Σj | +
1
2
tr  `
Ψj Σ
−1
j

−
X
K
j=1

1
2
log|Σj | +
1
2
tr((Ej−
`Mj )
TΣ
−1
j
(Ej−
`Mj )
`
Vj )

(29.44)
Given y1:T and z1:T we denote Nj =
PT
t=2 I(zt = j) and Njk =
PT −1
t=1 I(zt = j, zt+1 = k). The
joint likelihood is
log p(y1:T , z1:T |θ) = c +
X
K
k=1
I(z1 = k) log πk +
X
K
j=1
X
K
k=1
Njk log Ajk
−
X
K
j=1
X
zt=j

1
2
log|Σj | +
1
2
(yt − Ejyt−1 − µj
)
TΣ
−1
j
(yt − Ejyt−1 − µj
)

(29.45)
= c +
X
K
k=1
I(z1 = k) log πk +
X
K
j=1
X
K
k=1
Njk log Ajk
−
X
K
j=1

Nj
2
log|Σj | +
1
2
(Yˆ
j − EjY˜
j )
TΣ
−1
j
(Yˆ
j − EjY˜
j )

(29.46)
where Yˆ
j = [yt−µj
]zt=j and Y˜
j = [yt−1]zt=j , and it can be seen that Yˆ
j ∼ MN 
Yˆ
j |EjY˜
j , Σj , INj

.
It is obvious from log p(θ) + log p(y1:T , z1:T |θ) that the posteriors of π and Aj· are both still
Dirichlet distributions. It can also be shown that the posterior distributions of {Ej , Σj} are still
matrix normal inverse Wishart distributions, whose hyperparameters can be directly obtained by
replacing Y, A, X in Equation (15.105) with Yˆ
j , Ej and Y˜
j respectively. To summarize, the posterior
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.5. HMMS: GENERALIZATIONS
1 2 3 4
1 − p 1 − p 1 − p
p p p p
(a)
0 200 400 600
0.0000
0.0025
0.0050
0.0075
0.0100 n = 1
n = 2
n = 5
(b)
Figure 29.15: (a) A Markov chain with n = 4 repeated states and self loops. (b) The resulting distribution
over sequence lengths, for p = 0.99 and various n. Generated by hmm_self_loop_dist.ipynb.
distribution p(θ|z1:T , y1:T ) is:
π|z1:T ∼ Dir(aαπ),
aαπ,k =
`απ /K + I(z1 = k) (29.47)
Aj·
|z1:T ∼ Dir(aαA),
aαAj ,k =
`αA /K + Njk (29.48)
Σj |z1:T , y1:T ∼ IW(aνj ,
a
Ψj ) Ej |Σj , z1:T , y1:T ∼ MN (
aMj , Σj ,
a
Vj ) (29.49)
29.5 HMMs: generalizations
In this section, we discuss various extensions of the vanilla HMM introduced in Section 29.2.
29.5.1 Hidden semi-Markov model (HSMM)
In a standard HMM (Section 29.2), the probability we remain in state i for exactly d steps is
p(di = d) = (1 − Aii)A
d
ii ∝ exp(d log Aii) (29.50)
where Aii is the self-loop probability. This is called the geometric distribution. However, this
kind of exponentially decaying function of d is sometimes unrealistic.
A simple way to model non-geometric waiting times is to replace each state with n new states,
each with the same emission probabilities as the original state. For example, consider the model in
Figure 29.15(a). Obviously the smallest sequence this can generate is of length n = 4. Any path
of length d through the model has probability p
d−n(1 − p)
n; multiplying by the number of possible
paths we find that the total probability of a path of length d is
p(d) = 
d − 1
n − 1

p
d−n
(1 − p)
n
(29.51)
This is equivalent to the negative binomial distribution. By adjusting n and the self-loop probabilities
p of each state, we can model a wide range of waiting times: see Figure 29.15(b).
A more general solution is to use a semi-Markov model, in which the next state not only depends
on the previous state, but also on how how long we’ve been in that state. When the state-space is
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license988
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
dt−1 dt dt+1
zt−1 zt zt+1
yt−1 yt yt+1
(a)
d1 = 3 d2 = 2 d3 = 1 d4 = 2 d5 = 1
z1 z2 z3 z4 z5
y1 y2 y3 y4 y5
(b)
Figure 29.16: Encoding a hidden semi-Markov model as a DPGM. (a) dt is a deterministic down counter
(duration variable). Each observation is generated independently. (b) Similar to (a), except now we generate
the observations within each segment as a block. In this figure, we represent the non-Markovian dependencies
between the observations within each segment by using undirected edges. We represent the conditional
independence between the observations across different segments by disconnecting y1:3 from y4:5; this can be
enforced by “breaking the link” whenever dt = 1 (representing the end of a segment).
not observed directly, the result is called a hidden semi-Markov model (HSMM), a variable
duration HMM, or an explicit duration HMM [Yu10].
One way to represent a HSMM is to use the graphical model shown in Figure 29.16(a). The
dt ∈ {1, . . . , D} node is a state duration counter, where D is the maximum duration of any state.
When we first enter state j, we sample dt from the duration distribution for that state, dt ∼ pj (·).
Thereafter, dt deterministically counts down until dt = 1. More precisely, we define the following
CPD:
p(dt = d
′
|dt−1 = d, zt = j) =



Dj (d
′
) if d = 1
1 if d
′ = d − 1 and d > 1
0 otherwise
(29.52)
Note that Dj (d) could be represented as a table (a non-parametric approach) or as some kind
of parametric distribution, such as a gamma distribution. If Dj (d) is a (truncated) geometric
distribution, this emulates a standard HMM.
While dt > 1, the state zt is not allowed to change. When dt = 1, we make a stochastic transition
to a new state. (We assume Ajj = 0.) More precisely, we define the state CPD as follows:
p(zt = k|zt−1 = j, dt−1 = d) =



1 if d > 0 and j = k
Ajk if d = 1
0 otherwise
(29.53)
This ensures that the model stays in the same state for the entire duration of the segment. At each
step within this segment, an observation is generated.
HSMMs are useful not only because they can model the duration of each state explicitly, but also
because they can model the distribution of a whole subsequence of observations at once, instead
of assuming all observations are generated independently at each time step. That is, they can use
likelihood models of the form p(yt:t+l−1|zt = k, dt = l), which generate l correlated observations if
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.5. HMMS: GENERALIZATIONS
the duration in state k is for l time steps. This approach, known as a segmental HMM, is useful
for modeling data that is piecewise linear, or shows other local trends [ODK96]. We can also use an
RNN to model each segment, resulting in an RNN-HSMM model [Dai+17].
More precisely, we can define a segmental HMM as follows:
p(y, z, d) = "
p(z1)p(d1|z1)
Y
T
t=2
p(zt|zt−1, dt−1)p(dt|zt, dt−1)
#
p(y|z, d) (29.54)
In a standard HSMM, we assume
p(y|z, d) = Y
T
t=1
p(yt|zt) (29.55)
so the duration variables only determine the hidden state dynamics. To define p(y|z, d) for a
segmental HMM, let us use si and ei to denote the start and end times of segment i. This sequence
can be computed deterministically from d using s1 = 1, si = si−1 + dsi−1
, and ei = si + dsi − 1. We
now define the observation model as follows:
p(y|z, d) = Y
|s|
i=1
p(ysi:ei
|zsi
, dsi
) (29.56)
See Figure 29.16(b) for the DPGM.
If we use an RNN for each segment, we have
p(ysi:ei
|zsi
, dsi
) = Yei
t=si
p(yt|ysi:t−1, zsi
) = Yei
t=si
p(yt|ht, zsi
) (29.57)
where ht is the hidden state that is deterministically updated given the previous observations in this
sequence.
As shown in [Chi14], it is possible to compute p(zt, dt|y1:T ) in O(TK2 + TKD) time, where T is
the sequence length, K is the number of states, and D is the maximum duration of any segment.
In [Dai+17], they show how to train an approximate inference algorithm, based on a mean field
approximation q(z, d|y) = Q
t
q(zt|y)q(dt|y), to compute the posterior in O(TK + T D) time.
29.5.2 Hierarchical HMMs
A hierarchical HMM (HHMM) [FST98] is an extension of the HMM that is designed to model
domains with hierarchical structure. Figure 29.17 gives an example of an HHMM used in automatic
speech recognition, where words are composed of phones which are composed of subphones. We
can always “flatten” an HHMM to a regular HMM, but a factored representation is often easier to
interpret, and allows for more efficient inference and model fitting.
HHMMs have been used in many application domains, e.g., speech recognition [Bil01], gene finding
[Hu+00], plan recognition [BVW02], monitoring transportation patterns [Lia+07], indoor robot
localization [TMK04], etc. HHMMs are less expressive than stochastic context free grammars (SCFGs)
since they only allow hierarchies of bounded depth, but they support more efficient inference. In
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license990
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
on
aa n n iy d dh ax
n iy
words
phones
sub-phones
need the
end end
end
end end
Figure 29.17: An example of an HHMM for an ASR system which can recognize 3 words. The top level
represents bigram word probabilities. The middle level represents the phonetic spelling of each word. The
bottom level represents the subphones of each phone. (It is traditional to represent a phone as a 3 state HMM,
representing the beginning, middle and end; these are known as subphones.) Adapted from Figure 7.5 of
[JM00].
F
1
1 F
1
2 F
1
3
Z
1
1 Z
1
2 Z
1
3
F
2
1 F
2
2 F
2
3
Z
2
1 Z
2
2 Z
2
3
F
3
1 F
3
2 F
3
3
Z
3
1 Z
3
2 Z
3
3
Y1 Y2 Y3
Figure 29.18: An HHMM represented as a DPGM. Z
ℓ
t
is the state at time t, level ℓ; F
ℓ
t = 1 if the HMM at
level ℓ has finished (entered its exit state), otherwise F
ℓ
t = 0. Shaded nodes are observed; the remaining nodes
are hidden. We may optionally clamp F
ℓ
T = 1, where T is the length of the observation sequence, to ensure
all models have finished by the end of the sequence. From Figure 2 of [MP01].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.5. HMMS: GENERALIZATIONS
particular, inference in SCFGs (using the inside outside algorithm, [JM08]) takes O(T
3
) whereas
inference in an HHMM takes O(T) time [MP01; WM12].
We can represent an HHMM as a directed graphical model as shown in Figure 29.18. Qℓ
t
represents
the state at time t and level ℓ. A state transition at level ℓ is only “allowed” if the chain at the level
below has “finished”, as determined by the F
ℓ−1
t node. (The chain below finishes when it chooses to
enter its end state.) This mechanism ensures that higher level chains evolve more slowly than lower
level chains, i.e., lower levels are nested within higher levels.
A variable duration HMM can be thought of as a special case of an HHMM, where the top level is
a deterministic counter, and the bottom level is a regular HMM, which can only change states once
the counter has “timed out”. See [MP01] for further details.
29.5.3 Factorial HMMs
An HMM represents the hidden state using a single discrete random variable zt ∈ {1, . . . , K}. To
represent 10 bits of information would require K = 210 = 1024 states. By contrast, consider a
distributed representation of the hidden state, where each zt,m ∈ {0, 1} represents the m’th bit
of the t’th hidden state. Now we can represent 10 bits using just 10 binary variables. This model is
called a factorial HMM [GJ97].
More precisely, the model is defined as follows:
p(z, y) = Y
t
"Y
m
p(ztm|zt−1,m)
#
p(yt|zt) (29.58)
where p(ztm = k|zt−1,m = j) = Amjk is an entry in the transition matrix for chain m, p(z1m =
k|z0m) = p(z1m = k) = πmk, is the initial state distribution for chain m, and
p(yt|zt) = N
 
yt|
X
M
m=1
Wmztm, Σ
!
(29.59)
is the observation model, where ztm is a 1-of-K encoding of ztm and Wm is a D×K matrix (assuming
yt ∈ R
D). Figure 29.19a illustrates the model for the case where M = 3.
An interesting application of FHMMs is to the problem of energy disaggregation [KJ12]. In this
problem, we observe the total energy usage of a house at each moment in time, i.e., the observation
model has the form
p(yt|zt) = N (yt|
X
M
m=1
wmztm, σ2
) (29.60)
where wm is the amount of energy used by device m, and ztm = 1 if device m is being used at time t
and ztm = 0 otherwise. The transition model is assumed to be
p(zt,m = 1|zt−1,m) = (
A01 if zt−1,m = 0
A11 if zt−1,m = 1
(29.61)
We do not know which devices are turned on at each time step (i.e., the ztm are hidden), but by
applying inference in the FHMM over time, we can separate the total energy into its parts, and
thereby determine which devices are using the most electricity.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license992
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
x1 x2 x3
z3,1 z3,2 z3,3
z2,1 z2,2 z2,3
z1,1 z1,2 z1,3
(a)
y31 y32 y33
z31 z32 z33
y21 y22 y23
z21 z22 z23
y11 y12 y13
z11 z12 z13
(b)
Figure 29.19: (a) A factorial HMM with 3 chains. (b) A coupled HMM with 3 chains.
Unfortunately, conditioned on yt, all the hidden variables are correlated (due to explaining away
the common observed child yt). This make exact state estimation intractable. However, we can
derive efficient approximate inference algorithms, as we discuss in Supplementary Section 10.3.2.
29.5.4 Coupled HMMs
If we have multiple related data streams, we can use a coupled HMM [Bra96]. This is a series of
HMMs where the state transitions depend on the states of neighboring chains. That is, we represent
the conditional distribution for each time slice as
p(zt, yt|zt−1) = Y
m
p(ytm|ztm)p(ztm|zt−1,m−1:m+1) (29.62)
with boundary conditions defined in the obvious way. See Section 29.5.4 for an illustration with
M = 3 chains.
Coupled HMMs have been used for various tasks, such as audio-visual speech recognition
[Nef+02], modeling freeway traffic flows [KM00], and modeling conversational interactions between
people [Bas+01].
However, there are two drawbacks to this model. First, exact inference takes O(T(KM)
2
), as in a
factorial HMM; however, in practice this is not usually a problem, since M is often small. Second,
the model requires O(MK4
) parameters to specify, if there are M chains with K states per chain,
because each state depends on its own past plus the past of its two neighbors. There is a closely
related model, known as the influence model [Asa00], which uses fewer parameters, by computing
a convex combination of pairwise transition matrices.
29.5.5 Dynamic Bayes nets (DBN)
A dynamic Bayesian network (DBN) is a way to represent a stochastic process using a directed
graphical model [Mur02]. (Note that the network is not dynamic (the structure and parameters are
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.5. HMMS: GENERALIZATIONS
14
7
19
17
16
20
23
21
25
27
6
12
13
10
8
4
1
3
28
26
22
24
18
15
11
9
5
2
SensorValid1
FYdotDiff1
FcloseSlow1
Xdot0 Xdot1
InLane0 InLane1
LeftClr0 LeftClr1
RightClr0 RightClr1
LatAction0 LatAction1
FwdAction0 FwdAction1
Ydot0 Ydot1
Stopped0 Stopped1 BXdot1
EngStatus0 EngStatus1 BcloseFast1
FrontBackStatus0 FrontBackStatus1 BYdotDiff1
Fclr1
Bclr1
XdotSens1
YdotSens1
LeftClrSens1
RightClrSens1
TurnSignal1
FYdotDiffSens1
FclrSens1
BXdotSens1
BclrSens1
BYdotDiffSens1
slice t slice t+1 evidence
Figure 29.20: The BATnet DBN. The transient nodes are only shown for the second slice, to minimize clutter.
The dotted lines are used to group related variables. Used with kind permission of Daphne Koller.
fixed), rather it is a network representation of a dynamical system.) A DBN can be considered as a
natural generalization of an HMM.
An example is shown in Figure 29.20, which is a DBN designed to monitor the state of a simulated
autonomous car known as the “Bayesian automated taxi”, or “BATmobile” [For+95]. To define
the model, you just need to specify the structure of the first time-slice, the structure between two
time-slices, and the form of the CPDs. For details, see [KF09a].
29.5.6 Changepoint detection
In this section, we discuss changepoint detection, which is the task of detecting when there are
“abrupt” changes in the distribution of the observed values in a time series. We focus on the online
case. (For a review of offline methods to this problem, see e.g., [AC17; TOV18]. (See also [BW20] for
a recent empirical evaluation of various methods, focused on the 1d time series case.)
The methods we discuss can (in principle) be used for high-dimensional time series segmentation.
Our starting point is the hidden semi-Markov models (HSMM) discussed in Section 29.5.1. This
is like an HMM in which we explicitly model the duration spent in each state. This is done by
augmenting the latent state zt with a duration variable dt which is initialized according to a duration
distribution, dt ∼ Dzt
(·), and which then counts down to 1. An alternative approach is to add a
variable rt{0, 1, . . . , } which encodes the run length for the current state; this starts at 0 whenever a
new segment is created, and then counts up by one at each step. The transition dynamics is specified
by
p(rt|rt−1) =



H(rt−1 + 1) if rt = 0
1 − H(rt−1 + 1) if rt = rt−1 + 1
0 otherwise
(29.63)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license994
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
xt gg g 12 3
(a)
t
r
t
54321 6 7 8 9 10 11 12 13 14
1
2
3
4
0
(b)
Figure 29.21: Illustration of Bayesian online changepoint detection (BOCPD). (a) Hypothetical segmentation
of a univariate time series divided by changepoints on the mean into three segments of lengths g1 = 4, g2 = 6,
and an undetermined length for g3 (since it the third segment has not yet ended). From Figure 1 of [AM07].
Used with kind permission of Ryan Adams.
where H(τ ) is a hazard function:
H(τ ) = pg(τ )
P∞
t=τ
pg(t)
(29.64)
where pg(t) is the probability of a segment of length t. See Figure 29.21 for an illustration. If we
set pg to be a geometric distribution with parameter λ, then the hazard function is the constant
H(τ ) = 1/λ.
The advantage of the run-length representation is that we can define the observation model for a
segment in a causal way (that only depends on past data):
p(yt|y1:t−1, rt = r, zt = k) = p(yt|yt−r:t−1, zt = k) = Z
p(yt|η)p(η|yt−r:t−1, zt = k)dη (29.65)
where η are the parameters that are “local” to this segment. This called the underlying predictive
model or UPM for the segment. The posterior over the UPM parameters is given by
p(η|yt−r:t−1, zt = k) ∝ p(η|zt = k)
tY−1
i=t−r
p(yi
|η) (29.66)
where we initialize the prior for η using hyper-parameters chosen by state k. If the model is conjugate
exponential, we can compute this marginal likelihood in closed form, and we have
π
r,k
t = p(yt|yt−r:t−1, zt = k) = p(yt|ψ
r,k
t
) (29.67)
where ψ
r,k
t are the parameters of the posterior predictive distribution at time t based on the last r
observations (and using a prior from state k).
In the special case in which we have K = 1 hidden states, then each segment is modeled
independently, and we get a product partition model [BH92]:
p(y|r) = p(ys1:e1
). . . p(ysN :eN ) (29.68)
where si and ei are the start and end of segment i, which can be computed from the run lengths r.
(We initialize with r0 = 0.) Thus there is no information sharing between segments. This can be
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.5. HMMS: GENERALIZATIONS
−2.5
0.0
2.5
0 50 100 150
0
1
2
3
(a)
−2.5
0.0
2.5
0 50 100 150 200
0
50
(b)
Figure 29.22: Illustration of BOCPD. (a) Synthetic data from a GMM with 4 states. Top row is the data,
bottom row is the generating state. (b) Output of algorithm. Top row: Estimated changepoint locations. Bottom
row: posterior predicted probability of a changepoint at each step. Generated by changepoint_detection.ipynb.
useful for time series in which there are abrupt changes, and where the new parameters are unrelated
to the old ones.
Detecting the locations of these changes is called changepoint detection. An exact online
algorithm for solving this task was proposed in [FL07] and independently in [AM07]; in the latter
paper, they call the method Bayesian online changepoint detection or BOCPD. We can
compute a posterior over the current run length recursively as follows:
p(rt|y1:t) ∝ p(yt|y1:t−1, rt)p(rt|y1:t−1) (29.69)
where we initialize with p(r0 = 0) = 1. The marginal likelihood p(yt|y1:t−1, rt) is given by Equa￾tion (29.65) (with zt = 1 dropped, since there is just one state). The prior predictive is given by
p(rt|y1:t−1) = X
rt−1
p(rt|rt−1)p(rt−1|y1:t−1) (29.70)
The one step ahead predictive distribution is given by
p(yt+1|y1:t) = X
rt
p(yt+1|y1:t, rt)p(rt|y1:t) (29.71)
29.5.6.1 Example
We give an example of the method in Figure 29.22 applied to a synthetic 1d dataset generated from
a 4 state GMM. The likelihood is a univariate Gaussian, p(yt|µ) = N (yt|µ, σ2
), where σ
2 = 1 is
fixed, and µ is inferred using a Gaussian prior. The hazard function is set to a geometric distribution
with rate N/T, where N = 4 is the true number of change points and T = 200 is the length of the
sequence.
29.5.6.2 Extensions
Although the above method is exact, each update step takes O(t) time, so the total cost of the
algorithm is O(T
2
). We can reduce this by pruning out states with low probability. In particular, we
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license996
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
can use particle filtering (Section 13.2) with N particles, together with a stratified optimal resampling
method, to reduce the cost to O(T N). See [FL07] for details.
In addition, the above method relies on a conjugate exponential model in order to compute the
marginal likelihood, and update the posterior parameters for each r, in O(1) time. For more complex
models, we need to use approximations. In [TBS13], they use variational Bayes (Section 10.3.3), and
in [Mav16], they use particle filtering (Section 13.2), which is more general, but much slower.
It is possible to extend the model in various other ways. In [FL11], they allow for Markov
dependence between the parameters of neighboring segments. In [STR10], they use a Gaussian
process (Chapter 18) to represent the UPM, which captures correlations between observations within
the same segment. In [KJD18], they use generalized Bayesian inference (Section 14.1.3) to create a
method that is more robust to model misspecification.
In [Gol+17], they extend the model by modeling the probability of a sequence of observations,
rather than having to make the decision about whether to insert a changepoint or not based on just
the likelihood ratio of a single time step.
In [AE+20], they extend the model by allowing for multiple discrete states, as in an HSMM. In
addition, they add both the run length rt and the duration dt to the state space. This allows the
method to specify not just when the current segment started, but also when it is expected to end.
In addition, it allows the UPM to depend on the duration of the segment, and not just on past
observations. For example, we can use
p(yt|rt, dt, η) = N (yt|φ(rt/dt)
Tη, σ2
) (29.72)
where 0 ≤ rt/dt ≤ 1, and φ() is a set of learned basis functions. This allows observation sequences
for the same hidden state to have a common functional shape, even if the time spent in each state is
different.
29.6 Linear dynamical systems (LDSs)
In this section, we discuss linear-Gaussian state-space model (LG-SSM), also called linear
dynamical system (LDS). This is a special case of an SSM in which the transition function and
observation function are both linear, and the process noise and observation noise are both Gaussian.
29.6.1 Conditional independence properties
The LDS graphical model is shown in Figure 29.1(a). This encodes the assumption that the hidden
states are Markovian, and the observations are iid conditioned on the hidden states. All that remains
is to specify the form of the conditional probability distributions of each node.
29.6.2 Parameterization
An LDS model is defined as follows:
p(zt|zt−1,ut) = N (zt|Ftzt−1 + Btut + bt, Qt) (29.73)
p(yt|zt,ut) = N (yt|Htzt + Dtut + dt, Rt) (29.74)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.7. LDS: APPLICATIONS
We often assume the bias (offset) terms are zero, in which case the model simplifies to
p(zt|zt−1,ut) = N (zt|Ftzt−1 + Btut, Qt) (29.75)
p(yt|zt,ut) = N (yt|Htzt + Dtut, Rt) (29.76)
Furthermore, if there are no inputs, the model further simplifies to
p(zt|zt−1) = N (zt|Ftzt−1, Qt) (29.77)
p(yt|zt) = N (yt|Htzt, Rt) (29.78)
We can also write this as a structural equation model (Section 4.7.2):
zt = Ftzt−1 + qt (29.79)
yt = Htzt + rt (29.80)
where qt ∼ N (0, Qt) is the process noise, and rt ∼ N (0, Rt) is the observation noise.
Typically we assume the parameters θt = (Ft, Ht, Bt, Dt, Qt, Rt) are independent of time, so the
model is stationary. (We discuss how to learn the parameters in Section 29.8.) Given the parameters,
we discuss how to perform online posterior inference of the latent states using the Kalman filter in
Section 8.2.2, and offline inference using the Kalman smoother in Section 8.2.3.
29.7 LDS: applications
In this section, we discuss some applications of LDS models.
29.7.1 Object tracking and state estimation
Consider an object moving in R
2
. Let the state at time t be the position and velocity of the object,
zt =
￾
ut vt u˙ t v˙t

. (We use u and v for the two coordinates, to avoid confusion with the state and
observation variables.) We assume this evolves in continuous time according to a linear stochastic
differential equation or SDE, in which the dynamics are given by Newton’s law of motion, and
where the random acceleration corresponds to a white noise process (aka Brownian motion).
However, since the observations occur at discrete time steps tk, we will only evaluate the system at
discrete time points; this is called a continuous-discrete SSM [SS19, p199]. (We shall henceforth
write t instead of tk, since in this book we only consider discrete time.) The corresponding discrete
time SSM is given by the following [SS19, p82]:


ut
vt
u˙ t
v˙t


| {z }
zt
=


1 0 ∆ 0
0 1 0 ∆
0 0 1 0
0 0 0 1


| {z }
F


ut−1
vt−1
u˙ t−1
v˙t−1


| {z }
zt−1
+qt (29.81)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens998
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where ∆ is the step size between consecutive discrete measurement times, qt ∼ N (0, Q) is the process
noise, and the noise covariance matrix Q is given by
Q =


q1∆3
3
0
q1∆2
2
0
0
q2∆3
3
0
q2∆2
2
q1∆2
2
0 q1∆ 0
0
q2∆2
2
0 q2∆


where qi are the diffusion coefficients of the white noise process for dimension i (see [SS19, p44] for
details).
Now suppose that at each discrete time point we observe the location, corrupted by Gaussian noise.
Thus the observation model becomes

y1,t
y2,t
| {z }
yt
=

1 0 0 0
0 0 1 0
| {z }
H


ut
u˙ t
vt
v˙t


| {z }
zt
+rt (29.82)
where rt ∼ N (0, R) is the observation noise. We see that the observation matrix H simply
“extracts” the relevant parts of the state vector.
Suppose we sample a trajectory and corresponding set of noisy observations from this model,
(z1:T , y1:T ) ∼ p(z, y|θ). (We use diagonal observation noise, R = diag(σ
2
1
, σ2
2
).) The results are
shown in Figure 29.23(a). We can use the Kalman filter (Section 8.2.2) to compute p(zt|y1:t, θ) for
each t,. (We initialize the filter with a vague prior, namely p(z0) = N (z0|0, 105
I).) The results are
shown in Figure 29.23(b). We see that the posterior mean (red line) is close to the ground truth, but
there is considerable uncertainty (shown by the confidence ellipses). To improve results, we can use
the Kalman smoother (Section 8.2.3) to compute p(zt|y1:T , θ), where we condition on all the data,
past and future. The results are shown in Figure 29.23(c). Now we see that the resulting estimate is
smoother, and the uncertainty is reduced. (The uncertainty is larger at the edges because there is
less information in the neighbors to condition on.)
29.7.2 Online Bayesian linear regression (recursive least squares)
In Section 15.2.2, we discuss how to compute p(w|σ
2
, D) for a linear regression model in batch mode,
using a Gaussian prior of the form p(w) = N (w|µ, Σ). In this section, we discuss how to compute
this posterior online, by repeatedly performing the following update:
p(w|D1:t) ∝ p(Dt|w)p(w|D1:t−1) (29.83)
∝ p(Dt|w)p(Dt−1|w). . . p(D1|w)p(w) (29.84)
where Dt = (ut, yt) is the t’th labeled example, and D1:t−1 are the first t − 1 examples. (For brevity,
we drop the conditioning on σ
2
.) We see that the previous posterior, p(w|D1:t−1), becomes the
current prior, which gets updated by Dt to become the new posterior, p(w|D1:t). This is an example
of sequential Bayesian updating or online Bayesian inference. In the case of linear regression, this
process is known as the recursive least squares or RLS algorithm.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.7. LDS: APPLICATIONS
10 15 20 25 30
10
12
14
16
true state
emissions
(a)
10 15 20 25 30
4
6
8
10
12
14
16
18
20 observed
true state
filtered means
(b)
10 15 20 25 30
6
8
10
12
14
16
18
20 observed
true state
smoothed means
(c)
Figure 29.23: Illustration of Kalman filtering and smoothing for a linear dynamical system. (Repeated
from Figure 8.2.) (a) Observations (green circles) are generated by an object moving to the right (true
location denoted by blue squares). (b) Results of online Kalman filtering. Red cross is the posterior mean,
circles are 95% confidence ellipses derived from the posterior covariance. (c) Same as (b), but using offline
Kalman smoothing. The MSE in the trajectory for filtering is 3.13, and for smoothing is 1.71. Generated by
kf_tracking.ipynb.
xt−1 xt
yt−1 yt
wt−1 wt
(a)
0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0
time
−8
−6
−4
−2
0
2
4
weights
w0 batch
w1 batch
w0
w1
(b)
Figure 29.24: (a) A dynamic generalization of linear regression. (b) Illustration of the recursive least squares
algorithm applied to the model p(y|x, w) = N (y|w0 + w1x, σ2
). We plot the marginal posterior of w0 and w1
vs number of datapoints. (Error bars represent E [wj |y1:t, x1:t] ±
p
V [wj |y1:t, x1:t].) After seeing all the data,
we converge to the offline (batch) Bayes solution, represented by the horizontal lines. (Shading represents the
marginal posterior variance.) Generated by kf_linreg.ipynb.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1000
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We can implement this method by using a linear Gaussian state-space model(Section 29.6). The
basic idea is to let the hidden state represent the regression parameters, and to let the (time-varying)
observation model Ht represent the current feature vector xt.
3 That is, the observation model has
the form
p(yt|wt) = N (yt|Htzt, Rt) = N (yt|x
T
t wt, σ2
) (29.85)
If we assume the regression parameters do not change, the dynamics model becomes
p(wt|wt−1) = N (wt|wt−1, 0) = δ(wt − wt−1) (29.86)
(If we do let the parameters change over time, we get a so-called dynamic linear model [Har90;
WH97; PPC09].) See Figure 29.24a for the model, and Supplementary Section 8.1.2 for a simplification
of the Kalman filter equations when applied to this special case.
We show a 1d example in Figure 29.24b. We see that online inference converges to the exact batch
(offline) posterior in a single pass over the data.
If we approximate the Kalman gain matrix by Kt ≈ ηt1, we recover the least mean squares or
LMS algorithm, where ηt is the learning rate. In LMS, we need to adapt the learning rate to ensure
convergence to the MLE. Furthermore, the algorithm may require multiple passes through the data
to converge to this global optimum. By contrast, the RLS algorithm automatically performs step-size
adaptation, and converges to the optimal posterior in a single pass over the data.
In Section 8.6.3, we extend this approach to perform online parameter estimation for logistic
regression, and in Section 17.5.2, we extend this approach to perform online parameter estimation
for MLPs.
29.7.3 Adaptive filtering
Consider an autoregressive model of order D:
yt = w1yt−1 + · · · + wDyt−D + ǫt (29.87)
where ǫt ∼ N (0, 1). The problem of adaptive filtering is to estimate the parameters w1:D given
the observations y1:t.
We can cast this as inference in an LG-SSM by defining the observation matrix to be Ht =
(yt−1 . . . yt−D) and defining the state as zt = w. We can also allow the parameters to evolve over
time, similar to Section 29.7.2.
29.7.4 Time series forecasting
In Section 29.12 we discuss how to use LDS models to perform time series forecasting.
3. It is tempting to think we can just set the input ut to the covariates xt. Unfortunately this will not work, since
the effect of the inputs is to add an offset term to the output in a way which is independent of the hidden state
(parameters). That is, since we have yt = Htzt + Dtut + d + rt, if we set ut = xt then the features get multiplied by
the constant LDS parameter Dt instead of the hidden state zt containing the regression weights.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.8. LDS: PARAMETER LEARNING
29.8 LDS: parameter learning
There are many approaches for estimating the parameters of state-space models. (In the control
theory community, this is known as systems identification [Lju87].) In the case of linear dynamical
systems, many of the methods are similar to techniques used to fit HMMs, discussed in Section 29.4.
For example, we can use EM, SGD, spectral methods, or Bayesian methods, as we discuss below.
(For more details, see [Sar13, Ch 12].)
29.8.1 EM for LDS
This section is coauthored with Xinglong Li.
If we only observe the output sequence, we can compute ML or MAP estimates of the parameters
using EM. The method is conceptually quite similar to the Baum-Welch algorithm for HMMs
(Section 29.4.1), except we use Kalman smoothing (Section 8.2.3) instead of forwards-backwards in
the E step, and use different calculations in the M step. The details can be found in [SS82; GH96a].
Here we extend these results to consider the case where the HMM may have an optional input
sequence u1:T .
Our goal is to maximize the expected complete data log likelihood
Q(θ, θk−1) = E [log p(z1:T , y1:T |θ)|y1:T ,u1:T , θk−1] (29.88)
where the expectations are taken wrt the parameters at the previous iteration k − 1 of the algorithm.
(We initialize with random parameters, or by first fitting a simpler model, such as factor analysis.)
For brevity of notations, we assume that the bias terms are included in D and B (i.e., the last entry
of ut is 1).
The log joint is given by the following:
log p(z1:T , y1:T |θ) = −
X
T
t=1

1
2
(yt − Hzt − Dut)
TR−1
(yt − Hzt − Dut)

−
T
2
log |R| (29.89)
−
X
T
t=2

1
2
(zt − Fzt−1 − But)
TQ−1
(zt − Fzt−1 − But)

−
T − 1
2
log |Q|
(29.90)
−
1
2
(z1 − m1)
TV−1
1
(z1 − m1) −
1
2
log |V1| + const (29.91)
where the prior on the initial state is p(z1) = N (z1|m1, V1).
In the E step, we can run the Kalman smoother to compute µt|T = E [zt|y1:T ], and Σt|T =
Cov [zt|y1:T ], from which we can compute zˆt = µt|T and
Pt = E

ztz
T
t
|y1:T

= Σt|T + µt|T µ
T
t|T
(29.92)
We also need to compute the cross term
Pt,t−1 = E

ztz
T
t−1
|y1:T

= Σt,t−1|T + µt|T µ
T
t−1|T
(29.93)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1002
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where
Σt−1,t−2|T = Σt−1|t−1J
T
t−2 + Jt−1(Σt,t−1|T − FΣt−1|t−1)J
T
t−2
(29.94)
where Jt is the backwards Kalman gain matrix defined in Equation (8.67). We initialize this
using ΣT ,T −1|T = (I − KT H)FΣT −1|T −1, where KT is the forwards Kalman gain matrix defined in
Equation (8.28).
We can derive the M step as follows, using standard matrix calculus. We denote Aout = [H, D],
xˆout,t = [zˆ
T
t
,u
T
t
]
T
, Adyn = [F, B], ,xˆdyn,t = [zˆ
T
t−1
,u
T
t
]
T
, and
Pout,t =

Pt zˆtu
T
t
utzˆ
T
t utu
T
t

, Pdyn,t =

Pt−1 zˆt−1u
T
t
utzˆ
T
t−1 utu
T
t

. (29.95)
• Output matrices:
∂Q
∂Aout
=
X
T
t=1
R−1ytxˆ
T
out,t −
X
T
t=1
R−1AoutPout,t = 0 (29.96)
Anew
out =
 X
T
t=1
ytxˆ
T
out,t! X
T
t=1
Pout,t!−1
(29.97)
• Output noise covariance:
∂Q(Aout = Anew
out )
∂R−1
=
T
2
R −
1
2
X
T
t=1

yty
T
t − 2Anew
out xˆout,ty
T
t + Anew
out Pout,tA
new,T
out 
= 0 (29.98)
Rnew =
1
T
X
T
t=1
(yty
T
t − Anew
out xˆout,ty
T
t
) (29.99)
• System dynamics matrices:
∂Q
∂Adyn
= −
X
T
t=2
Q−1

Pt,t−1, zˆtu
T
t

+
X
T
t=2
Q−1AdynPdyn,t = 0 (29.100)
Anew
dyn =
 X
T
t=2
[Pt,t−1, zˆtu
T
t
]
! X
T
t=2
Pdyn,t!−1
(29.101)
• State noise covariance:
∂Q(Adyn = Anew
dyn )
∂Q−1
=
T − 1
2
Q −
1
2
X
T
t=2
(Pt − 2Anew
dyn 
Pt−1,t,utzˆ
T
t

+ Anew
dynPdyn,tA
new,T
dyn )
(29.102)
=
T − 1
2
Q −
1
2
X
T
t=2
￾
Pt − Anew
dyn 
Pt−1,t,utzˆ
T
t

= 0 (29.103)
Qnew =
1
T − 1
X
T
t=2
￾
Pt − Anew
dyn 
Pt−1,t,utzˆ
T
t
 (29.104)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 201
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.8. LDS: PARAMETER LEARNING
• Initial state mean:
∂Q
∂m
= (zˆ1 − m)V−1
1 = 0 (29.105)
mnew = zˆ1 (29.106)
• Initial state covariance:
∂Q
∂V−1
1
=
V1
2
−
1
2
(P1 − zˆ1mT
1 − m1zˆ
T
1 + m1mT
1
) = 0 (29.107)
Vnew
1 = P1 − zˆ1zˆ
T
1
(29.108)
Note that computing these expected sufficient statistics in the inner loop of EM takes O(T)
time, which can be expensive for long sequences. In [Mar10b], a faster method, known as ASOS
(approximate second order statistics), is proposed. In this approach, various statistics are precomputed
in a single pass over the sequence, and from then on, all iterations take constant time (independent
of T). Alternatively, if we have multiple processors, we can perform Kalman smoothing in O(log T)
time using parallel scan operations (Section 8.2.3.4).
29.8.2 Subspace identification methods
EM does not always give satisfactory results, because it is sensitive to the initial parameter estimates.
One way to avoid this is to use a different approach known as a subspace identification (SSID)
[OM96; Kat05].
To understand this approach, let us initially assume there is no observation noise and no system
noise. In this case, we have zt = Fzt−1 and yt = Hzt, and hence yt = HFt−1z1. Consequently all
the observations must be generated from a dim(zt)-dimensional linear manifold or subspace. We can
identify this subspace using PCA. Once we have an estimate of the zt’s, we can fit the model as if it
were fully observed. We can either use these estimates in their own right, or use them to initialize
EM. Several papers (e.g., [Smi+00; BK15]) have shown that initializing EM this way gives much
better results than initializing EM at random, or just using SSID without EM.
Although the theory only works for noise-free data, we can try to estimate the system noise
covariance Q from the residuals in predicting zt from zt−1, and to estimate the observation noise
covariance R from the residuals in predicting yt from zt. We can either use these estimates in their
own right, or use them to initialize EM. Because this method relies on taking an SVD, it is called a
spectral estimation method. Similar methods can also be used for HMMs (see Section 29.4.3).
29.8.3 Ensuring stability of the dynamical system
When estimating the dynamics matrix F, it is very useful to impose a constraint on its eigenvalues.
To see why this is important, consider the case of no system noise. In this case, the hidden state at
time t is given by
zt = F
tz1 = UΛtU−1z1 (29.109)
where U is the matrix of eigenvectors for F, and Λ = diag(λi) contains the eigenvalues. If any λi > 1,
then for large t, zt will blow up in magnitude. Consequently, to ensure stability, it is useful to require
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1004
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
that all the eigenvalues are less than 1 [SBG07]. Of course, if all the eigenvalues are less than 1, then
E [zt] = 0 for large t, so the state will return to the origin. Fortunately, when we add noise, the state
becomes non-zero, so the model does not degenerate.
29.8.4 Bayesian LDS
SSMs can be quite sensitive to their parameter values, which is a particular concern when they are
used for forecasting applications (see Section 29.12.1), or when the latent states or parameters are
interpreted for scientific purposes (see e.g., [AM+16]). In such cases, it is wise to represent our
uncertainty about the parameters by using Bayesian inference.
There are various algorithms we can use to perform this task. For linear-Gaussian SSMs, it
is possible to use variational Bayes EM [Bea03; BC07] (see Section 10.3.5), or blocked Gibbs
sampling (see Section 29.8.4.1). Note, however, that θ and z are highly correlated, so the mean field
approximation can be inaccurate, and the blocked Gibbs method can mix slowly. It is also possible
to use collapsed MCMC in which we marginalize out z1:T and just work with p(θ|y1:T ), which we
can sample using HMC.
29.8.4.1 Blocked Gibbs sampling for LDS
This section is written by Xinglong Li.
In this section, we discuss blocked Gibbs sampling for LDS [CK94b; CMR05; FS07]. We alter￾nate between sampling from p(z1:T |y1:T , θ) using the forwards-filter backwards-sampling algorithm
(Section 8.2.3.5), and sampling from p(θ|z1:T , y1:T ), which is easy to do if we use conjugate priors.
In more detail, we will consider the following linear Gaussian state space model with homogeneous
parameters:
p(zt|zt−1,ut) = N (zt|Fzt−1 + But, Q) (29.110)
p(yt|zt,ut) = N (yt|Hzt + Dut, R) (29.111)
The set of all the parameters is θ = {F, H, B, D, Q, R}. For the sake of simplicity, we assume that
the regression coefficient matrix B and D include the intercept term (i.e., the last entry of ut = 1).
We use conjugate MNIW priors, as in Bayesian multivariate linear regression Section 15.2.9.
Specifically,
p(Q, [F, B]) = MNIW(Mz0, Vz0, νq0, Ψq0) (29.112)
p(R, [H, D]) = MNIW(My0, Vy0, νr0, Ψr0) (29.113)
Given z1:T , u1:T and y1:T , the posteriors are also MNIW. Specifically,
Q|z1:T ,u1:T ∼ IW(νq1, Ψq1) (29.114)
[F, B]|Q, z1:T ,u1:T ∼ MN (Mz1, Q, Vz1) (29.115)
where the set of hyperparameters {Mz1, Vz1, νq1
, Ψq1} of the posterior MNIW can be obtained by
replacing Y, A, X in Equation (15.105) with z2:T , [F, B], and [z
T
t−1
,u
T
t
]
T
t=2:T
, respectively. Similarly,
R|z1:T ,u1:T , y1:T ∼ IW(νr1, Ψr1) (29.116)
[H, D]|R, z1:T ,u1:T , y1:T ∼ MN (My1, R, Vy1), (29.117)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.9. SWITCHING LINEAR DYNAMICAL SYSTEMS (SLDSS)
and the hyperparameters {My1, Vy1, νr1, Ψr1} of the posterior MNIW can be obtained by replacing
Y, A, X in Equation (15.105) with y1:T , [H, D], and [y
T
t
,u
T
t
]
T
1;T
.
29.8.5 Online parameter learning for SSMs
For many applications, we need to estimate the parameters of the SSM (such as the transition noise
Q and observation noise R) online, so that we can track non-stationary environments, etc. This
problem is known as adaptive filtering. For some classical methods, see [JB67; Meh72]. For some
online MLE methods, see [ADT12]. For a recent online variational Bayes approach, see [Hua+18c;
VW21] and the references therein.
29.9 Switching linear dynamical systems (SLDSs)
Consider a state-space modelin which the latent state has both a discrete latent variable, mt ∈
{1, . . . , K}, and a continuous latent variable, zt ∈ R
Nz
. (A model with discrete and continuous
latent variables is known as a hybrid system in control theory.) We assume the observed responses
are continuous, yt ∈ R
Ny . We may also have continuous observed inputs ut ∈ R
Nu . The discrete
variable can be used to represent different kinds of system dynamics or operating regimes (e.g.,
normal or abnormal), or different kinds of observation models (e.g., to handle outliers due to sensor
noise or failures). If the system is linear-Gaussian, it is called a switching linear dynamical
system (SLDS), a regime switching Markov model [Ham90; KN98], or a jump Markov
linear system (JMLS) [DGK01].
29.9.1 Parameterization
An SLDS model is defined as follows:
p(mt = k|mt−1 = j) = Ajk (29.118)
p(zt|zt−1, mt = k,ut) = N (zt|Fkzt−1 + Bkut + bk, Qk) (29.119)
p(yt|zt, mt = k,ut) = N (yt|Hkzt + Dkut + dk, Rk) (29.120)
See Figure 29.25a for the DPGM representation. It is straightforward to make a nonlinear version
of this model.
29.9.2 Posterior inference
Unfortunately exact inference in such switching models is intractable, even in the linear Gaussian
case. To see why, suppose for simplicity that the latent discrete switching variable mt is binary, and
that only the dynamics matrix F depend on mt, not the observation matrix H. Our initial belief
state will be a mixture of 2 Gaussians, corresponding to p(z1|y1, m1 = 1) and p(z1|y1, m1 = 2).
The one-step-ahead predictive density will be a mixture of 4 Gaussians p(z2|y1, m1 = 1, m2 = 1),
p(z2|y1, m1 = 1, m2 = 2), p(z2|y1, m1 = 2, m2 = 1), and p(z2|y1, m1 = 2, m2 = 2), obtained by
passing each of the prior modes through the 2 possible transition models. The belief state at step 2
will also be a mixture of 4 Gaussians, obtained by updating each of the above distributions with
y2. At step 3, the belief state will be a mixture of 8 Gaussians. And so on. So we see there is an
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1006
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
yt−1 yt
zt−1 zt
mt−1 mt
ut−1 ut
(a) (b)
Figure 29.25: (a) A switching SSM. Squares represent discrete random variables, circles represent continuous
random variables. (b) Illustration of how the number of modes in the belief state of a switching SSM grows
exponentially over time. We assume there are two binary states.
exponential explosion in the number of modes. Each sequence of discrete values corresponds to a
different hypothesis (sometimes called a track), which can be represented as a tree, as shown in
Figure 29.25b.
Various methods for approximate online inference have been proposed for this model, such as the
following:
• Prune off low probability trajectories in the discrete tree. This is widely used in multiple hypothesis
tracking methods (see Section 29.9.3).
• Use particle filtering (Section 13.2) where we sample discrete trajectories, and apply the Kalman
filter to the continuous variables. See Section 13.4.1 for details.
• Use ADF (Section 8.6), where we approximate the exponentially large mixture of Gaussians with
a smaller mixture of Gaussians. See Section 8.6.2 for details.
• Use structured variational inference, where we approximate the posterior as a product of chain￾structured distributions, one over the discrete variables and one over the continuous variables,
with variational “coupling” terms in between (see e.g., [GH98; PJD21; Wan+22]).
29.9.3 Application: Multitarget tracking
The problem of multi-target tracking frequently arises in engineering applications (especially in
aerospace and defence). This is a very large topic (see e.g., [BSF88; BSL93; Vo+15] for details), but
in this section, we show how switching LDS models (or their nonlinear extensions) can be used to
tackle the problem.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.9. SWITCHING LINEAR DYNAMICAL SYSTEMS (SLDSS)
7.5 10.0 12.5 15.0 17.5 20.0 22.5 25.0 27.5
4
6
8
10
12
Data
Trajectory 1
Trajectory 2
Trajectory 3
Trajectory 4
(a)
10 15 20 25
0
2
4
6
8
10
12
14
Filtered Posterior
Trajectory 1
Trajectory 2
Trajectory 3
Trajectory 4
(b)
10 15 20 25
0
2
4
6
8
10
12
14
Smoothed Posterior
Trajectory 1
Trajectory 2
Trajectory 3
Trajectory 4
(c)
Figure 29.26: Illustration of Kalman filtering and smoothing for tracking multiple moving objects. Generated
by kf_parallel.ipynb.
zt−1,1
zt−1,2
zt,1
zt,2
zt+1,1
zt+1,2
yt−1,1
yt−1,2
yt−1,3
yt,1
yt+1,1
yt+1,2
mt−1 mt mt+1
Figure 29.27: A model for tracking two objects in the presence of data-association ambiguity. We observe 3, 1
and 2 detections at time steps t − 1, t and t + 1. The mt hidden variable encodes the association between the
observations and the hidden causes.
29.9.3.1 Warm-up
In the simplest setting, we know there are N objects we want to track, and each one generates its
own uniquely identified observation. If we assume the objects are independent, we can apply Kalman
filtering and smoothing in parallel, as shown in Figure 29.26. (In this example, each object follows a
linear dynamical model with different initial random velocities, as in Section 29.7.1.)
29.9.3.2 Data association
More generally, at each step we may observe M measurements, e.g., “blips” on a radar screen. We
can have M < N due to occlusion or missed detections. We can have M > N due to clutter or false
alarms. Or we can have M = N. In any case, we need to figure out the correspondence between
the M detections x
m
t and the N objects z
i
t
. This is called the problem of data association, and it
arises in many application domains.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1008
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We can model this problem by augmenting the state space with discrete variables mt that represent
the association matrix between the observations, yt,1:M, and the sources, zt,1:N . See Figure 29.27 for
an illustration, where we have N = 2 objects, but a variable number Mt of observations per time
step.
As we mentioned in Section 29.9.2, inference in such hybrid (discrete-continouus) models is
intractable, due to the exponential number of posterior modes. In the sections below, we briefly
mention a few approximate inference methods.
29.9.3.3 Nearest neighbor approximation using Hungarian algorithm
A common way to perform approximate inference in this model is to compute an N × M weight
matrix, where Wim measures the “compatibility” between object i and measurement m, typically
based on how close m is to where the model thinks i is (the so-called nearest neighbor data
association heuristic).
We can make this into a square matrix by adding dummy background objects, which can explain
all the false alarms, and adding dummy observations, which can explain all the missed detections.
We can then compute the maximal weight bipartite matching using the Hungarian algorithm,
which takes O(max(N, M)
3
) time (see e.g., [BDM09]).
Conditional on knowing the assignments of measurements to tracks, we can perform the usual
Bayesian state update procedure (e.g., based on Kalman filtering). Note that objects that are assigned
to dummy observations do not perform a measurement update, so their state estimate is just based
on forwards prediction from the dynamics model.
29.9.3.4 Other approximate inference schemes
The Hungarian algorithm can be slow (since it is cubic in the number of measurements), and can give
poor results since it relies on hard assignment. Better performance can be obtained by using loopy
belief propagation (Section 9.4). The basic idea is to approximately marginalize out the unknown
assignment variables, rather than perform a MAP estimate. This is known as the SPADA method
(sum-product algorithm for data association) [WL14b; Mey+18].
The cost of each iteration of the iterative procedure is O(NM). Furthermore, [WL14b] proved this
will always converge in a finite number of steps, and [Von13] showed that the corresponding solution
will in fact be the global optimum. The SPADA method is more efficient, and more accurate, than
earlier heuristic methods, such as JPDA (joint probabilistic data association) [BSWT11; Vo+15].
It is also possible to use sequential Monte Carlo methods to solve data association and tracking.
See Section 13.2 for a general discussion of SMC, and [RAG04; Wan+17b] for a review of specific
techniques for this model family.
29.9.3.5 Handling an unknown number of targets
In general, we do not know the true number of targets N, so we have to deal with variable-sized
state space. This is an example of an open world model (see Section 4.6.5), which differs from the
standard closed world assumption where we know how many objects of interest there are.
For example, suppose at each time step we get two “blips” on our radar screen, representing the
presence of an object at a given location. These measurements are not tagged with the source of the
object that generated them, so the data looks like Figure 29.28(a). In Figure 29.28(b-c) we show two
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.9. SWITCHING LINEAR DYNAMICAL SYSTEMS (SLDSS)
1
2
3
4
5
1
2
3
4
5
(a)
1
2
3
3
4
5
1
2 4
5
(b)
1
2
3
4
5
1
2
3
4
5
(c)
1
2
3
3
4
5
1
2
track termination
detection
failure
track
initiation
4
5
false alarm
(d)
Figure 29.28: Illustration of multi-target tacking in 2d over 5 time steps. (a) We observe 2 measurements per
time step. (b-c) Possible hypotheses about the underlying object tracks. (d) A more complex hypothesis in
which the red track stops at step 3, the dashed red track starts at step 4, the dotted blue track has a detection
failure at step 3, and one of the measurements at step 3 is a false alarm. Adapted from Figure 15.8 of [RN19].
different hypotheses about the underlying object trajectories that could have generated this data.
However, how can we know there are two objects? Maybe there are more, but some are just not
detected. Maybe there are fewer, and some observations are false alarms due to background clutter.
One such more complex hypothesis is shown in Figure 29.28(d). Figuring out what is going on in
problems such as this is known as multiple hypothesis tracking.
A common approximate solution to this is to create new objects whenever an observation cannot be
“explained” (i.e., generated with high likelihood) by any existing objects, and to prune out old objects
that have not been detected in a while (in order to keep the computational cost bounded). Sets
whose size and content are both random are called random finite sets. An elegant mathematical
framework for dealing with such objects is described in [Mah07; Mah13; Vo+15].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1010
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Zt 1
Zt
Yt 1
Yt
Figure 29.29: Illustration of a bearings-only tracking problem. Adapted from Figure 2.1 of [CP20b].
29.10 Nonlinear SSMs
In this section, we consider SSMs with nonlinear transition and/or observation functions, and additive
Gaussian noise. That is, we assume the model has the following form
zt = f(zt−1,ut) + qt (29.121)
qt ∼ N (0, Qt) (29.122)
yt = h(zt,ut) + rt (29.123)
rt ∼ N (0, Rt) (29.124)
This is called a nonlinear dynamical system (NLDS), or nonlinear Gaussian SSM (NLG￾SSM).
29.10.1 Example: object tracking and state estimation
In Section 8.3.2.3 we give an example of a 2d tracking problem where the motion model is nonlinear,
but the observation model is linear.
Here we consider an example where the motion model is linear, but the observation model is
nonlinear. In particular, suppose we use the same 2d linear dynamics as in Section 29.7.1, where the
state space contains the position and velocity of the object, zt =
￾
ut vt u˙ t v˙t

. (We use u and
v for the two coordinates, to avoid confusion with the state and observation variables.) Instead of
directly observing the location, suppose we have a bearings only tracking problem, in which we
just observe the angle to the target:
yt = tan−1

vt − sy
ut − sx

+ rt (29.125)
where (sx, sy) is the position of the measurement sensor. See Figure 29.29 for an illustration. This
nonlinear observation model prevents the use of the Kalman filter, but we can still apply approximate
inference methods, as we discuss below.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.11. NON-GAUSSIAN SSMS
Figure 29.30: Samples from a 2d LDS with 5 Poisson likelihood terms. Generated by poisson_lds.ipynb.
29.10.2 Posterior inference
Inferring the states of an NLDS model is in general computationally difficult. Fortunately, there are
a variety of approximate inference schemes that can be used, such as the extended Kalman filter
(Section 8.3.2), the unscented Kalman filter (Section 8.4.2), etc.
29.11 Non-Gaussian SSMs
In this section, we consider SSMs in which the transition and observation noise is non-Gaussian.
The transition and observation functions can be linear or nonlinear. We can represent this as a
probabilistic model as follows:
p(zt|zt−1,ut) = p(zt|f(zt−1,ut)) (29.126)
p(yt|zt,ut) = p(yt|h(zt,ut)) (29.127)
This is called a non-Gaussian SSM (NSSM).
29.11.1 Example: spike train modeling
In this section we discuss consider an SSM with linear-Gaussian latent dynamics and a Poisson
likelihood. Such models are widely used in neuroscience for modeling neural spike trains. (see
e.g., [Pan+10; Mac+11]). This is an example of an exponential family state-space model (see
e.g., [Vid99; Hel17]).
We consider a simple example where the model has 2 continuous latent variables, and we set the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1012
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2 1 0 1 2
z1
2.0
1.5
1.0
0.5
0.0
0.5
1.0
1.5
2.0
z
2
True Latent States & Dynamics
1 0 1
z1
1.5
1.0
0.5
0.0
0.5
1.0
1.5
z
2
Simulated Latent States & Dynamics
Figure 29.31: Latent state trajectory (blue lines) and dynamics matrix A (arrows) for (left) true model and
(right) estimated model. The star marks the start of the trajectory. Generated by poisson_lds.ipynb.
dynamics matrix A to a random rotation matrix. The observation model has the form
p(yt|zt) = Y
D
d=1
Poi(ytd| exp(wT
dzt)) (29.128)
where wd is a random vector, and we use D = 5 observations per time step. Some samples from this
model are shown in Figure 29.30.
We can fit this model by using EM, where in the E step we approximate p(yt|zt) using a Laplace
approximation, after which we can use the Kalman smoother to compute p(z1:T |y1:T ). In the M step,
we optimize the expected complete data log likelihood, similar to Section 29.8.1. We show the result
in Figure 29.31, where we compare the parameters A and the posterior trajectory E [zt|y1:T ] using
the true model and the estimated model. We see good agreement.
29.11.2 Example: stochastic volatility models
In finance, it is common to model the log-returns, yt = log(pt/pt−1), where pt is the price of some
asset at time t. A common model for this problem, known as a stochastic volatility model, (see
e.g., [KSC98]), has the following form:
yt = u
T
t β + exp(zt/2)rt (29.129)
zt = µ + ρ(zt−1 − µ) + σqt (29.130)
rt ∼ N (0, 1) (29.131)
qt ∼ N (0, 1) (29.132)
We see that the dynamical model is a first-order autoregressive process. We typically require that
|ρ| < 1, to ensure the system is stationary. The observation model is Gaussian, but can be replaced
by a heavy-tailed distribution such as a Student.
We can capture longer range temporal correlation by using a higher order auto-regressive process.
To do this, we just expand the state-space to contain the past K values. For example, if K = 2 we
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.12. STRUCTURAL TIME SERIES MODELS
have

zt − µ
zt−1 − µ

=

ρ1 ρ2
1 0  zt−1 − µ
zt−2 − µ

+

qt
0

(29.133)
where qt ∼ N (0, σ2
z
). Thus we have
zt = µ + ρ1(zt−1 − µ) + ρ2(zt−2 − µ) + qt (29.134)
29.11.3 Posterior inference
Inferring the states of an NGSSM model is in general computationally difficult. Fortunately, there
are a variety of approximate inference schemes that can be used, which we discuss in Chapter 8 and
Chapter 13.
29.12 Structural time series models
In this section, we discuss time series forecasting, which is the problem of computing the predictive
distribution over future observations given the data up until the present, i.e., computing p(yt+h|y1:t).
(The model may optionally be conditioned on known future inputs, to get p(yt+h|y1:t,u1:t+h).) There
are many approaches to this problem (see e.g., [HA21]), but in this section, we focus on structural
time series (STS) models, which are defined in terms of linear-Gaussian SSMs.
Many classical time series methods, such as the ARMA (autoregressive moving average) method,
can be represented as STS models (see e.g., [Har90; CK07; DK12; PFW21]). However, the STS
approach has much more flexibility. For example, we can create nonlinear, non-Gaussian, and even
hierarchical extensions, as we discuss below.
29.12.1 Introduction
The basic idea of an STS model is to represent the observed scalar time series as a sum of C individual
components:
f(t) = f1(t) + f2(t) + · · · + fC (t) + ǫt (29.135)
where ǫt ∼ N (0, σ2
). For example, we might have a seasonal component that causes the observed
values to oscillate up and down, and a growth component, that causes the observed values to get
larger over time. Each latent process fc(t) is modeled by a linear Gaussian state-space model, which
(in this context) is also called a dynamic linear model (DLM). Since these are linear, we can
combine them altogether into a single LG-SSM. In particular, in the case of scalar observations, the
model has the form
p(zt|zt−1, θ) = N (zt|Fzt−1, Q) (29.136)
p(yt|zt, θ) = N (yt|Hzt + β
Tut, σ2
y
) (29.137)
where F and Q are block structured matrices, with one block per component. The vector H then
adds up all the relevant pieces from each component to generate the overall mean. Note that the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1014
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
matrices F and H are fixed sparse matrices which can be derived from the form of the corresponding
components of the model, as we discuss below. So the only model parameters are the variance
terms, Q and σ
2
y
, and the optional regression coefficients β.
4 We can generalize this to vector-valued
observations as follows:
p(zt|zt−1, θ) = N (zt|Fzt−1, Q) (29.138)
p(yt|zt, θ) = N (yt|Hzt + Dut, R) (29.139)
29.12.2 Structural building blocks
In this section, we discuss the building blocks of common STS models.
29.12.2.1 Local level model
The simplest latent dynamical process is known as the local level model. It assumes the observations
yt ∈ R are generated by a Gaussian with (latent) mean µt, which evolves over time according to a
random walk:
yt = µt + ǫy,t ǫy,t ∼ N (0, σ2
y
) (29.140)
µt = µt−1 + ǫµ,t, ǫµ,t ∼ N (0, σ2
µ
) (29.141)
We also assume µ1 ∼ N (0, σ2
µ
). Hence the latent mean at any future step has distribution
µt ∼ N (0, tσ2
µ
), so the variance grows with time. We can also use an autoregressive (AR) process,
µt = ρµt−1 + ǫµ,t, where |ρ| < 1. This has the stationary distribution µ∞ ∼ N (0,
σ
2
µ
1−ρ2 ), so the
uncertainty grows to a finite asymptote instead of unboundedly.
29.12.2.2 Local linear model
Many time series exhibit linear trends upwards or downwards, at least locally. We can model this
by letting the level µt change by an amount δt−1 (representing the slope of the line over an interval
∆t = 1) at each step
µt = µt−1 + δt−1 + ǫµ,t (29.142)
The slope itself also follows a random walk,
δt = δt−1 + ǫδ,t (29.143)
and ǫδ,t ∼ N (0, σ2
δ
). This is called a local linear trend model.
We can combine these two processes by defining the following dynamics model:

µt
δt

| {z }
zt
=

1 1
0 1

| {z }
F

µt−1
δt−1

| {z }
zt−1
+

ǫµ,t
ǫδ,t
| {z }
ǫt
(29.144)
4. In the statistics community, the notation often [DK12], who write the dynamics as αt = Ttαt−1 + ctRtηt and the
observations as yt = Ztαt + β
Txt + Htǫt, where ηt ∼ N (0, I) and ǫt ∼ N (0, 1).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.12. STRUCTURAL TIME SERIES MODELS
δt−1
δt
µt−1
µt
yt
ut
σµ σδ
σy β
(a)
δt−1 δt
µt−1 µt
yt
ut
st−1 st
st−2 st−1
st−3 st−2
(b)
Figure 29.32: (a) A BSTS model with local linear trend and linear regression on inputs. The observed output
is yt. The latent state vector is defined by zt = (µt, δt). The (static) parameters are θ = (σy, σµ, σδ, β). The
covariates are ut. (b) Adding a latent seasonal process (with S = 4 seasons). Parameter nodes are omitted
for clarity.
For the emission model we have
yt =
￾
1 0
| {z }
H

µt
δt

| {z }
zt
+ǫy,t (29.145)
We can also use an autoregressive model for the slope, i.e.,
δt = D + ρ(δt−1 − D) + ǫδ,t (29.146)
where D is the long run slope to which δ will revert. This is called a “semilocal linear trend”
model, and is useful for longer term forecasts.
29.12.2.3 Adding covariates
We can easily include covariates ut into the model, to increase prediction accuracy. If we use a linear
model, we have
yt = µt + β
Tut + ǫy,t (29.147)
See Figure 29.32a for an illustration of the local level model with covariates. Note that, when
forecasting into the future, we will need some way to predict the input values of future ut+h; a simple
approach is just to assume future inputs are the same as the present, ut+h = ut.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens1016
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.12.2.4 Modelling seasonality
Many time series also exhibit seasonality, i.e., they fluctuate periodically. This can be modeled by
creating a latent process consisting of a series offset terms, st. To model cyclicity, we ensure that
these sum to zero (on average) over a complete cycle of S steps:
st = −
S
X−1
k=1
st−k + ǫs,t, ǫs,t ∼ N (0, σ2
s
) (29.148)
For example, for S = 4, we have st = −(st−1 +st−2 +st−3) +ǫs,t. We can convert this to a first-order
model by stacking the last S − 1 seasons into the state vector, as shown in Figure 29.32b.
29.12.2.5 Adding it all up
We can combine the various latent processes (local level, linear trend, and seasonal cycles) into a
single linear-Gaussian SSM, because the sparse graph structure can be encoded by sparse matrices.
More precisely, the transition model becomes


st
st−1
st−2
µt
δt


| {z }
zt
=


−1 −1 −1 0 0
1 0 0 0 0
0 1 0 0 0
0 0 0 1 1
0 0 0 0 1


| {z }
F


st−1
st−2
st−3
µt−1
δt−1


| {z }
zt−1
+N
￾
0, diag([σ
2
s
, 0, 0, σ2
µ
, σ2
δ
]

(29.149)
Having defined the model, we can use the Kalman filter to compute p(zt|y1:t), and then make
predictions forwards in time by rolling forwards in latent space, and then predicting the outputs:
p(yt+1|y1:t) = Z
p(yt+1|zt+1)p(zt+1|zt)p(zt|y1:t)dzt (29.150)
This can be computed in closed form, as explained in Section 8.2.2.
29.12.3 Model fitting
Once we have specified the form of the model, we need to learn the model parameters, θ = (D, R, Q),
since F and H fixed to the values specified by the structural blocks, and B = 0. Common
approaches are based on maximum likelihood estimation (see Section 29.8), and Bayesian inference
(see Section 29.8.4). The latter approach is known as Bayesian structural time series or BSTS
modeling [SV14; QRJN18], and often uses the following conjugate prior:
p(θ) = MNIW(R, D)IW(Q) (29.151)
Alternatively, if there are a large number of covariates, we may use a sparsity-promoting prior (e.g.,
spike and slab, Section 15.2.5) for the regression coefficients D.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.12. STRUCTURAL TIME SERIES MODELS
1967
1974
1981
1988
1995
2002
2009
2016
Year
325
350
375
400
Atmospheric CO2
concentration (ppm)
Atmospheric CO2 forecast
ground truth
forecast
(a)
0
50
LocalLinearTrend
1970
1980
1990
2000
2010
2020
−2.5
0.0
2.5
Seasonal
(b)
Figure 29.33: (a) CO2 levels from Mauna Loa. In orange plot we show predictions for the most recent 10
years. (b) Underlying components for the STS mode which was fit to Figure 29.33a. Generated by sts.ipynb.
29.12.4 Forecasting
Once the parameters have been estimated on an historical dataset, we can perform inference on
a new time series to compute p(zt|y1:t,u1:t, θ) using the Kalman filter (Section 8.2.2). Given the
current posterior, we can then “roll forwards” in time to forecast future observations h steps ahead
by computing p(yt+h|y1:t,u1:t+h, θ), as in Section 8.2.2.3. If the parameters are uncertain, we can
sample from the posterior, p(θ|y1:t,u1:t), and then perform Monte Carlo averaging of the forecasts.
29.12.5 Examples
In this section, we give various examples of STS models.
29.12.5.1 Example: forecasting CO2 levels from Mauna Loa
In this section, we fit an STS model to the monthly atmospheric CO2 readings from the Mauna Loa
observatory in Hawaii.5 The data is from January 1966 to February 2019. We combine a local linear
trend model with a seasonal model, where we assume the periodicity is S = 12, since the data is
monthly (see Figure 29.33a). We fit the model to all the data except for the last 10 years using
variational Bayes. The resulting posterior mean and standard deviations for the parameters are
σy = 0.169 ± 0.008, σµ = 0.159 ± 0.017, σδ = 0.009 ± 0.003, σs = 0.038 ± 0.008. We can sample 10
parameter vectors from the posterior and then plug them it to create a distribution over forecasts.
The results are shown in orange in Figure 29.33a. Finally, in Figure 29.33b, we plot the posterior
mean values of the two latent components (linear trend and current seasonal value) over time. We
see how the model has successfully decomposed the observed signal into a sum of two simpler signals.
(See also Section 18.8.1 where we model this data using a GP.)
5. For details, see https://blog.tensorflow.org/2019/03/structural-time-series-modeling-in.html.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1018
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
5.0
7.5
Hourly demand
(GW)
Jan 01
Jan 15
Jan 29
Feb 12
20
40
Temp(
◦C)
Electricity Demand in Victoria, Australia (2014)
(a)
Jan 08
Jan 22
Feb 05
Feb 19
0
2
4
6
8
10
Electricity demand forecast
ground truth
forecast
(b)
Figure 29.34: (a) Hourly temperature and electricity demand in Victoria, Australia in 2014. (b) Electricity
forecasts using an STS. Generated by sts.ipynb.
29.12.5.2 Example: forecasting (real-valued) electricity usage
In this section, we consider a more complex example: forecasting electricity demand in Victoria,
Australia, as a function of the previous value and the external temperature. (Remember that January
is summer in Australia!) The hourly data from the first six weeks of 2014 is shown in Figure 29.34a.
6
We fit an STS to this using 4 components: a seasonal hourly effect (period 24), a seasonal daily effect
(period 7, with 24 steps per season), a linear regression on the temperature, and an autoregressive
term on the observations themselves. We fit the model with variational inference. (This takes about
a minute on a GPU.) We then draw 10 posterior samples and show the posterior predictive forecasts
in Figure 29.34b. We see that the results are reasonable, but there is also considerable uncertainty.
We plot the individual components in Figure 29.35. Note that they have different vertical scales,
reflecting their relative importance. We see that the regression on the external temperature is the
most important effect. However, the hour of day effect is also quite significant, even after accounting
for external temperature. The autoregressive effect is the most uncertain one, since it is responsible
for modeling all of the residual variation in the data beyond what is accounted for by the observation
noise.
We can also use the model for anomaly detection. To do this, we compute the one-step-ahead
predictive distributions, p(yt|y1:t−1,u1:t), for each time step t, and then flag all time steps where the
observation is improbable. The results are shown in Figure 29.36.
29.12.5.3 Example: forecasting (integer valued) sales
In Section 29.12.5.2, we used a linear Gaussian STS model to forecast electricity demand. However, for
some problems, we have integer valued observations, e.g., for neural spike data (see Section 29.11.1),
RNA-Seq data [LJY19], sales data, etc. Here we focus on the case of sales data, where yt ∈ {0, 1, 2, . . .}
is the number of units of some item that are sold on a given day. Predicting future values of yt is
important for many businesses. (This problem is known as demand forecasting.)
We assume the observed counts are due to some latent demand, zt ∈ R. Hence we can use a
model similar to Section 29.11.1, with a Poisson likelihood, except the linear dynamics are given
6. The data is from https://github.com/robjhyndman/fpp2-package.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.12. STRUCTURAL TIME SERIES MODELS
1.0
0.5
0.0
0.5
1.0
hour_of_day_effect/
2
0
2
day_of_week_effect/
0.5
0.0
0.5
1.0
temperature_effect/
Wed Jan 01
Wed Jan 08
Wed Jan 15
Wed Jan 22
Wed Jan 29
Wed Feb 05
Wed Feb 12
Wed Feb 19
Wed Feb 26
2
1
0
1
2
3
autoregressive/
Figure 29.35: Components of the electricity forecasts. Generated by sts.ipynb.
Jan 08
Jan 22
Feb 05
Feb 19
0
2
4
6
8
10
observed time series
one-step prediction
predictive z-score
Anomalies (> 3σ)
Figure 29.36: Anomaly detection in a time series. We plot the observed electricity data in blue and the
predictions in orange. In gray, we plot the z-score at time t , given by (yt − µt)/σt, where p(yt|y1:t−1, u1:t) =
N (µt, σ2
t ). Anomalous observations are defined as points where zt > 3 and are marked with red crosses.
Generated by sts.ipynb.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1020
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 29.37: Visualization of a probabilistic demand forecast for a hypothetical product. Note the sudden
spike near the Christmas holiday in December 2013. The black line denotes the actual demand. Green lines
denote the model samples in the training range, while the red lines show the actual probabilistic forecast on
data unseen by the model. The red bars at the bottom indicate out-of-stock events which can explain the
observed zeros. From Figure 1 of [Bös+17]. Used with kind permission of Tim Januschowski.
by an STS model. In [SSF16; See+17], they consider a likelihood of the form yt ∼ Poi(yt|g(d
y
t
)),
where dt = zt + u
T
t w is the instantaneous latent demand, ut are the covariates that encode seasonal
indicators (e.g., temporal distance from holidays), and g(d) = e
d or log(1+e
d
) is the transfer function.
The dynamics model is a local random walk term, and zt = zt−1 + αN (0, 1), to capture serial
correlation in the data.
However, sometimes we observe zero counts, yt = 0, not because there is no demand, but because
there is no supply (i.e., we are out of stock). If we do not model this properly, we may incorrectly
infer that zt = 0, thus underestimating demand, which may result in not ordering enough inventory
for the future, further compounding the error.
One solution is to use a zero-inflated Poisson (ZIP) model [Lam92] for the likelihood. This is
a mixture model of the form p(yt|dt) = p0I(yt = 0) + (1 − p0)Poi(yt|e
dt ), where p0 is the probability
of the first mixture component. It is also common to use a (possibly zero-inflated) negative binomial
model (Section 2.2.1.4) as the likelihood. This is used in [Cha14; Sal+19b] for the demand forecasting
problem. The disadvantage of these likelihoods is that they are not log-concave for dt = 0, which
complicates posterior inference. In particular, the Laplace approximation is a poor choice, since it
may find a saddle point. In [SSF16], they tackle this using a log-concave multi-stage likelihood,
in which yt = 0 is emitted with probability σ(d
0
t
); otherwise yt = 1 is emitted with probability σ(d
1
t
);
otherwise yt = is emitted with probability Poi(d
2
t
). This generalizes the scheme in [SOB12].
29.12.5.4 Example: hierarchical SSM for electoral panel data
Suppose we perform a survey for the US presidential elections. Let N
j
t be the number of people who
vote at time t in state j, and let y
j
t be the number of those people who vote Democrat. (We assume
N
j
t − y
j
t vote Republican.) It is natural to want to model the dependencies in this data both across
time (longitudinally) and across space (this is an example of panel data).
We can do this using a hierarchical SSM, as illustrated in Figure 29.38. The top level Markov
chain, z
0
t
, models national-level trends, and the state-specific chains, z
j
t
, model local “random effects”.
In practice we would usually also include covariates at the national level, u
0
t and state level, u
j
t
.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.12. STRUCTURAL TIME SERIES MODELS
y
j
t−1 y
j
t
z
j
t−1 z
j
t
z
0
t−1 z
0
t
· · ·
· · ·
j=1:J
Figure 29.38: Illustration of a hierarchical state-space model.
Thus the model becomes
y
j
t ∼ Bin(y
j
t
|π
j
t
, Nj
t
) (29.152)
π
j
t = σ
h
(z
0
t
)
Tu
0
t + (z
j
t
)
Tu
j
t
i
(29.153)
z
0
t = z
0
t−1 + N (0, σ2
I) (29.154)
z
j
t = z
j
t−1 + N (0, τ 2
I) (29.155)
For more details, see [Lin13b].
29.12.6 Causal impact of a time series intervention
In this section, we discuss how to estimate the causal effect on an intervention given some quasi￾experimental time series data. (The term “quasi-experimental” means the data was collected under
an intervention but without using random assignment.) For example, suppose yt is the click through
rate (CTR) of the web page of some company at time t. The company launches an ad campaign at
time n, and observes outcomes y1:n before the intervention and yn+1:m after the intervention. (This
is an example of an interrupted time series, since the “natural” process was perturbed at some
point.) A natural question to ask is: what would the CTR have been had the company not run the ad
campaign? This is a counterfactual question. (We discuss counterfactuals in Section 4.7.4.) If we
can predict this counterfactual time series, y˜n+1:m, then we compare the actual yt to the predicted
y˜t, and use this to estimate the causal impact of the intervention.
To predict the counterfactual outcome, we will use a structural time series (STS) model (see
Section 29.12), following [Bro+15]. An STS model is a linear-Gaussian state-space model, where
arrows have a natural causal interpretation in terms of the arrow of time; thus a STS is a kind
of structural equation model, and hence a structural causal model (see Section 4.7). The use of an
SCM allows us to infer the latent state of the noise variables given the observed data; we can then
“roll back time” to the point of intervention, where we explore an alternative “fork in the road” from
the one we actually took by “rolling forwards in time” in a new version of the model, using the twin
network approach to counterfactual inference (see Section 4.7.4).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1022
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
z1
y1
z2
y2
a3 = 1
z3
y3
z4
y4
a˜3 = 0
z˜3
y˜3
z˜4
y˜4
x1 x2 x3 x4
Figure 29.39: Twin network state-space model for estimating causal impact of an intervention that occurs
just after time step n = 2. We have m = 4 actual observations, denoted y1:4. We cut the incoming arcs
to z3 since we assume z3:T comes from a different distribution, namely the post-intervention distribution.
However, in the counterfactual world, shown at the bottom of the figure (with tilde symbols), we assume the
distributions are the same as in the past, so information flows along the chain uninterrupted.
29.12.6.1 Computing the counterfactual prediction
To explain the method in more detail, consider the twin network in Figure 29.39. The intervention
occurs after time n = 2, and there are m = 4 observations in total. We observe 2 datapoints before
the intervention, y1:2, and 2 datapoints afterwards, y3:4. We assume observations are generated by
latent states z1:4, which evolve over time. The states are subject to exogeneous noise terms, which
can represent any set of unmodeled factors, such as the state of the economy. In addition, we have
exogeneous covariates, x1:m.
To predict what would have happened if we had not performed the intervention, (an event denoted
by a˜ = 0), we replicate the part of the model that occurs after the intervention, and use it to make
forecasts. The goal is to compute the counterfactual distribution, p(y˜n+1:m|y1:n, x1:m), where y˜t
represents counterfactual outcomes if the action had been a˜ = 0. We can compute this counterfactual
distribution as follows:
p(y˜n+1:m|y1:n, x1:m) = Z
p(y˜n+1:m|z˜n+1:m, xn+1:m, θ)p(z˜n+1:m|zn, θ)× (29.156)
p(zn, θ|x1:n, y1:n)dθdzndz˜n+1:m (29.157)
where
p(zn, θ|x1:n, y1:n) = p(zn|x1:n, y1:n, θ)p(θ|x1:n, y1:n) (29.158)
For linear Gaussian SSMs, the term p(zn|x1:n, y1:n, θ) can be computed using Kalman filtering
(Section 8.2.2), and the term p(θ|y1:n, x1:n), can be computed using MCMC or variational inference.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.12. STRUCTURAL TIME SERIES MODELS
𝜇!
𝑦! 𝒩 𝑦" 𝜇" + 𝛽"
#𝑥"
, 𝜎$
%
𝜇&
… 𝑦&
𝜇&'!
𝑦)&'!
𝜇(
𝑦)(
𝑥! 𝑥& 𝑥&'! 𝑥(
𝒩 𝜇" 𝜇")! + 𝛿")!, 𝜎*
%
𝒩 𝛿" 𝛿")!, 𝜎+
%
…
…
…
…
…
𝜎* 𝜎+
𝜎$
𝜇,
local trend
local level
observed (𝑦) and 
counterfactual 
( $𝑦) outcomes
covariates
pre-intervention period post-intervention period
𝛿! 𝛿&'! 𝛿(
diffusion 
parameters
𝒩 𝛽 0, 𝜎𝛽𝐼
𝛿, 𝛿&
regression 𝛽
coefficients
observation 
noise
Figure 29.40: A graphical model representation of the local level causal impact model. The dotted line
represents the time n at which an intervention occurs. Adapted from Figure 2 of [Bro+15]. Used with kind
permission of Kay Brodersen.
We can use samples from the above posterior predictive distribution to compute a Monte Carlo
approximation to the distribution of the treatment effect per time step, τ
i
t = yt − y˜
i
t
, where the
i index refers to posterior samples. We can also approximate the distribution of the cumulative
causal impact using σ
i
t =
Pt
s=n+1 τ
i
t
. (There will be uncertainty in these quantities arising both from
epistemic uncertainty, about the true parameters controlling the model, and aleatoric uncertainty,
due to system and observation noise.)
29.12.6.2 Assumptions needed for the method to work
The validity of the method is based on 3 assumptions: (1) Predictability: we assume that the outcome
can be adequately predicted by our model given the data at hand. (We can check this by using
backcasting, in which we make predictions on part of the historical data.) (2) Unaffectedness: we
assume that the intervention does not change future covariates xn+1:m. (We can potentially check
this by running the method with each of the covariates as an outcome variable.) (3) Stability: we
assume that, had the intervention not taken place, the model for the outcome in the pre-treatment
period would have continued in the post-treatment period. (We can check this by seeing if we predict
an effect if the treatment is shifted earlier in time.)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1024
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
115
120
125
130
Original time series
0
10
20
Poinwise causal impact
0 20 40 60 80 100
0
100
200
300
400
Cumulative causal impact
Figure 29.41: Some simulated time series data which we use to estimate the causal impact of some intervention,
which occurs at time n = 70, Generated by causal_impact_jax.ipynb.
29.12.6.3 Example
As a concrete example, let us assume we have a local level model and we use linear regression to
model the dependence on the covariates, as in Section 29.12.2.3. That is,
yt = µt + β
Txt + N (0, σ
2
y
) (29.159)
µt = µt−1 + δt−1 + N (0, σ2
µ
) (29.160)
δt = δt−1 + N (0, σ2
δ
) (29.161)
See the graphical model in Figure 29.40. The static parameters of the model are θ = (β, σ2
y
, σ2
µ
, σ2
δ
),
the other terms are state or observation variables. (Note that we are free to use any kind of STS
model; the local level model is just a simple default.)
For simplicity, let us assume we have a single scalar input xt, in addition to the scalar output yt.
We create some synthetic data using an autoregressive process on xt, and then set yt = 1.2xt + ǫt.
We then manually intervene at timestep t = 70 by increasing the yt values by 10. In Figure 29.41, we
show the output of the causal impact procedure when applied to this dataset. In the top row, we see
that the forecasted output y˜t (blue line) at times t ≥ 70 follows the general AR trend learned by
the model on the pre-interventional period, whereas the actual observations yt (black line) are quite
different. Thus the posterior over the pointwise causal impact, τt = yt − y˜t, has a value of about 10
for t ≥ 70.
29.12.6.4 Comparison to synthetic control
The use of a linear combination of other “donor” time series β
Txt is similar in spirit to the concept of
a “synthetic control” [Aba; Shi+21]. However we do not restrict ourselves to a convex combination
of donors. Indeed, when we have many covariates, we can use a spike-and-slab prior (Section 15.2.5)
or horseshoe prior (Section 15.2.7) to select the relevant ones. Furthermore, the STS method can be
applied even if we just observe the outcome series yt, without any other parallel time series.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.12. STRUCTURAL TIME SERIES MODELS
29.12.7 Prophet
Prophet [TL18a] is a popular time series forecasting library from Facebook. It fits a generalized
additive model of the form
y(t) = g(t) + s(t) + h(t) + wTx(t) + ǫt (29.162)
where g(t) is a trend function, s(t) is a seasonal fluctuation (modeled using linear regression applied
to a sinusoidal basis set), h(t) is an optional set of sparse “holiday effects”, x(t) are an optional set
of (possibly lagged) covariates, w are the regression coefficients, and ǫ(t) is the residual noise term,
assumed to be iid Gaussian.
Prophet is a regression model, not an auto-regressive model, since it predicts the time series y1:T
given the time stamp t and the covariates x1:T , but without conditioning on past observations of
y. To model the dependence on time, the trend function is assumed to be a piecewise linear trend
with S changepoints, uniformly spaced in time. (See Section 29.5.6 for a discussion of changepoint
detection.) That is, the model has the form
g(t) = (k + a(t)
T
δ)t + (m + a(t)
Tγ) (29.163)
where k is the growth rate, m is the offset, aj (t) = I(t ≥ sj ), where sj is the time of the j’th
changepoint, δt ∼ Laplace(τ ) is the magnitude of the change, and γj = −sj δj to make the function
continuous. The Laplace prior on δ ensures the MAP parameter estimate is sparse, so the difference
across change point boundaries is usually 0.
For an interactive visualization of how Prophet works, see https://github.com/MBrouns/timeseers.
29.12.8 Neural forecasting methods
Classical time series methods work well when there is little data (e.g., short sequences, or few
covariates). However, in some cases, we have a lot of data. For example, we might have a single, but
very long sequence, such as in anomaly detection from real-time sensors [Ahm+17]. Or we may have
multiple, related sequences, such as sales of related products [Sal+19b]. In both cases, larger data
means we can afford to fit more complex parametric models. Neural networks are a natural choice,
because of their flexibility. Until recently, their performance in forecasting tasks was not competitive
with classical methods, but this has recently started to change, as described in [Ben+22; LZ20].
A common benchmark in the univariate time series forecasting literature is the M4 forecasting
competition [MSA18], which requires participants to make forecasts on many different kinds of
(univariate) time series (without covariates). This was recently won by a neural method [Smy20].
More precisely, the winner of the 2019 M4 competition was a hybrid RNN-classical method called
ES-RNN [Smy20]. The exponential smoothing (ES) part allows data-efficient adaptation to the
observed past of the current time series; the recurrent neural network (RNN) part allows for learning
of nonlinear components from multiple related time series. (This is known as a local+global model,
since the ES part is “trained” just on the local time series, whereas the RNN is trained on a global
dataset of related time series.)
In [Ran+18] they adopt a different approach for combining RNNs and classical methods, called
DeepSSM. In particular, they train a single RNN to predict the parameters of a state-space model
(see Main Section 29.1). In more detail, let x
n
1:T
represent the n’th time series, and let θ
n
t
represent
the non-stationary parameters of a linear-trend SSM model (see Section 29.12.1). We train an RNN to
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1026
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
compute θ
n
t = f(c
n
1:T
; φ), where φ are the RNN parameters shared across all sequences. We can use
the predicted parameters to compute the log likelihood of the sequence, Ln = log p(x
n
1:T
|c
n
1:T
, θ
n
1:T
),
using the Kalman filter. These two modules can be combined to allow for end-to-end training of φ
to maximize PN
n=1 Ln.
In [Wan+19c], they propose a different hybrid model known as Deep Factors. The idea is to
represent each time series (or its latent function, for non-Gaussian data) as a weighted sum of a
global time series, coming from a neural model, and a stochastic local model, such as an SSM or GP.
The DeepGLO (global-local) approach of [SYD19] proposes a related hybrid method, where the
global model uses matrix factorization to learn shared factors. This is then combined with temporal
convolutional networks.
It is also possible to train a purely neural model, without resorting to classical methods. For
example, the N-BEATS model of [Ore+20] trains a residual network to predict the weights of a set
of basis functions, corresponding to a polynomial trend and a periodic signal. The weights for the
basis functions are predicted for each window of input using the neural network. Another approach
is the DeepAR model of [Sal+19b], which fits a single RNN to a large number of time series. The
original paper used integer (count) time series, modeled with a negative binomial likelihood function.
This is a unimodal distribution, which may not be suitable for all tasks. More flexible forms, such as
mixtures of Gaussians, have also been proposed [Muk+18].
A popular alternative is to use quantile regression [Koe05], in which the model is trained
to predict quantiles of the distribution, which can be done by optimizing the pinball loss (see
Section 14.3.2.1). For example, [Gas+19] proposed SQF-RNN, which uses splines to represent
the quantile function. They used CRPS or continuous-ranked probability score as the loss
function, which trains the model to predict all the quantiles. In particular, for a quantile predictor
F
−1
(α), the CRPS loss is defined as
CRPS(F
−1
, y) = Z 1
0
2ℓα(y, F −1
(α))dα
where the inner loss function is the pinball loss defined in Equation (14.53). CRPS is a proper scoring
rule, but is less sensitive to outliers, and is more “distance aware”, than log loss. For determiistic
predictions, the CRPS reduces to the absolute error.
The above methods all predict a single output (per time step). If there are multiple simultaneous
observations, it is best to try to model their interdependencies. In [Sal+19a], they use a (low-rank)
Gaussian copula for this, and in [Tou+19], they use a nonparametric copula.
In [Wen+17], they simultaneously predict quantiles for multiple steps ahead using dilated causal
convolution (or an RNN). They call their method MQ-CNN. In [WT19], they extend this to predict
the full quantile function, taking as input the desired quantile level α, rather than prespecifying
a fixed set of levels. They also use a copula to learn the dependencies among multiple univariate
marginals.
29.13 Deep SSMs
Traditional state-space model assume linear dynamics and linear observation models, both with
additive Gaussian noise. This is obviously very limiting. In this section, we allow the dynamics
and/or observation model to be modeled by nonlinear and/or non-Markovian deep neural networks;
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.13. DEEP SSMS
we call these deep state-space model, also known as dynamical variational autoencoders.
(To be consistent with the literature on VAEs, we denote the observations by xt instead of yt.) For a
detailed review, see [Ged+20; Gir+21].
29.13.1 Deep Markov models
Suppose we create a SSM in which we use a deep neural network for the dynamics model and/or
observation model; the result is called a deep Markov model [KSS17] or stochastic RNN [BO14;
Fra+16]. (This is not quite the same as a variational RNN, which we explain in Section 29.13.4.)
We can fit a DMM using SVI (Section 10.1.4). The key is to infer the posterior over the latents.
From the first-order Markov properties, the exact posterior is given by
p(z1:T |x1:T ) = Y
T
t=1
p(zt|zt−1, x1:T ) = Y
T
t=1
p(zt|zt−1,✘x1:✘t−✘1, xt:T ) (29.164)
where we define p(z1|z0, x1:T ) = p(z1|x1:T ), and the cancelation follows since zt ⊥ x1:t−1|zt−1, as
pointed out in [KSS17].
In general, it is intractable to compute p(z1:T |x1:T ), so we approximate it with an inference network.
There are many choices for q. A simple one is a fully factorized model, q(z1:T ) = Q
t
q(zt|x1:t). This
is illustrated in Figure 29.42a. Since zt only depends on past data, x1:t (which is accumulated in the
RNN hidden state ht), we can use this inference network at run time for online inference. However,
for training the model offline, we can use a more accurate posterior by using
q(z1:T |x1:T ) = Y
T
t=1
q(zt|zt−1, x1:T ) = Y
T
t=1
q(zt|zt−1,✘x1:✘t−✘1, xt:T ) (29.165)
Note that the dependence on past observation x1:t−1 is already captured by zt−1, as in Equa￾tion (29.164). The dependencies on future observations, xt:T , can be summarized by a backwards
RNN, as shown in Figure 29.42b. Thus
q(z1:T , h1:T |x1:T ) = Y
1
t=T
I(ht = f(ht+1, xt))Y
T
t=1
q(zt|zt−1, ht) (29.166)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1028
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
( µ1,s1) (µ2,s2) (µ3,s3)
z
z
1
2 z3
h
1
h h
2
3
x1 x x 2 3
(a)
( µ1,s1) (µ2,s2) (µ3,s3)
z z
z z
q
0 1
2
3
h
1
h h
2
3
x x 1 2 x3
(b)
Figure 29.42: Inference networks for deep Markov model. (a) Fully factorized causal posterior
Q
q(z1:T |x1:T ) =
t
q(zt|x1:t). The past observations x1:t are stored in the RNN hidden state ht. (b) Markovian posterior
q(z1:T |x1:T ) = Q
t
q(zt|zt−1, xt:T ). The future observations xt:T are stored in the RNN hidden state ht.
Given a fully factored q(z1:T ), we can compute the ELBO as follows.
log p(x1:T ) = log "X
z1:T
p(x1:T |z1:T )p(z1:T )
#
(29.167)
= log Eq(z1:T )

p(x1:T |z1:T )
p(z1:T )
q(z1:T )

(29.168)
= log Eq(z1:T )
"Y
T
t=1
p(xt|zt)p(zt|zt−1)
q(zt)
#
(29.169)
≥ Eq(z1:T )
"X
T
t=1
log p(xt|zt) + log p(zt|zt−1) − log q(zt)
#
(29.170)
=
X
T
t=1
Eq(zt)
[log p(xt|zt)] − Eq(zt−1)
[DKL (q(zt) k p(zt|zt−1))] (29.171)
If we assume that the variational posteriors are jointly Gaussian, we can use the reparameterization
trick to use posterior samples to compute stochastic gradients of the ELBO. Furthermore, since we
assumed a Gaussian prior, the KL term can be computed analytically.
29.13.2 Recurrent SSM
In a DMM, the observation model p(xt|zt) is first-order Markov, as is the dynamics model p(zt|zt−1).
We can modify the model so that it captures long-range dependencies by adding deterministic hidden
states as well. We can make the observation model depend on z1:t instead of just zt by using p(xt|ht),
where ht = f(ht−1, zt), so ht records all the stochastic choices. This is illustrated in Figure 29.43a.
We can also make the dynamical prior depend on z1:t−1 by replacing p(zt|zt−1) with p(zt|ht−1). as
is illustrated in Figure 29.43b. This is known as a recurrent SSM.
We can derive an inference network for an RSSM similar to the one we used for DMMs, except
now we use a standard forwards RNN to compute q(zt|x1:t−1, x1:t).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.13. DEEP SSMS
x1 x2 x3
h1 h2 h3
z1 z2 z3
(a)
x1 x2 x3
h1 h2 h3
z1 z2 z3
(b)
Figure 29.43: Recurrent state-space models. (a) Prior is first-order Markov, p(zt|zt−1), but observation model
is not Markovian, p(xt|ht) = p(xt|z1:t), where ht summarizes z1:t. (b) Prior model is no longer first-order
Markov either, p(zt|ht−1) = p(zt|z1:t−1). Diamonds are deterministic nodes, circles are stochastic.
z2|1 z3|1
z2|2 z3|2 z1|1
z2|1 z3|2
z3|1
z2|2 z3|3
z2|1 z3|2
z3|1
z1|1 z1|1 z2|2 z3|3
x1
x2 x3 x1
x2 x3 x1 x2 x3
(a) Standard Variational bound (b) Observation overshooting (c) Latent overshooting
Figure 29.44: Unrolling schemes for SSMs. The labels zi|j is shorthand for p(zi|x1:j ). Solid lines denote the
generative process, dashed lines the inference process. Arrows pointing at shaded circles represent log-likelihood
loss terms. Wavy arrows indicate KL divergence loss terms. (a) Standard 1 step reconstruction of the
observations. (b) Observation overshooting tries to predict future observations by unrolling in latent space.
(c) Latent overshooting predicts future latent states and penalizes their KL divergence, but does need to care
about future observations. Adapted from Figure 3 of [Haf+19].
29.13.3 Improving multistep predictions
In Figure 29.44(a), we show the loss terms involved in the ELBO. In particular, the wavy edge zt|t →
zt|t−1 corresponds to Eq(zt−1)
[DKL (q(zt) k p(zt|zt−1))], and the solid edge zt|t → xt corresponds to
Eq(zt)
[log p(xt|zt)]. We see that the dynamics model, p(zt|zt−1), is only ever penalized in terms of
how it differs from the one-step-ahead posterior q(zt), which can hurt the ability of the model to
make long-term predictions.
One solution to this is to make multistep forwards predictions using the dynamics model, and use
these to reconstruct future observations, and add these errors as extra loss terms. This is called
observation overshooting [Amo+18], and is illustrated in Figure 29.44(b).
A faster approach, proposed in [Haf+19], is to apply a similar idea but in latent space. More
precisely, let us compute the multi-step prediction model, by repeatedly applying the transition
model and integrating out the intermediate states to get p(zt|zt−d). We can then compute the ELBO
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1030
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
x1 x2 x3
h1 h2 h3
z1 z2 z3
(a)
x1 x2 x3
h1 h2 h3
z1 z2 z3
(b)
Figure 29.45: Variational RNN. (a) Generative model. (b) Inference model. The diamond-shaped nodes are
deterministic.
for this as follows:
log pd(x1:T ) , log Z Y
T
t=1
p(zt|zt−d)p(xt|zt)dz1:T (29.172)
≥
X
T
t=1
Eq(zt)
[log p(xt|zt)] − Ep(zt−1|zt−d)q(zt−d)
[DKL (q(zt) k p(zt|zt−1))] (29.173)
To train the model so it is good at predicting at different future horizon depths d, we can average
the above over all 1 ≤ d ≤ D. However, for computational reasons, we can instead just average
the KL terms, using weights βd. This is called latent overshooting [Haf+19], and is illustrated in
Figure 29.44(c). The new objective becomes
1
D
X
D
d=1
log pd(x1:T ) ≥
X
T
t=1
Eq(zt)
[log p(xt|zt)] (29.174)
−
1
D
X
D
d=1
βdEp(zt−1|zt−d)q(zt−d)
[DKL (q(zt) k p(zt|zt−1))] (29.175)
29.13.4 Variational RNNs
A variational RNN (VRNN) [Chu+15] is similar to a recurrent SSM except the hidden states are
generated conditional on all past hidden states and all past observations, rather than just the past
hidden states. This is a more expressive model, but is slower to use for forecasting, since unrolling
into the future requires generating observations xt+1, xt+2, . . . to “feed into” the hidden states, which
controls the dynamics. This makes the model less useful for forecasting and model-based RL (see
Section 35.4.5.2).
More precisely, the generative model is as follows:
p(x1:T , z1:T , h1:T ) = Y
T
t=1
p(zt|ht−1, xt−1)I(ht = f(ht−1, xt−1, zt)) p(xt|ht) (29.176)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
29.13. DEEP SSMS
where p(z1|h0, x0) = p(z0) and h1 = f(h0, x0, z1) = f(z1). Thus ht = (z1:t, x1:t−1) is a summary
of the past observations and past and current stochastic latent samples. If we marginalize out
these deterministic hidden nodes, we see that the dynamical prior on the stochastic latents is
p(zt|ht−1, xt−1) = p(zt|z1:t−1, x1:t−1), whereas in a DMM, it is p(zt|zt−1), and in an RSSM, it is
p(zt|z1:t−1). See Figure 29.45a for an illustration.
We can train VRNNs using SVI. In [Chu+15], they use the following inference network:
q(z1:T , h1:T |x1:T ) = Y
T
t=1
I(ht = f(ht−1, zt−1, xt) q(zt|ht) (29.177)
Thus ht = (z1:t−1, x1:t). Marginalizing out these deterministic nodes, we see that the filtered
posterior has the form q(z1:T |x1:T ) = Q
t
q(zt|z1:t−1, x1:t). See Figure 29.45b for an illustration. (We
can also optionally replace xt with the output of a bidirectional RNN to get the smoothed posterior,
q(z1:T |x1:T ) = Q
t
q(zt|z1:t−1, x1:T ).)
This approach was used in [DF18] to generate simple videos of moving objects (e.g., a robot
pushing a block); they call their method stochastic video generation or SVG. This was scaled
up in [Vil+19], using simpler but larger architectures.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license30 Graph learning
30.1 Introduction
Graphs are a very common way to represent data. In this chapter we discuss probability models for
graphs. In Section 30.2, we assume the graph structure G is known, but we want to “explain” it in
terms of a set of meaningful latent features; for this we use various kinds of latent variable models. In
Section 30.3, we assume the graph structure G is unknown and needs to be inferred from correlated
data, xn ∈ R
D; for this, we will use probabilistic graphical models with unknown topology. (See also
Section 16.3.6, where we discuss graph neural networks, for performing supervised learning using
graph-structured data.)
30.2 Latent variable models for graphs
Graphs arise in many application areas, such as modeling social networks, protein-protein interaction
networks, or patterns of disease transmission between people or animals. To try to find “interesting
structure” in such graphs, such as clusters or communities, it is common to fit latent variable generative
models of various forms, such as the stochastic blocks model. See Supplementary Section 30.1 for
details.
30.3 Graphical model structure learning
In this section, we discuss how to learn the structure of a probabilistic graphical model given sample
observations of some or all of its nodes. That is, the input is an N × D data matrix, and the output
is a graph G (directed or undirected) with NG nodes. (Usually NG = D, but we also consider the
case where we learn extra latent nodes that are not present in the input.)
There are many different methods for learning PGM graph structures. See Supplementary Chap￾ter 30 for details, and [VCB22] for a recent review.
In terms of applications, there are three main reasons to perform structure learning for PGMs:
understanding, prediction, and causal inference (which involves both understanding and prediction),
as we summarize below.
Learning sparse PGMs can be useful for gaining an understanding of multiple interacting variables.
For example, consider a problem that arises in systems biology: we measure the phosphorylation
status of some proteins in a cell [Sac+05] and want to infer how they interact. Figure 30.1 gives an
example of a graph structure that was learned from this data, using a method called graphical lasso1034
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Raf
Mek
Plcg
PIP2
PIP3
Erk Akt
PKA
PKC
P38
Jnk
 = 36
(a)
Raf
Mek
Plcg
PIP2
PIP3
Erk Akt
PKA
PKC
P38
Jnk
 = 27
(b)
Raf
Mek
Plcg
PIP2
PIP3
Erk Akt
PKA
PKC
P38
Jnk
 = 7
(c)
Raf
Mek
Plcg
PIP2
PIP3
Erk Akt
PKA
PKC
P38
Jnk
 = 0
(d)
Figure 30.1: A sparse undirected Gaussian graphical model learned using graphical lasso applied to some flow
cytometry data (from [Sac+05]), which measures the phosphorylation status of 11 proteins. The sparsity level
is controlled by λ. (a) λ = 36. (b) λ = 27. (c) λ = 7. (d) λ = 0. Adapted from Figure 17.5 of [HTF09].
Generated by ggm_lasso_demo.ipynb.
[FHT08; MH12], which is explained in Supplementary Section 30.4.2. As another example, [Smi+06]
showed that one can recover the neural “wiring diagram” of a certain kind of bird from multivariate
time-series EEG data. The recovered structure closely matched the known functional connectivity of
this part of the bird brain.
In some cases, we are not interested in interpreting the graph structure, we just want to use it to
make predictions. One example of this is in financial portfolio management, where accurate models of
the covariance between large numbers of different stocks is important. [CW07] show that by learning
a sparse graph, and then using this as the basis of a trading strategy, it is possible to outperform (i.e.,
make more money than) methods that do not exploit sparse graphs. Another example is predicting
traffic jams on the freeway. [Hor+05] describe a deployed system called JamBayes for predicting
traffic flow in the Seattle area, using a directed graphical model whose structure was learned from
data.
Structure learning is also an important pre-requisite for causal inference. In particular, to predict
the effects of interventions on a system, or to perform counterfactual reasoning, we need to know the
structural causal model (SCM), as we discuss in Section 4.7. An SCM is a kind of directed graphical
model where the relationships between nodes are deterministic (functional), except for stochastic
root (exogeneous) variables. Consequently one can use techniques for learning DAG structures as a
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
30.3. GRAPHICAL MODEL STRUCTURE LEARNING
way to learn SCMs, if we make some assumptions about (lack of) confounders. This is called causal
discovery. See Supplementary Section 30.5 for details.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license31 Nonparametric Bayesian models
This chapter is written by Vinayak Rao.
31.1 Introduction
The defining characteristic of a parametric model is that the objects being modeled, whether
regression or classification functions, probability densities, or something more modern like graphs or
shapes, are indexed by a finite-dimensional parameter vector. For instance, neural networks have a
fixed number of parameters, independent of the dataset. In a parametric Bayesian model, a prior
probability distribution on these parameters is used to define a prior distribution on the objects of
interest. By contrast, in a Bayesian nonparametric (BNP) model (also called a non-parametric
Bayesian model) we directly place prior distributions on the objects of interest, such as functions,
graphs, probability distributions, etc. This is usually done via some kind of stochastic process,
which is a probability distribution over a potentially infinite set of random variables.
One example is a Gaussian process. As explained in Chapter 18, this defines a probability
distribution over an unknown function f : X → R, such that the joint distribution of f(X) =
(f(x1), . . . , f(xN )) is jointly Gaussian for any finite set of values X = {xn ∈ X }N
n=1 i.e., p(f(X)) =
N (f(X)|µ(X), K(X)) where µ(X) = [µ(x1), . . . , µ(xN )] is the mean, K(X) = [K(xi), K(xj )] is the
N × N Gram matrix, and K is a positive definite kernel function. The complexity of the posterior
over functions can grow with the amount of data, avoiding underfitting, since we maintain a full
posterior distribution over the infinite set of unknown “parameters” (i.e., function evaluations at all
points x ∈ X ). But by taking a Bayesian approach, we avoid overfitting this infinitely flexible model.
Despite involving infinite-parameter objects, practitioners are often only interested in inferences on a
finite training dataset and predictions on a finite test dataset. This often allows these models to be
surprisingly tractable. We can also define probability distributions over probability distributions, as
well as other kinds of objects.
We discuss these topics in more detail in Supplementary Chapter 31. For even more information,
see e.g., [Hjo+10; GV17].32 Representation learning
This chapter is written by Ben Poole and Simon Kornblith.
32.1 Introduction
Representation learning is a paradigm for training machine learning models to transform raw
inputs into a form that makes it easier to solve new tasks. Unlike supervised learning, where the
task is known at training time, representation learning often assumes that we do not know what task
we wish to solve ahead of time. Without this knowledge, are there transformations of the input we
can learn that are useful for a variety of tasks we might care about?
One point of evidence that representation learning is possible comes from us. Humans can rapidly
form rich representations of new classes [LST15] that can support diverse behaviors: finding more
instances of that class, decomposing that instance into parts, and generating new instances from that
class. However, it is hard to directly specify what representations we would like our machine learning
systems to learn. We may want it make it easy to solve new tasks with small amounts of data, we
may want to construct novel inputs or answer questions about similarities between inputs, and we
may want the representation to encode certain information while discarding other information.
In building methods for representation learning, the goal is to design a task whose solution requires
learning an improved representation of the input instead of directly specifying what the representation
should do. These tasks can vary greatly, from building generative models of the dataset to learning
to cluster datapoints. Different methods often involve different assumptions on the dataset, different
kinds of data, and induce different biases on the learned representation. In this chapter we first
discuss methods for evaluating learned representations, then approaches for learning representations
based on supervised learning, generative modeling, and self-supervised learning, and finally the theory
behind when representation learning is possible.
32.2 Evaluating and comparing learned representations
How can we make sense of representations learned by different neural networks, or of the differences
between representations learned in different layers of the same network? Although it is tempting
to imagine representations of neural networks as points in a space, this space is high-dimensional.
In order to determine the quality of representations and how different representations differ, we
need ways to summarize these high-dimensional representations or their relationships with a few1040
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Neural Network
Input Data Representation
Figure 32.1: Representation learning transforms input data (left) where data from different classes (color) are
mixed together to a representation (right) where attributes like class are more easily distinguished. Generated
by vib_demo.ipynb.
relevant scalars. Doing so requires making assumptions about what structure in the representations
is important.
32.2.1 Downstream performance
The most common way to evaluate the quality of a representation is to adapt it to one or more
downstream tasks thought to be representative of real-world scenarios. In principle, one could choose
any strategy to adapt the representation, but a small number of adaptation strategies dominate the
literature. We discuss these strategies below.
Clearly, downstream performance can only differ from pretraining performance if the downstream
task is different from the pretraining task. Downstream tasks can differ from the pretraining task
in their input distributions, target distributions, or both. The downstream tasks used to evaluate
unsupervised or self-supervised representation learning often involve the same distribution of inputs
as the pretraining task, but require predicting targets that were not provided during pretraining. For
example, in self-supervised visual representation learning, representations learned on the ImageNet
dataset without using the accompanying labels are evaluated on ImageNet using labels, either by
performing linear evaluation with all the data or by fine-tuning using subsets of the data. By contrast,
in transfer learning (Section 19.5.1), the input distribution of the downstream task differs from
the distribution of the pretraining task. For example, we might pretrain the representation on a large
variety of natural images and then ask how the representation performs at distinguishing different
species of birds not seen during pretraining.
32.2.1.1 Linear classifiers and linear evaluation
Linear evaluation treats the trained neural network as a fixed feature extractor and trains a
linear classifier on top of fixed features extracted from a chosen network layer. In earlier work,
this linear classifier was often a support vector machine [Don+14; SR+14; Cha+14], but in more
recent work, it is typically an L
2
-regularized multinomial logistic regression classifier [ZIE17; KSL19;
KZB19]. The process of training this classifier is equivalent to attaching a new layer to the chosen
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
32.2. EVALUATING AND COMPARING LEARNED REPRESENTATIONS
representation layer and training only this new layer, with the rest of the network’s weights frozen
and any normalization/regularization layers set to “inference mode” (see Figure 32.2).
Although linear classifiers are conceptually simple compared to deep neural networks, they are
not necessarily simple to train. Unlike deep neural network training, objectives associated with
commonly-used linear classifiers are convex and thus it is possible to find global minima, but it can
be challenging to do so with stochastic gradient methods. When using SGD, it is important to
tune both the learning rate schedule and weight decay. Even with careful tuning, SGD may still
require substantially more epochs to converge when training the classifier than when training the
original neural network [KZB19]. Nonetheless, linear evaluation with SGD remains a commonly used
approach in the representation learning literature.
When it is possible to maintain all features in memory simultaneously, it is possible to use full-batch
optimization method with line search such as L-BFGS in place of SGD [KSL19; Rad+21]. These
optimization methods ensure that the loss decreases at every iteration of training, and thus do not
require manual tuning of learning rates. To obtain maximal accuracy, it is still important to tune
the amount of regularization, but this can be done efficiently by sweeping this hyperparameter and
using the optimal weights for the previous value of the hyperparameter as a warm start. Using a
full-batch optimizer typically implies precomputing the features before performing the optimization,
rather than recomputing features on each minibatch. Precomputing features can save a substantial
amount of computation, since the forwards passes through the frozen model are typically much more
expensive than computing the gradient of the linear classifier. However, precomputing features also
limits the number of augmentations of each example that can be considered.
It is important to keep in mind that the accuracy obtainable by training a linear classifier on a finite
dataset is only a lower bound on the accuracy of the Bayes-optimal linear classifier. The datasets
used for linear evaluation are often small relative to the number of parameters to be trained, and
the classifier typically needs to be regularized to obtain maximal accuracy. Thus, linear evaluation
accuracy depends not only on whether it is possible to linearly separate different classes in the
representation, but also on how much data is required to find a good decision boundary with a
given training objective and regularizer. In practice, even an invertible linear transformation of a
representation can affect linear evaluation accuracy.
32.2.1.2 Fine-tuning
It is also possible to adapt all layers from the pretraining task to the downstream task. This process
is typically referred to as fine-tuning [HS06b; Gir+14]. In its simplest form, fine-tuning, like
linear evaluation, involves attaching a new layer to a chosen representation layer, but unlike linear
evaluation, all network parameters, and not simply those of the new layer, are updated according to
gradients computed on the downstream task. The new layer may be initialized with zeros or using
the solution obtained by training it with all other parameters frozen. Typically, the best results are
obtained when the network is fine-tuned at a lower learning rate than was used for pretraining.
Fine-tuning is substantially more expensive than training a linear classifier on top of fixed feature
representations, since each training step requires backpropagating through multiple layers. However,
fine-tuned networks typically outperform linear classifiers, especially when the pretraining and
downstream tasks are very different [KSL19; AGM14; Cha+14; Azi+15]. Linear classifiers perform
better only when the number of training examples is very small (~5 per class) [KSL19].
Fine-tuning can also involve adding several new network layers. For detection and segmentation
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1042
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
tasks, which require fine-grained knowledge of spatial position, it is common to add a feature pyramid
network (FPN) [Lin+17b] that incorporates information from different feature maps in the pretrained
network. Alternatively, new layers can be interspersed between old layers and initialized to preserve
the network’s output. Net2Net [CGS15] follows this approach to construct a higher-capacity network
that makes use of representations contained in the pretrained weights of a smaller network, whereas
adapter modules [Hou+19] incorporate new, parameter-efficient modules into a pretrained network
and freeze the old ones to reduce the number of parameters that need to be stored when adapting
models to different tasks.
32.2.1.3 Disentanglement
Given knowledge about how a dataset was generated, for example that there are certain factors of
variation such as position, shape, and color that generated the data, we often wish to estimate how
well we can recover those factors in our learned representation. This requires using disentangled
representation learning methods (see Section 21.3.1.1). While there are a variety of metrics for
disentanglement, most measure to what extent there is a one-to-one correspondence between latent
factors and dimensions of the learned representation.
32.2.2 Representational similarity
Rather than measure compatibility between a representation and a downstream task, we might seek
to directly examine relationships between two fixed representations without reference to a task. In
this section, we assume that we have two sets of fixed representations corresponding to the same
n examples. These representations could be extracted from different layers of the same network
or layers of different neural networks, and need not have the same dimensionality. For notational
convenience, we assume that each set of representations has been stacked row-wise to form matrices
X ∈ R
n×p1 and Y ∈ R
n×p2 such that Xi,: and Yi,: are two different representations of the same
example.
32.2.2.1 Representational similarity analysis and centered kernel alignment
Representational similarity analysis (RSA) is the dominant technique for measuring similarity
of representations in neuroscience [KMB08], but has also been applied in machine learning. RSA
reduces the problem of measuring similarity between representation matrices to measuring the
similarities between representations of individual examples. RSA begins by forming representational
similarity matrices (RSMs) from each representation. Given functions k : X × X 7→ R and k
′
:
Y × Y 7→ R that measure the similarity between pairs of representations of individual examples
x, x
′ ∈ X , and y, y
′ ∈ Y, the corresponding representational similarity matrices K, K′ ∈ R
n×n
contain the similarities between the representations of all pairs of examples Kij = k(Xi,:
, Xj,:) and
K′
ij = k
′
(Yi,:
,Yj,:). These representational similarity matrices are transformed into a scalar similarity
value by applying a matrix similarity function s(K, K′
).
The RSA framework can encompass many different forms of similarity through the selection of the
similarity functions k(·, ·), k
′
(·, ·), and s(·, ·). How these functions should be selected is a contentious
topic [BS+20; Kri19]. In practice, it is common to choose k(x, x
′
) = k
′
(x, x
′
) = corr[x, x
′
], the
Pearson correlation coefficient between examples. s(·, ·) is often chosen to be the Spearman rank
correlation between the representational similarity matrices, which is computed by reshaping K and
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
32.2. EVALUATING AND COMPARING LEARNED REPRESENTATIONS
K′
to vectors, computing the rankings of their elements, and measuring the Pearson correlation
between these rankings.
Centered kernel alignment (CKA) is a technique that was first proposed in machine learning
literature [Cri+02; CMR12] but that can be interpreted as a form of RSA. In centered kernel
alignment, the per-example similarity functions k and k
′ are chosen to be positive semi-definite
kernels so that K and K′ are kernel matrices. The matrix similarity function s is the cosine similarity
between centered kernel matrices
s(K, K′
) = hHKH, HK′HiF
kHKHkFkHK′HkF
, (32.1)
where hA, BiF = vec(A)
⊤vec(B) = tr(A⊤B) is the Frobenius product, and H = I −
1
n
11⊤ is the
centering matrix. As it is applied above, the centering matrix subtracts the means from the rows
and columns of the similarity index.
A special case of centered kernel alignment arises when k and k
′ are chosen to be the linear kernel
k(x, x
′
) = k
′
(x, x
′
) = x
⊤x
′
. In this case, K = XX⊤ and K′ = Y Y ⊤, allowing for an alternative
expression for CKA in terms of the similarities between pairs of features rather than pairs of examples.
The representations themselves must first be centered by subtracting the means from their columns,
yielding X˜ = HX and Y˜ = HY . Then, so-called linear centered kernel alignment is given by
s(K, K′
) = hX˜ X˜ ⊤,Y˜ Y˜ ⊤iF
kX˜ X˜ ⊤kFkY˜ Y˜ ⊤kF
=
kX˜ ⊤Y˜ k
2
F
kX˜ ⊤X˜ kFkY˜ ⊤Y˜ kF
. (32.2)
Linear centered kernel alignment is equivalent to the RV coefficient [RE76] between centered features,
as shown in [Kor+19].
32.2.2.2 Canonical correlation analysis and related methods
Given two datasets (in this case, the representation matrices X and Y ), canonical correlation
analysis or CCA (Section 28.3.4.3) seeks to map both datasets to a shared latent space such that
they are maximally correlated in this space. The i
th pair of canonical weights (wi
, w′
i
) maximize
the correlation between the corresponding canonical vectors ρi = corr[Xwi
,Y w′
i
] subject to the
constraint that the new canonical vectors are orthogonal to previous canonical vectors,
maximize corr[Xwi
,Y w′
i
]
subject to ∀j<i Xwi ⊥ Xwj
∀j<i Y w′
i ⊥ Y w′
j
kXwik = kY w′
ik = 1.
(32.3)
The maximum number of non-zero canonical correlations is the minimum of the ranks, p =
min(rk(X),rk(Y )).
The standard algorithm for computing the canonical weights and correlations [BG73] first decom￾poses the individual representations as the product of an orthogonal matrix and a second matrix,
X˜ = QR : Q⊤Q = I and Y˜ = Q′R′
: Q′⊤Q′ = I. These decompositions can be obtained either
by QR factorization or singular value decomposition. A second singular value decomposition of
Q⊤Q′ = UΣV
⊤ provides the quantities needed to determine the canonical weights and correlations.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1044
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Specifically, the canonical correlations are the singular values ρ = diag(Σ); the canonical vectors
are the columns of XW = QU and Y W′ = Q′V ; and the canonical weights are W = R−1U and
W′ = R′−1V .
Two common strategies to turn the resulting vector of canonical correlations into a scalar are to
take the mean squared canonical correlation,
R
2
CCA(X,Y ) = kρk
2
2/p = kQ⊤Q′
k
2
F/p, (32.4)
or the mean canonical correlation,
ρ¯ =
Xp
i=1
ρi/p = kQ⊤Q′
k∗/p, (32.5)
where k · k∗ denotes the nuclear norm. The mean squared canonical correlation has several alter￾native names, including Yanai’s GCD [Yan74; RBS84], Pillai’s trace, or the eigenspace overlap
score [May+19].
Although CCA is a powerful tool, it suffers from the curse of dimensionality. If at least one
representation has more neurons than examples and each neuron is linearly independent of the
others, then all canonical correlations are 1. In practice, because neural network representations are
high-dimensional, we can find ourselves in the regime where there are not enough data to accurately
estimate the canonical correlations. Moreover, even when we can accurately estimate the canonical
correlations, it may be desirable for a similarity measure to place less emphasis on the similarity of
low-variance directions.
Singular vector CCA (SVCCA) mitigates these problems by retaining only the largest principal
components of X˜ and Y˜ when performing CCA. Given the singular value decomposition of the
representations X˜ = UΣV
⊤ and Y˜ = U′Σ′V
′⊤, SVCCA retains only the first k columns of U
corresponding to the largest k singular values of σ = diag(Σ) (i.e., the k largest principal components)
and the first k
′
columns of U′
corresponding to the largest k
′
singular values σ
′ = diag(Σ′
). With
these singular value decompositions, the canonical correlations, vectors, and weights can then be
computed using the algorithm of Björck and Golub [BG73] described above, by setting
Q = U:,1:k, R = Σ1:k,1:kV
⊤
:,1:k
, Q′ = U
′
:,1:k
, R′ = Σ′
1:k,1:kV
′⊤
:,1:k
. (32.6)
Raghu et al. [Rag+17] suggest retaining enough components to explain 99% of the variance, i.e.,
setting k to the minimum value such that kσ1:kk
2/kσk
2 = 0.99 and k
′
to the minimum value such
that kσ
′
1:k′k
2/kσ
′k
2 = 0.99. However, for a fixed value of min(k, k′
), CCA-based similarity measures
increase with the value of max(k, k′
). Representations that require more components to explain 99%
of the variance of representations may thus appear “more similar” to all other representations than
representations with more rapidly decaying singular value spectra. In practice, it is often better to
set k and k
′
to the same fixed value.
Projection-weighted CCA (PWCCA) [MRB18] instead weights the correlations by a measure
of the variability in the original representation that they explain. The resulting similarity measure is
PWCCA(X,Y ) =
Pp
P
i=1 αiρi
p
i=1 αi
, αi = k(Y w′
i
)
⊤Y k1. (32.7)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
32.2. EVALUATING AND COMPARING LEARNED REPRESENTATIONS
PWCCA enjoys somewhat widespread use in representational similarity literature, but it has po￾tentially undesirable properties. First, it is asymmetric; its value depends on which of the two
representations is used for the weighting. Second, it is unclear why weightings should be determined
using the L
1 norm, which is not invariant to rotations of the representation. It is arguably more
intuitive to weight the correlations directly by the amount of variance in the representation that
the canonical component explains, which corresponds to replacing the L
1 norm with the squared L
2
norm. The resulting similarity measure is
R
2
LR(X,Y ) =
Pp
i=1 α
′
i
ρ
2
P
i
p
i=1 α
′
i
, α
′
i =
Xp2
j=1
k(Y w′
i
)
⊤Y k
2
2
. (32.8)
As shown by Kornblith et al. [Kor+19], when p2 ≥ p1, this alternative similarity measure is equivalent
to the overall variance explained by using linear regression to fit every neuron in Y˜ using the
representation X˜ ,
R
2
LR(X,Y ) = 1 −
Xp2
i=1
min
β
kY˜
:,i − Xβ˜ k
2
/kY˜ k
2
F. (32.9)
Finally, there is also a close relationship between CCA and linear CKA. This relationship can
be clarified by writing similarity indexes directly in terms of the singular value decompositions
X˜ = UΣV
⊤ and Y˜ = U′Σ′V
′⊤. The left-singular vectors ui = U:,i correspond to the principal
components of X normalized to unit length, and the squared singular values λi = Σ2
ii are the amount
of variance that those principal components explain (up to a factor of 1/n). Given these singular
value decompositions, R2
CCA, R2
LR, and linear CKA become:
R
2
CCA(X,Y ) = Xp1
i=1
Xp2
j=1
￾
u
⊤
i u
′
j
2
/p1 (32.10)
R
2
LR(X,Y ) = Xp2
i=1
Xp2
j=1
λ
′
j
￾
u
⊤
i u
′
j
2
/
Xp2
j=1
λ
′
j
(32.11)
CKAlinear(X,Y ) =
Pp1
i=1
Pp2
j=1 λiλ
′
j
￾
u
⊤
i u
′
j
2
pPp1
i=1 λ
2
i
qPp2
j=1 λ
′
j
2
. (32.12)
Thus, these similarity indexes all involve the similarities between all pairs of principal components
from X and Y , but place different weightings on these similarities according to the fraction of
variance that these principal components explain.
32.2.2.3 Comparing representational similarity measures
What properties are desirable in a representational similarity measure is an open question, and this
question may not have a unique answer. Whereas evaluations of downstream accuracy approximate
real-world use cases for neural network representations, the goal of representational similarity is
instead to develop understanding of how representations evolve across neural networks, or how they
differ between neural networks with different architectures or training settings.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND lice1046
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
One way to taxonomize different similarity measures is through the transformations of a repre￾sentation that they are invariant to. The minimum form of invariance is invariance to permutation
of a representation’s constituent neurons, which is needed because neurons in neural networks gen￾erally have no canonical ordering: for commonly-used initialization strategies, any permutation of
a given initialization is equiprobable, and nearly all architectures and optimizers produce training
trajectories that are equivariant under permutation. On the other hand, invariance to arbitrary
invertible transformations, as provided by mutual information, is clearly undesirable, since many
realistic neural networks are injective functions of the input [Gol+19] and thus there always exists an
invertible transformation between any pair of representations. In practice, most similarity measures in
common use are invariant to rotations (orthogonal transformations) of representations, which implies
invariance to permutation. Similarity measures based solely on CCA correlations, such as R2
CCA and
ρ¯, are invariant to all invertible linear transformations of representations. However, SVCCA and
PWCCA are not.
A different way to distinguish similarity measures is to investigate situations where we know
the relationships among representations and to empirically evaluate their ability to recover these
relationships. Kornblith et al. [Kor+19] propose a simple “sanity check”: Given two architecturally
identical networks A and B trained from different random initializations, any layer in network A
should be more similar to the architecturally corresponding layer in network B than to any other
layer. They show that, when considering flattened representations of CNNs, similarity measures
based on centered kernel alignment satisfy this sanity check whereas other similarity measures do not.
By contrast, when considering representations of individual tokens in Transformers, all similarity
measures perform reasonably well. However, Maheswaranathan et al. [Mah+19] show that both
CCA and linear CKA are highly sensitive to seemingly innocuous RNN design choices such as the
activation function, even though analysis of the fixed points of the dynamics of different networks
suggests they all operate similarly.
32.3 Approaches for learning representations
The goal of representation learning is to learn a transformation of the inputs that makes it easier to
solve future tasks. Typically the tasks we want the representation to be useful for are not known when
learning the representation, so we cannot directly train to improve performance on the task. Learning
such generic representations requires collecting large-scale unlabeled or weakly-labeled datasets, and
identifying tasks or priors for the representations that one can solve without direct access to the
downstream tasks. Most methods focus on learning a parametric mapping z = fθ(x) that takes an
input x and transforms it into a representation z using a neural network with parameters θ.
The main challenge in representation learning is coming up with a task that requires learning
a good representation to solve. If the task is too easy, then it can be solved without learning an
interesting transformation of the inputs, or by learning a shortcut. If a task is too different from
the downstream task that the representation will be evaluated on, then the representation may also
not be useful. For example, if the downstream task is object detection, then the representation
needs to encode both the identity and location of objects in the image. However, if we only care
about classification, then the representation can discard information about position. This leads
to approaches for learning representations that are often not generic: different training tasks may
perform better for different downstream tasks.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
32.3. APPROACHES FOR LEARNING REPRESENTATIONS
Supervised Generative Self-Supervised
dog 90°
autoencoders image
completion
rotation
prediction
contrastive learning
attract repel
Schroff et al. 2016
Figure 32.2: Approaches for representation learning from images. An input image is encoded through a deep
neural network (green) to produce a representation (blue). An additional shallow or deep neural network
(yellow) is often used to train the representation, but is thrown out after the representation is learned when
solving downstream tasks. In the supervised case, the mapping from the representation to logits is typically
linear, while for autoencoders the mapping from representation to images can be highly complex and stochastic.
Unlike supervised or generative approaches, contrastive methods rely on other datapoints in the form of positive
pairs (often created through data augmentation) and negative pairs (typically other datapoints) to learn a
representation.
In Figue 32.2, we outline three approaches we will discuss for representation learning. Supervised
approaches train on large-scale supervised or weakly-supervised data using standard supervised
losses. Generative approaches aim to learn generative models of the dataset or parts of a dataset.
Self-supervised approaches are based on transformation prediction or multi-view learning, where
we design a task that where labels can be easily synthesized without needing human input.
32.3.1 Supervised representation learning and transfer
The first major successes in visual representation learning with deep learning came from networks
trained on large labeled datasets. Following the discovery that supervised deep neural networks could
outperform classical computer vision models for natural image classification [KSH12b; CMS12], it
became clear that the representations learned by these networks could outperform handcrafted features
used across a wide variety of tasks [Don+14; SR+14; Oqu+14; Gir+14]. Although unsupervised
visual representation learning has recently achieved competitive results on many domains, supervised
representation learning remains the dominant approach.
Larger networks trained on larger datasets generally achieve better performance on both pretrain￾ing and downstream tasks. When other design choices are held fixed, architectures that achieve
higher accuracy during pretraining on natural image datasets such as ImageNet also learn better
representations for downstream natural image tasks, as measured by both linear evaluation and
fine-tuned accuracy [KSL19; TL19; Zha+19a; Zha+21; Abn+21]. However, when the domain shift
from the pretraining task to the downstream task becomes larger (e.g., from ImageNet to medical
imaging), the correlation between pretraining and downstream accuracy can be much lower [Rag+19;
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1048
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Ke+21; Abn+21]. Studies that vary pretraining dataset size generally find that larger pretraining
datasets yield better representations for downstream tasks [HAE16; Mah+18; Kol+20; Zha+21;
Abn+21], although there is an interaction between model size and dataset. When training small
models with the intention of transferring to a specific downstream task, it is sometimes preferable to
pretrain on a smaller dataset that is more closely related to that task rather than a larger dataset
that is less closely related [Cui+18; Mah+18; Ngi+18; Kol+20], but larger models seem to derive
greater benefit from larger, more diverse datasets [Mah+18; Kol+20].
Whereas scaling the architecture and dataset size generally improves both pretraining and down￾stream accuracy, other design choices can improve pretraining accuracy at the expense of transfer, or
vice versa. Regularizers such as penultimate layer dropout and label smoothing improve accuracy
on pretraining tasks but produce worse representations for downstream tasks [KSL19; Kor+21].
Although most convolutional neural networks are trained with batch normalization, Kolesnikov
et al. [Kol+20] find that the combination of group normalization and weight standardization leads
to networks that perform similarly on pretraining tasks but substantially better on transfer tasks.
Adversarial training produces networks that perform worse on pretraining tasks as compared to
standard training, but these representations transfer better to other tasks [Sal+20]. For certain
combinations of pretraining and downstream datasets, increasing the amount of weight decay on
the network’s final layer can improve transferability at the cost of pretraining accuracy [Zha+21;
Abn+21].
The challenge of collecting ever-larger pretraining datasets has led to the emergence of weakly￾supervised representation learning, which eschews the expensive human annotations of datasets
such as ImageNet and instead relies on data that can be readily collected from the Internet, but which
may have greater label noise. Supervision sources include hashtags accompanying images on websites
such as Instagram and Flickr [CG15; Iza+15; Jou+16; Mah+18], image labels obtained automatically
using proprietary algorithms involving user feedback signals [Sun+17; Kol+20], or image captions/alt
text [Li+17a; SPL20; DJ21; Rad+21; Jia+21]. Hashtags and automatic labeling give rise to image
classification problems that closely resemble their more strongly supervised counterparts. The primary
difference versus standard supervised representation learning is that the data are noisier, but in
practice, the benefits of more data often outweigh the detrimental effects of the noise.
Image-text supervision has provided more fertile ground for innovation, as there are many
different ways of jointly processing text and images. The simplest approach is again to convert the
data into an image classification problem, where the network is trained to predict which words or
n-grams appear in the text accompanying a given image [Li+17a]. More sophisticated approaches
train image-conditional language models [DJ21] or masked language models [SPL20], which can make
better use of the structure of the text. Recently, there has been a surge in interest in contrastive
image/text pretraining models such as CLIP [Rad+21] and ALIGN [Jia+21], details of which we
discuss in Section 32.3.4. These models process images and text independently using two separate
“towers”, and learn an embedding space where embeddings of images lie close to the embeddings of
the corresponding text. As shown by Radford et al. [Rad+21], contrastive image/text pretraining
learns high-quality representations faster than alternative approaches.
Beyond simply learning good visual representations, pretrained models that embed image and text
in a common space enable zero-shot transfer of learned representations. In zero-shot transfer, an
image classifier is constructed using only textual descriptions of the classes of interest, without any
images from the downstream task. Early co-embedding models relied on pretrained image models and
word embeddings that were then adapted to a common space [Fro+13], but contrastive image/text
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
32.3. APPROACHES FOR LEARNING REPRESENTATIONS
pretraining provides a means to learn co-embedding models end-to-end. Compared to linear classifiers
trained using image embeddings, zero-shot classifiers typically perform worse, but zero-shot classifiers
are far more robust to distribution shift [Rad+21].
32.3.2 Generative representation learning
Supervised representation learning often fails to learn representations for tasks that differ significantly
from the task the representation was trained on. How can we learn representations when the task we
wish to solve differs a lot from tasks where we have large labeled datasets?
Generative representation learning aims to model the entire distribution of a dataset q(x)
with a parametric model pθ(x). The hope of generative representation learning is that. if we can build
models that can create all the data that we have seen, then we implicitly may learn a representation
that can be used to answer any question about the data, not just the questions that are related to a
supervised task for which we have labels. For example, in the case of digit classification, it is hard
to collect labels for the style of a handwritten digit, but if the model has to product all possible
handwritten digits in our dataset it needs to learn to produce digits with different styles. On the
other hand, supervised learning to classify digits aims to learn a representation that is invariant to
style.
There are two main approaches for learning representations with generative models: (1) latent￾variable models that aim to capture the underlying factors of variation in data with latent variables z
that act as the representation (see the chapter on VAEs, Chapter 21), and (2) fully-observed models
where a neural architecture is trained with a tractable generative objective (see the chapters on AR
models, Chapter 22, and flow models, Chapter 23), and then a representation is extracted from the
learned architecture.
32.3.2.1 Latent-variable models
One criterion for learning a good representation of the world is that it is useful for synthesizing
observed data. If we can build a model that can create new observations, and has a simple set of
latent variables, then hopefully this model will learn variables that are related to the underlying
physical process that created the observations. For example, if we are trying to model a dataset of
2d images of shapes, knowing the position, size, and type of the shape would enable easy synthesis
of the image. This approach to learning is known as analysis-by-synthesis, and is a theory of
perception that aims at identifying a set of underlying latent factors (analysis) that could be used to
synthesize observations [Rob63; Bau74; LM03]. Our goal is to learn a generative model pθ(x, z) over
the observations x and latents z, with parameters θ. Given an observation x, performing the analysis
step to extract a representation requires running inference to sample or compute the posterior mean
of pθ(z|x). Different choices for the model pθ(x, z) and inference procedure for pθ(z|x) represent
different ways of learning representations from a dataset.
Early work on deep latent-variable generative models aimed to learn stacks of features often based
on training simple energy-based models or directed sparse coding models, each of which could explain
the previous set of latent factors, and which learned increasingly abstract representation [HOT06b;
Lee+09; Ran+06]. Bengio, Courville, and Vincent [BCV13] provide an overview of several methods
based on stacking latent-variable generative modeling approaches to learn increasingly abstract
representation. However greedy approaches to generative representation learning have failed to scale
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1050
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
to larger natural datasets.
If the generative process that created the data is simple and can be described, then encoding
that structure into a generative model is a tremendously powerful way of learning useful and robust
representations. Lake, Salakhutdinov, and Tenenbaum [LST15] and George et al. [Geo+17] use
knowledge of how characters are composed of strokes to build hierarchical generative models with
representations that excel at several downstream tasks. However, for many real-world datasets the
generative structure is not known, and the generative model must also be learned. There is often a
tradeoff between imposing structure in the generative process (such as sparsity) vs. learning that
structure from data.
Directed latent-variable generative models have proven easier to train and scale to natural datasets.
Variational autoencoders (Chapter 21) train a directed latent-variable generative model with varia￾tional inference, and learn a prior pθ(z), decoder pθ(x|z), and an amortized inference network qφ(z|x)
that can be used to extract a representation on new datapoints. Higgins et al. [Hig+17b] show
β-VAEs (Section 21.3.1) are capable of learning latent variables that correspond to factors of variation
on simple synthetic datasets. Kingma et al. [Kin+14b] and Rasmus et al. [Ras+15] demonstrate
improved performing on semi-supervised learning with VAEs. While there have been several recent
advances to scale up VAEs to natural datasets [VK20b; Chi21b], none of these methods have yet led
to representations that are competitive for downstream tasks such as classification or segmentation.
Adversarial methods for training directed latent-variable models have also proven useful for
representation learning. In particular, GANs (Chapter 26) trained with encoders such as BiGAN
[DKD17], ALI [Dum+17], and [Che+16] were able to learn representations on small scale datasets
that performed well at object classification. The discriminators from GANs have also proven useful
for learning representations [RMC16b]. More recently, these methods were scaled up to ImageNet
in BigBiGAN [DS19], with learned representations that performed strongly on classification and
segmentation tasks.
32.3.2.2 Fully observed models
The neural network architectures used in fully observed generative models can also learn useful
representations without the presence of latent-variables. ImageGPT [Che+20a] demonstrate that
an autoregressive model trained on pixels can learn internal representations that excel at image
classification. Unlike with latent-variable models where the representation is often thought of as the
latent variables, ImageGPT extracted representations from the deterministic layers of the transformer
architecture used to compute future tokens. Similar approaches have shown progress for learning
features in language modeling [Raf+20b], however alternative objectives, based on masked training
(as in BERT, [Dev+19]), often leads to better performance.
32.3.2.3 Autoencoders
A related set of methods for representation learning are based on learning a representation from
which the original data can be reconstructed. These methods are often called autoencoders (see
Section 16.3.3), as the data is encoded in a way such that the input data itself can be recreated.
However, unlike generative models, they cannot typically be used to synthesize observations from
scratch or assign likelihoods to observations. Autoencoders learn an encoder that outputs a repre￾sentation z = fθ(x), and a decoder gφ(z) that takes the representation z and tries to recreate the
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
32.3. APPROACHES FOR LEARNING REPRESENTATIONS
input data, x. The quality of the approximate reconstruction , xˆ = gφ(z) is often measured using a
domain-specific loss, for example mean-squared error for images:
L(θ, φ) = 1
|D|
X
x∈D
kx − gφ(fθ(x))k
2
2
. (32.13)
If there are no constraints on the encoder or decoder, and the dimensionality of the representation
z matches the dimensionality of the input x, then there exists a trivial solution to minimize the
autoencoding objective: set both fθ and gφ to identity functions. In this case the representation has
not learned anything interesting, and thus in practice an additional regularizer is often placed on the
learned representation.
Reducing the dimensionality of the representation z is one effective mechanism to avoid trivial
solutions to the autoencoding objective. If both the encoder and decoder networks are linear, and
the loss is mean-squared-error, then the resulting linear autoencoder model can learn the principal
components of a dataset [Pla18].
Other methods maintain higher-dimensional representations by adding sparsity (for example,
penalties on kzk1 in Ng et al. [Ng+11]) or smoothness regularizers [Rif+11], or adding noise to the
input [Vin+08] or intermediate layers of the network [Sri+14b; PSDG14]. These added regularizers
aim to bias the encoder and decoder to learn representations that are not just the identity function,
but instead are nonlinear transformations of the input that may be useful for downstream tasks. See
Bengio, Courville, and Vincent [BCV13] for a more detailed discussion of regularized autoencoders
and their applications. A recent re-evaluation of several algorithms based on iteratively learning
features by stacked regularized autoencoders have been shown to degrade performance versus training
end-to-end from scratch [Pai+14]. However, we will see in Section 32.3.3.1 that denoising autoencoders
have shown promise for representation learning in discrete domains and when applied with more
complex noise and masking patterns.
32.3.2.4 Challenges in generative representation learning
Despite several success in generative representation learning, they have empirically fallen behind.
Generative methods for representation learning have to learn to match complex high-dimensional
and diverse training datasets, which requires modeling all axis of variation of the inputs, regardless
of whether they are semantically relevant for downstream tasks. For example, the exact pattern of
blades of grass in an image matter for generation quality, but are unlikely to be useful for many of
the semantic evaluations that are typically used. Ways to bias generative models to focus on the
semantic features and ignore “noise” in the input is an open area of research.
32.3.3 Self-supervised representation learning
When given large amounts of labeled data, standard supervised learning is a powerful mechanism
for training deep neural networks. When only presented with unlabeled data, building generative
models requires modeling all variations in a dataset, and is often not explicit about what is the
signal and noise that we aim to capture in a representation. The methods and architectures for
building these generative models also differs substantially from those of supervised learning, where
largely feedforward architectures are used to predict low-dimensional representations. Instead of
trying to model all aspects of variation, self-supervised learning aims to design tasks where labels
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1052
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
can be generated cheaply, and help to encode the structure of what we may care about for other
downstream tasks. Self-supervised learning methods allow us to apply the tools and techniques of
supervised learning to unlabeled data by designing a task for which we can cheaply produce labels.
In the image domain, several self-supervised tasks, also known as pretext tasks, have been proven
effective for learning representations. Models are trained to perform these tasks in a supervised
fashion using data generated by the pretext task, and then the learned representation is transferred
to a target task of interest (such as object recognition), by training a linear classifier or fine-tuning
the model in a supervised fashion.
32.3.3.1 Denoising and masked prediction
Generative representation learning is challenging because generative models must learn to produce
the entire data distribution. A simpler option is denoising, in which some variety of noise is added to
the input and the model is trained to reconstruct the noiseless input. A particularly successful variant
of denoising is masked prediction, in which input patches or tokens are replaced with uninformative
masks and the network is trained to predict only these missing patches or tokens.
The denoising autoencoder [Vin+08; Vin+10a] was the first deep model to exploit denoising for
representation learning. A denoising autoencoder resembles a standard autoencoder architecturally,
but it is trained to perform a different task. Whereas a standard autoencoder attempts to reconstruct
its input exactly, a denoising autoencoder attempts to produce a noiseless output from a noisy input.
Vincent et al. [Vin+08] argue that the network must learn the structure of the data manifold in order
to solve the denoising task.
Newer approaches retain the conceptual approach of the denoising autoencoder, but adjust the
masking strategy and objective. BERT [Dev+18] introduced the masked language modeling
task, where 15% of the input tokens are selected for masking and the network is trained to predict
them. 80% of the time, these tokens are replaced with an uninformative [MASK] token. However, the
[MASK] token does not appear at fine-tuning time, producing some domain shift between pretraining
and fine-tuning. Thus, 10% of the time, tokens are replaced with random tokens, and 10% of the
time, they are left intact. BERT and the masked language modeling task have been extremely
influential for representation learning in natural language processing, inspiring substantial follow-up
work [Liu+19c; Jos+20].
Although denoising-based approaches to representation learning were first employed for computer
vision, they received little attention for the decade that followed. Vincent et al. [Vin+08] greedily
trained stacks of up to three denoising autoencoders that were then fine-tuned end-to-end to perform
digit classification, but greedy unsupervised pretraining was abandoned as it was shown that it
was possible to attain good performance using CNNs and other architectures trained end-to-end.
Context encoders [Pat+16] mask contiguous image regions and train models to perform inpainting,
achieving transfer learning performance competitive with other contemporary unsupervised visual
representation learning methods. The use of image colorization as a pretext task [ZIE16; ZIE17] is also
related to denoising in that colorization involves reconstructing the original image from a corrupted
input, although generally color is dropped in a deterministic fashion rather than stochastically.
Recently, the success of BERT in NLP has inspired new approaches to visual representation learning
based on masked prediction. Image GPT [Che+20a] trained a transformer directly upon pixels to
perform a BERT-style masked image modeling task. While the resulting model achieves very high
accuracy when fine-tuned CIFAR-10, the cost of self-attention is quadratic in the number of pixels,
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
32.3. APPROACHES FOR LEARNING REPRESENTATIONS
encoder
....
....
decoder
input target
Figure 32.3: Masked autoencoders learn a representation of images by randomly masking out input patches
and trying to predict them (from He et al. [He+21]).
limiting applicability to larger image sizes. BEiT [Bao+22b] addresses this challenge by combining
the idea of masked image modeling with the patch-based architecture of vision transformers [Dos+21].
BEiT splits images into 16×16 pixel image patches and then discretizes these patches using a discrete
VAE [Ram+21b]. At training time, 40% of tokens are masked. The network receives continuous
patches as input and is trained to predict the discretized missing tokens using a softmax over all
possible tokens.
The masked autoencoder or MAE [He+22] further simplifies the masked image modeling task
(see Figure 32.3). The MAE eliminates the need to discretize patches and instead predicts the
constituent pixels of each patch directly using a shallow decoder trained with L2 loss. Because the
MAE encoder operates only on the unmasked tokens, it can be trained efficiently even while masking
most (75%) of the tokens. Models pretrained using masked prediction and then fine-tuned with
labels currently hold the top positions on the ImageNet leaderboard among models trained without
additional data [He+22; Don+21].
32.3.3.2 Transformation prediction
An even simpler approach to representation learning involves applying a transformation to the
input image and then predicting the transformation that was applied (see Figure 32.4). This
prediction task is usually formulated as a classification problem. For visual representation learning,
transformation prediction is appealing because it allows reusing exactly the same training pipelines
as standard supervised image classification. However, it is not clear that networks trained to perform
transformation prediction tasks learn rich visual representations. Transformation prediction tasks
are potentially susceptible to “shortcut” solutions, where networks learn trivial features that are
nonetheless sufficient to solve the task with high accuracy. For many years, self-supervised learning
methods based on transformation prediction were among the top-performing methods, but they have
since been displaced by newer methods based on contrastive learning and masked prediction.
Some pretext tasks operate by cutting images into patches and training networks to recover the
spatial arrangement of the patches. In context prediction [DGE15], a network receives two adjacent
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1054
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Input Context encoders
, 
upper 
left
upper 
right
, 
Jigsaw puzzles Rotation
90°
180°
Figure 32.4: Transformation prediction involves training neural networks to predict a transformation applied
to the input. Context encoders predict the position of a second crop relative to the first. The jigsaw puzzle
task involves predicting the way in which patches have been permuted. Rotation prediction involves predicting
the rotation that was applied to the input.
image patches as input and is trained to recover their spatial relationship by performing an eight-class
classification problem. To prevent the network from directly matching the pixels at the patch borders,
the two patches must be separated by a small variable gap. In addition, to prevent networks from
using chromatic aberration to localize the patches relative to the lens, color channels must be distorted
or stochastically dropped. Other work has trained networks to solve jigsaw puzzles by splitting
images into a 3 × 3 grid of patches [NF16]. The network receives shuffled patches as input and learns
to predict how they were permuted. By limiting the permutations to a subset of all possibilities, the
jigsaw puzzle task can be formulated as a standard classification task [NF16].
Another widely used pretext task is rotation prediction [GSK18], where input images are rotated 0,
90, 180, or 270 degrees and networks are trained to classify which rotation was applied. Although this
task is extremely simple, the learned representations often perform better than those learned using
patch-based methods [GSK18; KZB19]. However, all approaches based on transformation prediction
currently underperform masked prediction and multiview approaches on standard benchmark datasets
such as CIFAR-10 and ImageNet.
32.3.4 Multiview representation learning
The field of multiview representation learning aims to learn a representation where “similar”
inputs or views of an input are mapped nearby in the representation space, and “dissimilar” inputs are
mapped further apart. This representation space is often high-dimensional, and relies on collecting
data or designing a task where one can generative “positive” pairs of examples that are similar,
and “negative” pairs of examples that are dissimilar. There are many motivations and objectives
for multiview representation learning, but all rely on coming up with sets of positive pairs, and a
mechanism to prevent all representations from collapsing to the same point. Here we use the term
multiview representation learning to encompass contrastive learning which combines positive and
negative pairs, metric learning, and “non-contrastive” learning which eliminates the need for negative
pairs.
Unlike generative methods for representation learning, multiview representation learning makes
it easy to incorporate prior knowledge about what inputs should be closer in the embedding space.
Furthermore, these inputs need not be from the same modality, and thus multiview representation
learning can be applied with rich multimodal datasets. The simplicity of the way in which prior
knowledge can be incorporated into a model through data has made multiview representation learning
one of the most powerful and performant methods for learning representations.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
32.3. APPROACHES FOR LEARNING REPRESENTATIONS
"happy dog"
"angry cat"
Figure 32.5: Positive and negative pairs used by different multiview representation learning methods.
While there are a variety of methods for multiview representation learning, they all involve a
repulsion component that pulls positive pairs closer together in embedding space, and a mechanism
to prevent collapse of the representation to a single point in embedding space. We begin by describing
loss functions for multiview representation learning and how they combine attractive and repulsive
terms to shape the representation, then discuss the role of view generation, and finally practical
considerations in deploying multiview representation learning.
32.3.4.1 View selection
Multiview representation learning depends on a datapoint or “anchor” x, a positive example x
+ that
x will be attracted to, and zero or more negative examples x
− that x is repelled from. We assume
access to a data-generating process for the positive pair: p
+(x, x+), and a process that generates the
negative examples given the datapoint x: p
−(x
−|x). Typically p
+(x, x+) generate (x, x+) that are
different augmentations of an underlying image from the dataset, and x
− represents an augmented
view of a different random image from the dataset. The generative process for x
− is then independent
of x, i.e., p
−(x
−|x) = p
−(x
−).
The choice of views used to generate positive and negative pairs is critical to the success of
representation learning. Figure 32.5 shows the positive pair (x, x+) and negative x
− for several
methods which we discuss below: SimCLR, CMC, SupCon, and CLIP.
SimCLR [Che+20c] creates positive pairs by applying two different data augmentations defined by
transformations t and t
′
to an initial image x0 twice: x = t(x0), x+ = t(x0). The data augmentations
used are random crops (with horizontal flips and resize), color distortion, and Gaussian blur. The
strengths of these augmentations (e.g., the amount of blur) impact performance and are typically
treated as a hyperparameter.
If we access to additional information, such as a categorical label, we can use this to select positive
pairs with the same label, and negative pairs with different labels. The resulting objective, when used
with a contrastive loss, is called SupCon [Kho+20], and resembles neighborhood component analysis
[Gol+04]. It was shown to improve robustness when compared to standard supervised learning.
Contrastive multiview coding (CMC) [TKI20] generates views by splitting an initial image
into orthogonal dimensions, such as the luma and chroma dimensions. These views are now no
longer in the same space (or same dimensionality), and thus we must learn different encoders for the
different inputs. However, the output of these encoders all live in the same-dimensional embedding
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1056
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
space, and can be used in contrastive losses. At test-time, we can then combine embeddings from
these different views through averaging or concatenation.
Views do not need to be from the same modality. CLIP [Rad+21] uses contrastive learning on
image-text pairs, where x is an image, and x
+ and x
− are text descriptions. When applied to massive
datasets of image-text pairs scraped from the Internet, CLIP is able to learn robust representations
without any of the additional data augmentation needed by SimCLR or other image-only contrastive
methods.
In most contrastive methods, negative examples are selected by randomly choosing x
+ from
other elements in a minibatch. However, if the batch size is small it may be the case that none of
the negative examples are close in embedding space to the positive example, and so learning may
be slow. Instead of randomly choosing negatives, they may be chosen more intelligently through
hard negative mining that selects negative examples that are close to the positive example in
embedding space [Fag+18]. This typically requires maintaining and updating a database of negative
examples over the course of training; this incurs enough computational overhead that the technique
is infrequently used. However, reweighting examples within a minibatch can also lead to improved
performance [Rob+21].
The choice of positive and negative views directly impacts what features are learned and what
invariances are encouraged. Tian et al. [Tia+20] discusses the role of view selection on the learned
representations, showing how choosing positives based on shared attributes (as in SupCon) can lead
to learning those attributes or ignoring them. They also present a method for learning views (whereas
all prior approaches fix views) based on targeting a “sweet spot” in the level of mutual information
between the views that is neither too high or too low. However, understanding what views will work
well for what downstream tasks remains an open area of study.
32.3.4.2 Contrastive losses
Given p
+ and p
−, we seek loss functions that learn an embedding fθ(x) where x and x
+ are close in
the embedding space, while x and x
− are far apart. This is called metric learning.
Chopra, Hadsell, LeCun, et al. [CHL+05] present a family of objectives that implements this
intuition by enforcing the distance between negative pairs to always be at least ǫ bigger than the
distance between positive pairs. The contrastive loss as instantiated in [HCL06] is:
Lcontrastive = Ex,x+,x−

kfθ(x) − fθ(x
+)k
2 + max(0, ǫ − kfθ(x) − fθ(x
−)k
2

. (32.14)
This loss pulls together the positive pairs by making the squared ℓ2 distance between them small,
and tries to ensure that negative pairs are at least a distance of ǫ apart. One challenge with using
the contrastive loss in practice is tuning the hyperparameter ǫ.
Similarly, the triplet loss [SKP15] tries to ensure that the positive pair (x, x+) is always at least
some distance ǫ closer to each other than the negative pair (x, x−):
Ltriplet = Ex,x+,x−

max(0, kfθ(x) − fθ(x
+)k
2 − kfθ(x) − fθ(x
−)k
2 + ǫ)

. (32.15)
A downside to the triplet loss approach is that one has to be careful about choosing hard negatives:
if the negative pair is already sufficiently far away then the objective function is zero and no learning
occurs.
An alternative contrastive loss which has gained popularity due to its lack of hyperparameters and
empirical effectiveness is known as the InfoNCE loss [OLV18b] or the multiclass N-pair loss
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
32.3. APPROACHES FOR LEARNING REPRESENTATIONS
[Soh16]:
LInfoNCE = −Ex,x+,x
−
1:M
"
log
exp fθ(x)
T
gφ(x
+)
exp fθ(x)
T gφ(x+) + PM
i=1 exp fθ(x)
T gφ(x
−
i
)
#
, (32.16)
where M are the number of negative examples. Typically the embeddings f(x) and g(x
′
) are ℓ2-
normalized, and an additional hyperparameter τ can be introduced to rescale the inner products
[Che+20c]. Unlike the triplet loss, which uses a hard threshold of ǫ, LInfoNCE can always be improved
by pushing negative examples further away. Intuitively, the InfoNCE loss ensures that the positive
pair is closer together than any of the M negative pairs in the minibatch. The InfoNCE loss
can be related to a lower bound on the mutual information between the input x and the learned
representation z [OLV18b; Poo+19a]:
I(X;Z) ≥ log M − LInfoNCE, (32.17)
and has also been motivated as a way of learning representations through the InfoMax principle
[OLV18b; Hje+18; BHB19]. When applying the InfoNCE loss to parallel views that are the same
modality and dimension, the encoder fθ for the anchor x and the positive and negative examples gφ
can be shared.
32.3.4.3 Negative-free losses
Negative-free representation learning (sometimes called non-contrastive representation
learning) learns representations using only positive pairs, without explicitly constructing negative
pairs. Whereas contrastive methods prevent collapse by enforcing that positive pairs are closer
together than negative pairs, negative-free methods make use of other mechanisms. One class of
negative-free objectives includes both attractive terms and terms that prevent collapse. Another
class of methods uses objectives that include only attractive terms, and instead relies on the learning
dynamics to prevent collapse.
The Barlow Twins loss [Zbo+21] is
LBT =
Xp
i=1
(1 − Cii)
2 + λ
Xp
i=1
X
j6=i
C
2
ij (32.18)
where C is the cross-correlation matrix between two batches of features that arise from the two views.
The first term is an attractive term that encourages high similarity between the representations of
the two views, whereas the second term prevents collapse to a low-rank representation. The loss is
minimized when C is the identity matrix. Similar losses based on ensuring the variance of features
being non-zero have also been useful for preventing collapse [BPL21b]. The Barlow Twins loss can
be related to kernel-based independence criterion such as HSIC which have also been useful as losses
for representation learning [Li+21; Tsa+21].
BYOL (bootstrap your own latents) [Gri+20] and SimSiam [Che+20c] simply minimize the mean
squared error between two representations:
LBYOL = Ex,x+

kgφ(fθ(x)) − fθ
′ (x
+)k
2

. (32.19)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1058
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Following Grill et al. [Gri+20], gφ is known as the predictor, fθ is the online network, and fθ
′ is the
target network. When optimizing this loss function, weights are backpropagated to update φ and
θ, but optimizing θ
′ directly leads the representation to collapse [Che+20c]. Instead, BYOL sets
θ
′ as an exponential moving average of θ, and SimSiam sets θ
′ ← θ at each iteration of training.
The reasons why BYOL and SimSiam avoid collapse are not entirely clear, but Tian, Chen, and
Ganguli [TCG21] analyze the gradient flow dynamics of a simplified linear BYOL model and show
that collapse can indeed be avoided given properly set hyperparameters.
DINO (self-distillation with no labels) [Car+21] is another non-contrastive loss that relies on
the dynamics of learning to avoid collapse. Like BYOL, DINO uses a loss that consists only of an
attractive term between an online network and a target network formed by an exponential moving
average of the online network weights. Unlike BYOL, DINO uses a cross-entropy loss where the
target network produces the targets for the online network, and avoids the need for a predictor
network. The DINO loss is:
LDINO = Ex,x+

H(fθ
′ (x)/τ, center(fθ(x
+))/τ ′
)

. (32.20)
where, with some abuse of notation, center is a mean-centering operation applied across the minibatch
that contains x
+. Centering the output of the target network is necessary to prevent collapse to a
single “class”, whereas using a lower temperature τ
′ < τ for the target network is necessary to prevent
collapse to a uniform distribution. The DINO loss provides marginal gains over the BYOL loss when
performing self-supervised representation learning with vision transformers on ImageNet [Car+21].
32.3.4.4 Tricks of the trade
Beyond view selection and losses, there are a number of useful architectures and modifications that
enable more effective multiview representation learning.
Normalizing the output of the encoders and computing cosine similarity instead of predicting
unconstrained representations has shown to improve performance [Che+20c]. This normalization
bounds the similarity between points between −1 and 1, so an additional temperature parameter τ
is typically introduced and fixed or annealed over the course of learning.
While the learned representation with multiview learning are often useful for downstream tasks, the
losses when combined with data augmentation typically lead to too much invariance for some tasks.
Instead, one can extract an earlier layer in the encoder as the representation, or alternatively, add an
additional layer known as a projection head to the encoder before computing the loss [Che+20c].
When training we compute the loss on the output of the projection head, but when evaluating the
quality of the representation we discard this additional layer.
Given the summation over negative examples in the denominator of the InfoNCE loss, it is often
sensitive to the batch size used for training. In practice, large batch sizes of 4096 or more are needed
to achieve good performance with this loss, which can be computationally burdensome. MoCo
(momentum contrast) [He+20] introduced a memory queue to store negative examples from previous
minibatches to expand the size of negatives at each iteration. Additionally, they use a momentum
encoder, where the encoder for the positive and negative examples uses an exponential moving
average of the anchor encoder parameters. This momentum encoder approach was also found useful
in BYOL to prevent collapse. As in BYOL, adding an extra predictor network that maps from the
online network to the target network has shown to improve the performance of MoCo, and removes
the requirement of a memory queue [CXH21].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
32.4. THEORY OF REPRESENTATION LEARNING
The backbone architectures of the encoder networks play a large role in the quality of representations.
For representation learning in vision, recent work has switched from ConvNet-based backbones to
vision transformers, resulting in larger-scale models with improved performance on several downstream
tasks [CXH21].
32.4 Theory of representation learning
While deep representation learning has replaced hand-designed features for most applications, the
theory behind what features are learned and what guarantees these methods provide are limited.
Here we review several theoretical directions in understanding representation learning: identifiability,
information maximization, and transfer bounds.
32.4.1 Identifiability
In this section, we assume a latent-variable generative model that generated the data, where z ∼ p(z)
are the latent variables, and x = g(z) is a deterministic generator that maps from the latent variables
to observations. Our goal is to learn a representation h = fθ(x) that inverts the generative model
and recovers h = z. If we can do this, we say the model is identifiable. Oftentimes we are not
able to recover the true latent variables exactly, for example the dimensions of the latent variables
may be permuted, or individual dimensions may be transformed version of an underlying latent
variable: hi = fi(zi). Thus most theoretical work on identifiability focuses on the case of learning a
representation that can be permuted and elementwise transformed to match the true latent variables.
Such representations are referred to as disentangled as the dimensions of the learned representation
do not mix together multiple dimensions of the true latent variables.
Methods for recovering are typically based around latent-variable models such as VAEs combined
with various regularizers (see Section 21.3.1.1). While several publications showed promising empirical
progress, a large-scale study by Locatello et al. [Loc+20a] on disentangled representation learning
methods showed that several existing approaches cannot work without additional assumptions on
the data or model. Their argument relies on the observation that we can form a bijection f that
takes samples from a factorial prior p(z) = Q
i
pi(zi) and maps to z
′ = f(z) that (1) preservers the
marginal distribution, and (2) has entirely entangled latents (each dimension of z influences every
dimension of z
′
). Transforming the marginal in this way changes the representation, but preserves
the marginal likelihood of the data, and thus one cannot use marginal likelihood alone to identify
or distinguish between the entangled and disentangled model. Empirically, they show that past
methods largely succeeded due to careful hyperparameter selection on the target disentanglement
metrics that require supervised labels. While further work has developed unsupervised methods
for hyperparameter that address several of these issues [Dua+20], at this point there are no known
robust methods for learning disentangled representations without further assumptions.
To address the empirical and theoretical gap in learning disentangled representations, several papers
have proposed using additional sources of information in the form of weakly-labeled data to provide
guarantees. In theoretical work on nonlinear ICA [RMK21; Khe+20; Häl+21], this information comes
in the form of additional observations for each datapoint that are related to the underlying latent
variable through an exponential family. Work on causal representation learning has expanded
the applicability of these methods and highlighted the settings where such strong assumptions on
weakly-labeled data may be attainable [Sch+21c; WJ21; Rei+22]
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1060
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Alternatively, one can assume access to pairs of observations where the relationship between latent
variables is known. In Shu et al. [Shu+19b], they show that one can provably learn a disentangled
representation of data when given access to pairs of data where only one of the latent variables is
changed at a time. In real world datasets, having access to pairs of data like this is challenging, as not
all the latent-variables of the model may be under the control of the data collector, and covering the
full space of settings of the latent variable may be prohibitively expensive. Locatello et al. [Loc+20b]
develops this method further but leverages a heuristic to detect which latent variable has changed,
and shows this performs empirically well, and under some restricted settings may lead to learning
disentangled representations.
More recently, [Kiv+21; Kiv+22] showed that it is possible to identify deep latent variable models,
such as VAEs, without any side information, provided the latent space prior has the form of a
mixture.
32.4.2 Information maximization
When learning representations of an input x, one desideratum is to preserve as much information
about x as possible. Any information we discard cannot be recovered, and if that information is
useful for a downstream task then performance will decrease. Early work on understanding biological
learning by Linsker [Lin88c] and Bell and Sejnowski [BS95b] argued that information maximization or
InfoMax is a good learning principle for biological systems as it enables the downstream processing
systems access to as much sensory input as possible. However, these biological systems aim to
communicate information subject to strong constraints, and these constraints can likely be tuned
over time by evolution to sculpt the kinds of representations that are learned.
When applying information maximization to neural networks, we are often able to realize trivial
solutions which biological systems may not face: being able to losslessly copy the input. Information
theory does not “color” the bits, it does not tell us which bits of an input are more important
than others. Simply sending the image losslessly maximizes information, but does not provide a
transformation of the input that can improve performance according to the metrics in Section 32.2.
Architectural and optimization constraints can guide the bits we learn and the bits we dispose of,
but we can also leverage additional sources of information, for example labels, to identify which bits
to extract.
The information bottleneck method (Section 5.6) aims to learn representations Z of an input
X that are predictive of another observed variable Y , while being as compressed as possible. The
observed variable Y guides the bits learned in the representation Z towards those that are predictive,
and penalizes content that does not predict Y . We can formalize the information bottleneck as an
optimization problem [TPB00]:
maximizeθI(Z; Y ) − βI(X;Z). (32.21)
Estimating mutual information in high dimensions is challenging, but we can form variational
bounds on mutual information that are amenable to optimization with modern neural networks, such
as variational information bottleneck (VIB, see Section 5.6.2). Approaches built on VIB have shown
improved robustness to adversarial examples and natural variations [FA20].
Unlike information bottleneck methods, many recent approaches motivated by InfoMax have no
explicit compression objective [Hje+18; BHB19; OLV18b]. They aim to maximize information subject
to constraints, but without any explicit penalty on the information contained in the representation.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
32.4. THEORY OF REPRESENTATION LEARNING
In spite of the appeal of explaining representation learning with information theory, there are a
number of challenges. One of the greatest challenges in applying information theory to understand
the content in learned representations is that most learned representations have determinstic encoders,
z = fθ(x) that map from a continuous input x to a continuous representation z. These mappings
can typically preserve infinite information about the input. As mutual information estimators scale
poorly with the true mutual information, estimating MI in this setting is difficult and typically results
in weak lower bounds.
In the absence of constraints, maximizing information between an input and a learned representation
has trivial solutions that do not result in any interesting transformation of the input. For example,
the identity mapping z = x maximizes information but does not alter the input. Tschannen et al.
[Tsc+19] show that for invertible networks where the true mutual information between the input
and representation is infinite, maximizing estimators of mutual information can result in meaningful
learned represenations. This highlights that the geometric dependence and bias of these estimators
may have more to do with their success for representation learning than the information itself (as it
is infinite throughout training).
There have been several proposed methods for learning stochastic representations that constrain
the amount of information in learned representations [Ale+17]. However, these approaches have not
yet resulted in improved performance on most downstream tasks. Fischer and Alemi [FA20] shows
that constraining information can improve robustness on some benchmarks, but scaling up models
and datasets with determinstic representations currently presents the best results [Rad+21]. More
work is needed to identify whether constraining information can improve learned representations.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license33 Interpretability
This chapter is written by Been Kim and Finale Doshi-Velez.
33.1 Introduction
As machine learning models become increasingly commonplace, there exists increasing pressure to
ensure that these models’ behaviors align with our values and expectations. It is essential that models
that automate even mundane tasks (e.g., processing paperwork, flagging potential fraud) do not harm
their users or society at large. Models with large impacts on health and welfare (e.g., recommending
treatment, driving autonomously) must not only be safe but often also function collaboratively with
their users.
However, determining whether a model is harmful is not easy. Specific performance metrics may
be too narrowly focused—e.g., just because an autonomous car stays in lane does not mean it is safe.
Indeed, the narrow objectives used in common decision formalisms such as Bayesian decision theory
(Section 34.1), multi-step decision problems (Chapter 34), and reinforcement learning (Chapter 35)
can often be easily exploited (e.g.„ reward hacking). Incomplete sets of metrics also result in models
that learn shortcuts that do not generalize to new situations (e.g., [Gei+20b]). Even when one knows
the desired metrics, those metrics can be hard to estimate with limited data or a distribution shift
(Chapter 19). Finally, normative concepts, such as fairness, may be impossible to fully formalize. As
a result, not only may unexpected and irreversible harms occur (e.g., an adverse drug reaction) but
more subtle harms may go unnoticed until sufficient reporting data accrues [Amo+16].
Interpretability allows human experts to inspect a model. Alongside traditional statistical measures
of performance, this human inspection can help expose issues and thus mitigate potential harms.
Exposing the workings of a model can also help people identify ways to incorporate information they
have into a final decision. More broadly, even when we are satisfied with a model’s performance,
we may be interested in understanding why they work to gain scientific and operational insights.
For example, one might gain insights in language structure by asking why a language model
performs so well; understanding why patient data cluster along particular axes may result in a better
understanding of disease and the common treatment pathways. Ultimately, interpretation helps
humans to communicate better with machines to accomplish our tasks better.
In this chapter, we lay out the role and terminologies in interpretable ML before introducing
methods, properties, and evaluation of interpretability methods.1064
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.1.1 The role of interpretability: unknowns and under-specifications
As noted above, ensuring that models behave as desired is challenging. In some cases, the desired
behavior can be guaranteed by design, such as certain notions of privacy via differentially-private
learning algorithms or some chosen mathematical metric of fairness. In other cases, tracking various
metrics, such as adverse events or subgroup error rates, may be the appropriate and sufficient way
to identify concerns. Much of this textbook deals with uncertainty quantification: basic models
in Chapter 3, Bayesian neural networks in Chapter 17, Gaussian processes in Chapter 18). When
well-calibrated uncertainties can be computed, they may provide sufficient warning that a model’s
output may be suspect.
However, in many cases, the ultimate goal may be fundamentally impossible to fully specify and
thus formalize. For example, Section 20.4.8 discusses the challenge of evaluating the quality of
samples from a generative model. In such cases, human inspection of the machine learning model
may be necessary. Below we describe several examples.
Blindspot discovery. Inspection may reveal blindspots in our modeling, objective, or data
[Bad+18; Zec+18b; Gur+18]. For example, suppose a company has trained a machine learning system
for credit scoring. The model was trained on a relatively affluent, middle-aged population, and now
the company is considering using it on a different, college-aged population. Suppose that inspection
of the model reveals that it relies heavily on the applicant’s mortgage payments. Not only might this
suggest that the model might not transfer well to the college population, but it might encourage
us to check for bias in the existing application because we know historical biases have prevented
certain populations from achieving home ownership (something that a purely quantitative definition
of fairness may not be able to recognize). Indeed, the most common application of interpretability in
industry settings is for engineers to debug models and make deployment decisions [Pai].
Novel insights. Inspection may catalyze the discovery of novel insights. For example, suppose
an algorithm determines that surgical procedures fall into three clusters. The surgeries in one of
the clusters of patients seem to consistently take longer than expected. A human inspecting these
clusters may determine that a common factor in the cluster with the delays is that those surgeries
occur in a different part of the hospital, a feature not in the original dataset. This insight may result
in ideas to improve on-time surgery performance.
Human+ML teaming. Inspection may empower effective human+ML interaction and
teaming. For example, suppose an anxiety treatment recommendation algorithm reveals the pa￾tient’s comorbid insomnia constrained its recommendations. If the patient reports that they no longer
have trouble sleeping, the algorithm could be re-run with that constraint removed to get additional
treatment options. More broadly, inspection can reveal places where people may wish to adjust the
model, such as correcting an incorrect input or assumption. It can also help people use only part
of a model in their own decision-making, such as using a model’s computation of which treatments
unsafe vs. which treatments are best. In these ways, the human+ML team may be able to produce
better combined performance than either alone (e.g., [Ame+19; Kam16]).
Individual-level recourse. Inspection can help determine whether a specific harm or error
happened in a specific context. For example, if a loan applicant knows what features were used to
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.1. INTRODUCTION
deny them a loan, they have a starting point to argue that an error might have been made, or that
the algorithm denied them unjustly. For this reason, inspectability is sometimes a legal requirement
[Zer+19; GF17; Cou16].
As we look at the examples above, we see that one common element is that interpretability is
needed when we need to combine human insights with the ML algorithm to achieve the ultimate goal.
1
However, looking at the list above also emphasizes that beyond this very basic commonality, each
application and task represents very different needs. A scientist seeking to glean insights from a
clustering on molecules may be interested in global patterns — such as all molecules with certain
loop structures are more stable — and be willing to spend hours puzzling over a model’s outputs. In
contrast, a clinician seeking to make a specific treatment decision may only care about aspects of the
model relevant to the specific patient; they must also reach their decision within the time-pressure of
an office visit. This brings us to our most important point: the best form of explanation depends on
the context; interpretability is a means to an end.
33.1.2 Terminology and framework
In broad strokes, “to interpret means to explain or present in understandable terms” [Mer]. Under￾standing, in turn, involves an alignment of mental models. In interpretable machine learning, that
alignment is between what (perhaps part of) the machine learning model is doing and what the user
thinks the model is doing.
As a result, interpretable machine learning ecosystem includes not only standard machine learning
(e.g.„ a prediction task) but also what information is provided to the human user, in what context,
and the user’s ultimate goal. The broader socio-technical system — the collection of interactions
between human, social, organizational, and technical (hardware and software) factors — cannot be
ignored [Sel+19]. The goal of interpretable machine learning is to help a user do their task, with their
cognitive strengths and weaknesses, with their focus and distractions [Mil19]. Below we define the
key terms of this expanded ecosystem and describe how they relate to each other. Before continuing,
however, we note that the field of interpretable machine learning is relatively new, and a consensus
around terminology is still evolving. Thus, it is always important to define terms.
Two core social or human factors elements in interpretable machine learning are the context
and the end-task.
Context. We use the term context to describe the setting in which an interpretable machine
learning system will be used. Who is the user? What information do they have? What constraints
are present on their time, cognition, or attention? We will use the terms context and application
interchangeably [Sta].
End-task. We use the term end-task to refer to the user’s ultimate goal. What are they ultimately
trying to achieve? We will use the terms end-task and downstream tasks interchangeably.
Three core technical elements in interpretable machine learning are the method, the metrics, and
the properties of the methods.
1. We emphasize that interpretability is different from manipulation or persuasion, where the goal is to intentionally
deceive or convince users of a predetermined choice.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1066
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Method. How do we does the interpretability happen? We use the term explanation to mean
the output provided by the method to the user: interpretable machine learning methods provide
explanations to the users. If the explanation is the model itself, we call the method inherently
interpretable or interpretable by design. In other cases, the model may be too complex for a human
to inspect it in its entirety: perhaps it is a large neural network that no human could expect to
comprehend; perhaps it is a medium-sized decision tree that could be inspected if one had twenty
minutes but not if one needs to make a decision in two minutes. In such cases, the explanation may
be a partial view of the model, one that is ideally suited for performing the end-task in the given
context. Finally, we note that even inherently interpretable models do not reveal everything: one
might be able to fully inspect the function (e.g., a two-node decision tree) but not know what data it
was trained on or which datapoints were most influential.
Metrics. How is the interpretability method evaluated? Evaluation is one of the most essential
and challenging aspects of interpretable machine learning, because we are interested in the end-task
performance of the human, when explanation is provided. We call this the downstream performance.
Just as different goals in ML require different metrics (e.g., positive predictive value, log likelihood,
AUC), different contexts and end-tasks will have different metrics. For example, the model with
the best predictive performance (e.g., log likelihood loss) may not be the model that results in the
best downstream performance.
Properties. What characteristics does the explanation have in relation to the model, the context
and the end-tasks? Different contexts and different end-tasks might require different properties.
For example, suppose that an explanation is being used to identify ways in which a denied loan appli￾cant could improve their application. Then, it may be important that the explanation only include
factors that, if changed, would change the outcome. In contrast, suppose the explanation is being used
to determine if the denial was fair. Then, it may be important that the explanation does not leave out
any relevant factors. In this way, properties serve as a glue between interpretability methods, contexts
and end-tasks: properties allow us to specify and quantify aspects of the explanation relevant to our
ultimate end-task goals. Then we can make sure that our interpretability method has those properties.
How they all relate. Formulating an interpretable machine learning problem generally starts by
specifying the context and the end-task. Together the context and the end-task imply what metrics
are appropriate to evaluate the downstream performance on the end-task and suggest what properties
will be important in the explanation. Meanwhile, the context also determines the data and training
metric for the ML model. The appropriate choice of explanation methods will depend on the model
and properties desired, and it will be evaluated with respect to the end-task metric to determine the
downstream performance. Figure 33.1 shows these relationships.
Interpretable machine learning involves many challenges, from computing explanations and op￾timizing interpretable models and creating explanations with certain properties to understanding
the associated human factors. That said, the grand challenge is to (1) understand what properties
are needed for different contexts and end-tasks and (2) identify and create interpretable machxine
learning methods that have those properties.
A simple example In the following sections, we will expand upon methods for interpretability,
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.1. INTRODUCTION
Figure 33.1: The interpretable machine learning ecosystem. While standard machine learning can often
abstract away elements of the context and consider only the process of learning models given a data distribution
and a loss, interpretable machine is inextricably tied to a socio-technical context.
metrics for evaluation, and types of properties. First, however, we provide a simple example connecting
all of the concepts we discussed above.
Suppose our context is that we have a lemonade stand, and our end-task is to understand when the
stand is most successful in order to prioritize which days it is worth setting it up. (We have heard
that sometimes machine learning models latch on to incorrect mechanisms and want to check the
model before using it to inform our business strategy.) Our metric for the downstream performance
is whether we correctly determine if the model can be trusted; this could be quantified as the amount
of profit that we make by opening on busy days and being closed on quiet days.
To train our model, we collect data on two input features — the average temperature for the
day (measured in degrees Fahrenheit) and the cleanliness of the sidewalk near our stand (mea￾sured as a proportion of the sidewalk that is free of litter, between 0 and 1) — and the output
feature of whether the day was profitable. Two models seem to fit the data approximately equally well:
Model 1:
p(profit) = .9 ∗ (temperature > 75) + .1(howCleanSidewalk) (33.1)
Model 2:
p(profit) = σ(.9(temperature − 75)/maxTemperature + .1(howCleanSidewalk − .5)) (33.2)
These models are illustrated in Figure 33.2. Both of these models are inherently interpretable in
the sense that they are easy to inspect and understand. While we were not explicitly seeking causal
models (for that, see Chapter 36), both rely mostly on the temperature, which seems reasonable.
For the sake of this example, suppose that the models above were black boxes, and we could only
request partial views of it. We decide to ask the model for the most important features. Let us see
what happens when we consider two different ways of computing important features.2
2. In the remainder of the chapter we will describe many other ways of creating and computing explanations.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1068
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 33.2: Models described in the simple example. Both of these models have the same qualitative
characteristics, but different explanation methods will describe these models quite differently, potentially
causing confusion.
Our first (feature-based) explanation method computes, for each training point, whether individually
changing each feature to its max or min value changes the prediction. Important features are those
that change the prediction for many training points. One can think of this explanation method as a
variant of computing feature importance based on how important a feature is to the coalition that
produces the prediction. In this case, both models will report temperature to be the dominating
feature. If we used this explanation to vet our models, we would correctly conclude that both models
use the features in a sensible way (and thus may be worth considering for deciding when to open our
lemonade stand).
Our second (feature-based) explanation method computes the magnitude of the derivatives of the
output with respect to the inputs for each training point. Important features are those that have a
large sum of absolute derivatives across the training set. One can think of this explanation method as
a variant of computing feature importances based on local geometry. In this case, Model 2 will still
report that temperature has higher derivatives. However, Model 1, which has very similar behavior
to Model 2, will report that sidewalk cleanliness is the dominating feature because the derivative
with respect to temperature is zero nearly everywhere. If we used this explanation to vet our models,
we would incorrectly conclude that Model 1 relies on an unimportant feature (and that Model 1 and
2 rely on different features).
What happened? The different explanations had different properties. The first explanation had
the property of fidelity with respect to identifying features that, if changed, will affect the prediction,
whereas the second explanation had the property of correctly identifying features that have the most
local curvature. In this example, the first property is more important for the task of determining
whether our model can be used to determine our business strategy. 3
33.2 Methods for interpretable machine learning
There exist many methods for interpretable machine learning. Each method has different properties
and the right choice will depend on context and end-tasks. As we noted in Section 33.1.2, the grand
challenge in interpretable machine learning is determining what kinds of properties are needed for
3. Other properties may be important for this end-task. This example is just the simplest one.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.2. METHODS FOR INTERPRETABLE MACHINE LEARNING
what contexts, and what explanation methods satisfy those properties. Thus, one should consider
this section a high-level snapshot of the rapidly changing options of methods that one may want to
choose for interpretable machine learning.
33.2.1 Inherently interpretable models: the model is its explanation
We consider certain classes of models inherently interpretable: a person can inspect the full model and,
with reasonable effort, understand how inputs become outputs.4 Specifically, we define inherently
interpretable models as those that require no additional process or proxies in order for them to be
used as explanation for the end-task. For example, suppose a model consists of a relatively small set
of rules. Then, those rules might suffice as the explanation for end-tasks that do not involve extreme
time pressure. (Note: in this way, a model might be inherently interpretable for one end-task and
not another.)
Inherently interpretable models fall into two main categories: sparse (or otherwise compact) models
and logic-based models.
Compact or sparse feature-based models include various kinds of sparse regressions. Earlier in
this textbook, we discussed simple models such as HMMs (Section 29.2), generalized linear models
(Chapter 15), and various latent variable models (Chapter 28). When small enough, these are
generally inherently interpretable. More advanced models in this category include super-sparse linear
integer models and other checklist models [DMV15; UTR14].
While simple functionally, sparsity has its drawbacks when it comes to inspection and interpretation.
For example, if a model picks only one of several correlated features, it may be harder to identify
what signal is actually driving the prediction. A model might also assign correlated features different
signs that ultimately cancel, rendering an interpretion of weights meaningless.
To handle these issues, as well as to express more complex functions, some models in this category
impose hierarchical or modular structures in which each component is still relatively compact and
can be inspected. Examples include topic models (e.g., [BNJ03b], (small) discrete time series models
(e.g., [FHDV20]), generalized additive models (e.g., [HT17]) and monotonicity-enforced models (e.g.,
[Gup+16]).
Logic-based models use logical statements as basis. Models in this category include decision￾trees [Bre+17], decision lists [Riv87; WR15; Let+15a; Ang+18; DMV15] , decision tables, decision
sets [Hau+10; Wan+17a; LBL16; Mal+17; Bén+21], and logic programming [MDR94]. A broader
discussion, as well as a survey of user studies on these methods, can be found in [Fre14]. Logic-based
models easily model non-linear relationships but can have trouble modeling continuous relationships
between the input and output (e.g., expressing a linear function vs. a step-wise constant function).
Like the compact models, hierarchies and other forms of modularity can be used to extend the
expressivity of the model while keeping it human-inspectable. For example, one can define a new
concept as a formula based on some literals, and then use the new concept to build more complex
rules.
When using inherently interpretable models, three key decisions need to be made: the choice of
the model class, how to manage uninterpretable input features, and the choice of optimization method.
4. There may be other questions, such as how training data influenced the model, which may still require additional
computation or information.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1070
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Decision: model class. Since the model is its own explanation, the decision on the model class
becomes the decision on the form of explanation. Thus, we need to consider both whether the model
class is a good choice for modeling the data as well as providing the necessary information to the
user. For example, if one chooses to use a linear model to describe one’s data, then it is important
that the intended users can understand or manipulate the linear model. Moreover, if the fitting
process produces a model that is too large to be human-inspectable, then it is no longer inherently
interpretable, even if it belongs to one of the model classes described above.
Decision: optimization methods for training. The kinds of model classes that are typically
inherently interpretable often require more advanced methods for optimization: compact, sparse, and
logic-based models all involve learning discrete parameters. Fortunately, there is a long and contin￾uing history of research for optimizing such models, including directly via optimization programs,
relaxation and rounding techniques, and search-based approaches. Another popular optimization
approach is via distillation or mimics: one first trains a complex model (e.g., a neural network) and
then uses the complex model’s output to train a simpler model to mimic the more complex model.
The more complex model is then discarded. These optimization techniques are beyond the scope of
this chapter but covered in optimization textbooks.
Decision: how to manage uninterpretable input features. Sometimes the input features
themselves are not directly interpretable (e.g., pixels of an image or individual amplitudes spectro￾gram); only collections of inputs have semantic meaning for human users. This situation challenges
our ability not only to create inherently interpretable models but also explanations in general.
To address this issue, more advanced methods attempt to add a “concept” layer that first converts
the uninterpretable raw input to a set of human-interpretable concept features. Next, these concepts
are mapped to the model’s output [Kim+18a; Bau+17]. This second stage can still be inherently
interpretable. For example, one could first map a pattern of spectrogram to a semantically meaningful
sound (e.g., people chatting, cups clinking) and then from those sounds to a scene classification (e.g.,
in a cafe). While promising, one must ensure that the initial data-to-concept mapping truly maps
the raw data to concepts as the user understands them, no more and no less. Creating and validating
that machine-derived concepts correspond to a semantically meaningful human concepts remains an
open research challenge.
When might we want to consider inherently interpretable models? When not? Inher￾ently interpretable models have several advantages over other approaches. When the model is its
explanation, one need not worry about whether the explanation is faithful to the model or whether it
provides the right partial view of the model for the intended task. Relatedly, if a person vets the
model and finds nothing amiss, they might feel more confident about avoiding surprises. For all these
reasons, inherently interpretable models have been advocated for in high-stakes scenarios, as well as
generally being the first go-to to try [Rud19].
That said, these models do have their drawbacks. They typically require more specialized
optimization approaches. With appropriate optimization, inherently interpretable models can
often match the performance of more complex models, but there are domains — in particular, images,
waveforms, and language — in which deep models or other more complex models typically give
significantly higher performance. Trying to fit complex behavior with a simple function may result
not only in high bias in the trained model but also invite people to (incorrectly) rationalize why that
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.2. METHODS FOR INTERPRETABLE MACHINE LEARNING
highly biased model is sensible [Lun+20]. In an industry setting, seeking a migration away from a
legacy, uninterpretable, business-critical model that has been tuned over decades would run into
resistance.
Lastly, we note that just because a model is inherently interpretable, it does not guard against all
kinds of surprises: as noted in Section 33.1, interpretability is just one form of validation mechanism.
For example, if the data distribution shifts, then one may observe unexpected model behavior.
33.2.2 Semi-inherently interpretable models: example-based methods
Example-based models use examples as their basis for their predictions. For example, an example￾based classifier might predict the class of a new input by first identifying the outputs for similar
instances in the training set and next taking a vote. K-nearest neighbors is one of the best
known models in this class. Extensions include methods to identify exemplars for predicted classes
and clusters (e.g., [KRS14; KL17b; JL15a; FD07b; RT16; Arn+10]), to generate exemplars (e.g.,
[Li+17d]), to define similarities between instances via sophisticated embeddings (e.g.,[PM18a]), and
to first decompose an instance into parts and then find neighbors or exemplars between the parts
(e.g., [Che+18b]). Like logic-based models, example-based models can describe highly non-linear
boundaries.
On one hand, individual decisions made by example-based methods seem fully inspectable: one can
provide the user with exactly the training instances (including their output labels) that were used to
classify a particular input in a particular way. However, it may be difficult to convey a potentially
complex distance metric used to define “similarity”. As a result, the user may incorrectly infer what
features or patterns made examples similar. It is also often difficult to convey the intuition behind
the global decision boundary using examples.
33.2.3 Post-hoc or joint training: the explanation gives a partial view of the
model
Inherently interpretable models are a subset of all machine learning models, and circumstances may
require working with a model that is not inherently interpretable. As noted above, large neural
models (Chapter 16) have demonstrated large performance benefits for certain kinds of data (e.g.,
images, waveform, and text); one might have to work with a legacy, business critical model that has
been tuned for decades; one might be trying to understand a system of interconnected models.
In these cases, the view that the explanation gives into the model will necessarily be partial: the
explanation may only be an approximation of the model or be otherwise incomplete. Thus, more
decisions have to be made. Below, we split these decisions into two broad categories — what the
explanation should consist of to best serve the context and how the explanation should be computed
from the trained model. More detail on the abilities and limitations of these partial explanation
methods can be found in [Sla+20; Yeh+19a; Kin+19; Ade+20a].
33.2.3.1 What does the explanation consist of ?
One set of decisions center around the content of the explanation and what properties it should have.
One choice is the form: Should the explanation be a list of important features? The top interactions?
One must also choose the scope of the explanation: Is it trying to explain the whole model (global)?
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1072
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The model’s behavior near a specific input (local)? Something else? Determining what properties
the explanation must have will help answer these and other questions. We expand on each of these
points below; the right choice, as always, will depend on the user — whom the explanation is for
—and their end-task.
Decision: form of the explanation. In the case of inherently interpretable models, the model
class used to fit the data was also the explanation. Now, the model class and the explanation are two
different entities. For example, the model could be a deep network and the explanation a decision
tree.
Works in interpretable machine learning have used a large variety of forms of explanations. The
form could be a list of “important” input features [RSG16b; Lun+20; STY17; Smi+17; FV17] or
“important” concepts [Kim+18a; Bau+20; Bau+18]. Or it could be a simpler model that approximates
the complex model (e.g., a local linear approximation, an approximating rule set)[FH17; BKB17;
Aga+21b; Yin+19c]. Another choice could be a set of similar or prototypical examples [KRS14;
AA18; Li+17d; JL15a; JL15b; Arn+10]. Finally, one can choose whether the explanation should
include a contrast against an alternative (also sometimes described as a counterfactual explanation)
[Goy+19; WMR18; Kar+20a] or include or influential examples [KL17b].
Different forms of explanations will facilitate different tasks in different contexts. For example, a
contrastive explanation of why treatment A is better than treatment B may help a clinician decide
between treatments A and B. However, a contrast between treatments A and B may not be useful
when comparing treatments A and C. Given the large number of choices, literature on how people
communicate in the desired context can often provide some guidance. For example, if the domain
involves making quick, high-stakes decisions, one might turn to how trauma nurses and firefighters
explain their decisions (known as recognition-primed decision making, [Kle17]).
Decision: scope of the explanation: global or local. Another major decision regarding the
parameters of the explanation is its scope.
Local explanation: In some cases, we may only need to interrogate an existing model about
a specific decision. For example, why was this image predicted as a bird? Why was this patient
predicted to have diabetes? Local explanations can help see if a consequential decision was made
incorrectly or determine what could have been done differently to produce a different outcome (i.e.,
provide a recourse).
Local explanations can take many forms. A family of methods called saliency maps or attribution
maps [STY17; Smi+17; ZF14; Sel+17; Erh+09; Spr+14; Shr+16] estimate the importances of each
input dimension (e.g., via first-order derivatives with respect to the input). More generally, one
might locally-fit simpler model in the neighborhood of the input of interest (e.g., LIME [RSG16b]).
A local explanation may also consist of representative examples, including identifying which training
points were most influential for a particular decision [KL17b] or identifying nearby datapoints with
different predictions [MRW19; LHR20; Kar+20a].
All local explanation methods are partial views because they only attempt to explain the model
around an input of interest. A key risk is that the user may overgeneralize the explanation to a wider
region than it applies. They may also interpolate an incorrect mental model of the model based on a
few local explanations.
Global explanation: In other cases, we may desire insight into the model as a whole or for a
collection of datapoints (e.g., all inputs predicted to one class). For example, suppose that our
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.2. METHODS FOR INTERPRETABLE MACHINE LEARNING
end-task is to decide whether to deploy a model. Then, we care about understanding the entire
model.
Global explanations can take many forms. One choice is to fit a simpler model (e.g., an inherently
interpretable model) that approximates the original model (e.g., [HVD14]). One can also identify
concepts or features that affect decisions across many inputs (e.g., [Kim+18b]). Another approach
is to provide a carefully chosen set of representative examples [Yeh+18]. These examples might be
chosen to be somehow characteristic of, or providing coverage of, a class (e.g., [AA18]), to draw
attention to decision boundaries (e.g., [Zhu+18]), or to identify inputs particularly influential in
training the model.
Unless a model is inherently interpretable, it is still important to remember that a global explanation
is still a partial view. To make a complex model accessible to the user, the global explanation will
need to leave some things out.
Decision: determining what properties the context needs. Different forms of explanations
have different levels of expressivity. For example, an explanation listing important features, or fitting
a local linear model around a particular input, does not expose interactions—but fitting a local
decision tree would. For each form, there will also be many ways to compute an explanation of that
form (more on this in Section 33.2.3.2). How do we choose amongst all of these different ways to
compute the explanation? We suggest that the first step in determining the form and computation
of an explanation should be to determine what properties are needed from it.
Specifying properties is especially important because not only may different forms of explanations
have different intrinsic properties—e.g., can it model interactions?—but the properties may depend
on the model being explained. For example, if the model is relatively smooth, then a feature-based
explanation relying on local gradients may be fairly faithful to the original model. However if the
model has spiky contours, the same explanation may not adequately capture the model’s behavior.
Once the desired properties are determined, one can determine what kind of computation is necessary
to achieve them. We will list commonly desirable properties in Section 33.3.
33.2.3.2 How the explanation is computed
Another set of decisions has to do with how the explanation is computed.
Decision: computation of explanation. Once we make the decisions above, we must decide
how the explanation will actually be computed. This choice will have a large impact on the
explanation’s properties. Thus, it is crucial to carefully choose a computational approach that
provides the properties needed for the context and end-task.
For example, suppose one is seeking to identify the most “important" input features that change a
prediction. Different computations correspond to different definitions of importance. One definition
of importance might be the smallest region in an image that, when changed, changes the prediction—
a perturbation-based analysis. Even within this definition, we would need to specify how that
perturbation will be computed: Do we keep the pixel values within the training distribution? Do we
preserve correlations between pixels? Different works take different approaches [SVZ13; DG17; FV17;
DSZ16; Adl+18; Bac+15a].
A related approach is to define importance in terms of sensitivity (e.g., largest gradients of the
output with respect to the input feature). Even then, there are many computational decisions to be
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1074
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
made [STY17; Smi+17; Sel+17; Erh+09; Shr+16]. Yet another common definition of importance is
how often the input feature is part of a “winning coalition” that drives the prediction, e.g., a Shapley
or Banzaf score [LL17]. Each of these definitions have different properties, as well as require different
amounts of computation.
Similar issues come up with other forms of explanations. For example, for an example-based
explanation, one has to define what it means to be similar or otherwise representative: Is it the cosine
similarity between activations? A uniform L2 ball of a certain size between inputs? Likewise, there
are many different ways to obtain counterfactuals. One can rely on distance functions to identify
nearby inputs that with different outputs [WMR17; LHR20], causal frameworks [Kus+18], or SAT
formulations [Kar+20a], among other choices.
Decision: joint training vs. post-hoc application. So far, we have described our partial
explanation techniques as extracting some information from an already-trained model. This approach
is called deriving a post-hoc explanation. As noted above, post-hoc, partial explanations may have
some limitations: for example, an explanation based on a local linear approximation may be great
if the model is generally smooth, but provide little insight if the model has high curvature. Note
that this limitation is not because the partial explanation is wrong, but because the view that local
gradients provide isn’t sufficient if the true decision boundary is curvy.
One approach to getting explanations to have desired properties we is to train the model and the
explanation jointly. For example, a regularizer that penalizes violations of desired properties can
help steer the overall optimization process towards learning models that both perform well and are
amenable to the desired explanation [Plu+20]. It is often possible to find such a model because most
complex model classes have multiple high-performing optima [Bre01].
The choice of regularization will depend on the desired properties, the form of the explanation,
and its computation. For example, in some settings, we may desire the explanation use the same
features that people do for the task (e.g., lower frequency vs. higher frequency features in image
classifiers [Wan+20b]) — and still be faithful to the model. In other settings, we may want to control
the input dimensions used or not used in the explanation, or for the explanation to be somehow
compact (e.g., a small decision tree) while still being faithful to the underlying model, [RHDV17;
Shu+19a; Vel+17; Nei+18; Wu+19b; Plu+20]. (Certain attention models fall into this category
[JW19; WP19].) We may also have constraints on the properties of concepts or other intermediate
features [AMJ18b; Koh+20a; Hen+16; BH20; CBR20; Don+17b]. In all of these cases, these desired
properties could be included as a regularizer when training the model.
When choosing between a post-hoc explanation or joint training, one key consideration is that joint
training assumes that one can re-train the model or the system of interest. In many cases in practice,
this may not be possible. Replacing a complex and well-validated system in deployment for a decade
may not be possible or take a prohibitively long time. In that case, one can still extract approximated
explanations using post-hoc methods. Finally, a joint optimization, even when it can be performed, is
not a panacea: optimization for some properties may result in unexpected violations of other (unspec￾ified but desired) properties. For this reason, explanations from jointly trained models are still partial.
When might we want to consider post-hoc methods, and when not?. The advantage of
post-hoc interpretability methods is that they can be applied to any model. This family of methods
is especially useful in real-world scenarios where one needs to work with a system that contains many
models as its parts, where one cannot expect to replace the whole system with one model. These
approaches can also provide at least some broader knowledge about the model to identify unexpected
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.2. METHODS FOR INTERPRETABLE MACHINE LEARNING
concerns.
That said, post-hoc explanations, as approximations of the true model, may not be fully faithful to
the model nor cover the model completely. As such, an explanation method tailored for one context
may not be transferable in another; even in the intended context, there may be blindspots about
the model that the explanation misses completely. For these reasons, in high stakes situations, one
should attempt to use an inherently interpretable model first if possible [Rud19]. In all situations
when post-hoc explanations are used, one must keep in mind that they are only one tool in a broader
accountability toolkit and warn users appropriately.
33.2.4 Transparency and visualization
The scope of interpretable machine learning is around methods that expose the process by which a
trained model makes a decision. However, the behavior of a model also depends on the objective
function, the training data, how the training data were collected and processed, and how the model
was trained and tested. Conveying to a human these other aspects of what goes into the creation
of a model can be as important as explaining the trained model itself. While a full discussion of
transparency and visualization is outside the scope of this chapter, we provide a brief discussion here
to describe these important adjacent concepts.
Transparency is an umbrella term for the many things that one could expose about the modeling
process and its context. Interpreting models is one aspect. However, one could also be transparent
about other aspects, such as the data collection process or the training process (e.g., [Geb+21;
Mit+19; Dnp]). There are also situations in which a trained model is released (whether or not it is
inherently interpretable), and thus the software can be inspected and run directly.
Visualization is one way to create transparency. One can visualize the data directly or various
aspects of the model’s process (e.g., [Str+17]). Interactive visualizations can convey more than text
or code descriptions [ZF14; OMS17; MOT15; Ngu+16; Hoh+20]. Finally, in the specific context of
interpretable machine learning, how the explanation is presented — the visualization — can make a
large difference in how easily users can consume it. Even something as simple as a rule list has many
choices of layout, highlighting, and other organization.
When might we want to consider transparency and visualization? When not? In many
cases, the trouble with a model comes not from the model itself, but parts of its training pipeline.
The problem might be the training data. For example, since policing data contain historical bias,
predictions of crime hot spots based on that data will be biased. Similarly, if clinicians only order
tests when they are concerned about a patient’s condition, then a model trained to predict risk based
on tests ordered will only recapitulate what the clinicians already know. Transparency about the
properties of the data, and how training and testing were performed, can help identify these issues.
Of course, inspecting the data and the model generation process is something that takes time
and attention. Thus, visualizations of this kind and other descriptions to increase transparency
are best-suited to situations in which a human inspector is not under time pressure to sift through
potentially complex patterns for sources of trouble. These methods are not well-suited for situations
in which a specific decision must be made in a relatively short amount of time, e.g., providing
decision-support to a clinician at the bedside.
Finally, transparency in the form of making code available can potentially assist in understanding
how a model works, identifying bugs, and allowing independent testing by a third party (e.g., testing
with a new set of inputs, evaluating counterfactuals in different testing distributions). However, if a
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1076
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
model is sufficiently complex, as many modern models are, then simply having access to the code is
likely not be enough for a human to gain sufficient understanding for their task.
33.3 Properties: the abstraction between context and method
Recall from the terminology and framework in Section 33.1.2 that the context and end-task determine
what properties are needed for the explanation. For example, in a high-stakes setting — such
as advising on interventions for an unstable patient — it may be important that the explanation
completely and accurately reflects the model (fidelity). In contrast, in a discovery-oriented setting, it
might be more important for any explanation to allow for efficient iterative refinement, revealing
different aspects of the model in turn (interactivity). Not all contexts and end-tasks need all properties,
and the lack of a key property may result in poor downstream performance.
While the research is still evolving, there exists a growing informal understanding about how
properties may work as an abstraction between methods and contexts. Many interpretability methods
from Section 33.2 share the same properties, and methods with the same properties may have similar
downstream performance in a specific end-task and context. If two contexts and end-tasks require
the same properties, then a method that works well for one may work well for the other. A method
with properties well-matched for one context could miserably fail in another context.
How to find desired properties? Of course, identifying what properties are important for a
particular context and end-task is not trivial. Indeed, identifying what properties are important for
what contexts, end-tasks, and downstream performance metrics is one facet of the grand challenge of
interpretable machine learning. For the present, the process of identifying the correct properties will
likely require iteration via user studies. However, iterating over properties is still a much smaller
space than iterating over methods. For example, if one wants to test whether the sparsity of the
explanation is key to good downstream performance, one could intentionally create explanations of
varying levels of sparsity to test that hypothesis. This is a much more precise knob to test than
exhaustively trying out different explanation methods with different hyperparameters.
Below, we first describe examples of properties that have been discussed in the interpretable
machine learning literature. Many of these properties are purely computational — that is, they can
be determined purely from the model and the explanation. A few have some user-centric elements.
Next we list examples of properties of explanation from cognitive science (on human to human
explanations) and human-computer interaction (on machine to human explanations). Some of these
properties have analogs in the machine learning list, while others may serve as inspiration for areas
to formalize.
33.3.1 Properties of explanations from interpretable machine learning
Many lists of potentially-important properties of interpretable machine learning models have been
compiled, sometimes using different terms for similar concepts and sometimes using the similar terms
for different concepts. Below we list some commonly-described properties of explanations, knowing
that this list will evolve over time as the field advances.
Faithfulness, fidelity (e.g., as described in [JG20; JG21]). When the explanation is only a partial
view of the model, how well does it match the model? There are many ways to make this notion
precise. For example, suppose a mimic (simple model) is used to provide a global explanation of a
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.3. PROPERTIES: THE ABSTRACTION BETWEEN CONTEXT AND METHOD
more complex model. One possible measure of faithfulness could be how often the mimic gives the
same outputs as the original. Another could be how often the mimic has the same first derivatives
(local slope) as the original. In the context of a local explanation consisting of the ‘key’ features for
a prediction, one could measure faithfulness by whether the prediction changes if the supposedly
important features are flipped. Another measure could check to make sure the prediction does not
change if a supposedly unimportant feature is flipped. The appropriate formalization will depend on
the context.
Compactness, sparsity (e.g., as described in [Lip18; Mur+19] ). In general, an explanation
must be small enough such that the user can process it within the constraints of the task (e.g., how
quickly a decision must be made). Sparsity generally corresponds to some notion of smallness (a few
features, a few parameters, L1 norm etc.). Compactness generally carries an additional notion of
not including anything irrelevant (that is, even if the explanation is small enough, it could be made
smaller). Each must be formalized for the context
Completeness (e.g., as described in [Yeh+19b]). If the explanation is not the model, does it still
include all of the relevant elements? For example, if an explanation consists of important features for
a prediction, does it include all of them, or leave some out? Moreover, if the explanation uses derived
quantities that are not the raw input features — for example, some notion of higher-level concepts
— are they expressive enough to explain all possible directions of variation that could change the
prediction? Note that one can have a faithful explanation in certain ways but not complete in others:
Fore example, an explanation may be faithful in the sense that flipping features considered important
flips the prediction and flipping features considered unimportant does not. However, the explanation
may fail to include that flipping a set of unimportant features does change the prediction.
Stability (e.g., as described in [AMJ18a]) To what extent are the explanations similar for similar
inputs? Note that the underlying model will naturally affect whether the explanation can be
stable. For example, if the underlying model has high curvature and the explanation has limited
expressiveness, then it may not be possible to have a stable explanation.
Actionability (e.g., as described in [Kar+20b; Poy+20]). Actionability implies filtering the
content of the explanation to focus on only aspects of the model that the user might be able to
intervene on. For example, if a patient is predicted to be at high risk of heart disease, an actionable
explanation might only include mutable factors such as exercise and not immutable factors such as
age or genetics. The notion of recourse corresponds to actionability in a justice context.
Modularity (e.g., as described in [Lip18; Mur+19]). Modularity implies that the explanation can
be broken down into understandable parts. While modularity does not guarantee that the user can
explain the system as a whole, for more complex models, modular explanations — where the user
can inspect each part — can be an effective way to provide a reasonable level of insight into the
model’s workings.
Interactivity (e.g., [Ten+20]) Does the explanation allow the user to ask questions, such as how
the explanation changes for a related input, or how an output changes given a change in input? In
some contexts, providing everything that a user might want or need to know from the start might be
overwhelming, but it might be possible to provide a way for the user to navigate the information
about the model in their own way.
Translucence (e.g., as described in [SF20; Lia+19]). Is the explanation clear about its limitations?
For example, if a linear model is locally fit to a deep model at a particular input, is there a mechanism
that reports that this explanation may be limited if there are strong feature interactions around
that input? We emphasize that translucence is about exposing limitations in the explanation, rather
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1078
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
than the model. As with all accountability methods, the goal of the explanation is to expose the
limitations of the model.
Simulability (e.g., as described in [Lip18; Mur+19]). A model is simulable if a user can take
the model and an input and compute the output (within any constraints of time and cognition). A
simulable explanation is an explanation that is a simulable model. For example, a list of features
is not simulable, because a list of features alone does not tell us how to compute the output. In
contrast, an explanation in the form of a decision tree does include a computation process: the
user can follow the logic of the tree, as long as it is not too deep. This example also points out an
important difference between compactness and simulability: if an explanation is too large, it may not
be simulable. However, just because an explanation is compact — such as a short list of features —
does not mean that a person can compute the model’s output with it.
It may seem that simulability is different from the other properties because its definition involves
human input. However, in practice, we often know what kinds of explanations are easy for people
to simulate (e.g., decision trees with short path lengths, rule lists with small formulas, etc.). This
knowledge can be turned into a purely computational training constraint where we seek simulatable
explanations.
Alignment to the user’s vocabulary and mental model. (e.g., as described in [Kim+18a]).
Is the content of the explanation designed for the user’s vocabulary? For example, the explanation
could be given in the semantics a user knows, such as medical conditions vs. raw sensor readings.
Doing so can help the user more easily connect the explanation to their knowledge and existing
decision-making guidelines [Clo+19]. Of course, the right vocabulary will depend on the user: an
explanation in terms of parameter variances and influential points may be comprehensible to an
engineer debugging a lending model but not to a loan applicant.
Like simulability, mental-model alignment is more human-centric. However, just as before, we can
imagine an abstraction between eliciting vocabulary and mental models from users (i.e., determining
how they define their terms and how to think), and ensuring that an explanation is provided in
alignment with whatever that elicited user vocabulary and mental model is.
Once desired properties are identified, we need to operationalize them. For example, if sparsity is a
desired property, would using the L1 norm be enough? Or does a more sophisticated loss term need
to be designed? This decision will necessarily be human-centric: how small an explanation needs to
be, or in what ways it needs to be small, is a decision that needs to consider how people will be using
the explanation. Once operationalized, most properties can be optimized computationally. That
said, the properties should be evaluated with the context, end-task, model, and chosen explanation
methods. Once evaluated, one may revisit the choice of the explanation and model.
Finally, we emphasize that the ability to achieve a particular property will depend on the intrinsic
characteristics of the model. For example, the behavior of a highly nonlinear model with interactions
between the inputs will, in general, be harder to understand than a linear model. No matter how we
try to explain it, if we are trying to explain something complicated, then users will have a harder
time understanding it.
33.3.2 Properties of explanations from cognitive science
Above we focused on computational properties between models and explanations. The fields of
cognitive science and human-computer interaction have long examined what people consider good
properties of an explanation. These more human-centered properties may be ones that researchers in
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.4. EVALUATION OF INTERPRETABLE MACHINE LEARNING MODELS
machine learning may be less aware of, yet essential for communicating information to people.
Unsurprisingly, the literature on human explanation concurs that the explanation must fit the
context [VF+80]; different contexts require different properties and different explanations. That said,
human explanations are also social constructs, often including post-hoc rationalizations and other
biases. We should focus on properties that help users achieve their goals, not ones simply “because
people sometimes do it”.
Below we list several of these properties.
Soundness (e.g., as described in [Kul+13]). Explanations should contain nothing but the truth
with respect to whatever they are describing. Soundness corresponds to notions of compactness and
faithfulness above.
Completeness (e.g., as described in [Kul+13]). Explanations should contain the whole truth
with respect to whatever they are describing. Completeness corresponds to notions of completeness
and faithfulness above.
Generality (e.g., as described in [Mil19]). Overall, people understand that an explanation for one
context may not apply in another. That said, there is an expectation that an explanation should
reflect some underlying mechanism or principle and will thus apply to similar cases — for whatever
notion of similarity is in the person’s mental model. Explanations that do not generalize to similar
cases may be misinterpreted. Generality corresponds to notions of stability above.
Simplicity (e.g., as described in [Mil19]). All of the above being equal, simpler explanations are
generally preferred. Simplicity relates to notions of sparsity and complexity above.
Contrastiveness (e.g., as described in [Mil19]). Contrastive explanations provide information of
how something differs from an alternate decision or prediction. For example, instead of providing a
list of features for why a particular drug is recommended, it might provide a list of features that
explain why one drug is recommended over another. Contrastiveness relates to notions of actionability
above, and more generally explanation types that include counterfactuals.
Finally, the cognitive science literature also notes that explanations are often goal directed. This
matches the notion of explanation in ML as information that helps a person improve performance on
their end-task. Different information may help with different goals, and thus human explanations
take many forms. Examples include deductive-nomological forms (i.e. a logical proofs) [HO48], forms
that provide a sense of an underlying mechanism [BA05; Gle02; CO06], and forms that conveying
understanding [Kei06]. Knowing these forms can help us consider what options might be best among
different sets of interpretable machine learning methods.
33.4 Evaluation of interpretable machine learning models
One cannot formalize the notion of interpretability without specifying the context, the end-task, and
the downstream performance metric [VF+80]. If one explanation empowers the human to get better
performance on their end-task over another explanation, then it is more useful. While the grand
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1080
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
challenge of interpretable machine learning is to develop a general understanding of what properties
are needed for good downstream performance on different end-tasks in different contexts, in this
section, we will focus on rigorous evaluation within one context [DVK17].
Specifically, we describe two major categories for evaluating interpretable machine learning methods:
Computational evaluations of properties (without people). Computational evaluations of
whether explanations have desired properties do not user studies. For example, one can computation￾ally measure whether a particular explanation satisfies a definition of faithfulness under different
training and test data distributions or whether the outputs of one explanation are more sparse
than another. Such measures are valuable when one already knows that certain properties may be
important for certain contexts. Computational evaluations also serve as intermediate evaluations and
sanity checks to identify undesirable explanation behavior prior to a more expensive user study-based
evaluation.
User studies (with people). Ultimately, user studies are needed to measure how well an
interpretable machine learning method enables the user to complete their end-task in a given context.
Performing a rigorous, well-designed user study in a real context is significant work — much more
so than computing a test likelihood on benchmark datasets. It requires significant asks of not only
the researchers but also the target users. Methods for different contexts will also have different
evaluation challenges: while a system designed to assist with optimizing music recommendations
might be testable on a wide population, a system designed to help a particle physicist identify
new kinds of interactions might only be tested with one or two physicists because people with that
expertise are hard to find. In all cases, the evaluation can be done rigorously given careful attention
to experimental design.
33.4.1 Computational evaluation: does the method have desired properties?
While the ultimate measure of interpretability is whether the method successfully empowers the
user to perform their task, properties can serve as a valuable abstraction. Checking whether an
explanation has the right computational and desired properties can ensure that the method works as
expected (e.g., no implementation errors, no obviously odd behaviors). One can iterate on novel,
computationally-efficient methods to optimize the quantitative formalization of a property before
conducting expensive human experiments. Computational checks can also ensure whether properties
that held for one model continue to hold when applied to another model. Finally, checking for specific
properties can also help pinpoint in what way an explanation is falling short, which may be less clear
from a user study due to confounding.
In some cases, one might be able to prove mathematically that an explanation has certain properties,
while in others the test must be empirical. For empirical testing, one umbrella strategy is to use
a hypothesis-based sanity check; if we think a phenomenon X should never occur (hypothesis), we
can test whether we can create situations where X may occur. If it does, then the method fails
this sanity check. Another umbrella strategy is to create datasets with known characteristics or
ground truth explanations. These could be purely synthetic constructions (e.g., generated tables
with intentionally correlated features), semi-synthetic approaches (e.g., intentionally changing the
labels on an image dataset), or taking slices of a real dataset (e.g., introduce intentional bias
by only selecting real image, label pairs that are of outdoor environments). Note that these tests
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.4. EVALUATION OF INTERPRETABLE MACHINE LEARNING MODELS
Figure 33.3: An example of computational evaluation using (semi-)synthetic datasets from [YK19]: foreground
images (e.g., dogs, backpacks) are placed on different backgrounds (e.g., indoors, outdoors) to test what an
explanation is looking for.
can only tell us if something is wrong; if a method passes a check, there may still be missing blindspots.
Examples of sanity checks. One strategy is to come up statements of the form “if this explanation
is working, then phenomenon X should not be occurring” and then try to create a situation in which
phenomenon X occurs. If we succeed, then the sanity check fails. By asking about out-of-the-box
phenomena, this strategy can reveal some surprising failure modes of explanation methods.
For example, [Ade+20a] operates under the assumption that a faithful explanation should be a
function of a model’s prediction. The hypothesis is that the explanation should significantly change
when comparing a trained model to an untrained model (where prediction is random). They show
that many existing methods fail to pass this sanity check (Figure 33.4).
In another example, [Kin+19] hypothesize that a faithful explanation should be invariant to input
transformations that do not affect model predictions or weights, such as constant shift of inputs (e.g.,
all inputs are added by 10). This hypothesis can be seen as testing both faithfulness and stability
properties. Their work shows that some methods fail this sanity check.
Adversarial attacks on explanations also fall into this category. For example, [GAZ19] shows that
two perceptively indistinguishable inputs with the same predicted label can be assigned very different
explanations.
Examples using (semi)synthetic datasets. Constructed datasets can also help score properties
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1082
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 33.4: Interpretability methods (each row) and their explanations as we randomize layers starting from
the logits, and cumulatively to the bottom layer (each column), in the context of image classification task. The
rightmost column is showing a completely randomized network. Most methods output similar explanations
for the first two columns; one predicts the bird, and the other predicts randomly. This sanity check tests the
hypothesis that the explanation should significantly change (quantitatively and qualitatively) when comparing
a trained model and an untrained model [Ade+20a].
of various methods. We use the work of [YK19] as an example. Here, the authors were interested
in explanations with the properties of compactness and faithfulness: it should not identify features
as important if they are not. To test for these properties, the authors generate images with known
correlations. Specifically, they generate multiple datasets, each with a different rate of how often
each particular foreground object co-occurs with each particular background (see Figure 33.3). Each
dataset comes with two labels per image: for the object and the background.
Now, the authors compare two models: one trained to classify objects and one trained to classify
backgrounds (left, Figure 33.3). If a model is trained to classify objects and they all happen to
have the same background, the background should be less important than in a model trained to
classify backgrounds ([YK19] call this ‘model contrast score’). They also checked that the model
trained to predict backgrounds was not providing attributions to the foreground objects (see right
Figure 33.3). Other works using similar strategies include [Wil+20b; Gha+21; PMT18; KPT21;
Yeh+19b; Kim+18b].
Examples with real datasets. While more difficult, it is possible to at least partially check for
certain kinds of properties on real datasets that have no ground-truth.
For example, suppose an explanation ranks features from most to least important. We want to
determine if this ranking is faithful. Further, suppose we can assume that the features do not interact.
Then, one can attempt to make the prediction just with the top-1 most important feature, just the
top-2 ranked features, etc. and observe if the change in prediction accuracy exhibits diminishing
returns as more features are added. (If the features do interact, this test will not work. For example,
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.4. EVALUATION OF INTERPRETABLE MACHINE LEARNING MODELS
Figure 33.5: Examples of computational evaluation with real datasets. Top row is from Figure 1 of [DG17],
used with kind permission of Yarin Gal. Bottom row is from Figure 4 of [Gho+19]. One would expect that
adding or deleting patches rated as most ‘relevant’ for an image classification would have a large effect on the
classification compared to patches not rated as important.
if features A, B, C are the top-3 features, but C is only important if feature B is present, the test
above would over-estimate the importance of the feature C.)
Figure 33.5 shows an example of this kind of test [Gho+19]. Their method outputs a set of
image patches (e.g., a set of connected pixels) that correlates with the prediction. They add top-n
image patches provided by the explanation one by one and observe the desired trend in accuracy. A
similar experiment in reverse direction (i.e., deleting top-n most important image patches one by
one) provides additional evidence. Similar experiments are also conducted in [FV17; RSG16a].
For example, in [DG17], authors define properties in plain English first: smallest sufficient region
(smallest region of the image that alone allows a confident classification) and smallest destroying
region (smallest region of the image that when removed, prevents a confident classification), followed
by careful operationalization of these properties such that they become the objective for optimization.
Then, separately, an evaluation metric of saliency is defined to be “the tightest rectangular crop that
contains the entire salient region and to feed that rectangular region to the classifier to directly verify
whether it is able to recognise the requested class”. While the “rectangular” constraint may introduce
artifacts, it is a neat trick to make evaluation possible. By checking expected behavior as described
above, authors confirm that methods’ behavior on the real data is aligned with the defined property
compared to baselines.
Evaluating the evaluations. As we have seen so far, there are many ways to formalize a given
property and many empirical tests to determine whether a property is present. Each empirical test
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1084
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
will have different qualities. As an illustration, in [Tom+20], the authors ask whether popular saliency
metrics give consistent results across literature. They tested whether different metrics for assessing
the quality of saliency-based explanations (explanations that identify important pixels or regions in
images) is evaluating similar properties. In other words, this work tests consistency and stability
properties of metrics. They show many metrics are statistically unreliable and inconsistent. While
each metric may still have a particular use [Say+19], knowing this inconsistency exists helps us better
understand the landscape and limitations of evaluation approaches. Developing good evaluations for
computational properties is an ongoing area of research.
33.4.2 User study-based evaluation: does the method help a user perform a
target task?
User study-based evaluations measure whether an interpretable machine learning method helps
a human perform some task. This task could be the ultimate end-task of interest (e.g., does a
method help a doctor make better treatment decisions) or a synthetic task that mirrors contexts of
interest (e.g., a simplified situation with artificial diseases and symptoms). In both cases, rigorous
experimental design is critical to ensuring that the experiment measures what we want it to measure.
Understanding experimental design for user studies is essential for research in interpretable machine
learning.
33.4.2.1 User studies in real contexts.
The gold standard for testing whether an explanation is useful is to test it in the intended context:
Do clinicians make better decisions with a certain kind of decision support? Do programmers debug
code faster with a certain kind of explanation about model errors? Do product teams create more
fair models for their businesses? A complete guide on how to design and conduct user studies is out
of scope for this chapter; below we point out some basic considerations.
33.4.2.2 Basic elements of user studies
Performing a high-quality user study is a nuanced and non-trivial endeavor. There are many sources
of bias, some obvious (e.g., learning and fatigue effects during a study) and some less obvious (e.g.,
participants willing to work with us are more optimistic about AI technology than those we could
not recruit, or different participants may have different needs for cognition).
Interface design. The explanation must be presented to the user. Unlike the intrinsic difficulty
of explaining a model (i.e., complex models are harder to explain than simple ones), the design of
the interface is an extrinsic source of difficulty that can confound the experimental results. For
example, it may be easier, in general, to scan a list of features ordered by importance rather than
alphabetically.
When we perform an evaluation with respect to an end-task, intrinsic and extrinsic difficulties
can get conflated. Does one explanation type work better because it does a better job of explaining
the complex system? Or does it work better simply because it was presented in a way that was
easier for people to use? Especially if the goal is to test the difference between one explanation and
another in the experiment, it is important that the interface for each is designed to tease out the
effect from the explanations and their presentations. (Note that good presentations and visualization
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.4. EVALUATION OF INTERPRETABLE MACHINE LEARNING MODELS
are an important but different object of study.) Moreover, if using the interface requires training, it
is important to deliver the training to users in a way that is neutral in each testing condition. For
example, how the end-task and goals of the study are described during training (e.g., with practice
questions) will have a large impact on how users approach the task.
Baselines. Simply the presence of an explanation may change the way in which people interact
with an ML system. Thus, it is often important to consider how a human performs with no ML
system, with an ML system and no explanation, with an ML system and a placebo explanation (an
explanation that provides no information), and with an ML system and hand-crafted explanations
(manually generated by humans who are presumably good communicators).
Experimental design and hypothesis testing. Independent and dependent variables, hy￾potheses, and inclusion and exclusion criteria must be clearly defined prior to the start of the study.
For example, suppose that one hypothesizes that a particular explanation will help a developer
debug an image classifier. In this case, the independent variable would be a form of assistance: the
particular explanation, competing explanation methods, and the baselines above. The dependent
variable would be whether the developer can identify bugs. Inclusion and exclusion criteria might
include a requirement that the developer has sufficient experience training image classifiers (as
determined by an initial survey, or a pre-test), demonstrates engagement (as measured by a base
level of performance on practice rounds), and does not have prior experience with the particular
explanation types (as determined by an initial survey). Other exclusion criteria could be removing
outliers. For example, one could decide, in advance, to exclude data from any participant that takes
an unusually long or short time to perform task as a proxy for engagement.
As noted in Section 33.2, there are many decisions that go into any interpretable machine learning
method, and each context is nuanced. Studies of the form “Does explanation X (computed via some
pipeline Y ) help users in context Z compared to explanation X′
?” may not provide much insight
as to why that particular explanation is better or worse — making it harder not only to iterate on
a particular explanation but also to generalize to other explanations or contexts. There are many
factors of potential variation in the results, ranging from the properties of the explanation and its
presentation to the difficulty of the task.
To reduce this variance, and to get more useful and generalizable insights, we can manipulate
some factors of variation directly. For example, suppose the research question is whether complete
explanations are better than incomplete explanations in a particular context. One might write out
hand-crafted explanations that are complete in what features they implicate, explanations in which
one important feature is missing, and explanations in which several important features are missing.
Doing so ensures even coverage of the different experimental regimes of interest, which may not occur
if the explanations were simply output from a pipeline. As another example, one might intentionally
create an image classifier with known bugs, or simply pretend to have an image classifier that makes
certain predictions (as done in [Ade+20b]). These kinds of studies are called wizard-of-Oz studies,
and they can help us more precisely uncover the science of why an explanation is useful (e.g., as
done in [Jac+21]).
Once the independent and dependent variables, hypotheses, and participant criteria (including
how the independent and dependent variables may be manipulated) are determined, the next step
is setting up the study design itself. Broadly speaking, randomization marginalizes over potential
confounds. For example, randomization in assigning subjects to tasks marginalizes the subject’s
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1086
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
prior knowledge; randomization in the order of tasks marginalizes out learning effects. Matching and
repeated measures reduce variance. An example of matching would be asking the same subject to
perform the same end-task with two different explanations. An example of repeated measures would
be asking the subject to perform the end-task for several different inputs.
Other techniques for designing user studies include block randomized designs/Latin square designs
that randomize the order of explanation types while keeping tasks associated with each explanation
type grouped together. This can be used to marginalize the effects of learning and fatigue without
too much context switching. Careful consideration should be given to what will be compared within
subjects and across subjects. Comparisons of task performance within subjects will have lower
variance but a potential bias from learning effects from the first task to the second. Comparisons
across subjects will have higher variance and also potential bias from population shift during ex￾perimental recruitment. Finally, each of these study designs, as well as the choice of independent
and dependent variables, will imply an appropriate significance test. It is essential to choose the
right test and multiple hypothesis correction to avoid inflated significance values while retaining power.
Qualitative studies. So far, we have described the standard approach for the design of a
quantitative user study–one in which the dependent variable is numerically measured (e.g., time
taken to correctly identify a bug, % bugs detected). While quantitative studies provide value by
demonstrating that there is a consistent, quantifiable effect across many users, they usually do not
tell us why a certain explanation worked. In contrast, qualitative studies, often performed with a
“think-aloud” or other discussion-based protocol in which users expose their thought process as they
perform the experiment, can help identify why a particular form of explanation seems to be useful or
not. The experimenter can gain insights by hearing how the user was using the information, and
depending on the protocol, can ask for clarifications.
For example, suppose one is interested in how people use an example-based explanation to
understand a video-game agent’s policy. The idea is to show a few video clips of an automated
agent in the video game, and then ask the user what the agent might do in novel situations. In a
think-aloud study, the user would perform this task while talking through how they are connecting
the videos they have seen to the new situation. By hearing these thoughts, a researcher might not
only gain deeper insight into how users make these connections — e.g., users might see the agent
collect coins in one video and presume that the agent will always go after coins — but they might
also identify surprising bugs: for example, a user might see the agent fall into a pit and attribute it
to a one-off sloppy fingers, not internalizing that an automated agent might make that mistake every
time.
While a participant in a think-aloud study is typically more engaged in the study than they might
be otherwise (because they are describing their thinking), knowing their thoughts can provide insight
into the causal process between what information is being provided by the explanation and the
action that the human user takes, ultimately helping advance the science of how people interact with
machine-provided information.
Pilot studies: The above descriptions are just a very high-level overview of the many factors that
must be designed properly for a high-quality evaluation. In practice, one does not typically get all of
these right the first time. Small scale pilot studies are essential to checking factors such as whether
participants attend to the provided information in unexpected ways or whether instructions are clear
and well-designed. Modifying the experiments after iterative small scale pilot studies can save a lot
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.4. EVALUATION OF INTERPRETABLE MACHINE LEARNING MODELS
of time and energy down the road. In these pilots, one should collect not only the usual information
about users and the dependent variables, but also discuss with the participants how they approached
the study tasks and whether any aspects of the study were confusing. These discussions will lead to
insights and confidence that the study is testing what it is intended to test. The results from pilot
studies should not be included in the final results.
Finally, as the number of factors to test increases (e.g., baselines, independent variables), the study
design becomes more complex and may require more participants and longer participation times
to determine if the results are significant — which can in turn increase costs and effects of fatigue.
Pilots, think-aloud studies, and careful thinking about what aspects of the evaluation require user
studies and what can be completed computationally can all help distill down a user-based evaluation
to the most important factors.
33.4.2.3 User studies in synthetic contexts
It is not always appropriate or possible to test an interpretable machine learning method in the real
context: for example, it would be unethical to test a prototype explanation system on patients each
time one has a new way to convey information about a treatment recommendation. In such cases, we
might want to run an experiment in which clinicians perform a task on made-up patients, or in some
analogous non-medical context where the participant pool is bigger and more affordable. Similarly,
one might create a relatively accessible image classification debugging context where one can control
the incorrect labels, distribution shifts, etc. (e.g., [Ade+20b]) and see what explanations help users
detect problems in this simpler setting. The convenience and scalability of using a simpler setting
could shed light on what properties of explanations are important generally (e.g., for debugging
image classification). For example, we can test how different forms of explanation have different
cognitive loads or how a particular property affects performance with a relatively large pool of
subjects (e.g., [Lag+19]). The same principles we outlined above for user studies in real contexts
continue to apply, but there are some important cautions.
Cautions regarding synthetic contexts: While user studies with synthetic contexts can be
valuable for identifying scientific principles, one must be cautious. For example, experimental subjects
in a synthetic high-stakes context may not treat the stakes of the problem as seriously, may be
relatively unburdened with respect to distractions or other demands on their time and attention (e.g.,
a quiet study environment vs. a chaotic hospital floor), and ignore important factors of the task (e.g.,
clicking through to complete the task as quickly as possible). Moreover, small differences in task
definition can have big effects: even the difference between asking users to simply perform a task
with an explanation available vs. asking users to answer some questions about the explanation first,
may create very different results as the latter forces the user to pay attention to the explanation and
the former does not. Priming users by giving them a specific scenario where they can put themselves
into a mindset could help. For example: “Imagine now you are an engineer at a company selling a
risk calculator. A deadline is approaching and your boss wants to make sure the product will work
for a new client. Describe how you would use the following explanation”.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1088
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.5 Discussion: how to think about interpretable machine learning
Interpretable machine learning is a young, interdisciplinary field of study. As a result, consensus
on definitions, evaluation methods, and appropriate abstractions is still forming. The goal of this
section is to lay out a core set of principles about interpretable machine learning. While specifics in
the previous sections may change, the principles below will be durable.
There is no universal, mathematical definition of interpretability, and there never will be. Defining
a downstream performance metric (and justifying it) for each context is a must. The information
that best communicates to the human what is needed to perform a task will necessarily vary: for
example, what a clinical expert needs to determine whether to try a new treatment policy is very
different than what a person to determine how to get a denied loan approved. Similarly, methods to
communicate characteristics of models built on pixel data may not be appropriate for communicating
characteristics of models built on language data. We may hope to identify desired properties in
explanations to maximize downstream task performance for different classes of end tasks — that is
the grand challenge of interpretable machine learning — but there will never be one metric for all
contexts.
While this lack of a universal metric may feel disappointing, other areas of machine learning
also lack universal metrics. For example, not only is it impossible to satisfy the many metrics on
fairness at the same time [KMR16], but also in a particular situation, none may exactly match the
desires of the stakeholders. Even in a standard classification setting, there are many metrics that
correspond to making the predicted and true labels as close as possible. Does one care about overall
accuracy? Precision? Recall? It is unlikely that one objective captures everything that is needed
in one situation, much less across different contexts. Evaluation can still be rigorous as long as
assumptions and requirements are made precise.
What sets interpretable machine learning apart from other areas of machine learning, however, is
that a large class of evaluations require human input. As a necessarily interdisciplinary area, rigorous
work in interpretable machine learning requires not only knowledge of computation and statistics but
also experimental design and user studies.
Interpretability is only a part of the solution for fairness, calibrated trust, accountability, causality,
and other important problems. Learning models that are fair, safe, causal, or engender calibrated
trust are all goals, whereas interpretability is one means towards that goal.
In some cases, we don’t need interpretability. For example, if the goal can be fully formalized in
mathematical terms (e.g., a regulatory requirement may mandate a model satisfy certain fairness
metrics), we do not need any human input. If a model behaves as expected across an exhaustive
set of pre-defined inputs, then it may be less important to understand how it produced its outputs.
Similarly, if a model performs well across a variety of regimes, that might (appropriately) increase
one’s trust in it; if it makes errors, that might (appropriately) decrease trust without an inspection
of any of the system’s internals.
In other cases, human input is needed to achieve the end-task. For example, while there is much
work in the identification of causal models (see Chapter 36), under many circumstances, it is not
possible to learn a model that is guaranteed to be causal from a dataset alone. Here, interpretability
could assist the end-task of “Is the model causal?” by allowing a human to inspect the model’s
prediction process.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.5. DISCUSSION: HOW TO THINK ABOUT INTERPRETABLE MACHINE LEARNING
As another example, one could measure the safety of a clinical decision support system by tracking
how often its recommendations causes harm to patients — and stop using the system if it causes
too much harm. However, if we use this approach to safety, we will only discover that the system is
unsafe after a significant number of patients have been harmed. Here, interpretability could support
the end-task of safety by allowing clinical experts to inspect the model’s decision process for red flags
prior to deployment.
In general, complex contexts and end-tasks will require a constellation of methods (and people)
to achieve them. For example, formalizing a complex notion such as accountability will require a
broad collection of people — from policy makers and ethicists to corporations, engineers, and users —
unifying vocabularies, exchanging domain knowledge, and identifying goals. Evaluating or monitoring
it will involve various empirical measures of quality and insights from interpretability.
Interpretability is not about understanding everything about the model; it is about understanding
enough to do the end-task. The ultimate measure of an interpretable machine learning method is
whether it helps the user perform their end-task. Suppose the end-task is to fix an overheating laptop.
An explanation that lists the likely sources of heat is probably sufficient to address the issue, even
if one does not know the chemical properties of its components. On the other hand, if the laptop
keeps freezing up, knowing about the sources of heat may not be the right information. Importantly,
both end-tasks have clear downstream performance metrics: we can observe whether the information
helped the user perform actions that make the laptop overheat or freeze up less.
As another example, consider AlphaGo, Google DeepMind’s AI go player that beat the human
world champion, Lee SeDol. The model is so complex that one cannot fully understand its decision
process, including surprising moves like its famous move 37[Met16]. That said, partial probes (e.g.,
does AlphaGo believe the same move would have made a different impact if it was made earlier but
similar position in the game) might still help a go expert gain insights on the rationale for the move
in the context of what they already know about the game.
Relatedly, interpretability is distinct from full transparency into the model or knowing the model’s
code. Staring at the weights of every neuron in a large network is likely to be as effective as taking
one’s laptop apart to understand a bug in your code. There are many good reasons for open source
projects and models, but open source code itself may or may not be sufficient for a user to accomplish
their end-task. For example, a typical user will not be able to reason through 100K lines of parameters
despite having all the pieces available.
That said, any partial view of a model is, necessarily, only a partial view; it does not tell the full
story. While we just argued that many end-tasks do not require knowing everything about a model,
we also must acknowledge that a partial view does not convey the full model. For example, the set of
features needed to change a loan decision may be the right partial view for a denied applicant, but
convey nothing about whether the model is discriminatory. Any probe will only return what it is
designed to compute (e.g., an approximation of a complex function with a simpler one). Different
probes may be able to reveal different properties at different levels of quality. Incorrectly believing
the partial view is the full story could result in incorrect insights.
Partial views can lack stability and enable attacks. Relatedly, any explanation that reveals only
certain parts of a model can lack stability (e.g., [AMJ18a]) and can be more easily attacked (e.g.,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1090
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
see [Yeh+19a; GAZ19; Dom+19; Sla+20]). Especially when models are overparameterized such as
neural networks, it is possible to learn models whose explanations say one thing (e.g., a feature is not
important, according to some formalization of feature importance) while the model does another
(e.g., uses the prohibited feature). Joint training can also exacerbate the issue, as it allows the
model to learn boundaries that pass some partial-view test while in reality violating the underlying
constraint. Other adversarial approaches can work on the input, minimally perturbing it to change
the explanation’s partial view while keeping the prediction constant or to change the prediction while
keeping the explanation constant.
These concerns highlight an important open area: We need to improve ways to endow explanations
with the property of translucence, that is, explanations that communicate what they can and cannot
say about the model. Translucence is important because misinterpreted explanations that happen to
favor a user’s views create false basis for trust.
Trade-offs between inherently interpretable models and performance often do not exist; partial views
can help when they do. While some have claimed that there exists an inherent trade-off between
using an inherently-interpretable model and performance (defined as a model’s performance on some
test data), this trade-off does not always exist in practice for several reasons [Rud19].
First, in many cases, the data can be surprisingly well-fit by a fairly simple model (due to high
noise, for example) or a model that can be decomposed into interpretable parts. One can often find a
combination of architecture, regularizer, and optimizer that produces inherently interpretable models
with performance comparable to, or sometimes even better than, blackbox approaches [Wan+17a;
LCG12; Car+15; Let+15b; UR16; FHDV20; KRS14]. In fact, interpretability and performance can
be synergistic: methods for encoding a preference for simpler models (e.g., L1 regularizer for sparsity
property) were initially developed to increase performance and avoid overfitting, and interpretable
models are often more robust [RDV18].
Second, a narrow focus on the trade-off between using inherently interpretable models and a
predefined metric of performance, as usually measured on a validation set, overlooks a broader issue:
that predefined metric of performance may not tell the full story about the quality of the model. For
example, using an inherently interpretable model may enable a person to realize that a prediction is
based on confounding, not causation—or other ways it might fail in deployment. In this way, one
might get better performance with an inherently interpretable model in practice even if a blackbox
appears to have better performance numbers in validation. An inherently interpretable model may
also enable better human+model teaming by allowing the human user to step in and override the
system appropriately.
Human factors are essential. All machine learning systems ultimately connect to broader socio￾technical contexts. However, in many cases, many aspects of model construction and optimization can
be performed in a purely computational setting: there are techniques to check for appropriate model
capacity, techniques for tuning a gradient descent or convex optimization. In contrast, interpretable
machine learning must consider human factors from the beginning: there is no point optimizing
an explanation to have various properties if it still fails to improve the user’s performance on the
end-task.
Over-reliance. Just because an explanation is present, does not mean that the user will analytically
and reasonably incorporate the information provided into their ultimate decision-making task. The
presence of any explanation can increase a user’s trust in the model, exacerbating the general issue
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
33.5. DISCUSSION: HOW TO THINK ABOUT INTERPRETABLE MACHINE LEARNING
Figure 33.6: (Potential) perception issues: an explanation from a trained network (left) is visually indistin￾guishable to humans from one from an untrained network (right)—even if they are not exactly identical.
of over-trust in human+ML teams. Recent studies have found that even data scientists over-trust
explanations in unintended ways [Kau+20]; their excitement about the tool led them to take it
at face-value rather than dig deeper. [LM20] reports a similar finding, noting that inaccurate but
evocative presentations can create a feeling of comprehension.
Over-reliance can be combated with explicit measures to force the user to engage analytically
and skeptically with the information in the explanation. For example, one could ask the user to
submit their decision first and only then show the recommendation and accompanying explanation
to pique their interest in why their choice and the recommendation might disagree (and prompting
whether they want to change their choice). Another option is to ask the user some basic questions
about the explanation prior to submitting their decision to force them to look at the explanation
carefully. Yet another option is to provide only the relevant information (the explanation) without
the recommendation, forcing the user to synthesize the additional information on their own. However,
in all these cases, there is a delicate balance: users will often be amenable to expending additional
cognitive effort if they can see it achieves better results, but if they feel the effort is too much, they
may start ignoring the information entirely.
Potential for misuse. A malicious version of over-reliance is when explanations are used to manip￾ulate a user rather than facilitating the user’s end-task. Further, users may report that they like
explanations that are simple, require little cognitive effort, etc. even when those explanations do not
help them perform their end-task. As creators of interpretable machine learning methods, one must
be on alert to ensure that the explanations help the user achieve what they want to (ideally in a way
that they also like).
Misunderstandings from a lack of understanding of machine learning. Even when correctly engaged,
users in different contexts will have different levels of knowledge about machine learning. For example,
not everyone may understand concepts such as additive factors or Shapley values [Sha16]. Users may
also attribute more understanding to a model than it actually has. For example, if they see a set of
pixels highlighted around a beak, or a set of topic model terms about a disease, they may mistakenly
believe that the machine learning model has some notion of concepts that matches theirs, when the
truth might be quite different.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1092
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Related: perception issues in image explanations. The nature of our visual processing system
adds another layer of nuance when it comes to interpreting and misinterpreting explanations. In
Figure 33.6, two explanations (in terms of important pixels in a bird image) seem to communicate a
similar message; for most people, both explanations seem to suggest that the belly and cheek of the
bird are the important parts for this prediction. However, one of them is generated from a trained
network (left), but the other one is from a network that returns random predictions (right). While
the two saliency maps aren’t identical to machines, they look similar because humans don’t parse an
image as pixel values, but as whole, they see a bird in both pictures.
Another common issue with pixel-based explanations is that explanation creators often multiply the
original image with an importance “mask” (black and clear saliency mask, where black pixel represents
no importance and a clear pixel represents maximum importance), introducing the arbitrary artifact
that black objects never appear important [Smi+17]. In addition, this binary mask is produced
by clipping important pixels in a certain percentile (e.g., only taking 99−th percentile), which can
also introduce another artifact [Sun+19c]. The balancing act between artifacts introduced by visu￾alization for the ease of understanding and faithfully representing the explanation remains a challenge.
Together, all of these points on human factors emphasize what we said from the start: we cannot
divorce the study and practice of interpretable machine learning from its intended socio-technical
context.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2023Part VI
Action34 Decision making under uncertainty
34.1 Statistical decision theory
Bayesian inference provides the optimal way to update our beliefs about hidden quantities H given
observed data X = x by computing the posterior p(H|x). However, at the end of the day, we need
to turn our beliefs into actions that we can perform in the world. How can we decide which action
is best? This is where decision theory comes in. In this section, we give a brief introduction. For
more details, see e.g., [DeG70; Ber85b; KWW22].
34.1.1 Basics
In statistical decision theory, we have an agent or decision maker, who wants to choose an
action from has a set of possible actions, a ∈ A, given some observations or data x. We assume
the data comes from some environment that is external to the agent; we characterize the state of
this environment by a hidden or unknown variable h ∈ H, known as the state of nature. Finally,
we assume we know a loss function ℓ(h, a), that specifies the loss we incur if we take action a
when the state of nature is h. The goal is to define a policy, also called an estimator or decision
procedure, which specifies which action to take in response to each possible observation, a = δ(x),
so as to minimize the expected loss, also called the risk:
δ
∗
(·) = argmin
δ
R(δ) (34.1)
where the risk is given by
R(δ) = E [ℓ(h, δ(X))] (34.2)
The key question is how to define the above expectation. We can use a frequentist or Bayesian
approach, as we discuss below.
34.1.2 Frequentist decision theory
In frequentist decision theory, we treat the state of nature h as a fixed but unknown quantity,
and treat the data X as random. Hence we take expectations wrt the data, which gives us the
frequentist risk:
r(δ|h) = Ep(x|h)
[ℓ(h, δ(x))] = Z
p(x|h)ℓ(h, δ(x))dx (34.3)1096
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The idea is that a good estimator will have low risk across many different datasets.
Unfortunately, the state of nature is not known, so the above quantity cannot be computed. There
are several possible solutions to this. One idea is to put a prior distribution on h, and then to
compute the Bayes risk, also called the integrated risk:
RB(δ) , Ep(h)
[r(δ|h)] = Z
p(h)p(x|h)ℓ(h, δ(x)) dh dx (34.4)
A decision rule that minimizes the Bayes risk is known as a Bayes estimator.
Of course the use of a prior might seem undesirable in the context of frequentist statistics. We can
therefore use the maximum risk instead. This is defined as follows:
Rmax(δ) = max
h
r(δ|h) (34.5)
Minimizing the maximum risk gives rise to a minimax estimator:
δ
∗ = min
δ
max
h
rh(δ) (34.6)
Minimax estimators have a certain appeal. However, computing them can be hard. And furthermore,
they are very pessimistic. In fact, one can show that all minimax estimators are equivalent to Bayes
estimators under a least favorable prior. In most statistical situations (excluding game theoretic
ones), assuming nature is an adversary is not a reasonable assumption. See [BS94, p449] for further
discussion of this point.
34.1.3 Bayesian decision theory
In Bayesian decision theory, we treat the data as an observed constant, x, and the state of nature
as an unknown random variable. The posterior expected loss for picking action a is defined as
follows:
ρ(a|x) , Ep(h|x)
[ℓ(h, a)] = Z
ℓ(h, a)p(h|x)dh (34.7)
We can define the posterior expected loss, or Bayesian risk, for an estimator using
ρ(δ|x) = ρ(δ(x)|x) (34.8)
The optimal policy specifies what action to take so as to minimize the expected loss. This is given
by
δ
∗
(x) = argmin
a∈A
Ep(h|x)
[ℓ(h, a)] (34.9)
An alternative, but equivalent, way of stating this result is as follows. Let us define a utility
function U(h, a) to be the desirability of each possible action in each possible state. If we set
U(h, a) = −ℓ(h, a), then the optimal policy is as follows:
δ
∗
(x) = argmax
a∈A
Eh [U(h, a)] (34.10)
This is called the maximum expected utility principle.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.1. STATISTICAL DECISION THEORY
ρ(δ|x) = Eh∼p(h|x)[ℓ(h, δ(x))]
ℓ(h, δ(x)) RB(δ) = E(x,h)∼p(x,h)[ℓ(h, δ(x))]
r(δ|h) = Ex∼p(x|h) ℓ(h, δ(x))]
Bayesian
Frequentist
Figure 34.1: Illustration of how the Bayesian and frequentist approaches to decision making incur the same
Bayes risk.
34.1.4 Frequentist optimality of the Bayesian approach
We see that the Bayesian approach, given by Equation (34.9), which picks the best action for each
individual observation x, will also optimize the Bayes risk in Equation (34.4), which picks the best
policy for all possible observations. This follows from Fubini’s theorem, which lets us exchange
the order of integration in a double integral:
RB(δ) = Ep(x)
[ρ(δ|x)] = Ep(h|x)p(x)
[ℓ(h, δ(x))] (34.11)
= Ep(h)
[r(δ|h)] = Ep(h)p(x|h)
[ℓ(h, δ(x))] (34.12)
See Figure 34.1 for an illustration. The above result tells us that the Bayesian approach has optimal
frequentist properties.
More generally, one can show that any admissable policy1
is a Bayes policy with respect to some,
possibly improper, prior distribution, a result known as Wald’s theorem [Wal47]. (See [DR21] for
a more general version of this result.) Thus we arguably lose nothing by “restricting” ourselves to the
Bayesian approach (although we need to check that our modeling assumptions are adequate, a topic
we discuss in Section 3.9). See [BS94, p448] for further discussion of this point.
Another advantage of the Bayesian approach is that is constructive, that is, it specifies how to
create the optimal policy (estimator) given a particular dataset. By contrast, the frequentist approach
allows you to use any estimator you like; it just derives the properties of this estimator across multiple
datasets, but does not tell you how to create the estimator.
34.1.5 Examples of one-shot decision making problems
In the sections below, we give some common examples of one-shot decision making problems (i.e.,
making a single decision, not a sequence of decisions) that arise in ML applications.
1. An estimator is said to be admissible if it is not strictly dominated by any other estimator. We say that δ
1
dominates δ
2
if R(θ, δ1
) ≤ R(θ, δ2
) for all θ. The domination is said to be strict if the inequality is strict for some
θ
∗.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1098
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.1.5.1 Classification
Suppose the states of nature correspond to class labels, so H = Y = {1, . . . , C}. Furthermore,
suppose the actions also correspond to class labels, so A = Y. In this setting, a very commonly used
loss function is the zero-one loss ℓ01(y
∗
, yˆ), defined as follows:
yˆ = 0 ˆy = 1
y
∗ = 0 0 1
y
∗ = 1 1 0
(34.13)
We can write this more concisely as follows:
ℓ01(y
∗
, yˆ) = I(y
∗
6= ˆy) (34.14)
In this case, the posterior expected loss is
ρ(ˆy|x) = p(ˆy 6= y
∗
|x) = 1 − p(y
∗ = ˆy|x) (34.15)
Hence the action that minimizes the expected loss is to choose the most probable label:
δ(x) = argmax
y∈Y
p(y|x) (34.16)
This corresponds to the mode of the posterior distribution, also known as the maximum a
posteriori or MAP estimate.
We can generalize the loss function to associate different costs for false positives and false negatives.
We can also allow for a “reject action”, in which the decision maker abstains from classifying when
it is not sufficiently confident. This is called selective prediction; see Section 19.3.3 for details.
34.1.5.2 Regression
Now suppose the hidden state of nature is a scalar h ∈ R, and the corresponding action is also a
scalar, y ∈ R. The most common loss for continuous states and actions is the ℓ2 loss, also called
squared error or quadratic loss, which is defined as follows:
ℓ2(h, y) = (h − y)
2
(34.17)
In this case, the risk is given by
ρ(y|x) = E

(h − y)
2
|x

= E

h
2
|x

− 2yE [h|x] + y
2
(34.18)
The optimal action must satisfy the condition that the derivative of the risk (at that point) is zero
(as explained in Chapter 6). Hence the optimal action is to pick the posterior mean:
∂
∂y ρ(y|x) = −2E [h|x] + 2y = 0 ⇒ δ(x) = E [h|x] = Z
h p(h|x)dh (34.19)
This is often called the minimum mean squared error estimate or MMSE estimate.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.1. STATISTICAL DECISION THEORY
Figure 34.2: A distribution on a discrete space in which the mode (black point L, with probability p1) is
untypical of most of the probability mass (gray circles, with probability p2 < p1). The small black circle labeled
M (near the top left) is the posterior mean, which is not well defined in a discrete state space. C (the top left
vertex) is the centroid estimator, made up of the maximizer of the posterior marginals. See text for details.
From Figure 1 of [CL07]. Used with kind permission of Luis Carvalho.
34.1.5.3 Parameter estimation
Suppose the states of nature correspond to unknown parameters, so H = Θ = R
D. Furthermore,
suppose the actions also correspond to parameters, so A = Θ. Finally, we assume the observed data
(that is input to the policy/estimator) is a dataset, such as D = {(xn, yn) : n = 1 : N}. If we use
quadratic loss, then the optimal action is to pick the posterior mean. If we use 0-1 loss, then the
optimal action is to pick the posterior mode, i.e., the MAP estimate:
δ(D) = θˆ = argmax
θ∈Θ
p(θ|D) (34.20)
34.1.5.4 Estimating discrete parameters
The MAP estimate is the optimal estimate when the loss function is 0-1 loss, ℓ(θ, θˆ) = I

θ 6= θˆ

, as
we show in Section 34.1.5.1. However, this does not give any “partial credit” for estimating some of
the components of θ correctly. An alternative is to use the Hamming loss:
ℓ(θ, θˆ) = X
D
d=1
I

θd 6= ˆθd

(34.21)
In this case, one can show that the optimal estimator is the vector of max marginals
θˆ =
"
argmax
θd
Z
θ−d
p(θ|D)dθ−d
#D
d=1
(34.22)
This is also called the maximizer of posterior marginals or MPM estimate. Note that computing
the max marginals involves marginalization and maximization, and thus depends on the whole
distribution; this tends to be more robust than the MAP estimate [MMP87].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1100
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 34.3: Spectograms for three different spoken sentences. The x-axis shows progression of time and
the y-axis shows different frequency bands. The energy of the signal in different bands is shown as intensity
in grayscale values with progression of time. (A) and (B) show spectrograms of the same sentence “How
to recognize speech with this new display” spoken by two different speakers, male and female. Although the
frequency characterization is similar, the formant frequencies are much more clearly defined in the speech
of the female speaker. (C) shows the spectrogram of the utterance “How to wreck a nice beach with this
nudist play” spoken by the same female speaker as in (B). (A) and (B) are not identical even though they
are composed of the same words. (B) and (C) are similar to each other even though they are not the same
sentences. From Figure 1.2 of [Gan07]. Used with kind permission of Madhavi Ganapathiraju.
For example, consider a problem in which we must estimate a vector of binary variables. Figure 34.2
shows a distribution on {0, 1}
3
, where points are arranged such that they are connected to their nearest
neighbors, as measured by Hamming distance. The black state (circle) labeled L (configuration
(1,1,1)) has probability p1, and corresponds to the MAP estimate. The 4 gray states have probability
p2 < p1; and the 3 white states have probability 0. Although the black state is the most probable,
it is untypical of the posterior: all its nearest neighbors have probability zero, meaning it is very
isolated. By contrast, the gray states, although slightly less probable, are all connected to other gray
states, and together they constitute much more of the total probability mass.
In the example in Figure 34.2, we have p(θj = 0) = 3p2 and p(θj = 1) = p2 + p1 for j = 1 : 3.
If 2p2 > p1, the vector of max marginals is (0, 0, 0). This MPM estimate can be shown to be a
centroid estimator, in the sense that it minimizes the squared distance to the posterior mean (the
center of mass), yet it (usually) represents a valid configuration, unlike the actual mean (fractional
estimates do not make sense for discrete problems). See [CL07] for further discussion of this point.
34.1.5.5 Structured prediction
In some problems, such as natural language processing or computer vision, the desired action is to
return an output object y ∈ Y, such as a set of labels or body poses, that not only is probable given
the input x, but is also internally consistent. For example, suppose x is a sequence of phonemes and
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.2. DECISION (INFLUENCE) DIAGRAMS
y is a sequence of words. Although x might sound more like y = “How to wreck a nice beach” on a
word-by-word basis, if we take the sequence of words into account then we may find (under a language
model prior) that y = “How to recognize speech” is more likely overall. (See Figure 34.3.) We can
capture this kind of dependency amongst outputs, given inputs, using a structured prediction
model, such as a conditional random field (see Section 4.4).
In addition to modeling dependencies in p(y|x), we may prefer certain action choices yˆ, which we
capture in the loss function ℓ(y, yˆ). For example, referring to Figure 34.3, we may be reluctant to
assume the user said yˆt=”nudist” at step t unless we are very confident of this prediction, since the
cost of mis-categorizing this word may be higher than for other words.
Given a loss function, we can pick the optimal action using minimum Bayes risk decoding:
yˆ = min
yˆ∈Y
X
y∈Y
p(y|x)ℓ(y, yˆ) (34.23)
We can approximate the expectation empirically by sampling M solutions y
m ∼ p(y|x) from the
posterior predictive distribution. (Ideally these are diverse from each other.) We use the same set of
M samples to approximate the minimization to get
yˆ ≈ min
yi
,i∈{1,...,M}
X
j∈{1,...,M}
p(y
j
|x)ℓ(y
j
, y
i
) (34.24)
This is called empirical MBR [Pre+17a], who applied it to computer vision problems. A similar
approach was adopted in [Fre+22], who applied it to neural machine translation.
34.1.5.6 Fairness
Models trained with ML are increasingly being used to high-stakes applications, such as deciding
whether someone should be released from prison or not, etc. In such applications, it is important
that we focus not only on accuracy, but also on fairness. A variety of definitions for what is meant
by fairness have been proposed (see e.g., [VR18]), many of which entail conflicting goals [Kle18].
Below we mention a few common definitions, which can all be interpreted decision theoretically.
We consider a binary classification problem with true label Y , predicted label Yˆ and sensitive
attribute S (such as gender or race). The concept of equal opportunity requires equal true
positive rates across subgroups, i.e., p(Yˆ = 1|Y = 1, S = 0) = p(Yˆ = 1|Y = 1, S = 1). The concept
of equal odds requires equal true positive rates across subgroups, and also equal false positive rates
across subgroups, i.e., p(Yˆ = 1|Y = 0, S = 0) = p(Yˆ = 1|Y = 0, S = 1). The concept of statistical
parity requires positive predictions to be unaffected by the value of the protected attribute, regardless
of the true label, i.e., p(Yˆ = 1|S = 0) = p(Yˆ |S = 1).
For more details on this topic, see e.g., [KR19].
34.2 Decision (influence) diagrams
When dealing with structured multi-stage decision problems, it is useful to use a graphical notation
called an influence diagram [HM81; KM08], also called a decision diagram. This extends directed
probabilistic graphical models (Chapter 4) by adding decision nodes (also called action nodes),
represented by rectangles, and utility nodes (also called value nodes), represented by diamonds.
The original random variables are called chance nodes, and are represented by ovals, as usual.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1102
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Oil Drill
Utility
(a)
Oil Drill
Utility
Sound
(b)
Oil Drill
Utility
Sound
Test
Cost
(c)
Figure 34.4: Influence diagrams for the oil wildcatter problem. Ovals are random variables (chance nodes),
squares are decision (action) nodes, diamonds are utility (value) nodes. (a) Basic model. (b) An extension in
which we have an information arc from the Sound chance node to the Drill decision node. (c) An extension
in which we get to decide whether to perform a test or not, as well as whether to drill or not.
34.2.1 Example: oil wildcatter
As an example (from [Rai68]), consider creating a model for the decision problem faced by an oil
“wildcatter”, which is a person who drills wildcat wells, which are exploration wells drilled in areas
not known to be oil fields.
Suppose you have to decide whether to drill an oil well or not at a given location. You have two
possible actions: d = 1 means drill, d = 0 means don’t drill. You assume there are 3 states of nature:
o = 0 means the well is dry, o = 1 means it is wet (has some oil), and o = 2 means it is soaking (has
a lot of oil). We can represent this as a decision diagram as shown in Figure 34.4(a).
Suppose your prior beliefs are p(o) = [0.5, 0.3, 0.2], and your utility function U(d, o) is specified by
the following table:
o = 0 o = 1 o = 2
d = 0 0 0 0
d = 1 −70 50 200
We see that if you don’t drill, you incur no costs, but also make no money. If you drill a dry well,
you lose $70; if you drill a wet well, you gain $50; and if you drill a soaking well, you gain $200.
What action should you take if you have no information beyond your prior knowledge? Your prior
expected utility for taking action d is
EU(d) = X
2
o=0
p(o)U(d, o) (34.25)
We find EU(d = 0) = 0 and EU(d = 1) = 20 and hence the maximum expected utility is
MEU = max{EU(d = 0),EU(d = 1)} = max{0, 20} = 20 (34.26)
Thus the optimal action is to drill, d
∗ = 1.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.2. DECISION (INFLUENCE) DIAGRAMS
34.2.2 Information arcs
Now let us consider a slight extension to the model, in which you have access to a measurement
(called a “sounding”), which is a noisy indicator about the state of the oil well. Hence we add an
O → S arc to the model. In addition, we assume that the outcome of the sounding test will be
available before we decide whether to drill or not; hence we add an information arc from S to D.
This is illustrated in Figure 34.4(b). Note that the utility depends on the action and the true state
of the world, but not the measurement.
We assume the sounding variable can be in one of 3 states: s = 0 is a diffuse reflection pattern,
suggesting no oil; s = 1 is an open reflection pattern, suggesting some oil; and s = 2 is a closed
reflection pattern, indicating lots of oil. Since S is caused by O, we add an O → S arc to our model.
Let us model the reliability of our sensor using the following conditional distribution for p(S|O):
s = 0 s = 1 s = 2
o = 0 0.6 0.3 0.1
o = 1 0.3 0.4 0.3
o = 2 0.1 0.4 0.5
Suppose the sounding observation is s. The posterior expected utility of performing action d is
EU(d|s) = X
2
o=0
p(o|s)U(o, d) (34.27)
We need to compute this for each possible observation, s ∈ {0, 1, 2}, and each possible action,
d ∈ {0, 1}. If s = 0, we find the posterior over the oil state is p(o|s = 0) = [0.732, 0.219, 0.049],
and hence EU(d = 0|s = 0) = 0 and EU(d = 1|s = 0) = −30.5. If s = 1, we similarly find
EU(d = 0|s = 1) = 0 and EU(d = 1|s = 1) = 32.9. If s = 2, we find EU(d = 0|s = 2) = 0 and
EU(d = 1|s = 2) = 87.5. Hence the optimal policy d
∗
(s) is as follows: if s = 0, choose d = 0 and get
$0; if s = 1, choose d = 1 and get $32.9; and if s = 2, choose d = 1 and get $87.5.
The maximum expected utility of the wildcatter, before seeing the experimental sounding, can be
computed using
MEU = X
s
p(s)EU(d
∗
(s)|s) (34.28)
where prior marginal on the outcome of the test is p(s) = P
o
p(o)p(s|o) = [0.41, 0.35, 0.24]. Hence
the MEU is
MEU = 0.41 × 0 + 0.35 × 32.9 + 0.24 × 87.5 = 32.2 (34.29)
These numbers can be summarized in the decision tree shown in Figure 34.5.
34.2.3 Value of information
Now suppose you can choose whether to do the test or not. This can be modelled as shown in
Figure 34.4(c), where we add a new test node T. If T = 1, we do the test, and S can enter states
{0, 1, 2}, determined by O, exactly as above. If T = 0, we don’t do the test, and S enters a special
unknown state. There is also some cost associated with performing the test.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1104
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
S = 1
0.35
Drill
Don’t Drill
32.9
0
S = 0
0.41
Drill
Don’t Drill
-30.5
0
S = 2
0.24
Drill
Don’t Drill
87.5
0
Figure 34.5: Decision tree for the oil wildcatter problem. Black circles are chance variables, black squares are
decision nodes, diamonds are the resulting utilities. Green leaf nodes have higher utility than red leaf nodes.
Is it worth doing the test? This depends on how much our MEU changes if we know the outcome of
the test (namely the state of S). If you don’t do the test, we have MEU = 20 from Equation (34.26).
If you do the test, you have MEU = 32.2 from Equation (34.29). So the improvement in utility if
you do the test (and act optimally on its outcome) is $12.2. This is called the value of perfect
information (VPI). So we should do the test as long as it costs less than $12.2.
In terms of graphical models, the VPI of a variable S can be determined by computing the MEU
for the base influence diagram, G, in Figure 34.4(b), and then computing the MEU for the same
influence diagram where we add information arcs from S to the action node, and then computing the
difference. In other words,
VPI = MEU(G + S → D) − MEU(G) (34.30)
where D is the decision node and S is the variable we are measuring. This will tell us whether it is
worth adding obtaining measurement S.
34.2.4 Computing the optimal policy
In general, given an influence diagram, we can compute the optimal policy automatically by modifiying
the variable elimination algorithm (Section 9.5), as explained in [LN01; KM08]. The basic idea is to
work backwards from the final action, computing the optimal decision at each step, assuming all
following actions are chosen optimally. When the influence diagram has a simple chain structure,
as in a Markov decision process (Section 34.5), the result is equivalent to Bellman’s equation
(Section 34.5.5).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.3. A/B TESTING
34.3 A/B testing
Suppose you are trying to decide which version of a product is likely to sell more, or which version of
a drug is likely to work better. Let us call the versions you are choosing between A and B; sometimes
version A is called the control, and version B is called the treatment. (Sometimes the different
actions are called “arms”.)
A very common approach to such problems is to use an A/B test, in which you try both actions
out for a while, by randomly assigning a different action to different subsets of the population, and
then you measure the resulting accumulated reward from each action, and you pick the winner.
(This is sometimes called a “test and roll” approach, since you test which method is best, and then
roll it out for the rest of the population.)
A key problem in A/B testing is to come up with a decision rule, or policy, for deciding which
action is best, after obtaining potentially noisy results during the test phase. Another problem is
to choose how many people to assign to the treatment, n1, and how many to the control, n0. The
fundamental tradeoff is that using larger values of n1 and n0 will help you collect more data and
hence be more confident in picking the best action, but this incurs an opportunity cost, because
the testing phase involves performing actions that may not result in the highest reward. (This is
an example of the exploration-exploitation tradeoff, which we discuss more in Section 34.4.3.) In
this section, we give a simple Bayesian decision theoretic analysis of this problem, following the
presentation of [FB19].2 More details on A/B testing can be found in [KTX20].
34.3.1 A Bayesian approach
We assume the i’th reward for action j is given by Yij ∼ N (µj , σ2
j
) for i = 1 : nj and j = 0 : 1, where
j = 0 corresponds to the control (action A), j = 1 corresponds to the treatment (action B), and nj is
the number of samples you collect from group j. The parameters µj are the expected reward for
action j; our goal is to estimate these parameters. (For simplicity, we assume the σ
2
j
are known.)
We will adopt a Bayesian approach, which is well suited to sequential decision problems. For
simplicity, we will use Gaussian priors for the unknowns, µj ∼ N (mj , τ 2
j
), where mj is the prior
mean reward for action j, and τj is our confidence in this prior. We assume the prior parameters are
known. (In practice we can use an empirical Bayes approach, as we discuss in Section 34.3.2.)
34.3.1.1 Optimal policy
Initially we assume the sample size of the experiment (i.e., the values n1 for the treatment and n0 for
the control) are known. Our goal is to compute the optimal policy or decision rule π(y1, y0), which
specifies which action to deploy, where yj = (y1j , . . . , ynj ,j ) is the data from action j.
The optimal policy is simple: choose the action with the greater expected posterior expected
reward:
π
∗
(y1, y0) = (
1 if E [µ1|y1] ≥ E [µ0|y0]
0 if E [µ1|y1] < E [µ0|y0]
(34.31)
2. For a similar set of results in the time-discounted setting, see https://chris-said.io/2020/01/10/
optimizing-sample-sizes-in-ab-testing-part-I.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1106
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
All that remains is to compute the posterior. over the unknown parameters, µj . Applying Bayes’
rule for Gaussians (Equation (2.121)), we find that the corresponding posterior is given by
p(µj |yj , nj ) = N (µj | ma
j ,
aτ
2
j
) (34.32)
1/
aτ j = nj/σ2
j + 1/τ 2
j
(34.33)
ma
j /
aτ j = njyj/σ2
j + mj/τ 2
j
(34.34)
We see that the posterior precision (inverse variance) is a weighted sum of the prior precision plus nj
units of measurement precision. We also see that the posterior precision weighted mean is a sum of
the prior precision weighted mean and the measurement precision weighted mean.
Given the posterior, we can plug ma
j into Equation (34.31). In the fully symmetric case, where
n1 = n0, m1 = m0 = m, τ1 = τ0 = τ , and σ1 = σ0 = σ, we find that the optimal policy is to simply
“pick the winner”, which is the arm with higher empirical performance:
π
∗
(y1, y0) = I

m
τ
2
+
y1
σ
2
>
m
τ
2
+
y0
σ
2

= I(y1 > y0
) (34.35)
However, when the problem is asymmetric, we need to take into account the different sample sizes
and/or different prior beliefs.
34.3.1.2 Optimal sample size
We now discuss how to compute the optimal sample size for each arm of the experiment, i.e, the
values n0 and n1. We assume the total population size is N, and we cannot reuse people from the
testing phase,
The prior expected reward in the testing phase is given by
E [Rtest] = n0m0 + n1m1 (34.36)
The expected reward in the roll phase depends on the decision rule π(y1, y0) that we use:
Eπ [Rroll] = Z
µ1
Z
µ0
Z
y1
Z
y0
(N − n1 − n0) (π(y1, y0)µ1 + (1 − π(y1, y0))µ0) (34.37)
× p(y0|µ0)p(y1|µ1)p(µ0)p(µ1)dy0dy1dµ0dµ1 (34.38)
For π = π
∗ one can show that this equals
E [Rroll] , Eπ∗ [Rroll] = (N − n1 − n0)

m1 + eΦ( e
v
) + vφ(
e
v
)

(34.39)
where φ is the Gaussian pdf, Φ is the Gaussian cdf, e = m0 − m1 and
v =
s
τ
4
1
τ
2
1 + σ
2
1
/n1
+
τ
4
0
τ
2
0 + σ
2
0
/n0
(34.40)
In the fully symmetric case, Equation (34.39) simplifies to
E [Rroll] = (N − 2n)m
| {z }
Ra
+ (N − 2n)
√
2τ
2
√
π
q
2τ
2 +
2
n
σ
2
| {z }
Rb
(34.41)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.3. A/B TESTING
This has an intuitive interpretation. The first term, Ra, is the prior reward we expect to get before
we learn anything about the arms. The second term, Rb, is the reward we expect to see by virtue of
picking the optimal action to deploy.
Let us we write Rb = (N − 2n)Ri
, where Ri
is the incremental gain. We see that the incremental
gain increases with n, because we are more likely to pick the correct action with a larger sample
size; however, this gain can only be accrued for a smaller number of people, as shown by the N − 2n
prefactor. (This is a consequence of the explore-exploit tradeoff.)
The total expected reward is given by adding Equation (34.36) and Equation (34.41):
E [R] = E [Rtest] + E [Rroll] = Nm + (N − 2n)


√
2τ
2
√
π
q
2τ
2 +
2
n
σ
2

 (34.42)
(The equation for the nonsymmetric case is given in [FB19].)
We can maximize the expected reward in Equation (34.42) to find the optimal sample size for the
testing phase, which (from symmetry) satisfies n
∗
1 = n
∗
2 = n
∗
, and from d
dn∗ E [R] = 0 satisfies
n
∗ =
s
N
4
u
2 +

3
4
u
2
2
−
3
4
u
2 ≤
√
N
σ
2τ
(34.43)
where u
2 =
σ
2
τ
2 . Thus we see that the optimal sample size n
∗
increases as the observation noise σ
increases, since we need to collect more data to be confident of the right decision. However, the
optimal sample size decreases with τ , since a prior belief that the effect size δ = µ1 − µ0 will be large
implies we expect to need less data to reach a confident conclusion.
34.3.1.3 Regret
Given a policy, it is natural to wonder how good it is. We define the regret of a policy to be the
difference between the expected reward given perfect information (PI) about the true best action
and the expected reward due to our policy. Minimizing regret is equivalent to making the expected
reward of our policy equal to the best possible reward (which may be high or low, depending on the
problem).
An oracle with perfect information about which µj is bigger would pick the highest scoring action,
and hence get an expected reward of NE [max(µ1, µ2)]. Since we assume µj ∼ N (m, τ 2
), we have
E [R|P I] = N

m +
τ
√
π

(34.44)
Therefore the regret from the optimal policy is given by
E [R|P I] − (E [Rtest|π
∗
] + E [Rroll|π
∗
]) = N
τ
√
π

1 −
τ q
τ
2 +
σ2
n∗

 +
2n
∗
τ
2
√
π
q
τ
2 +
σ2
n∗
(34.45)
One can show that the regret is O(
√
N), which is optimal for this problem when using a time horizon
(population size) of N [AG13].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1108
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.3.1.4 Expected error rate
Sometimes the goal is posed as best arm identification, which means identifying whether µ1 > µ0
or not. That is, if we define δ = µ1 − µ0, we want to know if δ > 0 or δ < 0. This is naturally
phrased as a hypothesis test. However, this is arguably the wrong objective, since it is usually
not worth spending money on collecting a large sample size to be confideny that δ > 0 (say) if the
magnitude of δ is small. Instead, it makes more sense to optimize total expected reward, using the
method in Section 34.3.1.1.
Nevertheless, we may want to know the probability that we have picked the wrong arm if we use
the policy from Section 34.3.1.1. In the symmetric case, this is given by the following:
Pr(π(y1, y0) = 1|µ1 < µ0) = Pr(Y1 − Y0 > 0|µ1 < µ0) = 1 − Φ


µ1 − µ0
σ
q 1
n1
+
1
n0

 (34.46)
The above expression assumed that µj are known. Since they are not known, we can com￾pute the expected error rate using E [Pr(π(y1, y0) = 1|µ1 < µ0)]. By symmetry, the quantity
E [Pr(π(y1, y0) = 0|µ1 > µ0)] is the same. One can show that both quantities are given by
Prob. error =
1
4
−
1
2π
arctan √
2τ
σ
r n1n0
n1 + n0
!
(34.47)
As expected, the error rate decreases with the sample size n1 and n0, increases with observation noise
σ, and decreases with variance of the effect size τ . Thus a policy that minimizes the classification
error will also maximize expected reward, but it may pick an overly large sample size, since it does
not take into account the magnitude of δ.
34.3.2 Example
In this section, we give a simple example of the above framework. Suppose our goal is to do website
testing, where have two different versions of a webpage that we want to compare in terms of their
click through rate. The observed data is now binary, yij ∼ Ber(µj ), so it is natural to use a beta
prior, µj ∼ Beta(α, β) (see Section 3.4.1). However, in this case the optimal sample size and decision
rule is harder to compute (see [FB19; Sta+17] for details). As a simple approximation, we can assume
yij ∼ N (µj , σ
2
), where µj ∼ N (m, τ 2
), m =
α
α+β
, τ
2 =
αβ
(α+β)
2(α+β+1) , and σ
2 = m(1 − m).
To set the Gaussian prior, [FB19] used empirical data from about 2000 prior A/B tests. For each
test, they observed the number of times the page was served with each of the two variations, as well
as the total number of times a user clicked on each version. Given this data, they used a hierarchical
Bayesian model to infer µj ∼ N (m = 0.68, τ = 0.03). This prior implies that the expected effect size
is quite small, E [|µ1 − µ0|] = 0.023. (This is consistent with the results in [Aze+20], who found that
most changes made to the Microsoft Bing EXP platform had negligible effect, although there were
occasionally some “big hits”.)
With this prior, and assuming a population of N = 100, 000, Equation (34.43) says that the optimal
number of trials to run is n
∗
1 = n
∗
0 = 2284. The expected reward (number of clicks or conversions)
in the testing phase is E [Rtest] = 3106, and in the deployment phase E [Rroll] = 66, 430, for a total
reward of 69, 536. The expected error rate is 10%.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.4. CONTEXTUAL BANDITS
0 20000 40000
Test size
68000
68500
69000
69500
Expected no
of conversions
n*=2283.9
(a)
0 10000 20000 30000 40000 50000
Test size
0.0
0.2
0.4
Expected error rate
n*=2283.9
(b)
Figure 34.6: Total expected profit (a) and error rate (b) as a function of the sample size used for website
testing. Generated by ab_test_demo.ipynb.
In Figure 34.6a, we plot the expected reward vs the size of the test phase n. We see that the
reward increases sharply with n to the global maximum at n
∗ = 2284, and then drops off more slowly.
This indicates that it is better to have a slightly larger test than one that is too small by the same
amount. (However, when using a heavy tailed model, [Aze+20] finds that it is better to do lots of
smaller tests.)
In Figure 34.6b, we plot the probability of picking the wrong action vs n. We see that tests that
are larger than optimal only reduce this error rate marginally. Consequently, if you want to make
the misclassification rate low, you may need a large sample size, particularly if µ1 − µ0 is small, since
then it will be hard to detect the true best action. However, it is also less important to identify
the best action in this case, since both actions have very similar expected reward. This explains
why classical methods for A/B testing based on frequentist statistics, which use hypothesis testing
methods to determine if A is better than B, may often recommend sample sizes that are much larger
than necessary. (See [FB19] and references therein for further discussion.)
34.4 Contextual bandits
This section is co-authored with Lihong Li.
In Section 34.3, we discussed A/B testing, in which the decision maker tries two different actions,
a0 and a1, a fixed number of times, n1 and n0, measures the resulting sequence of rewards, y1 and
y0, and then picks the best action to use for the rest of time (or the rest of the population) so as to
maximize expected reward.
We can obviously generalize this beyond two actions. More importantly, we can generalize this
beyond a one-stage decision problem. In particular, suppose we allow the decision maker to try an
action at, observe the reward rt, and then decide what to do at time step t + 1, rather than waiting
until n1 + n0 experiments are finished. This immediate feedback allows for adaptive policies
that can result in much higher expected reward (lower regret). We have converted a one-stage
decision problem into a sequential decision problem. There are many kinds of sequential decision
problems, but in this section, we consider the simplest kind, known as a bandit problem (see e.g.,
[LS19; Sli19]).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1110
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.4.1 Types of bandit
In a multi-armed bandit problem (MAB) there is an agent (decision maker) that can choose an
action from some policy at ∼ πt at each step, after which it receives a reward sampled from the
environment, rt ∼ pR(at), with expected value R(s, a) = E [R|a].
3
We can think of this in terms of an agent at a casino who is faced with multiple slot machines,
each of which pays out rewards at a different rate. A slot machine is sometimes called a one￾armed bandit, so a set of K such machines is called a multi-armed bandit; each different action
corresponds to pulling the arm of a different slot machine, at ∈ {1, . . . , K}. The goal is to quickly
figure out which machine pays out the most money, and then to keep playing that one until you
become as rich as possible.
We can extend this model by defining a contextual bandit, in which the input to the policy
at each step is a randomly chosen state or context st ∈ S. The states evolve over time according
to some arbitrary process, st ∼ p(st|s1:t−1), independent of the actions of the agent. The policy
now has the form at ∼ πt(at|st), and the reward function now has the form rt ∼ pR(rt|st, at), with
expected value R(s, a) = E [R|s, a]. At each step, the agent can use the observed data, D1:t where
Dt = (st, at, rt), to update its policy, to maximize expected reward.
In the finite horizon formulation of (contextual) bandits, the goal is to maximize the expected
cumulative reward:
J ,
X
T
t=1
EpR(rt|st,at)πt(at|st)p(st|s1:t−1)
[rt] = X
T
t=1
E [rt] (34.48)
(Note that the reward is accrued at each step, even while the agent updates its policy; this is
sometimes called “earning while learning”.) In the infinite horizon formulation, where T = ∞,
the cumulative reward may be infinite. To prevent J from being unbounded, we introduce a discount
factor 0 < γ < 1, so that
J ,
X∞
t=1
γ
t−1E [rt] (34.49)
The quantity γ can be interpreted as the probability that the agent is terminated at any moment in
time (in which case it will cease to accumulate reward).
Another way to write this is as follows:
J =
X∞
t=1
γ
t−1E [rt] = X∞
t=1
γ
t−1E
"X
K
a=1
Ra(st, at)
#
(34.50)
where we define
Ra(st, at) = (
R(st, a) if at = a
0 otherwise
(34.51)
3. This is known as a stochastic bandit. It is also possible to allow the reward, and possibly the state, to be chosen
in an adversarial manner, where nature tries to minimize the reward of the agent. This is known as an adversarial
bandit.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.4. CONTEXTUAL BANDITS
Thus we conceptually evaluate the reward for all arms, but only the one that was actually chosen
(namely at) gives a non-zero value to the agent, namely rt.
There are many extensions of the basic bandit problem. A natural one is to allow the agent to
perform multiple plays, choosing M ≤ K distinct arms at once. Let at be the corresponding action
vector which specifies the identity of the chosen arms. Then we define the reward to be
rt =
X
K
a=1
Ra(st, at) (34.52)
where
Ra(st, at) = (
R(st, a) if a ∈ at
0 otherwise
(34.53)
This is useful for modeling resource allocation problems.
Another variant is known as a restless bandit [Whi88]. This is the same as the multiple play
formulation, except we additionally assume that each arm has its own state vector s
a
t associated with
it, which evolves according to some stochastic process, regardless of whether arm a was chosen or
not. We then define
rt =
X
K
a=1
Ra(s
a
t
, at) (34.54)
where s
a
t ∼ p(s
a
t
|s
a
1:t−1
) is some arbitrary distribution, often assumed to be Markovian. (The fact
that the states associated with each arm evolve even if the arm is not picked is what gives rise to the
term “restless”.) This can be used to model serial dependence between the rewards given by each
arm.
34.4.2 Applications
Contextual bandits have many applications. For example, consider an online advertising system.
In this case, the state st represents features of the web page that the user is currently looking at, and
the action at represents the identity of the ad which the system chooses to show. Since the relevance
of the ad depends on the page, the reward function has the form R(st, at), and hence the problem
is contextual. The goal is to maximize the expected reward, which is equivalent to the expected
number of times people click on ads; this is known as the click through rate or CTR. (See e.g.,
[Gra+10; Li+10; McM+13; Aga+14; Du+21; YZ22] for more information about this application.)
Another application of contextual bandits arises in clinical trials [VBW15]. In this case, the
state st are features of the current patient we are treating, and the action at is the treatment the
doctor chooses to give them (e.g., a new drug or a placebo). Our goal is to maximize expected
reward, i.e., the expected number of people who get cured. (An alternative goal is to determine
which treatment is best as quickly as possible, rather than maximizing expected reward; this variant
is known as best-arm identification [ABM10].)
34.4.3 Exploration-exploitation tradeoff
The fundamental difficulty in solving bandit problems is known as the exploration-exploitation
tradeoff. This refers to the fact that the agent needs to try multiple state/action combinations (this
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1112
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
AD AD AD
Users
Historical Data CTR Model Predictions Ad Winner(s)
learning inference Ad-ranking
feedback impression
AD AD AD
2 1 3
Figure 34.7: Illustration of the feedback problem in online advertising and recommendation systems. The
click through rate (CTR) model is used to decide what ads to show, which affects what data is collected, which
affects how the model learns. From Figure 1–2 of [Du+21]. Used with kind permission of Chao Du.
,
,
Action 2
Success Failure Success Failure
, , ,
Action 1
Success Failure
, ,
Action 1
Figure 34.8: Illustration of sequential belief updating for a two-armed beta-Bernoulli bandit. The prior for the
reward for action 1 is the (blue) uniform distribution Beta(1, 1); the prior for the reward for action 2 is the
(orange) unimodal distribution Beta(2, 2). We update the parameters of the belief state based on the chosen
action, and based on whether the observed reward is success (1) or failure (0).
is known as exploration) in order to collect enough data so it can reliably learn the reward function
R(s, a); it can then exploit its knowledge by picking the predicted best action for each state. If the
agent starts exploiting an incorrect model too early, it will collect suboptimal data, and will get
stuck in a negative feedback loop, as illustrated in Figure 34.7. This is different from supervised
learning, where the data is drawn iid from a fixed distribution (see e.g., [Jeu+19] for details).
We discuss some solutions to the exploration-exploitation problem below.
34.4.4 The optimal solution
In this section, we discuss the optimal solution to the exploration-exploitation tradeoff. Let
us denote the posterior over the parameters of the reward function by bt = p(θ|ht), where
ht = {s1:t−1, a1:t−1, r1:t−1} is the history of observations; this is known as the belief state or
information state. It is a finite sufficient statistic for the history ht. The belief state can be
updated deterministically using Bayes’ rule:
bt = BayesRule(bt−1, at, rt) (34.55)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.4. CONTEXTUAL BANDITS
For example, consider a context-free Bernoulli bandit, where pR(r|a) = Ber(r|µa), and µa =
pR(r = 1|a) = R(a) is the expected reward for taking action a. Suppose we use a factored beta prior
p0(θ) = Y
a
Beta(µa|α
a
0
, βa
0
) (34.56)
where θ = (µ1, . . . , µK). We can compute the posterior in closed form, as we discuss in Section 3.4.1.
In particular, we find
p(θ|Dt) = Y
a
Beta(µa| α
a
0 + N
0
t
(a)
| {z }
αa
t
, βa
0 + N
1
t
(a)
| {z }
β
a
t
) (34.57)
where
N
r
t
(a) = Xt−1
s=1
I(at = a, rt = r) (34.58)
This is illustrated in Figure 34.8 for a two-armed Bernoulli bandit.
We can use a similar method for a Gaussian bandit, where pR(r|a) = N (r|µa, σ2
a
), using results
from Section 3.4.3. In the case of contextual bandits, the problem becomes more complicated. If
we assume a linear regression bandit, pR(r|s, a; θ) = N (r|φ(s, a)
Tθ, σ2
), we can use Bayesian
linear regression to compute p(θ|Dt) in closed form, as we discuss in Section 15.2. If we assume
a logistic regression bandit, pR(r|s, a; θ) = Ber(r|σ(φ(s, a)
Tθ)), we can use Bayesian logistic
regression to compute p(θ|Dt), as we discuss in Section 15.3.5. If we have a neural bandit of
the form pR(r|s, a; θ) = GLM(r|f(s, a; θ)) for some nonlinear function f, then posterior inference
becomes more challenging, as we discuss in Chapter 17. However, standard techniques, such as the
extended Kalman filter (Section 17.5.2) can be applied. (For a way to scale this approach to large
DNNs, see the “subspace neural bandit” approach of [DMKM22].)
Regardless of the algorithmic details, we can represent the belief state update as follows:
p(bt|bt−1, at, rt) = I(bt = BayesRule(bt−1, at, rt)) (34.59)
The observed reward at each step is then predicted to be
p(rt|bt) = Z
pR(rt|st, at; θ)p(θ|bt)dθ (34.60)
We see that this is a special form of a (controlled) Markov decision process (Section 34.5) known as a
belief-state MDP.
In the special case of context-free bandits with a finite number of arms, the optimal policy of this
belief state MDP can be computed using dynamic programming (see Section 34.6); the result can
be represented as a table of action probabilities, πt(a1, . . . , aK), for each step; this is known as the
Gittins index [Git89]. However, computing the optimal policy for general contextual bandits is
intractable [PT87], so we have to resort to approximations, as we discuss below.
34.4.5 Upper confidence bounds (UCBs)
The optimal solution to explore-exploit is intractable. However, an intuitively sensible approach is
based on the principle known as “optimism in the face of uncertainty”. The principle selects
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1114
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
actions greedily, but based on optimistic estimates of their rewards. The most important class of
strategies with this principle are collectively called upper confidence bound or UCB methods.
To use a UCB strategy, the agent maintains an optimistic reward function estimate R˜
t, so that
R˜
t(st, a) ≥ R(st, a) for all a with high probability, and then chooses the greedy action accordingly:
at = argmax
a
R˜
t(st, a) (34.61)
UCB can be viewed a form of exploration bonus, where the optimistic estimate encourages
exploration. Typically, the amount of optimism, R˜
t − R, decreases over time so that the agent
gradually reduces exploration. With properly constructed optimistic reward estimates, the UCB
strategy has been shown to achieve near-optimal regret in many variants of bandits [LS19]. (We
discuss regret in Section 34.4.7.)
The optimistic function R˜ can be obtained in different ways, sometimes in closed forms, as we
discuss below.
34.4.5.1 Frequentist approach
One approach is to use a concentration inequality [BLM16] to derive a high-probability upper
bound of the estimation error: |Rˆ
t(s, a) − Rt(s, a)| ≤ δt(s, a), where Rˆ
t is a usual estimate of R
(often the MLE), and δt is a properly selected function. An optimistic reward is then obtained by
setting R˜
t(s, a) = Rˆ
t(s, a) + δt(s, a).
As an example, consider again the context-free Bernoulli bandit, R(a) ∼ Ber(µ(a)). The MLE
Rˆ
t(a) = ˆµt(a) is given by the empirical average of observed rewards whenever action a was taken:
µˆt(a) = N1
t
(a)
Nt(a)
=
N1
t
(a)
N0
t
(a) + N1
t
(a)
(34.62)
where Nr
t
(a) is the number of times (up to step t − 1) that action a has been tried and the observed
reward was r, and Nt(a) is the total number of times action a has been tried:
Nt(a) = Xt−1
s=1
I(at = a) (34.63)
Then the Chernoff-Hoeffding inequality [BLM16] leads to δt(a) = c/p
Nt(a) for some proper
constant c, so
R˜
t(a) = ˆµt(a) + c
p
Nt(a)
(34.64)
34.4.5.2 Bayesian approach
We may also derive R˜ from Bayesian inference. If we use a beta prior, we can compute the posterior
in closed form, as shown in Equation (34.57). The posterior mean is µˆt(a) = E [µ(a)|ht] =
α
a
t
αa
t +β
a
t
.
From Equation (3.17), the posterior standard deviation is approximately
σˆt(a) = p
V [µ(a)|ht] ≈
s
µˆt(a)(1 − µˆt(a))
Nt(a)
(34.65)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.4. CONTEXTUAL BANDITS
Figure 34.9: Illustration of the reward distribution Q(a) for 3 different actions, and the corresponding lower
and upper confidence bounds. From [Sil18]. Used with kind permission of David Silver.
We can use similar techniques for a Gaussian bandit, where pR(R|a, θ) = N (R|µa, σ2
a
), µa is the
expected reward, and σ
2
a
the variance. If we use a conjugate prior, we can compute p(µa, σa|Dt)
in closed form (see Section 3.4.3). Using an uninformative version of the conjugate prior, we find
E [µa|ht] = µˆt(a), which is just the empirical mean of rewards for action a. The uncertainty in
this estimate is the standard error of the mean, given by Equation (3.133), i.e., p
V [µa|ht] =
σˆt(a)/
p
Nt(a), where σˆt(a) is the empirical standard deviation of the rewards for action a.
This approach can also be extended to contextual bandits, modulo the difficulty of computing the
belief state.
Once we have computed the mean and posterior standard deviation, we define the optimistic
reward estimate as
R˜
t(a) = ˆµt(a) + cσˆt(a) (34.66)
for some constant c that controls how greedy the policy is. We see that this is similar to the frequentist
method based on concentration inequalities, but is more general.
34.4.5.3 Example
Figure 34.9 illustrates the UCB principle for a Gaussian bandit. We assume there are 3 actions, and
we represent p(R(a)|Dt) using a Gaussian. We show the posterior means Q(a) = µ(a) with a vertical
dotted line, and the scaled posterior standard deviations cσ(a) as a horizontal solid line.
34.4.6 Thompson sampling
A common alternative to UCB is to use Thompson sampling [Tho33], also called probability
matching [Sco10]. In this approach, we define the policy at step t to be πt(a|st, ht) = pa, where pa
is the probability that a is the optimal action. This can be computed using
pa = Pr(a = a∗|st, ht) = Z
I

a = argmax
a′
R(st, a′
; θ)

p(θ|ht)dθ (34.67)
If the posterior is uncertain, the agent will sample many different actions, automatically resulting in
exploration. As the uncertainty decreases, it will start to exploit its knowledge.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1116
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0
−20
−15
−10
−5
0
5
10
arm0
arm1
arm2
(a)
0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0
time
0
200
400
600
800
1000
1200
1400
cumulative reward
arm0
arm1
arm2
(b)
0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0
time
0
5
10
15
20
25
30
35
40
L
T
Cumulative regret
observed
c √ t
(c)
Figure 34.10: Illustration of Thompson sampling applied to a linear-Gaussian contextual bandit. The context
has the form st = (1, t, t2
). (a) True reward for each arm vs time. (b) Cumulative reward per arm vs time.
(c) Cumulative regret vs time. Generated by thompson_sampling_linear_gaussian.ipynb.
To see how we can implement this method, note that we can compute the expression in Equa￾tion (34.67) by using a single Monte Carlo sample θ˜
t ∼ p(θ|ht). We then plug in this parameter into
our reward model, and greedily pick the best action:
at = argmax
a′
R(st, a′
; θ˜
t) (34.68)
This sample-then-exploit approach will choose actions with exactly the desired probability, since
pa =
Z
I

a = argmax
a′
R(st, a′
; θ˜
t)

p(θ˜
t|ht) = Pr
θ˜t∼p(θ|ht)
(a = argmax
a′
R(st, a′
; θ˜
t)) (34.69)
Despite its simplicity, this approach can be shown to achieve optimal (logarithmic) regret (see
e.g., [Rus+18] for a survey). In addition, it is very easy to implement, and hence is widely used in
practice [Gra+10; Sco10; CL11].
In Figure 34.10, we give a simple example of Thompson sampling applied to a linear regression bandit.
The context has the form st = (1, t, t2
). The true reward function has the form R(st, a) = wT
ast. The
weights per arm are chosen as follows: w0 = (−5, 2, 0.5), w1 = (0, 0, 0), w2 = (5, −1.5, −1). Thus we
see that arm 0 is initially worse (large negative bias) but gets better over time (positive slope), arm 1
is useless, and arm 2 is initially better (large positive bias) but gets worse over time. The observation
noise is the same for all arms, σ
2 = 1. See Figure 34.10(a) for a plot of the reward function.
We use a conjugate Gaussian-gamma prior and perform exact Bayesian updating. Thompson
sampling quickly discovers that arm 1 is useless. Initially it pulls arm 2 more, but it adapts to the
non-stationary nature of the problem and switches over to arm 0, as shown in Figure 34.10(b).
34.4.7 Regret
We have discussed several methods for solving the exploration-exploitation tradeoff. It is useful
to quantify the degree of suboptimality of these methods. A common approach is to compute the
regret, which is defined as the difference between the expected reward under the agent’s policy and
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.4. CONTEXTUAL BANDITS
the oracle policy π∗, which knows the true reward function. (Note that the oracle policy will in
general be better than the Bayes optimal policy, which we disucssed in Section 34.4.4.)
Specifically, let πt be the agent’s policy at time t. Then the per-step regret at t is defined as
lt , Ep(st)
[R(st, π∗(st))] − Eπt(at|st)p(st)
[R(st, at)] (34.70)
If we only care about the final performance of the best discovered arm, as in most optimization
problems, it is enough to look at the simple regret at the last step, namely lT . Optimizing simple
regret results in a problem known as pure exploration [BMS11], since there is no need to exploit
the information during the learning process. However, it is more common to focus on the cumulative
regret, also called the total regret or just the regret, which is defined as
LT , E
"X
T
t=1
lt
#
(34.71)
Here the expectation is with respect to randomness in determining πt, which depends on earlier
states, actions and rewards, as well as other potential sources of randomness.
Under the typical assumption that rewards are bounded, LT is at most linear in T. If the agent’s
policy converges to the optimal policy as T increases, then the regret is sublinear: LT = o(T). In
general, the slower LT grows, the more efficient the agent is in trading off exploration and exploitation.
To understand its growth rate, it is helpful to consider again a simple context-free bandit, where
R∗ = argmaxa R(a) is the optimal reward. The total regret in the first T steps can be written as
LT = E
"X
T
t=1
R∗ − R(at)
#
=
X
a∈A
E [NT +1(a)] (R∗ − R(a)) = X
a∈A
E [NT +1(a)] ∆a (34.72)
where NT +1(a) is the total number of times the agent picks action a up to step T, and ∆a = R∗−R(a)
is the reward gap. If the agent under-explores and converges to choosing a suboptimal action (say,
aˆ), then a linear regret is suffered with a per-step regret of ∆aˆ. On the other hand, if the agent
over-explores, then Nt(a) will be too large for suboptimal actions, and the agent also suffers a linear
regret.
Fortunately, it is possible to achieve sublinear regrets, using some of the methods discussed above,
such as UCB and Thompson sampling. For example, one can show that Thompson sampling has
O(
√
KT log T) regret [RR14]. This is shown empirically in Figure 34.10(c).
In fact, both UCB and Thompson sampling are optimal, in the sense that their regrets are
essentially not improvable; that is, they match regret lower bounds. To establish such a lower bound,
note that the agent needs to collect enough data to distinguish different reward distributions, before
identifying the optimal action. Typically, the deviation of the reward estimate from the true reward
decays at the rate of 1/
√
N, where N is the sample size (see e.g., Equation (3.133)). Therefore, if
two reward distributions are similar, distinguishing them becomes harder and requires more samples.
(For example, consider the case of a bandit with Gaussian rewards with slightly different means and
large variance, as shown in Figure 34.9.)
The following fundamental result is proved by [LR85] for the asymptotic regret (under certain mild
assumptions not given here):
lim inf
T→∞
LT ≥ log T
X
a:∆a>0
∆a
DKL (pR(a) k pR(a∗))
(34.73)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1118
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 34.11: Illustration of an MDP as a finite state machine (FSM). The MDP has three discrete states
(green cirlces), two discrete actions (orange circles), and two non-zero rewards (orange arrows). The numbers
on the black edges represent state transition probabilities, e.g., p(s
′ = s0|a = a0, s′ = s0) = 0.7; most
state transitions are impossible (probability 0), so the graph is sparse. The numbers on the yellow wiggly
edges represent expected rewards, e.g., R(s = s1, a = a0, s′ = s0) = +5; state transitions with zero reward
are not annotated. From https: // en. wikipedia. org/ wiki/ Markov_ decision_ process . Used with kind
permission of Wikipedia author waldoalvarez.
Thus, we see that the best we can achieve is logarithmic growth in the total regret. Similar lower
bounds have also been obtained for various bandits variants.
34.5 Markov decision problems
In this section, we generalize the discussion of contextual bandits by allowing the state of nature
to change depending on the actions chosen by the agent. The resulting model is called a Markov
decision process or MDP, as we explain in detail below. This model forms the foundation of
reinforcement learning, which we discuss in Chapter 35.
34.5.1 Basics
A Markov decision process [Put94] can be used to model the interaction of an agent and an
environment. It is often described by a tuple hS, A, pT , pR, p0i, where S is a set of environment
states, A a set of actions the agent can take, pT a transition model, pR a reward model, and p0
the initial state distribution. The interaction starts at time t = 0, where the initial state s0 ∼ p0.
Then, at time t ≥ 0, the agent observes the environment state st ∈ S, and follows a policy π to
take an action at ∈ A. In response, the environment emits a real-valued reward signal rt ∈ R and
enters a new state st+1 ∈ S. The policy is in general stochastic, with π(a|s) being the probability of
choosing action a in state s. We use π(s) to denote the conditional probability over A if the policy
is stochastic, or the action it chooses if it is deterministic. The process at every step is called a
transition; at time t, it consists of the tuple (st, at, rt, st+1), where at ∼ π(st), st+1 ∼ pT (st, at),
and rt ∼ pR(st, at, st+1). Hence, under policy π, the probability of generating a trajectory τ of
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.5. MARKOV DECISION PROBLEMS
length T can be written explicitly as
p(τ ) = p0(s0)
T
Y−1
t=0
π(at|st)pT (st+1|st, at)pR(rt|st, at, st+1) (34.74)
It is useful to define the reward function from the reward model pR, as the average immediate
reward of taking action a in state s, with the next state marginalized:
R(s, a) , EpT (s
′
|s,a)

Ep(r|s,a,s′)
[r]

(34.75)
Eliminating the dependence on next states does not lead to loss of generality in the following
discussions, as our subject of interest is the total (additive) expected reward along the trajectory.
For this reason, we often use the tuple hS, A, pT , R, p0i to describe an MDP.
In general, the state and action sets of an MDP can be discrete or continuous. When both sets are
finite, we can represent these functions as lookup tables; this is known as a tabular representation.
In this case, we can represent the MDP as a finite state machine, which is a graph where nodes
correspond to states, and edges correspond to actions and the resulting rewards and next states.
Figure 34.11 gives a simple example of an MDP with 3 states and 2 actions.
The field of control theory, which is very closely related to RL, uses slightly different terminology.
In particular, the environment is called the plant, and the agent is called the controller. States are
denoted by xt ∈ X ⊆ R
D, actions are denoted by ut ∈ U ⊆ R
K, and rewards are denoted by costs
ct ∈ R. Apart from this notational difference, the fields of RL and control theory are very similar
(see e.g., [Son98; Rec19]), although control theory tends to focus on provably optimal methods (by
making strong modeling assumptions), whereas RL tends to tackle harder problems with heuristic
methods, for which optimality guarantees are often hard to obtain.
34.5.2 Partially observed MDPs
An important generalization of the MDP framework relaxes the assumption that the agent sees the
hidden world state st directly; instead we assume it only sees a potentially noisy observation generated
from the hidden state, xt ∼ p(·|st, at). The resulting model is called a partially observable Markov
decision process or POMDP (pronounced “pom-dee-pee”). Now the agent’s policy is a mapping
from all the available data to actions, at ∼ π(D1:t−1, xt), Dt = (xt, at, rt). See Figure 34.12 for an
illustration. MDPs are a special case where xt = st.
In general, POMDPs are much harder to solve than MDPs (see e.g., [KLC98]). A common
approximation is to use the last several observed inputs, say xt−h:t for history of size h, as a proxy
for the hidden state, and then to treat this as a fully observed MDP.
34.5.3 Episodes and returns
The Markov decision process describes how a trajectory τ = (s0, a0, r0, s1, a1, r1, . . .) is stochastically
generated. If the agent can potentially interact with the environment forever, we call it a continuing
task. Alternatively, the agent is in an episodic task, if its interaction terminates once the system
enters a terminal state or absorbing state; s is absorbing if the next state from s is always s
with 0 reward. After entering a terminal state, we may start a new epsiode from a new initial state
s0 ∼ p0. The episode length is in general random. For example, the amount of time a robot takes to
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1120
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
s0 s1 s2
x0 x1 x2
b0 b1 b2
a0 a1
r0 r1
· · ·
· · ·
environment
agent
Figure 34.12: Illustration of a partially observable Markov decision process (POMDP) with hidden environment
state st which generates the observation xt, controlled by an agent with internal belief state bt which generates
the action at. The reward rt depends on st and at. Nodes in this graph represent random variables (circles)
and decision variables (squares).
reach its goal may be quite variable, depending on the decisions it makes, and the randomness in the
environment. Note that we can convert an episodic MDP to a continuing MDP by redefining the
transition model in absorbing states to be the initial-state distribution p0. Finally, if the trajectory
length T in an episodic task is fixed and known, it is called a finite horizon problem.
Let τ be a trajectory of length T, where T may be ∞ if the task is continuing. We define the
return for the state at time t to be the sum of expected rewards obtained going forwards, where
each reward is multiplied by a discount factor γ ∈ [0, 1]:
Gt , rt + γrt+1 + γ
2
rt+2 + · · · + γ
T −t−1
rT −1 (34.76)
=
T
X−t−1
k=0
γ
k
rt+k =
T
X−1
j=t
γ
j−t
rj (34.77)
Gt is sometimes called the reward-to-go. For episodic tasks that terminate at time T, we define
Gt = 0 for t ≥ T. Clearly, the return satisfies the following recursive relationship:
Gt = rt + γ(rt+1 + γrt+2 + · · ·) = rt + γGt+1 (34.78)
The discount factor γ plays two roles. First, it ensures the return is finite even if T = ∞ (i.e.,
infinite horizon), provided we use γ < 1 and the rewards rt are bounded. Second, it puts more weight
on short-term rewards, which generally has the effect of encouraging the agent to achieve its goals
more quickly (see Section 34.5.5.1 for an example). However, if γ is too small, the agent will become
too greedy. In the extreme case where γ = 0, the agent is completely myopic, and only tries to
maximize its immediate reward. In general, the discount factor reflects the assumption that there
is a probability of 1 − γ that the interaction will end at the next step. For finite horizon problems,
where T is known, we can set γ = 1, since we know the life time of the agent a priori.4
4. We may also use γ = 1 for continuing tasks, targeting the (undiscounted) average reward criterion [Put94].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.5. MARKOV DECISION PROBLEMS
34.5.4 Value functions
Let π be a given policy. We define the state-value function, or value function for short, as
follows (with Eπ [·] indicating that actions are selected by π):
Vπ(s) , Eπ [G0|s0 = s] = Eπ
"X∞
t=0
γ
t
rt|s0 = s
#
(34.79)
This is the expected return obtained if we start in state s and follow π to choose actions in a
continuing task (i.e., T = ∞).
Similarly, we define the action-value function, also known as the Q-function, as follows:
Qπ(s, a) , Eπ [G0|s0 = s, a0 = a] = Eπ
"X∞
t=0
γ
t
rt|s0 = s, a0 = a
#
(34.80)
This quantity represents the expected return obtained if we start by taking action a in state s, and
then follow π to choose actions thereafter.
Finally, we define the advantage function as follows:
Aπ(s, a) , Qπ(s, a) − Vπ(s) (34.81)
This tells us the benefit of picking action a in state s then switching to policy π, relative to the
baseline return of always following π. Note that Aπ(s, a) can be both positive and negative, and
Eπ(a|s)
[Aπ(s, a)] = 0 due to a useful equality: Vπ(s) = Eπ(a|s)
[Qπ(s, a)].
34.5.5 Optimal value functions and policies
Suppose π∗ is a policy such that Vπ∗ ≥ Vπ for all s ∈ S and all policy π, then it is an optimal
policy. There can be multiple optimal policies for the same MDP, but by definition their value
functions must be the same, and are denoted by V∗ and Q∗, respectively. We call V∗ the optimal
state-value function, and Q∗ the optimal action-value function. Furthermore, any finite MDP
must have at least one deterministic optimal policy [Put94].
A fundamental result about the optimal value function is Bellman’s optimality equations:
V∗(s) = max
a
R(s, a) + γEpT (s
′
|s,a)
[V∗(s
′
)] (34.82)
Q∗(s, a) = R(s, a) + γEpT (s
′
|s,a)
h
max
a′
Q∗(s
′
, a′
)
i
(34.83)
Conversely, the optimal value functions are the only solutions that satisfy the equations. In other
words, although the value function is defined as the expectation of a sum of infinitely many rewards,
it can be characterized by a recursive equation that involves only one-step transition and reward
models of the MDP. Such a recursion play a central role in many RL algorithms we will see later
in this chapter. Given a value function (V or Q), the discrepancy between the right- and left-hand
sides of Equations (34.82) and (34.83) are called Bellman error or Bellman residual.
Furthermore, given the optimal value function, we can derive an optimal policy using
π∗(s) = argmax
a
Q∗(s, a) (34.84)
= argmax
a

R(s, a) + γEpT (s
′
|s,a)
[V∗(s
′
)]
(34.85)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1122
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Following such an optimal policy ensures the agent achieves maximum expected return starting from
any state. The problem of solving for V∗, Q∗ or π∗ is called policy optimization. In contrast,
solving for Vπ or Qπ for a given policy π is called policy evaluation, which constitutes an important
subclass of RL problems as will be discussed in later sections. For policy evaluation, we have similar
Bellman equations, which simply replace maxa{·} in Equations (34.82) and (34.83) with Eπ(a|s)
[·].
In Equations (34.84) and (34.85), as in the Bellman optimality equations, we must take a maximum
over all actions in A, and the maximizing action is called the greedy action with respect to the
value functions, Q∗ or V∗. Finding greedy actions is computationally easy if A is a small finite
set. For high dimensional continuous spaces, we can treat a as a sequence of actions, and optimize
one dimension at a time [Met+17], or use gradient-free optimizers such as cross-entropy method
(Section 6.7.5), as used in the QT-Opt method [Kal+18a]. Recently, CAQL (continuous action
Q-learning, [Ryu+20]) proposed to use mixed integer programming to solve the argmax problem,
leveraging the ReLU structure of the Q-network. We can also amortize the cost of this optimization
by training a policy a∗ = π∗(s) after learning the optimal Q-function.
34.5.5.1 Example
In this section, we show a simple example, to make concepts like value functions more concrete.
Consider the 1d grid world shown in Figure 34.13(a). There are 5 possible states, among them ST1
and ST2 are absorbing states, since the interaction ends once the agent enters them. There are 2
actions, ↑ and ↓. The reward function is zero everywhere except at the goal state, ST2, which gives a
reward of 1 upon entering. Thus the optimal action in every state is to move down.
Figure 34.13(b) shows the Q∗ function for γ = 0. Note that we only show the function for
non-absorbing states, as the optimal Q-values are 0 in absorbing states by definition. We see that
Q∗(s3, ↓) = 1.0, since the agent will get a reward of 1.0 on the next step if it moves down from s3;
however, Q∗(s, a) = 0 for all other state-action pairs, since they do not provide nonzero immediate
reward. This optimal Q-function reflects the fact that using γ = 0 is completely myopic, and ignores
the future.
Figure 34.13(c) shows Q∗ when γ = 1. In this case, we care about all future rewards equally. Thus
Q∗(s, a) = 1 for all state-action pairs, since the agent can always reach the goal eventually. This is
infinitely far-sighted. However, it does not give the agent any short-term guidance on how to behave.
For example, in s2, it is not clear if it is should go up or down, since both actions will eventually
reach the goal with identical Q∗-values.
Figure 34.13(d) shows Q∗ when γ = 0.9. This reflects a preference for near-term rewards, while
also taking future reward into account. This encourages the agent to seek the shortest path to the
goal, which is usually what we desire. A proper choice of γ is up to the agent designer, just like the
design of the reward function, and has to reflect the desired behavior of the agent.
34.6 Planning in an MDP
In this section, we discuss how to compute an optimal policy when the MDP model is known. This
problem is called planning, in contrast to the learning problem where the models are unknown,
which is tackled using reinforcement learning Chapter 35. The planning algorithms we discuss are
based on dynamic programming (DP) and linear programming (LP).
For simplicity, in this section, we assume discrete state and action sets with γ < 1. However, exact
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.6. PLANNING IN AN MDP
ST1
S1
S2
S3
ST2
ST1
S1
S2
S3
ST2
0
0
0
0
1 
0 0
0 0
0 1.0
0 1.0
1.0 1.0
1.0 1.0
0 0.81
0.73 0.9
0.81 1.0
Up Down Up Down Up Down
R(s)
Q*(s, a)
Up 
a1 
Down 
a2 
(a) (b) (c) (d)
𝛄 = 0 𝛄 = 1 𝛄 = 0.9
Figure 34.13: Left: illustration of a simple MDP corresponding to a 1d grid world of 3 non-absorbing states
and 2 actions. Right: optimal Q-functions for different values of γ. Adapted from Figures 3.1, 3.2, 3.4 of
[GK19].
calculation of optimal policies often depends polynomially on the sizes of S and A, and is intractable,
for example, when the state space is a Cartesian product of several finite sets. This challenge is known
as the curse of dimensionality. Therefore, approximations are typically needed, such as using
parametric or nonparametric representations of the value function or policy, both for computational
tractability and for extending the methods to handle MDPs with general state and action sets.
In this case, we have approximate dynamic programming (ADP) and approximate linear
programming (ALP) algorithms (see e.g., [Ber19]).
34.6.1 Value iteration
A popular and effective DP method for solving an MDP is value iteration (VI). Starting from an
initial value function estimate V0, the algorithm iteratively updates the estimate by
Vk+1(s) = max
a
"
R(s, a) + γ
X
s
′
p(s
′
|s, a)Vk(s
′
)
#
(34.86)
Note that the update rule, sometimes called a Bellman backup, is exactly the right-hand side of
the Bellman optimality equation Equation (34.82), with the unknown V∗ replaced by the current
estimate Vk. A fundamental property of Equation (34.86) is that the update is a contraction: it
can be verified that
max
s
|Vk+1(s) − V∗(s)| ≤ γ max
s
|Vk(s) − V∗(s)| (34.87)
In other words, every iteration will reduce the maximum value function error by a constant factor.
It follows immediately that Vk will converge to V∗, after which an optimal policy can be extracted
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1124
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
using Equation (34.85). In practice, we can often terminate VI when Vk is close enough to V∗, since
the resulting greedy policy wrt Vk will be near optimal. Value iteration can be adapted to learn the
optimal action-value function Q∗.
In value iteration, we compute V∗(s) and π∗(s) for all possible states s, averaging over all possible
next states s
′ at each iteration, as illustrated in Figure 34.14(right). However, for some problems,
we may only be interested in the value (and policy) for certain special starting states. This is the
case, for example, in shortest path problems on graphs, where we are trying to find the shortest
route from the current state to a goal state. This can be modeled as an episodic MDP by defining a
transition matrix pT (s
′
|s, a) where taking edge a from node s leads to the neighboring node s
′ with
probability 1. The reward function is defined as R(s, a) = −1 for all states s except the goal states,
which are modeled as absorbing states.
In problems such as this, we can use a method known as real-time dynamic programming
(RTDP) [BBS95], to efficiently compute an optimal partial policy, which only specifies what to do
for the reachable states. RTDP maintains a value function estimate V . At each step, it performs a
Bellman backup for the current state s by V (s) ← maxa EpT (s
′
|s,a)
[R(s, a) + γV (s
′
)]. It can picks an
action a (often with some exploration), reaches a next state s
′
, and repeats the process. This can be
seen as a form of the more general asynchronous value iteration, that focuses its computational
effort on parts of the state space that are more likely to be reachable from the current state, rather
than synchronously updating all states at each iteration.
34.6.2 Policy iteration
Another effective DP method for computing π∗ is policy iteration. It is an iterative algorithm that
searches in the space of deterministic policies until converging to an optimal policy. Each iteration
consists of two steps, policy evaluation and policy improvement.
The policy evaluation step, as mentioned earlier, computes the value function for the current
policy. Let π represent the current policy, v(s) = Vπ(s) represent the value function encoded as
a vector indexed by states, r(s) = P
a
π(a|s)R(s, a) represent the reward vector, and T(s
′
P
|s) =
a
π(a|s)p(s
′
|s, a) represent the state transition matrix. Bellman’s equation for policy evaluation
can be written in the matrix-vector form as
v = r + γTv (34.88)
This is a linear system of equations in |S| unknowns. We can solve it using matrix inversion:
v = (I − γT)
−1r. Alternatively, we can use value iteration by computing vt+1 = r + γTvt until near
convergence, or some form of asynchronous variant that is computationally more efficient.
Once we have evaluated Vπ for the current policy π, we can use it to derive a better policy π
′
, thus
the name policy improvement. To do this, we simply compute a deterministic policy π
′
that acts
greedily with respect to Vπ in every state; that is, π
′
(s) = argmaxa{R(s, a) + γE [Vπ(s
′
)]}. We can
guarantee that Vπ′ ≥ Vπ. To see this, define r
′
, T′ and v
′ as before, but for the new policy π
′
. The
definition of π
′
implies r
′ + γT′v ≥ r + γTv = v, where the equality is due to Bellman’s equation.
Repeating the same equality, we have
v ≤ r
′ + γT
′v ≤ r
′ + γT
′
(r
′ + γT
′v) ≤ r
′ + γT
′
(r
′ + γT
′
(r
′ + γT
′v)) ≤ · · · (34.89)
= (I + γT
′ + γ
2T
′2 + · · ·)r = (I − γT
′
)
−1
r = v
′
(34.90)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.6. PLANNING IN AN MDP
Figure 34.14: Policy iteration vs value iteration represented as backup diagrams. Empty circles represent
states, solid (filled) circles represent states and actions. Adapted from Figure 8.6 of [SB18].
Starting from an initial policy π0, policy iteration alternates between policy evaluation (E) and
improvement (I) steps, as illustrated below:
π0
E
→ Vπ0
I
→ π1
E
→ Vπ1
· · ·
I
→ π∗
E
→ V∗ (34.91)
The algorithm stops at iteration k, if the policy πk is greedy with respect to its own value function
Vπk
. In this case, the policy is optimal. Since there are at most |A||S| deterministic policies, and
every iteration strictly improves the policy, the algorithm must converge after finite iterations.
In PI, we alternate between policy evaluation (which involves multiple iterations, until convergence
of Vπ), and policy improvement. In VI, we alternate between one iteration of policy evaluation followed
by one iteration of policy improvement (the “max” operator in the update rule). In generalized
policy improvement, we are free to intermix any number of these steps in any order. The process
will converge once the policy is greedy wrt its own value function.
Note that policy evaluation computes Vπ whereas value iteration computes V∗. This difference is
illustrated in Figure 34.14, using a backup diagram. Here the root node represents any state s,
nodes at the next level represent state-action combinations (solid circles), and nodes at the leaves
representing the set of possible resulting next state s
′
for each possible action. In the former case, we
average over all actions according to the policy, whereas in the latter, we take the maximum over all
actions.
34.6.3 Linear programming
While dynamic programming is effective and popular, linear programming (LP) provides an alternative
that finds important uses, such as in off-policy RL (Section 35.5). The primal form of LP is given by
min
V
X
s
p0(s)V (s) s.t. V (s) ≥ R(s, a) + γ
X
s
′
pT (s
′
|s, a)V (s), ∀(s, a) ∈ S × A (34.92)
where p0(s) > 0 for all s ∈ S, and can be interpreted as the initial state distribution. It can be
verified that any V satisfying the constraint in Equation (34.92) is optimistic [Put94], that is, V ≥ V∗.
When the objective is minimized, the solution V will be “pushed” to the smallest possible, which is
V∗. Once V∗ is found, any action a that makes the constraint tight in state s is optimal in that state.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1126
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The dual LP form is sometimes more intuitive:
max
d≥0
X
s,a
d(s, a)R(s, a) s.t.
X
a
d(s, a) = (1 − γ)p0(s) + γ
X
s, ¯ a¯
pT (s|s, ¯ a¯)d(¯s, a¯) ∀s ∈ S (34.93)
Any nonnegative d satisfying the constraint above is the normalized occupancy distribution of
some corresponding policy πd(a|s) , d(s, a)/
P
a′ d(s, a′
):
5
d(s, a) = (1 − γ)
X∞
t=0
γ
t
p
￾
st = s, at = a|s0 ∼ p0, at ∼ πd(st)

(34.94)
The constant (1 − γ) normalizes d to be a valid distribution, so that it sums to unity. With this
interpretation of d, the objective in Equation (34.93) is just the average per-step reward under the
normalized occupancy distribution. Once an optimal solution d∗ is found, an optimal policy can be
immediately obtained by π∗(a|s) = d∗(s, a)/
P
a′ d∗(s, a′
).
A challenge in solving the primal or dual LPs for MDPs is the large number of constraints and
variables. Approximations are needed, where the variables are parameterized (either linearly or
nonlinearly), and the constraints are sampled or approximated (see e.g., [dV04; LBS17; CLW18]).
34.7 Active learning
This section is coauthored with Zeel B Patel.
In this section, we discuss active learning (AL), in which the agent gets to choose which data it
wants to use so as to learn the underlying predictive function as quickly as possible, i.e., using the
smallest amount of labeled data. This can be much more efficient than using randomly collected data,
as illustrated in Figure 34.15. This is useful when labels are expensive to collect, e.g., for medical
image classification [GIG17; Wal+20].
There are many approaches to AL, as reviewed in [Set12; Ren+21; ZSH22]. In this section, we just
consider a few methods.
34.7.1 Active learning scenarios
One of the earliest AL methods is known as membership query synthesis [Ang88]. In this scenario
the agent can generate an arbitrary query x ∼ p(x) and then ask the oracle for its label, y = f(x).
(An “oracle” is the term given to a system that knows the true answer to every possible question.)
This scenario is mostly of theoretical interest, since it is hard to learn good generative models, and it
is rarely possible to have access to an oracle on demand (although human-power crowd computing
platforms can be considered as oracles with high latency).
Another scenario is stream-based selective sampling [ACL89], where the agent receives a
stream of inputs, x1, x2, . . ., and at each step must decide whether to request the label or not. Again,
this scenario is mostly of theoretical interest.
The last and widely used setting for machine learning is pool-based-sampling [LG94], where the
pool of unlabeled samples X is available from the beginning. At each step we apply an acquisition
5. If P
a′ d(s, a
′
) = 0 for some state s, then πd(s) may be defined arbitrarily, since s is not visited under the policy.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.7. ACTIVE LEARNING
Feature 1
Feature 2
Train Data
Pool Data
(a)
Feature 1
Queried Data
Train Data
Pool Data
(b)
Feature 1
Queried Data
Train Data
Pool Data
(c)
Figure 34.15: Decision boundaries for a logistic regression model applied to a 2-dimensional, 3-class dataset.
(a) Results after fitting the model on the initial training data; the test accuracy is 0.818. (b) results
after further training on 11 randomly sampled points; accuracy is 0.848. (c) Results after further train￾ing on 11 points chosen with margin sampling (see Section 34.7.3); accuracy is 0.969. Generated by
active_learning_visualization_class.ipynb.
Problem Goal Action space
Active learning argminf Ep(x)
[ℓ(f
∗
(x), f(x))] choose x at which to get y = f
∗
(x)
Bayesian optimization argmaxx∈X f
∗
(x) choose x at which to evaluate f
∗
(x)
Contextual bandits argmaxπ Ep(x)π(a|x)
[R∗
(x, a)] choose a at which to evaluate R∗
(x, a)
Table 34.1: Comparison among active learning, Bayesian optimization, and contextual bandits in terms of
goal and action space.
function to each candidate in the batch, to decide which one to collect the label for. We then collect
the label, update the model with the new data, and repeat the process until we exhaust the pool,
run out of time, or reach some desired performance. In the subsequent sections, we will focus only
on pool-based sampling.
34.7.2 Relationship to other forms of sequential decision making
(Pool-based) active learning is closely related to Bayesian optimization (BO, Section 6.6) and contexual
bandit problems (Section 34.4). The connections are discussed at length [Tou14], but in brief, the
methods differ because they solve slightly different objective functions, as summarized in Table 34.1.
In particular, in active learning, our goal is to identify a function f : X → Y that will incur minimum
expected loss when applied to random inputs x; in BO, our goal is to identify an input point x where
the function output f(x) is maximal; and in bandits, our goal is to identify a policy π : X → A that
will give maximum expected reward when applied to random inputs (contexts) x. (We see that the
goal in AL and bandits is similar, but in bandits the agent only gets to choose the action, not the
state, so only has partial control over where the (reward) function is evaluated.)
In all three problems, we want to find the optimum with as few actions as possible, so we have
to solve the exploration-exploitation problem (Section 34.4.3). One approach is to represent our
uncertainty about the function using a method such as a Gaussian process (Chapter 18), which lets
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1128
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
0.0 0.2 0.4 0.6 0.8 1.0
−1
0
1
True function
Predictive mean
0.0 0.2 0.4 0.6 0.8 1.0
0.01
0.02
0.03
Variance
(a) Active learning
0.0 0.2 0.4 0.6 0.8 1.0
−1
0
1
95% confidence
0.0 0.2 0.4 0.6 0.8 1.0
0.0
0.5
Probability of improvement
(b) Bayesian optimization
Figure 34.16: Active learning vs Bayesian optimization. Active learning tries to approximate the true function
well. Bayesian optimization tries to find maximum value of the true function. Initial and queried points are
denoted as black and red dots respectively. Generated by bayes_opt_vs_active_learning.ipynb.
us compute p(f|D1:t). We then define some acquisition function α(x) that evaluates how useful it
would be to query the function at input location x, given the belief state p(f|D1:t) and we pick as
our next query xt+1 = argmaxx α(x). (In the bandit setting, the agent does not get to choose the
state x, but does get to choose action a.) For example, in BO, it is common to use probability of
improvement (Section 6.6.3.1), and for AL of a regression task, we can use the posterior predictive
variance. The objective for AL will cause the agent to query “all over the place”, whereas for BO,
the agent will “zoom in” on the most promising regions, as shown in Figure 34.16. We discuss other
acquisition functions for AL in Section 34.7.3.
34.7.3 Acquisition strategies
In this section, we discuss some common AL heuristics for choosing which points to query.
34.7.3.1 Uncertainty sampling
An intuitive heuristic for choosing which example to label next is to pick the one for which the model
is currently most uncertain. This is called uncertainty sampling. We already illustrated this in
the case of regression in Figure 34.16, where we represented uncertainty in terms of the posterior
variance.
For classification problems, we can measure uncertainty in various ways. Let pn = [p(y = c|xn)]C
c=1
be the vector of class probabilities for each unlabeled input xn. Let Un = α(pn) be the uncertainty for
example n, where α is an acquisition function. Some common choices for α are: entropy sampling
[SW87a], which uses α(p) = −
PC
c=1 pc log pc; margin sampling, which uses α(p) = p2 − p1, where
p1 is the probability of the most probable class, and p2 is the probability of the second most probable
class; and least confident sampling, which uses α(p) = 1 − pc
∗ , where c
∗ = argmaxc pc. The
difference between these strategies is shown in Figure 34.17. In practice it is often found that margin
sampling works the best [Chu+19].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.7. ACTIVE LEARNING
0 1 2 3 4 5 6 7 8 9
Predicted Digit
0.0
0.5
Probability
0.2067 0.2370
0 1 2 3 4 5 6 7 8 9
Predicted Digit
0.2277 0.2513
0 1 2 3 4 5 6 7 8 9
Predicted Digit
0.4689 0.4687
0.0
1.0
2.0
Uncertainty
0.030
0.763
entropy 1.630
margin
least confidence
0.0
1.1
2.2
0.024
0.749
entropy 1.782
margin
least confidence
0.0
0.7
1.3
0.000
0.531
0.892
entropy
margin
least confidence
Figure 34.17: Outputs of a logistic regression model fit on some training points, and then applied to 3
candidate query inputs. We show the predicted probabilites for each class label. The highlighted dark gray
is the max probability, the light gray bar is the 2nd highest probability. The least confident scores for the 3
inputs are: 1 − 0.23 = 0.76, 1 − 0.25 = 0.75, and 1 − 0.47 = 0.53, so we pick the first query. The entropy
scores are: 1.63, 1.78 and 0.89, so we pick the second query. The margin scores are: 0.237 − 0.2067 = 0.0303,
0.2513 − 0.2277 = 0.0236, and 0.4689 − 0.4687 = 0.0002, so we pick the third query. Generated by
active_learning_comparison_mnist.ipynb.
34.7.3.2 Query by committee
In this section, we discuss how to apply uncertainty sampling to models, such as support vector
machines (SVMs), that only return a point prediction rather than a probability distribution. The
basic approach is to create an ensemble of diverse models, and to use disagreement between the
model predictions as a form of uncertainty. (This can be useful even for probabilistic models, such as
DNNs, since model uncertainty can often be larger than parametric uncertainty, as we discuss in the
section on deep ensembles, Section 17.3.9.)
In more detail, suppose we have K ensemble members, and let c
k
n be the predicted class from
member k on input xn. Let vnc =
PK
k=1 I
￾
c
k
n = c

be the number of votes cast for class c, and
qnc = vnc/C be the induced distribution. (A similar method can be used for regression models,
where we use the standard deviation of the prediction across the members.) We can then use margin
sampling or entropy sampling with distribution qn. This approach is called query by committee
(QBC) [SOS92], and can often out-perform vanilla uncertainty sampling with a single model, as we
show in Figure 34.18.
34.7.3.3 Information theoretic methods
A natural acquisition strategy is to pick points whose labels will maximimally reduce our uncertainty
about the model parameters w. This is known as the information gain criterion, and was first
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens1130
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
−2 0 2
X0
−2
0
2
4
X
1
Train Data
Pool Data
(a)
0 5 10 15 20 25 30 35 40
Number of Points queried
0.7
0.8
0.9
1.0
Accuracy
Uncertanity sampling
QBC sampling
Random samples
Mean of Random sampling
(b)
Figure 34.18: (a) Random forest (RF) classifier applied to a 2-dimensional, 3-class dataset. (b) Accuracy vs
number of query points for margin sampling vs random sampling. We represent uncertainty using either a
single RF (based on the predicted distribution over labels induced by the trees in the forest), or a committee
containing an RF and a logistic regression model. Generated by active_learning_compare_class.ipynb.
proposed in [Lin56]. It is defined as follows:
α(x) , H (p(w|D)) − Ep(y|x,D)
[H (p(w|D, x, y))] (34.95)
(Note that the first term is a constant wrt x, but we include it for later convenience.) This is
equivalent to the expected change in the posterior over the parameters which is given by
α
′
(x) , Ep(y|x,D)
[DKL (p(w|D, x, y) k p(w|D))] (34.96)
Using symmetry of the mutual information, we can rewrite Equation (34.95) as follows:
α(x) = H (w|D) − Ep(y|x,D)
[H (w|D, x, y)] (34.97)
= I(w, y|D, x) (34.98)
= H (y|x, D) − Ep(w|D)
[H (y|x, w, D)] (34.99)
The advantage of this approach is that we now only have to reason about the uncertainty of the
predictive distribution over outputs y, not over the parameters w. This approach is called Bayesian
active learning by disagreement or BALD [Hou+12].
Equation (34.99) has an interesting interpretation. The first term prefers examples x for which
there is uncertainty in the predicted label. Just using this as a selection criterion is equivalent to
uncertainty sampling, which we discussed above. However, this can have problems with examples
which are inherently ambiguous or mislabeled. By adding the second term, we penalize such behavior,
since we add a large negative weight to points whose predictive distribution is entropic even when
we know the parameters. Thus we ignore aleatoric (intrinsic) uncertainty and focus on epistemic
uncertainty.
34.7.4 Batch active learning
In many applications, we need to select a batch of unlabeled examples at once, since training a model
on single examples is too slow. This is called batch active learning. The key challenge is that we
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.7. ACTIVE LEARNING
need to ensure the different queries that we request are diverse, so we maximize the information gain.
Various methods for this problem have been devised; here we focus on the BatchBALD method of
[KAG19], which extends the BALD method of Section 34.7.3.3.
34.7.4.1 BatchBALD
The naive way to extend the BALD score to a batch of b candidate query points is to define
αBALD({x1, . . . , xB}, p(w|D)) = αBALD(x1:B, p(w|D)) = X
B
i=1
I(yi
; w|xi
, D) (34.100)
However this may pick points that are quite similar in terms of their information content. In
BatchBALD, we use joint conditional mutual information between the set of labels and the parameters:
αBBALD(x1:B, p(w|D)) = I(y1:B; w|x1:B, D) = H(y1:b|x1:B, D) − Ep(w|D)
[H(y1:B|x1:B, w, D)]
(34.101)
To understand how this differs from BALD, we will use information diagrams for representing MI
in terms of Venn diagrams, as explained in Section 5.3.2. In particular, [Yeu91a] showed that we
can define a signed measure, µ
∗
, for discrete random variables x and y such that I(x; y) = µ
∗
(x ∩ y),
H(x, y) = µ
∗
(x ∪ y), Ep(y)
[H(x|y)] = µ
∗
(x \ y), etc. Using this, we can interpret standard BALD as
the sum of the individual intersections, P
i µ
∗
(yi ∩ w), which double counts overlaps between the yi
,
as shown in Figure 34.19(a). By contrast, BatchBALD takes overlap into account by computing
I(y1:B; w|x1:B, D) = µ
∗
(∪iyi ∩ w) = µ
∗
(∪iyi) − µ
∗
(∪iyi \ w) (34.102)
This is illustrated in Figure 34.19(b). From this, we can see that αBBALD ≤ αBALD. Indeed, one can
show6
I(y1:B, w|x1:B, D) = X
B
i=1
I(yi
, w|x1:B, D) − TC(y1:B|x1:B, D) (34.103)
where TC is the total correlation (see Section 5.3.5.1).
34.7.4.2 Optimizing BatchBALD
To avoid the combinatorial explosion that arises from jointly scoring subsets of points, we can use a
a greedy approximation for computing BatchBALD one point at a time. In particular, suppose at
step n − 1 we already have a partial batch An−1. The next point is chosen using
xn = argmax
x∈Dpool\An−1
αBBALD(An−1 ∪ {x}, p(w|D)) (34.104)
We then add xn to An−1 to get An. Fortunately the BatchBALD acquisition function is submodular,
as shown in [KAG19]. Hence this greedy algorithm is within 1 − 1/e ≈ 0.63 of optimal (see
Section 6.9.4.1).
6. See http://blog.blackhc.net/2022/07/kbald/
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1132
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) BALD (b) BatchBALD
Figure 34.19: Intuition behind BALD and BatchBALD. Dpool is an unlabelled dataset (from which x1:b
are taken) , Dtrain is the current training set, w is set of model parameters, p(y|x,w, Dtrain) are output
predictions for datapoint x. BALD overestimates the joint mutual information whereas BatchBALD takes
the overlap between variables into account. Areas contributing to the respective score are shown in grey, and
areas that are double-counted in dark grey. From Figure 3 of [KAG19]. Used with kind permission of Andreas
Kirsch.
34.7.4.3 Computing BatchBALD
Computing the joint (conditional) mutual information is intractable, so in this section, we discuss
how to approximate it. For brevity we drop the conditioning on x and D. With this new notation,
the objective becomes
αBBALD(x1:B, p(w|D)) = H(y1, . . . , yB) − Ep(w)
[H(y1, . . . , yB|w)] (34.105)
Note that the yi are conditionally independent given w, so H(y1, . . . , yB|w) = PB
i=1 H(yi
|w). Hence
we can approximate the second term with Monte Carlo:
Ep(w)
[H(y1, . . . , yB|w)] ≈
1
S
Xn
i=1
X
s
H(yi
|wˆ s) (34.106)
where wˆ s ∼ p(w|D).
The first term, H(y1, . . . , yB), is a joint entropy, so is harder to compute. [KAG19] propose the
following approximation, summing over all possible label sequences in the batch, and leveraging the
fact that p(y) = Ep(w)
[p(y|w)]:
H(y1:B) = Ep(w)p(y1:B|vw)
[− log p(y1:B|w)] (34.107)
≈
X
yˆ1:B
 
1
S
X
S
s=1
p(yˆ1:B|wˆ s)
!
log 
1
S
X
S
s=1
p(yˆ1:B|wˆ s)
!
(34.108)
The sum over all possible labels sequences can be made more efficient by noting that p(y1:n|w) =
p(yn|w)p(y1:n−1|w), so when we implement the greedy algorithm, we can incrementally update the
probabilities, reusing previous computations. See [KAG19] for the details.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
34.7. ACTIVE LEARNING
0 5 10 15 20 25
0
5
10
15
20
25
Batch 1
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
Batch 2
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
Batch 3
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
(a)
0 5 10 15 20 25
0
5
10
15
20
25
Batch 1
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
Batch 2
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
Batch 3
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
0 5 10 15 20 25
0
5
10
15
20
25
(b)
0
16
32
48
64
80
96
No. of Points Queried
55 60 65 70 75 80 85 90
Test Accuracy
Random
BALD
BatchBALD
(c)
Figure 34.20: Three batches (each of size 4) queried from the MNIST pool by (a) BALD and (b) BatchBALD.
(c) Plot of accuracy vs number of points queried. BALD may select replicas of single informative datapoint
while BatchBALD selects diverse points, thus increasing data efficiency. Generated by batch_bald_mnist.ipynb.
34.7.4.4 Experimental comparison of BALD vs BatchBALD on MNIST
In this section, we show some experimental results applying BALD and BatchBALD to train a CNN
on the standard MNIST dataset. We use a batch size of 4, and approximate the posterior over
parameters p(w|D) using MC dropout (Section 17.3.1). In Figure 34.20(a), we see that BALD selects
examples that are very similar to each other, whereas in Figure 34.20(b), we see that BatchBALD
selects a greater diversity of points. In Figure 34.20(c), we see that BatchBALD results in more
efficient learning than BALD, which in turn is more efficient than randomly sampling data.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license35 Reinforcement learning
This chapter is co-authored with Lihong Li.
35.1 Introduction
Reinforcement learning or RL is a paradigm of learning where an agent sequentially interacts
with an initially unknown environment. The interaction typically results in a trajectory, or multiple
trajectories. Let τ = (s0, a0, r0, s1, a1, r1, s2, . . . , sT ) be a trajectory of length T, consisting of a
sequence of states st, actions at, and rewards rt.
1 The goal of the agent is to optimize her action￾selection policy, so that the discounted cumulative reward, G0 ,
PT −1
t=0 γ
t
rt, is maximized for some
given discount factor γ ∈ [0, 1].
In general, G0 is a random variable. We will focus on maximizing its expectation, inspired by the
maximum expected utility principle (Section 34.1.3), but note other possibilities such as conditional
value at risk2
that can be more appropriate in risk-sensitive applications.
We will focus on the Markov decision process, where the generative model for the trajectory τ can
be factored into single-step models. When these model parameters are known, solving for an optimal
policy is called planning (see Section 34.6); otherwise, RL algorithms may be used to obtain an
optimal policy from trajectories, a process called learning.
In model-free RL, we try to learn the policy without explicitly representing and learning the
models, but directly from the trajectories. In model-based RL, we first learn a model from the
trajectories, and then use a planning algorithm on the learned model to solve for the policy. See
Figure 35.1 for an overview. This chapter will introduce some of the key concepts and techniques,
and will mostly follow the notation from [SB18]. More details can be found in textbooks such as
[Sze10; SB18; Ber19; Aga+21a; Mey22; Aga+22], and reviews such as [WO12; Aru+17; FL+18;
Li18].
35.1.1 Overview of methods
In this section, we give a brief overview of how to compute optimal policies when the MDP model
is not known. Instead, the agent interacts with the environment and learns from the observed
1. Note that the time starts at 0 here, while it starts at 1 when we discuss bandits (Section 34.4). Our choices of
notation are to be consistent with conventions in respective literature.
2. The conditional value at risk, or CVaR, is the expected reward conditioned on being in the worst 5% (say) of
samples. See [Cho+15] for an example application in RL.1136
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Model-based RL
Markov Decision Process
Actor
Critic
Deep
MPC
Policy Iteration
Value Iteration
REINFORCEMENT LEARNING
Nonlinear Dynamics
Optimal Control & HJB
Model-free RL
Q Learning
DQN
Off Policy
Gradient Free
On Policy
SARSA
TD(0)
...
TD(?) ? MC
TD - ?
Deep
Policy
Network
Gradient Based
Policy Gradient Optimization
Deep RL
Dynamic programming
& Bellman optimality
Figure 35.1: Overview of RL methods. Abbreviations: DQN = Deep Q network (Section 35.2.6); MPC =
Model Predictive Control (Section 35.4); HJB = Hamilton-Jacobi-Bellman equation; TD = temporal difference
learning (Section 35.2.2). Adapted from a slide by Steve Brunton.
Method Functions learned On/Off Section
SARSA Q(s, a) On Section 35.2.4
Q-learning Q(s, a) Off Section 35.2.5
REINFORCE π(a|s) On Section 35.3.2
A2C π(a|s), V (s) On Section 35.3.3.1
TRPO/PPO π(a|s), A(s, a) On Section 35.3.4
DDPG a = π(s), Q(s, a) Off Section 35.3.5
Soft actor-critic π(a|s), Q(s, a) Off Section 35.6.1
Model-based RL p(s
′
|s, a) Off Section 35.4
Table 35.1: Summary of some popular methods for RL. On/off refers to on-policy vs off-policy methods.
trajectories. This is the core focus of RL. We will go into more details into later sections, but first
provide this roadmap.
We may categorize RL methods by the quantity the agent represents and learns: value function,
policy, and model; or by how actions are selected: on-policy (actions must be selected by the agent’s
current policy), and off-policy. Table 35.1 lists a few representative examples. More details are given
in the subsequent sections. We will also discuss at greater depth two important topics of off-policy
learning and inference-based control in Sections 35.5 and 35.6.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.1. INTRODUCTION
35.1.2 Value-based methods
In a value-based method, we often try to learn the optimal Q-function from experience, and then
derive a policy from it using Equation (34.84). Typically, a function approximator (e.g., a neural
network), Qw, is used to represent the Q-function, which is trained iteratively. Given a transition
(s, a, r, s′
), we define the temporal difference (also called the TD error) as
r + γ max
a′
Qw(s
′
, a′
) − Qw(s, a)
Clearly, the expected TD error is the Bellman error evaluated at (s, a). Therefore, if Qw = Q∗, the
TD error is 0 on average by Bellman’s optimality equation. Otherwise, the error provides a signal for
the agent to change w to make Qw(s, a) closer to R(s, a) + γ maxa′ Qw(s
′
, a′
). The update on Qw is
based on a target that is computed using Qw. This kind of update is known as bootstrapping in
RL, and should not be confused with the statistical bootstrap (Section 3.3.2). Value based methods
such as Q-learning and SARSA are discussed in Section 35.2.
35.1.3 Policy search methods
In policy search, we try to directly maximize J(πθ) wrt the policy parameter θ. If J(πθ) is
differentiable wrt θ, we can use stochastic gradient ascent to optimize θ, which is known as policy
gradient, as described in Section 35.3.1. The basic idea is to perform Monte Carlo rollouts, in
which we sample trajectories by interacting with the environment, and then use the score function
estimator (Section 6.3.4) to estimate ∇θJ(πθ). Here, J(πθ) is defined as an expectation whose
distribution depends on θ, so it is invalid to swap ∇ and E in computing the gradient, and the score
function estimator can be used instead. An example of policy gradient is REINFORCE.
Policy gradient methods have the advantage that they provably converge to a local optimum
for many common policy classes, whereas Q-learning may diverge when approximation is used
(Section 35.5.3). In addition, policy gradient methods can easily be applied to continuous action
spaces, since they do not need to compute argmaxa Q(s, a). Unfortunately, the score function
estimator for ∇θJ(πθ) can have a very high variance, so the resulting method can converge slowly.
One way to reduce the variance is to learn an approximate value function, Vw(s). and to use it
as a baseline in the score function estimator. We can learn Vw(s) using one of the value function
methods similar to Q-learning. Alternatively, we can learn an advantage function, Aw(s, a), and use
it to estimate the gradient. These policy gradient variants are called actor critic methods, where
the actor refers to the policy πθ and the critic refers to Vw or Aw. See Section 35.3.3 for details.
35.1.4 Model-based RL
Value-based methods, such as Q-learning, and policy search methods, such as policy gradient, can be
very sample inefficient, which means they may need to interact with the environment many times
before finding a good policy. If an agent has prior knowledge of the MDP model, it can be more
sample efficient to first learn the model, and then compute an optimal (or near-optimal) policy of
the model without having to interact with the environment any more.
This approach is called model-based RL. The first step is to learn the MDP model including
the pT (s
′
|s, a) and R(s, a) functions, e.g., using DNNs. Given a collection of (s, a, r, s′
) tuples, such
a model can be learned using standard supervised learning methods. The second step can be done
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1138
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
by running an RL algorithm on synthetic experiences generated from the model, or by running a
planning algorithm on the model directly (Section 34.6). In practice, we often interleave the model
learning and planning phases, so we can use the partially learned policy to decide what data to
collect. We discuss model-based RL in more detail in Section 35.4.
35.1.5 Exploration-exploitation tradeoff
A fundamental problem in RL with unknown transition and reward models is to decide between
choosing actions that the agent knows will yield high reward, or choosing actions whose reward
is uncertain, but which may yield information that helps the agent get to parts of state-action
space with even higher reward. This is called the exploration-exploitation tradeoff, which has
been discussed in the simpler contextual bandit setting in Section 34.4. The literature on efficient
exploration is huge. In this section, we briefly describe several representative techniques.
35.1.5.1 ǫ-greedy
A common heuristic is to use an ǫ-greedy policy πǫ, parameterized by ǫ ∈ [0, 1]. In this case, we pick
the greedy action wrt the current model, at = argmaxa Rˆ
t(st, a) with probability 1−ǫ, and a random
action with probability ǫ. This rule ensures the agent’s continual exploration of all state-action
combinations. Unfortunately, this heuristic can be shown to be suboptimal, since it explores every
action with at least a constant probability ǫ/|A|.
35.1.5.2 Boltzmann exploration
A source of inefficiency in the ǫ-greedy rule is that exploration occurs uniformly over all actions.
The Boltzmann policy can be more efficient, by assigning higher probabilities to explore more
promising actions:
πτ (a|s) = exp(Rˆ
t(st, a)/τ )
P
a′ exp(Rˆ
t(st, a′)/τ )
(35.1)
where τ > 0 is a temperature parameter that controls how entropic the distribution is. As τ gets
close to 0, πτ becomes close to a greedy policy. On the other hand, higher values of τ will make
π(a|s) more uniform, and encourage more exploration. Its action selection probabilities can be much
“smoother” with respect to changes in the reward estimates than ǫ-greedy, as illustrated in Table 35.2.
35.1.5.3 Upper confidence bounds and Thompson sampling
The upper confidence bound (UCB) (Section 34.4.5) and Thompson sampling (Section 34.4.6)
approaches may also be extended to MDPs. In contrast to the contextual bandit case, where the
only uncertainty is in the reward function, here we must also take into account uncertainty in the
transition probabilities.
As in the bandit case, the UCB approach requires to estimate an upper confidence bound for all
actions’ Q-values in the current state, and then take the action with the highest UCB score. One way
to obtain UCBs of the Q-values is to use count-based exploration, where we learn the optimal
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.1. INTRODUCTION
Rˆ(s, a1) Rˆ(s, a2) πǫ(a|s1) πǫ(a|s2) πτ (a|s1) πτ (a|s2)
1.00 9.00 0.05 0.95 0.00 1.00
4.00 6.00 0.05 0.95 0.12 0.88
4.90 5.10 0.05 0.95 0.45 0.55
5.05 4.95 0.95 0.05 0.53 0.48
7.00 3.00 0.95 0.05 0.98 0.02
8.00 2.00 0.95 0.05 1.00 0.00
Table 35.2: Comparison of ǫ-greedy policy (with ǫ = 0.1) and Boltzmann policy (with τ = 1) for a simple
MDP with 6 states and 2 actions. Adapted from Table 4.1 of [GK19].
Q-function with an exploration bonus added to the reward in a transition (s, a, r, s′
):
r˜ = r + α/p
Ns,a (35.2)
where Ns,a is the number of times action a has been taken in state s, and α ≥ 0 is a weighting term
that controls the degree of exploration. This is the approach taken by the MBIE-EB method [SL08]
for finite-state MDPs, and in the generalization to continuous-state MDPs through the use of hash￾ing [Bel+16]. Other approaches also explicitly maintain uncertainty in state transition probabilities,
and use that information to obtain UCBs. Examples are MBIE [SL08], UCRL2 [JOA10], and
UCBVI [AOM17], among many others.
Thompson sampling can be similarly adapted, by maintaining the posterior distribution of the
reward and transition model parameters. In finite-state MDPs, for example, the transition model is a
categorical distribution conditioned on the state. We may use the conjugate prior of Dirichlet
distributions (Section 3.4) for the transition model, so that the posterior distribution can be
conveniently computed and sampled from. More details on this approach are found in [Rus+18].
Both UCB and Thompson sampling methods have been shown to yield efficient exploration with
provably strong regret bounds (Section 34.4.7) [JOA10], or related PAC bounds [SLL09; DLB17],
often under necessary assumptions such as finiteness of the MDPs. In practice, these methods may
be combined with function approximation like neural networks and implemented approximately.
35.1.5.4 Optimal solution using Bayes-adaptive MDPs
The Bayes optimal solution to the exploration-exploitation tradeoff can be computed by formulating
the problem as a special kind of POMDP known as a Bayes-adaptive MDP or BAMDP [Duf02].
This extends the Gittins index approach in Section 34.4.4 to the MDP setting.
In particular, a BAMDP has a belief state space, B, representing uncertainty about the reward
model pR(r|s, a, s′
) and transition model pT (s
′
|s, a). The transition model on this augmented MDP
can be written as follows:
T
+(st+1, bt+1|st, bt, at, rt) = T
+(st+1|st, at, bt)T
+(bt+1|st, at, rt, st+1) (35.3)
= Ebt
[T(st+1|st, at)] × I(bt+1 = p(R, T|ht+1)) (35.4)
where Ebt
[T(st+1|st, at)] is the posterior predictive distribution over next states, and p(R, T|ht+1) is
the new belief state given ht+1 = (s1:t+1, a1:t+1, r1:t+1), which can be computed using Bayes’ rule.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1140
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Similarly, the reward function for the augmented MDP is given by
R
+(r|st, bt, at, st+1, bt+1) = Ebt+1 [R(st, at, st+1)] (35.5)
For small problems, we can solve the resulting augmented MDP optimally. However, in general
this is computationally intractable. [Gha+15] surveys many methods to solve it more efficiently.
For example, [KN09] develop an algorithm that behaves similarly to Bayes optimal policies, except
in a provably small number of steps; [GSD13] propose an approximate method based on Monte
Carlo rollouts. More recently, [Zin+20] propose an approximate method based on meta-learning
(Section 19.6.4), in which they train a (model-free) policy for multiple related tasks. Each task is
represented by a task embedding vector m, which is inferred from ht using a VAE (Section 21.2).
The posterior p(m|ht) is used as a proxy for the belief state bt, and the policy is trained to perform
well given st and bt. At test time, the policy is applied to the incrementally computed belief state;
this allows the method to infer what kind of task this is, and then to use a pre-trained policy to
quickly solve it.
35.2 Value-based RL
In this section, we assume the agent has access to samples from pT and pR by interacting with the
environment. We will show how to use these samples to learn optimal Q-functions from which we
can derive optimal policies.
35.2.1 Monte Carlo RL
Recall that Qπ(s, a) = E [Gt|st = s, at = a] for any t. A simple way to estimate this is to take action
a, and then sample the rest of the trajectory according to π, and then compute the average sum of
discounted rewards. The trajectory ends when we reach a terminal state, if the task is episodic, or
when the discount factor γ
t becomes negligibly small, whichever occurs first. This is the Monte
Carlo estimation of the value function.
We can use this technique together with policy iteration (Section 34.6.2) to learn an optimal policy.
Specifically, at iteration k, we compute a new, improved policy using πk+1(s) = argmaxa Qk(s, a),
where Qk is approximated using MC estimation. This update can be applied to all the states visited
on the sampled trajectory. This overall technique is called Monte Carlo control.
To ensure this method converges to the optimal policy, we need to collect data for every (state,
action) pair, at least in the tabular case, since there is no generalization across different values of
Q(s, a). One way to achieve this is to use an ǫ-greedy policy. Since this is an on-policy algorithm,
the resulting method will converge to the optimal ǫ-soft policy, as opposed to the optimal policy. It
is possible to use importance sampling to estimate the value function for the optimal policy, even if
actions are chosen according to the ǫ-greedy policy. However, it is simpler to just gradually reduce ǫ.
35.2.2 Temporal difference (TD) learning
The Monte Carlo (MC) method in Section 35.2.1 results in an estimator for Qπ(s, a) with very high
variance, since it has to unroll many trajectories, whose returns are a sum of many random rewards
generated by stochastic state transitions. In addition, it is limited to episodic tasks (or finite horizon
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.2. VALUE-BASED RL
Figure 35.2: Backup diagrams of V (st) for Monte Carlo, temporal difference, and dynamic programming
updates of the state-value function. Used with kind permission of Andy Barto.
truncation of continuing tasks), since it must unroll to the end of the episode before each update
step, to ensure it reliably estimates the long term return.
In this section, we discuss a more efficient technique called temporal difference or TD learning
[Sut88]. The basic idea is to incrementally reduce the Bellman error for sampled states or state-actions,
based on transitions instead of a long trajectory. More precisely, suppose we are to learn the value
function Vπ for a fixed policy π. Given a state transition (s, a, r, s′
) where a ∼ π(s), we change the
estimate V (s) so that it moves towards the bootstrapping target (Section 35.1.2)
V (st) ← V (st) + η [rt + γV (st+1) − V (st)] (35.6)
where η is the learning rate. The term multiplied by η above is known as the TD error. A more
general form of TD update for parametric value function representations is
w ← w + η [rt + γVw(st+1) − Vw(st)] ∇wVw(st) (35.7)
of which Equation (35.6) is a special case. The TD update rule for learning Qπ is similar.
It can be shown that TD learning in the tabular case, Equation (35.6), converges to the correct
value function, under proper conditions [Ber19]. However, it may diverge when approximation is
used (Equation (35.7)), an issue we will discuss further in Section 35.5.3.
The potential divergence of TD is also consistent with the fact that Equation (35.7) is not SGD
(Section 6.3.1) on any objective function, despite a very similar form. Instead, it is an example of
bootstrapping, in which the estimate, Vw(st), is updated to approach a target, rt + γVw(st+1),
which is defined by the value function estimate itself. This idea is shared by DP methods like value
iteration, although they rely on the complete MDP model to compute an exact Bellman backup. In
contrast, TD learning can be viewed as using sampled transitions to approximate such backups. An
example of non-bootstrapping approach is the Monte Carlo estimation in the previous section. It
samples a complete trajectory, rather than individual transitions, to perform an update, and is often
much less efficient. Figure 35.2 illustrates the difference between MC, TD, and DP.
35.2.3 TD learning with eligibility traces
A key difference between TD and MC is the way they estimate returns. Given a trajectory τ =
(s0, a0, r0, s1, . . . , sT ), TD estimates the return from state st by one-step lookahead, Gt:t+1 = rt +
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1142
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 35.3: The backup diagram for TD(λ). Standard TD learning corresponds to λ = 0, and standard MC
learning corresponds to λ = 1. From Figure 12.1 of [SB18]. Used with kind permission of Richard Sutton.
γV (st+1), where the return from time t + 1 is replaced by its value function estimate. In contrast,
MC waits until the end of the episode or until T is large enough, then uses the estimate Gt:T =
rt + γrt+1 + · · · + γ
T −t−1
rT −1. It is possible to interpolate between these by performing an n-step
rollout, and then using the value function to approximate the return for the rest of the trajectory,
similar to heuristic search (Section 35.4.1.1). That is, we can use the n-step estimate
Gt:t+n = rt + γrt+1 + · · · + γ
n−1
rt+n−1 + γ
nV (st+n) (35.8)
The corresponding n-step version of the TD update becomes
V (st) ← V (st) + η [Gt:t+n − V (st)] (35.9)
Rather than picking a specific lookahead value, n, we can take a weighted average of all possible
values, with a single parameter λ ∈ [0, 1], by using
G
λ
t , (1 − λ)
X∞
n=1
λ
n−1Gt:t+n (35.10)
This is called the λ-return. The coefficient of 1 − λ = (1 + λ + λ
2 + · · ·)
−1
in the front ensures this
is a convex combination of n-step returns. See Figure 35.3 for an illustration.
An important benefit of using the geometric weighting in Equation (35.10) is that the corresponding
TD learning update can be efficiently implemented, through the use of eligibility traces, even
though Gλ
t
is a sum of infinitely many terms. The method is called TD(λ), and can be combined
with many algorithms to be studied in the rest of the chapter. See [SB18] for a detailed discussion.
35.2.4 SARSA: on-policy TD control
TD learning is for policy evaluation, as it estimates the value function for a fixed policy. In order
to find an optimal policy, we may use the algorithm as a building block inside generalized policy
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.2. VALUE-BASED RL
iteration (Section 34.6.2). In this case, it is more convenient to work with the action-value function,
Q, and a policy π that is greedy with respect to Q. The agent follows π in every step to choose
actions, and upon a transition (s, a, r, s′
) the TD update rule is
Q(s, a) ← Q(s, a) + η [r + γQ(s
′
, a′
) − Q(s, a)] (35.11)
where a
′ ∼ π(s
′
) is the action the agent will take in state s
′
. After Q is updated (for policy evaluation),
π also changes accordingly as it is greedy with respect to Q (for policy improvement). This algorithm,
first proposed by [RN94], was further studied and renamed to SARSA by [Sut96]; the name comes
from its update rule that involves an augmented transition (s, a, r, s′
, a′
).
In order for SARSA to converge to Q∗, every state-action pair must be visited infinitely often, at
least in the tabular case, since the algorithm only updates Q(s, a) for (s, a) that it visits. One way
to ensure this condition is to use a “greedy in the limit with infinite exploration” (GLIE) policy. An
example is the ǫ-greedy policy, with ǫ vanishing to 0 gradually. It can be shown that SARSA with a
GLIE policy will converge to Q∗ and π∗ [Sin+00].
35.2.5 Q-learning: off-policy TD control
SARSA is an on-policy algorithm, which means it learns the Q-function for the policy it is currently
using, which is typically not the optimal policy (except in the limit for a GLIE policy). However,
with a simple modification, we can convert this to an off-policy algorithm that learns Q∗, even if a
suboptimal policy is used to choose actions.
The idea is to replace the sampled next action a
′ ∼ π(s
′
) in Equation (35.11) with a greedy action
in s
′
: a
′ = argmaxb Q(s
′
, b). This results in the following update when a transition (s, a, r, s′
) happens
Q(s, a) ← Q(s, a) + η

r + γ max
b
Q(s
′
, b) − Q(s, a)

(35.12)
This is the update rule of Q-learning for the tabular case [WD92]. The extension to work with
function approximation can be done in a way similar to Equation (35.7). Since it is off-policy, the
method can use (s, a, r, s′
) triples coming from any data source, such as older versions of the policy,
or log data from an existing (non-RL) system. If every state-action pair is visited infinitely often, the
algorithm provably converges to Q∗ in the tabular case, with properly decayed learning rates [Ber19].
Algorithm 35.1 gives a vanilla implementation of Q-learning with ǫ-greedy exploration.
35.2.5.1 Example
Figure 35.4 gives an example of Q-learning applied to the simple 1d grid world from Figure 34.13,
using γ = 0.9. We show the Q-functon at the start and end of each episode, after performing actions
chosen by an ǫ-greedy policy. We initialize Q(s, a) = 0 for all entries, and use a step size of η = 1, so
the update becomes Q∗(s, a) = r + γQ∗(s
′
, a∗), where a∗ =↓ for all states.
35.2.5.2 Double Q-learning
Standard Q-learning suffers from a problem known as the optimizer’s curse [SW06], or the maxi￾mization bias. The problem refers to the simple statistical inequality, E [maxa Xa] ≥ maxa E [Xa],
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1144
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Algorithm 35.1: Q-learning with ǫ-greedy exploration
1 Initialize value function parameters w
2 repeat
3 Sample starting state s of new episode
4 repeat
5 Sample action a =
(
argmaxb Qw(s, b), with probability 1 − ǫ
random action, with probability ǫ
6 Observe state s
′
, reward r
7 Compute the TD error: δ = r + γ maxa′ Qw(s
′
, a′
) − Qw(s, a)
8 w ← w + ηδ∇wQw(s, a)
9 s ← s
′
10 until state s is terminal
11 until converged
for a set of random variables {Xa}. Thus, if we pick actions greedily according to their random
scores {Xa}, we might pick a wrong action just because random noise makes it appealing.
Figure 35.5 gives a simple example of how this can happen in an MDP. The start state is A.
The right action gives a reward 0 and terminates the episode. The left action also gives a reward
of 0, but then enters state B, from which there are many possible actions, with rewards drawn
from N (−0.1, 1.0). Thus the expected return for any trajectory starting with the left action is
−0.1, making it suboptimal. Nevertheless, the RL algorithm may pick the left action due to the
maximization bias making B appear to have a positive value.
One solution to avoid the maximization bias is to use two separate Q-functions, Q1 and Q2, one
for selecting the greedy action, and the other for estimating the corresponding Q-value. In particular,
upon seeing a transition (s, a, r, s′
), we perform the following update
Q1(s, a) ← Q1(s, a) + η

r + γQ2
￾
s
′
, argmax
a′
Q1(s
′
, a′
)

− Q1(s, a)

(35.13)
and may repeat the same update but with the roles of Q1 and Q2 swapped. This technique is
called double Q-learning [Has10]. Figure 35.5 shows the benefits of the algorithm over standard
Q-learning in a toy problem.
35.2.6 Deep Q-network (DQN)
When function approximation is used, Q-learning may be hard to use in practice due to instability
problems. Here, we will describe two important heuristics, popularized by the deep Q-network or
DQN work [Mni+15], which was able to train agents to outperform humans at playing Atari games,
using CNN-structured Q-networks.
The first technique, originally proposed in [Lin92], is to leverage an experience replace buffer,
which stores the most recent (s, a, r, s′
) transition tuples. In contrast to standard Q-learning which
updates the Q-function when a new transition occurs, the DQN agent also performs additional
updates using transitions sampled from the buffer. This modification has two advantages. First, it
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.2. VALUE-BASED RL
Q-function 
episode start Episode Time Step Action (s,α,r , s') r + γ Q*(s' , α)
UP DOWN
1 1 (S1 , D,0,S2) 0 + 0.9 X 0 = 0
1 2 (S2 ,U,0,S1) 0 + 0.9 X 0 = 0
1 3 (S1 , D,0,S2) 0 + 0.9 X 0 = 0
1 4 (S2 , U,0,S1) 0 + 0.9 X 0 = 0
1 5 (S3 , D,1,ST2) 1
2 1 (S1 , D,0,S2) 0 + 0.9 x 0 = 0
2 2 (S2 , D,0,S3) 0 + 0.9 x 1 = 0.9
2 3 (S3 , D,0,ST2) 1
3 1 (S1 , D,0,S2) 0 + 0.9 x 0.9 = 0.81
3 2 (S2 , D,0,S3) 0 + 0.9 x 1 = 0.9
3 3 (S3 , D,0,S2) 0 + 0.9 x 0.9 = 0.81
3 4 (S2 , D,0,S3) 0 + 0.9 x 1 = 0.9
3 5 (S3 , D,0,ST2) 1
4 1 (S1 , D,0,S2) 0 + 0.9 x 0.9 = 0.81
4 2 (S2 , U,0,S1) 0 + 0.9 x 0.81 = 0.73
4 3 (S1 , D,0,S2) 0 + 0.9 x 0.9 = 0.81
4 4 (S2 , U,0,S3) 0 + 0.9 x 0.81 = 0.73
4 5 (S1 , D,0,S3) 0 + 0.9 x 0.9 = 0.81
4 6 (S2 , D,0,S3) 0 + 0.9 x 1 = 0.9
4 7 (S2 , D,0,S3) 1
5 1 (S1 , U, 0,ST1) 0
0 0
0 0
0 1
0 0
0 0
0 0
0 0
0 0
0 1
0 0
0 0.9
0 1
0 0.81
0 0.9
0.81 1
0 0
0 0.9
0 1
0 0.81
0 0.9
0.81 1
0 0.81
0.73 0.9
0.81 1
0 0.81
0.73 0.9
0.81 1
0 0.81
0.73 0.9
0.81 1
S1
S2
S3
S1
S2
S3
S1
S2
S3
S1
S2
S3
S1
S2
S3
S1
S2
S3
S1
S2
S3
S1
S2
S3
S1
S2
S3
S1
S2
S3
Q-function 
episode end
UP DOWN
Q1
Q2
Q3
Q4
Q5
Figure 35.4: Illustration of Q learning for the 1d grid world in Figure 34.13 using ǫ-greedy exploration. At the
end of episode 1, we make a transition from S3 to ST 2 and get a reward of r = 1, so we estimate Q(S3, ↓) = 1.
In episode 2, we make a transition from S2 to S3, so S2 gets incremented by γQ(S3, ↓) = 0.9. Adapted from
Figure 3.3 of [GK19].
improves data efficiency as every transition can be used multiple times. Second, it improves stability
in training, by reducing the correlation of the data samples that the network is trained on.
The second idea to improve stability is to regress the Q-network to a “frozen” target network
computed at an earlier iteration, rather than trying to chase a constantly moving target. Specifically,
we maintain an extra, frozen copy of the Q-network, Qw− , of the same structure as Qw. This new
Q-network is to compute bootstrapping targets for training Qw, in which the loss function is
L
DQN(w) = E(s,a,r,s′)∼U(D)
h￾
r + γ max
a′
Qw− (s
′
, a′
) − Qw(s, a)
2
i
(35.14)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens1146
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 35.5: Comparison of Q-learning and double Q-learning on a simple episodic MDP using ǫ-greedy action
selection with ǫ = 0.1. The initial state is A, and squares denote absorbing states. The data are averaged
over 10,000 runs. From Figure 6.5 of [SB18]. Used with kind permission of Richard Sutton.
where U(D) is a uniform distribution over the replay buffer D. We then periodically set w− ← w,
usually after a few episodes. This approach is an instance of fitted value iteration [SB18].
Various improvements to DQN have been proposed. One is double DQN [HGS16], which uses
the double learning technique (Section 35.2.5.2) to remove the maximization bias. The second is to
replace the uniform distribution in Equation (35.14) with one that favors more important transition
tuples, resulting in the use of prioritized experience replay [Sch+16a]. For example, we can
sample transitions from D with probability p(s, a, r, s′
) ∝ (|δ| + ε)
η
, where δ is the corresponding
TD error (under the current Q-function), ε > 0 a hyperparameter to ensure every experience is
chosen with nonzero probability, and η ≥ 0 controls the “inverse temperature” of the distribution
(so η = 0 corresponds to uniform sampling). The third is to learn a value function Vw and an
advantage function Aw, with shared parameter w, instead of learning Qw. The resulting dueling
DQN [Wan+16] is shown to be more sample efficient, especially when there are many actions with
similar Q-values.
The rainbow method [Hes+18] combines all three improvements, as well as others, including
multi-step returns (Section 35.2.3), distributional RL [BDM17] (which predicts the distribution
of returns, not just the expected return), and noisy nets [For+18b] (which adds random noise to
the network weights to encourage exploration). It produces state-of-the-art results on the Atari
benchmark.
35.3 Policy-based RL
In the previous section, we considered methods that estimate the action-value function, Q(s, a), from
which we derive a policy, which may be greedy or softmax. However, these methods have three main
disadvantages: (1) they can be difficult to apply to continuous action spaces; (2) they may diverge if
function approximation is used; and (3) the training of Q, often based on TD-style updates, is not
directly related to the expected return garnered by the learned policy.
In this section, we discuss policy search methods, which directly optimize the parameters of the
policy so as to maximize its expected return. However, we will see that these methods often benefit
from estimating a value or advantage function to reduce the variance in the policy search process.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.3. POLICY-BASED RL
35.3.1 The policy gradient theorem
We start by defining the objective function for policy learning, and then derive its gradient. We
consider the episodic case. A similar result can be derived for the continuing case with the average
reward criterion [SB18, Sec 13.6].
We define the objective to be the expected return of a policy, which we aim to maximize:
J(π) , Ep0,π [G0] = Ep0(s0)
[Vπ(s0)] = Ep0(s0)π(a0|s0)
[Qπ(s0, a0)] (35.15)
We consider policies πθ parameterized by θ, and compute the gradient of Equation (35.15) wrt θ:
∇θJ(πθ) = Ep0(s0)
"
∇θ
 X
a0
πθ(a0|s0)Qπθ
(s0, a0)
!# (35.16)
= Ep0(s0)
"X
a0
∇πθ(a0|s0)Qπθ
(s0, a0)
#
+ Ep0(s0)πθ(a0|s0)
[∇θQπθ
(s0, a0)] (35.17)
Now we calculate the term ∇θQπθ
(s0, a0):
∇θQπθ
(s0, a0) = ∇θ

R(s0, a0) + γEpT (s1|s0,a0)
[Vπθ
(s1)]
= γ∇θEpT (s1|s0,a0)
[Vπθ
(s1)] (35.18)
The right-hand side above is in a form similar to ∇θJ(πθ). Repeating the same steps as before gives
∇θJ(πθ) = X∞
t=0
γ
tEpt(s)
"X
a
∇θπθ(a|s)Qπθ
(s, a)
#
(35.19)
=
1
1 − γ
Ep∞πθ
(s)
"X
a
∇θπθ(a|s)Qπθ
(s, a)
#
(35.20)
=
1
1 − γ
Ep∞πθ
(s)πθ(a|s)
[∇θ log πθ(a|s) Qπθ
(s, a)] (35.21)
where pt(s) is the probability of visiting s in time t if we start with s0 ∼ p0 and follow πθ, and p∞
πθ
(s) =
(1 − γ)
P∞
t=0 γ
tpt(s) is the normalized discounted state visitation distribution. Equation (35.21) is
known as the policy gradient theorem [Sut+99].
In practice, estimating the policy gradient using Equation (35.21) can have a high variance. A
baseline b(s) can be used for variance reduction (Section 6.3.4.1):
∇θJ(πθ) = 1
1 − γ
Ep∞πθ
(s)πθ(a|s)
[∇θ log πθ(a|s)(Qπθ
(s, a) − b(s))] (35.22)
A common choice for the baseline is b(s) = Vπθ
(s). We will discuss how to estimate it below.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1148
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.3.2 REINFORCE
One way to apply the policy gradient theorem to optimize a policy is to use stochastic gradient
ascent. Suppose τ = (s0, a0, r0, s1, . . . , sT ) is a trajectory with s0 ∼ p0 and πθ. Then,
∇θJ(πθ) = 1
1 − γ
Ep∞πθ
(s)πθ(a|s)
[∇θ log πθ(a|s)Qπθ
(s, a)] (35.23)
≈
T
X−1
t=0
γ
tGt∇θ log πθ(at|st) (35.24)
where the return Gt is defined in Equation (34.76), and the factor γ
t
is due to the definition of p∞
πθ
where the state at time t is discounted.
We can use a baseline in the gradient estimate to get the following update rule:
θ ← θ + η
T
X−1
t=0
γ
t
(Gt − b(st))∇θ log πθ(at|st) (35.25)
This is called the REINFORCE algorithm [Wil92].3 The udpate equation can be interepreted as
follows: we compute the sum of discounted future rewards induced by a trajectory, compared to a
baseline, and if this is positive, we increase θ so as to make this trajectory more likely, otherwise we
decrease θ. Thus, we reinforce good behaviors, and reduce the chances of generating bad ones.
We can use a constant (state-independent) baseline, or we can use a state-dependent baseline,
b(st) to further lower the variance. A natural choice is to use an estimated value function, Vw(s),
which can be learned, e.g., with MC. Algorithm 35.2 gives the pseudocode where stochastic gradient
updates are used with separate learning rates.
Algorithm 35.2: REINFORCE with value function baseline
1 Initialize policy parameters θ, baseline parameters w
2 repeat
3 Sample an episode τ = (s0, a0, r0, s1, . . . , sT ) using πθ
4 Compute Gt for all t ∈ {0, 1, . . . , T − 1} using Equation (34.76)
5 for t = 0, 1, . . . , T − 1 do
6 δ = Gt − Vw(st) // scalar error
7 w ← w + ηwδ∇wVw(st)
8 θ ← θ + ηθγ
t
δ∇θ log πθ(at|st)
9 until converged
35.3.3 Actor-critic methods
An actor-critic method [BSA83] uses the policy gradient method, but where the expected return is
estimated using temporal difference learning of a value function instead of MC rollouts. The term
3. The term “REINFORCE” is an acronym for “REward Increment = nonnegative Factor x Offset Reinforcement x
Characteristic Eligibility”. The phrase “characteristic eligibility” refers to the ∇ log πθ(at|st) term; the phrase “offset
reinforcement” refers to the Gt − b(st) term; and the phrase “nonnegative factor” refers to the learning rate η of SGD.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.3. POLICY-BASED RL
“actor” refers to the policy, and the term “critic” refers to the value function. The use of bootstrapping
in TD updates allows more efficient learning of the value function compared to MC. In addition, it
allows us to develop a fully online, incremental algorithm, that does not need to wait until the end of
the trajectory before updating the parameters (as in Algorithm 35.2).
Concretely, consider the use of the one-step TD(0) method to estimate the return in the episodic
csae, i.e., we replace Gt with Gt:t+1 = rt+γVw(st+1). If we use Vw(st) as a baseline, the REINFORCE
update in Equation (35.25) becomes
θ ← θ + η
T
X−1
t=0
γ
t
(Gt:t+1 − Vw(st)) ∇θ log πθ(at|st) (35.26)
= θ + η
T
X−1
t=0
γ
t
￾
rt + γVw(st+1) − Vw(st)

∇θ log πθ(at|st) (35.27)
35.3.3.1 A2C and A3C
Note that rt+1 + γVw(st+1) − Vw(st) is a single sample approximation to the advantage function
A(st, at) = Q(st, at) − V (st). This method is therefore called advantage actor critic or A2C
(Algorithm 35.3). If we run the actors in parallel and asynchronously update their shared parameters,
the method is called asynchrononous advantage actor critic or A3C [Mni+16].
Algorithm 35.3: Advantage actor critic (A2C) algorithm
1 Initialize actor parameters θ, critic parameters w
2 repeat
3 Sample starting state s0 of a new episode
4 for t = 0, 1, 2, . . . do
5 Sample action at ∼ πθ(·|st)
6 Observe next state st+1 and reward rt
7 δ = rt + γVw(st+1) − Vw(st)
8 w ← w + ηwδ∇wVw(st)
9 θ ← θ + ηθγ
t
δ∇θ log πθ(at|st)
10 until converged
35.3.3.2 Eligibility traces
In A2C, we use a single step rollout, and then use the value function in order to approximate the
expected return for the trajectory. More generally, we can use the n-step estimate
Gt:t+n = rt + γrt+1 + γ
2
rt+2 + · · · + γ
n−1
rt+n−1 + γ
nVw(st+n) (35.28)
and obtain an n-step advantage estimate as follows:
A
(n)
πθ
(st, at) = Gt:t+n − Vw(st) (35.29)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens1150
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The n steps of actual rewards are an unbiased sample, but have high variance. By contrast,
Vw(st+n+1) has lower variance, but is biased. By changing n, we can control the bias-variance
tradeoff. Instead of using a single value of n, we can take an weighted average, with weight
proportional to λ
n for A
(n)
πθ
(st, at), as in TD(λ). The average can be shown to be equivalent to
A
(λ)
πθ
(st, at) ,
X∞
ℓ=0
(γλ)
ℓ
δt+l (35.30)
where δt = rt + γVw(st+1) − Vw(st) is the TD error at time t. Here, λ ∈ [0, 1] is a parameter
that controls the bias-variance tradeoff: larger values decrease the bias but increase the variance,
as in TD(λ). We can implement Equation (35.30) efficiently using eligibility traces, as shown in
Algorithm 35.4, as an example of generalized advantage estimation (GAE) [Sch+16b]. See
[SB18, Ch.12] for further details.
Algorithm 35.4: Actor critic with eligibility traces
1 Initialize actor parameters θ, critic parameters w
2 repeat
3 Initialize eligibility trace vectors: zθ ← 0, zw ← 0
4 Sample starting state s0 of a new episode
5 for t = 0, 1, 2, . . . do
6 Sample action at ∼ πθ(·|st)
7 Observe state st+1 and reward rt
8 Compute the TD error: δ = rt + γVw(st+1) − Vw(st)
9 zw ← γλwzw + ∇wVw(s)
10 zθ ← γλθzθ + γ
t∇θ log πθ(at|st)
11 w ← w + ηwδzw
12 θ ← θ + ηθδzθ
13 until converged
35.3.4 Bound optimization methods
In policy gradient methods, the objective J(θ) does not necessarily increase monotonically, but
rather can collapse especially if the learning rate is not small enough. We now describe methods that
guarantee monotonic improvement, similar to bound optimization algorithms (Section 6.5).
We start with a useful fact that relate the policy values of two arbitrary policies [KL02]:
J(π
′
) − J(π) = 1
1 − γ
Ep∞
π′
(s)

Eπ′(a|s)
[Aπ(s, a)]
(35.31)
where π can be interpreted as the current policy during policy optimization, and π
′ a candidate new
policy (such as the greedy policy wrt Qπ). As in the policy improvement theorem (Section 34.6.2),
if Eπ′(a|s)
[Aπ(s, a)] ≥ 0 for all s, then J(π
′
) ≥ J(π). However, we cannot ensure this condition to
hold when function approximation is used, as such a uniformly improving policy π
′ may not be
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.3. POLICY-BASED RL
representable by our parametric family, {πθ}θ∈Θ. Therefore, nonnegativity of Equation (35.31) is
not easy to ensure, when we do not have a direct way to sample states from p∞
π′ .
One way to ensure monotonic improvement of J is to improve the policy conservatively. Define
πθ = θπ′ + (1 − θ)π for θ ∈ [0, 1]. It follows from the policy gradient theorem (Equation (35.21), with
θ = [θ]) that J(πθ) − J(π) = θL(π
′
) + O(θ
2
), where
L(π
′
) ,
1
1 − γ
Ep∞π (s)

Eπ′(a|s)
[Aπ(s, a)]
=
1
1 − γ
Ep∞π (s)π(a|s)

π
′
(a|s)
π(a|s)
Aπ(s, a)

(35.32)
In the above, we have switched the state distribution from p∞
π′ in Equation (35.31) to p∞
π
, while at
the same time introducing a higher order residual term of O(θ
2
). The linear term, θL(π
′
), can be
estimated and optimized based on episodes sampled by π. The higher order term can be bounded in
various ways, resulting in different lower bounds of J(πθ) − J(π). We can then optimize θ to make
sure this lower bound is positive, which would imply J(πθ) − J(π) > 0. In conservative policy
iteration [KL02], the following (slightly simplified) lower bound is used
J
CPI(πθ) , J(π) + θL(π
′
) −
2εγ
(1 − γ)
2
θ
2
(35.33)
where ε = maxs |Eπ′(a|s)
[Aπ(s, a)] |.
This idea can be generalized to policies beyond those in the form of πθ, where the condition
of a small enough θ is replaced by a small enough divergence between π
′ and π. In safe policy
iteration [Pir+13], the divergence is the maximum total variation, while in trust region policy
optimization (TRPO) [Sch+15b], the divergence is the maximum KL-divergence. In the latter
case, π
′ may be found by optimizing the following lower bound
J
TRPO(π
′
) , J(π) + L(π
′
) −
εγ
(1 − γ)
2 max
s
DKL (π(s) k π
′
(s)) (35.34)
where ε = maxs,a |Aπ(s, a)|.
In practice, the above update rule can be overly conservative, and approximations are used.
[Sch+15b] propose a version that implements two ideas: one is to replace the point-wise maximum
KL-divergence by some average KL-divergence (usually averaged over p∞
πθ
); the second is to maximize
the first two terms in Equation (35.34), with π
′
lying in a KL-ball centered at π. That is, we solve
argmax
π′
L(π
′
) s.t. Ep∞π (s)
[DKL (π(s) k π
′
(s))] ≤ δ (35.35)
for some threshold δ > 0.
In Section 6.4.2.1, we show that the trust region method, using a KL penalty at each step, is
equivalent to natural gradient descent (see e.g., [Kak02; PS08b]). This is important, because a step
of size η in parameter space does not always correspond to a step of size η in the policy space:
dθ(θ1, θ2) = dθ(θ2, θ3) 6⇒ dπ(πθ1
, πθ2
) = dπ(πθ2
, πθ3
) (35.36)
where dθ(θ1, θ2) = kθ1 − θ2k is the Euclidean distance, and dπ(π1, π2) = DKL (π1 k π2) the KL
distance. In other words, the effect on the policy of any given change to the parameters depends
on where we are in parameter space. This is taken into account by the natural gradient method,
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1152
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
resulting in faster and more robust optimization. The natural policy gradient can be approximated
using the KFAC method (Section 6.4.4), as done in [Wu+17].
Other than TRPO, another approach inspired by Equation (35.34) is to use the KL-divergence as
a penalty term, replacing the factor 2εγ/(1 − γ)
2 by a tuning parameter. However, it often works
better, and is simpler, by using the following clipped objective, which results in the proximal policy
optimization or PPO method [Sch+17]:
J
PPO(π
′
) ,
1
1 − γ
Ep∞π (s)π(a|s)

κǫ

π
′
(a|s)
π(a|s)

Aπ(s, a)

(35.37)
where κǫ(x) , clip(x, 1 − ǫ, 1 + ǫ) ensures |κ(x) − 1| ≤ ǫ. This method can be modified to ensure
monotonic improvement as discussed in [WHT19], making it a true bound optimization method.
35.3.5 Deterministic policy gradient methods
In this section, we consider the case of a deterministic policy, that predicts a unique action for each
state, so at = µθ(st), rather than at ∼ πθ(st). We assume the states and actions are continuous, and
define the objective as
J(µθ) ,
1
1 − γ
Ep∞µθ
(s)
[R(s, µθ(s))] (35.38)
The deterministic policy gradient theorem [Sil+14] provides a way to compute the gradient:
∇θJ(µθ) = 1
1 − γ
Ep∞µθ
(s)
[∇θQµθ
(s, µθ(s))] (35.39)
=
1
1 − γ
Ep∞µθ
(s)

∇θµθ(s)∇aQµθ
(s, a)|a=µθ(s)

(35.40)
where ∇θµθ(s) is the M × N Jacobian matrix, and M and N are the dimensions of A and θ,
respectively. For stochastic policies of the form πθ(a|s) = µθ(s) + noise, the standard policy gradient
theorem reduces to the above form as the noise level goes to zero.
Note that the gradient estimate in Equation (35.40) integrates over the states but not over the
actions, which helps reduce the variance in gradient estimation from sampled trajectories. However,
since the deterministic policy does not do any exploration, we need to use an off-policy method, that
collects data from a stochastic behavior policy β, whose stationary state distribution is p∞
β
. The
original objective, J(µθ), is approximated by the following:
Jb(µθ) , Ep∞β
(s)
[Vµθ
(s)] = Ep∞β
(s)
[Qµθ
(s, µθ(s))] (35.41)
with the off-policy deterministic policy gradient approximated by (see also Section 35.5.1.2)
∇θJb(µθ) ≈ Ep∞β
(s)
[∇θ [Qµθ
(s, µθ(s))]] = Ep∞β
(s)

∇θµθ(s)∇aQµθ
(s, a)|a=µθ(s)ds
(35.42)
where we have a dropped a term that depends on ∇θQµθ
(s, a) and is hard to estimate [Sil+14].
To apply Equation (35.42), we may learn Qw ≈ Qµθ with TD, giving rise to the following updates:
δ = rt + γQw(st+1, µθ(st+1)) − Qw(st, at) (35.43)
wt+1 ← wt + ηwδ∇wQw(st, at) (35.44)
θt+1 ← θt + ηθ∇θµθ(st)∇aQw(st, a)|a=µθ(st) (35.45)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.4. MODEL-BASED RL
This avoids importance sampling in the actor update because of the deterministic policy gradient,
and avoids importance sampling in the critic update because of the use of Q-learning.
If Qw is linear in w, and uses features of the form φ(s, a) = a
T∇θµθ(s), where a is the vector
representation of a, then we say the function approximator for the critic is compatible with the
actor; in this case, one can show that the above approximation does not bias the overall gradient.
The method has been extended in various ways. The DDPG algorithm of [Lil+16], which stands
for “deep deterministic policy gradient”, uses the DQN method (Section 35.2.6) to update Q that
is represented by deep neural networks. The TD3 algorithm [FHM18], which stands for “twin
delayed DDPG”, extends DDPG by using double DQN (Section 35.2.5.2) and other heuristics to
further improve performance. Finally, the D4PG algorithm [BM+18], which stands for “distributed
distributional DDPG”, extends DDPG to handle distributed training, and to handle distributional
RL (i.e., working with distributions of rewards instead of expected rewards [BDM17]).
35.3.6 Gradient-free methods
The policy gradient estimator computes a “zeroth order” gradient, which essentially evaluates the
function with randomly sampled trajectories. Sometimes it can be more efficient to use a derivative￾free optimizer (Section 6.7), that does not even attempt to estimate the gradient. For example,
[MGR18] obtain good results by training linear policies with random search, and [Sal+17b] show
how to use evolutionary strategies to optimize the policy of a robotic controller.
35.4 Model-based RL
Model-free approaches to RL typically need a lot of interactions with the environment to achieve
good performance. For example, state of the art methods for the Atari benchmark, such as rainbow
(Section 35.2.6), use millions of frames, equivalent to many days of playing at the standard frame rate.
By contrast, humans can achieve the same performance in minutes [Tsi+17]. Similarly, OpenAI’s
robot hand controller [And+20] learns to manipulate a cube using 100 years of simulated data.
One promising approach to greater sample efficiency is model-based RL (MBRL). In this
approach, we first learn the transition model and reward function, pT (s
′
|s, a) and R(s, a), then
use them to compute a near-optimal policy. This approach can significantly reduce the amount of
real-world data that the agent needs to collect, since it can “try things out” in its imagination (i.e.,
the models), rather than having to try them out empirically.
There are several ways we can use a model, and many different kinds of model we can create. Some
of the algorithms mentioned earlier, such as MBIE and UCLR2 for provably efficient exploration
(Section 35.1.5.3), are examples of model-based methods. MBRL also provides a natural connection
between RL and planning (Section 34.6) [Sut90]. We discuss some examples in the sections below,
and refer to [MBJ20; PKP21; MH20] for more detailed reviews.
35.4.1 Model predictive control (MPC)
So far in this chapter, we have focused on trying to learn an optimal policy π∗(s), which can then be
used at run time to quickly pick the best action for any given state s. However, we can also avoid
performing all this work in advance, and wait until we know what state we are in, call it st, and
then use a model to predict future states and rewards that might follow for each possible sequence of
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1154
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 35.6: Illustration of heuristic search. In this figure, the subtrees are ordered according to a depth-first
search procedure. From Figure 8.9 of [SB18]. Used with kind permission of Richard Sutton.
future actions we might pursue. We then take the action that looks most promising, and repeat the
process at the next step. More precisely, we compute
a
∗
t:t+H−1 = argmax
at:t+H−1
E
"H
X−1
h=0
R(st+h, at+h) + Vˆ (st+H)
#
(35.46)
where the expectation is over state sequences that might result from executing at:t+H−1 from state
st. Here, H is called the planning horizon, and Vˆ (st+H) is an estimate of the reward-to-go at the
end of this H-step look-ahead process. This is known as receeding horizon control or model
predictive control (MPC) [MM90; CA13]. We discuss some special cases of this below.
35.4.1.1 Heuristic search
If the state and action spaces are finite, we can solve Equation (35.46) exactly, although the time
complexity will typically be exponential in H. However, in many situations, we can prune off
unpromising trajectories, thus making the approach feasible in large scale problems.
In particular, consider a discrete, deterministic MDP where reward maximization corresponds to
finding a shortest path to a goal state. We can expand the successors of the current state according
to all possible actions, trying to find the goal state. Since the search tree grows exponentially with
depth, we can use a heuristic function to prioritize which nodes to expand; this is called best-first
search, as illustrated in Figure 35.6.
If the heuristic function is an optimistic lower bound on the true distance to the goal, it is called
admissible; If we aim to maximize total rewards, admissibility means the heuristic function is an
upper bound of the true value function. Admissibility ensures we will never incorrectly prune off
parts of the search space. In this case, the resulting algorithm is known as A∗
search, and is optimal.
For more details on classical AI heuristic search methods, see [Pea84; RN19].
35.4.1.2 Monte Carlo tree search (MCTS)
Monte Carlo tree search or MCTS is similar to heuristic search, but learns a value function for
each encountered state, rather than relying on a manually designed heuristic (see e.g., [Mun14] for
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.4. MODEL-BASED RL
details). MCTS is inspired by UCB for bandits (Section 34.4.5), but applies to general sequential
decision making problems including MDPs [KS06].
The MCTS method forms the basis of the famous AlphaGo and AlphaZero programs [Sil+16;
Sil+18], which can play expert-level Go, chess, and shogi (Japanese chess), using a known model
of the environment. The MuZero method of [Sch+20] and the Stochastic MuZero method of
[Ant+22] extend this to the case where the world model is also learned. The action-value functions
for the intermediate nodes in the search tree are represented by deep neural networks, and updated
using temporal difference methods that we discuss in Section 35.2. MCTS can also be applied to
many other kinds of seqential decision problems, such as experiment design for sequentially creating
molecules [SPW18].
35.4.1.3 Trajectory optimization for continuous actions
For continuous actions, we cannot enumerate all possible branches in the search tree. Instead,
Equation (35.46) can be viewed as a nonlinear program, where at:t+H−1 are the real-valued variables
to be optimized. If the system dynamics are linear and the reward function corresponds to negative
quadratic cost, the optimal action sequence can be solved mathematically, as in the linear-quadratic￾Gaussian (LQG) controller (see e.g., [AM89; HR17]). However, this problem is hard in general and
often solved by numerical methods such as shooting and collocation [Die+07; Rao10; Kal+11].
Many of them work in an iterative fashion, starting with an initial action sequence followed by a step
to improve it. This process repeats until convergence of the cost.
An example is differential dynamic programming (DDP) [JM70; TL05]. In each iteration,
DDP starts with a reference trajectory, and linearizes the system dynamics around states on the
trajectory to form a locally quadratic approximation of the reward function. This system can be
solved using LQG, whose optimal solution results in a new trajectory. The algorithm then moves to
the next iteration, with the new trajectory as the reference trajectory.
Other alternatives are possible, including black-box (gradient-free) optimization methods like the
cross-entropy method. (see Section 6.7.5).
35.4.2 Combining model-based and model-free
In Section 35.4.1, we discussed MPC, which uses the model to decide which action to take at each
step. However, this can be slow, and can suffer from problems when the model is inaccurate. An
alternative is to use the learned model to help reduce the sample complexity of policy learning.
There are many ways to do this. One approach is to generate rollouts from the model, and then
train a policy or Q-function on the “hallucinated” data. This is the basis of the famous dyna method
[Sut90]. In [Jan+19], they propose a similar method, but generate short rollouts from previously
visited real states; this ensures the model only has to extrapolate locally.
In [Web+17], they train a model to predict future states and rewards, but then use the hidden
states of this model as additional context for a policy-based learning method. This can help overcome
partial observability. They call their method imagination-augmented agents. A related method
appears in [Jad+17], who propose to train a model to jointly predict future rewards and other
auxiliary signals, such as future states. This can help in situations when rewards are sparse or absent.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1156
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 35.7: (a) A cart-pole system being controlled by a policy learned by PILCO using just 17.5 seconds
of real-world interaction. The goal state is marked by the red cross. The initial state is where the cart is
stationary on the right edge of the workspace, and the pendulum is horizontal. For a video of the system
learning, see https: // bit. ly/ 35fpLmR . (b) A low-quality robot arm being controlled by a block-stacking
policy learned by PILCO using just 230 seconds of real-world interaction. From Figures 11, 12 from [DFR15].
Used with kind permission of Marc Deisenroth.
35.4.3 MBRL using Gaussian processes
This section gives some examples of dynamics models that have been learned for low-dimensional
continuous control problems. Such problems frequently arise in robotics. Since the dynamics are
often nonlinear, it is useful to use a flexible and sample-efficient model family, such as Gaussian
processes (Section 18.1). We will use notation like s and a for states and actions to emphasize they
are vectors.
35.4.3.1 PILCO
We first describe the PILCO method [DR11; DFR15], which stands for “probabilistic inference for
learning control”. It is extremely data efficient for continuous control problems, enabling learning
from scratch on real physical robots in a matter of minutes.
PILCO assumes the world model has the form st+1 = f(st, at) + ǫt, where ǫt ∼ N (0, Σ), and f
is an unknown, continuous function.4 The basic idea is to learn a Gaussian process (Section 18.1))
approximation of f based on some initial random trajectories, and then to use this model to generate
“fantasy” rollout trajectories of length T, that can be used to evaluate the expected cost of the
current policy, J(πθ) = PT
t=1 Eat∼πθ
[c(st)], where s0 ∼ p0. This function and its gradients wrt θ
can be computed deterministically, if a Gaussian assumption about the state distribution at each
step is made, because the Gaussian belief state can be propagated deterministically through the
GP model. Therefore, we can use deterministic batch optimization methods, such as Levenberg￾Marquardt, to optimize the policy parameters θ, instead of applying SGD to sampled trajectories.
(See https://github.com/mathDR/jax-pilco for some JAX code.)
Due to its data efficiency, it is possible to apply PILCO to real robots. Figure 35.7a shows the
results of applying it to solve a cart-pole swing-up task, where the goal is to make the inverted
pendulum swing up by applying a horizontal force to move the cart back and forth. The state of the
system s ∈ R
4
consists of the position x of the cart (with x = 0 being the center of the track), the
4. An alternative, which often works better, is to use f to model the residual, so that st+1 = st + f(st, at) + ǫt.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.4. MODEL-BASED RL
velocity x˙, the angle θ of the pendulum (measured from hanging downward), and the angular velocity
˙θ. The control signal a ∈ R is the force applied to the cart. The target state is s∗ = (0, ⋆, π, ⋆),
corresponding to the cart being in the middle and the pendulum being vertical, with velocities
unspecified. The authors used an RBF controller with 50 basis functions, amounting to a total of
305 policy parameters. The controller was successfully trained using just 7 real world trials.5
Figure 35.7b shows the results of applying PILCO to solve a block stacking task using a low￾quality robot arm with 6 degrees of freedom. A separate controller was trained for each block. The
state space s ∈ R
3
is the 3d location of the center of the block in the arm’s gripper (derived from
an RGBD sensor), and the control a ∈ R
4
corresponds to the pulse widths of four servo motors. A
linear policy was successfully trained using as few as 10 real world trials.
35.4.3.2 GP-MPC
[KD18a] have proposed an extension to PILCO that they call GP-MPC, since it combines a GP
dynamics model with model predictive control (Section 35.4.1). In particular, they use an open-loop
control policy to propose a sequence of actions, at:t+H−1, as opposed to sampling them from a policy.
They compute a Gaussian approximation to the future state trajectory, p(st+1:t+H|at:t+H−1, st), by
moment matching, and use this to deterministically compute the expected reward and its gradient
wrt at:t+H−1 (as opposed to the policy parameters θ). Using this, they can solve Equation (35.46)
to find a
∗
t:t+H−1
; finally, they execute the first step of this plan, a
∗
t
, and repeat the whole process.
The advantage of GP-MPC over policy-based PILCO is that it can handle constraints more easily,
and it can be more data efficient, since it continually updates the GP model after every step (instead
of at the end of an trajectory).
35.4.4 MBRL using DNNs
Gaussian processes do not scale well to large sample sizes and high dimensional data. Deep neural
networks (DNNs) work much better in this regime. However, they do not naturally model uncertainty,
which can cause MPC methods to fail. We discuss various methods for representing uncertainty with
DNNs in Section 17.1. Here, we mention a few approaches that have been used for MBRL.
The deep PILCO method uses DNNs together with Monte Carlo dropout (Section 17.3.1) to
represent uncertainty [GMAR16]. [Chu+18] proposed probabilistic ensembles with trajectory
sampling or PETS, which represents uncertainty using an ensemble of DNNs (Section 17.3.9).
Many other approaches are possible, depending on the details of the problem being tackled.
Since these are all stochastic methods (as opposed to the GP methods above), they can suffer from
a high variance in the predicted returns, which can make it difficult for the MPC controller to pick
the best action. We can reduce variance with the common random number trick [KSN99], where
all rollouts share the same random seed, so differences in J(πθ) can be attributed to changes in θ
but not other factors. This technique was used in PEGASUS [NJ00]
6 and in [HMD18].
5. 2 random initial trials, each 5 seconds, and then 5 policy-generated trials, each 2.5 seconds, totalling 17.5 seeconds.
6. PEGASUS stands for “Policy Evaluation-of-Goodness And Search Using Scenarios”, where the term “scenario” refers
to one of the shared random samples.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1158
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 35.8: (a) Illustration of an agent interacting with the VizDoom environment. (The yellow blobs
represent fireballs being thrown towards the agent by various enemies.) The agent has a world model, composed
of a vision system V and a memory RNN M, and has a controller C. (b) Detailed representation of the
memory model. Here ht is the deterministic hidden state of the RNN at time t, which is used to predict the
next latent of the VAE, zt+1, using a mixture density network (MDN). Here τ is a temperature parameter
used to increase the variance of the predictions, to prevent the controller from exploiting model inaccuracies.
From Figures 4, 6 of [HS18]. Used with kind permission of David Ha.
35.4.5 MBRL using latent-variable models
In this section, we describe some methods that learn latent variable models, rather than trying to
predict dynamics directly in the observed space, which is hard to do when the states are images.
35.4.5.1 World models
The “world models” paper [HS18] showed how to learn a generative model of two simple video
games (CarRacing and a VizDoom-like environment), such that the model can be used to train a
policy entirely in simulation. The basic idea is shown in Figure 35.8. First, we collect some random
experience, and use this to fit a VAE model (Section 21.2) to reduce the dimensionality of the images,
xt ∈ R
64×64×3
, to a latent zt ∈ R
64. Next, we train an RNN to predict p(zt+1|zt, at, ht), where ht
is the deterministic RNN state, and at is the continuous action vector (3-dimensional in both cases).
The emission model for the RNN is a mixture density network, in order to model multi-modal futures.
Finally, we train the controller using zt and ht as inputs; here zt is a compact representation of the
current frame, and ht is a compact representation of the predicted distribution over zt+1.
The authors of [HS18] trained the controller using a derivative free optimizer called CMA-ES
(covariance matrix adaptation evolutionary strategy, see Section 6.7.6.2). It can work better than
policy gradient methods, as discussed in Section 35.3.6. However, it does not scale to high dimensions.
To tackle this, the authors use a linear controller, which has only 867 parameters.7 By contrast,
VAE has 4.3M parameters and MDN-RNN 422k. Fortunately, these two models can be trained in an
unsupervised way from random rollouts, so sample efficiency is less critical than when training the
policy.
7. The input is a 32-dimensional zt plus a 256-dimensional ht, and there are 3 outputs. So the number of parameters
is (32 + 256) × 3 + 3 = 867, to account for the weights and biases.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.4. MODEL-BASED RL
So far, we have described how to use the representation learned by the generative model as
informative features for the controller, but the controller is still learned by interacting with the
real world. Surprisingly, we can also train the controller entirely in “dream mode”, in which the
generated images from the VAE decoder at time t are fed as input to the VAE encoder at time t + 1,
and the MDN-RNN is trained to predict the next reward rt+1 as well as zt+1. Unfortunately, this
method does not always work, since the model (which is trained in an unsupervised way) may fail to
capture task-relevant features (due to underfitting) and may memorize task-irrelevant features (due
to overfitting). The controller can learn to exploit weaknesses in the model (similar to an adversarial
attack) and achieve high simulated reward, but such a controller may not work well when transferred
to the real world.
One approach to combat this is to artificially increase the variance of the MDN model (by using
a temperature parameter τ ), in order to make the generated samples more stochastic. This forces
the controller to be robust to large variations; the controller will then treat the real world as just
another kind of noise. This is similar to the technique of domain randomization, which is sometimes
used for sim-to-real applications; see e.g., [MAZA18].
35.4.5.2 PlaNet and Dreamer
In [HS18], they first learn the world model on random rollouts, and then train a controller. On harder
problems, it is necessary to iterate these two steps, so the model can be trained on data collected by
the controller, in an iterative fashion.
In this section, we describe one method of this kind, known as PlaNet [Haf+19]. PlaNet
uses a POMDP model, where zt are the latent states, st are the observations, at are the ac￾tions, and rt are the rewards. It fits a recurrent state space model (Section 29.13.2) of the form
p(zt|zt−1, at−1)p(st|zt)p(rt|zt) using variational inference, where the posterior is approximated by
q(zt|s1:t, a1:t−1). After fitting the model to some random trajectories, the system uses the inference
model to compute the current belief state, and then uses the cross entropy method to find an action
sequence for the next H steps to maximize expected reward, by optimizing in latent space. The
system then executes a
∗
t
, updates the model, and repeats the whole process. To encourage the
dynamics model to capture long term trajectories, they use the “latent overshooting” training method
described in Section 29.13.3. The PlaNet method outperforms model-free methods, such as A3C
(Section 35.3.3.1) and D4PG (Section 35.3.5), on various image-based continuous control tasks,
illustrated in Figure 35.9.
Although PlaNet is sample efficient, it is not computationally efficient. For example, they use
CEM with 1000 samples and 10 iterations to optimize trajectories with a horizon of length 12, which
requires 120, 000 evaluations of the transition dynamics to choose a single action. [AY19] improve this
by replacing CEM with differentiable CEM, and then optimize in a latent space of action sequences.
This is much faster, but the results are not quite as good. However, since the whole policy is now
differentiable, it can be fine-tuned using PPO (Section 35.3.4), which closes the performance gap at
negligible cost.
A recent extension of the PlaNet paper, known as Dreamer, was proposed in [Haf+20]. In this
paper, the online MPC planner is replaced by a policy network, π(at|zt), which is learned using
gradient-based actor-critic in latent space. The inference and generative models are trained by
maximizing the ELBO, as in PlaNet. The policy is trained by SGD to maximize expected total
reward as predicted by the value function, and the value function is trained by SGD to minimize
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1160
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Figure 35.9: Illustration of some image-based control problems used in the PlaNet paper. Inputs are 64×64×3.
(a) The cartpole swingup task has a fixed camera so the cart can move out of sight, making this a partially
observable problem. (b) The reacher task has a sparse reward. (c) The cheetah running task includes both
contacts and a larger number of joints. (d) The finger spinning task includes contacts between the finger and
the object. (e) The cup task has a sparse reward that is only given once the ball is caught. (f) The walker
task requires balance and predicting difficult interactions with the ground when the robot is lying down. From
Figure 1 of [Haf+19]. Used with kind permission of Danijar Hafner.
MSE between predicted future reward and the TD-λ estimate (Section 35.2.2). They show that
Dreamer gives better results than PlaNet, presumably because they learn a policy to optimize the long
term reward (as estimated by the value function), rather than relying on MPC based on short-term
rollouts.
35.4.6 Robustness to model errors
The main challenge with MBRL is that errors in the model can result in poor performance of the
resulting policy, due to the distribution shift problem (Section 19.2). That is, the model is trained
to predict states and rewards that it has seen using some behavior policy (e.g., the current policy),
and then is used to compute an optimal policy under the learned model. When the latter policy is
followed, the agent will experience a different distribution of states, under which the learned model
may not be a good approximation of the real environment.
We require the model to generalize in a robust way to new states and actions. (This is related to
the off-policy learning problem that we discuss in Section 35.5.) Failing that, the model should at
least be able to quantify its uncertainty (Section 19.3). These topics are the focus of much recent
research (see e.g., [Luo+19; Kur+19; Jan+19; Isl+19; Man+19; WB20; Eys+21]).
35.5 Off-policy learning
We have seen examples of off-policy methods such as Q-learning. They do not require that training
data be generated by the policy it tries to evaluate or improve. Therefore, they tend to have greater
data efficiency than their on-policy counterparts, by taking advantage of data generated by other
policies. They are also easier to be applied in practice, especially in domains where costs and risks of
following a new policy must be considered. This section covers this important topic.
A key challenge in off-policy learning is that the data distribution is typically different from the
desired one, and this mismatch must be dealt with. For example, the probability of visiting a state s
at time t in a trajectory depends not only on the MDP’s transition model, but also on the policy
that is being followed. If we are to estimate J(π), as defined in Equation (35.15), but the trajectories
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.5. OFF-POLICY LEARNING
are generated by a different policy π
′
, simply averaging rewards in the data gives us J(π
′
), not J(π).
We have to somehow correct for the gap, or “bias”. Another challenge is that off-policy data can also
make an algorithm unstable and divergent, which we will discuss in Section 35.5.3.
Removing distribution mismatches is not unique in off-policy learning, and is also needed in
supervised learning to handle covariate shift (Section 19.2.3.1), and in causal effect estimation
(Chapter 36), among others. Off-policy learning is also closely related to offline reinforcement
learning (also called batch reinforcement learning): the former emphasizes the distributional
mismatch between data and the agent’s policy, and the latter emphasizes that the data is static and
no further online interaction with the environment is allowed [LP03; EGW05; Lev+20]. Clearly, in the
offline scenario with fixed data, off-policy learning is typically a critical technical component. Recently,
several datasets have been prepared to facilitate empirical comparisons of offline RL methods (see
e.g., [Gul+20; Fu+20]).
Finally, while this section focuses on MDPs, most methods can be simplified and adapted to the
special case of contextual bandits (Section 34.4). In fact, off-policy methods have been successfully
used in numerous industrial bandit applications (see e.g., [Li+10; Bot+13; SJ15; HLR16]).
35.5.1 Basic techniques
We start with four basic techniques, and will consider more sophisticated ones in subsequent sections.
The off-policy data is assumed to be a collection of trajectories: D = {τ
(i)}1≤i≤n, where each
trajectory is a sequence as before: τ
(i) = (s
(i)
0
, a
(i)
0
, r
(i)
0
, s
(i)
1
. . .). Here, the reward and next states
are sampled according to the reward and transition models; the actions are chosen by a behavior
policy, denoted πb, which is different from the target policy, πe, that the agent is evaluating or
improving. When πb is unknown, we are in a behavior-agnostic off-policy setting.
35.5.1.1 Direct method
A natural approach to off-policy learning starts with estimating the unknown reward and transition
models of the MDP from off-policy data. This can be done using regression and density estimation
methods on the reward and transition models, respectively, to obtain Rˆ and Pˆ; see Section 35.4 for
further discussions. These estimated models then give us an inexpensive way to (approximately)
simulate the original MDP, and we can apply on-policy methods on the simulated data. This method
directly models the outcome of taking an action in a state, thus the name direct method, and is
sometimes known as regression estimator and plug-in estimator.
While the direct method is natural and sometimes effective, it has a few limitations. First, a small
estimation error in the simulator has a compounding effect in long-horizon problems (or equivalently,
when the discount factor γ is close to 1). Therefore, an agent that is optimized against an MDP
simulator may overfit the estimation errors. Unfortunately, learning the MDP model, especially the
transition model, is generally difficult, making the method limited in domains where Rˆ and Pˆ can be
learned to high fidelity. See Section 35.4.6 for a related discussion.
35.5.1.2 Importance sampling
The second approach relies on importance sampling (IS) (Section 11.5) to correct for distributional
mismatches in the off-policy data. To demonstrate the idea, consider the problem of estimating the
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1162
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
target policy value J(πe) with a fixed horizon T. Correspondingly, the trajectories in D are also of
length T. Then, the IS off-policy estimator, first adopted by [PSS00], is given by
Jˆ
IS(πe) ,
1
n
Xn
i=1
p(τ
(i)
|πe)
p(τ
(i)
|πb)
T
X−1
t=0
γ
t
r
(i)
t
(35.47)
It can be verified that Eπb
h
Jˆ
IS(πe)
i
= J(πe), that is, Jˆ
IS(πe) is unbiased, provided that p(τ |πb) > 0
whenever p(τ |πe) > 0. The importance ratio,
p(τ
(i)
|πe)
p(τ(i)|πb)
, is used to compensate for the fact that the
data is sampled from πb and not πe. Furthermore, this ratio does not depend on the MDP models,
because for any trajectory τ = (s0, a0, r0, s1, . . . , sT ), we have from Equation (34.74) that
p(τ |πe)
p(τ |πb)
=
p(s0)
QT −1
t=0 πe(at|st)pT (st+1|st, at)pR(rt|st, at, st+1)
p(s0)
QT −1
t=0 πb(at|st)pT (st+1|st, at)pR(rt|st, at, st+1)
=
T
Y−1
t=0
πe(at|st)
πb(at|st)
(35.48)
This simplification makes it easy to apply IS, as long as the target and behavior policies are
known. If the behavior policy is unknown, we can estimate it from D (using, e.g., logistic regression
or DNNs), and replace πb by its estimate πˆb in Equation (35.48). For convenience, define the
per-step importance ratio at time t by ρt(τ ) , πe(at|st)/πb(at|st), and similarly, ρˆt(τ ) ,
πe(at|st)/πˆb(at|st).
Although IS can in principle eliminate distributional mismatches, in practice its usability is often
limited by its potentially high variance. Indeed, the importance ratio in Equation (35.47) can be
arbitrarily large if p(τ
(i)
|πe) ≫ p(τ
(i)
|πb). There are many improvements to the basic IS estimator.
One improvement is based on the observation that the reward rt is independent of the trajectory
beyond time t. This leads to a per-decision importance sampling variant that often yields lower
variance (see Section 11.6.2 for a statistical motivation, and [LBB20] for a further discussion):
Jˆ
PDIS(πe) ,
1
n
Xn
i=1
T
X−1
t=0
Y
t
′≤t
ρt
′ (τ
(i)
)γ
t
r
(i)
t
(35.49)
There are many other variants such as self-normalized IS and truncated IS, both of which aim to
reduce variance possibly at the cost of a small bias; precise expressions of these alternatives are found,
e.g., in [Liu+18b]. In the next subsection, we will discuss another systematic way to improve IS.
IS may also be applied to improve a policy against the policy value given in Equation (35.15).
However, directly applying the calculation of Equation (35.48) runs into a fundamental issue with IS,
which we will discuss in Section 35.5.2. For now, we may consider the following approximation of
policy value, averaging over the state distribution of the behavior policy:
Jb(πθ) , Ep∞β
(s)
[Vπ(s)] = Ep∞β
(s)
"X
a
πθ(a|s)Qπ(s, a)
#
(35.50)
Differentiating this and ignoring the term ∇θQπ(s, a), as suggested by [DWS12], gives a way to
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.5. OFF-POLICY LEARNING
(approximately) estimate the off-policy policy-gradient using a one-step IS correction ratio:
∇θJb(πθ) ≈ Ep∞β
(s)
"X
a
∇θπθ(a|s)Qπ(s, a)
#
= Ep∞β
(s)β(a|s)

πθ(a|s)
β(a|s)
∇θ log πθ(a|s)Qπ(s, a)

Finally, we note that in the tabular MDP case, there exists a policy π∗ that is optimal in all states
(Section 34.5.5). This policy maximizes J and Jb simultaneously, so Equation (35.50) can be a good
proxy for Equation (35.15) as long as all states are “covered” by the behavior policy πb. The situation
is similar when the set of value functions or policies under consideration is sufficiently expressive: an
example is a Q-learning like algorithm called Retrace [Mun+16; ASN20]. Unfortunately, in general
when we work with parametric families of value functions or policies, such a uniform optimality is
lost, and the distribution of states has a direct impact on the solution found by the algorithm. We
will revisit this problem in Section 35.5.2.
35.5.1.3 Doubly robust
It is possible to combine the direct and importance sampling methods discussed previously. To
develop intuition, consider the problem of estimating J(πe) in a contextual bandit (Section 34.4),
that is, when T = 1 in D. The doubly robust (DR) estimator is given by
JˆDR(πe) ,
1
n
Xn
i=1 
πe(a
(i)
0
|s
(i)
0
)
πˆb(a
(i)
0
|s
(i)
0
)

r
(i)
0 − Qˆ(s
(i)
0
, a
(i)
0
)

+ Vˆ (s
(i)
0
)
!
(35.51)
where Qˆ is an estimate of Qπe
, which can be obtained using methods discussed in Section 35.2,
and Vˆ (s) = Eπe(a|s)
h
Qˆ(s, a)
i
. If πˆb = πb, the term Qˆ is canceled by Vˆ on average, and we get the
IS estimate that is unbiased; if Qˆ = Qπe
, the term Qˆ is canceled by the reward on average, and
we get the estimator as in the direct method that is also unbiased. In other words, the estimator
Equation (35.51) is unbiased, as long as one of the estimates, πˆb and Qˆ, is right. This observation
justifies the name doubly robust, which has its origin in causal inference (see e.g., [BR05]).
The above DR estimator may be extended to MDPs recursively, starting from the last step. Given
a length-T trajectory τ , define JˆDR[T] , 0, and for t < T,
JˆDR[t] , Vˆ (st) + ˆρt(τ )

rt + γJˆDR[t + 1] − Qˆ(st, at)

(35.52)
where Qˆ(st, at) is the estimated cumulative reward for the remaining T − t steps. The DR estimator
of J(πe), denoted JˆDR(πe), is the average of JˆDR[0] over all n trajectories in D [JL16]. It can be
verified (as an exercise) that the recursive definition is equivalent to
JˆDR[0] = Vˆ (s0) +
T
X−1
t=0 Yt
t
′=0
ρˆt
′ (τ )
!
γ
t

rt + γVˆ (st+1) − Qˆ(st, at)

(35.53)
This form can be easily generalized to the infinite-horizon setting by letting T → ∞ [TB16]. Other
than double robustness, the estimator is also shown to result in minimum variance under certain
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1164
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
conditions [JL16]. Finally, the DR estimator can be incorporated into policy gradient for policy
optimization, to reduce gradient estimation variance [HJ20].
35.5.1.4 Behavior regularized method
The three methods discussed previously do not impose any constraint on the target policy πe.
Typically, the more different πe is from πb, the less accurate our off-policy estimation can be.
Therefore, when we optimize a policy in offline RL, a natural strategy is to favor target policies that
are “close” to the behavior policy. Similar ideas are discussed in the context of conservative policy
gradient (Section 35.3.4).
One approach is to impose a hard constraint on the proximity between the two policies. For
example, we may modify the loss function of DQN (Equation (35.14)) as follows
L
DQN
1
(w) , E(s,a,r,s′)∼D 
￾
r + γ max
π:D(π,πb)≤ε
Eπ(a′
|s
′)
[Qw− (s
′
, a′
)] − Qw(s, a)
2

(35.54)
In the above, we replace the maxa′ operation by an expectation over a policy that stays close enough
to the behavior policy, measured by some distance function D. For various instantiations and further
details, see e.g, [FMP19; Kum+19a].
We may also impose a soft constraint on the proximity, by penalizing target policies that are too
different. The DQN loss function can be adapted accordingly:
L
DQN
2
(w) , E(s,a,r,s′)∼D h￾
r + γ max
π
Eπ(a′
|s
′)
[Qw− (s
′
, a′
)] − αγD(π(s
′
), πb(s
′
)) − Qw(s, a)
2
i
(35.55)
This idea has been used in contextual bandits [SJ15] and empirically studied in MDPs by [WTN19].
There are many choices for the function D, such as the KL-divergence, for both hard and soft
constraints. More detailed discussions and examples can be found in [Lev+20].
Finally, behavior regularization and previous methods like IS can be combined, where the former
ensures lower variance and greater generalization of the latter (e.g., [SJ15]). Furthermore, most
proposed behavior regularized methods consider one-step difference in D, comparing π(s) and πb(s)
conditioned on s. In many cases, it is desired to consider the difference between the long-term
distributions, p∞
β
and p∞, which we will discuss next.
35.5.2 The curse of horizon
The IS and DR approaches presented in the previous section all rely on an importance ratio to
correct distributional mismatches. The ratio depends on the entire trajectory, and its variance grows
exponentially in the trajectory length T. Correspondingly, the off-policy estimate of either the policy
value or policy gradient can suffer an exponentially large variance (and thus very low accuracy), a
challenge called the curse of horizon [Liu+18b]. Policies found by approximate algorithms like
Q-learning and off-policy actor-critic often have hard-to-control error due to distribution mismatches.
This section discusses an approach to tackling this challenge, by considering corrections in the
state-action distribution, rather than in the trajectory distribution. This change is critical: [Liu+18b]
describes an example, where the state-action distributions under the behavior and target policies
are identical, but the importance ratio of a trajectory grows exponentially large. It is now more
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 201
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.5. OFF-POLICY LEARNING
convenient to assume the off-policy data consists of a set of transitions: D = {(si
, ai
, ri
, s′
i
)}1≤i≤m,
where (si
, ai) ∼ pD (some fixed but unknown sampling distribution, such as p∞
β
), and ri and
s
′
i
are sampled from the MDP’s reward and transition models. Given a policy π, we aim to
estimate the correction ratio ζ∗(s, a) = p∞
π
(s, a)/pD(s, a), as it allows us to rewrite the policy value
(Equation (35.15)) as
J(π) = 1
1 − γ
Ep∞π (s,a)
[R(s, a)] = 1
1 − γ
Ep∞β
(s,a)
[ζ∗(s, a)R(s, a)] (35.56)
For simplicity, we assume the initial state distribution p0 is known, or can be easily sampled from.
This assumption is often easy to satisfy in practice.
The starting point is the following linear program formulation for any given π:
max
d≥0
− Df (dkpD)) s.t. d(s, a) = (1 − γ)µ0(s)π(a|s) + γ
X
s, ¯ a¯
p(s|s, ¯ a¯)d(¯s, a¯)π(a|s) ∀(s, a)
(35.57)
where Df
is the f-divergence (Section 2.7.1). The constraint is a variant of Equation (34.93), giving
similar flow conditions in the space of S × A under policy π. Under mild conditions, p∞
π
is only
solution that satisfies the flow constraints, so the objective does not affect the solution, but will
facilitate the derivation below. We can now obtain the Lagrangian, with multipliers {ν(s, a)}, and
use the change-of-variables ζ(s, a) = d(s, a)/pD(s, a) to obtain the following optimization problem:
max
ζ≥0
min
ν
L(ζ, ν) =EpD(s,a)
[−f(ζ(s, a)] + (1 − γ)Ep0(s)π(a|s)
[ν(s, a)] (35.58)
+ Eπ(a′
|s
′)p(s
′
|s,a)pD(s,a)
[ζ(s, a) (γν(s
′
, a′
) − ν(s, a))]
It can be shown that the saddle point to Equation (35.58) must coincide with the desired correction
ratio ζ∗. In practice, we may parameterize ζ and ν, and apply two-timescales stochastic gradient
descent/ascent on the off-policy data D to solve for an approximate saddle-point. This is the
DualDICE method [Nac+19a], which is extended to GenDICE [Zha+20c].
Compared to the IS or DR approaches, Equation (35.58) does not compute the importance ratio of
a trajectory, thus generally has a lower variance. Furthermore, it is behavior-agnostic, without having
to estimate the behavior policy, or even to assume data consists of a collection of trajectories. Finally,
this approach can be extended to be doubly robust (e.g., [UHJ20]), and to optimize a policy [Nac+19b]
against the true policy value J(π) (as opposed to approximations like Equation (35.50)). For more
examples along this line of approach, see [ND20] and the references therein.
35.5.3 The deadly triad
Other than introducing bias, off-policy data may also make a value-based RL method unstable and
even divergent. Consider the simple MDP depicted in Figure 35.10a, due to [Bai95]. It has 7 states
and 2 actions. Taking the dashed action takes the environment to the 6 upper states uniformly at
random, while the solid action takes it to the bottom state. The reward is 0 in all transitions, and
γ = 0.99. The value function Vw uses a linear parameterization indicated by the expressions shown
inside the states, with w ∈ R
8
. The target policies π always chooses the solid action in every state.
Clearly, the true value function, Vπ(s) = 0, can be exactly represented by setting w = 0.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1166
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(a) (b)
Figure 35.10: (a) A simple MDP. (b) Parameters of the policy diverge over time. From Figures 11.1 and
11.2 of [SB18]. Used with kind permission of Richard Sutton.
Suppose we use a behavior policy b to generate a trajectory, which chooses the dashed and solid
actions with probabilities 6/7 and 1/7, respectively, in every state. If we apply TD(0) on this
trajectory, the parameters diverge to ∞ (Figure 35.10b), even though the problem appears simple!
In contrast, with on-policy data (that is, when b is the same as π), TD(0) with linear approximation
can be guaranteed to converge to a good value function approximate [TR97].
The divergence behavior is demonstrated in many value-based bootstrapping methods, including
TD, Q-learning, and related approximate dynamic programming algorithms, where the value function
is represented either linearly (like the example above) or nonlinearly [Gor95; Ber19]. The root cause
of these divergence phenomena is that the contraction property in the tabular case (Equation (34.87))
may no longer hold when V is approximated by Vw. An RL algorithm can become unstable when it
has these three components: off-policy learning, bootstrapping (for faster learning, compared to MC),
function approximation (for generalization in large scale MDPs). This combination is known as the
deadly triad [SB18]. It highlights another important challenge introduced by off-policy learning,
and is a subject of ongoing research (e.g., [van+18; Kum+19a]).
A general way to ensure convergence in off-policy learning is to construct an objective function
function, the minimization of which leads to a good value function approximation; see [SB18, Ch. 11]
for more background. A natural candidate is the discrepancy between the left and right hand sides of
the Bellman optimality Equation (34.82), whose unique solution is V∗. However, the “max” operator
is not friendly to optimization. Instead, we may introduce an entropy term to smooth the greedy
policy, resulting in a differential square loss in path consistency learning (PCL) [Nac+17]:
min
V,π
L
PCL(V, π) , E

1
2
￾
r + γV (s
′
) − λ log π(a|s) − V (s)
2

(35.59)
where the expectation is over (s, a, r, s′
) tuples drawn from some off-policy distribution (e.g., uniform
over D). Minimizing this loss, however, does not result in the optimal value function and policy in
general, due to an issue known as “double sampling” [SB18, Sec. 11.5].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.6. CONTROL AS INFERENCE
o0 o1 o2 o3
a0 a1 a2 a3
s0 s1 s2 s3 · · ·
Figure 35.11: A graphical model for optimal control. States and actions are observed, while optimality
variables are not. Adapted from Figure 1b of [Lev18].
This problem can be mitigated by introducing a dual function in the optimization [Dai+18]
min
V,π
max
ν
L
SBEED(V, π; ν) , E
h
ν(s, a)
￾
r + γV (s
′
) − λ log π(a|s) − V (s)
2
− ν(s, a)
2
/2
i
(35.60)
where ν belongs to some function class (e.g., a DNN [Dai+18] or RKHS [FLL19]). It can be shown
that optimizing Equation (35.60) forces ν to model the Bellman error. So this approach is called
smoothed Bellman error embedding, or SBEED. In both PCL and SBEED, the objective can
be optimized by gradient-based methods on parameterized value functions and policies.
35.6 Control as inference
In this section, we will discuss another approach to policy optimization, by reducing it to probabilistic
inference. This is called control as inference, see e.g., [Att03; TS06; Tou09; BT12; KGO12; HR17;
Lev18]. This approach allows one to incorporate domain knowledge in modeling, and apply powerful
tools from approximate inference (see e.g., Chapter 7), in a consistent and flexible framework.
35.6.1 Maximum entropy reinforcement learning
We now describe a graphical model that exemplifies such a reduction, which results in RL algorithms
that are closely related to some discussed previously. The model allows a trade-off between reward
and entropy maximization, and recovers the standard RL setting when the entropy part vanishes in
the trade-off. Our discussion mostly follows the approach of [Lev18].
Figure 35.11 gives a probabilistic model, which not only captures state transitions as before, but
also introduces a new variable, ot. This variable is binary, indicating whether the action at time t is
optimal or not, and has the following probability distribution:
p(ot = 1|st, at) = exp(λ
−1R(st, at)) (35.61)
for some temperature parameter λ > 0 whose role will be clear soon. In the above, we have
assumed without much loss of generality that R(s, a) < 0, so that Equation (35.61) gives a valid
probability. Furthermore, we can assume a non-informative, uniform action prior, p(at|st), to simplify
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens1168
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
the exposition, for we can always push p(at|st) into Equation (35.61). Under these assumptions, the
likelihood of observing a length-T trajectory τ , when optimality achieved in every step, is:
p(τ |o0:T −1 = 1) ∝ p(τ , o0:T −1 = 1) ∝ p(s0)
T
Y−1
t=0
p(ot = 1|st, at)pT (st+1|st, at)
= p(s0)
T
Y−1
t=0
pT (st+1|st, at) exp 
1
λ
T
X−1
t=0
R(st, at)
!
(35.62)
The intuition of Equation (35.62) is clearest when the state transitions are deterministic. In this
case, pT (st+1|st, at) is either 1 or 0, depending on whether the transition is dynamically feasible or
not. Hence, p(τ |o0:T −1 = 1) is either proportional to exp(λ
−1 PT −1
t=0 R(st, at)) if τ is feasible, or 0
otherwise. Maximizing reward is equivalent to inferring a trajectory with maximum p(τ |o0:T −1 = 1).
The optimal policy in this probabilistic model is given by
p(at|st, ot:T −1 = 1) = p(st, at|ot:T −1 = 1)
p(st|ot:T −1 = 1)
=
p(ot:T −1 = 1|st, at)p(at|st)p(st)
p(ot:T −1 = 1|st)p(st)
∝
p(ot:T −1 = 1|st, at)
p(ot:T −1 = 1|st)
(35.63)
The two probabilities in Equation (35.63) can be computed as follows, starting with p(oT −1 =
1|sT −1, aT −1) = exp(λ
−1R(sT −1, aT −1)),
p(ot:T −1 = 1|st, at) = Z
S
p(ot+1:T −1 = 1|st+1)pT (st+1|st, at) exp(λ
−1R(st, at))dst+1 (35.64)
p(ot:T −1 = 1|st) = Z
A
p(ot:T −1 = 1|st, at)p(at|st)dat (35.65)
The calculation above is expensive. In practice, we can approximate the optimal policy using a
parametric form, πθ(at|st). The resulted probability of trajectory τ now becomes
pθ(τ ) = p(s1)
T
Y−1
t=0
pT (st+1|st, at)πθ(at|st) (35.66)
If we optimize θ so that DKL (pθ(τ ) k p(τ |o0:T −1 = 1)) is minimized, which can be simplified to
DKL (pθ(τ ) k p(τ |o0:T −1 = 1)) = −Epθ
"
T
X−1
t=0
λ
−1R(st, at) + H(πθ(st))#
+ const (35.67)
where the constant term only depends on the uniform action prior p(at|st), but not θ. In other words,
the objective is to maximize total reward, with an entropy regularization favoring more uniform
policies. Thus this approach is called maximum entropy RL, or MERL. If πθ can represent all
stochastic policies, a softmax version of the Bellman equation can be obtained for Equation (35.67):
Q∗(st, at) = λ
−1R(st, at) + EpT (st+1|st,at)

log Z
A
exp(Q∗(st+1, at+1))da
(35.68)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.6. CONTROL AS INFERENCE
with the convention that Q∗(sT , a) = 0 for all a, and the optimal policy has a softmax form:
π∗(at|st) ∝ exp(Q∗(st, at)). Note that the Q∗ above is different from the usual optimal Q-function
(Equation (34.83)), due to the introduction of the entropy term. However, as λ → 0, their difference
vanishes, and the softmax policy becomes greedy, recovering the standard RL setting.
The soft actor-critic (SAC) algorithm [Haa+18b; Haa+18c] is an off-policy actor-critic method
whose objective function is equivalent to Equation (35.67) (by taking T to ∞):
J
SAC(θ) , Ep∞πθ
(s)πθ(a|s)
[R(s, a) + λ H(πθ(s))] (35.69)
Note that the entropy term has also the added benefit of encouraging exploration.
To compute the optimal policy, similar to other actor-critic algorithms, we will work with the “soft”
state- and action-function approximations, parameterized by w and u, respectively:
Qw(s, a) = R(s, a) + γEpT (s
′
|s,a)
[Vu(s
′
, a′
) − λ log πθ(a
′
|s
′
)] (35.70)
Vu(s, a) = λ logX
a
exp(λ
−1Qw(s, a)) (35.71)
This induces an improved policy (with entropy regularization): πw(a|s) = exp(λ
−1Qw(s, a))/Zw(s),
where Zw(s) = P
a
exp(λ
−1Qw(s, a)) is the normalization constant. We then perform a soft policy
improvement step to update θ by minimizing E [DKL (πθ(s) k πw(s))] where the expectation may be
approximated by sampling s from a replay buffer D.
In [Haa+18c; Haa+18b], they show that the SAC method outperforms the off-policy DDPG
algorithm (Section 35.3.5) and the on-policy PPO algorithm (Section 35.3.4) by a wide margin on
various continuous control tasks. For more details, see [Haa+18c].
There is a variant of soft actor-critic, which only requires to model the action-value function. It is
based on the observation that both the policy and soft value function can be induced by the soft
action-value function as follows:
Vw(s) = λ logX
a
exp ￾
λ
−1Qw(s, a)

(35.72)
πw(a|s) = exp ￾
λ
−1
(Qw(s, a) − Vw(s))
(35.73)
We then only need to learn w, using approaches similar to DQN (Section 35.2.6). The resulting
algorithm, soft Q-learning [SAC17], is convenient if the number of actions is small (when A is
discrete), or if the integral in obtaining Vw from Qw is easy to compute (when A is continuous).
It is interesting to see that algorithms derived in the maximum entropy RL framework bears a
resemblance to PCL and SBEED in Section 35.5.3, both of which were to minimize an objective
function resulting from the entropy-smoothed Bellman equation.
35.6.2 Other approaches
VIREL is an alternative model to maximum entropy RL [Fel+19]. Similar to soft actor-critic, it uses
an approximate action-value function, Qw, a stochastic policy, πθ, and a binary optimality random
variable ot at time t. A different probability model for ot is used
p(ot = 1|st, at) = exp 
Qw(st, at) − maxa Qw(st, a)
λw

(35.74)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licen1170
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The temperature parameter λw is also part of the parameterization, and can be updated from data.
An EM method can be used to maximize the objective
L(w, θ) = Ep(s)

Eπθ(a|s)

Qw(s, a)
λw

+ H(πθ(s))
(35.75)
for some distribution p that can be conveniently sampled from (e.g., in a replay buffer). The algorithm
may be interpreted as an instance of actor-critic. In the E-step, the critic parameter w is fixed, and
the actor parameter θ is updated using gradient accent with stepsize ηθ (for policy improvement):
θ ← θ + ηθ∇θL(w, θ) (35.76)
In the M-step, the actor parameter is fixed, and the critic parameter is updated (for policy evaluation):
w ← w + ηw∇wL(w, θ) (35.77)
Finally, there are other possibilities of reducing optimal control to probabilistic inference, in
addition to MERL and VIREL. For example, we may aim to maximize the expectation of the
trajectory return G, by optimizing the policy parameter θ:
J(πθ) = Z
G(τ )p(τ |θ)dτ (35.78)
It can be interpreted as a pseudo-likelihood function, when the G(τ ) is treated as probability density,
and solved (approximately) by a range of algorithms (see e.g., [PS07; Neu11; Abd+18]). Interestingly,
some of these methods have a similar objective as MERL (Equation (35.67)), although the distribution
involving θ appears in the second argument of DKL. As discussed in Section 2.7.1, this forwards
KL-divergence is mode-covering, which in the context of RL is argued to be less preferred than the
mode-seeking, reverse KL-divergence used by MERL. For more details and references, see [Lev18].
Control as inference is also closely related to active inference; this is based on the free energy
principle which is popular in neuroscience (see e.g., [Fri09; Buc+17; SKM18; Ger19; Maz+22]).
The FEP is equivalent to using variational inference (see Section 10.1) to perform state estimation
(perception) and parameter estimation (learning). In particular, consider a latent variable model
with hidden states s, observations y, and parameters θ. Following Section 10.1.1.1, we define the
variational free energy to be F(o) = DKL (q(s, θ|y) k p(s, y, θ)). State estimation corresponds to
solving minq(s|y) F(y), and parameter estimation corresponds to solving minq(θ|y) F(y), just as in
variational Bayes EM (Section 10.3.5). (Minimizing the VFE for certain hierarchical Gaussian models
also forms the foundation of predictive coding, which we discuss in Supplementary Section 8.1.4.)
To extend this to decision making problems we can define the expected free energy as F(a) =
Eq(y|a)
[F(y)], where q(y|a) is the posterior predictive distribution over observations given actions
sequence a. The connection to control as inference is explained in [Mil+20; WIP20; LÖW21].
35.6.3 Imitation learning
In previous sections, an RL agent is to learn an optimal sequential decision making policy so that the
total reward is maximized. Imitation learning (IL), also known as apprenticeship learning and
learning from demonstration (LfD), is a different setting, in which the agent does not observe
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
35.6. CONTROL AS INFERENCE
rewards, but has access to a collection Dexp of trajectories generated by an expert policy πexp; that
is, τ = (s0, a0, s1, a1, . . . , sT ) and at ∼ πexp(st) for τ ∈ Dexp. The goal is to learn a good policy by
imitating the expert, in the absence of reward signals. IL finds many applications in scenarios where
we have demonstrations of experts (often humans) but designing a good reward function is not easy,
such as car driving and conversational systems. See [Osa+18] for a survey up to 2018.
35.6.3.1 Imitation learning by behavior cloning
A natural method is behavior cloning, which reduces IL to supervised learning; see [Pom89] for
an early application to autonomous driving. It interprets a policy as a classifier that maps states
(inputs) to actions (labels), and finds a policy by minimizing the imitation error, such as
min
π
Ep∞πexp
(s)
[DKL (πexp(s) k π(s))] (35.79)
where the expectation wrt p∞
πexp may be approximated by averaging over states in Dexp. A challenge
with this method is that the loss does not consider the sequential nature of IL: future state distribution
is not fixed but instead depends on earlier actions. Therefore, if we learn a policy πˆ that has a low
imitation error under distribution p∞
πexp
, as defined in Equation (35.79), it may still incur a large
error under distribution p∞
πˆ
(when the policy πˆ is actually run). Further expert demonstrations or
algorithmic augmentations are often needed to handle the distribution mismatch (see e.g., [DLM09;
RGB11]).
35.6.3.2 Imitation learning by inverse reinforcement learning
An effective approach to IL is inverse reinforcement learning (IRL) or inverse optimal control
(IOC). Here, we first infer a reward function that “explains” the observed expert trajectories, and
then compute a (near-)optimal policy against this learned reward using any standard RL algorithms
studied in earlier sections. The key step of reward learning (from expert trajectories) is the opposite
of standard RL, thus called inverse RL [NR00a].
It is clear that there are infinitely many reward functions for which the expert policy is optimal,
for example by several optimality-preserving transformations [NHR99]. To address this challenge,
we can follow the maximum entropy principle (Section 2.4.7), and use an energy-based probability
model to capture how expert trajectories are generated [Zie+08]:
p(τ ) ∝ exp ￾
T
X−1
t=0
Rθ(st, at)

(35.80)
where Rθ is an unknown reward function with parameter θ. Abusing notation slightly, we denote
by Rθ(τ ) = PT −1
t=0 Rθ(st, at)) the cumulative reward along the trajectory τ . This model assigns
exponentially small probabilities to trajectories with lower cumulative rewards. The partition function,
Zθ ,
R
τ
exp(Rθ(τ )), is in general intractable to compute, and must be approximated. Here, we can
take a sample-based approach. Let Dexp and D be the sets of trajectories generated by an expert, and
by some known distribution q, respectively. We may infer θ by maximizing the likelihood, p(Dexp|θ),
or equivalently, minimizing the negative log-likelihood loss
L(θ) = −
1
|Dexp|
X
τ∈Dexp
Rθ(τ ) + log 1
|D|
X
τ∈D
exp(Rθ(τ ))
q(τ )
(35.81)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens1172
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The term inside the log of the loss is an importance sampling estimate of Z that is unbiased as long
as q(τ ) > 0 for all τ . However, in order to reduce the variance, we can choose q adaptively as θ is
being updated. The optimal sampling distribution (Section 11.5), q∗(τ ) ∝ exp(Rθ(τ )), is hard to
obtain. Instead, we may find a policy πˆ which induces a distribution that is close to q∗, for instance,
using methods of maximum entropy RL discussed in Section 35.6.1. Interestingly, the process above
produces the inferred reward Rθ as well as an approximate optimal policy πˆ. This approach is used
by guided cost learning [FLA16], and found effective in robotics applications.
35.6.3.3 Imitation learning by divergence minimization
We now discuss a different, but related, approach to IL. Recall that the reward function depends
only on the state and action in an MDP. It implies that if we can find a policy π, so that p∞
π
(s, a)
and p∞
πexp
(s, a) are close, then π receives similar long-term reward as πexp, and is a good imitation of
πexp in this regard. A number of IL algorithms find π by minimizing the divergence between p∞
π and
p∞
πexp
. We will largely follow the exposition of [GZG19]; see [Ke+19b] for a similar derivation.
Let f be a convex function, and Df the f-divergence (Section 2.7.1). From the above intuition, we
want to minimize Df

p∞
πexp


p∞
π

. Then, using a variational approximation of Df
[NWJ10a], we can
solve the following optimization problem for π:
min
π
max
w
Ep∞πexp
(s,a)
[Tw(s, a)] − Ep∞π (s,a)
[f
∗
(Tw(s, a))] (35.82)
where Tw : S × A → R is a function parameterizd by w. The first expectation can be estimated
using Dexp, as in behavior cloning, and the second can be estimated using trajectories generated by
policy π. Furthermore, to implement this algorithm, we often use a parametric policy representation
πθ, and then perform stochastic gradient updates to find a saddle-point to Equation (35.82).
With different choices of the convex function f, we can obtain many existing IL algorithms,
such as generative adversarial imitation learning (GAIL) [HE16b] and adversarial inverse
RL (AIRL) [FLL18], as well as new algorithms like f-divergence max-ent IRL (f-MAX) and
forward adversarial inverse RL (FAIRL) [GZG19; Ke+19b].
Finally, the algorithms above typically require running the learned policy π to approximate the
second expectation in Equation (35.82). In risk- or cost-sensitive scenarios, collecting more data is not
always possible, Instead, we are in the off-policy IL setting, working with trajectories collected by some
policy other than π. Hence, we need to correct the mismatch between p∞
π and the off-policy trajectory
distribution, for which techniques from Section 35.5 can be used. An example is ValueDICE [KNT20],
which uses a similar distribution correction method of DualDICE (Section 35.5.2).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 202336 Causality
This chapter is written by Victor Veitch and Alex D’Amour.
36.1 Introduction
The bulk of machine learning considers relationships between observed variables with the goal of
summarizing these relationships in a manner that allows predictions on similar data. However, for
many problems, our main interest is to predict how system would change if it were observed under
different conditions. For instance, in healthcare, we are interested in whether a patient will recover
if given a certain treatment (as opposed to whether treatment and recovery are associated in the
observed data). Causal inference addresses how to formalize such problems, determine whether
they can be solved, and, if so, how to solve them. This chapter covers the fundamentals of this
subject. Code examples for the discussed methods are available at https://github.com/vveitch/
causality-tutorials. For more information on the connections between ML and causal inference,
see e.g., [Kad+22; Xia+21a].
To make the gap between observed data modeling and causal inference concrete, consider the
relationships depicted in Figure 36.1a and Figure 36.1b. Figure 36.1a shows the relationship between
deaths by drowning and ice cream production in the United States in 1931 (the pattern holds across
most years). Figure 36.1b shows the relationship between smoking and lung cancer across various
countries. In each case, there is a strong positive association. Faced with this association, we might
ask: could we reduce drowning deaths by banning ice cream? Could we reduce lung cancer by
banning cigarettes? We intuitively understand that these interventional questions have different
answers, despite the fact that the observed associations are similar. Determining the causal effect of
some intervention in the world requires some such causal hypothesis about the world.
For concreteness, consider three possible explanations for the association between ice cream and
drowning. Perhaps eating ice cream does cause people to drown — due to stomach cramps or similar.
Or, perhaps, drownings increase demand for ice cream — the survivors eat huge quantities of ice
cream to handle their grief. Or, the association may be due (at least in part) to a common cause:
warm weather makes people more likely to eat ice cream and more likely to go swimming (and, hence,
to drown). Under all three scenarios, we can observe exactly the same data, but the implications for
an ice cream ban are very different. Hence, answering questions about what will happen under an
intervention requires us to incorporate some causal knowledge of the world — e.g., which of these
scenarios is plausible?
Our goal in this chapter to introduce the essentials of estimating causal effects. The high-level1174
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
National Ice Cream Production, Millions of Gallons
Deaths by Accidental Drowning Nationally
0
200
400
600
800
65 70 75 80 85 90
Ice Cream Production and Deaths By Drowning in USA, 2020
(a) (b)
Figure 36.1: Correlation is not causation. (a) Ice cream production is strongly associated with deaths
by drowning. Ice cream production data from the US Department of Agriculture National Agricultural
Statistics Service. Drowning data from the National Center for Health Statistics at the United States Centers
for Disease Control. (b) Smoking is strongly associated with lung cancer. From ourworldindata. org/
smoking-big-problem-in-brief . Used with kind permission of Max Roser.
approach has three steps.
• Causal estimands: The first step is to formally define the quantities we want to estimate. These
are summaries of how the world would change under intervention, rather than summaries of
the world as it has already been observed. E.g., we want to formalize “The expected number of
drownings in the United States if we ban ice cream”.
• Identification: The next step is to identify the causal estimands with quantities that can, in
principle, be estimated from observational data. This step involves codifying our causal knowledge
of the world and translating this into a statement such as, “The causal effect is equal to the
expected number of drownings after adjusting for month”. This step tells us what causal questions
we could answer with perfect knowledge of the observed data distribution.
• Estimation: Finally, we must estimate the observable quantity using a finite data sample. The
form of causal estimands favors certain efficient estimation procedures that allow us to exploit
non-parametric (e.g., machine learning) predictive models.
In this chapter, we’ll mainly focus on the estimation of the causal effect of an intervention averaged
over all members of a population, known as the average treatment effect or ATE. This is the
most common problem in applied causal inference work. It is in some sense the simplest problem,
and will allow us to concretely explain the use and importance of the fundamental causal concepts.
These causal concepts include structural causal models, causal graphical models, the do-calculus, and
efficient estimation using influence function techniques. This problem is also useful for understanding
the role that standard predictive modeling and machine learning play in estimating causal quantities.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.2. CAUSAL FORMALISM
36.2 Causal formalism
In causal inference, the goal is to use data to learn about how the outcome in the world would change
under intervention. In order to make such inferences, we must also make use of our causal knowledge
of the world. This requires a formalism that lets us make the notion of intervention precise and lets
us encode our causal knowledge as assumptions.
36.2.1 Structural causal models
Consider a setting in which we observe four variables from a population of people: Ai
, an indicator
of whether or not person i smoked at a particular age, Yi
, an indicator of whether or not person i
developed lung cancer at a later age, Hi
, a “health consciousness” index that measures a person’s
health-consciousness (perhaps constructed from a set of survey responses about attitudes towards
health), and Gi
, an indicator for whether the person has a genetic predisposition towards cancer.
Suppose we observe a dataset of these variables drawn independently and identically from a population,
(Ai
, Yi
, Hi)
iid∼ P
obs, where “obs” stands for “observed”.
In standard practice, we model data like these using probabilistic models. Notably, there are many
different ways to specify a probabilistic model for the same observed distribution. For example, we
could write a probabilistic model for P
obs as
A ∼ P
obs(A) (36.1)
H|A ∼ P
obs(H|A) (36.2)
Y |A, H ∼ P
obs(Y |H, A) (36.3)
G|A, H, Y ∼ P
obs(G|A, H, Y ) (36.4)
This is a valid factorization, and sampling variables in this order would yield valid samples from the
joint distribution P
obs. However, this factorization does not map well to a mechanistic understanding
of how these variables are causally related in the world. In particular, it is perhaps more plausible
that health-consciousness H causally precedes smoking status A, since a person’s health-consciousness
would influence their decision to smoke.
These intuitions about causal ordering are intimately tied to the notion of intervention. Here,
we will focus on a notion of intervention that can be represented in terms of “structural” models
that describe mechanistic relationships between variables. The fundamental objects that we will
reason about are structural causal models, or SCM’s. SCM’s resemble probabilistic models, but
they encode additional assumptions (see also Section 4.7). Specifically, SCM’s serve two purposes:
they describe a probabilistic model and they provide semantics for transforming the data-generating
process through intervention.
Formally, SCM’s describe a mechanistic data generating process with an ordered sequence of
equations that resemble assignment operations in a program. Each variable in a system is determined
by combining other modeled variables (the causes) with exogenous “noise” according to some
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1176
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
(unknown) deterministic function. For instance, a plausible SCM for P
obs might be
G ← fG(ξ0) (36.5)
H ← fH(ξ1) (36.6)
A ← fA(H, ξ2) (36.7)
Y ← fY (G, H, A, ξ3) (36.8)
where the (unknown) functions f are fixed, and the variables ξ are unmeasured causes, modeled
as independent random “noise” variables. Conceptually, the functions fG, fH, fA, fY describe deter￾ministic physical relationships in the real world, while the variables ξ are hidden causes that are
sufficient to distinguish each unit i in the population. Because we assume that each observed unit i
is drawn at random from the population, we model ξ as random noise.
SCM’s imply probabilistic models, but not the other way around. For example, our example SCM
implies probabilistic model for the observed data based on the factorization P
obs(G, H, A, Y ) =
P
obs(G)P
obs(H)P
obs(A | H)P
obs(Y | A, H). Thus, we could sample from the SCM in the same way
we would from a probabilistic model: draw a set of noise variables ξ and evaluate each assignment
operation in the SCM in order.
Beyond the probabilistic model, an SCM encodes additional assumptions about the effects of
interventions. This can be formalized using the do-calculus (as in the verb “to do”), which
we describe in Section 36.8; But in brief, interventions are represented by replacing assignment
statements. For example, if we were interested in the distribution of Y in the hypothetical scenario
that smoking were eliminated, we could set the second line of the SCM to be A ← 0. We would
denote this by P(Y |do(A = 0), H). Because the f functions in the SCM are assumed to be invariant
mechanistic relationships, the SCM encodes the assumption that this edited SCM generates data that
we would see if we really applied this intervention in the world. Thus, the ordering of statements
in an SCM are load-bearing: they imply substantive assumptions about how the world changes in
response to interventions. This is in contrast to more standard probabilistic models where variables
can be rearranged by applications of Bayes’ Rule without changing the substantive implications of
the model. (See also Section 4.7.3.)
We note that structural causal model may not incorporate all possible notions of causality. For
example, laws based on conserved quantities or equilibria — e.g., the ideal gas law — do not
trivially map to SCMs, though these are fundamental in disciplines such as physics and economics.
Nonetheless, we will confine our discussion to SCMs.
36.2.2 Causal DAGs
SCM’s encode many details about the assumed generative process of a system, but often it is useful
to reason about causal problems at a higher level of abstraction. In particular, it is often useful
to separate the causal structure of a problem from the particular functional form of those causal
relationships. Causal graphs provide this level of abstraction. A causal graph specifies which
variables causally affect other variables, but leaves the parametric form of the structural equations f
unspecified. Given an SCM, the corresponding causal graph can be drawn as follows: for each line
of the SCM, draw arrows from the variables on the right hand side to variables on the left hand
side. The causal DAG for our smoking-cancer example is shown in Figure 36.2. In this way, causal
DAGs are related to SCMs in the same way that probabilistic graphical models (PGMs) are related
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.2. CAUSAL FORMALISM
A Y
H G
(a)
A Y
H G
(b)
Figure 36.2: (a) Causal graph illustrating relationships between smoking A, cancer Y , health conciousness
H, and genetic cancer pre-disposition G. (b) “Mutilated” causal graph illustrating relationships under an
intervention on smoking A.
to probabilistic models.
In fact, in the same way that SCMs imply a probabilistic model, causal DAGs imply a PGM.
Functionally, causal graphs behave as probabilistic graphical models (Chapter 4). They imply
conditional independence relationships between the variables in the observed data in same way. They
obey the Markov property: If X ← Y → Z then X ⊥⊥ Z|Y ; recall d-separation (Section 4.2.4.1).
Additionally, if X → Y ← Z then, usually, X 6⊥⊥ Z|Y (even if X and Z are marginally independent).
In this case, Y is called a collider for X and Z.
Conceptually, the difference between causal DAGs and PGMs is that probabilistic graphical models
encode our assumptions about statistical relationships, whereas causal graphs encode our (stronger)
assumptions about causal relationships. Such causal relationships can be used to derive how statistical
relationships would change under intervention.
Causal graphs also allow us to reason about the causal and non-causal origins of statistical
dependencies in observed data without specifying a full SCM. In a causal graph, two variables — say,
A and D — can be statistically associated in different ways. First, there can be a directed path
from (ancestor) A to (descendant) D. In this case, A is a causal ancestor of D and interventions
on A will propagate through to change D; P(D|do(A = a)) 6= P(D|do(A = a
′
)). For example,
smoking is a causal ancestor of cancer in our example. Alternatively, A and D could share a common
cause — there is some variable C such that there is a directed path from C to A and from C to D.
If A and D are associated only through such a path then interventions on A will not change the
distribution of D. However, it is still the case that P(D|A = a) 6= P(D|A = a
′
) — observing different
values of A changes our guess for the value of D. The reason is that A carries information about
C, which carries information about D. For example, suppose we lived in a world where there was
no effect of smoking on developing cancer (e.g., everybody vapes), there would nevertheless be an
association between smoking and cancer because of the path A ← H → Y . The existence of such
“backdoor paths” is one core reason that statistical and causal association are not the same. Of
course, more complicated variants of these associations are possible — e.g., C is itself only associated
with A through a backdoor path — but this already captures the key distinction between causal and
non-causal paths.
Recall that our aim in introducing SCMs and causal graphs is to enable us to formalize our causal
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1178
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
knowledge of the world and to make precise what interventional quantities we’d like to estimate.
Writing down a causal graph gives a simple formal way to encode our knowledge of the causal
structure of a problem. Usefully, this causal structure is sufficient to directly reason about the
implications of interventions without fully specifying the underlying SCM. The key observation is that
if a variable A is intervened on then, after intervention, none of the other variables are causes of A.
That is, when we replace a line of an SCM with a statement directly assigning a variable a particular
value, we cut off all dependencies that variable had on its causal parents. Accordingly, in the causal
graph, the intervened on variable has no parents. This leads us to the graph surgery notion of
intervention: an intervention that sets A to a is the operation that deletes all incoming edges to A in
the graph, and then conditions on A = a in the resulting probability distribution (which is defined
by the conditional independence structure of the post-surgery graph). We’ll use Pearl’s do notation
to denote this operation. P(X|do(A = a)) is the distribution of X given A = a under the mutilated
graph that results from deleting all edges going into A. Similarly, E[X|do(A = a)] , EP(X|do(A=a))[X].
Thus, we can formalize statements such as “the average effect of receiving drug A” as
ATE = E[Y |do(A = 1)] − E[Y |do(A = 0)], (36.9)
where ATE stands for average treatment effect.
For concreteness, consider our running example. We contrast the distribution that results by
conditioning on A with the distribution that results from intervening on A:
P(Y, H, G|A = a) = P(Y |H, G, A = a)P(G)P(H|A = a) (36.10)
P(Y, H, G|do(A = a)) = P(Y |H, G, A = a)P(G)P(H) (36.11)
The key difference between these two distributions is that the standard conditional distribution
describes a population where health consciousness H has the distribution that we observe among
individuals with smoking status A = a, while the interventional distribution described a population
where health consciousness H follows the marginal distribution among all individuals. For example,
we would expect P(H | A = smoker) to put more mass on lower values of H than the marginal
health consciousness distribution than the marginal distribution P(H), which would also include
non-smokers. The intervention distribution thus incorporates a hypothesis of how smoking would
affect the subpopulation individuals who tend to be too health conscious to smoke in the observed
data.
36.2.3 Identification
A central challenge in causal inference is that many different SCM’s can produce identical distributions
of observed data. This means that, on the basis of observed data alone, we cannot uniquely identify
the SCM that generated it. This is true no matter how large of a data sample is available to us.
For example, consider the setting where there is a treatment A that may or may not have an
effect on outcome Y , and where both the treatment and outcome are known to be affected by
some unobserved common binary cause U. Now, we might be interested in the causal estimand
E[Y |do(A = 1)]. In general, we can’t learn this quantity from the observed data. The problem
is that, we can’t tell apart the case where the treatment has a strong effect from the case where
the treatment has no effect, but U = 1 both causes people to tend to be treated and increases the
probability of a positive outcome. The same observation shows we can’t learn the (more complicated)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.2. CAUSAL FORMALISM
interventional distribution P(Y |do(A = 1)) (if we could learn this, then we’d get the average effect
automatically).
Thus, an important part of causal inference is to augment the observed data with knowledge about
the underlying causal structure of the process under consideration. Often, these assumptions can
narrow the space of SCM’s sufficiently so that there is only one value of the causal estimand that is
compatible with the observed data. We say that the causal estimand is identified or identifiable
under a given set of assumptions if those assumptions are sufficient to provide a unique answer.
There are many different sets of sufficient conditions that yield identifiable causal effects; we call
each set of sufficient conditions an identification strategy.
Given a set of assumptions about the underlying SCM, the most common way to show that a
causal estimand is identified is by construction. Specifically, if the causal estimand can be written
entirely in terms of observable probability distributions, then it is identifed. We call such a function of
observed distributions a statistical estimand. Once such a statistical estimand has been recovered,
we can then construct and analyze an estimator for that quantity using standard statistical tools.
As an example of a statistical estimand, in the SCM above, it can be shown the ATE as defined in
Equation (36.9), is equal to the following statistical estimand
ATE (∗)
= τ
ATE , E[E[Y |H, A = 1] − E[Y |H, A = 0]], (36.12)
where the equality (∗) only holds because of some specific properties of the SCM. Note that the RHS
above only involves conditional expectations between observed variables (there are no do operators),
so τ
ATE is only a function of observable probability distributions.
There are many kinds of assumptions we might make about the SCM governing the process under
consideration. For example, the following are assertions we might make about the system in our
running example:
1. The probability of developing cancer is additive on the logit scale in A, G, and H (i.e., logistic
regression is a well-specified model).
2. For each individual, smoking can never decrease the probability of developing cancer.
3. Whether someone smokes is influenced by their health consciousness H, but not by their genetic
predisposition to cancer G.
These assumptions range from strong parametric assumptions fully specifying the form of the SCM
equations, to non-parametric assumptions that only specify what the inputs to each equation are,
leaving the form fully unspecified. Typically, assumptions that fully specify the parametric form are
very strong, and would require far more detailed knowledge of the system under consideration than
we actually have. The goal in identification arguments is to find a set of assumptions that are weak
enough that they might be plausibly true for the system under consideration, but which are also
strong enough to allow for identification of the causal effect.
If we are not willing to make any assumptions about the functional form of the SCM, then our
assumptions are just about which variables affect (and do not affect) the other variables. In this sense,
such which-affects-which assumptions are minimal. These assumptions are exactly the assumptions
captured by writing down a (possibly incomplete) causal DAG, showing which variables are parents
of each other variable. The graph may be incomplete because we may not know whether each possible
edge is present in the physical system. For example, we might be unsure whether the gene G actually
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1180
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
has a causal effect on health consciousness H. It is natural to ask to what extent we can identify
causal effects only on the basis of partially specified causal DAGs. It turns out much progress can be
made based on such non-parametric assumptions; we discuss this in detail in Section 36.8.
We will also discuss certain assumptions that cannot be encoded in a causal graph, but that are
still weaker than assuming that full functional forms are known. For example, we might assume that
the outcome is affected additively by the treatment and any confounders, with no interaction terms
between them. These weaker assumptions can enable causal identification even when assuming the
causal graph alone does not.
It is worth emphasizing that every causal identification strategy relies on assumptions that have
some content that cannot be validated in the observed data. This follows directly from the ill-posedness
of causal problems: if the assumptions used to identify causal quantities could be validated, that
would imply that the causal estimand was identifiable from the observed data alone. However, since
we know that there are many values of the causal estimand that are compatible with observed data,
it follows that the assumptions in our identification strategy must have unobservable implications.
36.2.4 Counterfactuals and the causal hierarchy
Structural causal models let us formalize and study a hierarchy of different kinds of query about the
system under consideration. The most familiar is observational queries: questions that are purely
about statistical associations (e.g., “Are smoking and lung cancer associated in the population this
sample was drawn from?”). Next is interventional queries: questions about causal relationships at
the population level (e.g., “How much does smoking increase the probability of cancer in a given
population?”). The rest of this chapter is focused on the defintion, identification, and estimation of
interventional queries. Finally, there are counterfactual queries: questions about causal relationships
at the level of specific individuals, had something been different (e.g., “Would Alice have developed
cancer had she not smoked?”). This causal hierarchy was popularized by [Pea09a, Ch. 1].
Interventional queries concern the prospective effect of an intervention on an outcome; for
example, if we intervene and prevent a randomly sampled individual from smoking, what is the
probability they develop lung cancer? Ultimately, the probability statement here is about our
uncertainity about the “noise” variables ξ in the SCM. These are the unmeasured factors specific to
the randomly selected individual. The distribution is determined by the population from which that
individual is sampled. Thus, interventional queries are statements about populations. Interventional
queries can be written in terms of conditional distributions using do-notation, e.g., P(Y |do(A = 0)).
In our example, this represents the distribution of lung cancer outcomes for an individual selected at
random and prevented from smoking.
Counterfactual queries concern how an observed outcome might have been different had an
intervention been applied in the past. Counterfactual queries are often framed in terms of attributing
a given outcome to a particular cause. For example, would Alice have developed cancer had she not
smoked? Did most smokers with lung cancer develop cancer because they smoked? Counterfactual
queries are so called because they require a comparison of counterfactual outcomes within individuals.
In the formalism of SCM’s, counterfactual outcomes for an individual i are generated by running the
same values of ξi through differently intervened SCMs. Counterfactual outcomes are often written in
terms of potential outcomes notation. In our running smoking example, this would look like:
Yi(a) , fY (Gi
, Hi
, a, ξ3,i). (36.13)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.2. CAUSAL FORMALISM
That is, Yi(a) is the outcome we would have seen had A been set to a while all of Gi
, Hi
, ξ3,i were
kept fixed.
It is important to understand what distinguishes interventional and fundamentally counterfactual
queries. Just because a query can be written in terms of potential outcomes does not make it a
counterfactual query. For example, the average treatment effect, which is the canonical interventional
query, is easy to write in potential outcomes notation:
ATE = E[Yi(1) − Yi(0)]. (36.14)
Instead, the key dividing line between counterfactual and interventional queries is whether the query
requires knowing the joint distribution of potential outcomes within individuals, or whether marginal
distributions of potential outcomes across individuals will suffice. An important signature of a
counterfactual query is conditioning on the value of one potential outcome. For example, “the lung
cancer rate among smokers who developed cancer, had they not smoked” is a counterfactual query,
and can be written as:
E[Yi(0) | Yi(1) = 1, Ai = 1] (36.15)
Answering this query requires knowing how individual-level cancer outcomes are related (through
ξ3,i) across the worlds where the each individual i did and did not smoke. Notably, this query cannot
be rewritten using do-notation, because it requires a distinction between Y (0) and Y (1) while the
ATE can: E[Y | do(A = 1)] − E[Y | do(A = 0)].
Counterfactual queries require categorically more assumptions for identification than interventional
ones. For identifying interventional queries, knowing the DAG structure of an SCM is often sufficient,
while for counterfactual queries, some assumptions about the functional forms in the SCM are
necessary. This is because only one potential outcome is ever observed for each individual, so the
dependence between potential outcomes within individuals is not observable. For example, the data
in our running example provide no information on how individual-level smoking and non-smoking
cancer risk are related. Thus, answering a question like “Did smokers who developed cancer have lower
non-smoking cancer risk than smokers who did not develop cancer?”, requires additional assumptions
about how characteristics encoded in ξi are translated to cancer outcomes. To answer this question
without such assumptions, we would need to observe smokers who developed cancer in the alternate
world where they did not smoke. Because they compare how individuals would have turned out under
different generating processes, counterfactual queries are often referred to as “cross-world” quantities.
On the other hand, interventional queries only require understanding the marginal distributions of
potential outcomes Yi(0) and Yi(1) across individuals; thus, no cross-world information is necessary
at the individual level.
We conclude this section by noting that counterfactual outcomes and potential outcomes notation
are often conceptually useful, even if they are not used to explicitly answer counterfactual queries.
Many causal queries are more intuitive to formalize in terms of potential outcomes. E.g., “Would I
have smoked if I was more health conscious?” may be more intuitive than “Would a randomly sampled
individual from the same population have smoked had they been subject to an intervention that made
them more health concious?”. In fact, some schools of causal inference use potential outcomes, rather
than DAGs, as their primary conceptual building block [See IR15]. Causal graphs and potential
outcomes both provide ways to formulate interventional queries and causal assumptions. Ultimately,
these are mathematically equivalent. Nevertheless, practically, they have different strengths. The
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1182
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
main advantage of potential outcomes is that counterfactual statements often map more directly to
our mechanistic understanding of the world. This can make it easier to articulate causal desiderata
and causal assumptions we may wish to use. On the other hand, the potential outcomes notation
does not automatically distinguish between interventional and counterfactual queries. Additionally,
causal graphs often give an intuitive and easy way of articulating assumptions about structural
causal models involving many variables—potential outcomes get quickly unwieldly. In short: both
formalizations have distinct advantages, and those advantages are simply about how easy it is to
translate our causal understanding of the world into crisp mathematical assumptions.
36.3 Randomized control trials
We now turn to the business of estimating causal effects from data. We begin with randomized
control trials, which are experiments designed to make the causal concerns as simple as possible.
The simplest situation for causal estimation is when there are no common causes of A and Y . The
world is rarely so obliging as to make this the case. However, sometimes we can design an experiment
to enforce the no-common-causes structure. In randomized control trials we assign each participant
to either the treatment or control group at random. Because random assignment does not depend on
any property of the units in the study, there are no causes of treatment assignment, and hence also
no common causes of Y and A.
In this case, it’s straightforward to see that P(Y |do(A = a) = P(Y |a). This is essentially by
definition of the graph surgery: since A has no parents, the mutilated graph is the same as the original
graph. Indeed, the graph surgery definition is chosen to make this true: any sensible formalization of
causality should have this identification result.
It is common to use RCTs to study the average treatment effect,
ATE = E[Y |do(A = 1)] − E[Y |do(A = 0)]. (36.16)
This is the expected difference between being assigned treatment and assigned no treatment for a
randomly chosen member of the population. It’s easy to see that in an RCT this causal quantity is
identified as a parameter τ
RCT of the observational distribution:
τ
RCT = E[Y |A = 1] − E[Y |A = 0].
Then, a natural estimator is:
τˆ
RCT ,
1
nA
X
i:Ai=1
Yi −
1
n − nA
X
i:Ai=0
Yi
, (36.17)
where nA is the number of units who received treatment. That is, we estimate the average treatment
effect as the difference between the average outcome of the treated group and the average outcome of
the untreated (control) group.1
Randomized control trials are the gold standard for estimating causal effects. This is because we
know by design that there are no confounders that can produce alternative causal explanations of the
1. There is a literature on efficient estimation of causal effects in RCT’s going back to Fisher [Fis25] that employ more
sophisticated estimators. See also Lin [Lin13a] and Bloniarz et al. [Blo+16] for more modern treatments.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.4. CONFOUNDER ADJUSTMENT
A Y
X
Figure 36.3: A causal DAG illustrating a situation where treatment A and outcome Y are both influenced by
observed confounders X.
data. In particular, the assumption of the triangle DAG—there are no unobserved confounders—is
enforced by design. However, there are limitations. Most obviously, randomized control trials are
sometimes infeasible to conduct. This could be due to expense, regulatory restrictions, or more
fundamental difficulties (e.g., in developmental economics, the response of interest is sometimes
collected decades after treatment). Additionally, it may be difficult to ensure that the participants in
an RCT are representative of the population where the treatment will be deployed. For instance,
participants in drug trials may skew younger and poorer than the population of patients who will
ultimately take the drug.
36.4 Confounder adjustment
We now turn to the problem of estimating causal effects using observational (i.e., not experimental)
data. The most common application of causal inference is estimating the average treatment effect
(ATE) of an intervention. The ATE is also commonly called the average causal effect, or ACE.
Here, we focus on the important special case where the treatment A is binary, and we observe the
outcome Y as well as a set of common causes X that influence both A and Y .
36.4.1 Causal estimand, statistical estimand, and identification
Consider a problem where we observe treatment A, outcome Y , and covariates X, which are drawn
iid from some unknown distribution P. We wish to learn the average treatment effect: the expected
difference between being assigned treatment and assigned no treatment for a randomly chosen member
of the population. Following the discussion in the introduction, there are three steps to learning this
quantity: mathematically formalize the causal estimand, give conditions for the causal estimand to
be identified as a statistical estimand, and, finally, estimate this statistical estimand from data. We
now turn to the first two steps.
The average treatment effect is defined to be the difference between the average outcome if we
intervened and set A to be 0, versus the average outcome if we intervented and set A to be 1. Using
the do notation, we can write this formally as
ATE = E[Y |do(A = 1)] − E[Y |do(A = 0)]. (36.18)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1184
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The next step is to articulate sufficient conditions for the ATE to be identified as a statistical
estimand (a parameter of distribution P). The key issue is the possible presence of confounders.
Confounders are “common cause” variables that affect both the treatment and outcome. When there
are confounding variables in observed data, the sub-population of people who are observed to have
received one level of the treatment A will differ from the rest of the population in ways that are
relevant to their observed Y . For example, there is a strong positive association between horseback
riding in childhood (treatment) and healthiness as an adult (outcome) [RB16]. However, both of
these quantities are influenced by wealth X. The population of people who rode horses as children
(A = 1) is wealthier than the population of people who did not. Accordingly, the horseback-riding
population will have better health outcomes even if there is no actual causal benefit of horseback
riding for adult health.
We’ll express the assumptions required for causal identification in the form of a causal DAG.
Namely, we consider the simple triangle DAG in Figure 36.3, where the treatment and outcome
are influenced by observed confounders X. It turns out that the assumption encoded by this DAG
suffices for identification. To understand why this is so, recall that the target causal effect is defined
according to the distribution we would see if the edge from X to A was removed (that’s the meaning
of do). The key insight is that because the intervention only modifies the relationship between X
and A, the structural equation that generates outcomes Y given X and A, illustrated in Figure 36.3
as the A → Y ← X, is the same even after the X → Y edge is removed. For example, we might
believe that the physiological processes by which smoking status A and confounders X produce
lung cancer Y remain the same, regardless of how the decision to smoke or not smoke was made.
Second, because the intervention does not change the composition of the population, we would also
expect the distribution of background characteristics X to be the same between the observational
and intervened processes.
With these insights about invariances between observed and interventional data, we can derive a
statistical estimand for the ATE as follows.
Theorem 2 (Adjustment with no unobserved confounders). We observe A, Y, X ∼ P. Suppose
that
1. (Confounders observed) The data obeys the causal structure in Figure 36.3. In particular, X
contains all common causes of A and Y and no variable in X is caused by A or Y .
2. (Overlap) 0 < P(A = 1|X = x) < 1 for all values of x. That is, there are no individuals for whom
treatment is always or never assigned.
Then, the average treatment effect is identified as ATE = τ , where
τ = E[E[Y |A = 1, X]] − E[E[Y |A = 0, X]]. (36.19)
Proof. First, we expand the ATE using the tower property of expectation, conditioning on X. Then,
we apply the invariances discussed above:
AT E = E[Y |do(A = 1)] − E[Y |do(A = 0)] (36.20)
= E[E[Y |do(A = 1), X]] − E[E[Y |do(A = 0), X]] (36.21)
= E[E[Y |A = 1, X]] − E[E[Y |A = 0, X]] (36.22)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.4. CONFOUNDER ADJUSTMENT
The final equality is the key to passing from a causal to observational quantity. This follows because,
from the causal graph, the conditional distribution of Y given A, X is the same in both the original
graph and in the mutilated graph created by removing the edge from X to A. This mutilated graph
defines P(Y |do(A = 1), X), so the equality holds.
The condition that 0 < P(A = 1|X = x) < 1 is required for the first equality (the tower property)
to be well defined.
Note that Equation (36.19) is a function of only conditional expectations and distributions that
appear in the observed data distribution (in particular, it contains no “do” operators). Thus, if we
can fully characterize the observed data distribution P, we can map that distribution to a unique
ATE.
It is useful to note how τ differs from the naive estimand E[Y |A = 1] − E[Y |A = 0] that just
reports the treatment-outcome association without adjusting for confounding. The comparison is
especially clear when we write out the outer expectation in τ explicitly as an integral over X:
τ =
Z
E[Y | A = 1, X]P(X)dX −
Z
E[Y | A = 0, X]P(X)dX (36.23)
We can write the naive estimand in a similar form by applying the tower property of expectation:
E[Y | A = 1]−E[Y | A = 0] = Z
E[Y | A = 1, X]P(X | A = 1)dX−
Z
E[Y | A = 0, X]P(X | A = 0)dX
(36.24)
The key difference is the probability distribuiton over X that is being integrated over. The observa￾tional difference in means integrates over the distinct conditional distributions of confounders X,
depending on the value of A. On the other hand, in the ATE estimand τ , we integrate over the same
distribution P(X) for both levels of the treatment.
Overlap In addition to the assumption on the causal structure, identification requires that there is
sufficient random variation in how treatments are assigned.
Definition 1. A distribution P on A, X satisfies overlap if 0 < P(A = 1|x) < 1 for all x. It
satisfies strict overlap if ǫ < P(A = 1|x) < 1 − ǫ for all x and some ǫ > 0.
Overlap is the requirement that any unit could have either recieved the treatment or not.
To see the necessity of overlap, consider estimating the effectiveness of a drug in a study where
patient sex is a confounder, but the drug was only ever prescribed to male patients. Then, conditional
on a patient being female, we would know that patient was assigned to control. Without further
assumptions, it’s impossible to know the effect of the drug on a population with female patients,
because there would be no data to inform the expected outcome for treated female patients, that
is, E[Y | A = 1, X = female]. In this case, the statistical estimand equation 36.19 would not be
identifiable. In the same vein, strict overlap ensures that the conditional distributions at each stratum
of X can be estimated in finite samples.
Overlap can be particularly limiting in settings where we are adjusting for a large number of
covariates (in an effort to satisfy no unobserved confounding). Then, certain combinations of traits
may be very highly predictive of treatment assignment, even if individual traits are not. E.g., male
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1186
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
patients over age 70 with BMI greater than 25 are very rarely assigned the drug. If such groups
represent a significant fraction of the target population, or have significantly different treatment
effects, then this issue can be problematic. In this case, the strict overlap assumption puts very strong
restrictions on observational studies: for an observational study to satisfy overlap, most dimensions
of the confounders X would need to closely mimic the balance we would expect in an RCT [D’A+21].
36.4.2 ATE estimation with observed confounders
We now return to estimating the ATE using observed — i.e., not experimental — data. We’ve shown
that in the case where we observe all common causes of the treatment and outcome, the ATE is
causally identified with a statistical estimand τ . We now consider several strategies for estimating this
quantity using a finite data sample. Broadly, these techniques are known as backdoor adjustment.2
Recall that the defining characteristic of a confounding variable is that it affects both treatment
and outcome. Thus, an adjustment strategy may aim to account for the influence of confounders on
the observed outcome, the influence of confounders on treatment, or both. We discuss each of these
strategies in turn.
36.4.2.1 Outcome model adjustment
We begin with an approach to covariate adjustment that relies on modeling the conditional expectation
of the outcome Y given treatment A and confounders X. This strategy is often referred to as g￾computation or outcome adjustment.3 To begin, we define
Definition 2. The conditional expected outcome is the function Q given by
Q(a, x) = E[Y |A = a, X = x]. (36.25)
Substituting this definition into the definition of our estimand τ , Equation (36.19), we have
τ = E[Q(1, x) − Q(0, x)]. This suggests a procedure for estimating τ : fit a model Qˆ for Q and then
report
τˆ
Q ,
1
n
X
i
Qˆ(1, xi) − Qˆ(0, xi). (36.26)
To fit Qˆ, recall that E[Y |a, x] = argminQ E[(Y − Q(A, X)
2
]. That is, the minimizer (among all
functions) of the squared loss risk is the conditional expected outcome.4 So, to approximate Q, we
simply use mean squared error to fit a predictor that predicts Y from A and X.
The estimation procedure takes several steps. We first fit a model Qˆ to predict Y . Then, for each
unit i, we predict that unit’s outcome had they received treatment Qˆ(1, xi) and we predict their
outcome had they not received treatment Qˆ(0, xi).
5
If the unit actually did receive treatment (ai = 1)
2. As we discuss in Section 36.8, this backdoor adjustment references the estimand returned by the do-calculus to
eliminate confounding from a backdoor path. This also generalizes the approaches discussed here to some cases where
we do not observe all common causes.
3. The “g” stands for generalized, for now-inscrutable historical reasons [Rob86].
4. To be precise, this definition applies when X and Y are square-integrable, and the minimzation taken over measurable
functions.
5. This interpretation is justified by the same conditions as Theorem 2.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.4. CONFOUNDER ADJUSTMENT
then Qˆ(0, xi) is our guess about what would have happened in the counterfactual case that they
did not. The estimated expected gain from treatment for this individual is Qˆ(1, xi) − Qˆ(0, xi)—the
difference in expected outcome between being treated and not treated. Finally, we estimate the outer
expectation with respect to P(X) — the true population distribution of the confounders — using the
empirical distribution P( ˆ X) = 1/nP
i
δxi
. In effect, this means we substitute the expectation (over
an unknown distribution) by an average over the observed data.
Linear regression It’s worth saying something more about the special case where Q is modeled
as a linear function of both the treatment and all the covariates. That is, the case where we assume
the identification conditions of Theorem 2 and we additionally assume that the true, causal law
(the SCM) governing Y yields: Q(A, X) = E[Y |A, X] = E[fY (A, X, ξ)|A, X] = β0 + βAA + βXX.
Plugging in, we see that Q(1, X) − Q(0, X) = βA (and so also τ = βA). Then, the estimator for the
average treatment effect reduces to the estimator for the regression coefficient βA. This “fit linear
regression and report the regression coefficient” remains a common way of estimating the association
between two variables in practice. The expected-outcome-adjustment procedure here may be viewed
as a generalization of this procedure that removes the linear parametric assumption.
36.4.2.2 Propensity Score Adjustment
Outcome model adjustment relies on modeling the relationship between the confounders and the
outcome. A popular alternative is to model the relationship between the confounders and the
treatment. This strategy adjusts for confounding by directly addressing sampling bias in the treated
and control groups. This bias arises from the relationship between the confounders and the treatment.
Intuitively, the effect of confounding may be viewed as due to the difference between P(X|A = 1)
and P(X|A = 0) — e.g., the population of people who rode horses as children is wealthier than the
population of people who did not. When we observe all confounding variables X, this degree of over￾or under-representation can be adjusted away by reweighting samples such that the confounders X
have the same distribution in the treated and control groups. When the confounders are balanced
between the two groups, then any differences between them must be attributable to the treatment.
A key quantity for balancing treatment and control groups is the propensity score, which
summarises the relationship between confounders and treatment.
Definition 3. The propensity score is the function g given by g(x) = P(A = 1|X = x).
To make use of the propensity score in adjustment, we first rewrite the estimand τ in a suggestive
form, leveraging the fact that A ∈ {0, 1}:
τ = E[
Y A
g(X)
−
Y (1 − A)
1 − g(X)
]. (36.27)
This identity can be verified by noting that E[Y A|X] = E[Y |A = 1, X]P(A = 1|X) + 0, rearranging
for E[Y |A = 1, X], doing the same for E[Y |A = 0, X], and substituting in to Equation (36.19). Note
that the identity is just a mathematical fact about the statistical estimand — it does not rely on any
causal assumptions, and holds whether or not τ can be interpreted as a causal effect.
This expression suggests the inverse probability of treatment weighted estimator, or IPTW
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1188
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
estimator:
τˆ
IPTW ,
1
n
X
i
YiAi
gˆ(Xi)
−
Yi(1 − Ai)
1 − gˆ(Xi)
. (36.28)
Here, gˆ is an estimate of the propensity score function. Recall from Section 14.2.1 that if a model is well￾specified and the loss function is a proper scoring rule then risk minimizer g
∗ = argming E[L(A, g(X))]
will be g
∗
(X) = P(A = 1|X). That is, we can estimate the propensity score by fitting a model that
predicts A from X. Cross-entropy and squared loss are both proper scoring rules, so we may use
standard supervised learning methods.
In summary, the procedure is to estimate the propensity score function (with machine learning),
and then to plug the estimated propensity scores gˆ(xi) into Equation (36.28). The IPTW estimator
computes a difference of weighted averages between the treated and untreated group. The effect is to
upweight the outcomes of units who were unlikely to be treated but who nevertheless actually, by
chance, recieved treatment (and similarly for untreated). Intuitively, such units are typical for the
untreated population. So, their outcomes under treatment are informative about what would have
happened had a typical untreated unit received treatment.
A word of warning is in order. Although the IPTW is asymtotically valid and popular in practice,
it can be very unstable in finite samples. If estimated propensity scores are extreme for some values
of x (that is, very close to 0 or 1), then the corresponding IPTW weights can be very large, resulting
in a high-variance estimator. In some cases, this instability can be mitigated by instead using the
Hajek version of the estimator.
τˆ
h−IPTW ,
X
i
YiAi
1/gˆ(Xi)
P
i
Ai/gˆ(Xi)
−
X
i
Yi(1 − Ai)
1/(1−gˆ(Xi))
P
i
(1−Ai)/(1−gˆ(Xi))
. (36.29)
However, extreme weights can persist even after self-normalization, either because there are truly
strata of X where treatment assignment is highly imbalanced, or because the propensity score
estimation method has overfit. In such cases, it is common to apply heuristics such as weight clipping.
See Khan and Ugander [KU21] for a longer discussion of inverse-propensity type estimators,
including some practical improvements.
36.4.2.3 Double machine learning
We have seen how to estimate the average treatment effect using either the relationship between
confounders and outcome, or the relationship between confounders and treatment. In each case,
we follow a two step estimation procedure. First, we fit models for the expected outcome or the
propensity score. Second, we plug these fitted models into a downstream estimator of the effect.
Unsurprisingly, the quality of the estimate of τ depends on the quality of the estimates Qˆ or gˆ. This
is problematic because Q and g may be complex functions that require large numbers of samples to
estimate. Even though we’re only interested in the 1-dimensional parameter τ , the naive estimators
described thus far can have very slow rates of convergence. This leads to unreliable inference or very
large confidence intervals.
Remarkably, there are strategies for combining Q and g in estimators that, in principle, do better
than using either Q or g alone. The augmented inverse probability of treatment weighted
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.4. CONFOUNDER ADJUSTMENT
estimator (AIPTW) is one such estimator. It is defined as
τˆ
AIPTW ,
1
n
X
i
Qˆ(1, Xi) − Qˆ(0, Xi) + Ai
Yi − Qˆ(1, Xi)
gˆ(xi)
− (1 − Ai)
Yi − Qˆ(0, Xi)
1 − gˆ(Xi)
. (36.30)
That is, τˆ
AIPTW is the outcome adjustment estimator plus a stabilization term that depends on
the propensity score. This estimator is a particular case of a broader class of estimators that are
refered to as semi-parametrically efficient or double machine-learning estimators [Che+17e;
Che+17d]. We’ll use the later terminology here.
We now turn to understanding the sense in which double machine learning estimators are robust
to misestimation of the nuisance functions Q and g. To this end, we define the influence curve
of τ to be the function φ defined by6
φ(Xi
, Ai
, Yi
; Q, g, τ ) , Q(1, Xi) − Q(0, Xi) + Ai
Yi − Q(1, Xi)
g(xi)
− (1 − Ai)
Yi − Q(0, Xi)
1 − g(Xi)
− τ.
(36.31)
By design, τˆ
AIPTW − τ =
1
n
P
i
φ(Xi
; Q, ˆ g, τ ˆ ). We begin by considering what would happen if we
simply knew Q and g, and didn’t have to estimate them. In this case, the estimator would be
τˆ
ideal =
1
n
P
i
φ(Xi
; Q, g, τ ) and, by the central limit theorem, we would have:
√
n(ˆτ
ideal − τ )
d
−→ Normal(0, E[φ(Xi
; Q, g, τ )
2
]). (36.32)
This result characterizes the estimation uncertainity in the best possible case. If we knew Q and g,
we could rely on this result for, e.g., finding confidence intervals for our estimate.
The question is: what happens when Q and g need to be estimated? For general estimators and
nuisance function models, we don’t expect the √
n-rate of Equation (36.32) to hold. For instance,
√
n(τˆ
Q − τ ) only converges if √
nE[(Qˆ − Q)
2
]
1
2 → 0. That is, for the naive estimator we only get the
√
n rate for estimating τ if we can also estimate Q at the √
n rate — a much harder task! This is
the issue that the double machine learning estimator helps with.
To understand how, we decompose the error in estimating τ as follows:
√
n(ˆτ
AIPTW − τ ) (36.33)
=
1
√
n
X
i
φ(Xi
; Q, g, τ ) (36.34)
+
1
√
n
X
i
φ(Xi
; Q, ˆ g, ˆ τ ) − φ(Xi
; Q, g, τ ) − E[φ(X; Q, ˆ g, τ ˆ ) − φ(X; Q, g, τ )] (36.35)
+
√
nE[φ(X; Q, ˆ g, ˆ τ ) − φ(X; Q, g, τ )] (36.36)
We recognize the first term, Equation (36.34), as √
n(τˆ
ideal − τ ), the estimation error in the optimal
case where we know Q and g. Ideally, we’d like the error of τˆ
AIPTW to be asymptotically equal to
this ideal case—which will happen if the other two terms go to 0.
6. Influence curves are the foundation of what follows, and the key to generalizing the analysis beyond the ATE.
Unfortunately, going into the general mathematics would require a major digression, so we omit it. However, see
references at the end of the chapter for some pointers to the relevant literature.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1190
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
The second term, Equation (36.35), is a penalty we pay for using the same data to estimate Q, g
and to compute τ . For many model classes, it can be shown that such “empirical process” terms go
to 0. This can also be guaranteed in general by using different data for fitting the nuisance functions
and for computing the estimator (see the next section).
The third term, Equation (36.36), captures the penalty we pay for misestimating the nuisance
functions. This is where the particular form of the AIPTW is key. With a little algebra, we can show
that
E[φ(X; Q, ˆ gˆ) − φ(X; Q, g)] = E[
1
g(X)
(ˆg(X) − g(X))(Qˆ(1, X) − Q(1, X)) (36.37)
+
1
1 − g(X)
(ˆg(X) − g(X))(Qˆ(0, X) − Q(0, X))]. (36.38)
The important point is that estimation errors of Q and g are multiplied together. Using the Cauchy￾Schwarz inequality, we find that √
nE[φ(X; Q, ˆ gˆ) − φ(X; Q, g)] → 0 as long as √
n maxa E[(Qˆ(a, X) −
Q(a, X))2
]
1
2 E[(gˆ(X) − g(X))2
]
1
2 → 0. That is, the misestimation penalty will vanish so long as the
product of the misestimation errors is o(
√
n). For example, this means that τ can be estimated at
the (optimal) √
n rate even when the estimation error of each of Q and g only decreases as o(n
−1/4
).
The upshot here is that the double machine learning estimator has the special property that the
weak condition √
nE(Qˆ(T, X) − Q(T, X))2E(ˆg(X) − g(X))2 → 0 suffices to imply that
√
n(ˆτ
AIPTW − τ )
d
−→ Normal(0, E[φ(Xi
; Q, g, τ )
2
]) (36.39)
(though strictly speaking this requires some additional technical conditions we haven’t discussed).
This is not true for the earlier estimators we discussed, which require a much faster rate of convergence
for the nuisance function estimation.
The AIPTW estimator has two further nice properties that are worth mentioning. First, it is
non-parametrically efficient. This means that this estimator has the smallest possible variance
of any estimator that does not make parametric assumptions; namely, E[φ(Xi
; Q, g, τ )
2
]. This means,
for example, that this estimator yields the smallest confidence intervals of any approach that does not
rely on parametric assumptions. Second, it is doubly robust: the estimator is consistent (converges
to the true τ as n → ∞) as long as at least one of either Qˆ or gˆ is consistent.
36.4.2.4 Cross fitting
The term Equation (36.35) in the error decomposition above is the penalty we pay for reusing the
same data to both fit Q, g and to compute the estimator. For many choices of model for Q, g, this
term goes to 0 quickly as n gets large and we achieve the (best case) √
n error rate. However, this
property doesn’t always hold.
As an alternative, we can always randomly split the available data and use one part for model fitting,
and the other to compute the estimator. Effectively, this means the nuisance function estimation and
estimator computation are done using independent samples. It can then be shown that the reuse
penalty will vanish. However, this comes at the price of reducing the amount of data available for
each of nuisance function estimation and estimator computation.
This strategy can be improved upon by a cross fitting approach. We divide the data into K
folds. For each fold j we use the other K − 1 folds to fit the nuisance function models Qˆ−j
, gˆ
−j
.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.4. CONFOUNDER ADJUSTMENT
Then, for each datapoint i in fold j, we take Qˆ(ai
, xi) = Qˆ−j
(ai
, xi) and gˆ(xi) = gˆ
−j
(xi). That is,
the estimated conditional outcomes and propensity score for each datapoint are predictions from a
model that was not trained on that datapoint. Then, we estimate τ by plugging {Qˆ(ai
, xi), gˆ(xi)}i
into Equation (36.30). It can be shown that this cross fitting procedure has the same asymptotic
guarantee — the central limit theorem at the √
n rate — as described above.
36.4.3 Uncertainty quantification
In addition to the point estimate τˆ of the average treatment effect, we’d also like to report a measure
of the uncertainity in our estimate. For example, in the form of a confidence interval. The asymptotic
normality of √
nτˆ (Equation (36.39)) provides a means for this quantification. Namely, we could
base confidence intervals and similar on the limiting variance E[φ(Xi
; Q, g, τ )
2
]. Of course, we don’t
actually know any of Q, g, or τ . However, it turns out that it suffices to estimate the asymptotic
variance with 1
n
P
i
φ(Xi
; Q, ˆ g, ˆ τˆ)
2
[Che+17e]. That is, we can estimate the uncertainity by simply
plugging in our fitted nuisance models and our point estimate of τ into
Vˆ[ˆτ ] = 1/nX
i
φ(Xi
; Q, ˆ g, ˆ τˆ)
2
. (36.40)
This estimated variance can then be used to compute confidence intervals in the usual manner. E.g.,
we’d report a 95% confidence interval for τ as τˆ ± 1.96q
Vˆ[ˆτ ]/n.
Alternatively, we could quantify the uncertainity by bootstrapping. Note, however, that this would
require refitting the nuisance functions with each bootstrap model. Depending on the model and
data, this can be prohibitively computationally expensive.
36.4.4 Matching
One particularly popular approach to adjustment-based causal estimation is matching. Intuitively,
the idea is to match each treated to unit to an untreated unit that has the same (or at least similar)
values of the confounding variables and then compare the observed outcomes of the treated unit and
its matched control. If we match on the full set of common causes, then the difference in outcomes is,
intuitively, a noisy estimate of the effect the treatment had on that treated unit. We’ll now build
this up a bit more carefully. In the process we’ll see that matching can be understood as, essentially,
a particular kind of outcome model adjustment.
For simplicity, consider the case where X is a discrete random variable. Define Ax to be the set of
treated units with covariate value x, and Cx to be the set of untreated units with covariate value x.
In this case, the matching estimator is:
τˆ
matching =
X
x
P( ˆ x)
￾ 1
|Ax|
X
i∈Ax
Yi −
1
|Cx|
X
j∈Cx
Yj

, (36.41)
where P( ˆ x) is an estimator of P(X = x) — e.g., the fraction of units with X = x. Now, we can rewrite
Yi = Q(Ai
, Xi) + ξi where ξi
is a unit-specific noise term defined by the equation. In particular, we
have that E[ξi
|Ai
, Xi
] = 0. Substituting this in, we have:
τˆ
matching =
X
x
P( ˆ x)
￾
Q(1, x) − Q(0, x)

+
X
x
1
|Ax|
X
i∈Ax
ξi −
1
|Cx|
X
j∈Cx
ξj . (36.42)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licen1192
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
We can recognize the first term as an estimator of usual target parameter τ (it will be equal to τ if
P( ˆ x) = P(x)). The second term is a difference of averages of random variables with expectation 0,
and so each term will converge to 0 as long as |Ax| and |Cx| each go to infinity as we see more and
more data. Thus, we see that the matching estimator is a particular way of estimating the parameter
τ . The procedure can be extended to continuous covariates by introducing some notion of values of
X being close, and then matching close treatment and control variables.
There are two points we should emphasize here. First, notice that the argument here has nothing
to do with causal identification. Matching is a particular technique for estimating the observational
parameter τ . Whether or not τ can be interpreted as an average treatment effect is determined by
the conditions of Theorem 2 — the particular estimation strategy doesn’t say anything about this.
Second, notice that in essence matching amounts to a particular choice of model for Qˆ. Namely,
Qˆ(1, x) = 1
|Ax|
P
i∈Ax
Yi and similarly for Qˆ(0, x). That is, we estimate the conditional expected
outcome as a sample mean over units with the same covariate value. Whether this is a good idea
depends on the quality of our model for Q. In situations where better models are possible (e.g., a
machine-learning model fits the data well), we might expect to get a more accurate estimate by using
the conditional expected outcome predictor directly.
There is another important case we mention in passing. In general, when using adjustment based
identification, it suffices to adjust for any function φ(X) of X such that A ⊥⊥ X|φ(X). To see that
adjusting for only φ(X) suffices, first notice that g(X) = P(A = 1|X) = P(A = 1|φ(X)) only depends
on φ(X), and then recall that can write the target parameter as τ = E[
Y A
g(X) −
Y (1−A)
1−g(X)
], whence
τ only depends on X through g(X). That is: replacing X by a reduced version φ(X) such that
g(X) = P(A = 1|φ(X)) can’t make any difference to τ . Indeed, the most popular choice of φ(X) is
the propensity score itself, φ(X) = g(X). This leads to propensity score matching, a two step
procedure where we first fit a model for the propensity score, and then run matching based on the
estimated propensity score values for each unit. Again, this is just a particular estimation procedure
for the observational parameter τ , and says nothing about whether it’s valid to interpret τ as a
causal effect.
36.4.5 Practical considerations and procedures
when performing causal analysis, many issues can arise in practice, some of which we discuss below.
36.4.5.1 What to adjust for
Choosing which variables to adjust for is a key detail in estimating causal effects using covariate
adjustment. The criterion is clear when one has a full causal graph relating A, Y , and all covariates
X to each other. Namely, adjust for all variables that are actually causal parents of A and Y . In
fact, with access to the full graph, this criterion can be generalized somewhat — see Section 36.8.
In practice, we often don’t actually know the full causal graph relating all of our variables.
As a result, it is common to apply simple heuristics to determine which variables to adjust for.
Unfortunately, these heuristics have serious limitations. However, exploring these is instructive.
A key condition in Theorem 2 is that the covariates X that we adjust for must include all the
common causes. In the absence of a full causal graph, it is tempting to condition on as many observed
variables as possible to try to ensure this condition holds. However, this can be problematic. For
instance, suppose that M is a mediator of the effect of A on Y — i.e., M lies on one of the directed
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.4. CONFOUNDER ADJUSTMENT
A Y
U1
X
U2
Figure 36.4: The M-bias causal graph. Here, A and Y are not confounded. However, conditioning on the
covariate X opens a backdoor path, passing through U1 and U2 (because X is a colider). Thus, adjusting for
X creates bias. This is true even though X need not be a pre-treatment variable.
paths between A and Y . Then, conditioning on M will block this path, removing some of the causal
effect. Note that this does not always result in an attenuated, or smaller-magnitude, effect estimate.
The effect through a given mediator may run in the opposite direction of other causal pathways
from the treatment; thus conditioning on a mediator can inflate or even flip the sign of a treatment
effect. Alternatively, if C is a collider between A and Y — a variable that is caused by both — then
conditioning on C will induce an extra statistical dependency between A and Y .
Both pitfalls of the “condition on everything” heuristic discussed above both involve conditioning
on variables that are downstream of the treatment A. A natural response is to this is to limit
conditioning to all pre-treatment variables, or those that are causally upstream of the treatment.
Importantly, if there is a valid adjustment set in the observed covariates X, then there will also be a
valid adjustment set among the pre-treatment covariates. This is because any open backdoor path
between A and Y must include a parent of A, and the set of pre-treatment covariates includes these
parents. However, it is still possible that conditioning on the full set of pre-treatment variables can
induce new backdoor paths between A and Y through colliders. In particular, if there is a covariate
D that is separately confounded with the treatment A and the outcome Y then D is a collider, and
conditioning on D opens a new backdoor path. This phenomenon is known as m-bias because of the
shape of the graph [Pea09c], see Figure 36.4.
A practical refinement of the pre-treatment variable heuristic is given in VanderWeele and Shpitser
[VS11]. Their heuristic suggests conditioning on all pre-treatment variables that are causes of the
treatment, outcome, or both. The essential qualifier in this heuristic is that the variable is causally
upstream of treatment and/or outcome. This eliminates the possibility of conditioning on covariates
that are only confounded with treatment and outcome, avoiding m-bias. Notably, this heuristic
requires more causal knowledge than the above heuristics, but does not require detailed knowledge of
how different covariates are causally related to each other.
The VanderWeele and Shpitser [VS11] criterion is a useful rule of thumb, but other practical
considerations often arise. For example, if one has more knowledge about the causal structure
among covariates, it is possible to optimize adjustment sets to minimize the variance of the resulting
estimator [RS20]. One important example of reducing variance by pruning adjustment sets is the
exclusion of variables that are known to only be a parent of the treatment, and not of the outcome
(so called instruments, as discussed in Section 36.5).
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1194
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Finally, adjustment set selection criteria operate under the assumption that there actually exists a
valid adjustment set among observed covariates. When there is no set of observed covariates in X
that block all backdoor paths, then any adjusted estimate will be biased. Importantly, in this case,
the bias does not necessarily decrease as one conditions on more variables. For example, conditioning
on an instrumental variable often results in an estimate that has higher bias, in addition to the
higher variance discussed above. This phenomenon is known as bias amplification or z-bias; see
Section 36.7.2. A general rule of thumb is that variables that explain away much more variation in
the treatment than in the outcome can potentially amplify bias, and should be treated with caution.
36.4.5.2 Overlap
Recall that in addition to no-unobserved-confounders, identification of the average treatment effect
requires overlap: the condition that 0 < P(A = 1|x) < 1 for the population distribution P. With
infinite data, any amount of overlap will suffice for estimating the causal effect. In realistic settings,
even near failures can be problematic. Equation (36.39) gives an expression for the (asymptotic)
variance of our estimate: E[φ(Xi
; Q, ˆ g, ˆ τˆ)
2
]/n. Notice that φ(Xi
; Q, ˆ g, ˆ τˆ)
2
involves terms that are
proportional to 1/g(X) and 1/(1 − g(X). Accordingly, the variance of our estimator will balloon
if there are units where g(x) ≈ 0 or g(x) ≈ 1 (unless such units are rare enough that they don’t
contribute much to the expectation).
In practice, a simple way to deal with potential overlap violation is to fit a model gˆ for the
treatment assignment probability — which we need to do anyways — and check that the values
gˆ(x) are not too extreme. In the case that some values are too extreme, the simplest resolution is
to cheat. We can simply exclude all the data with extreme values of gˆ(x). This is equivalent to
considering the average treatment effect over only the subpopulation where overlap is satisfied. This
changes the interpretation of the estimand. The restricted subpopulation ATE may or may not
provide a satisfactory answer to the real-world problem at hand, and this needs to be justified based
on knowledge of the real-world problem.
36.4.5.3 Choice of estimand and average treatment effect on the treated
Usually, our goal in estimating a causal effect is qualitative. We want to know what the sign of the
effect is, and whether it’s large or small. The utility of the ATE is that it provides a concrete query
we can use to get a handle on the qualitative question. However, it is not sacrosanct; sometimes
we’re better off choosing an alternative causal estimand that still answers the qualitative question but
which is easier to estimate statistically. The average treatment effect on the treated or ATT,
ATT , EX|A=1[E[Y |X, do(A = 1)] − E[Y |X, do(A = 0)]], (36.43)
is one such an estimand that is frequently useful.
The ATT is useful when many members of the population are very unlikely to receive treatment,
but the treated units had a reasonably high probability of receiving the control. This can happen if,
e.g., we sample control units from the general population, but the treatment units all self-selected
into treatment from a smaller subpopulation. In this case, it’s not possible to (non-parametrically)
determine the treatment effect for the control units where no similar unit took treatment. The ATT
solves this obstacle by simply omitting such units from the average.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.4. CONFOUNDER ADJUSTMENT
If we have the causal structure Figure 36.3, and the overlap condition P(A = 1|X = x) < 1 for all
X = x then the ATT is causally identified as
τ
ATT = EX|A=1[E[Y |A = 1, X] − E[Y |A = 0, X]]. (36.44)
Note that the required overlap condition here is weaker than for identifying the ATE. (The proof is
the same as Theorem 2.)
The estimation strategies for the ATE translate readily to estimation strategies for the ATT.
Namely, estimate the nuisance functions the same way and then simply replace averages over all
datapoints by averages over the treated datapoints only. In principle, it’s possible to do a little
better than this by making use of the untreated datapoints as well. A corresponding double machine
learning estimator is
τˆ
ATT−AIPTW ,
1
n
X
i
Ai
P(A = 1)(Y − Qˆ(0, Xi)) −
(1 − Ai)g(X)
P(A = 1)(1 − g(X))(Y − Qˆ(0, Xi). (36.45)
. The variance of this estimator can be estimated by
φ
ATT(Xi
; Q, g, τ ) ,
1
n
X
i

Ai
P(A = 1)(Y − Qˆ(0, Xi))
−
(1 − Ai)g(X)
P(A = 1)(1 − g(X))(Y − Qˆ(0, Xi) −
Aτ
P(A = 1)
(36.46)
Vˆ[τˆ
ATT−AIPTW] ,
1
n
X
i
φ
ATT(Xi
; Qˆ, g, ˆ τˆ
ATT−AIPTW). (36.47)
Notice that the estimator for the ATT doesn’t require estimating Q(1, X). This can be a considerable
advantage when the treated units are rare. See Chernozhukov et al. [Che+17e] for details.
36.4.6 Summary and practical advice
We have seen a number of estimators that follow the general procedure:
1. Fit statistical or machine-learning models Qˆ(a, x) as a predictor for Y , and/or gˆ(x) as a predictor
for A
2. Compute the predictions Qˆ(0, xi), Qˆ(1, xi), gˆ(xi) for each datapoint, and
3. Combine these predictions into an estimate of the average treatment effect.
Importantly, no single estimation approach is a silver bullet. For example, the double machine￾learning estimator has appealing theoretical properties, such as asymptotic efficiency guarantees and
a recipe for estimating uncertainity without needing to bootstrap the model fitting. However, in
terms of the quality of point estimates, the double ML estimators can sometimes underperform their
more naive counterparts [KS07]. In fact, there are cases where each of outcome regression, propensity
weighting, or doubly robust methods will outperform the others.
One difficulty in choosing an estimator in practice is that there are fewer guardrails in causal
inference than there are in standard predictive modeling. In predictive modeling, we construct a
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1196
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
train-test split and validate our prediction models using the true labels or outcomes in the held-out
dataset. However, for causal problems, the causal estimands are functionals of a different data￾generating process from the one that we actually observed. As a result, it is impossible to empirically
validate many aspects of causal estimation using standard techniques.
The effectiveness of a given approach is often determined by how much we trust the specification of
our propensity score or outcome regression models gˆ(x) and Qˆ(a, x), and how well the treatment and
control groups overlap in the dataset. Using flexible models for the nuisance functions g and Q can
alleviate some of the concerns about model misspecification, but our freedom to use such models is
often constrained by dataset size. When we have the luxury of large data, we can use flexible models;
on the other hand, when the dataset is relatively small, we may need to use a smaller parametric
family or stringent regularization to obtain stable estimates of Q and g. Similarly, if overlap is poor
in some regions of the covariate space, then flexible models for Q may be highly variable, and inverse
propensity score weights may be large. In these cases, IPTW or AIPTW estimates may fluctuate
wildly as a function of large weights. Meanwhile, outcome regression estimates will be sensitive to
the specification of the Q model and its regularization, and can incur bias that is difficult to measure
if the specification or regularization does not match the true outcome process.
There are a number of practical steps that we can take to sanity-check causal estimates. The
simplest check is to compute many different ATE estimators (e.g., outcome regression, IPTW, doubly
robust) using several comparably complex estimators of Q and g. We can then check whether they
agree, at least qualitatively. If they do agree then this can provide some peace of mind (although it
is not a guarantee of accuracy). If they disagree, caution is warranted, particularly in choosing the
specification of the Q and g models.
It is also important to check for failures of overlap. Often, issues such as disagreement between
alternative estimators can be traced back to poor overlap. A common way to do this, particularly
with high-dimensional data, is to examine the estimated (ideally cross-fitted) propensity scores gˆ(xi).
This is a useful diagnostic, even if the intention is to use an outcome regression approach that only
incorporates and estimated outcome regression function Qˆ(a, xi). If overlap issues are relevant, it
may be better to instead estimate either the average treatment effect on the treated, or the “trimmed”
estimand given by discarding units with extreme propensities.
Uncertainty quantification is also an essential part of most causal analyses. This frequently takes
the form of an estimate of the estimator’s variance, or a confidence interval. This may be important
for downstream decision-making, and can also be a useful diagnostic. We can calculate variance either
by bootstrapping the entire procedure (including refitting the models in each bootstrap replicate),
or computing analytical variance estimates from the AIPTW estimator. Generally, large variance
estimates may indicate issues with the analysis. For example, poor overlap will often (although
not always) manifest as extremely large variances under either of these methods. Small variance
estimates should be treated with caution, unless other checks, such as overlap checks, or stability
across different Q and g models, also pass.
The previous advice only addresses the statistical problem of estimating τ from a data sample. It
does not speak to whether or not τ can reasonably be interpreted as an average treatment effect.
Considerable care should be devoted to whether or not the assumption that there are no unobserved
confounders is reasonable. There are several methods for assessing the sensitivity of the ATE estimate
to violations of this assumption. See Section 36.7. Bias due to unobserved confounding can be
substantial in practice—often overwhelming bias due to estimation error—so it is wise to conduct
such an analysis.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.5. INSTRUMENTAL VARIABLE STRATEGIES
Z A Y
X U
Figure 36.5: Causal graph illustrating the instrumental variable setup. The treatment A and outcome Y are
both influenced by unobserved confounder U. Nevertheless, identification is sometimes possible due to the
presence of the instrument Z. We also allow for observed covariates X that we may need to adjust for. The
dashed arrow between U and X indicates a statistical dependency where we remain agnostic to the particular
causal relationship.
36.5 Instrumental variable strategies
Adjustment-based methods rely on observing all confounders affecting the treatment and outcome.
In some situations, it is possible to identify interesting causal effects even when there are unobserved
confounders. We now consider strateges based on instrumental variables. The instrumental
variable graph is shown in Figure 36.5. The key ingredient is the instrumental variable Z, a variable
that has a causal effect on Y only through its causal effect on A. Informally, the identification
strategy is to determine to the causal effect of Z on Y , the causal effect of Z on A, and then combine
these into an estimate of the causal effect of A on Y .
For this identification to strategy to work the instrument must satisfy three conditions. There are
observed variables (confounders) X such that:
1. Instrument relevance Z 6⊥⊥ A|X: the instrument must actually affect the treatment assignment.
2. Instrument unconfoundedness Any backdoor path between Z and Y is blocked by X, even
conditional on A.
3. Exclusion restriction All directed paths from Z to Y pass through A. That is, the instrument
affects the outcome only through its effect on A.
(It may help conceptually to first think through the case where X is the empty set — i.e., where
the only confounder is the unobserved U). These assumptions are necessary for using instrumental
variables for causal identification, but they are not quite sufficient. In practice, they must be
supplemented by an additional assumption that depends more closely on the details of the problem
at hand. Historically, this additional assumption was usually that both the instrument-treatment and
treatment-outcome relationships are linear. We’ll examine some less restrictive alternatives below.
Before moving on to how to use instrumental variables for identification, let’s consider how we
might encounter instruments in practice. The key is that its often possible to find, and measure,
variables that affect treatment and that are assigned (as if) at random. For example, suppose we are
interested in measuring the effect of taking a drug A on some health outcome Y . The challenge is that
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1198
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
whether a study participant actually takes the drug can be confounded with Y —e.g., sicker people
may be more likely to take their medication, but have worse outcomes. However, the assignment
of treatments to patients can be randomized and this random assignment can be viewed as an
instrument. This random assignment with non-compliance scenario is common in practice.
The random assignment — the instrument — satisfies relevance (so long as assigning the drug affects
the probability of the patient taking the drug). It also satisfies unconfoundedness (because the
instrument is randomized). And, it plausibly satisfies exclusion restriction: telling (or not telling)
a patient to take a drug has no effect on their health outcome except through influencing whether
or not they actually take the drug. As a second example, the judge fixed effects research design
uses the identity of the judge assigned to each criminal case to infer the effect of incarceration on
some life outcome of interest (e.g., total lifetime earnings). Relevance will be satisfied so long as
different judges have different propensities to hand out severe sentences. The assignment of trial
judges to cases is randomized, so unconfoundedness will also be satisfied. And, exclusion restriction
is also plausible: the particular identity of the judge assigned to your case has no bearing on your
years-later life outcomes, except through the particular sentence that you’re subjected to.
It’s important to note that these assumptions require some care, particularly exclusion restriction.
Relevance can be checked directly from the data, by fitting a model to predict the treatment from the
instrument (or vice versa). Unconfoundedness is often satisfied by design: the instrument is randomly
assigned. Even when literal random assignment doesn’t hold, we often restrict to instruments where
unconfoundedness is “obviously” satisfied — e.g., using number of rainy days in a month as an
instrument for sun exposure. Exclusion restriction is trickier. For example, it might fail in the
drug assignment case if patients who are not told to take a drug respond by seeking out alternative
treatment. Or, it might fail in the judge fixed effects case if judges hand out additional, unrecorded,
punishments in addition to incarceration. Assessing the plausibility of exclusion restriction requires
careful consideration based on domain expertise.
We now return to the question of how to make use of an instrument once we have it in hand. As
previously mentioned, getting causal identification using instrumental variables requires supplementing
the IV assumptions with some additional assumption about the causal process.
36.5.1 Additive unobserved confounding
We first consider additive unobserved confounding. That is, we assume that the structural caual
model for the outcome has the form:7
Y ← f(A, X) + fU (U). (36.48)
In words, we assume that there are no interaction effects between the treatment and the unobserved
confounder — everyone responds to treatment in the same way. With this additional assumption, we
see that E[Y |X, do(A = a)] − E[Y |X, do(A = a
′
)] = f(a, X) − f(a
′
, X). In this setting, our goal is to
learn this contrast.
Theorem 3 (Additive confounding identification). If the instrumental variables assumptions hold
and also additive unobserved confounding holds, then there is a function ˜f(a, x) where
E[Y |x, do(A = a)] − E[Y |x, do(A = a
′
)] = ˜f(a, x) − ˜f(a
′
, x), (36.49)
7. We roll the unit-specific variables ξ into U to avoid notational overload.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.5. INSTRUMENTAL VARIABLE STRATEGIES
for all x, a, a′ and such that ˜f satisfies
E[Y |z, x] = Z
˜f(a, x)p(a|z, x)da. (36.50)
Here, p(a|z, x) is the conditional probability density of treatment.
In particular, if there is a unique function g that satisfies
E[Y |z, x] = Z
g(a, x)p(a|z, x)da, (36.51)
then g = ˜f and this relation identifies the target causal effect.
Before giving the proof, lets understand the point of this identification result. The key insight
is that both the left hand side of Equation (36.51) and p(a|z, x) (appearing in the integrand) are
identified by the data, since they involve only observational relationships between observed variables.
So, ˜f is identified implicitly as one of the functions that makes Equation (36.51) true. If there is a
unique such function, then this fully identifies the causal effect.
Proof. With the additive unobserved confounding assumption, the instrument unconfoundedness
implies that U ⊥⊥ Z|X. Then, we have that:
E[Y |Z, X] = E[f(A, X)|Z, X] + E[fU (U)|Z, X] (36.52)
= E[f(A, X)|Z, X] + E[fU (U)|X] (36.53)
= E[
˜f(A, X)|Z, X], (36.54)
where ˜f = f(A, X) +E[fU (U)|X]. Now, identifying just ˜f would suffice for us, because we could then
identify contrasts between treatements: f(a, x) − f(a
′
, x) = ˜f(a, x) − ˜f(a
′
, x). (The term E[fU (U)|x]
cancels out). Accordingly, we rewrite Equation (36.54) as:
E[Y |z, x] = Z
˜f(a, x)p(a|z, x)da. (36.55)
It’s worth dwelling briefly on how the IV assumptions come into play here. The exclusion restriction
is implied by the additive unobserved confounding assumption, which we use explicilty. We also use
the unconfoundedness assumption to conclude U ⊥⊥ Z|X. However, we do not use relevance. The
role of relevance here is in ensuring that few functions solve the relation Equation (36.51). Informally,
the solution g is constrained by the requirement that it hold for all values of Z. However, different
values of Z only add non-trivial constraints if p(a|z, x) differ depending on the value of z — this is
exactly the relevance condition.
Estimation The basic estimation strategy is to fit models for E[Y |z, x] and p(a|z, x) from the data,
and then solve the implicit equation Equation (36.51) to find g consistent with the fitted models. The
procedures for doing this can vary considerably depending on the particulars of the data (e.g., if Z is
discrete or continuous) and the choice of modeling strategy. We omit a detailed discussion, but see
e.g., [NP03; Dar+11; Har+17; SSG19; BKS19; Mua+20; Dik+20] for various concrete approaches.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1200
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
It’s also worth mentioning an additional nuance to the general procedure. Even if relevance holds,
there will often be more than one function that satisfies Equation (36.51). So, we have only identified
˜f as a member of this set of functions. In practice, this ambiguity is defeated by making some
additional structural assumption about ˜f. For example, we model ˜f with a neural network, and then
choose the network satisfying Equation (36.51) that has minimum l2-norm on the parameters (i.e.,
we pick the l2-regularized solution).
36.5.2 Instrument monotonicity and local average treatment effect
We now consider an alternative assumption to additive unobserved confounding that is applicable
when both the instrument and treatment are binary. It will be convenient to conceptualize the
instrument as assignment-to-treatment. Then, the population divides into four subpopulations:
1. Compliers, who take the treatment if assigned to it, and who don’t take the treatment otherwise.
2. Always takers, who take the treatment no matter their assignment.
3. Never takers, who refuse the treatment no matter their assignment.
4. Defiers, who refuse the treatment if assigned to it, and who take the treatment if not assigned.
Our goal in this setting will be to identify the average treatment effect among the compliers. The
local average treatment effect (or complier average treatment effect) is defined to be8
LATE = E[Y |do(A = 1), complier] − E[Y |do(A = 0), complier]. (36.56)
The LATE requires an additional assumption for identification. Namely, instrument monotonic￾ity: being assigned (not assigned) the treatment only increases (decreases) the probability that each
unit will take the treatment. Equivalently, P(defier) = 0.
We can then write down the identification result.
Theorem 4. Given the instrumental variable assumptions and instrument monotonicty, the local
average treatment is identified as a parameter τ
LATE of the observational distributional; that is,
LATE = τ
LATE. Namely,
τ
LATE =
E[E[Y |X, Z = 1] − E[Y |X, Z = 0]]
E[P(A = 1|X, Z = 1) − P(A = 1|X, Z = 0)]. (36.57)
Proof. We now show that, given the IV assumptions and monotonicity, LATE = τ
LATE. First, notice
that
τ
LATE =
E[Y |do(Z = 1)] − E[Y |do(Z = 0)]
P(A = 1|do(Z = 1)) − P(A = 1|do(Z = 0)). (36.58)
This follows from backdoor adjustment, Theorem 2, applied to the numerator and denominator
separately. Our strategy will be to decompose E[Y |do(Z = z)] into the contributions from the
8. We follow the econometrics literature in using “LATE” because “CATE” is already commonly used for conditional
average treatment effect.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.5. INSTRUMENTAL VARIABLE STRATEGIES
compliers, the units that ignore the instrument (the always/never takers), and the defiers. To that
end, note that P(complier|do(Z = z)) = P(complier) and similarly for always/never takers and
defiers — interventions on the instrument don’t change the composition of the population. Then,
E[Y |do(Z = 1)] − E[Y |do(Z = 1)] (36.59)
=
￾
E[Y |complier, do(Z = 1)] − E[Y |complier, do(Z = 0)]
P(complier) (36.60)
+
￾
E[Y |always/never, do(Z = 1)] − E[Y |always/never, do(Z = 0)]
P(always/never) (36.61)
+
￾
E[Y |defier, do(Z = 1)] − E[Y |defier, do(Z = 0)]
P(defier). (36.62)
The key is the effect on the complier subpopulation, Equation (36.60). First, by definition of the
complier population, we have that:
E[Y |complier, do(Z = z)] = E[Y |complier, do(A = z)]. (36.63)
That is, the causal effect of the treatment is the same as the causal effect of the instrument in this
subpopulation — this is the core reason why access to an instrument allows identification of the local
average treatment effect. This means that
LATE = E[Y |complier, do(Z = 1)] − E[Y |complier, do(Z = 0)]. (36.64)
Further, we have that P(complier) = P(A = 1|do(Z = 1)) − P(A = 1|do(Z = 0)). The reason is
simply that, by definition of the subpopulations,
P(A = 1|do(Z = 1)) = P(complier) + P(always taker) (36.65)
P(A = 1|do(Z = 0)) = P(always taker). (36.66)
Now, plugging the expression for P(complier) and Equation (36.64) into Equation (36.60) we have
that:
￾
E[Y |complier, do(Z = 1)] − E[Y |complier, do(Z = 0)]
P(complier) (36.67)
= LATE × (P(A = 1|do(Z = 1)) − P(A = 1|do(Z = 0))) (36.68)
This gives us an expression for the local average treatment effect in terms of the effect of the instrument
on the compliers and the probability that a unit takes the treatment when assigned/not-assigned.
The next step is to show that the remaining instrument effect decomposition terms, Equa￾tions (36.61) and (36.62), are both 0. Equation (36.61) is the causal effect of the instrument on the
always/never takers. It’s equal to 0 because, by definition of this subpopulation, the instrument has
no causal effect in the subpopulation — they ignore the instrument! Mathematically, this is just
E[Y |always/never, do(Z = 1)] = E[Y |always/never, do(Z = 0)]. Finally, Equation (36.62) is 0 by the
instrument monotonicity assumption: we assumed that P(defier) = 0.
In totality, we now have that Equations (36.60) to (36.62) reduces to:
E[Y |do(Z = 1)] − E[Y |do(Z = 1)] (36.69)
= LATE ×
￾
P(A = 1|do(Z = 1)) − P(A = 1|do(Z = 0))
+ 0 + 0 (36.70)
Rearranging for LATE and plugging in to Equation (36.58) gives the claimed identification result.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND li1202
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.5.2.1 Estimation
For estimating the local average treatment effect under the monotone instrument assumption, there
is a double-machine learning approach that works with generic supervised learning approaches. Here,
we want an estimator τˆ
LATE for the parameter
τ
LATE =
E[E[Y |X, Z = 1] − E[Y |X, Z = 0]]
E[P(A = 1|X, Z = 1) − P(A = 1|X, Z = 0)]. (36.71)
To define the estimator, it’s convenient to introduce some additional notation. First, we define the
nuisance functions:
µ(z, x) = E[Y |z, x] (36.72)
m(z, x) = P(A = 1|x, z) (36.73)
p(x) = P(Z = 1|x). (36.74)
We also define the score φ by:
φZ→Y (X; µ, p) , µ(1, X) − µ(0, X) + Z(Y − µ(1, X))
p(X)
−
(1 − Z)(Y − µ(0, X))
1 − p(X)
(36.75)
φZ→A(X; m, p) , m(1, X) − m(0, X) + Z(A − m(1, X))
p(X)
−
(1 − Z)(A − m(0, X))
1 − p(X)
(36.76)
φ(X; µ, m, p, τ ) , φZ→Y (X; µ, p) − φZ→A(X; m, p) × τ (36.77)
Then, the estimator is defined by a two stage procedure:
1. Fit models µ, ˆ m, ˆ pˆ for each of µ, m, p (using supervised machine learning).
2. Define τˆ
LATE as the solution to 1
n
P
i
φ(Xi
; ˆµ, m, ˆ p, ˆ τˆ
LATE) = 0. That is,
τˆ
LATE =
1
n
P
i
φZ→Y (Xi
; ˆµ, pˆ)
1
n
P
i
φZ→A(Xi
; ˆm, pˆ)
(36.78)
It may help intuitions to notice that the double machine learning estimator of the LATE is effectively
the double machine learning estimator of of the average treatment effect of Z on Y divided by the
double machine learning estimator of the average treatment effect of Z on A.
Similarly to Section 36.4, the nuisance functions can be estimated by:
1. Fit a model µˆ that predicts Y from Z, X by minimizing mean square error.
2. Fit a model mˆ that predicts A from Z, X by minimizing mean cross-entropy.
3. Fit a model pˆ that predicts Z from X by minimizing mean cross-entropy.
As in Section 36.4, reusing the same data for model fitting and computing the estimator can
potentially cause problems. This can be avoided with use a cross-fitting procedure as described in
Section 36.4.2.4. In this case, we split the data into K folds and, for each fold k, use all the but
the k’th fold to compute estimates µˆ−k, mˆ −k, pˆ−k of the nuisance parameters. Then we compute
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.5. INSTRUMENTAL VARIABLE STRATEGIES
the nuisance estimates for each datapoint i in fold k by predicting the required quantity using the
nuisance model fit on the other folds. That is, if unit i is in fold k, we compute µˆ(zi
, xi) , µˆ
−k
(zi
, xi)
and so forth.
The key result is that if we use the cross-fit version of the estimator and the estimators for the
nuisance functions converge to their true values in the sense that
1. E(ˆµ(Z, X) − µ(Z, X))2 → 0, E( ˆm(Z, X) − m(Z, X))2 → 0, and E(ˆp(X) − p(X))2 → 0
2. p
E[(ˆp(X) − p(X))2] ×
￾p
E[(ˆµ(Z, X) − µ(Z, X))2] + p
E[( ˆm(Z, X) − m(Z, X))2]

= o(
√
n)
then (with some omitted technical conditions) we have asymptotic normality at the √
n-rate:
√
n(ˆτ
LATE−cf − τ
LATE)
d
−→ Normal(0,
E[φ(X; µ, m, p, τ LATE)
2
]
E[m(1, X) − m(0, X)]2
). (36.79)
As with double machine learning for the confounder adjustment strategy, the key point here is that
we can achieve the (optimal) √
n rate for estimating the LATE under a relatively weak condition on
how well we estimate the nuisance functions — what matters is the product of the error in p and the
errors in µ, m. So, for example, a very good model for how the instrument is assigned (p) can make
up for errors in the estimation of the treatment-assignment (m) and outcome (µ) models.
The double machine learning estimator also gives a recipe for quantifying uncertainity. To that
end, define
τˆZ→A ,
1
n
X
i
φZ→A(Xi
; ˆm, pˆ) (36.80)
Vˆ[ˆτ
LATE] ,
1
τˆ
2
Z→A
1
n
X
i
φ(Xi
; ˆµ, m, ˆ p, ˆ τˆ
LATE)
2
. (36.81)
Then, subject to suitable technical conditions, Vˆ[τˆ
LATE−cf] can be used as an estimate of the variance
of the estimator. More precisely,
√
n(ˆτ
LATE − τ
LATE)
d
−→ Normal(0, Vˆ[ˆτ
LATE]). (36.82)
Then, confidence intervals or p-values can be computed using this variance in the usual way. The main
extra condition required for the variance estimator to be valid is that the nuisance parameters must
all converge at rate O(n
−1/4
) (so an excellent estimator for one can’t fully compensate for terrible
estimators of the others). In fact, even this condition is unnecessary in certain special cases — e.g.,
when p is known exactly, which occurs when the instrument is randomly assigned. See Chernozhukov
et al. [Che+17e] for technical details.
36.5.3 Two stage least squares
Commonly, the IV assumptions are supplemented with the following linear model assumptions:
Ai ← α0 + αZi + δAXi + γAXi + ξ
A
i
(36.83)
Yi ← β0 + βAi + δY Xi + γY Xi + ξ
Y
i
(36.84)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licens1204
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
That is, we assume that the real-world process for treatment assignment and the outcome are both
linear. In this case, plugging Equation (36.83) into Equation (36.84) yields
Yi ← β˜
0 + βαZi + ˜δXi + ˜γXi + ˜ξi
. (36.85)
The point is that β, the average treatment effect of A on Y , is equal to the coefficient βα of the
instrument in the outcome-instrument model divided by the coefficient α of the instrument in the
treatment-instrument model. So, to estimate the treatment effect, we simply fit both linear models
and divide the estimated coefficients. This procedure is called two stage least squares.
The simplicity of this procedure is seductive. However, the required linearity assumptions are hard
to satisfy in practice and frequently lead to severe issues. A particularly pernicious version of this
is that linear-model misspecfication together with weak relevance can yield standard errors for the
estimate that are far too small. In practice, this can lead us to find large, significant estimates from
two stage least squares when the truth is actually a weak or null effect. See [Rei16; You19; ASS19;
Lal+21] for critical evaluations of two stage least squares in practice.
36.6 Difference in differences
Unsurprisingly, time plays an important role in causality. Causes precede effects, and we should be
able to incorporate this knowledge into causal identification. We now turn to a particular strategy
for causal identification that relies on observing each unit at multiple time points. Data of this kind
is sometimes called panel data. We’ll consider the simplest case. There are two time periods. In
the first period, none of the units are treated, and we observe an outcome Y0i for each unit. Then,
a subset of the units are treated, denoted by Ai = 1. In the second time period, we again observe
the outcomes Y1i for each unit, where now the outcomes of the treated units are affected by the
treatment. Our goal is to determine the average effect receiving the treatment had on the treated
units. That is, we want to know the average difference between the outcomes we actually observed
for the treated units, and the outcomes we would have observed on those same units if they had not
been treated. The general strategy we look at is called difference in differences.
9
As a concrete motivating example, consider trying to determine the effect raising minimum wage
on employment. The concern here is that, in an efficient labor market, increasing the price of workers
will reduce the demand for them, thereby driving down employment. As such, it seems increasing
minimum wage may hurt the people the policy is nominally intended to help. The question is: how
strong is this effect in practice? Card and Krueger [CK94a] studied this effect using difference in
differences. The Philadelphia metropolitan area includes regions in both Pennsylvania and New
Jersey (different US states). On April 1st 1992, New Jersey raised its minimum wage from $4.25 to
$5.05. In Pennsylvania, the wage remained constant at $4.25. The strategy is to collect employment
data from fast food restaurants (which pay many employees minimum wage) in each state before
and after the change in minimum wage. In this case, for restaurant i, we have Y0i
, the number of
full time employees in February 1992, and Y1i
, the number of full time employees in November 1992.
The treatment is simply Ai = 1 if the restaurant was located in New Jersey, and Ai = 0 if located in
Pennsylvania. Our goal is to estimate the average effect of the minimum wage hike on employment
in the restaurants affected by it (i.e., the ones in New Jersey).
9. See github.com/vveitch/causality-tutorials/blob/main/difference_in_differences.ipynb.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.6. DIFFERENCE IN DIFFERENCES
The assumption in classical difference-in-differences is the following structural equation:
Yti ← Wi + St + τAiI(t = 1) + ξti, (36.86)
with E[ξti|Wi
, St, Ai
] = 0. Here, Wi
is a unit specific effect that is constant across time (e.g., the
location of the restuarant or competence of the management) and St is a time-specific effect that
applies to all units (e.g., the state of the US economy at each time). Both of these quantities are
treated as unobserved, and not explicitly accounted for. The parameter τ captures the target causal
effect. The (strong) assumption here is that unit, time, and treatment effects are all additive. This
assumption is called parallel trends, because it is equivalent to assuming that, in the absence of
treatment, the trend over time would be the same in both groups. It’s easy to see that under this
assumption, we have:
τ = E[Y1i − Y0i
|A = 1] − E[Y1i − Y0i
|A = 0]. (36.87)
That is, the estimand first computes the difference across time for both the treated and untreated
group, and then computes the difference between these differences across the groups. The obvious
estimator is then
τˆ =
1
nA
X
i:Ai=1
Y1i − Y0i −
1
n − nA
X
i:Ai=0
Y1i − Y0i
, (36.88)
where nA is the number of treated units.
The root identification problem addressed by difference-in-differences is that E[Wi
|Ai = 1] 6=
E[Wi
|Ai = 0]. That is, restaurants in New Jersey may be systematically different from restuarants in
Pennsylvania in unobserved ways that affect employment.10 This is why we can’t simply compare
average outcomes for the treated and untreated. The identification assumption is that this unit￾specific effect is the only source of statistical association with treatment; in particular we assume the
time-specific effect has no such issue: E[S1i − S0i
|Ai = 1] = E[S1i − S0i
|Ai = 0]. Unfortunately, this
assumption can be too strong. For instance, administrative data shows employment in Pennsylvania
falling relative to employment in New Jersey between 1993 and 1996 [AP08, §5.2]. Although this
doesn’t directly contradict the parallel trends assumption used for indentification, which needs to
hold only in 1992, it does make it seem less credible.
To weaken the assumption, we’ll look at a version that requires parallel trends to hold only after
adjusting for covariates. To motivate this, we note that there were several different types of fast food
restaurant included in the employment data. These vary, e.g., in the type of food they serve, and
in cost per meal. Now, it seems reasonable the trend in employment may depend on the type of
restuarant. For example, more expensive chains (such as KFC) might be more affected by recessions
than cheaper chains (such as McDonald’s). If expensive chains are more common in New Jersey
than in Pennsylvania, this effect can create a violation of parallel trends — if there’s recession
affecting both states, we’d expect employment to go down more in New Jersey than in Pennsylvania.
However, we may find it credible that McDonald’s restaurants in New Jersey have the same trend as
McDonald’s in Pennsylvania, and similarly for KFC.
10. This is similar to the issue that arises from unobserved confounding, except Wi need not be a cause of the treatment
assignment.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1206
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
A
U Y1 − Y0
X
Figure 36.6: Causal graph assumed for the difference-in-differences setting. Here, the outcome of interest
is the difference between the pre- and post-treatment period, Y1 − Y0. This difference is influenced by the
treatment, unobserved factors U, and observed covariates X. The dashed arrow between U and A indicates a
statistical dependency between the variables, but where we remain agnostic to the precise causal mechanism.
For example, in the minimum wage example, U might be the average income in restaurant’s neighbourhood,
which is dependent on the state, and hence also the treatment.
The next step is to give a definition of the target causal effect that doesn’t depend on a parametric
model, and a non-parametric statement of the identification assumption to go with it. In words, the
causal estimand will be the average treatment effect on the units that received the treatment. To
make sense of this mathematically, we’ll introduce a new piece of notation:
P
A=1(Y |do(A = a)) ,
Z
P(Y |A = a, parents of Y )dP(parents of Y |A = 1) (36.89)
E
A=1[Y |do(A = a)] , EPA=1(Y |do(A=a))[Y ]. (36.90)
In words: recall that the ordinary do operator works by replacing P(parents|A = a) by the marginal
distribution P(parents), thereby breaking the backdoor associations. Now, we’re replacing the
distribution P(parents|A = a) by P(parents|A = 1), irrespective of the actual treatment value. This
still breaks all backdoor associations, but is a better match for our target of estimating the treatment
effect only among the treated units.
To formalize a causal estimand using the do-calculus, we need to assume some partial causal
structure. We’ll use the graph in Figure 36.6. With this in hand, our causal estimand is the average
treatment effect on the units that received the treatment, namely:
ATTDiD = E
A=1[Y1 − Y0|do(A = 1)] − E
A=1[Y1 − Y0|do(A = 0)]] (36.91)
In the minimum wage example, this is the average effect of the minimum wage hike on employment
in the restaurants affected by it (i.e., the ones in New Jersey).
Finally, we formalize the identification assumption that, conditional on X, the trends in the treated
and untreated groups are the same. The conditional parallel trends assumption is:
E
A=1[Y1 − Y0|X, do(A = 0)] = E[Y1 − Y0|X, A = 0]. (36.92)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.6. DIFFERENCE IN DIFFERENCES
In words, this says that for treated units with covariates X, the trend we would have seen had we not
assigned treatment is the same as the trend we actually saw for the untreated units with covariates
X. That is, if New Jersey had not raised its minimum wage, then McDonald’s in New Jersey would
have the same expected change in employment as McDonald’s in Pennsylvania.
With this in hand, we can give the main identification result:
Theorem 5 (Difference in differences identification). We observe A, Y0, Y1, X ∼ P. Suppose that
1. (Causal structure) The data follows the causal graph in Figure 36.6.
2. (Conditional parallel trends) E
A=1[Y1 − Y0|X, do(A = 0)] = E[Y1 − Y0|X, A = 0].
3. (Overlap) P(A = 1) > 0 and P(A = 1|X = x) < 1 for all values of x in the sample space. That is,
there are no covariate values that only exist in the treated group.
Then, the average treatment effect on the treated is identified as ATTDiD = τ
DiD, where
τ
DiD = E[E[Y1 − Y0|A = 1, X] − E[Y1 − Y0|A = 0, X]|A = 1]. (36.93)
Proof. First, by unrolling definitions, we have that
E
A=1[Y1 − Y0|do(A = 1), X] = E[Y1 − Y0|A = 1, X]. (36.94)
The interpretation is the near-tautology that the average effect among the treated under treatment
is equal to the actually observed average effect among the treated. Next,
E
A=1[Y1 − Y0|do(A = 0), X] = E[Y1 − Y0|A = 0, X]. (36.95)
is just the conditional parallel trends assumption. The result follows immediately.
(The overlap assumption is required to make sure all the conditional expectations are well
defined).
36.6.1 Estimation
With the identification result in hand, the next task is to estimate the observational estimand
Equation (36.93). To that end, we define Y˜ , Y1 − Y0. Then, we’ve assumed that Y, X, A ˜
iid∼ P for
some unknown distribution P, and our target estimand is E[E[Y˜ |A = 1, X] − E[Y˜ |A = 0, X]|A = 1].
We can immediately recognize this as the observational estimand that occurs in estimating the
average treatment effect through adjustment, described in Section 36.4.5.3. That is, even though
the causal situation and the identification argument are different between the adjustment setting
and the difference in differences setting, the statistical estimation task we end up with is the same.
Accordingly, we can use all of the estimation tools we developed for adjustment. That is, all of the
techniques there — expected outcome modeling, propensity score methods, double machine learning,
and so forth — were purely about the statistical task, which is the same between the two scenarios.
So, we’re left with the same general recipe for estimation we saw in Section 36.4.6. Namely,
1. Fit statistical or machine-learning models Qˆ(a, x) as a predictor for Y˜ = Y1 − Y0, and/or gˆ(x) as
a predictor for A.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1208
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
2. Compute the predictions Qˆ(0, xi), Qˆ(1, xi), gˆ(xi) for each datapoint.
3. Combine these predictions into an estimate of the average treatment effect on the treated.
The estimator in the third step can be the expected outcome model estimator, the propensity weighted
estimator, the double machine learning estimator, or any other strategy that’s valid in the adjustment
setting.
36.7 Credibility checks
Once we’ve chosen an identification strategy, fit our models, and produced an estimate, we’re faced
with a basic question: should we believe it? Whether the reported estimate succeeds in capturing
the true causal effect depends on whether the assumptions required for causal identification hold, the
quality of the machine learning models, and the variability in the estimate due to only having access
to a finite data sample. The latter two problems are already familiar from machine learning and
statistical practice. We should, e.g., assess our models by checking performance on held out data,
examining feature importance, and so forth. Similarly, we should report measures of the uncertainity
due to finite sample (e.g., in the form of confidence intervals). Because these procedures are already
familiar practice, we will not dwell on them further. However, model evaluation and uncertainity
quantification are key parts of any credible causal analysis.
Assessing the validity of identification assumptions is trickier. First, there are assumptions that
can in fact be checked from data. For example, overlap should be checked in analysis using backdoor
adjustment or difference in differences, and relevance should be checked in the instrumental variable
setting. Again, checking these conditions is absolutely necessary for a credible causal analysis. But,
again, this involves only familiar data analysis, so we will not discuss it further. Next, there are the
causal assumptions that cannot be verified from data; e.g., no unobserved confounding in backdoor
adjustment, the exclusion restriction in IV, and conditional parallel trends in DiD. Ultimately, the
validity of these assumptions must be assessed using substantive causal knowledge of the particular
problem under consideration. However, it is possible to conduct some supplementary analyses that
make the required judgement easier. We now discuss two such two such techniques.
36.7.1 Placebo checks
In many situations we may be able to find a variable that can be interepreted as a “treatment” that is
known to have no effect on the outcome, but which we expect to be confounded with the outcome in
a very similar fashion to the true treatment of interest. For example, if we’re trying to estimate the
efficacy of a COVID vaccine in preventing symptomatic COVID, we might take our placebo treatment
to be vaccination against HPV. We do not expect that there’s any causal effect here. However, it
seems plausible that latent factors that cause an individual to seek (or avoid) HPV vaccination and
COVID vaccination are similar; e.g., health concientiousness, fear of needles, and so forth. Then, if
our identification strategy is valid for the COVID vaccine, we’d also expect it to be to be valid for
HPV vaccination. Accordingly, our estimation procedure we use for estimating the COVID effect
should, when applied to HPV, yield τˆ ≈ 0. Or, more precisely, the confidence interval should contain
0. If this does not happen, then we may suspect that there are still some confounding factors lurking
that are not adequately handled by the identification procedure.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.7. CREDIBILITY CHECKS
A similar procedure works when there is a variable that can be interpreted as an outcome which
is known to not be affected by the treatment, but that shares confounders with the outcome we’re
actually interested in. For example, in the COVID vaccination case, we might take the null outcome
to be symptomatic COVID within 7 days of vaccination [Dag+21]. Our knowledge of both the
biological mechanism of vaccination and the amount of time it takes to develop symptoms after
COVID infection (at least 2 days) lead us to conclude that it’s unlikely that the treatment has a
causal effect on the outcome. However, the properties of the treated people that affect how likely they
are to develop symptomatic COVID are largely the same in the 7 day and, e.g., 6 month window.
That includes factors such as risk aversion, baseline health, and so forth. Again, we can apply our
identification strategy to estimate the causal effect of the treatment on the null outcome. If the
confidence interval does not include 0, then we should doubt the credibility of the analysis.
36.7.2 Sensitivity analysis to unobserved confounding
We now specialize to the case of estimating the average causal effect of a binary treatment by
adjusting for confounding variables, as described in Section 36.4. In this case, causal identification
is based on the assumption of ‘no unobserved confounding’; i.e., the assumption that the observed
covariates include all common causes of the treatment assignment and outcome. This assumption is
fundamentally untestable from observed data, but its violation can induce bias in the estimation of
the treatment effect — the unobserved confounding may completely or in part explain the observed
association. Our aim in this part is to develop a sensitivity analysis tool to aid in reasoning about
potential bias induced by unobserved confounding.
Intuitively, if we estimate a large positive effect then we might expect the real effect is also positive,
even in the presence of mild unobserved confounding. For example, consider the association between
smoking and lung cancer. One could argue that this association arises from a hormone that both
predisposes carriers to both an increased desire to smoke and to a greater risk of lung cancer. However,
the association between smoking and lung cancer is large — is it plausible that some unknown
hormonal association could have a strong enough influence to explain the association? Cornfield et al.
[Cor+59] showed that, for a particular observational dataset, such an umeasured hormone would
need to increase the probability of smoking by at least a factor of nine. This is an unreasonable effect
size for a hormone, so they conclude it’s unlikely the causal effect can be explained away.
We would like a general procedure to allow domain experts to make judgments about whether
plausible confounding is “mild” relative to the “large” effect. In particular, the domain expert must
translate judgments about the strength of the unobserved confounding into judgments about the
bias induced in the estimate of the effect. Accordingly, we must formalize what is meant by strength
of unobserved confounding, and to show how to translate judgments about confounding strength into
judgments about bias.
A prototypical example, due to Imbens [Imb03] (building on [RR83]), illustrates the broad approach.
As above, the observed data consists of a treatment A, an outcome Y , and covariates X that may
causally affect the treatment and outcome. Imbens [Imb03] then posits an additional unobserved
binary confounder U for each patient, and supposes that the observed data and unobserved confounder
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1210
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
were generated according to the following assumption, known as Imbens’ Sensitivity Model:
Ui
iid∼ Bern(1/2) (36.96)
Ai
|Xi
, Ui
ind∼ Bern(sig(γXi + αUi)) (36.97)
Yi
|Xi
, Ai
, Ui
ind∼ N (τAi + βXi + δUi
, σ2
). (36.98)
where sig is the sigmoid function.
If we had observed Ui
, we could estimate (τ, ˆ γ, ˆ β, ˆ α, ˆ
ˆδ, σˆ
2
) from the data and report τˆ as the
estimate of the average treatment effect. Since Ui
is not observed, it is not possible to identify the
parameters from the data. Instead, we make (subjective) judgments about plausible values of α —
how strongly Ui affects the treatment assignment — and δ — how strongly Ui affects the outcome.
Contingent on plausible α = α
∗ and δ = δ
∗
, the other parameters can be estimated. This yields an
estimate of the treatment effect τˆ(α
∗
, δ∗
) under the presumed values of the sensitivity parameters.
The approach just outlined has a major drawback: it relies on a parametric model for the full data
generating process. The assumed model is equivalent to assuming that, had U been observed, it
would have been appropriate to use logistic regression to model treatment assignment, and linear
regression to model the outcome. This assumption also implies a simple, parametric model for the
relationships governing the observed data. This restriction is out of step with modern practice, where
we use flexible machine-learning methods to model these relationships. For example, the assumption
forbids the use of neural networks or random forests, though such methods are often state-of-the-art
for causal effect estimation.
Austen plots We now turn to developing an alternative an adaptation of Imbens’ approach that
fully decouples sensitivity analysis and modeling of the observed data. Namely, the Austen plots
of [VZ20]. An example Austen plot is shown in Figure 36.7. The high-level idea is to posit a
generative model that uses a simple, interpretable parametric form for the influence of the unobserved
confounder, but that puts no constraints on the model for the observed data. We then use the
parametric part of the model to formalize “confounding strength” and to compute the induced bias
as a function of the confounding.
Austen plots further adapt two strategies pioneered by Imbens [Imb03]. First, we find a parame￾terization of the model so that the sensitivity parameters, measuring strength of confounding, are on
a standardized, unitless scale. This allows us to compare the strength of hypothetical unobserved
confounding to the strength of observed covariates, measured from data. Second, we plot the curve
of all values of the sensitivity parameter that would yield given level of bias. This moves the analyst
judgment from “what are plausible values of the sensitivity parameters?” to “are sensitivity parameters
this extreme plausible?”
Figure 36.7, an Austen plot for an observational study of the effect of combination medications on
diastolic blood pressure, illustrates the idea. A bias of 2 would suffice to undermine the qualitative
conclusion that the blood-pressure treatment is effective. Examining the plot, an unobserved
confounder as strong as age could induce this amount of confounding, but no other (group of)
observed confounders has so much influence. Accordingly, if a domain expert thinks an unobserved
confounder as strong as age is unlikely then they may conclude that the treatment is likely effective.
Or, if such a confounder is plausible, they may conclude that the study fails to establish efficacy.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.7. CREDIBILITY CHECKS
Figure 36.7: Austen plot showing how strong an unobserved confounder would need to be to induce a bias
of 2 in an observational study of the effect of combination blood pressure medications on diastolic blood
pressure [Dor+16]. We chose this bias to equal the nominal average treatment effect estimated from the data.
We model the outcome with Bayesian Additive Regression Trees and the treatment assignment with logistic
regression. The curve shows all values treatment and outcome influence that would induce a bias of 2. The
colored dots show the influence strength of (groups of) observed covariates, given all other covariates. For
example, an unobserved confounder with as much influence as the patient’s age might induce a bias of about
2.
Setup The data are generated independently and identically (Yi
, Ai
, Xi
, Ui)
iid∼ P, where Ui
is not
observed and P is some unknown probability distribution. The approach in Section 36.4 assumes that
the observed covariates X contain all common causes of Y and A. If this ‘no unobserved confounding’
assumption holds, then the ATE is equal to parameter, τ , of the observed data distribution, where
τ = E[E[Y |X, A = 1] − E[Y |X, A = 0]]. (36.99)
This observational parameter is then estimated from a finite data sample. Recall from Section 36.4 that
this involves estimating the conditional expected outcome Q(A, X) = E[Y |A, X] and the propensity
score g(X) = P(A = 1|X), then plugging these into an estimator τˆ.
We are now concerned with the case of possible unobserved confounding. That is, where U causally
affects Y and A. If there is unobserved confounding then the parameter τ is not equal to the
ATE, so τˆ is a biased estimate. Inference about the ATE then divides into two tasks. First, the
statistical task: estimating τ as accurately as possible from the observed data. And, second, the
causal (domain-specific) problem of assessing bias = ATE − τ . We emphasize that our focus here is
bias due to causal misidentification, not the statistical bias of the estimator. Our aim is to reason
about the bias induced by unobserved confounding — the second task — in a way that imposes no
constraints on the modeling choices for Qˆ, gˆ, and τˆ used in the statistical analysis.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1212
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Sensitivity model Our sensitivity analysis should impose no constraints on how the observed
data is modeled. However, sensitivity analysis demands some assumption on the relationship between
the observed data and the unobserved confounder. It is convenient to formalize such assumptions
by specifying a probabilistic model for how the data is generated. The strength of confounding is
then formalized in terms of the parameters of the model (the sensitivity parameters). Then, the
bias induced by the confounding can be derived from the assumed model. Our task is to posit a
generative model that both yields a useful and easily interpretable sensitivity analysis, and that
avoids imposing any assumptions about the observed data.
To begin, consider the functional form of the sensitivity model used by Imbens [Imb03].
logit(P(A = 1|x, u)) = h(x) + αu (36.100)
E[Y |a, x, u] = l(a, x) + δu, (36.101)
for some functions h and l. That is, the propensity score is logit-linear in the unobserved confounder,
and the conditional expected outcome is linear.
By rearranging Equation (36.100) to solve for u and plugging in to Equation (36.101), we see
that it’s equivalent to assume E[Y |t, x, u] = ˜l(t, x) + ˜δlogitP(A = 1|x, u). That is, the unobserved
confounder u only influences the outcome through the propensity score. Accordingly, by positing a
distribution on P(A = 1|x, u) directly, we can circumvent the need to explicitly articulate U (and h).
Definition 36.7.1. Let g˜(x, u) = P(A = 1|x, u) denote the propensity score given observed covariates
x and the unobserved confounder u.
The insight is that we can posit a sensitivity model by defining a distribution on g˜ directly. We
choose:
g˜(X, U)|X ∼ Beta(g(X)(1/α − 1),(1 − g(X))(1/α − 1)).
That is, the full propensity score g˜(X, U) for each unit is assumed to be sampled from a Beta
distribution centered at the observed propensity score g(X). The sensitivity parameter α plays the
same role as in Imbens’ model: it controls the influence of the unobserved confounder U on treatment
assignment. When α is close to 0 then g˜(X, U)|X is tightly concentrated around g(X), and the
unobserved confounder has little influence. That is, U minimally affects our belief about who is
likely to receive treatment. Conversely, when α is close to 1 then g˜ concentrates near 0 and 1; i.e.,
knowing U would let us accurately predict treatment assignment. Indeed, it can be shown that α is
the change in our belief about how likely a unit was to have gotten the treatment, given that they
were actually observed to be treated (or not):
α = E[˜g(X, U)|A = 1] − E[˜g(X, U)|A = 0]. (36.102)
With the g˜ model in hand, we define the Austen sensitivity model as follows:
g˜(X, U)|X ∼ Beta(g(X)(1/α − 1),(1 − g(X))(1/α − 1)) (36.103)
A|X, U ∼ Bern(˜g(X, U)) (36.104)
E[Y |A, X, U] = Q(A, X) + δ
￾
logit˜g(X, U) − E[logit˜g(X, U)|A, X]

. (36.105)
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.7. CREDIBILITY CHECKS
This model has been constructed to satisfy the requirement that the propensity score and conditional
expected outcome are the g and Q actually present in the observed data:
P(A = 1|X) = E[E[T|X, U]|X] = E[˜g(X, U)|X] = g(X)
E[Y |A, X] = E[E[Y |A, X, U]|A, X] = Q(A, X).
The sensitivity parameters are α, controlling the dependence between the unobserved confounder the
treatment assignment, and δ, controlling the relationship with the outcome.
Bias We now turn to calculating the bias induced by unobserved confounding. By assumption, X
and U together suffice to render the average treatment effect identifiable as:
ATE = E[E[Y |A = 1, X, U] − E[Y |A = 0, X, U]].
Plugging in our sensitivity model yields,
ATE = E[Q(1, X) − Q(0, X)] + δ(E[logit˜g(X, U)|X, A = 1] − E[logit˜g(X, U)|X, A = 0]).
The first term is the observed-data estimate τ , so
bias = δ(E[logit˜g(X, U)|X, A = 1] − E[logit˜g(X, U)|X, A = 0]).
Then, by invoking beta-Bernoulli conjugacy and standard beta identities,11 we arrive at,
Theorem 6. Under the Austen sensitivity model, Equation (36.105), an unobserved confounder with
influence α and δ induces bias in the estimated treatment effect equal to
bias =
δ
1/α − 1
E
 1
g(X)
+
1
1 − g(X)
].
That is, the amount of bias is determined by the sensitivity parameters and by the realized
propensity score. Notice that more extreme propensity scores lead to more extreme bias in response
to unobserved confounding. This means, in particular, that conditioning on a covariate that affects
the treatment but that does not directly affect the outcome (an instrument) will increase any bias
due to unobserved confounding. This general phenomena is known as z-bias.
Sensitivity parameters The Austen model provides a formalization of confounding strength in
terms of the parameters α and δ and tells us how much bias is induced by a given strength of
confounding. This lets us translate judgments about confounding strength to judgments about bias.
However, it is not immediately obvious how to translate qualitative judgements such as “I think any
unobserved confounder would be much less important than age” to judgements about the possible
values of the sensitivity parameters.
First, because the scale of δ is not fixed, it may be difficult to compare the influence of potential
unobserved confounders to the influence of reference variables. To resolve this, we reexpress the
outcome-confounder strength in terms of the (non-parametric) partial coefficient of determination:
R
2
Y,par(α, δ) = 1 −
E(Y − E[Y |A, X, U])2
E(Y − Q(A, X))
2
.
The key to computing the reparameterization is the following result
11. We also use the recurrence relation ψ(x + 1) − ψ(x) = 1/x, where ψ is the digamma function.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1214
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Theorem 7. Under the Austen sensitivity model, Equation (36.105), the outcome influence is
R
2
Y,par(α, δ) = δ
2X
1
a=0
E

ψ1
￾
g(X)
a
(1 − g(X))1−a
(
1/α − 1) + 1[A = a]

E[(Y − Q(A, X))
2]
,
where ψ1 is the trigamma function.
See Veitch and Zaveri [VZ20] for the proof.
By design, α — the strength of confounding influence on on treatment assignment — is already
on a fixed, unitless scale. However, because the measure is tied to the model it may be difficult
to interpret, and it is not obvious how to compute reference confounding strength values from the
observed data. The next result clarifies these issues.
Theorem 8. Under the Austen sensitivity model, Equation (36.105),
α = 1 −
E[˜g(X, U)(1 − g˜(X, U))]
E[g(X)(1 − g(X))]
.
See Veitch and Zaveri [VZ20] for the proof. That is, the sensitivity parameter α is measures how
much more extreme the propensity scores become when we condition on U. That is, α is a measure
of the extra predictive power U adds for A, above and beyond the predictive power in X. It may
also be insightful to notice that
α = R
2
A,par = 1 −
E[(A − g˜(X, U))2
]
E[(A − g(X))2]
. (36.106)
That is, α is just the (non-parametric) partial coefficient of determination of U on A—the same
measure used for the outcome influence. (To see this, just expand the expectations conditional on
A = 1 and A = 0).
Estimating bias In combination, Theorems 6 and 7 yield an expression for the bias in terms of α
and R2
Y,par. In practice, we can estimate the bias induced by confounding by fitting models for Qˆ
and gˆ and replacing the expectations by means over the data.
36.7.2.1 Calibration using observed data
The analyst must make judgments about the influence a hypothetical unobserved confounder might
have on treatment assignment and outcome. To calibrate such judgments, we’d like to have a reference
point for how much the observed covariates influence the treatment assignment and outcome. In the
sensitivity model, the degree of influence is measured by partial R2
Y
and α. We want to measure the
degree of influence of an observed covariate Z given the other observed covariates X\Z.
For the outcome, this can be measured as:
R
2
Y ·Z|T ,X\Z , 1 −
E(Y − Q(A, X))2
E(Y − E[Y |A, X\Z])
2
.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2021
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.7. CREDIBILITY CHECKS
In practice, we can estimate the quantity by fitting a new regression model QˆZ that predicts Y from
A and X\Z. Then we compute
R
2
Y ·Z|T ,X\Z = 1 −
1
n
P
i
(yi − Qˆ(ti
, xi))2
1
n
P
i
(yi − QˆZ(ti
, xi\zi))
2
.
Using Theorem 8, we can measure influence of observed covariate Z on treatment assignment given
X\Z in an analogous fashion to the outcome. We define gX\Z(X\Z) = P(A = 1|X\Z), then fit a
model for gX\Z by predicting A from X\Z, and estimate
αˆZ|X\Z = 1 −
1
n
P
i
gˆ(xi)(1 − gˆ(xi))
1
n
P
i
gˆX\Z(xi\zi)(1 − gˆX\Z(xi\zi)).
Grouping covariates The estimated values αˆX\Z and Rˆ2
Y,X\Z measure the influence of Z condi￾tioned on all the other confounders. In some cases, this can be misleading. For example, if some piece
of information is important but there are multiple covariates providing redundant measurements,
then the estimated influence of each covariate will be small. To avoid this, group together related
or strongly dependent covariates and compute the influence of the entire group in aggregate. For
example, grouping income, location, and race as ‘socioeconomic variables’.
36.7.2.2 Practical use
We now have sufficient results to produce Austen plots such as Figure 36.7. At a high level, the
procedure is:
1. Produce an estimate τˆ using any modeling tools. As a component of this, estimate the propensity
score gˆ and conditional outcome model Qˆ.
2. Pick a level of bias that would suffice to change the qualitative interpretation of the estimate (e.g.,
the lower bound of a 95% confidence interval).
3. Plot the values of α and R2
Y,par that would suffice to induce that much bias. This is the black
curve on the plot. To calculate these values, use Theorems 6 and 7 together with the estimated gˆ
and Qˆ.
4. Finally, compute reference influence level for (groups of) observed covariates. In particular, this
requires fitting reduced models for the conditional expected outcome and propensity that do not
use the reference covariate as a feature.
In practice, an analyst only needs to do the model fitting parts themselves. The bias calculations,
reference value calculations, and plotting can be done automatically with standard libraries.12
.
Austen plots are predicated on Equation (36.105). This assumption replaces the purely parametric
Equation (36.98) with a version that eliminates any parametric requirements on the observed data.
However, we emphasize that Equation (36.105) does, implicitly, impose some parametric assumption
on the structural causal relationship between U and A, Y . Ultimately, any conclusion drawn from
12. See github.com/vveitch/causality-tutorials/blob/main/Sensitivity_Analysis.ipynb.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1216
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
the sensitivity analysis depends on this assumption, which is not justified on any substantive grounds.
Accordingly, such sensitivity analyses can only be used to informally guide domain experts. They
do not circumvent the need to thoroughly adjust for confounding. This reliance on a structural
assumption is a generic property of sensitivity analysis.13 Indeed, there are now many sensitivity
analysis models that allow the use of any machine learning model in the data analysis [e.g., RRS00;
FDF19; She+11; HS13; BK19; Ros10; Yad+18; ZSB19; Sch+21a]. However, none of these are yet in
routine use in practice. We have presented Austen plots here not because they make an especially
virtuous modeling assumption, but because they are (relatively) easy to understand and interpret.
Austen plots are most useful in situations where the conclusion from the plot would be ‘obvious’
to a domain expert. For instance, in Figure 36.7, we can be confident that an unobserved confounder
similar to socioeconomic status would not induce enough bias to change the qualitative conclusion.
By contrast, Austen plots should not be used to draw conclusions such as, “I think a latent confounder
could only be 90% as strong as ‘age’, so there is evidence of a small non-zero effect”. Such nuanced
conclusions might depend on issues such as the particular sensitivity model we use, or finite-sample
variation of our bias and influence estimates, or on incautious interpretation of the calibration dots.
These issues are subtle, and it would be difficult resolve them to a sufficient degree that a sensitivity
analysis would make an analysis credible.
Calibration using observed data The interpretation of the observed-data calibration requires
some care. The sensitivity analysis requires the analyst to make judgements about the strength
of influence of the unobserved confounder U, conditional on the observed covariates X. However,
we report the strength of influence of observed covariate(s) Z, conditional on the other observed
covariates X\Z. The difference in conditioning sets can have subtle effects.
Cinelli and Hazlett [CH20] give an example where Z and U are identical variables in the true
model, but where influence of U given A, X is larger than the influence of Z given A, X\Z. (The
influence of Z given X\Z, U would be the same as the influence of U given X). Accordingly, an
analyst is not justified in a judgment such as, “I know that U and Z are very similar. I see Z has
substantial influence, but the dot is below the line. Thus, U will not undo the study conclusions”. In
essence, if the domain expert suspects a strong interaction between U and Z then naively eyeballing
the dot-vs-line position may be misleading. A particular subtle case is when U and Z are independent
variables that both strongly influence A and Y . The joint influence on A creates an interaction effect
between them when A is conditioned on (the treatment is a collider). This affects the interpretation
of R2
Y ·U|X,A. Indeed, we should generally be skeptical of sensitivity analysis interpretation when it is
expected that a strong confounder has been omitted. In such cases, our conclusions may depend
substantively on the particular form of our sensitivity model, or other unjustifiable assumptions.
Although the interaction problem is conceptually important, its practical significance is unclear.
We often expect the opposite effect: if U and Z are dependent (e.g., race and wealth) then omitting
U should increase the apparent importance of Z — leading to a conservative judgement (a dot
artifically towards the top right part of the plot).
13. In extreme cases, there can be so little unexplained variation in A or Y that only a very weak confounder could be
compatible with the data. In this case, essentially assumption free sensitivity analysis is possible [Man90].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.8. THE DO-CALCULUS
36.8 The do-calculus
We have seen several strategies for identifying causal effects as parameters of observational distribu￾tions. Confounder adjustment (Section 36.4) relied only on the assumed causal graph (and overlap),
which specified that we observe all common causes of A and Y . On the other hand, instrumental
variable methods and difference-in-differences each relied on both an assumed causal graph and
partial functional form assumptions about the underlying structural causal model. Because functional
form assumptions can be quite difficult to justify on substantive grounds, it’s natural to ask when
causal identification is possible from the causal graph alone. That is, when can we be agnostic to the
particular functional form of the structural causal models?
There is a general “calculus of intervention”, known as the do-calculus, that gives a general
recipe for determining when the causal assumptions expressed in a causal graph can be used to
identify causal effects [Pea09c]. The do-calculus is a set of three rewrite rules that allows us to
replace statements where we condition on variables being set by intervention, e.g. P(Y |do(A = a)),
with statements involving only observational quantities, e.g. EX[P(Y |A = a, X)]. When causal
identification is possible, we can repeatedly apply the three rules to boil down our target causal
parameter into an expression involving only the observational distribution.
36.8.1 The three rules
To express the rules, let X, Y , Z, and W be arbitrary disjoint sets of variables in a causal DAG G.
Rule 1 The first rule allows us to insert or delete observations z:
p(y|do(x), z, w) = p(y|do(x), w) if (Y ⊥ Z|X, W)GX
(36.107)
where GX denotes cuting edges going into X, and (Y ⊥ Z|X, W)GX
denotes conditional independence
in the mutilated graph. The rule follows from d-separation in the mutilated graph. This rule just
says that conditioniong on irrelevant variables leaves the distribution invariant (as we would expect).
Rule 2 The second rule allows us to replace do(z) with conditioning on (seeing) z. The simplest
case where can do this is: if Z is a root of the causal graph (i.e., it has no causal parents) then
p(y|do(z)) = p(y|z). The reason is that the do operator is equivalent to conditioning in the mutilated
causal graph where all the edges into Z are removed, but, because Z is a root, the mutilated graph
is just the original causal graph. The general form of this rule is:
p(y|do(x), do(z), w) = p(y|do(x), z, w) if (Y ⊥ Z|X, W)GXZ
(36.108)
where GXZ cuts edges going into X and out of Z. Intutively, we can replace do(z) by z as long as
there are no backdoor (non-directed) paths between z and y. If there are in fact no such paths, then
cutting all the edges going out of Z will mean there are no paths connecting Z and Y , so that Y ⊥⊥ Z.
The rule just generalizes this line of reasoning to allow for extra observed and intervened variables.
Rule 3 The third rule allows us to insert or delete actions do(z):
p(y|do(x), do(z), w) = p(y|do(x), w) if (Y ⊥ Z|X, W)GXZ∗
(36.109)
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1218
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
where GXZ∗ cuts edges going into X and Z
∗
, and where Z
∗
is the set of Z-nodes that are not
ancestors of any W-node in GX. Intuitively, this condition corresponds to intervening on X, and
checking whether the distribution of Y is invariant to any intervention that we could apply on Z.
36.8.2 Revisiting backdoor adjustment
We begin with a more general form of the adjustment formula we used in Section 36.4.
First, suppose we observe all of A’s parents, call them X. For notational simplicity, we’ll assume
for the moment that X is discrete. Then,
p(Y = y|do(A = a)) = X
x
p(Y = y|x, do(A = a))p(x|do(A = a)) (36.110)
=
X
x
p(Y = y|x, A = a)p(x). (36.111)
The first line is just a standard probability relation (marginalizing over z). We are using causal
assumptions in two ways in the second line. First, p(x|do(A = a)) = p(x): the treatment has
no causal effect on Z, so interventions on A don’t change the distribution of Z. This is rule 3,
Equation (36.109). Second, p(Y = y|z, do(A = a)) = p(Y = y|z, A = a). This equality holds because
conditioning on the parents blocks all non-directed paths from A to Y , reducing the causal effect to
be the same as the observational effect. The equality is an application of rule 2, Equation (36.108).
Now, what if we don’t observe all the parents of A? The key issue is backdoor paths: paths
between A and Y that contain an arrow into A. These paths are the general form of the problem
that occurs when A and Y share a common cause. Suppose that we can find a set of variables S
such that (1) no node in S is a descendant of A; and (2) S blocks every backdoor path between A
and Y . Such a set is said to satisfy the backdoor criterion. In this case, we can use S instead of
the parents of X in the adjustment formula, Equation (36.111). That is,
p(Y = y|do(A = a)) = ES[p(Y = y|S, A = a)]. (36.112)
The proof follows the invocation of rules 3 and 2, in the same way as for the case where S is just the
parents of A. Notice that requiring S to not contain any descendants of A means that we don’t risk
conditioning on any variables that mediate the effect, nor any variables that might be colliders —
either would undermine the estimate.
The backdoor adjustment formula generalizes the adjust-for-parents approach and adjust-for-all￾common-causes approach of Section 36.4. That’s because both the parents of A and the common
causes satisfy the backdoor criterion.
In practice, the full distribution p(Y = y|do(A = a)) is rarely used as the causal target. Instead,
we try to estimate a low-dimensional parameter of this distribution, such as the average treatment
effect. The adjustment formula immediately translates in the obvious way. If we define
τ = ES[E[Y |A = 1, S] − E[Y |A = 0, S]],
then we have that ATE = τ whenever S satisfies the backdoor criteria. The parameter τ can then
be estimated from finite data using the methods described in Section 36.4, using S in place of the
common causes X.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.8. THE DO-CALCULUS
A M Y
U
Figure 36.8: Causal graph illustrating the frontdoor criterion setup. The effect of the treatment A on outcome
Y is entirely mediated by mediator M. This allows us infer the causal effect even if the treatment and outcome
are confounded by U.
36.8.3 Frontdoor adjustment
Backdoor adjustment is applicable if there’s at least one observed variable on every backdoor path
between A and Y . As we have seen, identification is sometimes still possible even when this condition
doesn’t hold. Frontdoor adjustment is another strategy of this kind. Figure 36.8 shows the causal
structure that allows this kind of adjustment strategy. Suppose we’re interested in the effect of
smoking A on developing cancer Y , but we’re concerned about some latent genetic confounder U.
Suppose that all of the directed paths from A to Y pass through some set of variables M. Such
variables are called mediators. For example, the effect of smoking on lung cancer might be entirely
mediated by the amount of tar in the lungs and measured tissue damage. It turns out that if all
such mediators are observed, and the mediators do not have an unobserved common cause with A or
Y , then causal identification is possible. To understand why this is true, first notice that we can
identify the causal effect of A on M and the causal effect of M on A, both by backdoor adjustment.
Further, the mechanism of action of A on Y is: A changes M which in turn changes Y . Then, we
can combine these as:
p(Y |do(A = a)) = X
m
p(Y |do(M = m))p(M = m|do(A = a)) (36.113)
=
X
m
X
a′
p(Y |a
′
, m)p(a
′
)p(m|a) (36.114)
The second line is just backdoor adjustment applied to identify each of the do expressions (note that
A blocks the M-Y backdoor path through U).
Equation (36.114) is called the front-door formula [Pea09b, §3.3.2]. To state the result in more
general terms, let us introduce a definition. We say a set of variables M satisfies the front-door
criterion relative to an ordered pair of variables (A, Y ) if (1) M intercepts all directed paths from
A to Y ; (2) there is no unblocked backdoor path from A to M; and (3) all backdoor paths from M
to Y are blocked by A. If M satisfies this criterion, and if p(A, M) > 0 for all values of A and M,
then the causal effect of A on Y is identifiable and is given by Equation (36.114).
Let us interpret this theorem in terms of our smoking example. Condition 1 means that smoking
A should have no effect on cancer Y except via tar and tissue damage M. Conditions 2 and 3 mean
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1220
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
that the genotype U cannot have any effect on M except via smoking A. Finally, the requirement
that p(A, M) > 0 for all values implies that high levels of tar in the lungs must arise not only due to
smoking, but also other factors (e.g., pollutants). In other words, we require p(A = 0, M = 1) > 0 so
we can assess the impact of the mediator in the untreated setting.
We can now use the do-calculus to derive the frontdoor criterion; following [PM18b, p236]. Assuming
the causal graph G shown in Figure 36.8:
p(y|do(a)) =
X
m
p(y|do(a), m)p(m|do(a)) (probability axioms)
=
X
m
p(y|do(a), do(m))p(m|do(a)) (rule 2 using GST )
=
X
m
p(y|do(a), do(m))p(m|a) (rule 2 using GS)
=
X
m
p(y|do(m))p(m|a) (rule 3 using GST
∗ )
=
X
a′
X
m
p(y|do(m), a
′
)p(a
′
|do(m))p(m|a) (probability axioms)
=
X
a′
X
m
p(y|m, a′
)p(a
′
|do(m))p(m|a) (rule 2 using GT )
=
X
a′
X
m
p(y|m, a′
)p(a
′
)p(m|a) (rule 3 using GT
∗ )
Estimation To estimate the causal distribution from data using the frontdoor criterion we need to
estimate each of p(y|m, a), p(a), and p(m|a). In practice, we can fit models pˆ(y|m, a) by predicting
Y from M and A, and pˆ(m|a) by predicting M from A. Then, using the empirical distribution to
estimate p(a), the final estimate is:
1
|A|
X
a′
X
m
pˆ(y|m, a′
)ˆp(m|a), (36.115)
where |A| is the number of treatments.
We usually have more modest targets than the full distribution p(y|do(a)). For instance, we may
be content with just estimating the average treatment effect. It’s straightforward to derive a formula
for this using the frontdoor adjustment. Similarly to backdoor adjustment, more advanced estimators
of the ATE through frontdoor effect are possible in principle. For example, we might combine fitted
models for E[Y |m, a] and P(M|a). See Fulcher et al. [Ful+20] for an approach to robust estimation
via front door adjustment, as well as a generalization of the front door approach to more general
settings.
36.9 Further reading
There is an enormous and growing literature on the intersection of causality and machine learning.
First, there are many textbooks on theoretical and practical elements of causal inference. These
include Pearl [Pea09c], focused on causal graphs, Angrist and Pischke [AP08], focused on econometrics,
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
36.9. FURTHER READING
Hernán and Robins [HR20b], with roots in epidemiology, Imbens and Rubin [IR15], with origin in
statistics, and Morgan and Winship [MW15], for a social sciences perspective. The introduction to
causality in Shalizi [Sha22, §7] is also recommended, particularly the treatment of matching.
Double machine-learning has featured prominently in this chapter. This is a particular instantiation
of non-parametric estimation. This topic has substantial theoretical and practical importance in
modern causal inference. The double machine learning work includes estimators for many commonly
encountered scenarios [Che+17e; Che+17d]. Good references for a lucid explanation of how and
why non-parametric estimation works include [Ken16; Ken17; FK21]. Usually, the key guarantees of
non-parametric estimator are asymptotic. Generally, there are many estimators that share optimal
asymptotic guarantees (e.g., the AIPTW estimator given in Equation (36.30)). Although these are
asymptotically equivalent, in finite samples their behavior can be very different. There are estimators
that preserve asymptotic guarantees but aim to improve performance in practical finite sample
regimes [e.g., vR11].
There is also considerable interest in the estimation of heterogeneous treatment effects. The
question here is: what effect would this treatment have when applied to a unit with such-and-such
specific characteristics? E.g., what is the effect of this drug on women over the age of 50? The causal
identification arguments used here are more-or-less the same as for the estimation of average case
effects. However, the estimation problems can be substantially more involved. Some reading includes
[Kün+19; NW20; Ken20; Yad+21].
There are several commonly applicable causal identification and estimation strategies beyond the
ones we’ve covered in this chapter. Regression discontinuity designs rely on the presence of
some sharp, arbitrary non-linearity in treatment assignment. For example, eligibility for some aid
programs is determined by whether an individual has income below or above a fixed amount. The
effect of the treatment can be studied by comparing units just below and just above this threshhold.
Synthetic controls are a class of methods that try to study the effect of a treatment on a given
unit by constructing a synthetic version of that unit that acts as a control. For example, to study the
effect of legislation banning smoking indoors in California, we can construct a synthetic California
as a weighted average of other states, with weights chosen to balance demographic characteristics.
Then, we can compare the observed outcome of California with the outcome of the synthetic control,
constructed as the weighted average of the outcomes of the donor states. See Angrist and Pischke
[AP08] for a textbook treatment of both strategies. Closely related are methods that use time series
modeling to create synthetic outcomes. For example, to study the effect of an advertising campaign
beginning at time T on product sales Yt, we might build a time series model for Yt using data in the
t < T period, and then use this model to predict the values of (Yˆ
t)t>T we would have seen had the
campaign not been run. We can estimate the causal effect by comparing the factual, realized Yt to
the predicted, counterfactual, Yˆ
t. See Brodersen et al. [Bro+15] for an instantiation of this idea.
In this chapter, our focus has been on using machine learning tools to estimate causal effects.
There is also a growing interest in using the ideas of causality to improve machine learning tools.
This is mainly aimed at building predictors that are robust when deployed in new domains [SS18b;
SCS19; Arj+20; Mei18b; PBM16a; RC+18; Zha+13a; Sch+12b; Vei+21] or that do not rely on
particular ‘spurious’ correlations in the training data [RPH21; Wu+21; Gar+19; Mit+20; WZ19;
KCC20; KHL20; TAH20; Vei+21].
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND licenseIndex
Q-function, 1121
χ
2
test, 133
f-MAX, 1172
#P-hard, 427
Global explanation, 1072
Local explanation, 1072
intrinsic, 1078
“arms”, 1105
“do” operator, 214
1/f, 15
2d lattice model, 167
3-SAT, 427
8-queens problem, 299
80-20 rule, 16
Sylvester determinant lemma, 698
A* search, 1154
A/B test, 1105
A2C, 1149
A3C, 1149
ABC, 563, 884
abduction, 216
absorbing state, 53, 879, 1119
abstain, 736
accept, 494
acquisition function, 292, 294,
1127, 1128
action, 1095, 1110
action nodes, 1101
action-value function, 1121
Actionability, 1077
actions, 1095
activation function, 624
active inference, 1170
active learning, 291, 296, 333, 698,
1126
actor critic, 1137
actor-critic, 1148
acyclic directed mixed graph, 199
AD, 255
adapt, 738
adaptive filtering, 1000, 1005
adaptive importance sampling,
469
adaptive MCMC, 498
adaptive policies, 1109
adaptive prediction sets, 581
adaptive rejection sampling, 483
adaptive resampling, 547
adaptive tempering, 559
add-one smoothing, 51, 66
addition rule, 7
additive intervention, 214
additive scalar bijection, 823
additive unobserved confounding,
1198
ADF, 385
adjoint sensitivity method, 835
ADMG, 199
admissable policy, 1097
admissible, 1097, 1154
admixture mixture, 953
admixture model, 18, 951, 953
advantage actor critic, 1149
advantage function, 1121
adversarial attack, 757
adversarial autoencoder, 790
adversarial bandit, 1110
adversarial image, 757
adversarial inverse RL, 1172
adversarial risk, 761
adversarial stickers, 758
adversarial training, 761
ADVI, 348, 446
AEP, 235
affine autoregressive flows, 828
affine flow, 822
affine scalar bijection, 823
affine transformation, 822
affinity propagation, 420
agent, 1095, 1110, 1118
aggregate posterior, 246
aggregated posterior, 252, 786
AI, 245
AIPTW, 1189
AIRL, 1172
Akaike information criterion, 127
aleatoric uncertainty, 71, 576
ALI, 903
alpha divergence, 56
alpha posterior, 656
alphafold, 170
AlphaGo, 1155
AlphaZero, 1155
alternative hypothesis, 132
AMD, 426
amortization gap, 439
amortized inference, 422, 781, 782
amortized variational inference,
438
anadjusted Langevin algorithm,
516
analysis by synthesis, 917
analysis-by-synthesis, 1049
ancestor, 404
ancestral graph, 180
ancestral sampling, 154, 305
annealed importance sampling,
486, 559, 776, 839
annotation shift, 731
annulus, 23
anomaly detection, 733, 939, 1018
anti-causal classifier, 142
anti-Hebbian term, 843
anticausal prediction, 729
antiferromagnetic, 167
antithetic sampling, 490
aperiodic, 54
apprenticeship learning, 1170
approximate Bayesian computa￾tion, 563, 884
approximate dynamic program￾ming, 1123
approximate inference, 342
approximate linear programming,
1123
approximate minimum degree, 426
architectural methods, 755
ARD, 598, 677
ARD kernel, 677
arithmetic circuits, 204
arithmetic coding, 245
ARM, 765, 811
ARMA, 1013
arrow of time, 1021
artificial dynamics, 384
ASOS, 1003
ASR, 405, 767
associative Markov model, 169
associative Markov network, 167
associative memory, 170
assumed density filtering, 385
asymmetric numeral systems, 2451224
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
asymptotic equipartition property,
235
asymptotic normality, 74
asynchrononous advantage actor
critic, 1149
asynchronous updates, 417
asynchronous value iteration, 1124
ATE, 1174
ATT, 1194
attention, 629
attention layer, 629
attention score, 629
attention weight, 629
attribute, 205
audio-visual speech recognition,
992
augmented DAG, 214
augmented inverse probability of
treatment weighted es￾timator, 1189
augmented reality, 554
Austen plots, 1210
Austen sensitivity model, 1212
auto-encoding SMC, 564
auto-regressive HMM, 972
Auto-Sklearn, 297
Auto-WEKA, 297
autoconj, 465
autocorrelation function, 525
autocorrelation time, 524
autodiff, 255
autoencoder, 634
autoencoders, 1050
automatic differentiation, 255
automatic differentiation varia￾tional inference, 348,
446
automatic relevance determination,
677, 939
automatic relevancy determination,
598, 642
automatic speech recognition, 405,
767, 989
autoregressive bijection, 827
autoregressive flows, 826
autoregressive model, 811
autoregressive models, 765, 912
auxiliary latent variables, 466
auxiliary variable deep generative
model, 466
auxiliary variables, 507
average causal effect, 1183
average treatment effect, 1174,
1182
average treatment effect on the
treated, 1194
axioms of probability, 7
axis aligned, 23
BA lower bound, 242
back translation, 738
backbone, 633
backcasting, 1023
backdoor criterion, 1218
backdoor paths, 1218
backoff smoothing, 116
backpropagation, 264
backup diagram, 1125
backwards Kalman gain, 365
backwards kernel, 558
backwards transfer, 754
BACS, 743
bagging, 651
balance the dataset, 732
balanced error rate, 604
BALD, 1130
Bambi, 588
bambi, 134
BAMDP, 1139
bandit problem, 1109
bandwidth, 770
Barlow Twins, 1057
base distribution, 819
base measure, 34
baseline, 489
baseline function, 268
basic random variables, 205
basin flooding, 300
basis functions, 967
batch active learning, 1130
batch ensemble, 652
batch normalization, 627
batch reinforcement learning, 1161
BatchBALD, 1131
batched Bayesian optimization,
297
Baum-Welch, 977, 980
Baum-Welch algorithm, 161
Bayes ball algorithm, 149
Bayes by backprop, 645
Bayes estimator, 1096
Bayes factor, 132
Bayes filter, 355, 397
Bayes model averaging, 121
Bayes nets, 143
Bayes risk, 1096
Bayes’ rule, 8
Bayes’ rule for Gaussians, 29
Bayes’ theorem, 8
Bayes-adaptive MDP, 1139
Bayes-Newton, 382
Bayesian active learning by dis￾agreement, 1130
Bayesian approach, 71
Bayesian dark knowledge, 656
Bayesian decision theory, 1096
Bayesian deep learning, 639
Bayesian estimation, 133
Bayesian factor regression, 943
Bayesian hypothesis testing, 132
Bayesian inference, 1, 63
Bayesian information criterion,
126
Bayesian lasso, 596
Bayesian model selection, 119
Bayesian multi net, 164
Bayesian networks, 143
Bayesian nonparametric, 1037
Bayesian nonparametric models,
533
Bayesian Occam’s razor, 119
Bayesian online changepoint detec￾tion, 995
Bayesian optimization, 291, 305,
675
Bayesian optimization algorithm,
305
Bayesian p-value, 130
Bayesian quadrature, 491
Bayesian risk, 1096
Bayesian statistics, 63, 72
Bayesian structural time series,
1016
Bayesian transfer learning, 642
BayesOpt, 291
BBB, 645
BBMM, 707
BBVI, 448
BDL, 639
Bean Machine, 210
bearings only tracking problem,
1010
behavior cloning, 1171
behavior policy, 1161
behavior-agnostic off-policy, 1161
BEiT, 1053
belief networks, 143
belief propagation, 395
belief state, 353, 355, 397, 576,
1112, 1139
belief states, 395
belief-state MDP, 1113
Bellman backup, 1123
Bellman error, 1121
Bellman residual, 1121
Bellman’s optimality equations,
1121
Berkson’s paradox, 146, 151
Bernoulli bandit, 1113
Bernoulli distribution, 9
Bernoulli mixture model, 922
BERT, 636, 794, 880, 1052
Bessel function, 18, 677
BEST, 134
best arm identification, 291, 1108
best-arm identification, 1111
best-first search, 1154
beta distribution, 17, 64
beta function, 12, 17
beta-VAE, 788
bi-directed graph, 200
BIC, 126, 716
BIC loss, 127
BIC score, 126
BiGAN, 903, 1050
bigram model, 49, 236
bigram statistics, 51
bijection, 44, 820
bilinear form, 631
binary entropy function, 233
binary logistic regression, 602
binomial coefficient, 9
binomial distribution, 9
binomial regression, 584
binomial test, 133
bit error, 411
bits, 222, 233
bits back coding, 248
bits per dimension, 775
BIVA, 800
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
INDEX
bivariate Gaussian, 22
black box attack, 759
black swan event, 69
blackbox, 448
blackbox EP, 474
blackbox matrix-matrix multiplica￾tion, 707
blackbox shift estimation, 742
blackbox variational inference, 448
blind inverse problem, 927
blind source separation, 962
block length, 249
block stacking, 1157
blocked Gibbs sampling, 505
BLOG, 210
BN, 627
BNP, 1037
BOA, 305
Bochner’s theorem, 680
BOCPD, 995
Boltzmann machine, 172
Boltzmann policy, 1138
bond variables, 509
Bonnet’s theorem, 270, 279
boolean satisfiability problems,
299
bootstrap, 73
bootstrap filter, 543
bootstrap sampling, 650
bootstrapping, 1137, 1141
Borel sigma-algebra, 6
Borel sigma-field, 6
borrow statistical strength, 108
bottom-up inference model, 800
bound optimization, 281, 283
Box-Muller, 481
BP, 395
branching factor, 236
Bregman divergence, 231, 232
Brier score, 572
BRMS, 588
Brownian motion, 516, 517, 678,
997
Brownian noise, 527, 867
BSS, 962
BSTS, 1016
BTT, 134
bucket elimination, 422
BUGS, 499
building blocks, 305, 623
burn-in phase, 518
burn-in time, 493
BYOL, 1057
calculus of intervention, 1217
calculus of variations, 43
calibrated, 572
calibration set, 580
canonical correlation analysis, 945,
1043
canonical form, 25, 34
canonical link function, 586
canonical parameters, 25, 34, 38,
177
CAQL, 1122
cart-pole swing-up, 1156
cascaded generation, 876
casino HMM, 971
CASP, 170
catastrophic forgetting, 754
categorical, 9
categorical distribution, 83
categorical PCA, 947, 957
CatPCA, 947
Cauchy, 12
Cauchy sequence, 691
causal classifier, 142
causal convolution, 812
causal DAGs, 729
causal discovery, 1035
Causal graphs, 1176
causal hierarchy, 215
causal impact, 216, 1021
Causal inference, 1173
causal Markov assumption, 211
causal model, 612
causal models, 211
causal prediction, 729
causal representation learning,
1059
causally sufficient, 211
causes, 611
causes of effects, 214
CAVI, 450, 450
cavity distribution, 473
CCA, 945
cdf, 6, 11
CEB, 253
CelebA, 773, 773, 783
Centered kernel alignment (CKA),
1043
centering matrix, 92
central composite design, 712
central interval, 67
central limit theorem, 479, 721
central moment, 13
centroid estimator, 1100
certify, 761
ceteris paribus, 216
chain components, 198
chain compositions, 260
chain graph, 181, 198, 199
chain rule, 259
chance nodes, 1101
change of variables, 44
changepoint detection, 732, 993,
995
channel coding, 217, 249
channel coding theorem, 420
Chapman-Kolmogorov, 48
Chapman-Kolmogorov equation,
355
characteristic length scale, 677
ChatGPT, 815
Chernoff-Hoeffding inequality,
1114
chi-squared distance, 57
chi-squared distribution, 14
chi-squared test, 140
children, 143
choice theory, 613
Cholesky decomposition, 481
Chomsky normal form, 188, 189
chordal, 194
Chow-Liu algorithm, 305
chromosomes, 302
CI, 143
circuits, 262
circular flow, 834
circular normal, 18
citation matching, 210
CKF, 379
clamped phase, 183, 843
class imbalance, 604
class incremental learning, 752
classical statistics, 72
classifier guidance, 875
classifier-free guidance, 876
Claude Shannon, 245
clausal form, 208
click through rate, 1108, 1111
clinical trials, 1111
CLIP, 817, 1056
clique, 165
clique tree, 428
cliques, 425
closed world assumption, 210,
1008
closing the loop, 555
closure, 179
cluster variational method, 418
clustering, 920
CMA-ES, 307, 1158
CMGF, 380
CNN, 633
co-information, 239
co-parents, 153
coalescence, 544
cocktail party problem, 962
code words, 245
codebook, 805
codebook loss, 806
codewords, 217
coffee, lemon, milk, and tea, 316
cold posterior, 656
collapsed, 161, 444
collapsed Gibbs sampler, 505
collapsed particles, 551
collective classification, 208
collider, 149, 1177
collocation, 1155
coloring, 499
commitment loss, 807
common corruptions, 727
common random number, 1157
common random numbers, 488
common random numbers trick,
447
compact support, 707
Compactness, sparsity, 1077
compatible, 1153
complement rule, 7
complementary log-log, 586
complete, 691
complete data, 182
Completeness, 1077, 1079
completing the square, 94
complexity penalty, 125
complier average treatment effect,
1200
components, 1013
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1226
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
composite likelihood, 184
compositional pattern-producing
network, 759
compression lemma, 226
computation graph, 623
computation tree, 415
concave, 42
concentration inequality, 1114
concentration of measure, 762
concept drift, 751
concept shift, 670, 731
concrete distribution, 272
condensation, 543
conditional entropy bottleck, 253
conditional expected outcome,
1186
conditional GAN, 902
conditional generative model, 765,
767
Conditional generative models, 902
conditional independence, 143
conditional KL divergence, 221
conditional log marginal likelihood,
123
conditional moments, 380
conditional moments Gaussian fil￾tering, 380
conditional parallel trends, 1206
conditional probability, 7
conditional probability distribu￾tion, 144
conditional probability table, 145
conditional random field, 185,
1101
conditional random fields, 165, 166
conditional shift, 731
conditional value at risk, 1135
conditionally conjugate, 92
conditioner, 826, 827
conditioning case, 145
conditioning matrix, 267
conductance, 519
confidence interval, 67, 79
confidence score, 734
conformal prediction, 579, 655,
733, 734, 755
conformal score, 579
conformalized quantile regression,
582
confounder, 201
confounders, 1184
conical combination, 824
conjugate, 342
conjugate gradients, 706
conjugate prior, 29, 34, 65, 83, 83
conjugate priors, 71
conjunction of features, 840
conjunctive normal form, 208
consensus sequence, 976
conservative policy iteration, 1151
constant symbols, 208
contact map, 170
content addressable memory, 170
content constrained, 760
context free grammar, 188
context variables, 746
Context., 1065
contextual bandit, 1110
contingency table, 140
continual learning, 664, 737, 750
continuation method, 534
continuing task, 1119
continuous normalizing flow, 870
continuous task-agnostic learning,
752
continuous time, 867
continuous-discrete SSM, 997
continuous-ranked probability
score, 1026
continuous-time flows, 834
contraction, 1123
contrastive divergence, 183, 842
contrastive learning, 1054
Contrastive multiview coding,
1055
Contrastiveness, 1079
control, 1105
control as inference, 1167
control theory, 1119
control variate, 489, 528
control variates, 268, 449
controller, 1119
converge, 519
conversions, 1108
convex BP, 418
convex combination, 66
ConvNeXt, 633
convolution, 625
convolutional layer, 626
convolutional Markov model, 813
convolutional neural network, 633,
812
convolutional neural networks, 191
cooling schedule, 535
cooperative cut, 322
coordinate ascent variational infer￾ence, 450, 450
coreset, 698
correlated topic model, 957
correlation coefficient, 23
correspondence, 1007
cosine distance, 18
cosine kernel, 679
count-based exploration, 1138
counterfactual, 1021
Counterfactual queries, 1180
counterfactual question, 214
coupled HMM, 992
coupling flows, 825
coupling layer, 825
covariance function, 673
covariance graph, 200, 244
covariance inflation, 383
covariance matrix, 22
covariate shift, 730
coverage, 79, 580
Cox process, 696
Cox’s theorem, 7
CPD, 144
CPPN, 759
CPT, 145
CQR, 582
credible interval, 67, 67, 90
CRF, 165, 185
CRFs, 166
critic, 885
critical temperature, 168, 510
critical value, 131
cross correlation, 625
cross entropy, 229, 235
cross entropy method, 304
cross fitting, 1190
cross validation, 122
cross-entropy method, 306, 563,
1155
cross-stitch networks, 744
crossover, 302
crowd computing, 1126
CRPS, 1026
CTR, 1111
cubature, 477
cubature Kalman filter, 379
cubatures, 379
cumulants, 39
cumulative distribution function, 6,
11
cumulative regret, 1117
cumulative reward, 1110
curse of dimensionality, 770, 1123
curse of horizon, 1164
curved exponential family, 34
CV, 449
cycle consistency, 910
cyclical annealing, 797
d-separated, 149
D3PM, 877
D4PG, 1153
DAGs, 143
DALL-E, 816
DALL-E 2, 817
damped updates, 453
damping, 415, 475
dark knowledge, 656
DARN, 147
data assimilation, 382
data association, 1007
data augmentation, 615, 738
data cleaning, 733
Data compression, 245
data compression, 217, 769, 774
data generating process, 1, 730
data processing inequality, 227,
237
data tempering, 539
data-driven MCMC, 498
datatset shift, 727
daydream phase, 471
DBL, 639
DBN, 174, 992
DCGAN, 905
DDIM, 872
DDP, 1155
DDPG, 1153
DDPMs, 857
de Finetti’s theorem, 71, 72
dead leaves, 926
decision diagram, 1101
decision nodes, 1101
decision procedure, 1095
decision theory, 1095
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
INDEX
decision tree, 1103
declarative approach, 211
decoder, 634, 781, 919
decomposable, 183, 194, 426
decompose, 157
decoupled EKF, 666
deduction, 81
deep autoregressive network, 147
deep Bayesian learning, 639
deep belief network, 174
deep Boltzmann machine, 174
deep Boltzmann network, 174
deep CCA, 945
deep deterministic policy gradient,
1153
deep ensembles, 650
Deep Factors, 1026
deep fakes, 767, 908
deep Gaussian process, 723
deep generative model, 147
deep generative models, 765
deep image prior, 643
Deep kernel learning, 718
deep latent Gaussian model, 781
deep latent variable model, 781
deep learning, 1, 623
deep Markov model, 1027
deep neural network, 623
deep PILCO, 1157
deep Q-network, 1144
deep state-space model, 1027
deep submodular function, 322
deep unfolding, 422
DeepAR, 1026
DeepGLO, 1026
DeepSSM, 1025
default prior, 102
deformable parts model, 192
degenerate kernel, 684
degree of normality, 12
degrees of freedom, 12, 87, 126
deleted interpolation, 116
delta function, 70
delta VAE, 798
demand forecasting, 1018
denoising autoencoder, 1052
denoising diffusion probabilistic
models, 857
denoising score matching, 847
DenseFlow, 767
density estimation, 769
density model, 735
density ratio estimation, 61
derivative function, 257
derivative operator, 257
Derivative-free optimization, 298
detailed balance, 495
detailed balance equations, 55
determinantal point process, 406
deterministic ADVI, 447
deterministic annealing, 983
deterministic inducing conditional,
700
deterministic policy gradient theo￾rem, 1152
deterministic training conditional,
701
deviance, 125
DFO, 298
DGP, 1, 723
diagonal covariance matrix, 23
diameter, 412
DIC, 700
dictionary learning, 967
diffeomorphism, 820
difference in differences, 1204
differentiable CEM, 306
differentiable simulators, 884
differential dynamic programming,
1155
differential entropy, 233
diffrax, 871
diffuse prior, 102
diffusion coefficient, 867
diffusion coefficients, 998
diffusion kernel, 859
diffusion matrix, 517
diffusion models, 765, 857
diffusion process, 857
diffusion term, 516, 516
digamma function, 460
dilated convolution, 813
diminishing returns, 319
DINO, 1058
Dirac delta function, 68
direct coupling analysis, 170
direct method, 1161
directed acyclic graphs, 143
directed Gaussian graphical model,
148
Dirichlet, 20
Dirichlet distribution, 84
Dirichlet process mixture models,
462
discount factor, 1110, 1120, 1135
discrete task-agnostic learning,
752
discretized Gaussian, 879
discriminative model, 569
discriminative prediction, 729
discriminative reranking, 405
discriminator, 885
disease mapping, 696
disease transmission, 1033
disentangled, 788, 966, 1059
disentangled representation learn￾ing, 1042
dispersion parameter, 43
distillation, 656
distortion, 246
distributed representation, 173,
991
distribution free, 579
distribution shift, 727, 761, 1160
distributional particles, 551
distributional RL, 1146, 1153
distributionally robust optimiza￾tion, 738
diverged, 513
divergence metric, 55
DLGM, 781
DLM, 1013
DLVM, 781
DNN, 623
do-calculus, 1176, 1217
do-notation, 1180
domain adversarial learning, 741
domain drift, 750
domain generalization, 669, 744
domain randomization, 1159
domain shift, 730
domains, 744
dominates, 1097
donor, 1024
Donsker-Varadhan, 226, 243
dot product attention, 629
dot product kernel, 681
double DQN, 1146
double loop algorithms, 416
double machine-learning, 1189
double Q-learning, 1144
double sided exponential, 12
doubly intractable, 182
doubly reparameterized gradient
estimator, 468
doubly robust, 1163, 1190
downstream, 774
DPGM, 143
DQN, 1144
DRE, 61
Dreamer, 1159
drift coefficient, 867
dropout, 627
DTC, 701
dual EKF, 384
DualDICE, 1165
dueling DQN, 1146
dyna, 1155
dynamic Bayesian network, 992
dynamic embedded topic model,
958
dynamic linear model, 1000, 1013
dynamic programming, 342, 395,
1122
dynamic programming., 428
dynamic topic model, 957
dynamic VAE, 794
dynamical variational autoen￾coders, 1027
dynamics model, 353
E step, 283, 285
EA, 301
earning while learning, 1110
EB, 114
EBM, 765, 839
ECE, 573
ECM, 290
ECME, 290
EDA, 304
edge potentials, 177
edit distance, 978
effective dimensionality, 659
effective sample size, 523, 525,
547
effects of causes, 214
EI, 294
eigenfunction, 684
eigengap, 519
eight schools, 111
Einstein summation, 429
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1228
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
einsum, 426, 429
einsum networks, 205
EKF, 369
elastic weight consolidation, 665,
755
ELBO, 284, 347, 434
elementwise flow, 822
eligibility traces, 1142
elimination order, 424
elite set, 302
ELPD, 124
EM, 283
EMNA, 305
empirical Bayes, 114, 642
empirical distribution, 228
empirical Fisher, 278
empirical MBR, 1101
empirical priors, 71
empirical risk, 570
empirical risk minimization, 267,
570
emulate, 563
encoder, 634
End-task., 1065
endogeneous, 211
energy, 166
energy based models, 765
energy disaggregation, 991
energy function, 301, 345, 839
energy score, 734
energy-based model, 166
Energy-based models, 839
EnKF, 382
ensemble, 627, 1129
ensemble Kalman filter, 382
ensemble square root filter, 383
ensembling, 121
entity resolution, 207
entropy, 232, 284
entropy sampling, 1128
entropy search, 296
environment, 1110, 1118
environments, 744
EP, 472
epidemiology, 544
episodic task, 1119
epistemic uncertainty, 71, 576
EPLL, 925
epsilon-greedy, 1138
epsiode, 1119
equal odds, 1101
equal opportunity, 1101
equilibrium distribution, 52
equivalent sample size, 65
ergodic, 54
ERM, 267, 570
error correcting codes, 249, 419
error correction, 217
error-correcting codes, 204
ES-RNN, 1025
ESS, 523, 547
estimated potential scale reduction,
523
estimation of distribution, 304
estimation of multivariate normal
algorithm, 305
estimator, 72, 72, 1095
Etsy, 978
EUBO, 468
Euler approximation, 527
Euler’s method, 512, 835, 870
Euler-Maruyama, 868, 870
event space, 5
evidence, 63, 69, 119, 347
evidence lower bound, 284, 347,
434
evidence maximization, 642
evidence procedure, 114
evidence upper bound, 468
Evolution strategies, 306
evolutionary algorithm, 301
evolutionary programming, 304
evolutionary search, 298
EWC, 665
excess kurtosis, 13
exchangeable, 162, 958
exchangeable with, 108
Exclusion restriction, 1197
exclusive KL, 223
execution traces, 211
exogenous, 211
exp-sine-squared kernel, 679
expanded parameterization, 923
expectation backpropagation, 667
expectation maximization, 283
expectation propagation, 392, 472
expected calibration error, 573
expected complete data log likeli￾hood, 285
expected free energy, 1170
expected improvement, 294
expected LPPD, 124
expected patch log likelihood, 925
expected sufficient statistics, 160,
285
experience replace, 1144
experience replay, 755
explainability, 215
explaining away, 92, 146, 151, 155,
241
explicit duration HMM, 988
explicit layers, 632
explicit probabilistic models, 883
exploration bonus, 1114, 1139
exploration-exploitation tradeoff,
1105, 1111, 1138
exponential cooling schedule, 535
exponential dispersion family, 43
exponential distribution, 14
exponential family, 33, 34, 44, 98
exponential family factor analysis,
946
exponential family harmonium,
173
exponential family PCA, 946
exponential family state-space
model, 1011
Exponential linear unit, 625
exponentiated quadratic, 676
extended Kalman filter, 369, 370,
1011
extended Kalman smoother, 373
extended particle filter, 549
extended RTS smoother, 373
external field, 168
external validity, 729
extrapolation, 709
extrinsic variables, 457
f-divergence, 55
f-divergence max-ent IRL, 1172
F-statistic, 139
factor, 138, 165
factor analysis, 162
factor graph, 201, 412, 420
factor loading matrix, 163, 929
factor of variation, 788
factor rotations problem, 933
factorial HMM, 465, 991
factorization property, 154
FAIRL, 1172
fairness, 215, 1101
Faithfulness, fidelity, 1076
family marginal, 160
fan-in, 262
fan-out, 259, 262
fantasy data, 844
Fast Fourier Transform, 402
fast geometric ensembles, 648
fast gradient sign, 758
fast ICA, 965
fast weights, 652
FastSLAM, 557
FB, 398
feature induction, 175
feature-based, 320
feedback loop, 1112
feedforward neural network, 632
ferromagnetic, 167
few-shot learning, 739
Feynman-Kac, 537
FFBS, 356
FFG, 203
FFJORD, 835
FFNN, 632
FGS, 758
FIC, 702
FID, 777
fill-in edges, 425
FiLM, 632
filter, 625
filter response normalization, 627
filtering, 353
filtering distribution, 397
filtering SMC, 564
filtering variational objective, 564
FIM, 75
fine-tuning, 1041
finite horizon, 1110
finite horizon problem, 1120
finite state machine, 1119
finite sum objective, 267
finite-state Markov chain, 47
first-order logic, 208
Fisher divergence, 846
Fisher information, 103
Fisher information matrix, 41, 75,
75, 104
FITC, 701
fitness, 302
fitness proportionate selection, 302
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
INDEX
fitted value iteration, 1146
FIVO, 564
fixed effects, 618
Fixed lag smoothing, 354
fixed-form VI, 435
flat minima, 517, 657
flow cytometry, 771
folded over, 11
folds, 122
FOO-VB, 669
fooling images, 759
force, 529
forest plot, 110
fork, 149
formula syntax, 588
Forney factor graph, 203
Forney factor graphs, 201
forward adversarial inverse RL,
1172
forward-mode automatic differenti￾ation, 260
forwards algorithm, 397, 427, 977
forwards filtering backwards sam￾pling, 406
forwards filtering backwards
smoothing, 356
forwards kernel, 558
forwards KL, 223
forwards mapping, 917
forwards process, 857
forwards transfer, 754
forwards-backwards, 398, 428
founder variables, 934
Fourier basis, 967
Fourier transform, 680
Fréchet Inception distance, 777
Fréchet inception distance, 60
free bits, 798
free energy, 434
free energy principle, 1170
free-form VI, 435, 451
freeze-thaw algorithm, 298
frequentist decision theory, 1095
frequentist risk, 1095
frequentist sampling distribution,
592
frequentist statistics, 63, 72
friction, 529
front-door criterion, 1219
front-door formula, 1219
frustrated, 510
frustrated system, 167
Fubini’s theorem, 1097
full batch, 267
full conditional, 153, 499
full conditionals, 349
full conformal prediction, 580
full covariance matrix, 23
fully connected CRF, 190
fully connected layer, 624
fully independent conditional, 702
fully independent training condi￾tional, 701
function space, 688
functional, 255
functional causal model, 211
fundamental problem of causal in￾ference, 216
funnel shape, 112
funnel transformer, 794
g-prior, 592
GA, 302
GAE, 1150
GAIL, 913, 1172
GAM, 714
gamma distribution, 14
gamma function, 12
GAN, 765
GANs, 883
GaP, 950
gap, 1117
gated recurrent unit, 636
Gauss-Hermite integration, 379
Gauss-Hermite Kalman filter, 379
Gaussian bandit, 1113, 1115
Gaussian Bayes net, 148
Gaussian copula, 1026
Gaussian distribution, 10
Gaussian filtering, 386
Gaussian graphical model, 177
Gaussian kernel, 676
Gaussian mixture model, 920
Gaussian MRF, 177
Gaussian process, 292, 673, 1037
Gaussian processes, 724, 1156
Gaussian quadrature, 379
Gaussian scale mixture, 288, 596,
922
Gaussian soap bubble, 23
Gaussian sum filter, 387
GELU, 625
GEM, 290
Gen, 211
GenDICE, 1165
general Gaussian filtering, 377
Generality, 1079
generalization, 774
generalized additive model, 714,
1025
generalized advantage estimation,
1150
generalized Bayesian inference,
571, 604
generalized belief propagation, 418
generalized CCA, 945
generalized EM, 290
generalized Gauss-Newton, 645
generalized linear mixed model,
618
generalized linear model, 583
generalized low rank models, 946
generalized policy improvement,
1125
generalized probit approximation,
608
generalized pseudo-Bayes filter,
387
generalized variational continual
learning, 669
generate and test, 498
generative adversarial imitation
learning, 1172
generative adversarial networks,
765, 883
generative AI, 767
generative design, 774
generative model, 765
generative neural samplers, 884
generative prediction, 729
Generative representation learning,
1049
generative weights, 962
generator networks, 884
genetic algorithm, 302
genetic programming, 302
geometric distribution, 10, 987
geometric path, 559
GGF, 377
GGM, 177
GGN, 645
GHKF, 379
Gibbs distribution, 166, 839
Gibbs kernel, 681
Gibbs posterior, 571
Gibbs sampling, 168, 349, 499
gist, 958
Gittins index, 1113
Glauber dynamics, 499
GLIE, 1143
GLM, 583
GLM predictive distribution, 654
GLMM, 618
global balance equations, 52
global latent variables, 340
global Markov property, 149, 179
global variables, 157
globally normalized, 187, 197
Glorot initialization, 640
GMM, 920
GMM-HMM, 972
GNNs, 637
goodness-of-fit, 55
GP, 292
GP-LVM, 948
GP-MPC, 1157
GP-UCB, 295
GPT, 815
GPT-2, 815
GPT-3, 815
gradient EM algorithm, 290
gradient sign reversal, 742
gradient-based meta-learning, 749
Gram matrix, 675
grammar VAE, 796
grammars, 188
grand mean, 139
graph neural networks, 637
graph surgery, 214, 1178
graphical lasso, 177, 1033
greatest common divisor, 53
greedy action, 1122
greedy search, 299
grid approximation, 345
grid search, 300
grid world, 1122
grid-based approximation, 392
ground network, 206
ground states, 167
ground terms, 205
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1230
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
group lasso, 597
group normalization, 627
GRU, 636
GSM, 922
guided cost learning, 1172
guided particle filter, 548
Gumbel distribution, 272
Gumbel-max trick, 272
Gumbel-softmax, 808
Gumbel-softmax distribution, 272
half Cauchy, 12
half-Cauchy distribution, 598
half-edge, 203
half-normal distribution, 11
hallucinate, 816
Halton sequence, 491
Hamilton’s equations, 511
Hamiltonian, 511
Hamiltonian mechanics, 510
Hamiltonian Monte Carlo, 349,
510, 529, 609
Hamiltonian variational inference,
466
Hammersley-Clifford theorem, 166
Hamming distance, 1100
Hamming loss, 1099
hard clustering, 921
hard EM, 289
hard negative mining, 1056
hard tanh, 273
harmonic mean estimator, 121
harmonium, 172
Hastings correction, 494
hazard function, 994
hBOA, 305
HDI, 68
HDP-HMM, 985
heads, 633
heat bath, 499
heavy tailed, 15
heavy tails, 15
Hebb’s rule, 843
Hebbian learning, 843
Hebbian term, 843
Hellinger distance, 57
Helmholtz machine, 782
Hessian free optimization, 278
heteroskedastic, 633
Heun’s method, 870
heuristic function, 1154
heuristic search, 1154
hidden Gibbs random field, 185
hidden Markov model, 396, 811,
970
hidden semi-Markov model, 988
hidden state, 811
hidden state predictive distribu￾tion, 355
hidden variables, 155, 283
hierarchical Bayesian model, 107,
617, 669
hierarchical Bayesian models, 525
hierarchical GLM, 618
hierarchical HMM, 989
hierarchical kernel learning, 713
hierarchical priors, 71
hierarchical VAE, 799
hierarchical variational model, 466
highest density interval, 68
highest posterior density, 67
Hilbert space, 691
hill climbing, 299
hindsight, 354
hinge-loss MRFs, 209
Hinton diagram, 50
Hinton diagrams, 940
histogram binning, 574
HMC, 110, 349, 510
HMM, 396, 970
HMM filter, 359
homogeneous, 47
Hopfield network, 170
horseshoe distribution, 923
horseshoe prior, 597
HPD, 67
HSMM, 988
Huffman coding, 245
Hungarian algorithm, 1008
Hutchinson trace estimator, 833
Hutter prize, 245
hybrid CNN-HMM, 974
hybrid MC, 510
hybrid system, 1005
hyper-parameters, 64
hypernetwork, 631
hyperparameters, 107
hypothesis test, 1108
hypothesis testing, 80, 131
I-map, 149
I-projection, 225
IAF, 831
IBIS, 561
ICA, 963
ICM, 171
ID, 733
identifiable, 870, 1059, 1179
identification strategy, 1179
identified, 1179
identity uncertainty, 207
iid, 64, 71
image captioning, 767
image deblurring, 925
image denoising, 925
image imputation, 943
image inpainting, 925
image super-resolution, 925
image to image translation, 909
Image-text supervision, 1048
image-to-image, 767
image-to-image translation, 877
image-to-text, 767
Imagen, 817, 877
imagination-augmented agents,
1155
Imbens’ Sensitivity Model, 1210
Imitation learning, 1170
IMM, 388
implicit generative models, 776,
883
implicit layers, 632
implicit models, 563, 765
implicit probabilistic model, 883
implicit probabilistic models, 883
implicit probability distributions,
466
implicit probability model, 789
importance ratio, 1162
importance sampling, 348, 484
importance weighted autoencoder,
467
importance weighted autoencoders,
486
importance weights, 485
imputation, 770
impute, 141
in-context learning, 739, 815
in-distribution, 733
in-domain, 728
in-painting, 771
inception, 60
Inception score, 777
inclusive KL, 223
income inequality, 16
incomplete data, 185
incremental EM, 291
incremental importance weights,
541
incumbent, 294
independence sampler, 496
independent and identically dis￾tributed, 64
independent components analysis,
963
independent events, 8
independent t-test, 135
induced width, 426
inducing points, 699
induction, 81
inference, 63, 155, 339
inference compilation, 438
inference network, 438, 623, 781
infinite horizon, 1110
infinitely exchangeable, 71
infinitely wide neural networks,
642
influence curve, 1189
influence diagram, 214, 1101
influence model, 992
infomax, 966
InfoNCE, 243
InfoNCE loss, 1056
information arc, 1103
information bottleneck, 1060
information bottleneck principle,
250
information criterion, 125
information diagram, 237, 240
information diagrams, 238, 1131
information extraction, 187
information filter, 364
information form, 25, 38, 177
information gain, 219, 296, 1129
information processing, 217
information projection, 225, 386
information state, 1112
informative vector machine, 698
InfoVAE, 789, 799
inhomogeneous polynomial kernel,
681
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
INDEX
injective, 44
inner product, 690
innovation term, 360
input nodes, 262
inside outside, 991
inside-outside algorithm, 189
instance normalization, 627
InstructGPT, 815
instrument monotonicity, 1200
Instrument relevance, 1197
Instrument unconfoundedness,
1197
instrumental variables, 1197
integral probability metric, 57
integrated risk, 1096
integrating out, 70
inter-causal reasoning, 151
interaction information, 239
interactive multiple models, 388
Interactivity, 1077
interpolated Kneser-Ney, 118
interpolator, 685
interrupted time series, 1021
intervention, 216
Interventional queries, 1180
interventions, 213, 1176
intrinsic uncertainty, 71
intrinsic variables, 457
invariant, 103, 495
invariant causal prediction, 746
invariant distribution, 52
invariant risk minimization, 746
inventory, 1020
inverse autoregressive, 830
inverse chi-squared distribution,
87
inverse gamma, 86, 590
inverse gamma distribution, 15
inverse mass matrix, 511, 514
inverse of a partitioned matrix, 25
inverse optimal control, 1171
inverse probability of treatment
weighted estimator,
1187
inverse probability theory, 63
inverse probability transform, 480
inverse reinforcement learning,
1171
inverse temperature, 559
inverse Wishart, 19, 91, 92
IPF, 183
IPLF, 381
IPLS, 381
IPM, 57
iResNet, 832
IRLS, 283, 587
IRM, 746
irreducible, 53
Ising model, 167, 169
Ising models, 500
isotonic regression, 574
isotropic covariance matrix, 23
Itô calculus, 867
iterated batch importance sam￾pling, 561
iterated EKF, 371, 371
iterated EKS, 373, 381
iterated posterior linearization fil￾ter, 381
iterated posterior linearization
smoother, 381
iterative amortized inference, 439
iterative conditional modes, 171
iterative proportional fitting, 183
iteratively reweighted least squares,
587
IWAE, 467
IWAE bound, 467
Jacobi, 417
Jacobian, 44
Jacobian determinant, 820
Jacobian vector product, 849
Jacobian-vector product (JVP),
257
JAGS, 499
JamBayes, 1034
Jeffrey’s conditionalization rule,
230
Jeffreys prior, 89, 103
Jensen’s inequality, 220, 284, 467
JMLS, 1005
join tree, 428
JPDA, 1008
JTA, 428
judge fixed effects, 1198
jump Markov linear system, 1005
junction tree, 428
junction tree algorithm, 428
K-means clustering, 922
Kalahari, 593
Kalman Bucy filter, 364
Kalman filter, 353, 358, 359, 364,
998, 1016
Kalman filter algorithm, 29
Kalman gain matrix, 29, 360
Kalman smoother, 353, 358, 998
Kalman smoothing, 364, 957
KDE, 770
kernel, 494, 625
kernel basis function expansion,
600
kernel density estimation, 770
kernel function, 675, 691
kernel Inception distance, 777
kernel inception distance, 60
kernel mean embedding, 59
kernel ridge regression, 690, 693
kernel trick, 59, 684
keys, 629
KF, 359
KFAC, 277, 645
kinetic energy, 511
KISS, 714
KISS-GP, 708
KL annealing, 797
KL divergence, 219, 284
knots, 824
knowledge gradient, 297
known knowns, 733
known unknowns, 733
Kolmogorov axioms, 7
Kolmogorov–Smirnov test, 46
kriging, 674
Kronecker factored curvature, 645
Kruskal-Wallis test, 139
Krylov subspace methods, 706
Kullback Leibler divergence, 56
Kullback-Leibler divergence, 219,
284
kurtosis, 13, 965
L0 norm, 595
L0 regularization, 595
L2, 691
L2 loss, 1098
label bias, 197
label shift, 731, 742
label smoothing, 575
label switching, 983
ladder network, 801
lag, 354
Lagrange multipliers, 43
Lagrangian, 43
lambda-return, 1142
LaMDA, 816
Langevin diffusion, 516, 527
Langevin MCMC, 842
Langevin Monte Carlo, 515
language models, 49
LapGAN, 906
Laplace approximation, 345, 606
Laplace bridge, 608, 654, 654
Laplace distribution, 12
Laplace Gaussian filter, 549
Laplace propagation, 474
Laplace’s rule of succession, 69
large language models, 816
lasso, 595, 596
latent Dirichlet allocation, 953
latent factor models, 919
latent factors, 917
latent overshooting, 1030
latent semantic analysis, 954
latent space arithmetic, 773
latent space interpolation, 773,
795
latent variable, 919
latent variable collapse, 804
latent variable model, 917, 919
law of total probability, 8
layer, 624
layer normalization, 627
layers, 623
lazy training, 723
LBP, 411
LDA, 953
LDA-HMM, 958
LDM, 874
LDPC code, 419
LDS, 357, 996
Leaky ReLU, 625
leapfrog integrator, 512
learned loss function, 904
learning, 1135
learning from demonstration, 1170
learning rate, 265
learning rate schedule, 266, 266
least confident sampling, 1128
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1232
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
least favorable prior, 1096
least mean squares, 1000
leave-one-out cross validation, 122
LeCun initialization, 640
left-to-right, 402
left-to-right transition matrix, 48
legal reasoning, 215
length-scale, 676
leptokurtic, 13
level sets, 23
LG-SSM, 357, 996
life-long learning, 750
lifted inference, 209
likelihood, 8, 63
likelihood ratio, 81, 132, 735
likelihood ratio gradient estimator,
268
likelihood tempering, 539
likelihood-free inference, 563, 884
lily pads, 972
limiting distribution, 53
linear discriminant analysis, 953
linear dynamical system, 357, 996
Linear evaluation, 1040
linear flow, 822
linear Gaussian CPD, 148
linear Gaussian state space model,
357
linear Gaussian system, 28
linear layer, 624
linear programming, 1122
Linear regression, 588
linear regression bandit, 1113
linear-Gaussian CPD, 199
linear-Gaussian state-space model,
996
linear-quadratic-Gaussian, 1155
linearization point, 257
link function, 583, 586
linkage learning, 305
Lipschitz constant, 57
LKJ distribution, 101
LLMs, 816
LM, 49
LMC, 515
LMS, 1000
local and global latent variables,
341
local average treatment effect,
1200
local evidence, 452
local factor, 472
local latent variables, 341
local level model, 1014
local linear trend, 1014
local Markov property, 154
local reparameterization trick, 646
local variables, 157
local+global, 1025
localist representation, 173
locally normalized, 187, 195, 197
locally optimal proposal distribu￾tion, 548
location-scale family, 106
log derivative trick, 268
log loss, 570, 572
log partition function, 34
log-derivative trick, 183
log-linear, 175
log-linear model, 175
log-odds score, 977
log-pointwise predictive-density,
124
log-returns, 1012
log-sum-exp trick, 928
logistic, 602
logistic distribution, 614, 964
logistic normal, 957
Logistic regression, 602
logistic regression bandit, 1113
logit adjusted softmax cross￾entropy loss, 604
logit adjustment, 604
logits, 603
long short term memory, 636
long tails, 15
LOO-CV, 122
lookahead function, 564
loopy belief propagation, 411, 420
Lorentz, 12
loss function, 1095
lossless compression, 245
lossy compression, 246
low discrepancy sequences, 491
low variance resampling, 546
low-density parity check code, 419
low-discrepancy sampler, 863
low-resource languages, 980
LPPD, 124
LQG, 1155
LSGM, 875
LSTM, 636
LVM, 919
M step, 283
M-complete, 118
M-open, 118
M-projection, 224
m-separation, 199
M2, 793
M4 forecasting competition, 1025
Möbius inversion formula, 241
machine translation, 767
MADE, 812
MAE, 1053
MAF, 830
Mahalanobis distance, 22
majorize-minimize, 281
MALA, 515
MAML, 749
manifestation shift, 731
Mann-Whitney U test, 138
MAP estimate, 403, 570, 1098
MAPIE, 579
MAR, 141
margin sampling, 1128
marginal calibration error, 573
marginal likelihood, 8, 63, 69, 99,
114, 119, 223
marginalization paradox, 132
marginalizing out, 70
Mariner 10, 364
Markov, 149
Markov assumption, 47, 811
Markov blanket, 153, 179, 499
Markov chain, 47
Markov chain Monte Carlo, 348,
493
Markov decision process, 1118
Markov kernel, 47
Markov logic network, 208
Markov mesh, 165
Markov model, 47, 811
Markov model of order n, 49
Markov network, 165
Markov random field, 165
Markovian SCM, 211
masked attention, 630
masked autoencoder, 1053
masked autoregressive flow, 830
masked convolution, 812
masked language modeling, 1052
masked language models, 880
MaskGIT, 880
Matérn kernel, 677
matching, 1191
matrix determinant lemma, 833
matrix inversion lemma, 26, 29,
360
matrix normal, 18
matrix normal inverse Wishart,
601
matrix vector multiplication, 706
max margin Markov networks, 193
max marginals, 410, 1099
max-product belief propagation,
410
maxent prior, 102
maximal clique, 165
maximal weight bipartite match￾ing, 1008
maximization bias, 1143
maximizer of posterior marginals,
1099
maximizer of the max marginal,
410
maximizer of the posterior
marginal, 410
maximum a posteriori, 1098
maximum entropy, 102
maximum entropy Markov model,
187, 196
maximum entropy model, 43, 175
maximum entropy RL, 1168
maximum expected utility princi￾ple, 1096
maximum likelihood estimation,
570
maximum mean discrepancy, 57,
58, 790, 891
maximum risk, 1096
MBIE, 1139
MBIE-EB, 1139
MBRL, 1153
MCAR, 141
MCEM, 290
MCMC, 348, 493
MCTS, 1154
MDL, 126
MDP, 1118
mean canonical correlation, 1044
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
INDEX
mean field, 348, 435, 450
mean function, 583, 673
mean squared canonical correla￾tion, 1044
mean value imputation, 770
measure, 691
measurement model, 353
measurement update step, 360
mediators, 1219
membership query synthesis, 1126
memetic algorithm, 304
MEMM, 197
MEMO, 743
memory methods, 755
mental model, 1078
Mercer kernel, 673, 675
Mercer’s theorem, 684
merit function, 294
MERL, 1168
message passing, 406
message passing algorithms, 395
messages, 395, 400
meta-data, 746
meta-learning, 747
Method., 1066
metric learning, 1056
Metrics., 1066
Metropoli-Hastings, 494
Metropolis adjusted Langevin algo￾rithm, 515
Metropolis within Gibbs, 504
Metropolis-Hastings, 301, 533
Metropolis-Hastings algorithm,
348
MH, 494
min-fill heuristic, 426
min-max, 894
min-max optimization problem,
738
min-weight heuristic, 426
minibatch, 267
minimal, 34
minimal I-map, 149
minimal representation, 35
minimal sufficient statistic, 238,
250, 250
minimally informative prior, 102
minimax estimator, 1096
minimum Bayes risk, 1101
minimum description length, 126
minimum mean squared error,
1098
minorize-maximize, 281
missing at random, 141
missing completely at random, 141
missing data, 141, 283, 286
missing data mechanism, 141
missing not at random, 141
mixed effects model, 618
mixed graph, 199
mixed membership model, 951,
953
mixing matrix, 962
mixing time, 493, 518, 519
mixing weights, 99
mixture model, 919
mixture of Bernoullis, 922
mixture of beta distributions, 99
mixture of conjugate priors, 99
mixture of experts, 652, 840
mixture of factor analyzers, 936
mixture of Gaussians, 920
mixture of Kalman filters, 551
mixture proposal, 497
MLE, 570
MLP, 632
MM, 281
MMD, 57, 58, 790, 891
MMD VAE, 790
MMI, 239
MMM, 410
MMSE, 1098
MNAR, 141
MNIST, 773
MoCo, 1058
mode, 1098
mode collapse, 897
mode connectivity, 658
mode hopping, 897
mode-covering, 223
mode-seeking, 223
model checking, 127
model predictive control, 1154
model-agnostic meta-learning, 749
model-based approach, 1
model-based RL, 1135, 1137,
1153
model-free RL, 1135
modified Euler’s method, 512
Modularity, 1077
modus tollens, 81
MoG, 920
molecular graph structure, 796
moment matching, 42, 116, 183,
224, 377, 388, 473,
892
moment parameters, 25, 34
moment projection, 224, 386
monference, 782
Monte Carlo, 344
Monte Carlo approximation, 348
Monte Carlo control, 1140
Monte Carlo dropout, 628, 643
Monte Carlo EM, 290
Monte Carlo estimation, 1140
Monte Carlo integration, 477, 480
Monte Carlo methods, 477
Monte Carlo rollouts, 1137
Monte Carlo tree search, 1154
moralization, 180, 195
Mormons, 129
most probable explanation, 411
motion capture, 949
MPC, 1154
mPCA, 951
MPE, 411
MPM, 410, 1099
MQ-CNN, 1026
MRF, 165
multi-armed bandit, 1110
multi-entity Bayesian networks,
210
multi-head attention, 630
multi-headed DNN, 753
multi-information, 239
multi-level model, 107
multi-sample ELBO, 467
multi-scale, 803
multi-stage likelihood, 1020
multi-target tracking, 1006
multi-task learning, 743
multiclass logistic regression, 602
multiclass N-pair loss, 1056
multilayer perceptron, 632
multilevel model, 617
multimodal VAE, 790
multinomial coefficient, 9
multinomial diffusion, 877
multinomial distribution, 9, 84
Multinomial logistic regression,
603
multinomial logistic regression,
602
multinomial PCA, 951
multinomial probit, 617
multinomial resampling, 546
multiple hypothesis tracking, 1006,
1009
multiple imputation, 771
multiple kernel learning, 713
multiple mutual information, 239
multiple plays, 1111
multiple restarts, 983
multiple sequence alignment, 170,
977
multiplexer, 207
multiplication rule, 7
multiplicative interaction, 629
multiplicative interactions, 631
multiplicative layers, 631
multiplicative noise, 923
MultiSWAG, 650
multivariate Gaussian, 17, 22, 22
multivariate linear regression, 600
multivariate mutual information,
239
multivariate normal, 17, 22, 22
multivariate probit, 617
multivariate Student distribution,
17
multiview representation learning,
1054
mutation, 302
mutual information, 236
MuZero, 1155
MVAE, 790
MVM, 706
MVN, 17, 22
myopic, 1120, 1122
N-BEATS, 1026
N-best list, 405
n-gram model, 49
NADE, 812
NAGVAC, 646
NAGVAC-1, 443
naive Bayes classifier, 164
named entity extraction, 188
named variable, 255
nats, 222, 233
natural evolution strategies, 307
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
natural evolutionary strategies,
278
natural exponential family, 34
natural gradient, 231, 275, 965
natural gradient descent, 75, 273,
1151
natural gradient Gaussian vari￾ational approximation,
443
natural language processing, 187
natural parameters, 25, 34, 38
Neal’s funnel, 526, 620
nearest neighbor data association,
1008
NEF, 34
negative binomial, 987
negative binomial distribution, 10
negative log likelihood, 570, 775
negative phase, 183
negative transfer, 744
Negative-free representation learn￾ing, 1057
negentropy, 965
neighbors, 299
nested dissection, 426
nested dissection order, 426
nested plates, 164
nested sampling, 122
nested SMC, 551
neural architecture search, 643
neural auto-regressive density esti￾mator, 812
neural bandit, 1113
neural CRF parser, 189
neural enhanced BP, 422
neural net kernel, 722
neural network Gaussian process,
642
neural ODE, 835, 870
neural process, 749
neural spike trains, 550, 1011
neural tangent kernel, 723
neural-linear, 646
neuroevolution, 304
neuron, 624
NeuTra HMC, 514
NGD, 273
NHST, 80, 131
NICE, 836
NIW, 93
NIX, 88
NLDS, 1010
NLG-SSM, 1010
NLP, 187
NMF, 950
NN-GP, 721
no-U-turn sampler, 514
node decoupled EKF, 666
node potentials, 177
noise conditional score network,
866
Noise contrastive estimation, 850
noisy channel, 249
noisy channel model, 978
noisy nets, 1146
non-centered parameterization,
112, 526, 621
non-contrastive representation
learning, 1057
non-descendants, 154
non-factorial prior, 600
non-Gaussian SSM, 1011
non-linear squared flow, 823
non-Markovian, 872
non-Markovian models, 538
non-negative matrix factorization,
950
non-null recurrent, 54
non-parametric Bayesian, 1037
non-parametric Bayesian models,
918
non-parametric bootstrap, 73
non-parametric BP, 415, 557
non-parametric models, 569
non-parametrically efficient, 1190
non-stationary kernel, 722
non-terminals, 189
noninformative, 102
nonlinear dynamical system, 1010
nonlinear factor analysis, 948
nonlinear Gaussian SSM, 1010
nonparametric copula, 1026
nonparametric models, 673
nonparametric tests, 136
nonstationary kernel, 681
normal distribution, 10
normal factor graph, 203
normal inverse chi-squared, 88
normal inverse gamma, 87, 590
normal-inverse-Wishart, 93
normalization layers, 627
normalized occupancy distribution,
1126
normalized weights, 486, 540
normalizes, 819
normalizing flow, 973
Normalizing flows, 466
normalizing flows, 765, 819
noun phrase chunking, 188
noun phrases, 187
Nouveau VAE, 804
novelty detection, 733
NP-hard, 427
NSSM, 1011
NTK, 723
nuisance functions, 1189
nuisance variables, 155, 411
null hypothesis, 80, 132
null hypothesis significance testing,
80, 131
numerical integration, 477
NUTS, 514
NUV, 598
NWJ lower bound, 243
Nyström approximation, 699
object detection, 191
objective, 102
observation function, 969
observation model, 353, 969, 971
observation noise, 969, 997, 998
observation overshooting, 1029
observed predictive distribution,
355
Occam factor, 126
Occam’s razor, 940
occasionally dishonest casino, 396
occlusion, 191
ODE, 868
off-policy, 1143
off-policy policy-gradient, 1163
offline reinforcement learning,
1161
offspring, 302
Olivetti faces dataset, 720
OLS, 589
on-policy, 1143
one sample t-test, 137
one-armed bandit, 1110
one-max, 304
one-shot, 1097
one-step-ahead predictive distribu￾tion, 385
one-to-one, 44
one-way ANOVA test, 138
online advertising system, 1111
online Bayesian inference, 998
online EM, 291
online EWC, 669
online learning, 664, 755
online structured Laplace, 669
OOD, 663, 733
open class, 188
open set recognition, 737
open world, 1008
open world classification, 737
open world recognition, 731
open-universe probability models,
210
OpenGAN, 736
opportunity cost, 1105
optimal action-value function,
1121
optimal partial policy, 1124
optimal policy, 1096, 1121
optimal resampling, 553
optimal state-value function, 1121
optimal transport, 307
optimism in the face of uncertainty,
1113
optimization problems, 255
optimizer’s curse, 1143
Optimus, 794
oracle, 291
order statistics, 136
ordered Markov property, 143, 154
ordinal regression, 616
ordinary differential equation, 868
ordinary least squares, 589
Ornstein-Uhlenbeck process, 678
Orstein-Uhlenbeck process, 708
orthodox statistics, 72
orthogonal additive kernel, 714
orthogonal Monte Carlo, 492
orthogonal random features, 685
OUPM, 210
out-of-distribution detection, 733
out-of-domain, 728
outer product method, 171
outlier detection, 733, 769
outlier exposure, 733
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
INDEX
over-complete representation, 35
overcomplete representation, 967
overdispersed, 520
overfitting, 69, 570
overlap, 1185
p-value, 80, 130, 131
PAC-Bayes, 571, 660
padding, 626
PageRank, 52
paired data, 902
paired sample t-test, 135, 137
pairwise Markov property, 179
panel data, 1020, 1204
parallel prefix scan, 366, 402, 724
parallel tempering, 520, 536
parallel trends, 1205
parallel wavenet, 831
parameter learning, 156
parameter tying, 47, 108, 204
parametric Bayesian model, 1037
parametric bootstrap, 73
parametric model, 1037
parametric models, 569
parent, 302
parents, 143
Pareto distribution, 15
Pareto index, 16
Pareto smoothed importance sam￾pling, 125
parity check bits, 249
part of speech, 187, 961
part of speech tagging, 197
PARTI, 817
partial least squares, 944
partially directed acyclic graph,
198
partially exchangeable, 72
partially observable Markov deci￾sion process, 1119
partially observed data, 286
partially observed Markov model,
969
partially pooled model, 617
particle BP, 415, 557
particle filter, 539
particle filtering, 349, 394, 537
particle impoverishment, 541
particle smoothing, 557
partition function, 34, 166, 839
parts, 950
patchGAN, 909
path consistency learning, 1166
path degeneracy, 544
path diagram, 213
path sampling, 468
pathwise derivative, 269
pattern completion, 170
PBIL, 304
PBP, 646, 667
PCFG, 188
PCL, 1166
PDAG, 198
pdf, 6
peaks function, 534
Pearson correlation coefficient,
135, 138
peeling algorithm, 422
PEGASUS, 1157
per-decision importance sampling,
1162
per-step importance ratio, 1162
per-step regret, 1117
perceptual aliasing, 917
perceptual distance metrics, 776
perfect elimination ordering, 426
perfect information, 1107
perfect intervention, 214
perfect map, 193
period, 53
periodic kernel, 679, 693
permuted MNIST, 752
perplexity, 235, 775
persistent contrastive divergence,
845
persistent variational inference,
182
perturb-and-MAP, 430
perturbation, 257
PETS, 1157
PGD, 758
PGMs, 143
phase space, 511
phase transition, 168
phi-exponential family, 39
phone, 990
phosphorylation state, 771
Picard-Lindelöf theorem, 835
pictorial structure, 191
PILCO, 1156
Pilot studies, 1086
pinball loss, 581, 1026
pipe, 149
Pitman-Koopman-Darmois theo￾rem, 42, 239
pix2pix, 909
pixelCNN, 813
pixelCNN++, 814
pixelRNN, 814
PixelSNAIL, 808
placebo, 1111
planar flow, 834
PlaNet, 1159
planning, 1122, 1135
planning horizon, 1154
plant, 1119
plates, 162
Platt scaling, 574
platykurtic, 13
PLS, 944
plug in, 68
plug-in estimator, 1161
plugin approximation, 68, 70
plutocratic, 16
pmf, 6
PoE, 840
Poisson, 10
Poisson regression, 585
policy, 1095, 1110, 1118
policy evaluation, 1122, 1124
policy gradient, 1137
policy gradient theorem, 1147
policy improvement, 1124
policy iteration, 1124
policy optimization, 1122
policy search, 1137, 1146
Polyak-Ruppert averaging, 648
polymatroid function, 319
polynomial kernel, 681, 682
polynomial regression, 595
polysemy, 954
polytrees, 409
POMDP, 1119
pool-based-sampling, 1126
pooled, 108
pooling layer, 626
population, 301
population mean, 131
population-based incremental
learning, 304
position-specific scoring matrix,
976
positive definite, 19
positive definite kernel, 675
positive phase, 183
possible worlds, 206, 208
post-order, 408
posterior collapse, 462, 796
posterior distribution, 63
posterior expected loss, 1096, 1096
posterior inference, 63, 353
posterior marginal, 155
posterior mean, 1098
posterior predictive check, 128
posterior predictive distribution,
68, 70, 121
posterior predictive p-value, 130
posterior probability, 8
potential energy, 511
potential function, 30, 165
potential outcome, 215
potential outcomes, 1180
Potts model, 169
Potts models, 500
power EP, 475
power law, 15
power posterior, 656
PPCA, 934
PPL, 211
PPO, 1152
pre-order, 408
pre-train and fine-tune, 739
precision, 11, 85
precision matrix, 25, 38
precision-weighted mean, 25
preconditioned SGD, 267
preconditioned SGLD, 527
predict-update, 355
prediction, 216
prediction step, 355
predictive coding, 1170
predictive entropy search, 296
predictive model, 569
predictive sparse decomposition,
967
predictive state representation,
985
prequential analysis, 123
prequential prediction, 755
prescribed probabilistic models,
883
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1236
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
pretext tasks, 1052
prevalence shift, 731
Price’s theorem, 270, 279
primitive nodes, 262
primitive operations, 260
principle of insufficient reason, 102
prior, 63
prior network, 21, 650, 654
prior predictive distribution, 594
prior probability, 8
prior shift, 731
prioritized experience replay, 1146
probabilistic backpropagation, 646,
667
probabilistic circuit, 204
probabilistic ensembles with trajec￾tory sampling, 1157
Probabilistic graphical models,
143
probabilistic graphical models, 765
probabilistic LSA, 954
probabilistic principal components
analysis, 934
probabilistic programming lan￾guage, 211
probabilistic soft logic, 209
probability density function, 6
probability distribution, 6
probability flow ODE, 869
probability integral transform, 45
probability mass function, 6
probability matching, 1115
probability measure, 5
probability of improvement, 294,
1128
probability simplex, 20
probability space, 5
probit approximation, 608
probit function, 613
probit link function, 586
probit regression, 613
procedural approach, 211
process noise, 665, 969, 997
product of experts, 173, 792, 840
product partition model, 994
production rules, 189
profile HMM, 977
progressive distillation, 873
projected gradient descent, 758
projecting, 385
projection, 198
projection pursuit, 965
Projection-weighted CCA
(PWCCA), 1044
prompt, 739
prompt tuning, 739
propensity score, 1187
propensity score matching, 1192
proper scoring rule, 572, 886
Properties., 1066
Prophet, 1025
proposal distribution, 348, 482,
484, 494, 534
propose, 494
protein sequence alignment, 976
protein structure prediction, 170
protein-protein interaction net￾works, 1033
prototypical networks, 750
proximal policy optimization,
1152
pseudo likelihood, 184
pseudocounts, 65
pseudoinputs, 699
pseudolabels, 743
pseudolikelihood, 183
pseudorandom number generator,
480
PSIS, 125
pure exploration, 1117
push forward, 310
pushforward, 820
pushing sums inside products, 422
Pyro, 211
Q-learning, 1137, 1143
QKF, 379
QT-Opt, 1122
quadratic approximation, 345
quadratic kernel, 681, 684
quadratic loss, 1098
quadrature, 477
quadrature Kalman filter, 379
quadratures, 379
Qualitative studies, 1086
quantile loss, 581
quantile regression, 581, 1026
quantization, 234
quasi-experimental, 1021
Quasi-Monte Carlo, 491
quasi-Newton EM algorithm, 290
queries, 291
query, 629
query by committee (QBC), 1129
query nodes, 155
R-hat, 523
radar, 1007
radial basis function, 676
radon, 618
rainbow, 1146, 1153
random assignment with non￾compliance, 1198
random effects, 618
random finite sets, 1009
random Fourier features, 685
random prior deep ensemble, 651
random restart, 299
random restart hill climbing, 299
random search, 300
random variable, 5
random walk kernel, 682
random walk Metropolis, 349, 496
random walk on the integers, 54
random walk proposal, 534
randomized control trials, 1182
Randomized QMC, 491
rank transform, 137
Rao-Blackwellization, 488
Rao-Blackwellized particle filter￾ing, 551
rare event, 562
raster scan, 813
rate, 246
rate distortion curve, 247, 788
rational quadratic, 680, 725
rats, 110
RBF, 676
RBM, 172
RBPF, 551
Real NVP, 836
real-time dynamic programming,
1124
receeding horizon control, 1154
recognition network, 438, 781
recognition weights, 963
recombination, 302
recommender system, 206
reconstruction error, 246, 736
record linkage, 207
Rectified linear unit, 625
recurrent, 54
recurrent layer, 630
recurrent neural network, 636, 811
recurrent neural networks, 630
recurrent SSM, 1028
recursive, 211
recursive least squares, 359, 665,
998
reduce-on-plateau, 266
reduced rank encoding, 139
redundancy, 240, 249
reference prior, 107
regime switching Markov model,
973, 1005
region of practical equivalence, 133
Regression discontinuity designs,
1221
regression estimator, 1161
regression model, 569
regret, 756, 1107, 1116, 1117
regular, 41, 54
regularization methods, 755
regularized evolution, 302
rehearsal, 755
REINFORCE, 268, 448, 1137,
1148
Reinforcement learning, 1135
reinforcement learning from human
feedback, 815
reject action, 1098
reject the null hypothesis, 131
rejection sampling, 481
relational probability models, 205
relational UGMs, 207
relational uncertainty, 206
relative entropy, 219
relative risk, 696
relevance network, 244
relevance vector machine, 600
reliability diagram, 573
reparameterization gradient, 269
reparameterization trick, 440, 645,
897
reparameterized VI, 441
representation, 250
Representation learning, 774,
1039
representation learning, 709
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
INDEX
Representational similarity analy￾sis (RSA), 1042
representer theorem, 692
Reproducing Kernel Hilbert Space,
691
reproducing property, 691
resample, 543
resample-move, 557
residual belief propagation, 413,
417
residual block, 832
residual connections, 626, 832
residual error, 360
residual flows, 832
residues, 170
ResNet, 633
resource allocation, 1111
response surface model, 291
responsibility, 921
restless bandit, 1111
restricted Boltzmann machine, 172
return, 1120
reverse KL, 223
reverse process, 857
reverse-mode automatic differentia￾tion, 261
reverse-time SDE, 869
reversible jump MCMC, 530, 940
reward, 1105, 1110
reward function, 1119
reward model, 1118
reward-to-go, 1120
reweighted wake-sleep, 469, 471
RFF, 685
rich get richer, 462
ridge regression, 589, 592, 690
Riemann manifold HMC, 515
Riemannian manifold, 275
risk, 1095
RJMCMC, 530
RKHS, 691
RL, 1135
RLHF, 815
RLS, 998
RM-HMC, 515
RNA-Seq, 1018
RNADE, 812
RNN, 636
RNN-HSMM, 989
Robbins-Monro conditions, 266
robust BTT, 134
robust IEKS, 373
robust optimization, 761
robust priors, 100
robust regression, 696
robustness, 737
robustness analysis, 100
roll call, 951
ROPE, 133
roulette wheel selection, 302
row stochastic matrix, 145, 971
RPMs, 205
RStanARM, 588
rstanarm, 134
RTS smoother, 364
RTSS, 364
Rubin causal model, 216
run length, 993
Russian-roulette estimator, 833
rv, 5
RVI, 441
SAC, 1169
safe policy iteration, 1151
SAGA-LD, 529
SAGAN, 905
sample diversity, 774
sample inefficient, 1137
sample quality, 774
sample size, 64
sample space, 5
sample standard deviation, 89
sampling distribution, 72, 73, 592
sampling with replacement, 10
SARSA, 1137, 1143
satisfying assignment, 427
SBEED, 1167
scale-invariant prior, 106
scaled inverse chi-squared, 15
scaled likelihood trick, 974
scaling-binning calibrator, 574
scatter matrix, 92
SCFGs, 989
Schur complement, 26, 27
SCM, 211
score, 846
score function, 75, 77, 842
score function estimator, 268, 448,
913
score matching, 846
score-based generative model, 850,
864
SDE, 708, 867
seasonality, 1016
second order EKF, 371
segmental HMM, 989
selection bias, 152, 732
selection function, 302
selective prediction, 736, 1098
self attention, 814
self attention GAN, 905
self-attention, 630
self-normalized importance sam￾pling, 485
self-train, 743
semantic segmentation, 186, 190
semi-amortized VI, 439
semi-Markov model, 987
semi-Markovian SCM, 212
semi-parametric model, 688
semi-parametrically efficient, 1189
semi-supervised learning, 141, 743,
793
semilocal linear trend, 1015
sensible PCA, 934
sensitive attribute, 1101
sensitivity analysis, 100
sensor fusion, 30
sequence-to-sequence, 767, 768
sequential Bayesian inference, 349,
663
sequential Bayesian updating, 355,
998
sequential decision problem, 1109
sequential importance sampling,
541
sequential importance sampling
with resampling, 542
sequential model-based optimiza￾tion, 292
sequential Monte Carlo, 349, 537
sequential VAE, 794
sFA, 951
SFE, 268
SG-HMC, 529
SGD, 265
SGLD, 516, 527
SGLD-Adam, 527
SGLD-CV, 528
SGM, 864
SGPR, 705
SGRLD, 527
shaded nodes, 162
shared trunk network, 744
sharp minima, 657
Sherman-Morrison-Woodbury for￾mula, 26
shift equivariance, 626
shift invariance, 626
shift-invariant kernels, 676
shooting, 1155
shortcut features, 728
shortest path problems, 1124
shrinkage, 86, 110
sifting property, 68
sigma point filter, 373
sigma points, 379
sigmoid, 602
sigmoid belief net, 147
signal to noise ratio, 862
signed measure, 237
signed ranked, 137
significance level, 131
silent state, 980
SimCLR, 1055
simple regret, 1117
simplex factor analysis, 951
Simplicity, 1079
Simulability, 1078
Simulated annealing, 301
simulated annealing, 533
simulation-based inference, 563,
884
simultaneous localization and map￾ping, 554
single site updating, 504
single world intervention graph,
216
singular statistical model, 127
Singular vector CCA (SVCCA),
1044
SIS, 541
SISR, 542
site potential, 472
SIXO, 564
sketch-rnn, 795
SKI, 707, 708
SKIP, 708
skip connections, 626, 798, 799
skip-chain CRF, 188
skip-VAE, 798
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1238
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
SLAM, 554
SLDS, 1005
sleep phase, 470
slice sampling, 507
sliced Fisher divergence, 848
Sliced score matching, 848
sliding window detector, 191
slippage, 555
slot machines, 1110
slow weights, 652
SLR, 378
SLS, 299
SMBO, 292
SMC, 349, 537
SMC sampler, 537
SMC samplers, 557
SMC2
, 563
SMC-ABC, 563
SMILES, 796
smoothed Bellman error embed￾ding, 1167
smoothing, 353, 356
smoothing distribution, 397
snapshot ensembles, 648
SNGP, 647
SNIS, 539
Sobol sequence, 491
social networks, 1033
soft actor-critic, 1169
soft clustering, 921
soft constraint, 840
soft Q-learning, 1169
soft-thresholding, 462
softmax, 36
softmax function, 603
Softplus, 625
SOLA, 669
SOR, 700
Soundness, 1079
source coding, 217, 245
source coding theorem, 245
source distribution, 727
source distributions, 743
source domain, 909
space filling, 491
SPADA, 1008
sparse, 20, 595
sparse Bayesian learning, 598
sparse coding, 967
sparse factor analysis, 934
sparse GP, 700
sparse GP regression, 705
sparse variational GP, 702
sparsity promoting priors, 642
Spearman rank correlation coeffi￾cient, 138
spectral density, 680, 717
spectral estimation, 985
spectral estimation method, 1003
spectral mixture kernel, 717
spectral mixture kernels, 680
speech-to-text, 767
spelling correction, 978
spherical covariance matrix, 23
spherical cubature integration, 379
spherical K-means algorithm, 18
spherical topic model, 18
sphering, 964
spike and slab, 923
spike-and-slab, 595
spin, 167
splines, 824
split conformal prediction, 580
split MNIST, 752
split-Rhat, 523
spurious correlations, 728
SQF-RNN, 1026
square root filter, 364
square root information filter, 364
square-integrable functions, 691
square-root schedule, 266
squared error, 1098
squared exponential, 676
SS, 595
SSID, 1003
SSM, 969
Stability, 1077
Stability AI, 875
Stable diffusion, 817
stable diffusion, 875
stacking, 652
standard error, 66, 479
standard error of the mean, 90
standard normal, 11
state estimation, 353
state of nature, 1095
state space, 6
state transition diagram, 48
state-space model, 969
state-space models, 353
state-value function, 1121
stateful, 630
static calibration error, 574
stationary, 47
stationary distribution, 51, 52
stationary kernels, 676
statistical decision theory, 1095
statistical estimand, 1179
statistical linear regression, 378
statistical parity, 1101
statistics, 63
steepest ascent, 299
step decay, 266
step size, 265
stepping out, 508
stepwise EM, 291
sticking the landing, 271
sticky, 497
STL, 271
stochastic approximation, 290
stochastic approximation EM, 290
stochastic automaton, 48
stochastic averaged gradient accel￾eration, 529
stochastic bandit, 1110
stochastic blocks model, 1033
stochastic computation graph, 272
stochastic context free grammars,
989
stochastic differential equation,
708, 867, 997
stochastic EP, 475
stochastic gradient descent, 265
stochastic gradient Langevin de￾scent, 516
stochastic gradient Langevin dy￾namics, 527
stochastic gradient Riemannian
Langevin dynamics,
527
stochastic hill climbing, 299
stochastic Lanczos quadrature,
706
stochastic local search, 298, 299,
301
stochastic matrix, 47
stochastic meta descent, 192
Stochastic MuZero, 1155
stochastic process, 1037
stochastic RNN, 1027
stochastic variance reduced gradi￾ent, 528
stochastic variational inference,
438, 706
stochastic video generation, 1031
stochastic volatility model, 1012
stochastic weight averaging, 648
stop gradient, 806
stop words, 956
straight-through estimator, 273,
805
stratified resampling, 546
streaks, 397
stream-based selective sampling,
1126
streaming variational Bayes, 668
strict, 1097
strict overlap, 1185
strictly monotonic scalar function,
823
string kernel, 682
structural causal models, 211, 213,
1175
structural equation model, 199,
213
structural support vector machine,
193
structural time series, 1013
structural zeros, 177
structured kernel interpolation,
707
structured mean field, 465
structured prediction, 186
structured prediction energy net￾works, 193
structured prediction model, 1101
STS, 1013
Student distribution, 11
student network, 145, 146, 195,
422
Student t distribution, 11
style transfer, 911
sub-Gaussian, 13
subjective probability, 143
submodular, 1131
Submodular function, 318
subphones, 990
Subscale Pixel Network, 814
subset of regressors, 700
subset-of-data, 698
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
INDEX
subspace identification, 1003
subspace neural bandit, 1113
sufficient, 250
sufficient statistic, 46, 238
sufficient statistics, 34, 34, 64
sum of squares, 93
sum-product algorithm, 408
sum-product networks, 204
SupCon, 1055
super-Gaussian, 13
super-resolution model, 877
supervised PCA, 943
surjective, 44
surrogate assisted EA, 304
surrogate function, 281, 291
survival of the fittest, 543
suspicious coincidence, 120
SUTVA, 216
SVG, 1031
SVGP, 702
SVI, 438
SVRG-LD, 528
SWA, 648
SWAG, 649
Swendsen-Wang, 509
SWIG, 216
Swish, 625
Swiss roll, 864
switching linear dynamical system,
551, 1005
Sylvester flow, 834
symamd, 426
symmetric, 494
synchronous updates, 417
synergy, 240
syntactic sugar, 162
synthetic control, 1024
Synthetic controls, 1221
synthetic data, 767
systems biology, 1033
systems identification, 1001
systolic array, 412
t-statistic, 131
t-test, 134
T5, 794
tabu search, 299
tabular representation, 1119
tacotron, 813
TAN, 164
target aware Bayesian inference,
486
target distribution, 481, 484, 537,
727, 743
target domain, 909
target function, 484
target network, 1145
target policy, 1161
targeted attack, 758
TASA corpus, 954
task, 750
task interference, 744
task-aware learning, 752
Taylor series, 345
Taylor series expansion, 369
TD, 1141
TD error, 1137, 1141
TD(λ), 1142
TD3, 1153
telescoping sum, 860
temperature, 517
temperature scaling, 574
tempered posterior, 656
tempering, 669
template, 206
templates, 926
temporal difference, 1137, 1141
tensor decomposition, 985
tensor train decomposition, 708
TENT, 743
terminal state, 1119
terminals, 189
test and roll, 1105
test statistic, 80, 131
test statistics, 128
test time adaptation, 742
text generation, 768
text to speech, 813
text-to-image, 767
text-to-speech, 912
the deadly triad, 1166
thermodynamic integration, 468
thermodynamic variational objec￾tive, 468
thin shell, 23
Thompson sampling, 296, 1115
threat model, 760
tilted distribution, 473
time reversal, 558
time reversible, 55
time series forecasting, 199, 1013
time update step, 359
time-invariant, 47
Toeplitz, 708
top-down inference model, 800
topic model, 953
topic vector, 953
topic-RNN, 961
topological order, 154
topological ordering, 143
total correlation, 239, 788
total derivative, 270
total regret, 1117
total variation distance, 61
tournament selection, 302
trace plot, 520
trace rank plot, 521
traceback, 404, 410
track, 1006
tracking, 358
tractable substructure, 465
trajectory, 1135
trankplot, 521
trans-dimensional MCMC, 530
transductive active learning, 578
transductive learning, 733
transfer learning, 739, 1040
transformer, 636, 637
transformer VAE, 794
transformers, 794
transient, 54
transition, 1118
transition function, 47, 969
transition kernel, 47
transition matrix, 47, 48
transition model, 353, 969, 971,
1118
translation invariant, 967
translation-invariant prior, 106
Translucence, 1077
Transparency, 1075
transportable, 729
treatment, 1105
treatment effect, 1023
tree-augmented naive Bayes classi￾fier, 164
treewidth, 426
trellis diagram, 403
trigram model, 49
triplet loss, 1056
TRPO, 1151
truncated Gaussian, 615
truncation selection, 302, 304
trust region policy optimization,
1151
TT-GP, 708
TTA, 742
TTT, 743
turbocodes, 419
Turing, 211
turning the Bayesian crank, 340
TVO, 468
Tweedie’s formula, 847
twin network, 216, 1021
twisted particle filters, 564
twisting function, 564
two part code, 248
two sample tests, 778
two stage least squares, 1204
two-filter smoothing, 366, 399
two-moons, 670
two-sample t-test, 135, 138
two-sample test, 55
two-sample testing, 733
two-way ANOVA test, 140
type I error rate, 131
type II maximum likelihood, 114
type signature, 205
typical set, 23, 234
U-net, 863
UCB, 295, 1114
UCBVI, 1139
UCRL2, 1139
UDA, 741
UKF, 373
ULA, 516
ULD, 529
UMDA, 304
UME, 59
unary terms, 168, 177
unbiased, 1162
uncertainty metric, 734
uncertainty quantification, 579
uncertainty sampling, 1128
unclamped phase, 183, 843
unconstrained monotonic neural
networks, 824
underdamped Langevin dynamics,
529
underlying predictive model, 994
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1240
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
underspecification, 639
undirected local Markov property,
179
unfaithful, 180
uniform dequantization, 775
unigram model, 49
unigram statistics, 51
uninformative, 102
uninformative prior, 64, 591
uninformative priors, 71
units, 215
univariate marginal distribution al￾gorithm, 304
unnormalized mean embedding, 59
unnormalized target distribution,
485
unnormalized weights, 486, 540
unobserved confounders, 612
unpaired data, 910
unpaired t-test, 135
unroll, 206, 208
unrolled, 162
unscented Kalman filter, 373, 1011
unscented Kalman smoother, 376
unscented particle filter, 549
unscented RTS smoother, 376
unscented transform, 373
unsupervised domain adaptation,
741
unsupervised domain translation,
910
untargeted attack, 758
update step, 356
UPGM, 165
UPM, 994
upper confidence bound, 295,
1114
user rating profile model, 951
User studies, 1080
utility function, 1096
utility nodes, 1101
v-structure, 149, 151
VAE, 174, 765, 781
VAE-RNN, 794
VAFC, 443
vague prior, 594
validation set, 122
value function, 1121
value iteration, 1123
value nodes, 1101
value of perfect information, 1104
ValueDICE, 1172
values, 629
VAR, 199
variable binding problem, 817
variable duration HMM, 988
variable elimination, 422, 1104
variance exploding, 868
variance preserving, 868
variational approximation with fac￾tor covariance, 443
variational autoencoder, 781, 948
variational autoencoders, 765
variational Bayes, 346, 438, 453
variational Bayes EM, 458
variational continual learning, 669,
755
variational diffusion model, 861
variational EM, 118, 285, 289, 437,
458
variational free energy, 434, 702,
1170
variational GP, 466
variational IB, 251
variational inference, 33, 289, 346,
393, 433, 571, 775
variational message passing, 464
variational method, 433
variational online Gauss-Newton,
646
variational optimization, 278
variational overpruning, 669, 797
variational parameters, 346, 433
variational pruning, 804
variational pruning effect, 462
variational RNN, 1030
variational SMC, 564
varimax, 934
VB, 346
VCL, 669
VD-VAE, 801
VDM, 861
vector autoregressive, 199
vector quantization, 246
vector-Jacobian product (VJP),
257
verb phrases, 187
very deep VAE, 801
VFE, 702
VI, 346
VIB, 251
VIM, 809
VIREL, 1169
virtual samples, 96
visible nodes, 155
vision as inverse graphics, 917
visual SLAM, 554
Visualization, 1075
Viterbi algorithm, 403, 977
Viterbi training, 983
VMP, 464
VOGN, 646
von Mises, 18
von Mises-Fisher, 18
VQ-GAN, 809
VQ-VAE, 805
VRNN, 1030
wake phase, 469
wake-phase q update, 471
wake-sleep, 782
wake-sleep algorithm, 469
Wald’s theorem, 1097
warm-up, 514
Wasserstein-1 distance, 58
Watanabe–Akaike information cri￾terion, 127
wavenet, 813
weak marginalization, 388
weak prior, 594
weak supervision, 210
weakly informative, 101
weakly informative priors, 134
weakly-supervised representation
learning, 1048
wealth, 16
website testing, 1108
weight degeneracy, 541
weight of evidence, 223
weight space, 688
weighted ERM, 740
weighted least squares, 288
Weinstein-Aronszajn identity, 833
Welch’s t-test, 135
white noise kernel, 693
white noise process, 997
whitebox attack, 758
whitened coordinate system, 275
whitening, 964
widely applicable information crite￾rion, 127
Wiener noise, 527, 529
Wiener process, 867
Wilcoxon matched pairs, 137
Wilcoxon signed-ranked test, 137
wildcatter, 1102
Wishart, 19
witness function, 57
word error, 411
word2vec, 773
world model, 774
Xavier initialization, 640
z-bias, 1213
zero-avoiding, 223
zero-forcing, 223, 472
zero-inflated Poisson, 586, 1020
zero-one loss, 1098
zero-shot transfer, 1048
zero-sum losses, 894
ZIP, 586, 1020
Zipf’s law, 16
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2023Bibliography
[AA18] D. Amir and O. Amir. “Highlights: Summa￾rizing agent behavior to people”. In: Proceedings of
the 17th International Conference on Autonomous
Agents and MultiAgent Systems. 2018, pp. 1168–
1176.
[AB08] C. Archambeau and F. Bach. “Sparse proba￾bilistic projections”. In: NIPS. 2008.
[AB17] M. Arjovsky and L. Bottou. “Towards princi￾pled methods for training generative adversarial net￾works”. In: (2017).
[AB21] A. N. Angelopoulos and S. Bates. “A Gentle In￾troduction to Conformal Prediction and Distribution￾Free Uncertainty Quantification”. In: (2021). arXiv:
2107.07511 [cs.LG].
[Aba] A. Abadie. “Using Synthetic Controls: Feasibil￾ity, Data Requirements, and Methodological Aspects”.
In: J. of Economic Literature ().
[Abd+18] A. Abdolmaleki, J. T. Springenberg, Y.
Tassa, R. Munos, N. Heess, and M. A. Riedmiller.
“Maximum a Posteriori Policy Optimisation”. In:
ICLR. 2018.
[ABM10] J.-Y. Audibert, S. Bubeck, and R. Munos.
“Best Arm Identification in Multi-Armed Bandits”. In:
COLT. 2010, pp. 41–53.
[Abn+21] S. Abnar, M. Dehghani, B. Neyshabur, and
H. Sedghi. “Exploring the limits of large scale pre￾training”. In: ICLR. 2021.
[ABV21] S. Akbayrak, I. Bocharov, and B. de Vries.
“Extended Variational Message Passing for Auto￾mated Approximate Bayesian Inference”. In: Entropy
23.7 (2021).
[AC17] S. Aminikhanghahi and D. J. Cook. “A Survey
of Methods for Time Series Change Point Detection”.
en. In: Knowl. Inf. Syst. 51.2 (2017), pp. 339–367.
[AC93] J. Albert and S. Chib. “Bayesian analysis of
binary and polychotomous response data”. In: JASA
88.422 (1993), pp. 669–679.
[ACB17] M. Arjovsky, S. Chintala, and L. Bottou.
“Wasserstein generative adversarial networks”. In:
ICML. 2017, pp. 214–223.
[ACL16] L. Aitchison, N. Corradi, and P. E. Latham.
“Zipf’s Law Arises Naturally When There Are Under￾lying, Unobserved Variables”. en. In: PLoS Comput.
Biol. 12.12 (2016), e1005110.
[ACL89] L. Atlas, D. Cohn, and R. Ladner. “Training
connectionist networks with queries and selective sam￾pling”. In: Advances in neural information processing
systems 2 (1989).
[ACP87] S. Arnborg, D. G. Corneil, and A.
Proskurowski. “Complexity of finding embeddings
in a k-tree”. In: SIAM J. on Algebraic and Discrete
Methods 8 (1987), pp. 277–284.
[Ada00] L. Adamic. Zipf, Power-laws, and Pareto - a
ranking tutorial. Tech. rep. 2000.
[Ada+20] V. Adam, S. Eleftheriadis, N. Durrande, A.
Artemev, and J. Hensman. “Doubly Sparse Variational
Gaussian Processes”. In: AISTATS. 2020.
[Ade+20a] J. Adebayo, J. Gilmer, M. Muelly, I. Good￾fellow, M. Hardt, and B. Kim. Sanity Checks for
Saliency Maps. 2020. arXiv: 1810.03292 [cs.CV].
[Ade+20b] J. Adebayo, M. Muelly, I. Liccardi, and B.
Kim. “Debugging tests for model explanations”. In:
arXiv preprint arXiv:2011.05429 (2020).
[Adl+18] P. Adler, C. Falk, S. A. Friedler, T. Nix, G.
Rybeck, C. Scheidegger, B. Smith, and S. Venkata￾subramanian. “Auditing black-box models for indirect
influence”. In: Knowledge and Information Systems
54.1 (2018), pp. 95–122.
[Ado] Taking It to the MAX: Adobe Photoshop Gets
New NVIDIA AI-Powered Neural Filters. https : / /
blogs . nvidia. com / blog / 2020 / 10 / 20 / adobe - max - ai/.
Accessed: 2021-08-12.
[ADT12] C. Andrieu, A. Doucet, and V. B. Tadić.
“One-line Parameter Estimation in General State￾Space Models using a Pseudo-Likelihood Approach”.
In: IFAC Proceedings Volumes 45.16 (July 2012),
pp. 500–505.
[AE+20] D. Agudelo-España, S. Gomez-Gonzalez, S.
Bauer, B. Schölkopf, and J. Peters. “Bayesian Online
Prediction of Change Points”. In: UAI. Vol. 124. Pro￾ceedings of Machine Learning Research. PMLR, 2020,
pp. 320–329.
[AFD01] C. Andrieu, N. de Freitas, and A. Doucet.
“Robust Full Bayesian Learning for Radial Basis
Networks”. In: Neural Computation 13.10 (2001),
pp. 2359–2407.
[AFG19] M. Akten, R. Fiebrink, and M. Grierson.
“Learning to See: You Are What You See”. In: ACM
SIGGRAPH 2019 Art Gallery. SIGGRAPH ’19. As￾sociation for Computing Machinery, 2019.
[AG11] A. Allahverdyan and A. Galstyan. “Compar￾ative Analysis of Viterbi Training and Maximum
Likelihood Estimation for HMMs”. In: NIPS. 2011,
pp. 1674–1682.
[AG13] S. Agrawal and N. Goyal. “Further Optimal Re￾gret Bounds for Thompson Sampling”. In: AISTATS.
2013.
[Aga+14] D. Agarwal, B. Long, J. Traupman, D. Xin,
and L. Zhang. “LASER: a scalable response prediction
platform for online advertising”. In: WSDM. 2014.
[Aga+21a] A. Agarwal, N. Jiang, S. M. Kakade, and
W. Sun. Reinforcement Learning: Theory and Algo￾rithms. 2021.
[Aga+21b] R. Agarwal, L. Melnick, N. Frosst, X.
Zhang, B. Lengerich, R. Caruana, and G. Hinton. Neu￾ral Additive Models: Interpretable Machine Learning
with Neural Nets. 2021. arXiv: 2004.13912 [cs.LG].
[Aga+22] A. Agarwal, N. Jiang, S. Kakade, and
W. Sun. Reinforcement Learning:Theory and Algo￾rithms. 2022.1242
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[AGM14] P. Agrawal, R. Girshick, and J. Malik. “Ana￾lyzing the performance of multilayer neural networks
for object recognition”. In: European conference on
computer vision. Springer. 2014, pp. 329–344.
[AGM19] V. Amrhein, S. Greenland, and B. McShane.
“Scientists rise up against statistical significance”. In:
Nature 567.7748 (2019), p. 305.
[AH09] I. Arasaratnam and S. Haykin. “Cubature
Kalman Filters”. In: IEEE Trans. Automat. Contr.
54.6 (2009), pp. 1254–1269.
[AHE07] I. Arasaratnam, S. Haykin, and R. J. El￾liott. “Discrete-Time Nonlinear Filtering Algorithms
Using Gauss–Hermite Quadrature”. In: Proc. IEEE
95.5 (2007), pp. 953–977.
[AHG20] L. Ambrogioni, M. Hinne, and M. van Ger￾ven. “Automatic structured variational inference”. In:
(2020). arXiv: 2002.00643 [stat.ML].
[AHK01] C. C. Aggarwal, A. Hinneburg, and D. A.
Keim. “On the Surprising Behavior of Distance Met￾rics in High Dimensional Space”. In: Database The￾ory — ICDT 2001. Springer Berlin Heidelberg, 2001,
pp. 420–434.
[AHK12] A. Anandkumar, D. Hsu, and S. M. Kakade.
“A Method of Moments for Mixture Models and Hid￾den Markov Models”. In: COLT. Vol. 23. Proceedings
of Machine Learning Research. PMLR, 2012, pp. 33.1–
33.34.
[AHK65] K. Abend, T. J. Harley, and L. N. Kanal.
“Classification of Binary Random Patterns”. In: IEEE
Transactions on Information Theory 11(4) (1965),
pp. 538–544.
[Ahm+17] S. Ahmad, A. Lavin, S. Purdy, and Z. Agha.
“Unsupervised real-time anomaly detection for stream￾ing data”. In: Neurocomputing 262 (2017), pp. 134–
147.
[AHP+05] P. K. Agarwal, S. Har-Peled, et al. “Geo￾metric approximation via coresets”. In: Combinatorial
and computational geometry 52.1-30 (2005), p. 3.
[AHS85] D. Ackley, G. Hinton, and T. Sejnowski. “A
Learning Algorithm for Boltzmann Machines”. In:
Cognitive Science 9 (1985), pp. 147–169.
[AHT07] Y. Altun, T. Hofmann, and I. Tsochantaridis.
“Support Vector Machine Learning for Interdepen￾dent and Structured Output Spaces”. In: Predicting
Structured Data. Ed. by G. Bakir, T. Hofmann, B.
Scholkopf, A. Smola, B. Taskar, and S. Vishwanathan.
MIT Press, 2007.
[Ahu+21] K. Ahuja, J. Wang, A. Dhurandhar, K. Shan￾mugam, and K. R. Varshney. “Empirical or Invariant
Risk Minimization? A Sample Complexity Perspec￾tive”. In: ICLR. 2021.
[AI 19] AI Artists. Creative Tools to Generate AI Art.
2019.
[Ait21] L. Aitchison. “A statistical theory of cold pos￾teriors in deep neural networks”. In: ICLR. 2021.
[Aka74] H. Akaike. “A new look at the statistical model
identification”. In: IEEE Trans. on Automatic Con￾trol 19.6 (1974).
[AKO18] S.-I. Amari, R. Karakida, and M. Oizumi.
“Fisher Information and Natural Gradient Learning
of Random Deep Networks”. In: (2018). arXiv: 1808 .
07172 [cs.LG].
[AKZK19] B. Amos, V. Koltun, and J Zico Kolter.
“The Limited Multi-Label Projection Layer”. In:
(2019). arXiv: 1906.08707 [cs.LG].
[AL+16] J. Ala-Luhtala, N. Whiteley, K. Heine, and
R. Piche. “An Introduction to Twisted Particle Fil￾ters and Parameter Estimation in Non-linear State￾space Models”. In: IEEE Trans. Signal Process. 64.18
(2016), pp. 4875–4890.
[al21] M. A. et al. Understanding Dataset Shift and
Potential Remedies. Tech. rep. Vector Institute, 2021.
[Ale+16] A. A. Alemi, I. Fischer, J. V. Dillon, and K.
Murphy. “Deep Variational Information Bottleneck”.
In: ICLR. 2016.
[Ale+17] A. A. Alemi, I. S. Fischer, J. V. Dillon, and
K. P. Murphy. “Deep Variational Information Bottle￾neck”. In: ArXiv abs/1612.00410 (2017).
[Ale+18] A. A. Alemi, B. Poole, I. Fischer, J. V. Dil￾lon, R. A. Saurous, and K. Murphy. “Fixing a broken
ELBO”. In: ICML. 2018.
[Alq21] P. Alquier. “User-friendly introduction to PAC￾Bayes bounds”. In: (2021). arXiv: 2110 . 11216
[stat.ML].
[Alq22] P. Alquier. “Approximate Bayesian Inference”.
In: Entropy 22.11 (2022).
[Als+19] J. Alsing, T. Charnock, S. Feeney, and B.
Wandelt. “Fast likelihood-free cosmology with neural
density estimators and active learning”. In: Monthly
Notices of the Royal Astronomical Society 488.3
(2019), pp. 4440–4458.
[ALS20] B. Axelrod, Y. P. Liu, and A. Sidford. “Near￾optimal approximate discrete and continuous submod￾ular function minimization”. In: Proceedings of the
Fourteenth Annual ACM-SIAM Symposium on Dis￾crete Algorithms. SIAM. 2020, pp. 837–853.
[AM07] R. P. Adams and D. J. C. MacKay. “Bayesian
Online Changepoint Detection”. In: (2007). arXiv:
0710.3742 [stat.ML].
[AM+16] M. Auger-Méthé, C. Field, C. M. Albertsen,
A. E. Derocher, M. A. Lewis, I. D. Jonsen, and J. Mills
Flemming. “State-space models’ dirty little secrets:
even simple linear Gaussian models can have estima￾tion problems”. en. In: Sci. Rep. 6 (2016), p. 26677.
[AM74] D. Andrews and C. Mallows. “Scale mixtures
of Normal distributions”. In: J. of Royal Stat. Soc.
Series B 36 (1974), pp. 99–102.
[AM89] B. D. Anderson and J. B. Moore. Optimal Con￾trol: Linear Quadratic Methods. Prentice-Hall Inter￾national, Inc., 1989.
[Ama09] S.-I. Amari. “α-Divergence Is Unique, Belong￾ing to Both f-Divergence and Bregman Divergence
Classes”. In: IEEE Trans. Inf. Theory 55.11 (2009),
pp. 4925–4931.
[Ama98] S Amari. “Natural Gradient Works Efficiently
in Learning”. In: Neural Comput. 10.2 (1998), pp. 251–
276.
[Ame+19] S. Amershi, D. Weld, M. Vorvoreanu, A.
Fourney, B. Nushi, P. Collisson, J. Suh, S. Iqbal, P. N.
Bennett, K. Inkpen, et al. “Guidelines for human-AI
interaction”. In: Proceedings of the 2019 chi confer￾ence on human factors in computing systems. 2019,
pp. 1–13.
[Ami01] E. Amir. “Efficient Approximation for Trian￾gulation of Minimum Treewidth”. In: UAI. 2001.
[AMJ18a] D. Alvarez-Melis and T. S. Jaakkola. “On
the robustness of interpretability methods”. In: arXiv
preprint arXiv:1806.08049 (2018).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[AMJ18b] D. Alvarez-Melis and T. S. Jaakkola. “To￾wards robust interpretability with self-explaining neu￾ral networks”. In: arXiv preprint arXiv:1806.07538
(2018).
[Amo+16] D. Amodei, C. Olah, J. Steinhardt, P. F.
Christiano, J. Schulman, and D. Mané. “Concrete
Problems in AI Safety”. In: CoRR abs/1606.06565
(2016). arXiv: 1606.06565.
[Amo+18] B. Amos, L. Dinh, S. Cabi, T. Rothörl, S. G.
Colmenarejo, A. Muldal, T. Erez, Y. Tassa, N. de Fre￾itas, and M. Denil. “Learning Awareness Models”. In:
ICLR. 2018.
[Amo22] B. Amos. “Tutorial on amortized optimization
for learning to optimize over continuous domains”. In:
(2022). arXiv: 2202.00665 [cs.LG].
[AMO88] R. K. Ahuja, T. L. Magnanti, and J. B. Orlin.
“Network flows”. In: (1988).
[Ana+14] A. Anandkumar, R. Ge, D. Hsu, S. M.
Kakade, and M. Telgarsky. “Tensor Decompositions
for Learning Latent Variable Models”. In: JMLR 15
(2014), pp. 2773–2832.
[And+03] C. Andrieu, N. de Freitas, A. Doucet, and
M. Jordan. “An introduction to MCMC for machine
learning”. In: Machine Learning 50 (2003), pp. 5–43.
[And+20] O. M. Andrychowicz et al. “Learning dexter￾ous in-hand manipulation”. In: Int. J. Rob. Res. 39.1
(2020), pp. 3–20.
[And82] B. D. O. Anderson. “Reverse-time diffusion
equation models”. In: Stochastic Processes and thei
Applications 12.3 (May 1982), pp. 313–326.
[Ang+18] E. Angelino, N. Larus-Stone, D. Alabi, M.
Seltzer, and C. Rudin. Learning Certifiably Optimal
Rule Lists for Categorical Data. 2018. arXiv: 1704 .
01701 [stat.ML].
[Ang+20] C. Angermueller, D. Dohan, D. Belanger, R.
Deshpande, K. Murphy, and L. Colwell. “Model-based
reinforcement learning for biological sequence design”.
In: ICLR. 2020.
[Ang+21] A. N. Angelopoulos, S. Bates, E. J. Candès,
M. I. Jordan, and L. Lei. “Learn then Test: Calibrat￾ing Predictive Algorithms to Achieve Risk Control”.
In: (2021). arXiv: 2110.01052 [cs.LG].
[Ang88] D. Angluin. “Queries and concept learning”. In:
Machine learning 2.4 (1988), pp. 319–342.
[Ani+18] R. Anirudh, J. J. Thiagarajan, B. Kailkhura,
and T. Bremer. “An Unsupervised Approach to Solv￾ing Inverse Problems using Generative Adversarial
Networks”. In: (2018). arXiv: 1805.07281 [cs.CV].
[Ano19] Anonymous. “Neural Tangents: Fast and Easy
Infinite Neural Networks in Python”. In: (2019).
[Ant+22] I. Antonoglou, J. Schrittwieser, S. Ozair,
T. K. Hubert, and D. Silver. “Planning in Stochastic
Environments with a Learned Model”. In: ICLR. 2022.
[AO03] J.-H. Ahn and J.-H. Oh. “A Constrained EM
Algorithm for Principal Component Analysis”. In:
Neural Computation 15 (2003), pp. 57–65.
[AOM17] M. G. Azar, I. Osband, and R. Munos. “Min￾imax Regret Bounds for Reinforcement Learning”. In:
ICML. 2017, pp. 263–272.
[AP08] J. D. Angrist and J.-S. Pischke. Mostly
harmless econometrics: An empiricist’s companion.
Princeton university press, 2008.
[AP09] J. Angrist and J.-S. Pischke. Mostly Harmless
Econometrics. 2009.
[AP19] M. Abadi and G. D. Plotkin. “A simple differen￾tiable programming language”. In: Proceedings of the
ACM on Programming Languages 4.POPL (2019),
pp. 1–28.
[Ara+09] A. Aravkin, B. Bell, J. Burke, and G. Pil￾lonetto. An L1-Laplace Robust Kalman Smoother.
Tech. rep. U. Washington, 2009.
[Ara10] A. Aravkin. Student’s t Kalman Smoother.
Tech. rep. U. Washington, 2010.
[Ara+17] A. Aravkin, J. V. Burke, L. Ljung, A. Lozano,
and G. Pillonetto. “Generalized Kalman smoothing:
Modeling and algorithms”. In: Automatica 86 (2017),
pp. 63–86.
[Arb+18] M. Arbel, D. Sutherland, M. Bińkowski,
and A. Gretton. “On gradient regularizers for MMD
GANs”. In: Advances in neural information process￾ing systems. 2018, pp. 6700–6710.
[Arj+19] M. Arjovsky, L. Bottou, I. Gulrajani, and D.
Lopez-Paz. “Invariant Risk Minimization”. In: (2019).
arXiv: 1907.02893 [stat.ML].
[Arj+20] M. Arjovsky, L. Bottou, I. Gulrajani, and D.
Lopez-Paz. Invariant Risk Minimization. 2020. arXiv:
1907.02893 [stat.ML].
[Arn+10] C. W. Arnold, S. M. El-Saden, A. A. Bui, and
R. Taira. “Clinical case-based retrieval using latent
topic analysis”. In: AMIA annual symposium proceed￾ings. Vol. 2010. American Medical Informatics Associ￾ation. 2010, p. 26.
[Aro+13] S. Arora, R. Ge, Y. Halpern, D. Mimno, A.
Moitra, D. Sontag, Y. Wu, and M. Zhu. “A Practical
Algorithm for Topic Modeling with Provable Guaran￾tees”. In: ICML. 2013.
[Aro+19] S. Arora, S. S. Du, W. Hu, Z. Li, R. Salakhut￾dinov, and R. Wang. “On Exact Computation with an
Infinitely Wide Neural Net”. In: (2019). arXiv: 1904.
11955 [cs.LG].
[Aro+21] R. Arora et al. Theory of deep learning.
2021.
[ARS13] N. S. Arora, S. Russell, and E. Sudderth.
“NET-VISA: Network Processing Vertically Integrated
Seismic AnalysisNET-VISA: Network Processing Ver￾tically Integrated Seismic Analysis”. In: Bull. Seismol.
Soc. Am. 103.2A (2013), pp. 709–729.
[Aru+02] M. Arulampalam, S. Maskell, N. Gordon,
and T. Clapp. “A Tutorial on Particle Filters for
Online Nonlinear/Non-Gaussian Bayesian Tracking”.
In: IEEE Trans. on Signal Processing 50.2 (2002),
pp. 174–189.
[Aru+17] K. Arulkumaran, M. P. Deisenroth, M.
Brundage, and A. A. Bharath. “A Brief Survey of Deep
Reinforcement Learning”. In: IEEE Signal Processing
Magazine, Special Issue on Deep Learning for Image
Understanding (2017).
[AS17] A. Achille and S. Soatto. “On the Emergence
of Invariance and Disentangling in Deep Representa￾tions”. In: (2017). arXiv: 1706.01350 [cs.LG].
[AS18] A. Achille and S. Soatto. “On the Emergence
of Invariance and Disentangling in Deep Representa￾tions”. In: JMLR 18 (2018), pp. 1–34.
[AS66] S. M. Ali and S. D. Silvey. “A General Class
of Coefficients of Divergence of One Distribution
from Another”. In: J. R. Stat. Soc. Series B Stat.
Methodol. 28.1 (1966), pp. 131–142.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1244
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[Asa00] C. Asavathiratham. “The Influence Model: A
Tractable Representation for the Dynamics of Net￾worked Markov Chains”. PhD thesis. MIT, Dept.
EECS, 2000.
[ASD20] A. Agrawal, D. Sheldon, and J. Domke. “Ad￾vances in Black-Box VI: Normalizing Flows, Impor￾tance Weighting, and Optimization”. In: NIPS. 2020.
[ASM17] A. Azuma, M. Shimbo, and Y. Matsumoto.
“An Algebraic Formalization of Forward and Forward￾backward Algorithms”. In: (2017). arXiv: 1702.06941
[cs.LG].
[ASN20] R. Agarwal, D. Schuurmans, and M. Norouzi.
“An Optimistic Perspective on Offline Reinforcement
Learning”. In: ICML. 2020.
[ASS19] I. Andrews, J. H. Stock, and L. Sun. “Weak In￾struments in Instrumental Variables Regression: The￾ory and Practice”. In: Annual Review of Economics
11.1 (2019).
[AT08] C. Andrieu and J. Thoms. “A tutorial on adap￾tive MCMC”. In: Statistical Computing 18 (2008),
pp. 343–373.
[AT20] E. Agustsson and L. Theis. “Universally Quan￾tized Neural Compression”. 2020.
[Att00] H. Attias. “A Variational Bayesian Framework
for Graphical Models”. In: NIPS-12. 2000.
[Att03] H. Attias. “Planning by Probabilistic Infer￾ence”. In: AI-Stats. 2003.
[Aue12] J. E. Auerbach. “Automated evolution of inter￾esting images”. In: Artificial Life 13. 2012.
[Aus+21] J. Austin, D. D. Johnson, J. Ho, D. Tarlow,
and R. van den Berg. “Structured Denoising Diffusion
Models in Discrete State-Spaces”. In: NIPS. July 2021.
[AWR17] J. Altschuler, J. Weed, and P. Rigollet. “Near￾linear time approximation algorithms for optimal
transport via Sinkhorn iteration”. In: arXiv preprint
arXiv:1705.09634 (2017).
[AXK17] B. Amos, L. Xu, and J. Z. Kolter. “Input con￾vex neural networks”. In: International Conference on
Machine Learning. PMLR. 2017, pp. 146–155.
[AY19] B. Amos and D. Yarats. “The Differentiable
Cross-Entropy Method”. In: (2019). arXiv: 1909.12830
[cs.LG].
[AZ17] S. Arora and Y. Zhang. “Do gans actually
learn the distribution? an empirical study”. In: arXiv
preprint arXiv:1706.08224 (2017).
[Aze+20] E. M. Azevedo, A. Deng, J. L. Montiel Olea,
J. Rao, and E. G. Weyl. “A/B Testing with Fat Tails”.
In: J. Polit. Econ. (2020), pp. 000–000.
[Azi+15] H. Azizpour, A. Sharif Razavian, J. Sullivan,
A. Maki, and S. Carlsson. “From generic to specific
deep representations for visual recognition”. In: Pro￾ceedings of the IEEE conference on computer vision
and pattern recognition workshops. 2015, pp. 36–45.
[BA03] D. Barber and F. Agakov. “The IM Algorithm:
A Variational Approach to Information Maximization”.
In: NIPS. NIPS’03. MIT Press, 2003, pp. 201–208.
[BA05] W. Bechtel and A. Abrahamsen. “Explanation:
A mechanist alternative”. In: Studies in History and
Philosophy of Science Part C: Studies in History
and Philosophy of Biological and Biomedical Sci￾ences 36.2 (2005), pp. 421–441.
[Bac09] F. Bach. “High-Dimensional Non-Linear Vari￾able Selection through Hierarchical Kernel Learning”.
In: (2009). arXiv: 0909.0844 [cs.LG].
[Bac+13] F. Bach et al. “Learning with Submodular
Functions: A Convex Optimization Perspective”. In:
Foundations and Trends® in Machine Learning 6.2-
3 (2013), pp. 145–373.
[Bac+15a] S. Bach, A. Binder, G. Montavon, F.
Klauschen, K.-R. Müller, and W. Samek. “On pixel￾wise explanations for non-linear classifier decisions by
layer-wise relevance propagation”. In: PloS one 10.7
(2015), e0130140.
[Bac+15b] S. H. Bach, M. Broecheler, B. Huang, and
L. Getoor. “Hinge-Loss Markov Random Fields and
Probabilistic Soft Logic”. In: (2015). arXiv: 1505.04406
[cs.LG].
[Bac+18] E. Bach, J. Dusart, L. Hellerstein, and D.
Kletenik. “Submodular goal value of Boolean func￾tions”. In: Discrete Applied Mathematics 238 (2018),
pp. 1–13.
[Bad+18] M. A. Badgeley, J. R. Zech, L. Oakden￾Rayner, B. S. Glicksberg, M. Liu, W. Gale, M. V.
McConnell, B. Percha, T. M. Snyder, and J. T. Dud￾ley. “Deep Learning Predicts Hip Fracture using Con￾founding Patient and Healthcare Variables”. In: CoRR
abs/1811.03695 (2018). arXiv: 1811.03695.
[Bah+20] Y. Bahri, J. Kadmon, J. Pennington, S.
Schoenholz, J. Sohl-Dickstein, and S. Ganguli. “Sta￾tistical Mechanics of Deep Learning”. In: Annu. Rev.
Condens. Matter Phys. (2020).
[Bai+15] R. Bairi, R. Iyer, G. Ramakrishnan, and J.
Bilmes. “Summarization of multi-document topic hier￾archies using submodular mixtures”. In: Proceedings
of the 53rd Annual Meeting of the Association for
Computational Linguistics and the 7th International
Joint Conference on Natural Language Processing
(Volume 1: Long Papers). 2015, pp. 553–563.
[Bai95] L. C. Baird. “Residual Algorithms: Reinforce￾ment Learning with Function Approximation”. In:
ICML. 1995, pp. 30–37.
[Bak+17] J. Baker, P. Fearnhead, E. B. Fox, and C.
Nemeth. “Control Variates for Stochastic Gradient
MCMC”. In: (2017). arXiv: 1706.05439 [stat.CO].
[Bal17] S. Baluja. “Learning deep models of optimiza￾tion landscapes”. In: IEEE Symposium Series on
Computational Intelligence (SSCI) (2017).
[Bal+18] D. Balduzzi, S. Racaniere, J. Martens, J. Fo￾erster, K. Tuyls, and T. Graepel. “The mechanics of
n-player differentiable games”. In: International Con￾ference on Machine Learning. PMLR. 2018, pp. 354–
363.
[Ban+05] A. Banerjee, I. S. Dhillon, J. Ghosh, and S.
Sra. “Clustering on the unit hypersphere using von
Mises-Fisher distributions”. In: JMLR. 2005, pp. 1345–
1382.
[Ban06] A. Banerjee. “On bayesian bounds”. In: ICML.
2006, pp. 81–88.
[Ban+18] A. Bansal, S. Ma, D. Ramanan, and Y.
Sheikh. “Recycle-gan: Unsupervised video retarget￾ing”. In: Proceedings of the European conference on
computer vision (ECCV). 2018, pp. 119–135.
[Bao+22a] F. Bao, S. Nie, K. Xue, Y. Cao, C. Li, H.
Su, and J. Zhu. “All are Worth Words: A ViT Back￾bone for Diffusion Models”. In: (Sept. 2022). arXiv:
2209.12152 [cs.CV].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Bao+22b] H. Bao, L. Dong, S. Piao, and F. Wei.
“BEiT: BERT Pre-Training of Image Transformers”.
In: International Conference on Learning Represen￾tations. 2022.
[Bas+01] S. Basu, T. Choudhury, B. Clarkson, and A.
Pentland. Learning Human Interactions with the In￾fluence Model. Tech. rep. 539. MIT Media Lab, 2001.
[Bat+12] D. Batra, P. Yadollahpour, A. Guzman￾Rivera, and G. Shakhnarovich. “Diverse M-Best Solu￾tions in Markov Random Fields”. In: ECCV. Springer
Berlin Heidelberg, 2012, pp. 1–16.
[Bau+17] D. Bau, B. Zhou, A. Khosla, A. Oliva, and
A. Torralba. “Network Dissection: Quantifying Inter￾pretability of Deep Visual Representations”. In: Com￾puter Vision and Pattern Recognition. 2017.
[Bau+18] D. Bau, J.-Y. Zhu, H. Strobelt, B. Zhou,
J. B. Tenenbaum, W. T. Freeman, and A. Tor￾ralba. “Gan dissection: Visualizing and understanding
generative adversarial networks”. In: arXiv preprint
arXiv:1811.10597 (2018).
[Bau+20] D. Bau, J.-Y. Zhu, H. Strobelt, A. Lapedriza,
B. Zhou, and A. Torralba. “Understanding the role of
individual units in a deep neural network”. In: Proceed￾ings of the National Academy of Sciences (2020).
[Bau+70] L. E. Baum, T. Petrie, G. Soules, and N.
Weiss. “A maximization technique occuring in the sta￾tistical analysis of probabalistic functions in Markov
chains”. In: The Annals of Mathematical Statistics 41
(1970), pp. 164–171.
[Bau74] B. G. Baumgart. “Geometric modeling for com￾puter vision.” In: 1974.
[Bax00] J Baxter. “A Model of Inductive Bias Learn￾ing”. In: JAIR (2000).
[Bay+15] A. G. Baydin, B. A. Pearlmutter, A. A.
Radul, and J. M. Siskind. “Automatic differentiation
in machine learning: a survey”. In: (2015). arXiv: 1502.
05767 [cs.SC].
[BB08] O. Bousquet and L. Bottou. “The Tradeoffs of
Large Scale Learning”. In: NIPS. 2008, pp. 161–168.
[BB11] L. Bottou and O. Bousquet. “The Tradeoffs of
Large Scale Learning”. In: Optimization for Machine
Learning. Ed. by S. Sra, S. Nowozin, and S. J. Wright.
MIT Press, 2011, pp. 351–368.
[BB12] J. Bergstra and Y. Bengio. “Random Search for
Hyper-Parameter Optimization”. In: JMLR 13 (2012),
pp. 281–305.
[BB15a] A. Bendale and T. Boult. “Towards Open
World Recognition”. In: CVPR. 2015.
[BB15b] J. Bornschein and Y. Bengio. “Reweighted
Wake-Sleep”. In: ICLR. 2015.
[BB17] J. Bilmes and W. Bai. “Deep Submodular Func￾tions”. In: Arxiv abs/1701.08939 (2017).
[BB18] W. Bai and J. Bilmes. “Greed is Still Good:
Maximizing Monotone Submodular+Supermodular
(BP) Functions”. In: International Conference on Ma￾chine Learning (ICML). http : / / proceedings . mlr .
press/v80/bai18a.html. Stockholm, Sweden, 2018.
[BBM10] N. Bhatnagar, C. Bogdanov, and E. Mossel.
The Computational Complexity of Estimating Con￾vergence Time. Tech. rep. arxiv, 2010.
[BBS09] J. O. Berger, J. M. Bernardo, and D. Sun.
“The Formal Definition of Reference Priors”. In: Ann.
Stat. 37.2 (2009), pp. 905–938.
[BBS95] A. G. Barto, S. J. Bradtke, and S. P. Singh.
“Learning to act using real-time dynamic program￾ming”. In: AIJ 72.1 (1995), pp. 81–138.
[BBV11a] R. Benassi, J. Bect, and E. Vazquez.
“Bayesian optimization using sequential Monte Carlo”.
In: (2011). arXiv: 1111.4802 [math.OC].
[BBV11b] R. Benassi, J. Bect, and E. Vazquez. “Ro￾bust Gaussian Process-Based Global Optimization Us￾ing a Fully Bayesian Expected Improvement Crite￾rion”. en. In: Intl. Conf. on Learning and Intelligent
Optimization (LION). 2011, pp. 176–190.
[BC07] D. Barber and S. Chiappa. “Unified inference
for variational Bayesian linear Gaussian state space
models”. In: NIPS. 2007.
[BC08] M. Bădoiu and K. L. Clarkson. “Optimal core￾sets for balls”. In: Computational Geometry 40.1
(2008), pp. 14–22.
[BC14] J. Ba and R. Caruana. “Do Deep Nets Really
Need to be Deep?” In: Advances in Neural Informa￾tion Processing Systems 27 (2014).
[BC17] D. Beck and T. Cohn. “Learning Kernels over
Strings using Gaussian Processes”. In: Proceedings of
the Eighth International Joint Conference on Natu￾ral Language Processing (Volume 2: Short Papers).
Vol. 2. 2017, pp. 67–73.
[BC89] D. P. Bertsekas and D. A. Castanon. “The auc￾tion algorithm for the transportation problem”. In:
Annals of Operations Research 20.1 (1989), pp. 67–
96.
[BC93] B. M. Bell and F. W. Cathey. “The iterated
Kalman filter update as a Gauss-Newton method”.
In: IEEE Trans. Automat. Contr. 38.2 (Feb. 1993),
pp. 294–297.
[BC94] P. Baldi and Y. Chauvin. “Smooth online learn￾ing algorithms for Hidden Markov Models”. In: Neural
Computation 6 (1994), pp. 305–316.
[BC95] S. Baluja and R. Caruana. “Removing the
Genetics from the Standard Genetic Algorithm”. In:
ICML. 1995, pp. 38–46.
[BCF10] E. Brochu, V. M. Cora, and N. de Freitas. “A
Tutorial on Bayesian Optimization of Expensive Cost
Functions, with Application to Active User Modeling
and Hierarchical Reinforcement Learning”. In: (2010).
arXiv: 1012.2599 [cs.LG].
[BCH20] M. Briers, M. Charalambides, and C. Holmes.
“Risk scoring calculation for the current NHSx contact
tracing app”. In: (2020). arXiv: 2005.11057 [cs.CY].
[BCJ20] A. Buchholz, N. Chopin, and P. E. Ja￾cob. “Adaptive Tuning Of Hamiltonian Monte Carlo
Within Sequential Monte Carlo”. In: Bayesian Anal.
(2020).
[BCN18] L. Bottou, F. E. Curtis, and J. Nocedal. “Op￾timization Methods for Large-Scale Machine Learn￾ing”. In: SIAM Rev. 60.2 (2018), pp. 223–311.
[BCNM06] C. Buciluˇa, R. Caruana, and A. Niculescu￾Mizil. “Model compression”. In: Proceedings of the
12th ACM SIGKDD international conference on
Knowledge discovery and data mining. 2006, pp. 535–
541.
[BCV13] Y. Bengio, A. Courville, and P. Vincent. “Rep￾resentation learning: A review and new perspectives”.
In: IEEE transactions on pattern analysis and ma￾chine intelligence 35.8 (2013), pp. 1798–1828.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1246
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[BD+10] S. Ben-David, J. Blitzer, K. Crammer, A.
Kulesza, F. Pereira, and J. W. Vaughan. “A theory
of learning from different domains”. In: Mach. Learn.
79.1 (May 2010), pp. 151–175.
[BD11] A. Bhattacharya and D. B. Dunson. “Simplex
factor models for multivariate unordered categorical
data”. In: JASA (2011).
[BD87] G. Box and N. Draper. Empirical Model￾Building and Response Surfaces. Wiley, 1987.
[BD92] D. Bayer and P. Diaconis. “Trailing the dovetail
shuffle to its lair”. In: The Annals of Applied Proba￾bility 2.2 (1992), pp. 294–313.
[BD97] S. Baluja and S. Davies. “Using Optimal
Dependency-Trees for Combinatorial Optimization:
Learning the Structure of the Search Space”. In: ICML.
1997.
[BDM09] R. Burkard, M. Dell’Amico, and S. Martello.
Assignment Problems. SIAM, 2009.
[BDM10] M. Briers, A. Doucet, and S. Maskel.
“Smoothing algorithms for state-space models”. In:
Annals of the Institute of Statistical Mathematics
62.1 (2010), pp. 61–89.
[BDM17] M. G. Bellemare, W. Dabney, and R. Munos.
“A Distributional Perspective on Reinforcement Learn￾ing”. In: ICML. 2017.
[BDM18] N. Brosse, A. Durmus, and E. Moulines. “The
promises and pitfalls of Stochastic Gradient Langevin
Dynamics”. In: NIPS. 2018.
[BDS18] A. Brock, J. Donahue, and K. Simonyan.
“Large Scale GAN Training for High Fidelity Natu￾ral Image Synthesis”. In: (2018). arXiv: 1809 . 11096
[cs.LG].
[Bea03] M. Beal. “Variational Algorithms for Approx￾imate Bayesian Inference”. PhD thesis. Gatsby Unit,
2003.
[Bea19] M. A. Beaumont. “Approximate Bayesian
Computation”. In: Annual Review of Statistics and
Its Application 6.1 (2019), pp. 379–403.
[Béd08] M. Bédard. “Optimal acceptance rates for
Metropolis algorithms: Moving beyond 0.234”. In:
Stochastic Process. Appl. 118.12 (2008), pp. 2198–
2222.
[Beh+19] J. Behrmann, W. Grathwohl, R. T. Q. Chen,
D. Duvenaud, and J.-H. Jacobsen. “Invertible Resid￾ual Networks”. In: ICML. 2019.
[Bel03] A. J. Bell. “The co-information lattice”. In: ICA
conference. 2003.
[Bel+16] M. G. Bellemare, S. Srinivasan, G. Ostro￾vski, T. Schaul, D. Saxton, and R. Munos. “Unifying
Count-Based Exploration and Intrinsic Motivation”.
In: NIPS. 2016.
[Bel+18] M. I. Belghazi, A. Baratin, S. Rajeshwar, S.
Ozair, Y. Bengio, A. Courville, and D. Hjelm. “Mutual
Information Neural Estimation”. In: ICML. Ed. by J.
Dy and A. Krause. Vol. 80. Proceedings of Machine
Learning Research. PMLR, 2018, pp. 531–540.
[Bel+19] D. Belanger, S. Vora, Z. Mariet, R. Desh￾pande, D. Dohan, C. Angermueller, K. Murphy, O.
Chapelle, and L. Colwell. “Biological Sequence De￾sign using Batched Bayesian Optimization”. In: NIPS
workshop on ML for the sciences. 2019.
[Bel94] B. M. Bell. “The Iterated Kalman Smoother as
a Gauss–Newton Method”. In: SIAM J. Optim. 4.3
(Aug. 1994), pp. 626–636.
[Ben13] Y. Bengio. “Estimating or Propagating Gradi￾ents Through Stochastic Neurons”. In: (2013). arXiv:
1305.2982 [cs.LG].
[Bén+21] C. Bénard, G. Biau, S. Veiga, and E. Scornet.
“Interpretable random forests via rule extraction”. In:
International Conference on Artificial Intelligence
and Statistics. PMLR. 2021, pp. 937–945.
[Ben+21a] Y. Bengio, T. Deleu, E. J. Hu, S. Lahlou,
M. Tiwari, and E. Bengio. “GFlowNet Foundations”.
In: (Nov. 2021). arXiv: 2111.09266 [cs.LG].
[Ben+21b] G. W. Benton, W. J. Maddox, S. Lotfi, and
A. G. Wilson. “Loss Surface Simplexes for Mode Con￾necting Volumes and Fast Ensembling”. In: ICML.
2021.
[Ben+22] K. Benidis et al. “Deep Learning for Time Se￾ries Forecasting: Tutorial and Literature Survey”. In:
ACM Computing Surveys (2022).
[Ber05] J. M. Bernardo. “Reference Analysis”. In:
Handbook of Statistics. Ed. by D. K. Dey and C. R.
Rao. Vol. 25. Elsevier, 2005, pp. 17–90.
[Ber15] D. Bertsekas. Convex Optimization Algo￾rithms. Athena Scientific, 2015.
[Ber16] D. Bertsekas. Nonlinear Programming. Third.
Athena Scientific, 2016.
[Ber+18] R. van den Berg, L. Hasenclever, J. M. Tom￾czak, and M. Welling. “Sylvester normalizing flows for
variational inference”. In: AISTATS. 2018.
[Ber+19] H. Berard, G. Gidel, A. Almahairi, P. Vin￾cent, and S. Lacoste-Julien. “A Closer Look at the
Optimization Landscapes of Generative Adversarial
Networks”. In: International Conference on Learning
Representations. 2019.
[Ber19] D. Bertsekas. Reinforcement learning and op￾timal control. Athena Scientific, 2019.
[Ber+21] J. Berner, P. Grohs, G. Kutyniok, and P. Pe￾tersen. “The Modern Mathematics of Deep Learning”.
In: (2021). arXiv: 2105.04026 [cs.LG].
[Ber85a] J. Berger. “Bayesian Salesmanship”. In:
Bayesian Inference and Decision Techniques with
Applications: Essays in Honor of Bruno deFinetti.
Ed. by P. K. Goel and A. Zellner. North-Holland, 1985.
[Ber85b] J. Berger. Statistical Decision Theory and
Bayesian Analysis (2nd edition). Springer-Verlag,
1985.
[Ber97a] D. A. Berry. “Teaching Elementary Bayesian
Statistics with Real Applications in Science”. In: Am.
Stat. 51.3 (1997), pp. 241–246.
[Ber97b] D. Bertsekas. Parallel and Distribution Com￾putation: Numerical Methods. Athena Scientific,
1997.
[Ber99] A. Berchtold. “The double chain Markov
model”. In: Comm. Stat. Theor. Methods 28 (1999),
pp. 2569–2589.
[Bes75] J. Besag. “Statistical analysis of non-lattice
data”. In: The Statistician 24 (1975), pp. 179–196.
[Bet13] M. Betancourt. “A General Metric for Rieman￾nian Manifold Hamiltonian Monte Carlo”. In: Geomet￾ric Science of Information. Springer Berlin Heidel￾berg, 2013, pp. 327–334.
[Bet17] M. Betancourt. “A Conceptual Introduction to
Hamiltonian Monte Carlo”. In: (2017). arXiv: 1701 .
02434 [stat.ME].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Bet18] M. Betancourt. Probability Theory (For Sci￾entists and Engineers). 2018.
[Bey+20] L. Beyer, O. J. Hénaff, A. Kolesnikov, X.
Zhai, and A. van den Oord. “Are we done with Im￾ageNet?” In: (2020). arXiv: 2006.07159 [cs.CV].
[Béz+20] E. de Bézenac, S. S. Rangapuram, K. Beni￾dis, M. Bohlke-Schneider, R. Kurle, L. Stella, H. Has￾son, P. Gallinari, and T. Januschowski. “Normalizing
Kalman Filters for Multivariate Time Series Analysis”.
In: NIPS. Vol. 33. 2020, pp. 2995–3007.
[BFH75] Y. Bishop, S. Fienberg, and P. Holland. Dis￾crete Multivariate Analysis: Theory and Practice.
MIT Press, 1975.
[BFY20] T. D. Barfoot, J. R. Forbes, and D. Yoon.
“Exactly Sparse Gaussian Variational Inference with
Application to Derivative-Free Batch Nonlinear State
Estimation”. In: Intl. J. of Robotics Research (2020).
[BG06] M. Beal and Z. Ghahramani. “Variational
Bayesian Learning of Directed Graphical Models with
Hidden Variables”. In: Bayesian Analysis 1.4 (2006).
[BG13] M. J. Betancourt and M. Girolami. “Hamilto￾nian Monte Carlo for Hierarchical Models”. In: (2013).
arXiv: 1312.0906 [stat.ME].
[BG73] A. Björck and G. H. Golub. “Numerical meth￾ods for computing angles between linear subspaces”.
In: Mathematics of computation 27.123 (1973),
pp. 579–594.
[BG96] A. Becker and D. Geiger. “A sufficiently fast
algorithm for finding close to optimal junction trees”.
In: UAI. 1996.
[BGHM17] J. Boyd-Graber, Y. Hu, and D. Mimno.
“Applications of Topic Models”. In: Foundations
and Trends in Information Retrieval 11.2-3 (2017),
pp. 143–296.
[BGM17] J Ba, R Grosse, and J Martens. “Distributed
Second-Order Optimization using Kronecker-Factored
Approximations”. In: ICLR. openreview.net, 2017.
[BGS16] Y. Burda, R. Grosse, and R. Salakhutdi￾nov. “Importance Weighted Autoencoders”. In: ICLR.
2016.
[BGT93] C. Berrou, A. Glavieux, and P. Thitima￾jashima. “Near Shannon limit error-correcting cod￾ing and decoding: Turbo codes”. In: Proc. IEEE Intl.
Comm. Conf. (1993).
[BH11] M.-F. Balcan and N. J. Harvey. “Learning sub￾modular functions”. In: Proceedings of the forty-third
annual ACM symposium on Theory of computing.
2011, pp. 793–802.
[BH20] M. T. Bahadori and D. Heckerman. “Debias￾ing Concept-based Explanations with Causal Analy￾sis”. In: International Conference on Learning Rep￾resentations. 2020.
[BH92] D. Barry and J. A. Hartigan. “Product parti￾tion models for change point problems”. In: Annals of
statistics 20 (1992), pp. 260–279.
[Bha+19] A. Bhadra, J. Datta, N. G. Polson, and
B. T. Willard. “Lasso Meets Horseshoe: a survey”. In:
Bayesian Anal. 34.3 (2019), pp. 405–427.
[Bha+21] K. Bhatia, N. Kuang, Y. Ma, and Y. Wang.
Statistical and computational tradeoffs in variational
Bayes: a case study of inferential model selection.
Tech. rep. 2021.
[BHB19] P. Bachman, R. D. Hjelm, and W. Buchwal￾ter. Learning Representations by Maximizing Mutual
Information Across Views. 2019. arXiv: 1906 . 00910
[cs.LG].
[BHB22] F. Berns, J. Hüwel, and C. Beecks. “Au￾tomated Model Inference for Gaussian Processes:
An Overview of State-of-the-Art Methods and Al￾gorithms”. en. In: SN Comput Sci 3.4 (May 2022),
p. 300.
[BHC19] M. Binkowski, D. Hjelm, and A. Courville.
“Batch weight for domain adaptation with mass shift”.
In: Proceedings of the IEEE/CVF International Con￾ference on Computer Vision. 2019, pp. 1844–1853.
[BHO75] P. J. Bickel, E. A. Hammel, and J. W.
O’connell. “Sex bias in graduate admissions: data from
berkeley”. en. In: Science 187.4175 (1975), pp. 398–
404.
[BHPI02] M. B¯adoiu, S. Har-Peled, and P. Indyk. “Ap￾proximate clustering via core-sets”. In: Proceedings of
the thiry-fourth annual ACM symposium on Theory
of computing. 2002, pp. 250–257.
[BHW16] P. G. Bissiri, C. Holmes, and S. Walker. “A
General Framework for Updating Belief Distributions”.
In: JRSSB 78.5 (2016), 1103–1130.
[Bic09] D. Bickson. “Gaussian Belief Propagation: The￾ory and Application”. PhD thesis. Hebrew University
of Jerusalem, 2009.
[Bie06] G. J. Bierman. Factorization Methods for Dis￾crete Sequential Estimation (Dover Books on Math￾ematics). en. Illustrated edition. Dover Publications,
2006.
[Big+11] B. Biggio, G. Fumera, I. Pillai, and F. Roli.
“A survey and experimental evaluation of image spam
filtering techniques”. In: Pattern recognition letters
32.10 (2011), pp. 1436–1446.
[Bil01] J. A. Bilmes. Graphical Models and Automatic
Speech Recognition. Tech. rep. UWEETR-2001-0005.
Univ. Washington, Dept. of Elec. Eng., 2001.
[Bil22] J. Bilmes. “Submodularity In Machine Learn￾ing and Artificial Intelligence”. In: (2022). arXiv: 2202.
00132 [cs.LG].
[Biń+18] M. Bińkowski, D. J. Sutherland, M. Arbel,
and A. Gretton. “Demystifying MMD GANs”. In:
ICLR. 2018.
[Bin+18] M. Binkowski, D. J. Sutherland, M. Arbel,
and A. Gretton. “Demystifying MMD GANs”. In: In￾ternational Conference on Learning Representations.
2018.
[Bin+19] E. Bingham, J. P. Chen, M. Jankowiak, F.
Obermeyer, N. Pradhan, T. Karaletsos, R. Singh, P.
Szerlip, P. Horsfall, and N. D. Goodman. “Pyro: Deep
Universal Probabilistic Programming”. In: JMLR
20.28 (2019), pp. 1–6.
[Biń+19] M. Bińkowski, J. Donahue, S. Dieleman, A.
Clark, E. Elsen, N. Casagrande, L. C. Cobo, and K.
Simonyan. “High Fidelity Speech Synthesis with Ad￾versarial Networks”. In: International Conference on
Learning Representations. 2019.
[Bin+97] J. Binder, D. Koller, S. J. Russell, and K.
Kanazawa. “Adaptive Probabilistic Networks with
Hidden Variables”. In: Machine Learning 29 (1997),
pp. 213–244.
[Bis06] C. Bishop. Pattern recognition and machine
learning. Springer, 2006.
[Bis99] C. Bishop. “Bayesian PCA”. In: NIPS. 1999.
[Bit16] S. Bitzer. The UKF exposed: How it works,
when it works and when it’s better to sample. 2016.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1248
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[Bit+21] J. Bitterwolf, A. Meinke, M. Augustin, and M.
Hein. “Revisiting out-of-distribution detection: A sim￾ple baseline is surprisingly effective”. In: ICML Work￾shop on Uncertainty in Deep Learning (UDL). 2021.
[BJ05] F. Bach and M. Jordan. A probabilistic inter￾pretation of canonical correlation analysis. Tech. rep.
688. U. C. Berkeley, 2005.
[BJ06] W. Buntine and A. Jakulin. “Discrete Compo￾nent Analysis”. In: Subspace, Latent Structure and
Feature Selection: Statistical and Optimization Per￾spectives Workshop. 2006.
[BJV97] J. S. D. Bonet, C. L. I. Jr., and P. A. Viola.
“MIMIC: Finding Optima by Estimating Probability
Densities”. In: NIPS. MIT Press, 1997, pp. 424–430.
[BK10] R. Bardenet and B. Kegl. “Surrogating the sur￾rogate: accelerating Gaussian-process-based global op￾timization with a mixture cross-entropy algorithm”. In:
ICML. 2010.
[BK15] D. Belanger and S. Kakade. “A Linear Dynam￾ical System Model for Text”. en. In: ICML. 2015,
pp. 833–842.
[BK19] M. Bonvini and E. H. Kennedy. “Sensitivity
Analysis via the Proportion of Unmeasured Confound￾ing”. In: arXiv e-prints, arXiv:1912.02793 (Dec. 2019),
arXiv:1912.02793. arXiv: 1912.02793 [stat.ME].
[BKB17] O. Bastani, C. Kim, and H. Bastani. “Inter￾preting blackbox models via model extraction”. In:
arXiv preprint arXiv:1705.08504 (2017).
[BKH16] J. L. Ba, J. R. Kiros, and G. E. Hinton.
“Layer Normalization”. In: (2016). arXiv: 1607.06450
[stat.ML].
[BKM16] D. M. Blei, A. Kucukelbir, and J. D.
McAuliffe. “Variational Inference: A Review for Statis￾ticians”. In: JASA (2016).
[BKS19] A. Bennett, N. Kallus, and T. Schnabel.
“Deep Generalized Method of Moments for Instrumen￾tal Variable Analysis”. In: Advances in Neural Infor￾mation Processing Systems. 2019, pp. 3564–3574.
[BL06] D. Blei and J. Lafferty. “Dynamic topic models”.
In: ICML. 2006, pp. 113–120.
[BL07a] C. M. Bishop and J. Lasserre. “Generative or
discriminative? Getting the best of both worlds”. In:
Bayesian Statistics 8. 2007.
[BL07b] D. Blei and J. Lafferty. “A Correlated Topic
Model of "Science"”. In: Annals of Applied Stat. 1.1
(2007), pp. 17–35.
[BLC18] A. J. Bose, H. Ling, and Y. Cao. “Adversar￾ial Contrastive Estimation”. In: Proceedings of the
56th Annual Meeting of the Association for Compu￾tational Linguistics (Volume 1: Long Papers). 2018,
pp. 1021–1032.
[Ble12] D. M. Blei. “Probabilistic topic models”. In:
Commun. ACM 55.4 (2012), pp. 77–84.
[BLH21] Y. Bengio, Y. Lecun, and G. Hinton. “Deep
learning for AI”. In: Comm. of the ACM 64.7 (June
2021), pp. 58–65.
[BLH22] J. Bornschein, Y. Li, and M. Hutter. “Se￾quential Learning Of Neural Networks for Prequential
MDL”. In: (Oct. 2022). arXiv: 2210.07931 [stat.ML].
[BLM16] S. Boucheron, G. Lugosi, and P. Massart.
Concentration Inequalities: A Nonasymptotic The￾ory of Independence. Oxford University Press, 2016.
[Blo+16] A. Bloniarz, H. Liu, C.-H. Zhang, J. S.
Sekhon, and B. Yu. “Lasso adjustments of treatment
effect estimates in randomized experiments”. In: Pro￾ceedings of the National Academy of Sciences 113.27
(2016), pp. 7383–7390.
[BLS11] G. Blanchard, G. Lee, and C. Scott. “General￾izing from several related classification tasks to a new
unlabeled sample”. In: NIPS. 2011.
[BLS17] J. Ballé, V. Laparra, and E. P. Simon￾celli. “End-to-end Optimized Image Compression”. In:
ICLR. 2017.
[Blu+15] C. Blundell, J. Cornebise, K. Kavukcuoglu,
and D. Wierstra. “Weight Uncertainty in Neural Net￾works”. In: ICML. 2015.
[BM+18] G. Barth-Maron, M. W. Hoffman, D. Bud￾den, W. Dabney, D. Horgan, T. B. Dhruva, A. Muldal,
N. Heess, and T. Lillicrap. “Distributed Distributional
Deterministic Policy Gradients”. In: ICLR. 2018.
[BM19] Y. Blau and T. Michaeli. “Rethinking Lossy
Compression: The Rate-Distortion-Perception Trade￾off”. In: ICML. 2019.
[BM93] H. A. Bourlard and N. Morgan. Connection￾ist Speech Recognition: A Hybrid Approach. USA:
Kluwer Academic Publishers, 1993.
[BMK20] Z. Borsos, M. Mutny, and A. Krause. “Core￾sets via Bilevel Optimization for Continual Learning
and Streaming”. In: Advances in Neural Information
Processing Systems 33 (2020).
[BMM00] J. Barnard, R. Mcculloch, and X.-L. Meng.
“Modeling covariance matrices in terms of standard
deviations and correlations, with application to shrink￾age”. In: Stat. Sin. 10 (2000).
[BMP19] A. Brunel, D. Mazza, and M. Pagani. “Back￾propagation in the Simply Typed Lambda-Calculus
with Linear Negation”. In: Proc. ACM Program. Lang.
4.POPL (2019).
[BMR97] J. Binder, K. Murphy, and S. Russell. “Space￾efficient inference in dynamic probabilistic networks”.
In: IJCAI. 1997.
[BMS11] S. Bubeck, R. Munos, and G. Stoltz. “Pure
Exploration in Finitely-armed and Continuous-armed
Bandits”. In: Theoretical Computer Science 412.19
(2011), pp. 1832–1852.
[BNJ03a] D. Blei, A. Ng, and M. Jordan. “Latent
Dirichlet allocation”. In: JMLR 3 (2003), pp. 993–
1022.
[BNJ03b] D. M. Blei, A. Y. Ng, and M. I. Jordan. “La￾tent dirichlet allocation”. In: JMLR 3 (2003), pp. 993–
1022.
[BO14] J. Bayer and C. Osendorfer. “Learning Stochas￾tic Recurrent Networks”. In: Workshop on Advances
in Variational Inference. 2014.
[Boe+05] P.-T. de Boer, D. P. Kroese, S. Mannor, and
R. Y. Rubinstein. “A Tutorial on the Cross-Entropy
Method”. en. In: Ann. Oper. Res. 134.1 (2005), pp. 19–
67.
[Boh92] D. Bohning. “Multinomial logistic regression
algorithm”. In: Annals of the Inst. of Statistical Math.
44 (1992), pp. 197–200.
[Bol02] W. Bolstad. “Teaching Bayesian Statistics to
Undergraduates: Who, What, Where, When, Why and
How”. In: ICOTS6 Intl. Conf. on Teaching Statistics.
2002.
[Bol89] K. Bollen. Structural Equation Models with
Latent Variables. John Wiley & Sons, 1989.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Bon64] G. Bonnet. “Transformations des signaux aleá￾toires a travers les systemes non lineáires sans
me ´moire”. In: Annales des Telecommuncations 19
(1964).
[Bös+17] J.-H. Böse, V. Flunkert, J. Gasthaus, T.
Januschowski, D. Lange, D. Salinas, S. Schelter, M.
Seeger, and Y. Wang. “Probabilistic Demand Fore￾casting at Scale”. In: Proceedings VLDB Endowment
10.12 (2017), pp. 1694–1705.
[Bot+13] L. Bottou, J. Peters, J. Quiñonero-Candela,
D. X. Charles, D. M. Chickering, E. Portugaly, D. Ray,
P. Simard, and E. Snelson. “Counterfactual Reason￾ing and Learning Systems: The Example of Compu￾tational Advertising”. In: JMLR 14 (2013), pp. 3207–
3260.
[Bow+16a] S. R. Bowman, L. Vilnis, O. Vinyals, A. M.
Dai, R. Jozefowicz, and S. Bengio. “Generating Sen￾tences from a Continuous Space”. In: CONLL. 2016.
[Bow+16b] S. R. Bowman, L. Vilnis, O. Vinyals, A. M.
Dai, R. Jozefowicz, and S. Bengio. “Generating Sen￾tences from a Continuous Space”. In: CONLL. 2016.
[Box80] G. E. P. Box. “Sampling and Bayes’ Inference
in Scientific Modelling and Robustness”. In: J. of
Royal Stat. Soc. Series A 143.4 (1980), pp. 383–430.
[BP13] K. A. Bollen and J. Pearl. “Eight Myths About
Causality and Structural Equation Models”. In: Hand￾book of Causal Analysis for Social Research. Ed. by
S. L. Morgan. Springer Netherlands, 2013, pp. 301–
328.
[BP16] E. Bareinboim and J. Pearl. “Causal inference
and the data-fusion problem”. en. In: Proc. Natl. Acad.
Sci. U. S. A. 113.27 (2016), pp. 7345–7352.
[BP21] T. Bricken and C. Pehlevan. “Attention Ap￾proximates Sparse Distributed Memory”. In: NIPS.
2021.
[BPK16] S. Bulo, L. Porzi, and P. Kontschieder. “Dis￾tillation dropout”. In: ICML. 2016.
[BPL21a] R. Balestriero, J. Pesenti, and Y. LeCun.
“Learning in High Dimension Always Amounts to
Extrapolation”. In: (Oct. 2021). arXiv: 2110 . 09485
[cs.LG].
[BPL21b] A. Bardes, J. Ponce, and Y. LeCun.
“Vicreg: Variance-invariance-covariance regularization
for self-supervised learning”. In: arXiv preprint
arXiv:2105.04906 (2021).
[BPS16] A. G. Baydin, B. A. Pearlmutter, and J. M.
Siskind. “DiffSharp: An AD library for .NET lan￾guages”. In: arXiv preprint arXiv:1611.03423 (2016).
[BR05] H. Bang and J. M. Robins. “Doubly Robust Es￾timation in Missing Data and Causal Inference Mod￾els”. In: Biometrics 61.4 (2005), pp. 962–973.
[BR18] B. Biggio and F. Roli. “Wild patterns: Ten
years after the rise of adversarial machine learning”.
In: Pattern Recognition 84 (2018), pp. 317–331.
[BR98] S. Brooks and G. Roberts. “Assessing conver￾gence of Markov Chain Monte Carlo algorithms”. In:
Statistics and Computing 8 (1998), pp. 319–335.
[Bra+18] J. Bradbury, R. Frostig, P. Hawkins,
M. J. Johnson, C. Leary, D. Maclaurin, and S.
Wanderman-Milne. JAX: composable transforma￾tions of Python+NumPy programs. Version 0.1.55.
2018.
[Bra96] M. Brand. Coupled hidden Markov models for
modeling interacting processes. Tech. rep. 405. MIT
Lab for Perceptual Computing, 1996.
[Bre01] L. Breiman. “Statistical modeling: The two cul￾tures (with comments and a rejoinder by the author)”.
In: Statistical science 16.3 (2001), pp. 199–231.
[Bre+17] L. Breiman, J. H. Friedman, R. A. Olshen,
and C. J. Stone. Classification and regression trees.
Routledge, 2017.
[Bre+20a] J. Brehmer, G. Louppe, J. Pavez, and K.
Cranmer. “Mining gold from implicit models to im￾prove likelihood-free inference”. en. In: Proc. Natl.
Acad. Sci. U. S. A. 117.10 (2020), pp. 5242–5249.
[Bre+20b] R. Brekelmans, V. Masrani, F. Wood, G.
Ver Steeg, and A. Galstyan. “All in the Exponential
Family: Bregman Duality in Thermodynamic Varia￾tional Inference”. In: ICML. 2020.
[Bre67] L. M. Bregman. “The relaxation method of
finding the common point of convex sets and its ap￾plication to the solution of problems in convex pro￾gramming”. In: USSR Computational Mathematics
and Mathematical Physics 7.3 (1967), pp. 200–217.
[Bre91] Y. Brenier. “Polar factorization and monotone
rearrangement of vector-valued functions”. In: Com￾munications on pure and applied mathematics 44.4
(1991), pp. 375–417.
[Bre92] J. Breese. “Construction of belief and decision
networks”. In: Computational Intelligence 8 (1992),
624–647.
[Bre96] L. Breiman. “Stacked regressions”. In: Mach.
Learn. 24.1 (1996), pp. 49–64.
[BRG20] R. Bai, V. Rockova, and E. I. George. “Spike￾and-slab meets LASSO: A review of the spike-and-slab
LASSO”. In: (2020). arXiv: 2010.06451 [stat.ME].
[Bri12] W. M. Briggs. “It is Time to Stop Teaching
Frequentism to Non-statisticians”. In: arXiv (2012).
arXiv: 1201.2590 [stat.OT].
[Bri50] G. W. Brier. “Verification of forecasts expressed
in terms of probability”. In: Monthly Weather Review
78.1 (1950), pp. 1–3.
[Bro09] G. Brown. “A new perspective on information
theoretic feature selection”. In: AISTATS. 2009.
[Bro+13] T. Broderick, N. Boyd, A. Wibisono, A. C.
Wilson, and M. I. Jordan. “Streaming Variational
Bayes”. In: NIPS. 2013.
[Bro+15] K. H. Brodersen, F. Gallusser, J. Koehler, N.
Remy, and S. L. Scott. “Inferring causal impact us￾ing Bayesian structural time-series models”. In: Ann.
Appl. Stat. 9.1 (2015), pp. 247–274.
[Bro18] T. Broderick. Tutorial: Variational Bayes and
Beyond. 2018.
[Bro19] J. Brownlee. Generative Adversarial Networks
with Python. Accessed: 2019-8-27. Machine Learning
Mastery, 2019.
[Bro+20a] D. Brookes, A. Busia, C. Fannjiang, K. Mur￾phy, and J. Listgarten. “A view of estimation of dis￾tribution algorithms through the lens of expectation￾maximization”. In: GECCO. GECCO ’20. Association
for Computing Machinery, 2020, pp. 189–190.
[Bro+20b] P. Brouillard, S. Lachapelle, A. Lacoste, S.
Lacoste-Julien, and A. Drouin. “Differentiable Causal
Discovery from Interventional Data”. In: NIPS. July
2020.
[Bro+20c] D. Brown, R. Coleman, R. Srinivasan, and
S. Niekum. “Safe imitation learning via fast bayesian
reward inference from preferences”. In: International
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1250
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Conference on Machine Learning. PMLR. 2020,
pp. 1165–1177.
[Bro+20d] T. B. Brown et al. “Language Models are
Few-Shot Learners”. In: (2020). arXiv: 2005 . 14165
[cs.CL].
[BRS17] E. Balkanski, A. Rubinstein, and Y. Singer.
“The Limitations of Optimization from Samples”. In:
Proceedings of the 49th Annual ACM SIGACT Sym￾posium on Theory of Computing. STOC 2017. Mon￾treal, Canada: Association for Computing Machinery,
2017, 1016–1027.
[BRSS18] N. Bou-Rabee and J. M. Sanz-Serna. “Geo￾metric integrators and the Hamiltonian Monte Carlo
method”. In: Acta Numer. (2018).
[Bru+18] M. Brundage et al. “The Malicious Use of Ar￾tificial Intelligence: Forecasting, Prevention, and Mit￾igation”. In: (2018). arXiv: 1802.07228 [cs.AI].
[BS17] E. Balkanski and Y. Singer. “Minimizing a Sub￾modular Function from Samples.” In: NIPS. 2017,
pp. 814–822.
[BS18] S. Barratt and R. Sharma. “A note on the in￾ception score”. In: arXiv preprint arXiv:1801.01973
(2018).
[BS20] E. Balkanski and Y. Singer. “A lower bound for
parallel submodular minimization”. In: Proceedings of
the 52nd Annual ACM SIGACT Symposium on The￾ory of Computing. 2020, pp. 130–139.
[BS+20] S. Bobadilla-Suarez, C. Ahlheim, A. Mehro￾tra, A. Panos, and B. C. Love. “Measures of neural
similarity”. In: Computational Brain & Behavior 3.4
(2020), pp. 369–383.
[BS94] J. Bernardo and A. Smith. Bayesian Theory.
John Wiley, 1994.
[BS95a] A. J. Bell and T. J. Sejnowski. “An infor￾mation maximisation approach to blind separation
and blind deconvolution”. In: Neural Computation 7.6
(1995), pp. 1129–1159.
[BS95b] A. J. Bell and T. J. Sejnowski. “An
information-maximization approach to blind separa￾tion and blind deconvolution”. In: Neural computation
7.6 (1995), pp. 1129–1159.
[BSA83] A. G. Barto, R. S. Sutton, and C. W. Ander￾son. “Neuronlike adaptive elements that can solve dif￾ficult learning control problems”. In: SMC 13.5 (1983),
pp. 834–846.
[BSF88] Y. Bar-Shalom and T. Fortmann. Tracking
and data association. Academic Press, 1988.
[BSL93] Y. Bar-Shalom and X. Li. Estimation and
Tracking: Principles, Techniques and Software.
Artech House, 1993.
[BSWT11] Y. Bar-Shalom, P. K. Willett, and X. Tian.
Tracking and Data Fusion: A Handbook of Algo￾rithms. en. Yaakov Bar-Shalom, 2011.
[BT00] C. Bishop and M. Tipping. “Variational rele￾vance vector machines”. In: UAI. 2000.
[BT04] G. Bouchard and B. Triggs. “The tradeoff be￾tween generative and discriminative classifiers”. In:
IASC International Symposium on Computational
Statistics (COMPSTAT ’04). 2004.
[BT08] D. Bertsekas and J. Tsitsiklis. Introduction to
Probability. 2nd Edition. Athena Scientific, 2008.
[BT12] M. Botvinick and M. Toussaint. “Planning as
inference”. en. In: Trends Cogn. Sci. 16.10 (2012),
pp. 485–488.
[BT73] G. Box and G. Tiao. Bayesian inference in sta￾tistical analysis. Addison-Wesley, 1973.
[BTEGN09] A. Ben-Tal, L. El Ghaoui, and A. Ne￾mirovski. Robust optimization. Vol. 28. Princeton Uni￾versity Press, 2009.
[Buc+12] N. Buchbinder, M. Feldman, J. Naor, and R.
Schwartz. “A tight (1/2) linear-time approximation
to unconstrained submodular maximization”. In: In
FOCS (2012).
[Buc+17] C. L. Buckley, C. S. Kim, S. McGregor, and
A. K. Seth. “The free energy principle for action and
perception: A mathematical review”. In: J. Math. Psy￾chol. 81 (2017), pp. 55–79.
[Buc21] J. Buchner. “Nested Sampling Methods”. In:
(Jan. 2021). arXiv: 2101.09675 [stat.CO].
[Bud+21] K. Budhathoki, D. Janzing, P. Bloebaum,
and H. Ng. “Why did the distribution change?” In:
AISTATS. Ed. by A. Banerjee and K. Fukumizu.
Vol. 130. Proceedings of Machine Learning Research.
PMLR, 2021, pp. 1666–1674.
[Bul11] A. D. Bull. “Convergence rates of efficient
global optimization algorithms”. In: JMLR 12 (2011),
2879–2904.
[Bul+20] S. Bulusu, B. Kailkhura, B. Li, P. K. Varsh￾ney, and D. Song. “Anomalous Example Detection in
Deep Learning: A Survey”. In: IEEE Access 8 (2020),
pp. 132330–132347.
[BV04] S. Boyd and L. Vandenberghe. Convex opti￾mization. Cambridge, 2004.
[BVHP18] S. Beery, G. Van Horn, and P. Perona.
“Recognition in terra incognita”. In: Proceedings of the
European Conference on Computer Vision (ECCV).
2018, pp. 456–473.
[BVW02] H. Bui, S. Venkatesh, and G. West. “Policy
Recognition in the Abstract Hidden Markov Model”.
In: JAIR 17 (2002), pp. 451–499.
[BW20] G. J. J. van den Burg and C. K. I. Williams.
“An Evaluation of Change Point Detection Algo￾rithms”. In: (2020). arXiv: 2003.06222 [stat.ML].
[BW21] G. J. van den Burg and C. K. Williams. “On
Memorization in Probabilistic Deep Generative Mod￾els”. In: NIPS. 2021.
[BWM18] A. Buchholz, F. Wenzel, and S. Mandt.
“Quasi-Monte Carlo Variational Inference”. In: ICML.
2018.
[BWR16] M. Bauer, M. van der Wilk, and C. E. Ras￾mussen. “Understanding Probabilistic Sparse Gaus￾sian Process Approximations”. In: NIPS. 2016,
pp. 1533–1541.
[BYH20] O. Bohdal, Y. Yang, and T. Hospedales.
“Flexible Dataset Distillation: Learn Labels Instead of
Images”. In: arXiv preprint arXiv:2006.08572 (2020).
[BYM17] D. Belanger, B. Yang, and A. McCallum.
“End-to-End Learning for Structured Prediction En￾ergy Networks”. In: ICML. Ed. by D. Precup and
Y. W. Teh. Vol. 70. Proceedings of Machine Learning
Research. PMLR, 2017, pp. 429–439.
[Byr+16] R Byrd, S Hansen, J Nocedal, and Y Singer.
“A Stochastic Quasi-Newton Method for Large-Scale
Optimization”. In: SIAM J. Optim. 26.2 (2016),
pp. 1008–1031.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[BZ20] A. Barbu and S.-C. Zhu. Monte Carlo Methods.
en. Springer, 2020.
[CA13] E. F. Camacho and C. B. Alba. Model predic￾tive control. Springer, 2013.
[Cac+18] M. Caccia, L. Caccia, W. Fedus, H.
Larochelle, J. Pineau, and L. Charlin. “Language
GANs Falling Short”. In: CoRR abs/1811.02549
(2018). arXiv: 1811.02549.
[CAII20] V. Coscrato, M. H. de Almeida Inácio, and
R. Izbicki. “The NN-Stacking: Feature weighted linear
stacking through neural networks”. In: Neurocomput￾ing (2020).
[Cal+07] G. Calinescu, C. Chekuri, M. Pál, and J. Von￾drák. “Maximizing a submodular set function sub￾ject to a matroid constraint”. In: Proceedings of the
12th International Conference on Integer Program￾ming and Combinatorial Optimization (IPCO). 2007,
pp. 182–196.
[Cal20] O. Calin. Deep Learning Architectures: A
Mathematical Approach. en. 1st ed. Springer, 2020.
[Cam+21] A. Campbell, Y. Shi, T. Rainforth, and A.
Doucet. “Online Variational Filtering and Parameter
Learning”. In: NIPS. 2021.
[Can04] J. Canny. “GaP: a factor model for discrete
data”. In: SIGIR. 2004, pp. 122–129.
[Cao+15] Y. Cao, M. A Brubaker, D. J Fleet, and A.
Hertzmann. “Efficient Optimization for Sparse Gaus￾sian Process Regression”. en. In: IEEE PAMI 37.12
(2015), pp. 2415–2427.
[Cao+22] H. Cao, C. Tan, Z. Gao, G. Chen, P.-A.
Heng, and S. Z. Li. “A Survey on Generative Diffusion
Model”. In: (Sept. 2022). arXiv: 2209.02646 [cs.AI].
[Cap+22] T. Capretto, C. Piho, R. Kumar, J. Westfall,
T. Yarkoni, and O. A. Martin. “Bambi: A Simple Inter￾face for Fitting Bayesian Linear Models in Python”. In:
Journal of Statistical Software 103.15 (2022), 1–29.
[Car03] P. Carbonetto. “Unsupervised Statistical Mod￾els for General Object Recognition”. MA thesis. Uni￾versity of British Columbia, 2003.
[Car+15] R. Caruana, Y. Lou, J. Gehrke, P. Koch,
M. Sturm, and N. Elhadad. “Intelligible models for
healthcare: Predicting pneumonia risk and hospital 30-
day readmission”. In: Proceedings of the 21th ACM
SIGKDD international conference on knowledge dis￾covery and data mining. 2015, pp. 1721–1730.
[Car+19] N. Carlini, A. Athalye, N. Papernot, W.
Brendel, J. Rauber, D. Tsipras, I. Goodfellow, A.
Madry, and A. Kurakin. “On evaluating adversar￾ial robustness”. In: arXiv preprint arXiv:1902.06705
(2019).
[Car+21] M. Caron, H. Touvron, I. Misra, H. Jégou, J.
Mairal, P. Bojanowski, and A. Joulin. Emerging Prop￾erties in Self-Supervised Vision Transformers. 2021.
arXiv: 2104.14294 [cs.CV].
[Car97] R. Caruana. “Multitask Learning”. In: Ma￾chine Learning 28.1 (1997), pp. 41–75.
[Cat08] A. Caticha. Lectures on Probability, Entropy,
and Statistical Physics. 2008. arXiv: 0808 . 0012
[physics.data-an].
[Cat+11] A. Caticha, A. Mohammad-Djafari, J.-F.
Bercher, and P. Bessiére. “Entropic Inference”. In:
AIP Conference Proceedings 1305.1 (2011), pp. 20–
29. eprint: https : / / aip . scitation . org / doi / pdf / 10 .
1063/1.3573619.
[CB20] Y. Chen and P. Bühlmann. “Domain adap￾tation under structural causal models”. In: JMLR
(2020).
[CBL20] K. Cranmer, J. Brehmer, and G. Louppe.
“The frontier of simulation-based inference”. In: Pro￾ceedings of the National Academy of Sciences 117.48
(2020), pp. 30055–30062.
[CBR20] Z. Chen, Y. Bei, and C. Rudin. “Concept
whitening for interpretable image recognition”. In: Na￾ture Machine Intelligence 2.12 (2020), pp. 772–782.
[CC84] M. Conforti and G. Cornuejols. “Submodular
set functions, matroids and the greedy algorithm: tight
worst-case bounds and some generalizations of the
Rado-Edmonds theorem”. In: Discrete Applied Math￾ematics 7.3 (1984), pp. 251–274.
[CC96] M. Cowles and B. Carlin. “Markov Chain
Monte Carlo Convergence Diagnostics: A Comparative
Review”. In: JASA 91 (1996), pp. 883–904.
[CCS22] A. Corenflos, N. Chopin, and S. Särkkä. “De￾Sequentialized Monte Carlo: a parallel-in-time particle
smoother”. In: (2022). arXiv: 2202.02264 [stat.CO].
[CDC15] C. Chen, N. Ding, and L. Carin. “On the Con￾vergence of Stochastic Gradient MCMC Algorithms
with High-Order Integrators”. In: NIPS. 2015.
[CDS02] M. Collins, S. Dasgupta, and R. E. Schapire.
“A Generalization of Principal Components Analysis
to the Exponential Family”. In: NIPS-14. 2002.
[CDS19] A. Clark, J. Donahue, and K. Simonyan. “Ad￾versarial video generation on complex datasets”. In:
arXiv preprint arXiv:1907.06571 (2019).
[Cér+12] F Cérou, P Del Moral, T Furon, and A
Guyader. “Sequential Monte Carlo for rare event esti￾mation”. In: Stat. Comput. 22.3 (2012), pp. 795–808.
[CFG14] T. Chen, E. B. Fox, and C. Guestrin.
“Stochastic Gradient Hamiltonian Monte Carlo”. In:
ICML. 2014.
[CG00] S. S. Chen and R. A. Gopinath. “Gaussianiza￾tion”. In: NIPS. 2000, pp. 423–429.
[CG15] X. Chen and A. Gupta. “Webly supervised
learning of convolutional networks”. In: Proceedings
of the IEEE International Conference on Computer
Vision. 2015, pp. 1431–1439.
[CG18] C. Ceylan and M. U. Gutmann. “Conditional
Noise-Contrastive Estimation of Unnormalised Mod￾els”. In: International Conference on Machine Learn￾ing. 2018, pp. 726–734.
[CG96] S. Chen and J. Goodman. “An empirical study
of smoothing techniques for language modeling”. In:
Proc. 34th ACL. 1996, pp. 310–318.
[CG98] S. Chen and J. Goodman. An empirical study
of smoothing techniques for language modeling. Tech.
rep. TR-10-98. Dept. Comp. Sci., Harvard, 1998.
[CGR06] S. R. Cook, A. Gelman, and D. B. Rubin.
“Validation of Software for Bayesian Models Using Pos￾terior Quantiles”. In: J. Comput. Graph. Stat. 15.3
(2006), pp. 675–692.
[CGS15] T. Chen, I. Goodfellow, and J. Shlens.
“Net2net: Accelerating learning via knowledge trans￾fer”. In: International Conference on Learning Rep￾resentations. 2015.
[CH20] C. Cinelli and C. Hazlett. “Making sense of sen￾sitivity: extending omitted variable bias”. In: Journal
of the Royal Statistical Society: Series B (Statistical
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1252
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Methodology) 82.1 (2020), pp. 39–67. eprint: https :
//rss.onlinelibrary.wiley.com/doi/pdf/10.1111/rssb.
12348.
[Cha12] K. M. A. Chai. “Variational Multinomial Logit
Gaussian Process”. In: JMLR 13.Jun (2012), pp. 1745–
1808.
[Cha14] N. Chapados. “Effective Bayesian Modeling of
Groups of Related Count Time Series”. In: ICML.
2014.
[Cha+14] K. Chatfield, K. Simonyan, A. Vedaldi, and
A. Zisserman. “Return of the devil in the details: Delv￾ing deep into convolutional nets”. In: British Machine
Vision Conference. 2014.
[Cha+17] D. Chakrabarty, Y. T. Lee, A. Sidford, and
S. C.-w. Wong. “Subquadratic submodular function
minimization”. In: Proceedings of the 49th Annual
ACM SIGACT Symposium on Theory of Computing.
2017, pp. 1220–1231.
[Cha+18] N. S. Chatterji, N. Flammarion, Y.-A. Ma,
P. L. Bartlett, and M. I. Jordan. “On the theory of vari￾ance reduction for stochastic gradient Monte Carlo”.
In: ICML. 2018.
[Cha+19a] C. Chan, S. Ginosar, T. Zhou, and A. A.
Efros. “Everybody dance now”. In: Proceedings of the
IEEE/CVF International Conference on Computer
Vision. 2019, pp. 5933–5942.
[Cha+19b] J. J. Chandler, I. Martinez, M. M. Fin￾ucane, J. G. Terziev, and A. M. Resch. “Speak￾ing on Data’s Behalf: What Researchers Say and
How Audiences Choose”. en. In: Eval. Rev. (2019),
p. 193841X19834968.
[Cha+19c] T. Chavdarova, G. Gidel, F. Fleuret, and S.
Lacoste-Julien. “Reducing noise in GAN training with
variance reduced extragradient”. In: Advances in Neu￾ral Information Processing Systems. 2019, pp. 393–
403.
[Cha21] S. H. Chan. Introduction to Probability for
Data Science. Michigan Publishing, 2021.
[Cha+22] H. Chang, H. Zhang, L. Jiang, C. Liu, and
W. T. Freeman. “MaskGIT: Masked Generative Image
Transformer”. In: CVPR. Feb. 2022.
[Che+05] G. Chechik, A. Globerson, N. Tishby, and
Y. Weiss. “Information Bottleneck for Gaussian Vari￾ables”. In: JMLR 6.Jan (2005), pp. 165–188.
[Che+15] L.-C. Chen, G. Papandreou, I. Kokkinos, K.
Murphy, and A. L. Yuille. “Semantic Image Segmen￾tation with Deep Convolutional Nets and Fully Con￾nected CRFs”. In: ICLR. 2015.
[Che+16] X. Chen, Y. Duan, R. Houthooft, J. Schul￾man, I. Sutskever, and P. Abbeel. “InfoGAN: In￾terpretable Representation Learning by Information
Maximizing Generative Adversarial Nets”. In: NIPS.
2016.
[Che+17] T. Che, Y. Li, R. Zhang, R. D. Hjelm, W.
Li, Y. Song, and Y. Bengio. “Maximum-likelihood aug￾mented discrete generative adversarial networks”. In:
arXiv preprint arXiv:1702.07983 (2017).
[Che17] C. Chelba. Language Modeling in the Era of
Abundant Data. AI with the best. 2017.
[Che+17a] L.-C. Chen, G. Papandreou, I. Kokkinos, K.
Murphy, and A. L. Yuille. “DeepLab: Semantic Image
Segmentation with Deep Convolutional Nets, Atrous
Convolution, and Fully Connected CRFs”. In: IEEE
PAMI (2017).
[Che+17b] X. Chen, D. P. Kingma, T. Salimans, Y.
Duan, P. Dhariwal, J. Schulman, I. Sutskever, and P.
Abbeel. “Variational Lossy Autoencoder”. In: ICLR.
2017.
[Che+17c] X. Chen, N. Mishra, M. Rohaninejad, and
P. Abbeel. “PixelSNAIL: An Improved Autoregres￾sive Generative Model”. In: (2017). arXiv: 1712.09763
[cs.LG].
[Che+17d] V. Chernozhukov, D. Chetverikov, M.
Demirer, E. Duflo, C. Hansen, and W. Newey. “Dou￾ble/Debiased/Neyman Machine Learning of Treat￾ment Effects”. In: American Economic Review 107.5
(2017), pp. 261–65.
[Che+17e] V. Chernozhukov, D. Chetverikov, M.
Demirer, E. Duflo, C. Hansen, W. Newey, and
J. Robins. “Double/Debiased Machine Learning for
Treatment and Structural parameters”. In: The
Econometrics Journal (2017).
[Che+18a] C. Chen, W. Wang, Y. Zhang, Q. Su, and
L. Carin. “A convergence analysis for a class of practi￾cal variance-reduction stochastic gradient MCMC”. In:
Sci. China Inf. Sci. 62.1 (2018), p. 12101.
[Che+18b] C. Chen, O. Li, C. Tao, A. J. Barnett, J. Su,
and C. Rudin. “This looks like that: deep learning for
interpretable image recognition”. In: arXiv preprint
arXiv:1806.10574 (2018).
[Che+18c] R. T. Q. Chen, Y. Rubanova, J. Betten￾court, and D. Duvenaud. “Neural Ordinary Differen￾tial Equations”. In: NIPS. 2018.
[Che+18d] X. Cheng, N. S. Chatterji, P. L. Bartlett,
and M. I. Jordan. “Underdamped Langevin MCMC:
A non-asymptotic analysis”. In: COLT. 2018.
[Che+19] R. T. Q. Chen, J. Behrmann, D. Duvenaud,
and J.-H. Jacobsen. “Residual Flows for Invertible
Generative Modeling”. In: NIPS. 2019.
[Che+20a] M. Chen, A. Radford, R. Child, J. Wu, H.
Jun, D. Luan, and I. Sutskever. “Generative pretrain￾ing from pixels”. In: International Conference on Ma￾chine Learning. PMLR. 2020, pp. 1691–1703.
[Che+20b] M. Chen, Y. Wang, T. Liu, Z. Yang, X. Li,
Z. Wang, and T. Zhao. “On computation and gener￾alization of generative adversarial imitation learning”.
In: arXiv preprint arXiv:2001.02792 (2020).
[Che+20c] T. Chen, S. Kornblith, M. Norouzi, and G.
Hinton. “A simple framework for contrastive learning
of visual representations”. In: ICML. 2020.
[Che+22] D. Chen, D. Wang, T. Darrell, and S.
Ebrahimi. “Contrastive Test-Time Adaptation”. In:
CVPR. Apr. 2022.
[Che95] Y. Cheng. “Mean shift, mode seeking, and clus￾tering”. In: IEEE PAMI 17.8 (1995).
[Chi14] S. Chiappa. “Explicit-Duration Markov Switch￾ing Models”. In: Foundations and Trends in Machine
Learning 7.6 (2014), pp. 803–886.
[Chi21a] R. Child. “Very Deep VAEs Generalize Au￾toregressive Models and Can Outperform Them on
Images”. In: ICLR. 2021.
[Chi21b] R. Child. “Very Deep VAEs Generalize Au￾toregressive Models and Can Outperform Them on
Images”. In: ArXiv abs/2011.10650 (2021).
[CHL+05] S. Chopra, R. Hadsell, Y. LeCun, et al.
“Learning a similarity metric discriminatively, with
application to face verification”. In: CVPR. 2005,
pp. 539–546.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[CHM97] D. M. Chickering, D. Heckerman, and C.
Meek. “A Bayesian Approach to Learning Bayesian
Networks with Local Structure”. In: UAI. UAI’97.
1997, pp. 80–89.
[Cho02] N. Chopin. “A Sequential Particle Filter
Method for Static Models”. In: Biometrika 89.3
(2002), pp. 539–551.
[Cho11] M. J. Choi. “Trees and Beyond: Exploiting and
Improving Tree-Structured Graphical Models”. PhD
thesis. MIT, 2011.
[Cho+15] Y. Chow, A. Tamar, S. Mannor, and M.
Pavone. “Risk-Sensitive and Robust Decision-Making:
A CVaR Optimization Approach”. In: NIPS. 2015,
pp. 1522–1530.
[Cho21] F. Chollet. Deep learning with Python (sec￾ond edition). Manning, 2021.
[Cho+22] J. Choi, J. Lee, C. Shin, S. Kim, H. Kim, and
S. Yoon. “Perception Prioritized Training of Diffusion
Models”. In: CVPR. Apr. 2022.
[Cho57] N. Chomsky. Syntactic Structures. Mouton,
1957.
[Chr+21] R. Christiansen, N. Pfister, M. E. Jakobsen,
N. Gnecco, and J. Peters. “A causal framework for dis￾tribution generalization”. In: IEEE PAMI (2021).
[Chu+15] J. Chung, K. Kastner, L. Dinh, K. Goel, A.
Courville, and Y. Bengio. “A Recurrent Latent Vari￾able Model for Sequential Data”. In: NIPS. 2015.
[Chu+18] K. Chua, R. Calandra, R. McAllister, and
S. Levine. “Deep Reinforcement Learning in a Hand￾ful of Trials using Probabilistic Dynamics Models”. In:
NIPS. 2018.
[Chu+19] G. Chuang, G. DeSalvo, L. Karydas, J.-F.
Kagy, A. Rostamizadeh, and A Theeraphol. “Active
Learning Empirical Study”. In: NeurIPS LIRE Work￾shop. 2019.
[Chw+15] K. Chwialkowski, A. Ramdas, D. Sejdinovic,
and A. Gretton. “Fast Two-Sample Testing with An￾alytic Representations of Probability Measures”. In:
NIPS. 2015.
[CI13] M. Clydec and E. S. Iversen. “Bayesian model
averaging in the M-open framework”. In: Bayesian
Theory and Applications. Ed. by P. Damien. Jan.
2013.
[CI81] W. J. Conover and R. L. Iman. “Rank Transfor￾mations as a Bridge Between Parametric and Nonpara￾metric Statistics”. In: Am. Stat. 35.3 (1981), pp. 124–
129.
[CJ21] A. D. Cobb and B. Jalaian. “Scaling Hamilto￾nian Monte Carlo inference for Bayesian neural net￾works with symmetric splitting”. In: UAI. Vol. 161.
Proceedings of Machine Learning Research. PMLR,
2021, pp. 675–685.
[CK05] M. Collins and T. Koo. “Discriminative Rerank￾ing for Natural Language Parsing”. In: Proc. ACL.
2005.
[CK07] J. J. F. Commandeur and S. J. Koopman. An
Introduction to State Space Time Series Analysis
(Practical Econometrics). en. 1st ed. Oxford Univer￾sity Press, 2007.
[CK21] D. Chakrabarty and S. Khanna. “Better and
simpler error analysis of the Sinkhorn–Knopp algo￾rithm for matrix scaling”. In: Mathematical Program￾ming 188.1 (2021), pp. 395–407.
[CK94a] D. Card and A. B. Krueger. “Minimum Wages
and Employment: A Case Study of the Fast-Food In￾dustry in New Jersey and Pennsylvania”. In: American
Economic Review 84.4 (1994), pp. 772–793.
[CK94b] C. Carter and R. Kohn. “On Gibbs sampling
for state space models”. In: Biometrika 81.3 (1994),
pp. 541–553.
[CK96] C. Carter and R. Kohn. “Markov Chain Monte
Carlo in Conditionally Gaussian State Space Models”.
In: Biometrika 83 (1996), pp. 589–601.
[CKK17] L. Chen, A. Krause, and A. Karbasi. “Inter￾active Submodular Bandit.” In: NIPS. 2017, pp. 141–
152.
[CL00] R. Chen and S. Liu. “Mixture Kalman Filters”.
In: J. Royal Stat. Soc. B (2000).
[CL07] L. Carvahlo and C. Lawrence. “Centroid esti￾mation in discrete high-dimensional spaces with appli￾cations in biology”. In: PNAS 105.4 (2007).
[CL11] O. Chapelle and L. Li. “An empirical evaluation
of Thompson sampling”. In: NIPS. 2011.
[CL18] Z. Chen and B. Liu. Lifelong Machine Learn￾ing. Synthesis Lectures on Artificial Intelligence and
Machine Learning. Morgan Claypool, 2018.
[CL96] B. P. Carlin and T. A. Louis. Bayes and Em￾pirical Bayes Methods for Data Analysis. Chapman
and Hall, 1996.
[Cla20] P. Clavier. “Sum-Product Network in the con￾text of missing data”. en. MA thesis. KTH, 2020.
[Cla21] A. Clayton. Bernoulli’s Fallacy: Statistical Il￾logic and the Crisis of Modern Science. en. Columbia
University Press, 2021.
[CLD18] C. Cremer, X. Li, and D. Duvenaud. “Infer￾ence Suboptimality in Variational Autoencoders”. In:
ICML. 2018.
[Clo+19] J. R. Clough, I. Oksuz, E. Puyol-Antón, B.
Ruijsink, A. P. King, and J. A. Schnabel. “Global
and local interpretability for cardiac MRI classifica￾tion”. In: International Conference on Medical Im￾age Computing and Computer-Assisted Intervention.
Springer. 2019, pp. 656–664.
[Clo20] Cloudera. Causality for ML. 2020.
[CLV19] M. Cox, T. van de Laar, and B. de Vries.
“A factor graph approach to automated design of
Bayesian signal processing algorithms”. In: Int. J. Ap￾prox. Reason. 104 (2019), pp. 185–204.
[CLW18] Y. Chen, L. Li, and M. Wang. “Scalable Bilin￾ear π-Learning Using State and Action Features”. In:
ICML. 2018, pp. 833–842.
[CM09] O. Cappé and E. Moulines. “Online EM Algo￾rithm for Latent Data Models”. In: J. of Royal Stat.
Soc. Series B 71.3 (2009), pp. 593–613.
[CMD17] C. Cremer, Q. Morris, and D. Duvenaud.
“Reinterpreting Importance-Weighted Autoencoders”.
In: ICLR Workshop. 2017.
[CMJ22] P. G. Chang, K. P. Murphy, and M. Jones.
“On diagonal approximations to the extended Kalman
filter for online training of Bayesian neural networks”.
In: Continual Lifelong Learning Workshop at ACML
2022. Dec. 2022.
[CMR05] O. Cappe, E. Moulines, and T. Ryden. Infer￾ence in Hidden Markov Models. Springer, 2005.
[CMR12] C. Cortes, M. Mohri, and A. Rostamizadeh.
“Algorithms for learning kernels based on centered
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1254
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
alignment”. In: The Journal of Machine Learning Re￾search 13.1 (2012), pp. 795–828.
[CMS12] D. Ciregan, U. Meier, and J. Schmidhuber.
“Multi-column deep neural networks for image classi￾fication”. In: 2012 IEEE conference on computer vi￾sion and pattern recognition. IEEE. 2012, pp. 3642–
3649.
[CN01] H. Choset and K. Nagatani. “Topological si￾multaneous localization and mapping (SLAM): toward
exact localization without explicit localization”. In:
IEEE Trans. Robotics and Automation 17.2 (2001).
[CNW20] M. Collier, A. Nazabal, and C. K. I. Williams.
“VAEs in the Presence of Missing Data”. In: ICML
Workshop on the Art of Learning with Missing Val￾ues. 2020.
[CO06] N. Chater and M. Oaksford. “Mental mecha￾nisms”. In: Information sampling and adaptive cog￾nition (2006), pp. 210–236.
[COB18] L. Chizat, E. Oyallon, and F. Bach. “On Lazy
Training in Differentiable Programming”. In: (2018).
arXiv: 1812.07956 [math.OC].
[Coh94] J. Cohen. “The earth is round (p < .05)”. In:
American Psychologist 49.12 (1994), pp. 997–1003.
[Col21] E. Collins. LaMDA: our breakthrough conver￾sation technology. https://blog.google/technology/
ai/lamda/. Accessed: NA-NA-NA. May 2021.
[Coo05] J. Cook. Exact Calculation of Beta Inequali￾ties. Tech. rep. M. D. Anderson Cancer Center, Dept.
Biostatistics, 2005.
[Cor+12] G. Cormode, M. Garofalakis, P. J. Haas, and
C. Jermaine. “Synopses for massive data: Samples,
histograms, wavelets, sketches”. In: Foundations and
Trends in Databases 4.1–3 (2012), pp. 1–294.
[Cor17] G. Cormode. “Data sketching”. In: Communi￾cations of the ACM 60.9 (2017), pp. 48–55.
[Cor+59] J. Cornfield, W. Haenszel, E. C. Hammond,
A. M. Lilienfeld, M. B. Shimkin, and E. L. Wynder.
“Smoking and Lung Cancer: Recent Evidence and a
Discussion of Some Questions”. In: JNCI: Journal
of the National Cancer Institute 22.1 (Jan. 1959),
pp. 173–203. eprint: https://academic.oup.com/jnci/
article-pdf/22/1/173/2704718/22-1-173.pdf.
[Cor+87] A Corana, M Marchesi, C Martini, and S
Ridella. “Minimizing Multimodal Functions of Con￾tinuous Variables with the “Simulated Annealing” Al￾gorithm”. In: ACM Trans. Math. Softw. 13.3 (1987),
pp. 262–280.
[Cou16] Council of European Union. General Data
Protection Regulation. 2016.
[Cou+20] J. Courts, A. Wills, T. Schön, and B. Nin￾ness. “Variational System Identification for Nonlinear
State-Space Models”. In: (2020). arXiv: 2012 . 05072
[stat.ML].
[Cou+21] J. Courts, J. Hendriks, A. Wills, T. Schön,
and B. Ninness. “Variational State and Parameter Es￾timation”. In: 19th IFAC Symposium on System Iden￾tification SYSID 2021. 2021.
[Cov99] T. M. Cover. Elements of information theory.
John Wiley & Sons, 1999.
[Cox06] D. R. Cox. Principles of Statistical Inference.
en. Illustrated edition. Cambridge University Press,
Aug. 2006.
[Cox46] R. T. Cox. “Probability, Frequency and Rea￾sonable Expectation”. In: Am. J. Phys. 14.1 (Jan.
1946), pp. 1–13.
[Cox61] R. Cox. Algebra of Probable Inference. en.
Johns Hopkins University Press, 1961.
[CP20a] R. Chen and I. C. Paschalidis. Distribution￾ally Robust Learning. NOW Foundations and Trends
in Optimization, 2020.
[CP20b] N. Chopin and O. Papaspiliopoulos. An In￾troduction to Sequential Monte Carlo. en. 1st ed.
Springer, 2020.
[CPD17] P. Constantinou and A Philip Dawid. “Ex￾tended conditional independence and applications in
causal inference”. en. In: Ann. Stat. 45.6 (2017),
pp. 2618–2653.
[CPS10] C. Carvahlo, N. Polson, and J. Scott. “The
horseshoe estimator for sparse signals”. In: Biometrika
97.2 (2010), p. 465.
[Cri+02] N. Cristianini, J. Shawe-Taylor, A. Elisseeff,
and J. S. Kandola. “On Kernel-Target Alignment”. In:
Advances in Neural Information Processing Systems.
2002, pp. 367–373.
[CRK19] J. M. Cohen, E. Rosenfeld, and J. Z.
Kolter. “Certified adversarial robustness via random￾ized smoothing”. In: arXiv preprint arXiv:1902.02918
(2019).
[Cro+11] D. F. Crouse, P. Willett, K. Pattipati, and
L. Svensson. “A look at Gaussian mixture reduction
algorithms”. In: 14th International Conference on In￾formation Fusion. 2011, pp. 1–8.
[CS04] I. Csiszár and P. C. Shields. “Information the￾ory and statistics: A tutorial”. In: (2004).
[CS09] Y. Cho and L. K. Saul. “Kernel Methods for
Deep Learning”. In: NIPS. 2009, pp. 342–350.
[CS18] P. Chaudhari and S. Soatto. “Stochastic gradi￾ent descent performs variational inference, converges
to limit cycles for deep networks”. In: ICLR. 2018.
[CSF16] A. W. Churchill, S. Sigtia, and C. Fernando.
“Learning to Generate Genotypes with Neural Net￾works”. In: (2016). arXiv: 1604.04153 [cs.NE].
[Csi67] I. Csiszar. “Information-Type Measures of Dif￾ference of Probability Distributions and Indirect Ob￾servations”. In: Studia Scientiarum Mathematicarum
Hungarica 2 (1967), pp. 299–318.
[CSN21] J. Coullon, L. South, and C. Nemeth.
“Stochastic Gradient MCMC with Multi-Armed Ban￾dit Tuning”. In: (2021). arXiv: 2105.13059 [stat.CO].
[CSZ06] O. Chapelle, B. Scholkopf, and A. Zien, eds.
Semi-Supervised Learning. MIT Press, 2006.
[CT06] T. M. Cover and J. A. Thomas. Elements of
Information Theory. 2nd edition. John Wiley, 2006.
[CT+19] M. F. Cusumano-Towner, F. A. Saad, A. K.
Lew, and V. K. Mansinghka. “Gen: a general-purpose
probabilistic programming system with programmable
inference”. In: Proceedings of the 40th ACM SIG￾PLAN Conference on Programming Language De￾sign and Implementation. PLDI 2019. Association for
Computing Machinery, 2019, pp. 221–236.
[CT91] T. M. Cover and J. A. Thomas. Elements of
Information Theory. John Wiley, 1991.
[CTM17] M. F. Cusumano-Towner and V. K. Mans￾inghka. “AIDE: An algorithm for measuring the accu￾Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
racy of probabilistic inference algorithms”. In: NIPS.
2017.
[CTN17] Y. Chali, M. Tanvee, and M. T. Nayeem. “To￾wards abstractive multi-document summarization us￾ing submodular function-based framework, sentence
compression and merging”. In: Proceedings of the
Eighth International Joint Conference on Natural
Language Processing (Volume 2: Short Papers). 2017,
pp. 418–424.
[CTS78] C. Cannings, E. A. Thompson, and M. H. Skol￾nick. “Probability functions in complex pedigrees”. In:
Advances in Applied Probability 10 (1978), pp. 26–61.
[CUH16] D.-A. Clevert, T. Unterthiner, and S. Hochre￾iter. “Fast and Accurate Deep Network Learning by
Exponential Linear Units (ELUs)”. In: ICLR. 2016.
[Cui+18] Y. Cui, Y. Song, C. Sun, A. Howard, and S.
Belongie. “Large scale fine-grained categorization and
domain-specific transfer learning”. In: Proceedings of
the IEEE conference on computer vision and pattern
recognition. 2018, pp. 4109–4118.
[Cun22] Y. L. Cun. A path towards autonomous AI.
2022.
[Cun83] W. H. Cunningham. “Decomposition of sub￾modular functions”. In: Combinatorica 3.1 (1983),
pp. 53–68.
[Cut13] M. Cuturi. “Sinkhorn Distances: Lightspeed
Computation of Optimal Transportation Distances”.
In: NIPS. 2013.
[CW07] C. M. Carvahlo and M. West. “Dynamic
Matrix-Variate Graphical Models”. In: Bayesian Anal￾ysis 2.1 (2007), pp. 69–98.
[CW16] T. Cohen and M. Welling. “Group Equivari￾ant Convolutional Networks”. en. In: ICML. 2016,
pp. 2990–2999.
[CWG20] D. C. Castro, I. Walker, and B. Glocker.
“Causality matters in medical imaging”. en. In: Nat.
Commun. 11.1 (2020), p. 3673.
[CWS21] J. Courts, A. G. Wills, and T. B. Schön.
“Gaussian Variational State Estimation for Nonlinear
State-Space Models”. In: IEEE Trans. Signal Process.
69 (2021), pp. 5979–5993.
[CXH21] X. Chen, S. Xie, and K. He. “An empirical
study of training self-supervised vision transformers”.
In: arXiv preprint arXiv:2104.02057 (2021).
[CY20] G. Cormode and K. Yi. Small Summaries for
Big Data. Cambridge University Press, 2020.
[Cza+20] J. Czarnowski, T. Laidlow, R. Clark, and
A. J. Davison. “DeepFactors: Real-Time Probabilistic
Dense Monocular SLAM”. In: ICRA. 2020.
[CZG20] B. Charpentier, D. Zügner, and S. Günne￾mann. “Posterior network: Uncertainty estimation
without ood samples via density-based pseudo-counts”.
In: arXiv preprint arXiv:2006.09239 (2020).
[CZS22] A. Corenflos, Z. Zhao, and S. Särkkä. “Tempo￾ral Gaussian Process Regression in Logarithmic Time”.
In: 2022 25th International Conference on Informa￾tion Fusion (FUSION). July 2022, pp. 1–5.
[D’A+20] A. D’Amour et al. “Underspecification
Presents Challenges for Credibility in Modern Ma￾chine Learning”. In: (2020). arXiv: 2011.03395 [cs.LG].
[D’A+21] A. D’Amour, P. Ding, A. Feller, L. Lei, and
J. Sekhon. “Overlap in observational studies with high￾dimensional covariates”. In: Journal of Econometrics
221.2 (2021), pp. 644–654.
[Dag+21] N. Dagan, N. Barda, E. Kepten, O. Miron,
S. Perchik, M. A. Katz, M. A. Hernán, M. Lipsitch,
B. Reis, and R. D. Balicer. “BNT162b2 mRNA Covid￾19 Vaccine in a Nationwide Mass Vaccination Setting”.
In: New England Journal of Medicine 384.15 (2021),
pp. 1412–1423. eprint: https : / / doi . org / 10 . 1056 /
NEJMoa2101765.
[Dai+17] H. Dai, B. Dai, Y.-M. Zhang, S. Li, and
L. Song. “Recurrent Hidden Semi-Markov Model”. In:
ICLR. 2017.
[Dai+18] B. Dai, A. Shaw, L. Li, L. Xiao, N. He, Z.
Liu, J. Chen, and L. Song. “SBEED: Convergent Rein￾forcement Learning with Nonlinear Function Approxi￾mation”. In: ICML. 2018, pp. 1133–1142.
[Dai+19a] B. Dai, H. Dai, A. Gretton, L. Song, D. Schu￾urmans, and N. He. “Kernel exponential family esti￾mation via doubly dual embedding”. In: AISTATS.
PMLR. 2019, pp. 2321–2330.
[Dai+19b] B. Dai, Z. Liu, H. Dai, N. He, A. Gretton,
L. Song, and D. Schuurmans. “Exponential family esti￾mation via adversarial dynamics embedding”. In: Ad￾vances in Neural Information Processing Systems.
2019, pp. 10979–10990.
[Dai+20a] C. Dai, J. Heng, P. E. Jacob, and N. White￾ley. “An invitation to sequential Monte Carlo sam￾plers”. In: (2020). arXiv: 2007.11936 [stat.CO].
[Dai+20b] Z. Dai, G. Lai, Y. Yang, and Q. V. Le.
“Funnel-Transformer: Filtering out Sequential Redun￾dancy for Efficient Language Processing”. In: NIPS.
2020.
[Dal+04] N. Dalvi, P. Domingos, S. Sanghai, and D.
Verma. “Adversarial classification”. In: Proceedings of
the tenth ACM SIGKDD international conference on
Knowledge discovery and data mining. 2004, pp. 99–
108.
[Dar03] A. Darwiche. “A Differential Approach to Infer￾ence in Bayesian Networks”. In: J. ACM 50.3 (2003),
pp. 280–305.
[Dar09] A. Darwiche. Modeling and Reasoning with
Bayesian Networks. Cambridge, 2009.
[Dar+11] S. Darolles, Y. Fan, J.-P. Florens, and E.
Renault. “Nonparametric instrumental regression”. In:
Econometrica 79.5 (2011), pp. 1541–1565.
[Dar80] R. A. Darton. “Rotation in Factor Analysis”.
In: Journal of the Royal Statistical Society. Series D
(The Statistician) 29.3 (1980), pp. 167–194.
[Dau05] F Daum. “Nonlinear filters: beyond the
Kalman filter”. In: IEEE Aerospace and Electronic
Systems Magazine 20.8 (Aug. 2005), pp. 57–69.
[Dav+04] T. A. Davis, J. R. Gilbert, S. I. Larimore,
and E. G. Ng. “A Column Approximate Minimum
Degree Ordering Algorithm”. In: ACM Trans. Math.
Softw. 30.3 (2004), pp. 353–376.
[Dav+18] T. R. Davidson, L. Falorsi, N. De Cao, T.
Kipf, and J. M. Tomczak. “Hyperspherical Variational
Auto-Encoders”. In: UAI. 2018.
[Daw00] A. P. Dawid. “Causal Inference Without Coun￾terfactuals”. In: JASA 95.450 (2000), pp. 407–424.
[Daw02] A. P. Dawid. “Influence diagrams for causal
modelling and inference”. In: Intl. Stat. Review 70
(2002). Corrections p437, pp. 161–189.
[Daw15] A. P. Dawid. “Statistical Causality from a
Decision-Theoretic Perspective”. In: Annu. Rev. Stat.
Appl. 2.1 (2015), pp. 273–303.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1256
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[Daw82] A. P. Dawid. “The Well-Calibrated Bayesian”.
In: JASA 77.379 (1982), pp. 605–610.
[Dax+21] E. Daxberger, A. Kristiadi, A. Immer, R. Es￾chenhagen, M. Bauer, and P. Hennig. “Laplace Redux–
Effortless Bayesian Deep Learning”. In: NIPS. 2021.
[Day+95] P. Dayan, G. Hinton, R. Neal, and R. Zemel.
“The Helmholtz machine”. In: Neural Networks 9.8
(1995).
[DBB20] S. Daulton, M. Balandat, and E. Bakshy. “Dif￾ferentiable Expected Hypervolume Improvement for
Parallel Multi-Objective Bayesian Optimization”. In:
NIPS. 2020.
[DBP19] C. Durkan, A. Bekasov, and I. M. G. Papa￾makarios. “Neural Spline Flows”. In: NIPS. 2019.
[DBW20] I. A. Delbridge, D. S. Bindel, and A. G.
Wilson. “Randomly Projected Additive Gaussian Pro￾cesses for Regression”. In: International Conference
on Machine Learning. 2020.
[DCF+15] E. Denton, S. Chintala, R. Fergus, et al.
“Deep generative image models using a Laplacian pyra￾mid of adversarial networks”. In: NIPS. 2015.
[DD22] S. Doyen and N. B. Dadario. “12 Plagues of
AI in Healthcare: A Practical Guide to Current Issues
With Using Machine Learning in a Medical Context”.
en. In: Front Digit Health 4 (May 2022), p. 765406.
[DDL97] S. DellaPietra, V. DellaPietra, and J. Lafferty.
“Inducing features of random fields”. In: IEEE PAMI
19.4 (1997).
[DE00] R. Dahlhaus and M. Eichler. “Causality and
graphical models for time series”. In: Highly structured
stochastic systems. Ed. by P. Green, N. Hjort, and S.
Richardson. Oxford University Press, 2000.
[DE04] J. Dow and J. Endersby. “Multinomial probit
and multinomial logit: a comparison of choice models
for voting research”. In: Electoral Studies 23.1 (2004),
pp. 107–122.
[Dec96] R. Dechter. “Bucket elimination: a unifying
framework for probabilistic inference”. In: UAI. 1996.
[DeG70] M. DeGroot. Optimal Statistical Decisions.
McGraw-Hill, 1970.
[DEL20] H. M. Dolatabadi, S. Erfani, and C. Leckie.
“Invertible Generative Modeling using Linear Rational
Splines”. In: AISTATS. 2020, pp. 4236–4246.
[Del+21] M. Delange, R. Aljundi, M. Masana, S.
Parisot, X. Jia, A. Leonardis, G. Slabaugh, and T.
Tuytelaars. “A continual learning survey: Defying for￾getting in classification tasks”. en. In: IEEE PAMI
(2021).
[Den+02] D. Denison, C. Holmes, B. Mallick, and A.
Smith. Bayesian methods for nonlinear classification
and regression. Wiley, 2002.
[Den+20] Y. Deng, A. Bakhtin, M. Ott, A. Szlam, and
M. Ranzato. “Residual Energy-Based Models for Text
Generation”. In: International Conference on Learn￾ing Representations. 2020.
[Dev+18] J. Devlin, M.-W. Chang, K. Lee, and K.
Toutanova. “Bert: Pre-training of deep bidirectional
transformers for language understanding”. In: arXiv
preprint arXiv:1810.04805 (2018).
[Dev+19] J. Devlin, M.-W. Chang, K. Lee, and K.
Toutanova. “BERT: Pre-training of Deep Bidirec￾tional Transformers for Language Understanding”. In:
NAACL. 2019.
[Dev+21] L. Devlin, P. Horridge, P. L. Green, and S.
Maskell. “The No-U-Turn Sampler as a Proposal Dis￾tribution in a Sequential Monte Carlo Sampler with a
Near-Optimal L-Kernel”. In: (2021). arXiv: 2108.02498
[stat.CO].
[Dev85] P. A. Devijver. “Baum’s forward-backward al￾gorithm revisited”. In: Pattern Recognition Letters
3.6 (1985), pp. 369–373.
[Dex] Dex: Research language for array processing in
the Haskell/ML family. https://github.com/google￾research/dex-lang. 2019.
[DF18] E. Denton and R. Fergus. “Stochastic Video
Generation with a Learned Prior”. In: ICML. 2018.
[DF19] X. Ding and D. J. Freedman. “Learning Deep
Generative Models with Annealed Importance Sam￾pling”. In: (2019). arXiv: 1906.04904 [stat.ML].
[DF21] F. D’Angelo and V. Fortuin. “Repulsive Deep
Ensembles are Bayesian”. In: NIPS. May 2021.
[DFF21] S. Dozinski, U. Feige, and M. Feldman. “Are
Gross Substitutes a Substitute for Submodular Valua￾tions?” In: arXiv preprint arXiv:2102.13343 (2021).
[DFO20] M. Deisenroth, A. Faisal, and C. S. Ong.
Mathematics for machine learning. Cambridge, 2020.
[DFR15] M. P. Deisenroth, D. Fox, and C. E. Ras￾mussen. “Gaussian Processes for Data-Efficient Learn￾ing in Robotics and Control”. en. In: IEEE PAMI 37.2
(2015), pp. 408–423.
[DFS16] A. Daniely, R. Frostig, and Y. Singer. “Toward
Deeper Understanding of Neural Networks: The Power
of Initialization and a Dual View on Expressivity”. In:
NIPS. 2016, pp. 2253–2261.
[DG17] P. Dabkowski and Y. Gal. “Real time image
saliency for black box classifiers”. In: NeurIPS (2017).
[DG84] P. J. Diggle and R. J. Gratton. “Monte Carlo
methods of inference for implicit statistical models”.
In: Journal of the Royal Statistical Society. Series B
(Methodological) (1984), pp. 193–227.
[DGA00] A. Doucet, S. Godsill, and C. Andrieu.
“On sequential Monte Carlo Sampling Methods for
Bayesian Filtering”. In: Statistics and Computing
10.3 (2000), pp. 197–208.
[DGE15] C. Doersch, A. Gupta, and A. A. Efros. “Un￾supervised visual representation learning by context
prediction”. In: Proceedings of the IEEE interna￾tional conference on computer vision. 2015, pp. 1422–
1430.
[DGK01] A. Doucet, N. Gordon, and V. Krishna￾murthy. “Particle Filters for State Estimation of Jump
Markov Linear Systems”. In: IEEE Trans. on Signal
Processing 49.3 (2001), pp. 613–624.
[DH22] F. Dellaert and S. Hutchinson. Introducion to
Robotics and Perception. 2022.
[DHK14] A. Deshpande, L. Hellerstein, and D.
Kletenik. “Approximation algorithms for stochastic
boolean function evaluation and stochastic submod￾ular set cover”. In: Proceedings of the twenty-fifth
annual ACM-SIAM Symposium on Discrete Algo￾rithms. SIAM. 2014, pp. 1453–1466.
[Dia88a] P Diaconis. “Recent progress on de Finetti’s
notions of exchangeability”. In: Bayesian Statistics 3
(1988).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Dia88b] P. Diaconis. “Sufficiency as statistical symme￾try”. In: Proceedings of the AMS Centennial Sympo￾sium. 1988, pp. 15–26.
[Die00] T. G. Dietterich. “Ensemble Methods in Ma￾chine Learning”. In: Multiple Classifier Systems.
Springer Berlin Heidelberg, 2000, pp. 1–15.
[Die+07] M. Diehl, H. G. Bock, H. Diedam, and P.-B.
Wieber. “Fast Direct Multiple Shooting Algorithms for
Optimal Robot Control”. In: Lecture Notes in Control
and Inform. Sci. 340 (2007).
[Die10] L. Dietz. Directed Factor Graph Notation for
Generative Models. Tech. rep. MPI, 2010.
[Die+17] A. B. Dieng, C. Wang, J. Gao, and J. Paisley.
“TopicRNN: A Recurrent Neural Network with Long￾Range Semantic Dependency”. In: ICLR. 2017.
[Die+19a] A. B. Dieng, Y. Kim, A. M. Rush, and D. M.
Blei. “Avoiding Latent Variable Collapse With Gener￾ative Skip Models”. In: AISTATS. 2019.
[Die+19b] A. B. Dieng, F. J. Ruiz, D. M. Blei, and
M. K. Titsias. “Prescribed generative adversarial net￾works”. In: arXiv preprint arXiv:1910.04302 (2019).
[Dik+20] N. Dikkala, G. Lewis, L. Mackey, and V.
Syrgkanis. “Minimax Estimation of Conditional Mo￾ment Models”. In: Advances in Neural Information
Processing Systems. 2020.
[Din+17] L. Dinh, R. Pascanu, S. Bengio, and Y. Ben￾gio. “Sharp Minima Can Generalize For Deep Nets”.
In: (2017). arXiv: 1703.04933 [cs.LG].
[DJ11] A. Doucet and A. M. Johansen. “A Tutorial on
Particle Filtering and Smoothing: Fifteen years later”.
In: Handbook of Nonlinear Filtering. Ed. by D Crisan
and B Rozovsk. 2011.
[DJ21] K. Desai and J. Johnson. VirTex: Learning
Visual Representations from Textual Annotations.
2021. arXiv: 2006.06666 [cs.CV].
[DJK18] J. Djolonga, S. Jegelka, and A. Krause.
“Provable Variational Inference for Constrained Log￾Submodular Models”. In: NeurIPS. 2018.
[DK12] J. Durbin and S. J. Koopman. Time Series
Analysis by State Space Methods (Second Edition).
en. Revised ed. edition. Oxford University Press, 2012.
[DK14] J. Djolonga and A. Krause. “From map to
marginals: Variational inference in bayesian submodu￾lar models”. In: Advances in Neural Information Pro￾cessing Systems. 2014, pp. 244–252.
[DK15a] J. Djolonga and A. Krause. “Scalable varia￾tional inference in log-supermodular models”. In: In￾ternational Conference on Machine Learning. PMLR.
2015, pp. 1804–1813.
[DK15b] G. Durrett and D. Klein. “Neural CRF Pars￾ing”. In: Proc. ACL. 2015.
[DKB15] L. Dinh, D. Krueger, and Y. Bengio. “NICE:
Non-linear Independent Components Estimation”. In:
ICLR. 2015.
[DKD16] J. Donahue, P. Krahenbuhl, and T. Dar￾rell. “Adversarial feature learning”. In: arXiv preprint
arXiv:1605.09782 (2016).
[DKD17] J. Donahue, P. Krähenbühl, and T. Dar￾rell. Adversarial Feature Learning. 2017. arXiv: 1605.
09782 [cs.LG].
[DKS13] J. Dick, F. Y. Kuo, and I. H. Sloan. “High￾dimensional integration: the quasi-Monte Carlo way”.
In: Acta Numerica 22 (2013), 133–288.
[DL09] P. Domingos and D. Lowd. Markov Logic: An
Interface Layer for AI. Morgan & Claypool, 2009.
[DL10] J. V. Dillon and G. Lebanon. “Stochastic Com￾posite Likelihood”. In: J. Mach. Learn. Res. 11 (2010),
pp. 2597–2633.
[DL13] A. Damianou and N. Lawrence. “Deep Gaussian
Processes”. en. In: AISTATS. 2013, pp. 207–215.
[DL93] P. Dagum and M. Luby. “Approximating prob￾abilistic inference in Bayesian belief networks is NP￾hard”. In: Artificial Intelligence 60 (1993), pp. 141–
153.
[DLB17] C. Dann, T. Lattimore, and E. Brunskill.
“Unifying PAC and Regret: Uniform PAC Bounds for
Episodic Reinforcement Learning”. In: NIPS. 2017,
pp. 5717–5727.
[DLM09] H. Daumé III, J. Langford, and D. Marcu.
“Search-based Structured Prediction”. In: MLJ 75.3
(2009), pp. 297–325.
[DLM99] B. Delyon, M. Lavielle, and E. Moulines.
“Convergence of a stochastic approximation version
of the EM algorithm”. In: Annals of Statistics 27.1
(1999), pp. 94–128.
[DLR77] A. P. Dempster, N. M. Laird, and D. B. Ru￾bin. “Maximum likelihood from incomplete data via
the EM algorithm”. In: J. of the Royal Statistical So￾ciety, Series B 34 (1977), pp. 1–38.
[DLT21] M. De Lange and T. Tuytelaars. “Contin￾ual Prototype Evolution: Learning Online from Non￾Stationary Data Streams”. In: ICCV. 2021.
[DM01] D. van Dyk and X.-L. Meng. “The Art of Data
Augmentation”. In: J. Computational and Graphical
Statistics 10.1 (2001), pp. 1–50.
[DM19a] Y. Du and I. Mordatch. “Implicit Genera￾tion and Generalization in Energy-Based Models”. In:
(2019). arXiv: 1903.08689 [cs.LG].
[DM19b] Y. Du and I. Mordatch. “Implicit Generation
and Modeling with Energy Based Models”. In: NIPS.
2019, pp. 3608–3618.
[DM22] A. P. Dawid and M. Musio. “Effects of Causes
and Causes of Effects”. In: Annu. Rev. Stat. Appl. 9.1
(Mar. 2022), pp. 261–287.
[DMDJ12] P. Del Moral, A. Doucet, and A. Jasra. “An
adaptive sequential Monte Carlo method for approxi￾mate Bayesian computation”. In: Stat. Comput. 22.5
(2012), pp. 1009–1020.
[DMKM22] G. Duran-Martin, A. Kara, and K. Mur￾phy. “Efficient Online Bayesian Inference for Neural
Bandits”. In: AISTATS. 2022.
[DMM17] A. P. Dawid, M. Musio, and R. Murtas. “The
probability of causation”. In: Law, Probability and
Risk 16.4 (2017), pp. 163–179.
[DMP18] C. Donahue, J. McAuley, and M. Puckette.
“Adversarial Audio Synthesis”. In: International Con￾ference on Learning Representations. 2018.
[DMV15] S. Dash, D. M. Malioutov, and K. R. Varsh￾ney. “Learning interpretable classification rules us￾ing sequential rowsampling”. In: 2015 IEEE Interna￾tional Conference on Acoustics, Speech and Signal
Processing (ICASSP). IEEE. 2015, pp. 3337–3341.
[DN21a] P. Dhariwal and A. Nichol. “Diffusion Models
Beat GANs on Image Synthesis”. In: NIPS. May 2021.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1258
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[DN21b] P. Dhariwal and A. Q. Nichol. “Diffusion Mod￾els Beat GANs on Image Synthesis”. In: NIPS. May
2021.
[Dnp] .
[DNR11] D. Duvenaud, H. Nickisch, and C. E. Ras￾mussen. “Additive Gaussian Processes”. In: NIPS.
2011.
[Dom+06] P. Domingos, S. Kok, H. Poon, M. Richard￾son, and P. Singla. “Unifying Logical and Statistical
AI”. In: IJCAI. 2006.
[Dom+19] A.-K. Dombrowski, M. Alber, C. J. Anders,
M. Ackermann, K.-R. Müller, and P. Kessel. “Explana￾tions can be manipulated and geometry is to blame”.
In: arXiv preprint arXiv:1906.07983 (2019).
[Don+14] J. Donahue, Y. Jia, O. Vinyals, J. Hoff￾man, N. Zhang, E. Tzeng, and T. Darrell. “Decaf: A
deep convolutional activation feature for generic vi￾sual recognition”. In: International conference on ma￾chine learning. 2014, pp. 647–655.
[Don+17a] K. Dong, D. Eriksson, H. Nickisch, D.
Bindel, and A. G. Wilson. “Scalable Log Determinants
for Gaussian Process Kernel Learning”. In: NIPS.
2017, pp. 6327–6337.
[Don+17b] Y. Dong, H. Su, J. Zhu, and F. Bao.
“Towards interpretable deep neural networks by
leveraging adversarial examples”. In: arXiv preprint
arXiv:1708.05493 (2017).
[Don+21] X. Dong, J. Bao, T. Zhang, D. Chen, W.
Zhang, L. Yuan, D. Chen, F. Wen, and N. Yu. “Peco:
Perceptual codebook for bert pre-training of vision
transformers”. In: arXiv preprint arXiv:2111.12710
(2021).
[Doo+17] J. van Doorn, A. Ly, M. Marsman, and
E.-J. Wagenmakers. “Bayesian Rank-Based Hypothe￾sis Testing for the Rank Sum Test, the Signed Rank
Test, and Spearman’s ρ”. In: (Dec. 2017). arXiv: 1712.
06941 [stat.ME].
[Dor+16] V. Dorie, M. Harada, N. B. Carnegie, and
J. Hill. “A flexible, interpretable framework for assess￾ing sensitivity to unmeasured confounding”. In: Statis￾tics in Medicine 35.20 (2016), pp. 3453–3470. eprint:
https://onlinelibrary.wiley.com/doi/pdf/10.1002/
sim.6973.
[Dos+21] A. Dosovitskiy et al. “An Image is Worth
16x16 Words: Transformers for Image Recognition
at Scale”. In: International Conference on Learning
Representations. 2021.
[Doy+07] K. Doya, S. Ishii, A. Pouget, and R. P. N.
Rao, eds. Bayesian Brain: Probabilistic Approaches
to Neural Coding. MIT Press, 2007.
[DR11] M. P. Deisenroth and C. E. Rasmussen.
“PILCO: A Model-Based and Data-Efficient Approach
to Policy Search”. In: ICML. 2011.
[DR17] G. K. Dziugaite and D. M. Roy. “Computing
nonvacuous generalization bounds for deep (stochas￾tic) neural networks with many more parameters than
training data”. In: UAI. 2017.
[DR21] H. Duanmu and D. M. Roy. “On extended
admissibale procedures and their nonstandard Bayes
risk”. In: Annals of Statistics (2021).
[DRB19] A. B. Dieng, F. J. R. Ruiz, and D. M. Blei.
“The Dynamic Embedded Topic Model”. In: (2019).
arXiv: 1907.05545 [cs.CL].
[DRG15] G. K. Dziugaite, D. M. Roy, and Z. Ghahra￾mani. “Training generative neural networks via Max￾imum Mean Discrepancy optimization”. In: ICML.
2015.
[Dru08] J. Drugowitsch. Bayesian linear regression.
Tech. rep. U. Rochester, 2008.
[DS18] J. Domke and D. R. Sheldon. “Importance
Weighting and Variational Inference”. In: NIPS. 2018,
pp. 4474–4483.
[DS19] J. Donahue and K. Simonyan. “Large scale ad￾versarial representation learning”. In: arXiv preprint
arXiv:1907.02544 (2019).
[DSDB17] L. Dinh, J. Sohl-Dickstein, and S. Bengio.
“Density estimation using Real NVP”. In: ICLR. 2017.
[DSK16] V. Dumoulin, J. Shlens, and M. Kudlur. “A
Learned Representation For Artistic Style”. In: (2016).
[DSP21] M. Dowling, P. Sokół, and I. M. Park. “Hida￾Matérn Kernel”. In: (July 2021). arXiv: 2107 . 07098
[stat.ML].
[DSZ16] A. Datta, S. Sen, and Y. Zick. “Algorith￾mic transparency via quantitative input influence:
Theory and experiments with learning systems”. In:
2016 IEEE symposium on security and privacy (SP).
IEEE. 2016, pp. 598–617.
[DTK16] J. Djolonga, S. Tschiatschek, and A. Krause.
“Variational inference in mixed probabilistic submodu￾lar models”. In: Advances in Neural Information Pro￾cessing Systems. 2016, pp. 1759–1767.
[Du+18] J. Du, S. Ma, Y.-C. Wu, S. Kar, and J. M. F.
Moura. “Convergence Analysis of Distributed Infer￾ence with Vector-Valued Gaussian Belief Propagation”.
In: JMLR 18.172 (2018), pp. 1–38.
[Du+19] S. S. Du, K. Hou, B. Póczos, R. Salakhutdi￾nov, R. Wang, and K. Xu. “Graph Neural Tangent
Kernel: Fusing Graph Neural Networks with Graph
Kernels”. In: (2019). arXiv: 1905.13192 [cs.LG].
[Du+20] Y. Du, S. Li, J. Tenenbaum, and I. Mordatch.
“Improved Contrastive Divergence Training of Energy
Based Models”. In: arXiv preprint arXiv:2012.01316
(2020).
[Du+21] C. Du, Z. Gao, S. Yuan, L. Gao, Z. Li, Y. Zeng,
X. Zhu, J. Xu, K. Gai, and K.-C. Lee. “Exploration
in Online Advertising Systems with Deep Uncertainty￾Aware Learning”. In: KDD. KDD ’21. Association for
Computing Machinery, 2021, pp. 2792–2801.
[Dua+20] S. Duan, N. Watters, L. Matthey, C. P.
Burgess, A. Lerchner, and I. Higgins. “A Heuris￾tic for Unsupervised Model Selection for Variational
Disentangled Representation Learning”. In: ArXiv
abs/1905.12614 (2020).
[Dua+87] S. Duane, A. Kennedy, B. Pendleton, and D.
Roweth. “Hybrid Monte Carlo”. In: Physics Letters B
195.2 (1987), pp. 216–222.
[Dub+16] A. Dubey, S. J. Reddi, B. Póczos, A. J.
Smola, E. P. Xing, and S. A. Williamson. “Variance
Reduction in Stochastic Gradient Langevin Dynam￾ics”. en. In: NIPS. Vol. 29. 2016, pp. 1154–1162.
[Dub20] Y. Dubois. Neural Process Family. http : / /
yanndubs.github.io/Neural-Process-Family/. 2020.
[Dud13] J. Duda. “Asymmetric numeral systems: en￾tropy coding combining speed of Huffman coding with
compression rate of arithmetic coding”. In: (2013).
arXiv: 1311.2540 [cs.IT].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Duf02] M. Duff. “Optimal Learning: Computational
procedures for Bayes-adaptive Markov decision pro￾cesses”. PhD thesis. U. Mass. Dept. Comp. Sci., 2002.
[Dum+16] V. Dumoulin, I. Belghazi, B. Poole, O. Mas￾tropietro, A. Lamb, M. Arjovsky, and A. Courville.
“Adversarially learned inference”. In: arXiv preprint
arXiv:1606.00704 (2016).
[Dum+17] V. Dumoulin, I. Belghazi, B. Poole, O. Mas￾tropietro, A. Lamb, M. Arjovsky, and A. Courville.
Adversarially Learned Inference. 2017. arXiv: 1606 .
00704 [stat.ML].
[Dum+18] A. Dumitrache, O. Inel, B. Timmermans, C.
Ortiz, R.-J. Sips, L. Aroyo, and C. Welty. “Empir￾ical Methodology for Crowdsourcing Ground Truth”.
In: Semantic Web Journal (2018).
[Dur+19] C. Durkan, A. Bekasov, I. Murray, and G.
Papamakarios. “Cubic-Spline Flows”. In: ICML Work￾shop on Invertible Neural Networks and Normalizing
Flows. 2019.
[Dur+98] R. Durbin, S. Eddy, A. Krogh, and G. Mitchi￾son. Biological Sequence Analysis: Probabilistic Mod￾els of Proteins and Nucleic Acids. Cambridge Univer￾sity Press, 1998.
[Duv+13] D. Duvenaud, J. Lloyd, R. Grosse, J. Tenen￾baum, and G. Zoubin. “Structure Discovery in Non￾parametric Regression through Compositional Kernel
Search”. en. In: ICML. 2013, pp. 1166–1174.
[Duv14] D. Duvenaud. “Automatic Model Construc￾tion with Gaussian Processes”. PhD thesis. Computa￾tional and Biological Learning Laboratory, University
of Cambridge, 2014.
[dV04] D. P. de Farias and B. Van Roy. “On Constraint
Sampling in the Linear Programming Approach to Ap￾proximate Dynamic Programming”. In: Mathematics
of Operations Research 29.3 (2004), pp. 462–478.
[DV+17] H. De Vries, F. Strub, J. Mary, H. Larochelle,
O. Pietquin, and A. C. Courville. “Modulating early
visual processing by language”. In: Advances in Neu￾ral Information Processing Systems. 2017, pp. 6594–
6604.
[DV75] M. D. Donsker and S. S. Varadhan. “Asymp￾totic evaluation of certain Markov process expecta￾tions for large time, I”. In: Communications on Pure
and Applied Mathematics 28.1 (1975), pp. 1–47.
[DV99] A. P. Dawid and V. Vovk. “Prequential prob￾ability: Principles and properties”. In: Bernoulli 5
(1999), pp. 125–162.
[DVK17] F. Doshi-Velez and B. Kim. Towards A Rig￾orous Science of Interpretable Machine Learning.
2017. eprint: 1702.08608 (stat.ML).
[DW19] B. Dai and D. Wipf. “Diagnosing and Enhanc￾ing VAE Models”. In: ICLR. 2019.
[DWS12] T. Degris, M. White, and R. S. Sutton. “Off￾Policy Actor-Critic”. In: ICML. 2012.
[DWW19] B. Dai, Z. Wang, and D. Wipf. “The Usual
Suspects? Reassessing Blame for VAE Posterior Col￾lapse”. In: (2019). arXiv: 1912.10702 [cs.LG].
[DWW20] B. Dai, Z. Wang, and D. Wipf. “The Usual
Suspects? Reassessing Blame for VAE Posterior Col￾lapse”. In: ICML. Ed. by H. D. Iii and A. Singh.
Vol. 119. Proceedings of Machine Learning Research.
PMLR, 2020, pp. 2313–2322.
[DY79] P. Diaconis and D. Ylvisaker. “Conjugate pri￾ors for exponential families”. In: vol. 7. 1979, pp. 269–
281.
[ECM18] P. Etoori, M. Chinnakotla, and R. Mamidi.
“Automatic Spelling Correction for Resource-Scarce
Languages using Deep Learning”. In: Proceedings of
ACL 2018, Student Research Workshop. Association
for Computational Linguistics, 2018, pp. 146–152.
[ED05] D. Earl and M. Deem. “Parallel tempering: The￾ory, applications, and new perspectives”. In: Phys.
Chem. Chem. Phys. 7 (2005), p. 3910.
[Edm69] H. P. Edmundson. “New methods in auto￾matic extracting”. In: Journal of the ACM (JACM)
16.2 (1969), pp. 264–285.
[Edm70] J. Edmonds. “Matroids, submodular func￾tions, and certain polyhedra”. In: Combinatorial
Structures and Their Applications (1970), pp. 69–87.
[EFL04] E. Erosheva, S. Fienberg, and J. Lafferty.
“Mixed-membership models of scientific publications”.
In: PNAS 101 (2004), pp. 5220–2227.
[Efr86] B. Efron. “Why Isn’t Everyone a Bayesian?” In:
The American Statistician 40.1 (1986).
[EGW05] D. Ernst, P. Geurts, and L. Wehenkel.
“Tree-Based Batch Mode Reinforcement Learning”. In:
JMLR 6 (2005), pp. 503–556.
[EH16] B. Efron and T. Hastie. Computer Age Sta￾tistical Inference, Student Edition: Algorithms, Ev￾idence, and Data Science. en. Cambridge University
Press, June 2016.
[Eis16] J. Eisner. “Inside-Outside and Forward￾Backward Algorithms Are Just Backprop (Tutorial
Paper)”. In: EMNLP Workshop on Structured Pre￾diction for NLP. 2016.
[Eke+13] M. Ekeberg, C. Lövkvist, Y. Lan, M. Weigt,
and E. Aurell. “Improved contact prediction in pro￾teins: using pseudolikelihoods to infer Potts models”.
en. In: Phys. Rev. E Stat. Nonlin. Soft Matter Phys.
87.1 (2013), p. 012707.
[EM07] D. Eaton and K. Murphy. “Exact Bayesian
structure learning from uncertain interventions”. In:
AI/Statistics. 2007.
[EMH19] T. Elsken, J. H. Metzen, and F. Hutter. “Neu￾ral Architecture Search: A Survey”. In: JMLR 20
(2019), pp. 1–21.
[EMK06] G. Elidan, I. McGraw, and D. Koller. “Resid￾ual belief propagation: Informed scheduling for asyn￾chronous message passing”. In: UAI. 2006.
[Eng+18] J. Engel, K. K. Agrawal, S. Chen, I. Gulra￾jani, C. Donahue, and A. Roberts. “GANSynth: Ad￾versarial Neural Audio Synthesis”. In: International
Conference on Learning Representations. 2018.
[Erh+09] D. Erhan, Y. Bengio, A. Courville, and P.
Vincent. “Visualizing higher-layer features of a deep
network”. In: University of Montreal 1341.3 (2009),
p. 1.
[Erm+13] S. Ermon, C. P. Gomes, A. Sabharwal, and
B. Selman. “Taming the Curse of Dimensionality: Dis￾crete Integration by Hashing and Optimization”. In:
ICML. Feb. 2013.
[ERO21] P. Esser, R. Rombach, and B. Ommer. “Tam￾ing Transformers for High-Resolution Image Synthe￾sis”. In: CVPR. 2021.
[ET93] B. Efron and R. J. Tibshirani. An Introduction
to the Bootstrap. en. 1st ed. Chapman and Hall/CRC,
Jan. 1993.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1260
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[Etz+18] A. Etz, J. M. Haaf, J. N. Rouder, and J.
Vandekerckhove. “Bayesian Inference and Testing Any
Hypothesis You Can Specify”. In: Advances in Meth￾ods and Practices in Psychological Science 1.2 (June
2018), pp. 281–295.
[Eva+18] R. Evans et al. “De novo structure prediction
with deep-learning based scoring”. In: (2018).
[Eve09] G. Evensen. Data Assimilation: The Ensem￾ble Kalman Filter. en. 2nd ed. 2009 edition. Springer,
2009.
[EW10] El-Yaniv and Wiener. “On the Foundations of
Noise-free Selective Classification”. In: JMLR (2010).
[EY09] M. Elad and I. Yavnch. “A plurality of sparse
representations is better than the sparsest one alone”.
In: IEEE Trans. on Info. Theory 55.10 (2009),
pp. 4701–4714.
[Eyk+18] K. Eykholt, I. Evtimov, E. Fernandes, B. Li,
A. Rahmati, C. Xiao, A. Prakash, T. Kohno, and D.
Song. “Robust Physical-World Attacks on Deep Learn￾ing Models”. In: CVPR. 2018.
[Eys+21] B. Eysenbach, A. Khazatsky, S. Levine,
and R. Salakhutdinov. “Mismatched No More: Joint
Model-Policy Optimization for Model-Based RL”. In:
(2021). arXiv: 2110.02758 [cs.LG].
[FA20] I. Fischer and A. A. Alemi. “CEB Improves
Model Robustness”. In: Entropy 22.10 (2020), p. 1081.
[Fad+20] S. G. Fadel, S. Mair, R. da S. Torres, and
U. Brefeld. “Principled Interpolation in Normalizing
Flows”. In: (2020). arXiv: 2010.12059 [stat.ML].
[Fag+18] F. Faghri, D. J. Fleet, J. R. Kiros, and S.
Fidler. “VSE++: Improving Visual-Semantic Embed￾dings with Hard Negatives”. In: BMVC. 2018.
[FAL17] C. Finn, P. Abbeel, and S. Levine. “Model￾Agnostic Meta-Learning for Fast Adaptation of Deep
Networks”. In: ICML. 2017.
[Far22] S. Farquhar. “Understanding Approximation
for Bayesian Inference in Neural Networks”. PhD the￾sis. Oxford, Nov. 2022.
[Fau+18] L. Faury, F. Vasile, C. Calauzènes, and O.
Fercoq. “Neural Generative Models for Global Op￾timization with Gradients”. In: (2018). arXiv: 1805 .
08594 [cs.NE].
[FB19] E. M. Feit and R. Berman. “Test & Roll: Profit￾Maximizing A/B Tests”. In: Marketing Science 38.6
(2019), pp. 1038–1058.
[FBW21] M. Finzi, G. Benton, and A. G. Wilson.
“Residual Pathway Priors for Soft Equivariance Con￾straints”. In: NIPS. 2021.
[FC03] P. Fearnhead and P. Clifford. “On-line inference
for hidden Markov models via particle filters”. en. In:
J. of Royal Stat. Soc. Series B 65.4 (2003), pp. 887–
899.
[FD07a] B. Frey and D. Dueck. “Clustering by Pass￾ing Messages Between Data Points”. In: Science 315
(2007), 972–976.
[FD07b] B. J. Frey and D. Dueck. “Clustering by
passing messages between data points”. In: science
315.5814 (2007), pp. 972–976.
[FDF19] A. M. Franks, A. D’Amour, and A. Feller.
“Flexible Sensitivity Analysis for Observational Stud￾ies Without Observable Implications”. In: Journal
of the American Statistical Association 0.0 (2019),
pp. 1–33. eprint: https://doi.org/10.1080/01621459.
2019.1604369.
[FDZ19] A. Fasano, D. Durante, and G. Zanella.
“Scalable and Accurate Variational Bayes for High￾Dimensional Binary Regression Models”. In: (2019).
arXiv: 1911.06743 [stat.ME].
[FE73] M. Fischler and R. Elschlager. “The representa￾tion and matching of pictorial structures”. In: IEEE
Trans. on Computer 22.1 (1973).
[Fed+18] W. Fedus, M. Rosca, B. Lakshminarayanan,
A. M. Dai, S. Mohamed, and I. Goodfellow. “Many
Paths to Equilibrium: GANs Do Not Need to Decrease
a Divergence At Every Step”. In: International Con￾ference on Learning Representations. 2018.
[Fei98] U. Feige. “A threshold of ln n for approximating
set cover”. In: Journal of the ACM (JACM) (1998).
[Fel+10] P. Felzenszwalb, R. Girshick, D. McAllester,
and D. Ramanan. “Object Detection with Discrimina￾tively Trained Part Based Models”. In: IEEE PAMI
32.9 (2010).
[Fel+19] M. Fellows, A. Mahajan, T. G. J. Rudner, and
S. Whiteson. “VIREL: A Variational Inference Frame￾work for Reinforcement Learning”. In: NeurIPS. 2019,
pp. 7120–7134.
[Fen+21] S. Y. Feng, V. Gangal, J. Wei, S. Chandar,
S. Vosoughi, T. Mitamura, and E. Hovy. “A Survey of
Data Augmentation Approaches for NLP”. In: (2021).
arXiv: 2105.03075 [cs.CL].
[Feu+15] M. Feurer, A. Klein, K. Eggensperger, J.
Springenberg, M. Blum, and F. Hutter. “Efficient
and Robust Automated Machine Learning”. In: NIPS.
2015, pp. 2962–2970.
[FG15] N. Fournier and A. Guillin. “On the rate of con￾vergence in Wasserstein distance of the empirical mea￾sure”. In: Probability Theory and Related Fields 162.3
(2015), pp. 707–738.
[FG18] S. Farquhar and Y. Gal. “Towards Robust Eval￾uations of Continual Learning”. In: (2018). arXiv: 1805.
09733 [stat.ML].
[FGG97] N. Friedman, D. Geiger, and M. Goldszmidt.
“Bayesian network classifiers”. In: MLJ 29 (1997),
pp. 131–163.
[FH12] P. F. Felzenszwalb and D. P. Huttenlocher.
“Distance Transforms of Sampled Functions”. In: The￾ory of Computing 8.19 (2012), pp. 415–428.
[FH17] N. Frosst and G. Hinton. Distilling a Neural
Network Into a Soft Decision Tree. 2017. arXiv: 1711.
09784 [cs.LG].
[FH20] E. Fong and C. Holmes. “On the marginal
likelihood and cross-validation”. In: Biometrika 107.2
(2020).
[FH75] K Fukunaga and L Hostetler. “The estimation
of the gradient of a density function, with applications
in pattern recognition”. In: IEEE Trans. Inf. Theory
21.1 (1975), pp. 32–40.
[FH97] B. J. Frey and G. Hinton. “Efficient stochastic
source coding and an application to a Bayesian net￾work source model”. In: Computer Journal (1997).
[FHDV20] J. Futoma, M. C. Hughes, and F. Doshi￾Velez. “Popcorn: Partially observed prediction con￾strained reinforcement learning”. In: AISTATS
(2020).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[FHHL20] G. Flamich, M. Havasi, and J. M.
Hernández-Lobato. “Compressing images by encod￾ing their latent representations with relative entropy
coding”. In: vol. 33. 2020, pp. 16131–16141.
[FHK03] P. Felzenszwalb, D. Huttenlocher, and J.
Kleinberg. “Fast Algorithms for Large State Space
HMMs with Applications to Web Usage Analysis”. In:
NIPS. 2003.
[FHL19] S. Fort, H. Hu, and B. Lakshminarayanan.
“Deep Ensembles: A Loss Landscape Perspective”. In:
(2019). arXiv: 1912.02757 [stat.ML].
[FHM18] S. Fujimoto, H. van Hoof, and D. Meger.
“Addressing Function Approximation Error in Actor￾Critic Methods”. In: ICLR. 2018.
[FHT08] J. Friedman, T. Hastie, and R. Tibshirani.
“Sparse inverse covariance estimation the graphical
lasso”. In: Biostatistics 9.3 (2008), pp. 432–441.
[FI10] A. Fischer and C. Igel. “Empirical analysis of
the divergence of Gibbs sampling based learning al￾gorithms for restricted Boltzmann machines”. In: In￾ternational conference on artificial neural networks.
Springer. 2010, pp. 208–217.
[Fie70] S. Fienberg. “An Iterative Procedure for Esti￾mation in Contingency Tables”. In: Annals of Mathe￾matical Statistics 41.3 (1970), pp. 907–917.
[Fin+16] C. Finn, P. Christiano, P. Abbeel, and S.
Levine. “A connection between generative adversarial
networks, inverse reinforcement learning, and energy￾based models”. In: arXiv preprint arXiv:1611.03852
(2016).
[Fis20] I. Fischer. “The Conditional Entropy Bottle￾neck”. In: Entropy 22.9 (2020).
[Fis25] R. Fisher. Statistical Methods for Research
Workers. Biological monographs and manuals. Oliver
and Boyd, 1925.
[FJ02] M. A. T. Figueiredo and A. K. Jain. “Unsuper￾vised Learning of Finite Mixture Models”. In: IEEE
PAMI 24.3 (2002), pp. 381–396.
[FJL18] R. Frostig, M. J. Johnson, and C. Leary. “Com￾piling machine learning programs via high-level trac￾ing”. In: Machine Learning and Systems (MLSys)
(2018).
[FK13a] V. Feldman and P. Kothari. “Learning Cov￾erage Functions”. In: CoRR abs/1304.2079 (2013).
arXiv: 1304.2079.
[FK13b] M Frei and H. R. Künsch. “Bridging the en￾semble Kalman and particle filters”. In: Biometrika
100.4 (2013), pp. 781–800.
[FK14] V. Feldman and P. Kothari. “Learning Cov￾erage Functions and Private Release of Marginals”.
In: Proceedings of The 27th Conference on Learn￾ing Theory. Ed. by M. F. Balcan, V. Feldman, and
C. Szepesvári. Vol. 35. Proceedings of Machine Learn￾ing Research. Barcelona, Spain: PMLR, 2014, pp. 679–
702.
[FK21] A. Fisher and E. H. Kennedy. “Visually Com￾municating and Teaching Intuition for Influence Func￾tions”. In: The American Statistician 75.2 (2021),
pp. 162–172. eprint: https : / / doi . org / 10 . 1080 /
00031305.2020.1717620.
[FKH17] S. Falkner, A. Klein, and F. Hutter. “Combin￾ing Hyperband and Bayesian Optimization”. In: NIPS
2017 Bayesian Optimization Workshop. 2017.
[FKV13] V. Feldman, P. Kothari, and J. Vondrák.
“Representation, Approximation and Learning of Sub￾modular Functions Using Low-rank Decision Trees”.
In: Proceedings of the 26th Annual Conference on
Learning Theory. Ed. by S. Shalev-Shwartz and I.
Steinwart. Vol. 30. Proceedings of Machine Learning
Research. Princeton, NJ, USA: PMLR, 2013, pp. 711–
740.
[FKV14] V. Feldman, P. Kothari, and J. Vondrák.
“Nearly tight bounds on l1 approximation of self￾bounding functions”. In: CoRR, abs/1404.4702 1
(2014).
[FKV17] V. Feldman, P. Kothari, and J. Vondrák.
“Tight Bounds on ℓ1 Approximation and Learning of
Self-Bounding Functions”. In: International Confer￾ence on Algorithmic Learning Theory. PMLR. 2017,
pp. 540–559.
[FKV20] V. Feldman, P. Kothari, and J. Vondrák.
“Tight bounds on ℓ1 approximation and learning of
self-bounding functions”. In: Theoretical Computer
Science 808 (2020), pp. 86–98.
[FL07] P. Fearnhead and Z. Liu. “Online Inference for
Multiple Changepoint Problems”. In: J. of Royal Stat.
Soc. Series B 69 (2007), pp. 589–605.
[FL11] P. Fearnhead and Z. Liu. “Efficient Bayesian
analysis of multiple changepoint models with depen￾dence across segments”. In: Statistics and Computing
21.2 (2011), pp. 217–229.
[FL+18] V. François-Lavet, P. Henderson, R. Islam,
M. G. Bellemare, and J. Pineau. “An Introduction to
Deep Reinforcement Learning”. In: Foundations and
Trends in Machine Learning 11.3 (2018).
[FLA16] C. Finn, S. Levine, and P. Abbeel. “Guided
Cost Learning: Deep Inverse Optimal Control via Pol￾icy Optimization”. In: ICML. 2016, pp. 49–58.
[Fla+16] S. Flaxman, D. Sejdinovic, J. P. Cunningham,
and S. Filippi. “Bayesian Learning of Kernel Embed￾dings”. In: UAI. 2016.
[FLL18] J. Fu, K. Luo, and S. Levine. “Learning Ro￾bust Rewards with Adverserial Inverse Reinforcement
Learning”. In: ICLR. 2018.
[FLL19] Y. Feng, L. Li, and Q. Liu. “A Kernel Loss
for Solving the Bellman Equation”. In: NeurIPS. 2019,
pp. 15430–15441.
[FLMM21] D. T. Frazier, R. Loaiza-Maya, and G. M.
Martin. “Variational Bayes in State Space Models: In￾ferential and Predictive Accuracy”. In: (June 2021).
arXiv: 2106.12262 [stat.ME].
[FMM18] M. Figurnov, S. Mohamed, and A. Mnih. “Im￾plicit Reparameterization Gradients”. In: NIPS. 2018.
[FMP19] S. Fujimoto, D. Meger, and D. Precup. “Off￾Policy Deep Reinforcement Learning without Explo￾ration”. In: ICML. 2019, pp. 2052–2062.
[FNG00] N. de Freitas, M. Niranjan, and A. Gee. “Hier￾archical Bayesian models for regularisation in sequen￾tial learning”. In: Neural Computation 12.4 (2000),
pp. 955–993.
[FNW78] M. Fisher, G. Nemhauser, and L. Wolsey.
“An analysis of approximations for maximizing sub￾modular set functions—II”. In: Polyhedral combina￾torics (1978), pp. 73–87.
[FO20] F. Farnia and A. Ozdaglar. “Do GANs always
have Nash equilibria?” In: Proceedings of the 37th In￾ternational Conference on Machine Learning. Ed. by
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1262
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
H. D. III and A. Singh. Vol. 119. Proceedings of Ma￾chine Learning Research. PMLR, 2020, pp. 3029–3039.
[Fon+21] D. Fontanel, F. Cermelli, M. Mancini, and B.
Caputo. “On the Challenges of Open World Recogni￾tion under Shifting Visual Domains”. In: ICRA. 2021.
[For01] G. D. Forney. “Codes on graphs: normal real￾izations”. In: IEEE Trans. Inf. Theory 47.2 (2001),
pp. 520–548.
[For+18a] V. Fortuin, G. Dresdner, H. Strathmann,
and G. Rätsch. “Scalable Gaussian Processes on
Discrete Domains”. In: (2018). arXiv: 1810 . 10368
[stat.ML].
[For+18b] M. Fortunato et al. “Noisy Networks for Ex￾ploration”. In: ICLR. 2018.
[For+19] N. Ford, J. Gilmer, N. Carlini, and D. Cubuk.
“Adversarial Examples Are a Natural Consequence of
Test Error in Noise”. In: (2019). arXiv: 1901 . 10513
[cs.LG].
[For22] V. Fortuin. “Priors in Bayesian Deep Learning:
A Review”. In: Intl. Statisical Review (2022). arXiv:
2105.06868 [stat.ML].
[For+95] J. Forbes, T. Huang, K. Kanazawa, and S.
Russell. “The BATmobile: Towards a Bayesian Auto￾mated Taxi”. In: IJCAI. 1995.
[Fot+14] N. Foti, J. Xu, D. Laird, and E. Fox. “Stochas￾tic variational inference for hidden Markov models”. In:
NIPS. 2014, pp. 3599–3607.
[Fox+08] E. Fox, E. Sudderth, M. Jordan, and A. Will￾sky. “An HDP-HMM for Systems with State Persis￾tence”. In: ICML. 2008.
[Fox09] E. B. Fox. “Bayesian nonparametric learning
of complex dynamical phenomena”. PhD thesis. Mas￾sachusetts Institute of Technology, 2009.
[FP08] N Friel and A. N. Pettitt. “Marginal Likelihood
Estimation via Power Posteriors”. In: J. of Royal Stat.
Soc. Series B 70.3 (2008), pp. 589–607.
[FP69] D. C. Fraser and J. E. Potter. “The optimum
linear smoother as a combination of two optimum lin￾ear filters”. In: IEEE Trans. on Automatical Control
(1969), pp. 387–390.
[FPD09] P. Frazier, W. Powell, and S. Dayanik. “The
knowledge-gradient policy for correlated normal be￾liefs”. In: INFORMS J. on Computing 21.4 (2009),
pp. 599–613.
[Fra08] A. Fraser. Hidden Markov Models and Dynam￾ical Systems. SIAM Press, 2008.
[Fra+16] M. Fraccaro, S. K. Sønderby, U. Paquet, and
O. Winther. “Sequential Neural Models with Stochas￾tic Layers”. In: NIPS. 2016.
[Fra18] P. I. Frazier. “Bayesian Optimization”. In: Re￾cent Advances in Optimization and Modeling of Con￾temporary Problems. INFORMS TutORials in Opera￾tions Research. INFORMS, 2018, pp. 255–278.
[Fre14] A. A. Freitas. “Comprehensible classification
models: a position paper”. In: ACM SIGKDD explo￾rations newsletter 15.1 (2014), pp. 1–10.
[Fre+22] M. Freitag, D. Grangier, Q. Tan, and B.
Liang. “High Quality Rather than High Model Prob￾ability: Minimum Bayes Risk Decoding with Neural
Metrics”. In: TACL. 2022.
[Fre98] B. Frey. Graphical Models for Machine Learn￾ing and Digital Communication. MIT Press, 1998.
[Fre99] R. M. French. “Catastrophic forgetting in con￾nectionist networks”. In: Trends in Cognitive Science
(1999).
[Fri09] K. Friston. “The free-energy principle: a rough
guide to the brain?” en. In: Trends Cogn. Sci. 13.7
(2009), pp. 293–301.
[Fro+13] A. Frome, G. Corrado, J. Shlens, S. Bengio,
J. Dean, M. Ranzato, and T. Mikolov. “Devise: A deep
visual-semantic embedding model”. In: (2013).
[Fro+21] R. Frostig, M. Johnson, D. Maclaurin, A.
Paszke, and A. Radul. “Decomposing reverse-mode au￾tomatic differentiation”. In: LAFI workshop at POPL
2021. 2021.
[FS07] S. Fruhwirth-Schnatter. Finite Mixture and
Markov Switching Models. Springer, 2007.
[FSF10] S. Fruhwirth-Schnatter and R. Fruhwirth.
“Data Augmentation and MCMC for Binary and
Multinomial Logit Models”. In: Statistical Modelling
and Regression Structures. Ed. by T. Kneib and G.
Tutz. Springer, 2010, pp. 111–132.
[FST98] S. Fine, Y. Singer, and N. Tishby. “The Hier￾archical Hidden Markov Model: Analysis and Applica￾tions”. In: Machine Learning 32 (1998), p. 41.
[FT05] M. Fashing and C. Tomasi. “Mean shift is a
bound optimization”. en. In: IEEE Trans. Pattern
Anal. Mach. Intell. 27.3 (2005), pp. 471–474.
[FT19] A. Finke and A. H. Thiery. “On the relation￾ship between variational inference and adaptive im￾portance sampling”. In: (July 2019). arXiv: 1907.10477
[stat.ML].
[FT74] J. H. Friedman and J. W. Tukey. “A Projection
Pursuit Algorithm for Exploratory Data Analysis”. In:
IEEE Trans. Comput. C-23.9 (1974), pp. 881–890.
[Fu15] M. Fu, ed. Handbook of Simulation Optimiza￾tion. 1st ed. Springer-Verlag New York, 2015.
[Fu+17] Z. Fu, X. Tan, N. Peng, D. Zhao, and R. Yan.
“Style transfer in text: Exploration and evaluation”. In:
arXiv preprint arXiv:1711.06861 (2017).
[Fu+19] H. Fu, C. Li, X. Liu, J. Gao, A. Celikyilmaz,
and L. Carin. “Cyclical Annealing Schedule: A Simple
Approach to Mitigating KL Vanishing”. In: NAACL.
2019.
[Fu+20] J. Fu, A. Kumar, O. Nachum, G. Tucker, and
S. Levine. D4RL: Datasets for Deep Data-Driven Re￾inforcement Learning. arXiv:2004.07219. 2020.
[Fuj05] S. Fujishige. Submodular functions and opti￾mization. Vol. 58. Elsevier Science, 2005.
[Ful+20] I. R. Fulcher, I. Shpitser, S. Marealle, and
E. J. Tchetgen Tchetgen. “Robust inference on popula￾tion indirect causal effects: the generalized front door
criterion”. In: Journal of the Royal Statistical Soci￾ety: Series B (Statistical Methodology) 82.1 (2020),
pp. 199–214. eprint: https://rss.onlinelibrary.wiley.
com/doi/pdf/10.1111/rssb.12345.
[FV15] V. Feldman and J. Vondrák. “Tight Bounds
on Low-Degree Spectral Concentration of Submodu￾lar and XOS Functions”. In: 2015 IEEE 56th An￾nual Symposium on Foundations of Computer Sci￾ence. 2015, pp. 923–942.
[FV16] V. Feldman and J. Vondrák. “Optimal bounds
on approximation of submodular and XOS functions
by juntas”. In: SIAM Journal on Computing 45.3
(2016), pp. 1129–1170.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[FV17] R. C. Fong and A. Vedaldi. “Interpretable ex￾planations of black boxes by meaningful perturbation”.
In: Proceedings of the IEEE international conference
on computer vision. 2017, pp. 3429–3437.
[FW12] N. Friel and J. Wyse. “Estimating the evidence
– a review”. In: Stat. Neerl. 66.3 (2012), pp. 288–308.
[FW21] R. Friedman and Y. Weiss. “Posterior Sam￾pling for Image Restoration using Explicit Patch Pri￾ors”. In: (2021). arXiv: 2104.09895 [cs.CV].
[FWW21] M. Finzi, M. Welling, and A. G. Wilson. “A
Practical Method for Constructing Equivariant Mul￾tilayer Perceptrons for Arbitrary Matrix Groups”. In:
ICML. 2021.
[Gaj+19] A. Gajewski, J. Clune, K. O. Stanley, and J.
Lehman. “Evolvability ES: Scalable and Direct Opti￾mization of Evolvability”. In: Proc. of the Conf. on
Genetic and Evolutionary Computation. 2019.
[Gan07] M Ganapathiraju. “Application of language
technologies in biology: Feature extraction and model￾ing for transmembrane helix prediction”. en. PhD the￾sis. 2007.
[Gan+16a] Y Ganin, E Ustinova, H Ajakan, P Ger￾main, and others. “Domain-adversarial training of neu￾ral networks”. In: JMLR (2016).
[Gan+16b] Y. Ganin, E. Ustinova, H. Ajakan, P. Ger￾main, H. Larochelle, F. Laviolette, M. Marchand, and
V. Lempitsky. “Domain-adversarial training of neural
networks”. In: The journal of machine learning re￾search 17.1 (2016), pp. 2096–2030.
[Gan+23] A. Gane et al. “ProtNLM: Model-based Nat￾ural Language Protein Annotation”. In: (2023).
[Gao+18] R. Gao, J. Xie, S.-C. Zhu, and Y. N. Wu.
“Learning Grid-like Units with Vector Representa￾tion of Self-Position and Matrix Representation of
Self-Motion”. In: arXiv preprint arXiv:1810.05597
(2018).
[Gao+20] R. Gao, E. Nijkamp, D. P. Kingma, Z. Xu,
A. M. Dai, and Y. N. Wu. “Flow contrastive esti￾mation of energy-based models”. In: Proceedings of
the IEEE/CVF Conference on Computer Vision and
Pattern Recognition. 2020, pp. 7518–7528.
[Gao+21] R. Gao, Y. Song, B. Poole, Y. N. Wu, and
D. P. Kingma. “Learning Energy-Based Models by Dif￾fusion Recovery Likelihood”. In: ICLR. 2021.
[Gär03] T. Gärtner. “A Survey of Kernels for Struc￾tured Data”. In: SIGKDD Explor. Newsl. 5.1 (2003),
pp. 49–58.
[GAR16] R. B. Grosse, S. Ancha, and D. M. Roy. “Mea￾suring the reliability of MCMC inference with bidirec￾tional Monte Carlo”. In: NIPS. 2016.
[Gar+18a] J. Gardner, G. Pleiss, K. Q. Weinberger,
D. Bindel, and A. G. Wilson. “GPyTorch: Blackbox
Matrix-Matrix Gaussian Process Inference with GPU
Acceleration”. In: NIPS. Ed. by S Bengio, H Wallach,
H Larochelle, K Grauman, N Cesa-Bianchi, and R Gar￾nett. Curran Associates, Inc., 2018, pp. 7576–7586.
[Gar+18b] J. R. Gardner, G. Pleiss, R. Wu, K. Q. Wein￾berger, and A. G. Wilson. “Product Kernel Interpola￾tion for Scalable Gaussian Processes”. In: AISTATS.
2018.
[Gar+18c] T. Garipov, P. Izmailov, D. Podoprikhin, D.
Vetrov, and A. G. Wilson. “Loss Surfaces, Mode Con￾nectivity, and Fast Ensembling of DNNs”. In: NIPS.
2018.
[Gar+18d] M. Garnelo, D. Rosenbaum, C. Maddison,
T. Ramalho, D. Saxton, M. Shanahan, Y. W. Teh, D.
Rezende, and S. M. A. Eslami. “Conditional Neural
Processes”. In: ICML. Ed. by J. Dy and A. Krause.
Vol. 80. Proceedings of Machine Learning Research.
PMLR, 2018, pp. 1704–1713.
[Gar+18e] M. Garnelo, J. Schwarz, D. Rosenbaum, F.
Viola, D. J. Rezende, S. M. Ali Eslami, and Y. W. Teh.
“Neural Processes”. In: ICML workshop on Theoret￾ical Foundations and Applications of Deep Genera￾tive Models. 2018.
[Gar+19] S. Garg, V. Perot, N. Limtiaco, A. Taly, E. H.
Chi, and A. Beutel. “Counterfactual Fairness in Text
Classification through Robustness”. In: Proceedings of
the 2019 AAAI/ACM Conference on AI, Ethics, and
Society. AIES ’19. Association for Computing Machin￾ery, 2019, 219–226.
[Gar+20] S. Garg, Y. Wu, S. Balakrishnan, and Z. C.
Lipton. “A unified view of label shift estimation”. In:
NIPS. Mar. 2020.
[Gar23] R. Garnett. Bayesian Optimization. Cam￾bridge University Press, 2023.
[GARD18] G. Gur-Ari, D. A. Roberts, and E. Dyer.
“Gradient Descent Happens in a Tiny Subspace”. In:
(2018). arXiv: 1812.04754 [cs.LG].
[Gas+19] J. Gasthaus, K. Benidis, Y. Wang, S. S.
Rangapuram, D. Salinas, V. Flunkert, and T.
Januschowski. “Probabilistic Forecasting with Spline
Quantile Function RNNs”. In: ICML. Vol. 89. Pro￾ceedings of Machine Learning Research. PMLR, 2019,
pp. 1901–1910.
[GAZ19] A. Ghorbani, A. Abid, and J. Zou. “Interpre￾tation of neural networks is fragile”. In: Proceedings
of the AAAI Conference on Artificial Intelligence.
Vol. 33. 01. 2019, pp. 3681–3688.
[GB00] Z. Ghahramani and M. Beal. “Variational in￾ference for Bayesian mixtures of factor analysers”. In:
NIPS-12. 2000.
[GB09] A. Guillory and J. Bilmes. “Label Selection on
Graphs”. In: NIPS. Vancouver, Canada, 2009.
[GB10] X. Glorot and Y. Bengio. “Understanding the
difficulty of training deep feedforward neural net￾works”. In: AISTATS. 2010, pp. 249–256.
[GB11] A. Guillory and J. Bilmes. “Active Semi￾Supervised Learning using Submodular Functions”. In:
UAI. Barcelona, Spain: AUAI, 2011.
[GB+18] R. Gómez-Bombarelli, J. N. Wei, D. Duve￾naud, J. M. Hernández-Lobato, B. Sánchez-Lengeling,
D. Sheberla, J. Aguilera-Iparraguirre, T. D. Hirzel,
R. P. Adams, and A. Aspuru-Guzik. “Automatic
Chemical Design Using a Data-Driven Continuous
Representation of Molecules”. en. In: American Chem￾ical Society Central Science 4.2 (2018), pp. 268–276.
[GBB11] X. Glorot, A. Bordes, and Y. Bengio. “Deep
Sparse Rectifer Neural Networks”. In: AISTATS. 2011.
[GBC16] I. Goodfellow, Y. Bengio, and A. Courville.
Deep Learning. http : / / www . deeplearningbook . org.
MIT Press, 2016.
[GBGM23] R. Gozalo-Brizuela and E. C. Garrido￾Merchan. “ChatGPT is not all you need. A State of
the Art Review of large Generative AI models”. In:
(Jan. 2023). arXiv: 2301.04655 [cs.LG].
[GBJ18] R. Giordano, T. Broderick, and M. I. Jordan.
“Covariances, Robustness, and Variational Bayes”. In:
JMLR 19.51 (2018), pp. 1–49.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1264
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[GBP18] C. Gurau, A. Bewley, and I. Posner. “Dropout
Distillation for Efficiently Estimating Model Confi￾dence”. 2018.
[GC11] M. Girolami and B. Calderhead. “Riemann
manifold Langevin and Hamiltonian Monte Carlo
methods”. In: J. of Royal Stat. Soc. Series B 73.2
(2011), pp. 123–214.
[GC90] R. P. Goldman and E. Charniak. “Dynamic
Construction of Belief Networks”. In: UAI. 1990.
[GCW19] M. Gerber, N. Chopin, and N. Whiteley.
“Negative association, ordering and convergence of
resampling methods”. In: Ann. Stat. 47.4 (2019),
pp. 2236–2260.
[GD20] T. Geffner and J. Domke. “A Rule for Gradi￾ent Estimator Selection, with an Application to Vari￾ational Inference”. In: AISTATS. Ed. by S. Chiappa
and R. Calandra. Vol. 108. Proceedings of Machine
Learning Research. PMLR, 2020, pp. 1803–1812.
[GDFY16] S. Ghosh, F. M. Delle Fave, and J. Yedidia.
“Assumed Density Filtering Methods for Learning
Bayesian Neural Networks”. In: AAAI. 2016.
[Geb+21] T. Gebru, J. Morgenstern, B. Vecchione,
J. W. Vaughan, H. Wallach, H. D. Iii, and K. Craw￾ford. “Datasheets for datasets”. In: Communications
of the ACM 64.12 (2021), pp. 86–92.
[Ged+20] D. Gedon, N. Wahlström, T. B. Schön, and
L. Ljung. “Deep State Space Models for Nonlinear Sys￾tem Identification”. In: (Mar. 2020). arXiv: 2003.14162
[eess.SY].
[Gei+20a] R. Geirhos, J.-H. Jacobsen, C. Michaelis, R.
Zemel, W. Brendel, M. Bethge, and F. A. Wichmann.
“Shortcut Learning in Deep Neural Networks”. In: Na￾ture Machine Intelligence (2020).
[Gei+20b] R. Geirhos, J. Jacobsen, C. Michaelis, R. S.
Zemel, W. Brendel, M. Bethge, and F. A. Wichmann.
“Shortcut Learning in Deep Neural Networks”. In:
CoRR abs/2004.07780 (2020). arXiv: 2004.07780.
[Gel+04] A. Gelman, J. Carlin, H. Stern, and D. Ru￾bin. Bayesian data analysis. 2nd edition. Chapman
and Hall, 2004.
[Gel06] A. Gelman. “Prior distributions for variance pa￾rameters in hierarchical models (comment on article
by Browne and Draper)”. en. In: Bayesian Anal. 1.3
(2006), pp. 515–534.
[Gel+08] A. Gelman, A. Jakulin, M. G. Pittau, and
Y.-S. Su. “A weakly informative default prior distribu￾tion for logistic and other regression models”. en. In:
The Annals of Applied Statistics 2.4 (2008), pp. 1360–
1383.
[Gel+14a] A. Gelman, J. B. Carlin, H. S. Stern, D. B.
Dunson, A. Vehtari, and D. B. Rubin. Bayesian Data
Analysis, Third Edition. Third edition. Chapman and
Hall/CRC, 2014.
[Gel+14b] A. Gelman, A. Vehtari, P. Jylänki, C.
Robert, N. Chopin, and J. P. Cunningham. “Expec￾tation propagation as a way of life”. In: (2014). arXiv:
1412.4869 [stat.CO].
[Gel16] A. Gelman. “The problems with p-values are
not just with p-values”. In: American Statistician
(2016).
[Gel+20] A. Gelman, A. Vehtari, D. Simpson, C. C.
Margossian, B. Carpenter, Y. Yao, L. Kennedy, J.
Gabry, P.-C. Bürkner, and M. Modrák. “Bayesian
Workflow”. In: (2020). arXiv: 2011.01808 [stat.ME].
[Gel+22] A. Gelman, J. Hill, B. Goodrich, J. Gabry,
D. Simpson, and A. Vehtari. Applied Regression and
Multilevel Models. To appear. 2022.
[Gel90] M. Gelbrich. “On a formula for the L2 Wasser￾stein metric between measures on Euclidean and
Hilbert spaces”. In: Mathematische Nachrichten 147.1
(1990), pp. 185–203.
[Gen+19] A. Genevay, L. Chizat, F. Bach, M. Cuturi,
and G. Peyré. “Sample complexity of sinkhorn diver￾gences”. In: The 22nd International Conference on
Artificial Intelligence and Statistics. PMLR. 2019,
pp. 1574–1583.
[Geo+17] D. George et al. “A generative vision model
that trains with high data efficiency and breaks
text-based CAPTCHAs”. In: Science 358.6368 (2017),
eaag2612. eprint: https://www.science.org/doi/pdf/
10.1126/science.aag2612.
[Geo+18] T. George, C. Laurent, X. Bouthillier, N. Bal￾las, and P. Vincent. “Fast Approximate Natural Gra￾dient Descent in a Kronecker Factored Eigenbasis”. In:
NIPS. Curran Associates, Inc., 2018, pp. 9550–9560.
[Geo88] H.-O. Georgii. Gibbs Measures and Phase
Transitions. en. Walter De Gruyter Inc, 1988.
[Ger+15] M. Germain, K. Gregor, I. Murray, and H.
Larochelle. “MADE: Masked Autoencoder for Distri￾bution Estimation”. In: ICML. Ed. by F. Bach and
D. Blei. Vol. 37. Proceedings of Machine Learning Re￾search. PMLR, 2015, pp. 881–889.
[Gér19] A. Géron. Hands-On Machine Learning with
Scikit-Learn and TensorFlow: Concepts, Tools, and
Techniques for Building Intelligent Systems (2nd edi￾tion). en. O’Reilly Media, Incorporated, 2019.
[Ger19] S. J. Gershman. “What does the free energy
principle tell us about the brain?” In: Neurons, Be￾havior, Data Analysis, and Theory (2019).
[GEY19] Y. Geifman and R. El-Yaniv. “SelectiveNet: A
Deep Neural Network with an Integrated Reject Op￾tion”. In: ICML. 2019.
[Gey92] C. Geyer. “Practical Markov chain Monte
Carlo”. In: Statistical Science 7 (1992), pp. 473–483.
[GF00] E. George and D. Foster. “Calibration and em￾pirical Bayes variable selection”. In: Biometrika 87.4
(2000), pp. 731–747.
[GF09] I. E. Givoni and B. J. Frey. “A Binary Variable
Model for Affinity Propagation”. In: Neural Computa￾tion 21.6 (2009), pp. 1589–1600.
[GF+15] Á. F. García-Fernández, L. Svensson, M. R.
Morelande, and S. Särkkä. “Posterior Linearization
Filter: Principles and Implementation Using Sigma
Points”. In: IEEE Trans. Signal Process. 63.20 (Oct.
2015), pp. 5561–5573.
[GF17] B. Goodman and S. Flaxman. “European
Union regulations on algorithmic decision-making and
a “right to explanation””. In: AI magazine 38.3 (2017),
pp. 50–57.
[GF21] A. Grim and P. Felzenszwalb. “Convex Com￾bination Belief Propagation Algorithms”. In: (May
2021). arXiv: 2105.12815 [cs.AI].
[GFSS17] Á. F. García-Fernández, L. Svensson, and S.
Särkkä. “Iterated Posterior Linearization Smoother”.
In: IEEE Trans. Automat. Contr. 62.4 (2017),
pp. 2056–2063.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[GFTS19] Á. F. García-Fernández, F. Tronarp, and S.
Särkkä. “Gaussian Process Classification Using Pos￾terior Linearization”. In: IEEE Signal Process. Lett.
26.5 (2019), pp. 735–739.
[GFWO20] T. Galy-Fajou, F. Wenzel, and M. Opper.
“Automated Augmented Conjugate Inference for Non￾conjugate Gaussian Process Models”. In: AISTATS.
2020.
[GG14] S. J. Gershman and N. D. Goodman. “Amor￾tized Inference in Probabilistic Reasoning”. In: 36th
Annual Conference of the Cognitive Science Society.
2014.
[GG16] Y. Gal and Z. Ghahramani. “Dropout as a
Bayesian Approximation: Representing Model Uncer￾tainty in Deep Learning”. In: ICML. 2016.
[GG84] S. Geman and D. Geman. “Stochastic Relax￾ation, Gibbs Distributions, and the Bayesian Restora￾tion of Images”. In: IEEE PAMI 6.6 (1984).
[GGG15] M. Gygli, H. Grabner, and L. Gool. “Video
summarization by learning submodular mixtures of ob￾jectives”. In: 2015 IEEE Conference on Computer
Vision and Pattern Recognition (CVPR) (2015),
pp. 3090–3098.
[GGS21] M. Grcic, I. Grubisic, and S. Segvic. “Dense￾Flow: Official implementation of Densely connected
normalizing flows”. en. In: NIPS. 2021.
[GH07] A. Gelman and J. Hill. Data analysis using
regression and multilevel/ hierarchical models. Cam￾bridge, 2007.
[GH10] M. Gutmann and A. Hyvärinen. “Noise￾contrastive estimation: A new estimation principle for
unnormalized statistical models”. In: Proceedings of
the Thirteenth International Conference on Artifi￾cial Intelligence and Statistics. 2010, pp. 297–304.
[GH12] M. Gutmann and J.-i. Hirayama. “Bregman di￾vergence as general framework to estimate unnormal￾ized statistical models”. In: arXiv:1202.3727 (2012).
[GH96a] Z. Ghahramani and G. Hinton. Parameter
estimation for linear dynamical systems. Tech. rep.
CRG-TR-96-2. Dept. Comp. Sci., Univ. Toronto, 1996.
[GH96b] Z. Ghahramani and G. Hinton. The EM Al￾gorithm for Mixtures of Factor Analyzers. Tech. rep.
Dept. of Comp. Sci., Uni. Toronto, 1996.
[GH98] Z. Ghahramani and G. Hinton. “Variational
learning for switching state-space models”. In: Neural
Computation 12.4 (1998), pp. 963–996.
[Gha+15] M. Ghavamzadeh, S. Mannor, J. Pineau, and
A. Tamar. “Bayesian Reinforcement Learning: A Sur￾vey”. In: Foundations and Trends in ML (2015).
[Gha+19] M. Ghazvininejad, O. Levy, Y. Liu, and L.
Zettlemoyer. “Mask-Predict: Parallel Decoding of Con￾ditional Masked Language Models”. In: EMNLP. Hong
Kong, China: Association for Computational Linguis￾tics, Nov. 2019, pp. 6112–6121.
[Gha+21] A. Ghandeharioun, B. Kim, C.-L. Li, B. Jou,
B. Eoff, and R. W. Picard. DISSECT: Disentangled
Simultaneous Explanations via Concept Traversals.
2021. arXiv: 2105.15164 [cs.LG].
[GHC20] C. Geng, S.-J. Huang, and S. Chen. “Recent
Advances in Open Set Recognition: A Survey”. In:
IEEE PAMI (2020).
[GHC21] S. Gould, R. Hartley, and D. J. Campbell.
“Deep Declarative Networks”. en. In: IEEE PAMI PP
(2021).
[GHK17] Y. Gal, J. Hron, and A. Kendall. “Concrete
Dropout”. In: (2017). arXiv: 1705.07832 [stat.ML].
[Gho+19] A. Ghorbani, J. Wexler, J. Zou, and B.
Kim. Towards Automatic Concept-based Explana￾tions. 2019. arXiv: 1902.03129 [stat.ML].
[Gho+21] A. Ghosh, A. Honoré, D. Liu, G. E. Henter,
and S. Chatterjee. “Normalizing Flow based Hidden
Markov Models for Classification of Speech Phones
with Explainability”. In: (July 2021). arXiv: 2107 .
00730 [cs.LG].
[GHV14] A. Gelman, J. Hwang, and A. Vehtari.
“Understanding predictive information criteria for
Bayesian models”. In: Statistics and Computing 24.6
(2014), pp. 997–1016.
[GHV20a] A. Gelman, J. Hill, and A. Vehtari. Regres￾sion and Other Stories. en. 1st ed. Cambridge Univer￾sity Press, 2020.
[GHV20b] A. Gelman, J. Hill, and A. Vehtari. Regres￾sion and Other Stories. Cambridge, 2020.
[Gib97] M. Gibbs. “Bayesian Gaussian Processes for
Regression and Classification”. PhD thesis. U. Cam￾bridge, 1997.
[GIG17] Y. Gal, R. Islam, and Z. Ghahramani. “Deep
bayesian active learning with image data”. In: Inter￾national Conference on Machine Learning. PMLR.
2017, pp. 1183–1192.
[Gil+18a] J. Gilmer, R. P. Adams, I. Goodfellow, D.
Andersen, and G. E. Dahl. “Motivating the rules of
the game for adversarial example research”. In: arXiv
preprint arXiv:1807.06732 (2018).
[Gil+18b] J. Gilmer, L. Metz, F. Faghri, S. S. Schoen￾holz, M. Raghu, M. Wattenberg, and I. Good￾fellow. “Adversarial spheres”. In: arXiv preprint
arXiv:1801.02774 (2018).
[Gil88] J. R. Gilbert. “Some nested dissection order is
nearly optimal”. In: Inf. Process. Lett. 26.6 (1988),
pp. 325–328.
[Gir+14] R. Girshick, J. Donahue, T. Darrell, and J.
Malik. “Rich feature hierarchies for accurate object
detection and semantic segmentation”. In: Proceedings
of the IEEE conference on computer vision and pat￾tern recognition. 2014, pp. 580–587.
[Gir+15] R. Girshick, F. Iandola, T. Darrell, and J. Ma￾lik. “Deformable Part Models are Convolutional Neu￾ral Networks”. In: CVPR. 2015.
[Gir+21] L. Girin, S. Leglaive, X. Bie, J. Diard, T. Hue￾ber, and X. Alameda-Pineda. “Dynamical Variational
Autoencoders: A Comprehensive Review”. In: Foun￾dations and Trends® in Machine Learning 15.1-2
(2021), pp. 1–175.
[Git89] J. Gittins. Multi-armed Bandit Allocation In￾dices. Wiley, 1989.
[GJ97] Z. Ghahramani and M. Jordan. “Factorial Hid￾den Markov Models”. In: Machine Learning 29 (1997),
pp. 245–273.
[GK19] L. Graesser and W. L. Keng. Foundations of
Deep Reinforcement Learning: Theory and Practice
in Python. en. 1 edition. Addison-Wesley Professional,
2019.
[GKS05] C. Guestrin, A. Krause, and A. P. Singh.
“Near-optimal sensor placements in gaussian pro￾cesses”. In: Proceedings of the 22nd international con￾ference on Machine learning. 2005, pp. 265–272.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1266
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[GL10] K. Gregor and Y. LeCun. “Learning fast ap￾proximations of sparse coding”. In: ICML. 2010,
pp. 399–406.
[GL97] F. Glover and M. Laguna. Tabu Search. Kluwer
Academic Publishers, 1997.
[Gla03] P. Glasserman. Monte Carlo Methods in Fi￾nancial Engineering. 1st ed. Stochastic Modelling and
Applied Probability. Springer-Verlag New York, 2003.
[Gle02] S. Glennan. “Rethinking mechanistic explana￾tion”. In: Philosophy of science 69.S3 (2002), S342–
S353.
[GLM15] J. Ghosh, Y. Li, and R. Mitra. “On the Use
of Cauchy Prior Distributions for Bayesian Logistic
Regression”. In: (2015). arXiv: 1507.07170 [stat.ME].
[GLP21] I. Gulrajani and D. Lopez-Paz. “In Search of
Lost Domain Generalization”. In: ICLR. 2021.
[GLS81] M. Grötschel, L. Lovász, and A. Schrijver.
“The ellipsoid method and its consequences in combi￾natorial optimization”. In: Combinatorica 1.2 (1981),
pp. 169–197.
[GM12] G. Gordon and J. McNulty. Matroids: a ge￾ometric introduction. Cambridge University Press,
2012.
[GM15] J. Gorham and L. Mackey. “Measuring sample
quality with Stein’s method”. In: Advances in Neural
Information Processing Systems. 2015, pp. 226–234.
[GM16] R. Grosse and J. Martens. “A Kronecker￾factored approximate Fisher matrix for convolution
layers”. In: ICML. 2016.
[GM17] P. L. Green and S Maskell. “Estimating the
parameters of dynamical systems from Big Data us￾ing Sequential Monte Carlo samplers”. In: Mech. Syst.
Signal Process. 93 (2017), pp. 379–396.
[GM98] A. Gelman and X.-L. Meng. “Simulating nor￾malizing constants: from importance sampling to
bridge sampling to path sampling”. In: Statisical Sci￾ence 13 (1998), pp. 163–185.
[GMAR16] Y. Gal, R. T. Mc Allister, and C. E. Ras￾mussen. “Improving PILCO with Bayesian Neural Net￾work Dynamics Models”. In: ICML workshop on Data￾efficient machine learning. 2016.
[GMH20] M. Gorinova, D. Moore, and M. Hoffman.
“Automatic Reparameterisation of Probabilistic Pro￾grams”. In: ICML. Vol. 119. Proceedings of Machine
Learning Research. PMLR, 2020, pp. 3648–3657.
[GNM19] D. Greenberg, M. Nonnenmacher, and J.
Macke. “Automatic Posterior Transformation for
Likelihood-Free Inference”. In: ICML. 2019.
[Goe+09] M. X. Goemans, N. J. Harvey, S. Iwata, and
V. Mirrokni. “Approximating submodular functions
everywhere”. In: Proceedings of the twentieth an￾nual ACM-SIAM symposium on Discrete algorithms.
SIAM. 2009, pp. 535–544.
[Gol+04] J. Goldberger, S. T. Roweis, G. E. Hinton,
and R. Salakhutdinov. “Neighbourhood Components
Analysis”. In: NIPS. 2004.
[Gol+17] N. Gold, M. G. Frasch, C. Herry, B. S.
Richardson, and X. Wang. “A Doubly Stochastic
Change Point Detection Algorithm for Noisy Biologi￾cal Signals”. en. In: Front. Physiol. (2017), p. 106088.
[Gol17] Y. Goldberg. Neural Network Methods for
Natural Language Processing. Morgan & Claypool
Publishers, 2017.
[Gol+19] Z. Goldfeld, E. van den Berg, K. H. Gree￾newald, I. Melnyk, N. Nguyen, B. Kingsbury, and
Y. Polyanskiy. “Estimating Information Flow in Deep
Neural Networks”. In: ICML. 2019.
[Gol89] D. E. Goldberg. Genetic Algorithms in Search,
Optimization and Machine Learning. 1st. Addison￾Wesley Longman Publishing Co., Inc., 1989.
[Gom+17] A. N. Gomez, M. Ren, R. Urtasun, and R. B.
Grosse. “The Reversible Residual Network: Backprop￾agation Without Storing Activations”. In: NIPS. 2017.
[Gon+11] J. Gonzalez, Y. Low, A. Gretton, and C.
Guestrin. “Parallel gibbs sampling: From colored fields
to thin junction trees”. In: AISTATS. 2011, pp. 324–
332.
[Gon+14] B. Gong, W.-L. Chao, K. Grauman, and F.
Sha. “Diverse sequential subset selection for super￾vised video summarization”. In: Advances in neural
information processing systems 27 (2014), pp. 2069–
2077.
[Gon+20] P. J. Goncalves et al. “Training deep neural
density estimators to identify mechanistic models of
neural dynamics”. In: Elife 9 (2020).
[Goo+14] I. J. Goodfellow, J. Pouget-Abadie, M.
Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville,
and Y. Bengio. “Generative Adversarial Networks”. In:
NIPS. 2014.
[Goo16] I. Goodfellow. “NIPS 2016 Tutorial: Genera￾tive Adversarial Networks”. In: NIPS Tutorial. 2016.
[Goo85] I. Good. “Weight of evidence: A brief survey”.
In: Bayesian statistics 2 (1985), pp. 249–270.
[Gor+14] A. D. Gordon, T. A. Henzinger, A. V. Nori,
and S. K. Rajamani. “Probabilistic programming”. In:
Intl. Conf. on Software Engineering. 2014.
[Gor+19] J. Gordon, J. Bronskill, M. Bauer, S.
Nowozin, and R. E. Turner. “Meta-Learning Proba￾bilistic Inference For Prediction”. In: ICLR. 2019.
[Gor93] N. Gordon. “Novel Approach to
Nonlinear/Non-Gaussian Bayesian State Estimation”.
In: IEE Proceedings (F) 140.2 (1993), pp. 107–113.
[Gor95] G. J. Gordon. “Stable Function Approximation
in Dynamic Programming”. In: ICML. 1995, pp. 261–
268.
[Gou+96] C. Gourieroux, M. Gourieroux, A. Monfort,
and D. A. Monfort. Simulation-based econometric
methods. Oxford university press, 1996.
[Goy+19] Y. Goyal, Z. Wu, J. Ernst, D. Batra, D.
Parikh, and S. Lee. Counterfactual Visual Explana￾tions. 2019. arXiv: 1904.07451 [cs.LG].
[Goy+22] S. Goyal, M. Sun, A. Raghunathan, and Z.
Kolter. “Test-Time Adaptation via Conjugate Pseudo￾labels”. In: (July 2022). arXiv: 2207.09640 [cs.LG].
[GPS89] D. Greig, B. Porteous, and A. Seheult. “Ex￾act maximum a posteriori estimation for binary im￾ages”. In: J. of Royal Stat. Soc. Series B 51.2 (1989),
pp. 271–279.
[GR06a] M Girolami and S Rogers. “Variational
Bayesian Multinomial Probit Regression with Gaus￾sian Process Priors”. In: Neural Comput. 18.8 (2006),
pp. 1790–1817.
[GR06b] M. Girolami and S. Rogers. “Variational
Bayesian multinomial probit regression with Gaussian
process priors”. In: Neural Comptuation 18.8 (2006),
pp. 1790 –1817.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[GR07a] T. Gneiting and A. E. Raftery. “Strictly
Proper Scoring Rules, Prediction, and Estimation”. In:
JASA 102.477 (2007), pp. 359–378.
[GR07b] T. Gneiting and A. E. Raftery. “Strictly
proper scoring rules, prediction, and estimation”.
In: Journal of the American statistical Association
102.477 (2007), pp. 359–378.
[Gra+10] T. Graepel, J. Quinonero-Candela, T.
Borchert, and R. Herbrich. “Web-Scale Bayesian Click￾Through Rate Prediction for Sponsored Search Adver￾tising in Microsoft’s Bing Search Engine”. In: ICML.
2010.
[Gra11] A. Graves. “Practical Variational Inference for
Neural Networks”. In: NIPS. 2011.
[Gra+19] W. Grathwohl, R. T. Q. Chen, J. Betten￾court, I. Sutskever, and D. Duvenaud. “FFJORD: Free￾form Continuous Dynamics for Scalable Reversible
Generative Models”. In: (2019).
[Gra+20a] W. Grathwohl, J. Kelly, M. Hashemi, M.
Norouzi, K. Swersky, and D. Duvenaud. “No MCMC
for me: Amortized sampling for fast and stable
training of energy-based models”. In: arXiv preprint
arXiv:2010.04230 (2020).
[Gra+20b] W. Grathwohl, K.-C. Wang, J.-H. Jacobsen,
D. Duvenaud, M. Norouzi, and K. Swersky. “Your clas￾sifier is secretly an energy based model and you should
treat it like one”. In: ICLR. 2020.
[Gra+20c] W. Grathwohl, K.-C. Wang, J.-H. Jacob￾sen, D. Duvenaud, and R. Zemel. “Cutting out
the Middle-Man: Training and Evaluating Energy￾Based Models without Sampling”. In: arXiv preprint
arXiv:2002.05616 (2020).
[Gre03] P. Green. “Tutorial on trans-dimensional
MCMC”. In: Highly Structured Stochastic Systems.
Ed. by P. Green, N. Hjort, and S. Richardson. OUP,
2003.
[Gre+12] A. Gretton, K. M. Borgwardt, M. J. Rasch,
B. Schölkopf, and A. Smola. “A Kernel Two-Sample
Test”. In: JMLR 13.Mar (2012), pp. 723–773.
[Gre+14] K. Gregor, I. Danihelka, A. Mnih, C. Blun￾dell, and D. Wierstra. “Deep AutoRegressive Net￾works”. In: ICML. 2014.
[Gre20] F. Greenlee. Transformer VAE. 2020.
[Gre+22] P. L. Green, R. E. Moore, R. J. Jackson, J.
Li, and S. Maskell. “Increasing the efficiency of Se￾quential Monte Carlo samplers through the use of ap￾proximately optimal L-kernels”. In: Mech. Syst. Sig￾nal Process. 162 (2022).
[Gre98] P. Green. “Reversible Jump Markov Chain
Monte Carlo computation and Bayesian model deter￾mination”. In: Biometrika 82 (1998), pp. 711–732.
[Gri+04] T. Griffiths, M. Steyvers, D. Blei, and J.
Tenenbaum. “Integrating Topics and Syntax”. In:
NIPS. 2004.
[Gri+20] J.-B. Grill, F. Strub, F. Altché, C. Tallec,
P. H. Richemond, E. Buchatskaya, C. Doersch, B. A.
Pires, Z. D. Guo, M. G. Azar, et al. “Bootstrap your
own latent: A new approach to self-supervised learn￾ing”. In: arXiv preprint arXiv:2006.07733 (2020).
[GRS96] W. Gilks, S. Richardson, and D. Spiegelhalter.
Markov Chain Monte Carlo in Practice. Chapman
and Hall, 1996.
[GS04] T. Griffiths and M. Steyvers. “Finding scientific
topics”. In: PNAS 101 (2004), pp. 5228–5235.
[GS08] Y Guo and D Schuurmans. “Efficient global op￾timization for exponential family PCA and low-rank
matrix factorization”. In: 2008 46th Annual Allerton
Conference on Communication, Control, and Com￾puting. 2008, pp. 1100–1107.
[GS13] A. Gelman and C. R. Shalizi. “Philosophy and
the practice of Bayesian statistics”. en. In: Br. J.
Math. Stat. Psychol. 66.1 (Feb. 2013), pp. 8–38.
[GS15] R. B. Grosse and R. Salakhutdinov. “Scaling Up
Natural Gradient by Sparsely Factorizing the Inverse
Fisher Matrix”. In: ICML. 2015.
[GS90] A. Gelfand and A. Smith. “Sampling-based ap￾proaches to calculating marginal densities”. In: JASA
85 (1990), pp. 385–409.
[GS92] G. Grimmett and D. Stirzaker. Probability and
Random Processes. Oxford, 1992.
[GS97] C. M. Grinstead and J. L. Snell. Introduction
to probability (2nd edition). American Mathematical
Society, 1997.
[GSA14] M. A. Gelbart, J. Snoek, and R. P. Adams.
“Bayesian Optimization with Unknown Constraints”.
In: UAI. 2014.
[GSD13] A. Guez, D. Silver, and P. Dayan. “Scalable
and Efficient Bayes-Adaptive Reinforcement Learning
Based on Monte-Carlo Tree Search”. In: JAIR 48
(2013), pp. 841–883.
[GSJ19] A. Gretton, D. Sutherland, and W. Jitkrittum.
NIPS tutorial on interpretable comparison of distri￾butions and models. 2019.
[GSK18] S. Gidaris, P. Singh, and N. Komodakis.
“Unsupervised Representation Learning by Predicting
Image Rotations”. In: International Conference on
Learning Representations. 2018.
[GSM18] U. Garciarena, R. Santana, and A.
Mendiburu. “Expanding Variational Autoencoders for
Learning and Exploiting Latent Representations in
Search Distributions”. In: Proc. of the Conf. on Ge￾netic and Evolutionary Computation. 2018, pp. 849–
856.
[GSR12] S. Garg, A. Singh, and F. Ramos. “Learning
non-stationary Space-Time models for environmental
monitoring”. In: AAAI 26.1 (2012), pp. 288–294.
[GSR13] J. Gama, R. Sebastião, and P. P. Rodrigues.
“On evaluating stream learning algorithms”. In: MLJ
90.3 (Mar. 2013), pp. 317–346.
[GSS15] I. J. Goodfellow, J. Shlens, and C. Szegedy.
“Explaining and Harnessing Adversarial Examples”.
In: ICLR. 2015.
[GSZ21] P. Grünwald, T. Steinke, and L. Zakynthinou.
“PAC-Bayes, MAC-Bayes and Conditional Mutual In￾formation: Fast rate bounds that handle general VC
classes”. In: COLT. 2021.
[GT86] J. R. Gilbert and R. E. Tarjan. “The analysis
of a nested dissection algorithm”. In: Numer. Math.
50.4 (1986), pp. 377–404.
[GU16] C. A. Gomez-Uribe. “Online Algorithms For
Parameter Mean And Variance Estimation In Dy￾namic Regression Models”. In: (May 2016). arXiv:
1605.05697 [stat.ML].
[Gue19] B. Guedj. “A primer on PAC-Bayesian learn￾ing”. In: arXiv preprint arXiv:1901.05353 (2019).
[GUK21] C. A. Gomez-Uribe and B. Karrer. “The
Decoupled Extended Kalman Filter for Dynamic
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1268
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Exponential-Family Factorization Models”. In: JMLR
22.5 (2021), pp. 1–25.
[Gul+17] I. Gulrajani, F. Ahmed, M. Arjovsky, V. Du￾moulin, and A. C. Courville. “Improved training of
wasserstein gans”. In: NIPS. 2017, pp. 5767–5777.
[Gul+20] C. Gulcehre et al. RL Unplugged:
Benchmarks for Offline Reinforcement Learning.
arXiv:2006.13888. 2020.
[Gum54] E. J. Gumbel. Statistical theory of extreme
values and some practical applications;: A series of
lectures (United States. National Bureau of Stan￾dards. Applied mathematics series). en. 1st edition.
U.S. Govt. Print. Office, 1954.
[Guo09] Y. Guo. “Supervised exponential family prin￾cipal component analysis via convex optimization”. In:
NIPS. 2009.
[Guo+14] Q. Guo, D. Tu, J. Lei, and G. Li. “Hybrid
CNN-HMM model for street view house number recog￾nition”. In: ACCV Workshops. Lecture notes in com￾puter science. Cham: Springer International Publish￾ing, 2014, pp. 303–315.
[Guo+17] C. Guo, G. Pleiss, Y. Sun, and K. Q. Wein￾berger. “On Calibration of Modern Neural Networks”.
In: ICML. 2017.
[Gup+16] M. Gupta, A. Cotter, J. Pfeifer, K. Voevod￾ski, K. Canini, A. Mangylov, W. Moczydlowski, and
A. van Esbroeck. “Monotonic Calibrated Interpolated
Look-Up Tables”. In: Journal of Machine Learning
Research 17.109 (2016), pp. 1–47.
[Gur+18] S. Gururangan, S. Swayamdipta, O. Levy, R.
Schwartz, S. R. Bowman, and N. A. Smith. “Anno￾tation Artifacts in Natural Language Inference Data”.
In: CoRR abs/1803.02324 (2018). arXiv: 1803.02324.
[Gus01] M. Gustafsson. “A probabilistic derivation
of the partial least-squares algorithm”. In: Journal
of Chemical Information and Modeling 41 (2001),
pp. 288–294.
[Gut+14] M. U. Gutmann, R. Dutta, S. Kaski, and
J. Corander. “Statistical inference of intractable gen￾erative models via classification”. In: arXiv preprint
arXiv:1407.4981 (2014).
[Gut22] M. U. Gutmann. “Pen and Paper Exercises in
Machine Learning”. In: (June 2022). arXiv: 2206.13446
[cs.LG].
[GV17] S. Ghosal and A. van der Vaart. Fundamen￾tals of Nonparametric Bayesian Inference. en. 1st ed.
Cambridge University Press, 2017.
[GW08] A. Griewank and A. Walther. Evaluating
Derivatives: Principles and Techniques of Algorith￾mic Differentiation. Second. Society for Industrial
and Applied Mathematics, 2008.
[GW92] W. Gilks and P. Wild. “Adaptive rejection
sampling for Gibbs sampling”. In: Applied Statistics
41 (1992), pp. 337–348.
[GXG18] H. Ge, K. Xu, and Z. Ghahramani. “Turing: a
language for flexible probabilistic inference”. In: AIS￾TATS. 2018, pp. 1682–1690.
[GZG19] S. K. S. Ghasemipour, R. S. Zemel, and S. Gu.
“A Divergence Minimization Perspective on Imitation
Learning Methods”. In: CORL. 2019, pp. 1259–1277.
[HA21] R. J. Hyndman and G. Athanasopoulos. Fore￾casting: Principles and Practice. en. 3rd ed. Otexts,
2021.
[Haa+17] T. Haarnoja, H. Tang, P. Abbeel, and S.
Levine. “Reinforcement learning with deep energy￾based policies”. In: Proceedings of the 34th Interna￾tional Conference on Machine Learning-Volume 70.
2017, pp. 1352–1361.
[Haa+18a] T. Haarnoja, A. Zhou, P. Abbeel, and S.
Levine. “Soft Actor-Critic: Off-Policy Maximum En￾tropy Deep Reinforcement Learning with a Stochas￾tic Actor”. In: International Conference on Machine
Learning. 2018, pp. 1861–1870.
[Haa+18b] T. Haarnoja, A. Zhou, P. Abbeel, and S.
Levine. “Soft Actor-Critic: Off-Policy Maximum En￾tropy Deep Reinforcement Learning with a Stochastic
Actor”. In: ICML. 2018.
[Haa+18c] T. Haarnoja et al. “Soft Actor-Critic Al￾gorithms and Applications”. In: (2018). arXiv: 1812 .
05905 [cs.LG].
[HAB17] J. H. Huggins, R. P. Adams, and T. Broderick.
“PASS-GLM: polynomial approximate sufficient statis￾tics for scalable Bayesian GLM inference”. In: NIPS.
2017.
[Had+20] R. Hadsell, D. Rao, A. A. Rusu, and R.
Pascanu. “Embracing Change: Continual Learning in
Deep Neural Networks”. en. In: Trends Cogn. Sci.
24.12 (2020), pp. 1028–1040.
[HAE16] M. Huh, P. Agrawal, and A. A. Efros. “What
makes ImageNet good for transfer learning?” In: arXiv
preprint arXiv:1608.08614 (2016).
[Haf18] D. Hafner. Building Variational Auto￾Encoders in TensorFlow. Blog post. 2018.
[Haf+19] D. Hafner, T. Lillicrap, I. Fischer, R. Ville￾gas, D. Ha, H. Lee, and J. Davidson. “Learning Latent
Dynamics for Planning from Pixels”. In: ICML. 2019.
[Haf+20] D. Hafner, T. Lillicrap, J. Ba, and M.
Norouzi. “Dream to Control: Learning Behaviors by
Latent Imagination”. In: ICLR. 2020.
[Hag+17] M. Hagen, M. Potthast, M. Gohsen, A.
Rathgeber, and B. Stein. “A Large-Scale Query
Spelling Correction Corpus”. In: Proceedings of the
40th International ACM SIGIR Conference on Re￾search and Development in Information Retrieval.
SIGIR ’17. ACM, 2017, pp. 1261–1264.
[Haj88] B. Hajek. “Cooling Schedules for Optimal An￾nealing”. In: Math. Oper. Res. 13.2 (1988), pp. 311–
329.
[Häl+21] H. Hälvä, S. L. Corff, L. Leh’ericy, J. So, Y.
Zhu, E. Gassiat, and A. Hyvärinen. “Disentangling
Identifiable Features from Noisy Data with Structured
Nonlinear ICA”. In: NIPS. 2021.
[Ham90] J. Hamilton. “Analysis of time series subject
to changes in regime”. In: J. Econometrics 45 (1990),
pp. 39–70.
[Han16] N. Hansen. “The CMA Evolution Strategy: A
Tutorial”. In: (2016). arXiv: 1604.00772 [cs.LG].
[Han+20] K. Han et al. “A Survey on Vision Trans￾former”. In: (2020). arXiv: 2012.12556 [cs.CV].
[Han80] T. S. Han. “Multiple mutual informations and
multiple interactions in frequency data”. In: Informa￾tion and Control 46.1 (1980), pp. 26–45.
[Har+17] J. Hartford, G. Lewis, K. Leyton-Brown, and
M. Taddy. “Deep IV: A flexible approach for counter￾factual prediction”. In: Proceedings of the 34th Inter￾national Conference on Machine Learning-Volume
70. JMLR. org. 2017, pp. 1414–1423.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Har18] K. Hartnett. “To Build Truly Intelligent Ma￾chines, Teach Them Cause and Effect”. In: Quanta
Magazine (2018).
[Har90] A. C. Harvey. Forecasting, Structural Time
Series Models, and the Kalman Filter. Cambridge
Univerity Press, 1990.
[Has10] H. van Hasselt. “Double Q-learning”. In: NIPS.
Ed. by J. D. Lafferty, C. K. I. Williams, J Shawe￾Taylor, R. S. Zemel, and A Culotta. Curran Associates,
Inc., 2010, pp. 2613–2621.
[Has70] W. Hastings. “Monte Carlo Sampling Meth￾ods Using Markov Chains and Their Applications”. In:
Biometrika 57.1 (1970), pp. 97–109.
[Hau+10] J. R. Hauser, O. Toubia, T. Evgeniou, R. Be￾furt, and D. Dzyabura. “Disjunctions of conjunctions,
cognitive simplicity, and consideration sets”. In: Jour￾nal of Marketing Research 47.3 (2010), pp. 485–496.
[Hau+11] M. Hauschild, M. Pelikan, M. Hauschild, and
M. Pelikan. “An introduction and survey of estimation
of distribution algorithms”. In: Swarm and Evolution￾ary Computation. 2011.
[Haz22] E. Hazan. Introduction to Online Convex Op￾timization. en. 2nd ed. The MIT Press, Sept. 2022.
[HBB10] M. Hoffman, D. Blei, and F. Bach. “Online
learning for latent Dirichlet allocation”. In: NIPS.
2010.
[HBW19] E. Hoogeboom, R. van den Berg, and M.
Welling. “Emerging Convolutions for Generative Nor￾malizing Flows”. In: ICML. 2019.
[HC93] G. Hinton and D. V. Camp. “Keeping Neu￾ral Networks Simple by Minimizing the Description
Length of the Weights”. In: in Proc. of the 6th
Ann. ACM Conf. on Computational Learning The￾ory. ACM Press, 1993, pp. 5–13.
[HCG20] S. Huang, Y. Cao, and R. Grosse. “Evaluating
Lossy Compression Rates of Deep Generative Models”.
In: ICML. 2020.
[HCL06] R. Hadsell, S. Chopra, and Y. LeCun. “Di￾mensionality Reduction by Learning an Invariant Map￾ping”. In: 2006 IEEE Computer Society Confer￾ence on Computer Vision and Pattern Recognition
(CVPR’06) 2 (2006), pp. 1735–1742.
[HD19] D. Hendrycks and T. Dietterich. “Benchmark￾ing Neural Network Robustness to Common Corrup￾tions and Perturbations”. In: ICLR. 2019.
[HDL17] D. Ha, A. M. Dai, and Q. V. Le. “HyperNet￾works”. In: ICLR. 2017.
[He+16a] K. He, X. Zhang, S. Ren, and J. Sun. “Deep
Residual Learning for Image Recognition”. In: CVPR.
2016.
[HE16a] J. Ho and S. Ermon. “Generative adversarial
imitation learning”. In: Proceedings of the 30th Inter￾national Conference on Neural Information Process￾ing Systems. 2016, pp. 4572–4580.
[He+16b] K. He, X. Zhang, S. Ren, and J. Sun. “Iden￾tity Mappings in Deep Residual Networks”. In: ECCV.
2016.
[HE16b] J. Ho and S. Ermon. “Generative Adversarial
Imitation Learning”. In: NIPS. 2016, pp. 4565–4573.
[HE18] D. Ha and D. Eck. “A Neural Representation
of Sketch Drawings”. In: ICLR. 2018.
[He+19] J. He, D. Spokoyny, G. Neubig, and T. Berg￾Kirkpatrick. “Lagging Inference Networks and Poste￾rior Collapse in Variational Autoencoders”. In: ICLR.
2019.
[He+20] K. He, H. Fan, Y. Wu, S. Xie, and R. Girshick.
“Momentum contrast for unsupervised visual represen￾tation learning”. In: CVPR. 2020, pp. 9729–9738.
[He+21] K. He, X. Chen, S. Xie, Y. Li, P. Dollár, and R.
Girshick. Masked Autoencoders Are Scalable Vision
Learners. 2021. arXiv: 2111.06377 [cs.CV].
[He+22] K. He, X. Chen, S. Xie, Y. Li, P. Dollár, and
R. Girshick. “Masked autoencoders are scalable vision
learners”. In: Proceedings of the IEEE/CVF Confer￾ence on Computer Vision and Pattern Recognition.
2022, pp. 16000–16009.
[Heg06] P. Heggernes. “Minimal triangulations of
graphs: A survey”. In: Discrete Math. 306.3 (2006),
pp. 297–317.
[Hei+16] M. Heinonen, H. Mannerström, J. Rousu, S.
Kaski, and H. Lähdesmäki. “Non-Stationary Gaussian
Process Regression with Hamiltonian Monte Carlo”.
In: AISTATS. Ed. by A. Gretton and C. C. Robert.
Vol. 51. Proceedings of Machine Learning Research.
Cadiz, Spain: PMLR, 2016, pp. 732–740.
[Hel17] J. Helske. “KFAS: Exponential Family State
Space Models in R”. In: J. Stat. Softw. (2017).
[Hen+15] J. Hensman, A. Matthews, M. Filippone,
and Z. Ghahramani. “MCMC for Variationally Sparse
Gaussian Processes”. In: NIPS. 2015, pp. 1648–1656.
[Hen+16] L. A. Hendricks, Z. Akata, M. Rohrbach, J.
Donahue, B. Schiele, and T. Darrell. “Generating vi￾sual explanations”. In: European conference on com￾puter vision. Springer. 2016, pp. 3–19.
[Hen+18] G. E. Henter, J. Lorenzo-Trueba, X. Wang,
and J. Yamagishi. “Deep Encoder-Decoder Models for
Unsupervised Learning of Controllable Speech Synthe￾sis”. In: (2018). arXiv: 1807.11470 [eess.AS].
[Hen+19a] O. J. Henaff, A. Razavi, C. Doersch, S. M.
Ali Eslami, and A. van den Oord. “Data-Efficient Im￾age Recognition with Contrastive Predictive Coding”.
In: arXiv [cs.CV] (2019).
[Hen+19b] D. Hendrycks, S. Basart, M. Mazeika, A.
Zou, J. Kwon, M. Mostajabi, J. Steinhardt, and D.
Song. “Scaling Out-of-Distribution Detection for Real￾World Settings”. In: (2019). arXiv: 1911.11132 [cs.CV].
[Hen+20] D. Hendrycks*, N. Mu*, E. D. Cubuk, B.
Zoph, J. Gilmer, and B. Lakshminarayanan. “AugMix:
A Simple Data Processing Method to Improve Robust￾ness and Uncertainty”. In: ICLR. 2020.
[Hen+21] C. Henning, M. R. Cervera, F. D’Angelo, J.
von Oswald, R. Traber, B. Ehret, S. Kobayashi, B. F.
Grewe, and J. Sacramento. “Posterior Meta-Replay for
Continual Learning”. In: NIPS. 2021.
[Hes00] T. Heskes. “On “Natural” Learning and Prun￾ing in Multilayered Perceptrons”. In: Neural Comput.
12.4 (2000), pp. 881–901.
[Hes+18] M. Hessel, J. Modayil, H. van Hasselt, T.
Schaul, G. Ostrovski, W. Dabney, D. Horgan, B.
Piot, M. Azar, and D. Silver. “Rainbow: Combining
Improvements in Deep Reinforcement Learning”. In:
AAAI. 2018.
[Heu+17a] M. Heusel, H. Ramsauer, T. Unterthiner, B.
Nessler, and S. Hochreiter. “GANs Trained by a Two
Time-Scale Update Rule Converge to a Local Nash
Equilibrium”. In: NIPS. 2017.
[Heu+17b] M. Heusel, H. Ramsauer, T. Unterthiner, B.
Nessler, and S. Hochreiter. “Gans trained by a two
time-scale update rule converge to a local nash equilib￾Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1270
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
rium”. In: Advances in neural information processing
systems. 2017, pp. 6626–6637.
[HFL13] J. Hensman, N. Fusi, and N. D. Lawrence.
“Gaussian Processes for Big Data”. In: UAI. 2013.
[HFM17] D. W. Hogg and D. Foreman-Mackey. “Data
analysis recipes: Using Markov Chain Monte Carlo”.
In: (2017). arXiv: 1710.06068 [astro-ph.IM].
[HG12] D. I. Hastie and P. J. Green. “Model Choice us￾ing Reversible Jump Markov Chain Monte Carlo”. In:
Statistica Neerlandica 66 (2012), pp. 309–338.
[HG14] M. D. Hoffman and A. Gelman. “The No￾U-Turn Sampler: Adaptively Setting Path Lengths
in Hamiltonian Monte Carlo”. In: JMLR 15 (2014),
pp. 1593–1623.
[HG16] D. Hendrycks and K. Gimpel. “Gaussian Error
Linear Units (GELUs)”. In: arXiv [cs.LG] (2016).
[HGMG18] J. Hron, A. G. de G. Matthews, and Z.
Ghahramani. “Variational Bayesian dropout: pitfalls
and fixes”. In: ICML. 2018.
[HGS16] H. van Hasselt, A. Guez, and D. Silver. “Deep
Reinforcement Learning with Double Q-Learning”. In:
AAAI. AAAI’16. AAAI Press, 2016, pp. 2094–2100.
[HH06] C. Holmes and L. Held. “Bayesian auxiliary
variable models for binary and multinomial regression”.
In: Bayesian Analysis 1.1 (2006), pp. 145–168.
[HHH09] A. Hyvarinen, J. Hurri, and P. Hoyer. Natu￾ral Image Statistics: a probabilistic approach to early
computational vision. Springer, 2009.
[HHK19] M. Haußmann, F. A. Hamprecht, and M.
Kandemir. “Sampling-Free Variational Inference of
Bayesian Neural Networks by Variance Backpropaga￾tion”. In: UAI. 2019.
[HHLB11] F. Hutter, H. H. Hoos, and K. Leyton￾Brown. “Sequential Model-Based Optimization for
General Algorithm Configuration”. In: Intl. Conf. on
Learning and Intelligent Optimization (LION). 2011,
pp. 507–523.
[Hig+17a] I. Higgins, L. Matthey, A. Pal, C. Burgess,
X. Glorot, M. Botvinick, S. Mohamed, and A. Ler￾chner. “beta-VAE: Learning Basic Visual Concepts
with a Constrained Variational Framework”. In: ICLR.
2017.
[Hig+17b] I. Higgins, L. Matthey, A. Pal, C. P.
Burgess, X. Glorot, M. M. Botvinick, S. Mohamed,
and A. Lerchner. “beta-VAE: Learning Basic Visual
Concepts with a Constrained Variational Framework”.
In: ICLR. 2017.
[Hin02] G. E. Hinton. “Training products of experts
by minimizing contrastive divergence”. en. In: Neural
Computation 14.8 (2002), pp. 1771–1800.
[Hin10] G. Hinton. A Practical Guide to Training Re￾stricted Boltzmann Machines. Tech. rep. U. Toronto,
2010.
[Hin+95] G. E. Hinton, P Dayan, B. J. Frey, and R. M.
Neal. “The “wake-sleep” algorithm for unsupervised
neural networks”. en. In: Science 268.5214 (1995),
pp. 1158–1161.
[HIY19] K. Hayashi, M. Imaizumi, and Y. Yoshida.
“On Random Subsampling of Gaussian Process Regres￾sion: A Graphon-Based Analysis”. In: (2019). arXiv:
1901.09541 [stat.ML].
[HJ12] T. Hazan and T. Jaakkola. “On the Partition
Function and Random Maximum A-Posteriori Pertur￾bations”. In: ICML. June 2012.
[HJ20] J. Huang and N. Jiang. “From Importance Sam￾pling to Doubly Robust Policy Gradient”. In: ICML.
2020.
[HJA20] J. Ho, A. Jain, and P. Abbeel. “Denoising Dif￾fusion Probabilistic Models”. In: NIPS. 2020.
[Hje+18] R. D. Hjelm, A. Fedorov, S. Lavoie￾Marchildon, K. Grewal, P. Bachman, A. Trischler,
and Y. Bengio. “Learning deep representations by mu￾tual information estimation and maximization”. In: In￾ternational Conference on Learning Representations.
2018.
[Hjo+10] N. Hjort, C. Holmes, P. Muller, and S.
Walker, eds. Bayesian Nonparametrics. Cambridge,
2010.
[HJT18] M. D. Hoffman, M. J. Johnson, and D.
Tran. “Autoconj: Recognizing and Exploiting Conju￾gacy Without a Domain-Specific Language”. In: NIPS.
2018.
[HKH22] M. Hobbhahn, A. Kristiadi, and P. Hennig.
“Fast Predictive Uncertainty for Classification with
Bayesian Deep Networks”. In: UAI. 2022.
[HKO22] P. Hennig, H. Kersting, and M. Osborne.
Probabilistic Numerics: Computation as Machine
Learning. 2022.
[HKP91] J. Hertz, A. Krogh, and R. G. Palmer. An
Introduction to the Theory of Neural Comptuation.
Addison-Wesley, 1991.
[HKZ12] D. Hsu, S. Kakade, and T. Zhang. “A spec￾tral algorithm for learning hidden Markov models”.
In: J. of Computer and System Sciences 78.5 (2012),
pp. 1460–1480.
[HL04] D. R. Hunter and K. Lange. “A Tutorial on MM
Algorithms”. In: The American Statistician 58 (2004),
pp. 30–37.
[HL+16a] J. Hernandez-Lobato, Y. Li, M. Rowland, T.
Bui, D. Hernandez-Lobato, and R. Turner. “Black-Box
Alpha Divergence Minimization”. en. In: ICML. 2016,
pp. 1511–1520.
[HL+16b] M. Hernandez-Lobato, M. A. Gelbart, R. P.
Adams, M. W. Hoffman, and Z. Ghahramani. “A
General Framework for Constrained Bayesian Opti￾mization using Information-based Search”. In: JMLR
(2016).
[HL20] X. Hu and J. Lei. “A Distribution-Free Test
of Covariate Shift Using Conformal Prediction”. In:
(2020). arXiv: 2010.07147 [stat.ME].
[HLA15a] J. M. Hernández-Lobato and R. P. Adams.
“Probabilistic Backpropagation for Scalable Learning
of Bayesian Neural Networks”. In: ICML. 2015.
[HLA15b] J. M. Hernández-Lobato and R. P. Adams.
“Probabilistic Backpropagation for Scalable Learning
of Bayesian Neural Networks”. In: ICML. 2015.
[HLA19] J. Ho, E. Lohn, and P. Abbeel. “Compression
with Flows via Local Bits-Back Coding”. In: NeurIPS.
2019.
[HLC19] Y.-P. Hsieh, C. Liu, and V. Cevher. “Find￾ing mixed nash equilibria of generative adversarial
networks”. In: International Conference on Machine
Learning. 2019, pp. 2810–2819.
[HLHG14] J. Hernandez-Lobato, M. W. Hoffman, and
Z. Ghahramani. “Predictive entropy search for efficient
global optimization of black-box functions”. In: NIPS.
2014.
[HLR16] K. Hofmann, L. Li, and F. Radlinski. “On￾line Evaluation for Information Retrieval”. In: Foun￾Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
dations and Trends in Information Retrieval 10.1
(2016), pp. 1–117.
[HLRW14] J. R. Hershey, J. Le Roux, and F. Weninger.
“Deep Unfolding: Model-Based Inspiration of Novel
Deep Architectures”. In: (2014). arXiv: 1409 . 2574
[cs.LG].
[HLS03] R. Herbrich, N. D. Lawrence, and M. Seeger.
“Fast Sparse Gaussian Process Methods: The Infor￾mative Vector Machine”. In: NIPS. MIT Press, 2003,
pp. 625–632.
[HM81] R. Howard and J. Matheson. “Influence dia￾grams”. In: Readings on the Principles and Appli￾cations of Decision Analysis, volume II. Ed. by R.
Howard and J. Matheson. Strategic Decisions Group,
1981.
[HMD18] J. C. Higuera, D Meger, and G Dudek. “Syn￾thesizing Neural Network Controllers with Probabilis￾tic Model-Based Reinforcement Learning”. In: IROS.
2018, pp. 2538–2544.
[HMD19] D. Hendrycks, M. Mazeika, and T. Dietterich.
“Deep Anomaly Detection with Outlier Exposure”. In:
ICLR. 2019.
[HMK04] D. Heckerman, C. Meek, and D. Koller. Prob￾abilistic Models for Relational Data. Tech. rep. MSR￾TR-2004-30. Microsoft Research, 2004.
[HNBK18] J. He, G. Neubig, and T. Berg-Kirkpatrick.
“Unsupervised Learning of Syntactic Structure with
Invertible Neural Projections”. In: EMNLP. 2018.
[HNP09] A. Halevy, P. Norvig, and F. Pereira. “The un￾reasonable effectiveness of data”. In: IEEE Intelligent
Systems 24.2 (2009), pp. 8–12.
[HO00] A. Hyvarinen and E. Oja. “Independent compo￾nent analysis: algorithms and applications”. In: Neural
Networks 13 (2000), pp. 411–430.
[Ho+21] J. Ho, C. Saharia, W. Chan, D. J. Fleet, M.
Norouzi, and T. Salimans. “Cascaded Diffusion Models
for High Fidelity Image Generation”. In: (May 2021).
arXiv: 2106.15282 [cs.CV].
[HO48] C. G. Hempel and P. Oppenheim. “Studies in
the Logic of Explanation”. In: Philosophy of science
15.2 (1948), pp. 135–175.
[Hob69] A. Hobson. “A new theorem of information
theory”. In: Journal of Statistical Physics 1.3 (1969),
pp. 383–391.
[Hoe+14] R. Hoekstra, R. D. Morey, J. N. Rouder, and
E.-J. Wagenmakers. “Robust misinterpretation of con￾fidence intervals”. en. In: Psychon. Bull. Rev. 21.5
(2014), pp. 1157–1164.
[Hoe+21] T. Hoefler, D. Alistarh, T. Ben-Nun, N. Dry￾den, and A. Peste. “Sparsity in Deep Learning: Prun￾ing and growth for efficient inference and training
in neural networks”. In: (2021). arXiv: 2102 . 00554
[cs.LG].
[Hoe+99] J. Hoeting, D. Madigan, A. Raftery, and C.
Volinsky. “Bayesian Model Averaging: A Tutorial”. In:
Statistical Science 4.4 (1999).
[Hof09] P. D. Hoff. A First Course in Bayesian Sta￾tistical Methods. Springer, 2009.
[Hof+13] M. D. Hoffman, D. M. Blei, C. Wang, and J.
Paisley. “Stochastic Variational Inference”. In: JMLR
14 (2013), pp. 1303–1347.
[Hof17] M. D. Hoffman. “Learning Deep Latent Gaus￾sian Models with Markov Chain Monte Carlo”. In:
ICML. 2017, pp. 1510–1519.
[Hof+18] J. Hoffman, E. Tzeng, T. Park, J.-Y. Zhu,
P. Isola, K. Saenko, A. Efros, and T. Darrell. “Cy￾cada: Cycle-consistent adversarial domain adaptation”.
In: International conference on machine learning.
PMLR. 2018, pp. 1989–1998.
[Hof+19] M. Hoffman, P. Sountsov, J. V. Dillon, I.
Langmore, D. Tran, and S. Vasudevan. “NeuTra-lizing
Bad Geometry in Hamiltonian Monte Carlo Using
Neural Transport”. In: (2019). arXiv: 1903 . 03704
[stat.CO].
[Hof99] T. Hofmann. “Probabilistic latent semantic in￾dexing”. In: Research and Development in Informa￾tion Retrieval (1999), pp. 50–57.
[Hoh+20] F. Hohman, M. Conlen, J. Heer, and D. H. P.
Chau. “Communicating with interactive articles”. In:
Distill 5.9 (2020), e28.
[Hol86] P. W. Holland. “Statistics and Causal Infer￾ence”. In: JASA 81.396 (1986), pp. 945–960.
[Hol92] J. H. Holland. Adaptation in Natural and Ar￾tificial Systems. https : / / mitpress . mit . edu / books /
adaptation - natural - and - artificial - systems. Ac￾cessed: 2017-11-26. 1992.
[Hon+10] A. Honkela, T. Raiko, M. Kuusela, M.
Tornio, and J. Karhunen. “Approximate Riemannian
Conjugate Gradient Learning for Fixed-Form Varia￾tional Bayes”. In: JMLR 11.Nov (2010), pp. 3235–
3268.
[Hoo+21] E. Hoogeboom, D. Nielsen, P. Jaini, P. Forré,
and M. Welling. “Argmax Flows and Multinomial Dif￾fusion: Learning Categorical Distributions”. In: NIPS.
Feb. 2021.
[Hop82] J. J. Hopfield. “Neural networks and physical
systems with emergent collective computational abili￾ties”. In: PNAS 79.8 (1982), 2554–2558.
[Hor+05] E. Horvitz, J. Apacible, R. Sarin, and L. Liao.
“Prediction, Expectation, and Surprise: Methods, De￾signs, and Study of a Deployed Traffic Forecasting Ser￾vice”. In: UAI. 2005.
[Hor61] P Horst. “Generalized canonical correlations
and their applications to experimental data”. en. In:
J. Clin. Psychol. 17 (1961), pp. 331–347.
[Hos+20a] T. Hospedales, A. Antoniou, P. Micaelli,
and A. Storkey. “Meta-Learning in Neural Networks:
A Survey”. In: (2020). arXiv: 2004.05439 [cs.LG].
[Hos+20b] R. Hostettler, F. Tronarp, Á. F. García￾Fernández, and S. Särkkä. “Importance Densities for
Particle Filtering Using Iterated Conditional Expec￾tations”. In: IEEE Signal Process. Lett. 27 (2020),
pp. 211–215.
[HOT06a] G. Hinton, S. Osindero, and Y. Teh. “A fast
learning algorithm for deep belief nets”. In: Neural
Computation 18 (2006), pp. 1527–1554.
[HOT06b] G. E. Hinton, S. Osindero, and Y. W. Teh.
“A Fast Learning Algorithm for Deep Belief Nets”. In:
Neural Computation 18 (2006), pp. 1527–1554.
[Hot36] H. Hotelling. “Relations Between Two Sets of
Variates”. In: Biometrika 28.3/4 (1936), pp. 321–377.
[Hou+12] N. Houlsby, F. Huszar, Z. Ghahramani,
and J. M. Hernández-lobato. “Collaborative Gaussian
Processes for Preference Learning”. In: NIPS. 2012,
pp. 2096–2104.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1272
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[Hou+19] N. Houlsby, A. Giurgiu, S. Jastrzebski, B.
Morrone, Q. De Laroussilhe, A. Gesmundo, M. At￾tariyan, and S. Gelly. “Parameter-efficient transfer
learning for NLP”. In: International Conference on
Machine Learning. PMLR. 2019, pp. 2790–2799.
[HOW11] P. Hall, J. T. Ormerod, and M. P. Wand.
“Theory of Gaussian Variational Approximation for
a Generalised Linear Mixed Model”. In: Statistica
Sinica 21 (2011), pp. 269–389.
[HP10] J. Hacker and P. Pierson. Winner-Take-All
Politics: How Washington Made the Rich Richer —
and Turned Its Back on the Middle Class. Simon &
Schuster, 2010.
[HPHL19] M. Havasi, R. Peharz, and J. M. Hernández￾Lobato. “Minimal Random Code Learning: Getting
Bits Back from Compressed Model Parameters”. In:
2019.
[HPR19] C. Herzog né Hoffmann, E. Petersen, and P.
Rostalski. “Iterative Approximate Nonlinear Inference
via Gaussian Message Passing on Factor Graphs”. In:
IEEE Control Systems Letters 3.4 (2019), pp. 978–
983.
[HR17] C. Hoffmann and P. Rostalski. “Linear Optimal
Control on Factor Graphs — A Message Passing Per￾spective”. In: Intl. Federation of Automatic Control
50.1 (2017), pp. 6314–6319.
[HR20a] M. Hernan and J. Robins. Causal Inference:
What If. CRC Press, 2020.
[HR20b] M. Hernán and J. Robins. Causal Inference:
What If. Boca Raton: Chapman & Hall/CRC., 2020.
[HS05] H. Hoos and T. Stutzle. Stochastic local search:
Foundations and applications. Morgan Kauffman,
2005.
[HS06a] G. Hinton and R. Salakhutdinov. “Reducing
the dimensionality of data with neural networks”. In:
Science 313.5786 (2006), pp. 504–507.
[HS06b] G. E. Hinton and R. R. Salakhutdinov. “Re￾ducing the dimensionality of data with neural net￾works”. In: science 313.5786 (2006), pp. 504–507.
[HS09] M. Heaton and J. Scott. Bayesian computation
and the linear model. Tech. rep. Duke, 2009.
[HS10] J. Hartikainen and S. Särkkä. “Kalman filter￾ing and smoothing solutions to temporal Gaussian pro￾cess regression models”. In: 2010 IEEE International
Workshop on Machine Learning for Signal Process￾ing. Aug. 2010, pp. 379–384.
[HS12] P. Hennig and C. Schuler. “Entropy search for
information-efficient global optimization”. In: JMLR
13 (2012), pp. 1809–1837.
[HS13] J. Y. Hsu and D. S. Small. “Calibrating Sen￾sitivity Analyses to Observed Covariates in Observa￾tional Studies”. In: Biometrics 69.4 (2013), pp. 803–
811. eprint: https : / / onlinelibrary . wiley . com / doi /
pdf/10.1111/biom.12101.
[HS18] D. Ha and J. Schmidhuber. “World Models”. In:
NIPS. 2018.
[HS21] J. Ho and T. Salimans. “Classifier-Free Diffu￾sion Guidance”. In: NIPS Workshop on Deep Gener￾ative Models and Downstream Applications. 2021.
[HS88] D. S. Hochbaum and D. B. Shmoys. “A polyno￾mial approximation scheme for scheduling on uniform
processors: Using the dual approximation approach”.
In: SICOMP. 1988.
[HS97] S Hochreiter and J Schmidhuber. “Flat minima”.
en. In: Neural Comput. 9.1 (1997), pp. 1–42.
[HSDK12] C. Hillar, J. Sohl-Dickstein, and K. Koepsell.
Efficient and Optimal Binary Hopfield Associative
Memory Storage Using Minimum Probability Flow.
Tech. rep. 2012. arXiv: 1204.2916.
[HSG06] J. D. Hol, T. B. Schon, and F. Gustafsson.
“On Resampling Algorithms for Particle Filters”. In:
IEEE Nonlinear Statistical Signal Processing Work￾shop. 2006, pp. 79–82.
[HSGF21] S. Hassan, S. Sarkka, and A. F. Garcia￾Fernandez. “Temporal Parallelization of Inference in
Hidden Markov Models”. In: IEEE Trans. Signal Pro￾cessing 69 (2021), pp. 4875–4887.
[Hsu+18] Y.-C. Hsu, Y.-C. Liu, A. Ramasamy, and
Z. Kira. “Re-evaluating Continual Learning Scenarios:
A Categorization and Case for Strong Baselines”. In:
NIPS Continual Learning Workshop. 2018.
[HT01] G. E. Hinton and Y. Teh. “Discovering multi￾ple constraints that are frequently approximately sat￾isfied”. In: UAI. 2001.
[HT09] H. Hoefling and R. Tibshirani. “Estimation
of Sparse Binary Pairwise Markov Networks using
Pseudo-likelihoods”. In: JMLR 10 (2009).
[HT15] J. H. Huggins and J. B. Tenenbaum. “Risk and
regret of hierarchical Bayesian learners”. In: ICML.
2015.
[HT17] T. J. Hastie and R. J. Tibshirani. Generalized
additive models. Routledge, 2017.
[HTF01] T. Hastie, R. Tibshirani, and J. Friedman.
The Elements of Statistical Learning. Springer, 2001.
[HTF09] T. Hastie, R. Tibshirani, and J. Friedman.
The Elements of Statistical Learning. 2nd edition.
Springer, 2009.
[HTW15] T. Hastie, R. Tibshirani, and M. Wainwright.
Statistical Learning with Sparsity: The Lasso and
Generalizations. CRC Press, 2015.
[Hu+00] M. Hu, C. Ingram, M.Sirski, C. Pal, S. Swamy,
and C. Patten. A Hierarchical HMM Implementation
for Vertebrate Gene Splice Site Prediction. Tech. rep.
Dept. Computer Science, Univ. Waterloo, 2000.
[Hu+12] J. Hu, Y. Wang, E. Zhou, M. C. Fu, and S. I.
Marcus. “A Survey of Some Model-Based Methods
for Global Optimization”. en. In: Optimization, Con￾trol, and Applications of Stochastic Systems. Systems
& Control: Foundations & Applications. Birkhäuser,
Boston, 2012, pp. 157–179.
[Hu+17] W. Hu, C. J. Li, L. Li, and J.-G. Liu. “On the
diffusion approximation of nonconvex stochastic gradi￾ent descent”. In: (2017). arXiv: 1705.07562 [stat.ML].
[Hua+17a] G. Huang, Y. Li, G. Pleiss, Z. Liu, J.
Hopcroft, and K. Weinberger. “Snapshot ensembles:
train 1, get M for free”. In: ICLR. 2017.
[Hua+17b] Y Huang, Y Zhang, N Li, Z Wu, and
J. A. Chambers. “A Novel Robust Student’s t-Based
Kalman Filter”. In: IEEE Trans. Aerosp. Electron.
Syst. 53.3 (2017), pp. 1545–1554.
[Hua+18a] C.-Z. A. Huang, A. Vaswani, J. Uszkoreit,
N. Shazeer, I. Simon, C. Hawthorne, A. M. Dai, M. D.
Hoffman, M. Dinculescu, and D. Eck. “Music Trans￾former”. In: (2018). arXiv: 1809.04281 [cs.LG].
[Hua+18b] C.-W. Huang, D. Krueger, A. Lacoste,
and A. Courville. “Neural Autoregressive Flows”. In:
ICML. 2018.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Hua+18c] Y. Huang, Y. Zhang, Z. Wu, N. Li, and J.
Chambers. “A Novel Adaptive Kalman Filter With In￾accurate Process and Measurement Noise Covariance
Matrices”. In: IEEE Trans. Automat. Contr. 63.2
(Feb. 2018), pp. 594–601.
[Hua+19] Y. Huang, Y. Zhang, Y. Zhao, and J. A.
Chambers. “A Novel Robust Gaussian–Student’s t
Mixture Distribution Based Kalman Filter”. In: IEEE
Trans. Signal Process. 67.13 (2019), pp. 3606–3620.
[Hug+19] J. H. Huggins, T. Campbell, M. Kasprzak,
and T. Broderick. “Scalable Gaussian Process Infer￾ence with Finite-data Mean and Variance Guarantees”.
In: AISTATS. 2019.
[Hug+20] J. Huggins, M. Kasprzak, T. Campbell, and
T. Broderick. “Validated Variational Inference via
Practical Posterior Error Bounds”. In: AISTATS. Ed.
by S. Chiappa and R. Calandra. Vol. 108. Proceedings
of Machine Learning Research. PMLR, 2020, pp. 1792–
1802.
[Hus17a] F. Huszár. Is Maximum Likelihood Useful
for Representation Learning? 2017.
[Hus17b] F. Huszár. “Variational inference us￾ing implicit distributions”. In: arXiv preprint
arXiv:1702.08235 (2017).
[Hut89] M. F. Hutchinson. “A stochastic estimator
of the trace of the influence matrix for Laplacian
smoothing splines”. In: Communications in Statistics￾Simulation and Computation 18.3 (1989), pp. 1059–
1076.
[HVD14] G. Hinton, O. Vinyals, and J. Dean. “Distill￾ing the Knowledge in a Neural Network”. In: NIPS DL
workshop. 2014.
[HW13] A. Huang and M. P. Wand. “Simple Marginally
Noninformative Prior Distributions for Covariance
Matrices”. en. In: Bayesian Analysis 8.2 (2013),
pp. 439–452.
[HXW17] H. He, B. Xin, and D. Wipf. “From Bayesian
Sparsity to Gated Recurrent Nets”. In: NIPS. 2017.
[HY01] M. Hansen and B. Yu. “Model selection and the
principle of minimum description length”. In: JASA
(2001).
[Hyv05] A. Hyvärinen. “Estimation of non-normalized
statistical models by score matching”. In: JMLR 6.Apr
(2005), pp. 695–709.
[Hyv07a] A. Hyvarinen. “Connections between score
matching, contrastive divergence, and pseudolike￾lihood for continuous-valued variables”. In: IEEE
Transactions on neural networks 18.5 (2007),
pp. 1529–1531.
[Hyv07b] A. Hyvärinen. “Some extensions of score
matching”. In: Computational statistics & data anal￾ysis 51.5 (2007), pp. 2499–2512.
[IB12] R. Iyer and J. Bilmes. “Algorithms for Approxi￾mate Minimization of the Difference Between Submod￾ular Functions, with Applications”. In: Uncertainty in
Artificial Intelligence (UAI). Catalina Island, USA:
AUAI, 2012.
[IB13] R. Iyer and J. Bilmes. “Submodular Optimiza￾tion with Submodular Cover and Submodular Knap￾sack Constraints”. In: Neural Information Processing
Society (NeurIPS, formerly NIPS). Lake Tahoe, CA,
2013.
[IB15] R. K. Iyer and J. A. Bilmes. “Polyhedral as￾pects of Submodularity, Convexity and Concavity”. In:
Arxiv, CoRR abs/1506.07329 (2015).
[IB98] M. Isard and A. Blake. “CONDENSATION -
conditional density propagation for visual tracking”.
In: Intl. J. of Computer Vision 29.1 (1998), pp. 5–
18.
[IBK06] E. L. Ionides, C Bretó, and A. A. King. “Infer￾ence for nonlinear dynamical systems”. en. In: PNAS
103.49 (2006), pp. 18438–18443.
[IFF00] S. Iwata, L. Fleischer, and S. Fujishige. “A com￾binatorial strongly polynomial algorithm for minimiz￾ing submodular functions”. In: Journal of the ACM
(2000).
[IFW05] A. T. Ihler, J. W. Fischer III, and A. S. Will￾sky. “Loopy Belief Propagation: Convergence and Ef￾fects of Message Errors”. In: JMLR 6 (2005), pp. 905–
936.
[IJB13] R. Iyer, S. Jegelka, and J. Bilmes. “Curvature
and Optimal Algorithms for Learning and Minimizing
Submodular Functions”. In: NIPS. Lake Tahoe, CA,
2013.
[IKB21] A. Immer, M. Korzepa, and M. Bauer. “Im￾proving predictions of Bayesian neural nets via local
linearization”. In: AISTATS. Ed. by A. Banerjee and
K. Fukumizu. Vol. 130. Proceedings of Machine Learn￾ing Research. PMLR, 2021, pp. 703–711.
[IM17] J. Ingraham and D. Marks. “Bayesian Sparsity
for Intractable Undirected Models”. In: ICML. 2017.
[Imb03] G. Imbens. “Sensitivity to Exogeneity Assump￾tions in Program Evaluation”. In: The American Eco￾nomic Review (2003).
[Imb19] G. W. Imbens. “Potential Outcome and Di￾rected Acyclic Graph Approaches to Causality: Rele￾vance for Empirical Practice in Economics”. In: (2019).
arXiv: 1907.07271 [stat.ME].
[Imm+21] A. Immer, M. Bauer, V. Fortuin, G. Rätsch,
and M. E. Khan. “Scalable Marginal Likelihood Es￾timation for Model Selection in Deep Learning”. In:
ICML. 2021.
[IN09] S. Iwata and K. Nagano. “Submodular function
minimization under covering constraints”. In: Proceed￾ings of the 50th Annual IEEE Symposium on Foun￾dations of Computer Science (FOCS). 2009, pp. 671–
680.
[Ing20] M. Ingram. Deterministic ADVI in JAX
(blog post). https : / / martiningram . github . io /
deterministic-advi/. 2020.
[INK18] P. Izmailov, A. Novikov, and D. Kropotov.
“Scalable Gaussian Processes with Billions of Induc￾ing Inputs via Tensor Train Decomposition”. In: ICML.
2018.
[Inn20] M. Innes. “Sense &amp; Sensitivities: The Path
to General-Purpose Algorithmic Differentiation”. In:
Proceedings of Machine Learning and Systems. Ed.
by I. Dhillon, D. Papailiopoulos, and V. Sze. Vol. 2.
2020, pp. 58–69.
[IO09] S. Iwata and J. B. Orlin. “A simple combina￾torial algorithm for submodular function minimiza￾tion”. In: Proceedings of the twentieth annual ACM￾SIAM symposium on Discrete algorithms. SIAM.
2009, pp. 1230–1237.
[IR00] D. R. Insua and F. Ruggeri. Robust Bayesian
Analysis. Springer, 2000.
[IR15] G. Imbens and D. Rubin. Causal Inference in
Statistics, Social and Biomedical Sciences: An Intro￾duction. Cambridge University Press, 2015.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1274
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[IS15] S. Ioffe and C. Szegedy. “Batch Normalization:
Accelerating Deep Network Training by Reducing In￾ternal Covariate Shift”. In: ICML. 2015, pp. 448–456.
[Isa03] M. Isard. “PAMPAS: Real-Valued Graphical
Models for Computer Vision”. In: CVPR. Vol. 1. 2003,
p. 613.
[Isl+19] R. Islam, R. Seraj, S. Y. Arnob, and D. Precup.
“Doubly Robust Off-Policy Actor-Critic Algorithms
for Reinforcement Learning”. In: NeurIPS Workshop
on Safety and Robustness in Decision Making. 2019.
[Iso+17] P. Isola, J.-Y. Zhu, T. Zhou, and A. A. Efros.
“Image-to-Image Translation with Conditional Adver￾sarial Networks”. In: CVPR. 2017.
[IX00] K Ito and K Xiong. “Gaussian filters for non￾linear filtering problems”. In: IEEE Trans. Automat.
Contr. 45.5 (2000), pp. 910–927.
[Iye+21] R. Iyer, N. Khargonkar, J. Bilmes, and H. As￾nani. “Generalized Submodular Information Measures:
Theoretical Properties, Examples, Optimization Algo￾rithms, and Applications”. In: IEEE Transactions on
Information Theory (2021).
[Iza+15] H. Izadinia, B. C. Russell, A. Farhadi, M. D.
Hoffman, and A. Hertzmann. “Deep classifiers from
image tags in the wild”. In: Proceedings of the
2015 Workshop on Community-Organized Multi￾modal Mining: Opportunities for Novel Solutions.
2015, pp. 13–18.
[Izm+18] P. Izmailov, D. Podoprikhin, T. Garipov, D.
Vetrov, and A. G. Wilson. “Averaging Weights Leads
to Wider Optima and Better Generalization”. In: UAI.
2018.
[Izm+19] P. Izmailov, W. J. Maddox, P. Kirichenko, T.
Garipov, D. Vetrov, and A. G. Wilson. “Subspace In￾ference for Bayesian Deep Learning”. In: UAI. 2019.
[Izm+21a] P. Izmailov, P. Nicholson, S. Lotfi, and A. G.
Wilson. “Dangers of Bayesian Model Averaging under
Covariate Shift”. In: NIPS. 2021.
[Izm+21b] P. Izmailov, S. Vikram, M. D. Hoffman, and
A. G. Wilson. “What Are Bayesian Neural Network
Posteriors Really Like?” In: ICML. 2021.
[Jaa01] T. Jaakkola. “Tutorial on variational approxi￾mation methods”. In: Advanced mean field methods.
Ed. by M. Opper and D. Saad. MIT Press, 2001.
[Jac+21] M. Jacobs, M. F. Pradier, T. H. McCoy, R. H.
Perlis, F. Doshi-Velez, and K. Z. Gajos. “How machine￾learning recommendations influence clinician treat￾ment selections: the example of antidepressant selec￾tion”. In: Translational psychiatry 11.1 (2021), pp. 1–
9.
[Jad+17] M. Jaderberg, V. Mnih, W. M. Czarnecki, T.
Schaul, J. Z. Leibo, D. Silver, and K. Kavukcuoglu.
“Reinforcement Learning with Unsupervised Auxiliary
Tasks”. In: ICLR. 2017.
[Jak21] K. Jakkala. “Deep Gaussian Processes: A Sur￾vey”. In: (2021). arXiv: 2106.12135 [cs.LG].
[Jan+17] P. A. Jang, A. Loeb, M. Davidow, and A. G.
Wilson. “Scalable Levy Process Priors for Spectral
Kernel Learning”. In: Advances in Neural Informa￾tion Processing Systems. 2017.
[Jan18] E. Jang. Normalizing Flows Tutorial. 2018.
[Jan+19] M. Janner, J. Fu, M. Zhang, and S. Levine.
“When to Trust Your Model: Model-Based Policy Op￾timization”. In: NIPS. 2019.
[Jas] Jason Antic and Jeremy Howard and Uri Manor.
Decrappification, DeOldification, and Super Resolu￾tion (Blog post).
[Jay03] E. T. Jaynes. Probability theory: the logic of
science. Cambridge university press, 2003.
[Jay+20] S. M. Jayakumar, W. M. Czarnecki, J.
Menick, J. Schwarz, J. Rae, S. Osindero, Y. W. Teh, T.
Harley, and R. Pascanu. “Multiplicative Interactions
and Where to Find Them”. In: ICLR. 2020.
[Jay76] E. T. Jaynes. “Confidence intervals vs Bayesian
intervals”. In: Foundations of Probability Theory,
Statistical Inference, and Statistical Theories of Sci￾ence, vol II. Ed. by W. L. Harper and C. A. Hooker.
Reidel Publishing Co., 1976.
[JB03] A. Jakulin and I. Bratko. “Analyzing Attribute
Dependencies”. In: Proc. 7th European Conf. on
Principles and Practice of Knowledge Discovery in
Databases. 2003.
[JB16] S. Jegelka and J. Bilmes. “Graph cuts with in￾teracting edge weights: examples, approximations, and
algorithms”. In: Mathematical Programming (2016),
pp. 1–42.
[JB65] C. Jacobi and C. W. Borchardt. “De investi￾gando ordine systematis aequationum differentialium
vulgarium cujuscunque.” In: Journal für die reine
und angewandte Mathematik 1865.64 (1865), pp. 297–
320.
[JB67] A. H. Jazwinski and A. E. Bailie. Adaptive Fil￾tering. Tech. rep. 1967.
[JBB09] D. Jian, A. Barthels, and M. Beetz. “Adaptive
Markov logic networks: Learning statistical relational
models with dynamic parameters”. In: 9th European
Conf. on AI. 2009, 937–942.
[Jef04] R. Jeffrey. Subjective Probability: The Real
Thing. Cambridge, 2004.
[Jen+17] R. Jenatton, C. Archambeau, J. González,
and M. Seeger. “Bayesian Optimization with Tree￾structured Dependencies”. en. In: ICML. 2017,
pp. 1655–1664.
[Jeu+19] O. Jeunen, D. Mykhaylov, D. Rohde, F.
Vasile, A. Gilotte, and M. Bompaire. “Learning from
Bandit Feedback: An Overview of the State-of-the￾art”. In: (2019). arXiv: 1909.08471 [cs.IR].
[JG20] A. Jacovi and Y. Goldberg. “Towards faith￾fully interpretable NLP systems: How should we de￾fine and evaluate faithfulness?” In: arXiv preprint
arXiv:2004.03685 (2020).
[JG21] A. Jacovi and Y. Goldberg. “Aligning faith￾ful interpretations with their social attribution”. In:
Transactions of the Association for Computational
Linguistics 9 (2021), pp. 294–310.
[JGH18] A. Jacot, F. Gabriel, and C. Hongler. “Neu￾ral Tangent Kernel: Convergence and Generalization
in Neural Networks”. In: NIPS. 2018.
[JGP17] E. Jang, S. Gu, and B. Poole. “Categorical
Reparameterization with Gumbel-Softmax”. In: ICLR.
2017.
[Jha+22] S. Jha, D. Gong, X. Wang, R. E. Turner, and
L. Yao. “The Neural Process Family: Survey, Applica￾tions and Perspectives”. In: (Sept. 2022). arXiv: 2209.
00517 [cs.LG].
[Ji+22] Z. Ji et al. “Survey of Hallucination in Natural
Language Generation”. In: ACM Computing Surveys
(Feb. 2022).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Jia+19] R. Jia, A. Raghunathan, K. Göksel, and P.
Liang. “Certified Robustness to Adversarial Word Sub￾stitutions”. In: EMNLP. 2019.
[Jia+21] C. Jia, Y. Yang, Y. Xia, Y.-T. Chen, Z.
Parekh, H. Pham, Q. V. Le, Y. Sung, Z. Li, and T.
Duerig. Scaling Up Visual and Vision-Language Rep￾resentation Learning With Noisy Text Supervision.
2021. arXiv: 2102.05918 [cs.CV].
[Jia21] H. Jiang. “Minimizing convex functions with in￾tegral minimizers”. In: Proceedings of the 2021 ACM￾SIAM Symposium on Discrete Algorithms (SODA).
SIAM. 2021, pp. 976–985.
[Jih+12] Jihong Min, J Kim, Seunghak Shin, and I. S.
Kweon. “Efficient Data-Driven MCMC sampling for
vision-based 6D SLAM”. In: ICRA. 2012, pp. 3025–
3032.
[Jin11] Y. Jin. “Surrogate-assisted evolutionary com￾putation: Recent advances and future challenges”. In:
Swarm and Evolutionary Computation 1.2 (2011),
pp. 61–70.
[Jit+16] W. Jitkrittum, Z. Szabó, K. P. Chwialkowski,
and A. Gretton. “Interpretable Distribution Features
with Maximum Testing Power”. In: NIPS. Curran As￾sociates, Inc., 2016, pp. 181–189.
[JJ00] T. S. Jaakkola and M. I. Jordan. “Bayesian
parameter estimation via variational methods”. In:
Statistics and Computing 10 (2000), pp. 25–37.
[JKG18] H. Jiang, B. Kim, and M. Y. Guan. “To Trust
Or Not To Trust A Classifier”. In: NIPS. 2018.
[JKK95] C. S. Jensen, A. Kong, and U. Kjaerulff.
“Blocking-Gibbs Sampling in Very Large Probabilistic
Expert Systems”. In: Intl. J. Human-Computer Stud￾ies (1995), pp. 647–666.
[JL15a] V. Jalali and D. Leake. “CBR meets big data:
A case study of large-scale adaptation rule generation”.
In: International Conference on Case-Based Reason￾ing. Springer. 2015, pp. 181–196.
[JL15b] V. Jalali and D. B. Leake. “Enhancing case￾based regression with automatically-generated ensem￾bles of adaptations”. In: Journal of Intelligent Infor￾mation Systems 46 (2015), pp. 237–258.
[JL16] N. Jiang and L. Li. “Doubly Robust Off-policy
Evaluation for Reinforcement Learning”. In: ICML.
2016, pp. 652–661.
[JM00] D. Jurafsky and J. H. Martin. Speech and lan￾guage processing: An Introduction to Natural Lan￾guage Processing, Computational Linguistics, and
Speech Recognition. Prentice-Hall, 2000.
[JM08] D. Jurafsky and J. H. Martin. Speech and lan￾guage processing: An Introduction to Natural Lan￾guage Processing, Computational Linguistics, and
Speech Recognition. 2nd edition. Prentice-Hall, 2008.
[JM18] A. Jolicoeur-Martineau. “The relativistic dis￾criminator: a key element missing from standard
GAN”. In: arXiv preprint arXiv:1807.00734 (2018).
[JM70] D. H. Jacobson and D. Q. Mayne. Differential
Dynamic Programming. Elsevier Press, 1970.
[JMW06] J. K. Johnson, D. M. Malioutov, and A. S.
Willsky. “Walk-sum interpretation and analysis of
Gaussian belief propagation”. In: NIPS. 2006, pp. 579–
586.
[JNJ20] C. Jin, P. Netrapalli, and M. I. Jordan. “What
is local optimality in nonconvex-nonconcave minimax
optimization?” In: Proceedings of the 34th Interna￾tional Conference on Machine Learning-Volume 73.
2020.
[JO18] M. Jankowiak and F. Obermeyer. “Pathwise
Derivatives Beyond the Reparameterization Trick”. In:
ICML. 2018.
[JOA10] T. Jaksch, R. Ortner, and P. Auer. “Near￾optimal Regret Bounds for Reinforcement Learning”.
In: JMLR 11 (2010), pp. 1563–1600.
[JOA17] P. E. Jacob, J. O’Leary, and Y. F. Atchadé.
“Unbiased Markov Chain Monte Carlo with couplings”.
In: arXiv preprint arXiv:1708.03625 (2017).
[Joh12] M. J. Johnson. “A Simple Explanation of A
Spectral Algorithm for Learning Hidden Markov Mod￾els”. In: (2012). arXiv: 1204.2477 [stat.ME].
[Jon01] D. R. Jones. “A Taxonomy of Global Opti￾mization Methods Based on Response Surfaces”. In:
J. Global Optimiz. 21.4 (2001), pp. 345–383.
[Jor07] M. I. Jordan. An Introduction to Probabilistic
Graphical Models. In preparation. 2007.
[Jor+22] J. Jordon, L. Szpruch, F. Houssiau, M.
Bottarelli, G. Cherubin, C. Maple, S. N. Cohen, and
A. Weller. “Synthetic Data – what, why and how?” In:
(May 2022). arXiv: 2205.03257 [cs.LG].
[Jor+98] M. I. Jordan, Z. Ghahramani, T. S. Jaakkola,
and L. K. Saul. “An introduction to variational meth￾ods for graphical models”. In: Learning in Graphical
Models. Ed. by M. Jordan. MIT Press, 1998.
[Jos+17] A. Joshi, S. Ghosh, M. Betke, S. Sclaroff, and
H. Pfister. “Personalizing gesture recognition using hi￾erarchical Bayesian neural networks”. In: CVPR. Hon￾olulu, HI: IEEE, July 2017.
[Jos20] C. Joshi. Transformers are Graph Neural Net￾works. Tech. rep. 2020.
[Jos+20] M. Joshi, D. Chen, Y. Liu, D. S. Weld, L.
Zettlemoyer, and O. Levy. “Spanbert: Improving pre￾training by representing and predicting spans”. In:
Transactions of the Association for Computational
Linguistics 8 (2020), pp. 64–77.
[Jos+22] L. V. Jospin, W. Buntine, F. Boussaid, H.
Laga, and M. Bennamoun. “Hands-on Bayesian Neu￾ral Networks — a Tutorial for Deep Learning Users”.
In: (2022).
[Jou+16] A. Joulin, L. Van Der Maaten, A. Jabri, and
N. Vasilache. “Learning visual features from large
weakly supervised data”. In: European Conference on
Computer Vision. Springer. 2016, pp. 67–84.
[JP95] R. Jirousek and S. Preucil. “On the effective im￾plementation of the iterative proportional fitting pro￾cedure”. In: Computational Statistics & Data Analy￾sis 19 (1995), pp. 177–189.
[JS93] M. Jerrum and A. Sinclair. “Polynomial-time ap￾proximation algorithms for the Ising model”. In: SIAM
J. on Computing 22 (1993), pp. 1087–1116.
[JS96] M. Jerrum and A. Sinclair. “The Markov chain
Monte Carlo method: an approach to approximate
counting and integration”. In: Approximation Algo￾rithms for NP-hard problems. Ed. by D. S. Hochbaum.
PWS Publishing, 1996.
[JSY19] P. Jaini, K. A. Selby, and Y. Yu. “Sum-of￾Squares Polynomial Flow”. In: ICML. 2019, pp. 3009–
3018.
[JU97] S. Julier and J. Uhlmann. “A New Extension of
the Kalman Filter to Nonlinear Systems”. In: Proc. of
AeroSense: The 11th Intl. Symp. on Aerospace/De￾fence Sensing, Simulation and Controls. 1997.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1276
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[JUDW00] S Julier, J Uhlmann, and H. F. Durrant￾Whyte. “A new method for the nonlinear transforma￾tion of means and covariances in filters and estima￾tors”. In: IEEE Trans. Automat. Contr. 45.3 (Mar.
2000), pp. 477–482.
[JW14] M. Johnson and A. Willsky. “Stochastic Varia￾tional Inference for Bayesian Time Series Models”. en.
In: ICML. 2014, pp. 1854–1862.
[JW19] S. Jain and B. C. Wallace. “Attention is not
explanation”. In: arXiv preprint arXiv:1902.10186
(2019).
[Kaa12] Kaare Brandt Petersen and Michael Syskind
Pedersen. The Matrix Cookbook. 2012.
[Kad+22] J. Kaddour, A. Lynch, Q. Liu, M. J. Kusner,
and R. Silva. “Causal Machine Learning: A Survey and
Open Problems”. In: (June 2022). arXiv: 2206.15475
[cs.LG].
[KAG19] A. Kirsch, J. van Amersfoort, and Y. Gal.
“BatchBALD: Efficient and Diverse Batch Acquisition
for Deep Bayesian Active Learning”. In: NIPS. 2019.
[KAH19] F. H. Kingma, P. Abbeel, and J. Ho. “Bit￾Swap: Recursive Bits-Back Coding for Lossless Com￾pression with Hierarchical Latent Variables”. In:
ICML. 2019.
[Kai58] H. Kaiser. “The varimax criterion for analytic
rotation in factor analysis”. In: Psychometrika 23.3
(1958).
[Kak02] S. M. Kakade. “A Natural Policy Gradient”. In:
NIPS. 2002, pp. 1531–1538.
[Kal+11] M. Kalakrishnan, S. Chitta, E. A. Theodorou,
P. Pastor, and S. Schaal. “STOMP: Stochastic Tra￾jectory Optimization for Motion Planning”. In: ICRA.
2011, pp. 4569–4574.
[Kal+18a] D. Kalashnikov et al. “QT-Opt: Scal￾able Deep Reinforcement Learning for Vision-Based
Robotic Manipulation”. In: CORL. 2018.
[Kal+18b] N. Kalchbrenner, E. Elsen, K. Simonyan, S.
Noury, N. Casagrande, E. Lockhart, F. Stimberg, A.
Oord, S. Dieleman, and K. Kavukcuoglu. “Efficient
neural audio synthesis”. In: International Conference
on Machine Learning. PMLR. 2018, pp. 2410–2419.
[Kam16] E. Kamar. “Directions in Hybrid Intelligence:
Complementing AI Systems with Human Intelligence.”
In: IJCAI. 2016, pp. 4070–4073.
[Kam+22] S. Kamthe, S. Takao, S. Mohamed, and
M. P. Deisenroth. “Iterative state estimation in non￾linear dynamical systems using approximate expecta￾tion propagation”. In: Trans. on Machine Learning
Research (2022).
[Kan+20] T. Kaneko, H. Kameoka, K. Tanaka, and
N. Hojo. “CycleGAN-VC3: Examining and Improving
CycleGAN-VCs for Mel-spectrogram Conversion”. In:
Interspeech conference proceedings (2020).
[Kan42] L. Kantorovich. “On the transfer of masses (in
Russian)”. In: Doklady Akademii Nauk 37.2 (1942),
pp. 227–229.
[Kap+22] S. Kapoor, W. J. Maddox, P. Izmailov, and
A. G. Wilson. “On Uncertainty, Tempering, and Data
Augmentation in Bayesian Classification”. In: arXiv
preprint arXiv:2203.16481 (2022).
[Kar+18] T. Karras, T. Aila, S. Laine, and J. Lehtinen.
“Progressive Growing of GANs for Improved Quality,
Stability, and Variation”. In: ICLR. 2018.
[Kar+20a] A.-H. Karimi, G. Barthe, B. Balle, and I.
Valera. Model-Agnostic Counterfactual Explanations
for Consequential Decisions. 2020. arXiv: 1905.11190
[cs.LG].
[Kar+20b] A.-H. Karimi, G. Barthe, B. Schölkopf, and
I. Valera. “A survey of algorithmic recourse: defi￾nitions, formulations, solutions, and prospects”. In:
arXiv preprint arXiv:2010.04050 (2020).
[Kar+20c] T. Karras, S. Laine, M. Aittala, J. Hell￾sten, J. Lehtinen, and T. Aila. “Analyzing and improv￾ing the image quality of stylegan”. In: Proceedings of
the IEEE/CVF Conference on Computer Vision and
Pattern Recognition. 2020, pp. 8110–8119.
[Kar+21] T. Karras, M. Aittala, S. Laine, E. Härkö￾nen, J. Hellsten, J. Lehtinen, and T. Aila. “Alias-Free
Generative Adversarial Networks”. In: arXiv preprint
arXiv:2106.12423 (2021).
[Kar+22] T. Karras, M. Aittala, T. Aila, and S. Laine.
“Elucidating the Design Space of Diffusion-Based Gen￾erative Models”. In: NIPS. June 2022.
[Kat05] T. Katayama. Subspace Methods for Systems
Identification. Springer Verlag, 2005.
[Kat+06] H. G. Katzgraber, S. Trebst, D. A. Huse,
and M. Troyer. “Feedback-optimized parallel temper￾ing Monte Carlo”. In: Journal of Statistical Mechan￾ics: Theory and Experiment 2006.03 (2006), P03018.
[Kat+17] G. Katz, C. Barrett, D. L. Dill, K. Julian,
and M. J. Kochenderfer. “Reluplex: An efficient SMT
solver for verifying deep neural networks”. In: Interna￾tional Conference on Computer Aided Verification.
Springer. 2017, pp. 97–117.
[Kat+19] N. Kato, H. Osone, K. Oomori, C. W. Ooi,
and Y. Ochiai. “GANs-Based Clothes Design: Pat￾tern Maker Is All You Need to Design Clothing”. In:
Proceedings of the 10th Augmented Human Interna￾tional Conference 2019. Association for Computing
Machinery, 2019.
[Kau+19] V. Kaushal, R. Iyer, S. Kothawade, R. Ma￾hadev, K. Doctor, and G. Ramakrishnan. “Learning
from less data: A unified data subset selection and ac￾tive learning framework for computer vision”. In: 2019
IEEE Winter Conference on Applications of Com￾puter Vision (WACV). IEEE. 2019, pp. 1289–1299.
[Kau+20] H. Kaur, H. Nori, S. Jenkins, R. Caruana,
H. Wallach, and J. Wortman Vaughan. “Interpreting
interpretability: understanding data scientists’ use of
interpretability tools for machine learning”. In: Pro￾ceedings of the 2020 CHI conference on human fac￾tors in computing systems. 2020, pp. 1–14.
[Kau+21] D. Kaushik, A. Setlur, E. Hovy, and Z. C.
Lipton. “Explaining The Efficacy of Counterfactually
Augmented Data”. In: ICLR. 2021.
[KB00] H. J. Kushner and A. S. Budhiraja. “A non￾linear filtering algorithm based on an approximation
of the conditional distribution”. In: IEEE Trans. Au￾tomat. Contr. 45.3 (2000), pp. 580–585.
[KB14a] D. P. Kingma and J. Ba. “Adam: A method
for stochastic optimization”. In: arXiv preprint
arXiv:1412.6980 (2014).
[KB14b] K. Kirchhoff and J. Bilmes. “Submodular￾ity for Data Selection in Machine Translation”. In:
Empirical Methods in Natural Language Processing
(EMNLP). 2014.
[KB16] T. Kim and Y. Bengio. “Deep directed genera￾tive models with energy-based probability estimation”.
In: arXiv preprint arXiv:1606.03439 (2016).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[KBH19] F. Kunstner, L. Balles, and P. Hennig. “Lim￾itations of the Empirical Fisher Approximation”. In:
(2019). arXiv: 1905.12558 [cs.LG].
[KCC20] V. Kumar, A. Choudhary, and E. Cho. “Data
Augmentation using Pre-trained Transformer Mod￾els”. In: Proceedings of the 2nd Workshop on Life￾long Learning for Spoken Language Systems. Suzhou,
China: Association for Computational Linguistics,
Dec. 2020, pp. 18–26.
[KD18a] S. Kamthe and M. P. Deisenroth. “Data￾Efficient Reinforcement Learning with Probabilistic
Model Predictive Control”. In: AISTATS. 2018.
[KD18b] D. P. Kingma and P. Dhariwal. “Glow: Gen￾erative Flow with Invertible 1×1 Convolutions”. In:
NIPS. 2018.
[Ke+19a] L. Ke, M. Barnes, W. Sun, G. Lee, S.
Choudhury, and S. Srinivasa. “Imitation Learning
as f-Divergence Minimization”. In: arXiv preprint
arXiv:1905.12888 (2019).
[Ke+19b] L. Ke, S. Choudhury, M. Barnes, W. Sun,
G. Lee, and S. Srinivasa. Imitation Learning as f￾Divergence Minimization. arXiv:1905.12888. 2019.
[Ke+21] A. Ke, W. Ellsworth, O. Banerjee, A. Y. Ng,
and P. Rajpurkar. “CheXtransfer: performance and pa￾rameter efficiency of ImageNet models for chest X-Ray
interpretation”. In: Proceedings of the Conference on
Health, Inference, and Learning. 2021, pp. 116–124.
[Kei06] F. C. Keil. “Explanation and understanding”.
In: Annu. Rev. Psychol. 57 (2006), pp. 227–254.
[Kel+20] J. Kelly, J. Bettencourt, M. J. Johnson, and
D. Duvenaud. “Learning Differential Equations that
are Easy to Solve”. In: Neural Information Process￾ing Systems. 2020.
[Kel21] R. Kelter. “Bayesian model selection in the
M-open setting — Approximate posterior inference
and subsampling for efficient large-scale leave-one-out
cross-validation via the difference estimator”. In: J.
Math. Psychol. 100 (Feb. 2021), p. 102474.
[Ken16] E. H. Kennedy. “Semiparametric theory and
empirical processes in causal inference”. In: Statisti￾cal causal inferences and their applications in pub￾lic health research. ICSA Book Ser. Stat. Springer,
[Cham], 2016, pp. 141–167.
[Ken17] E. H. Kennedy. Semiparametric theory. 2017.
arXiv: 1709.06418 [stat.ME].
[Ken20] E. H. Kennedy. Optimal doubly robust esti￾mation of heterogeneous causal effects. 2020. arXiv:
2004.14497 [math.ST].
[Ken93] G. Kenji. 100 Statistical Tests. Sage Publica￾tions, 1993.
[Kes+17] N. S. Keskar, D. Mudigere, J. Nocedal, M.
Smelyanskiy, and P. T. P. Tang. “On Large-Batch
Training for Deep Learning: Generalization Gap and
Sharp Minima”. In: ICLR. 2017.
[KF09a] D. Koller and N. Friedman. Probabilistic
Graphical Models: Principles and Techniques. MIT
Press, 2009.
[KF09b] D. Krishnan and R. Fergus. “Fast Image De￾convolution using Hyper-Laplacian Priors”. In: NIPS.
2009, pp. 1033–1041.
[KFL01] F. Kschischang, B. Frey, and H.-A. Loeliger.
“Factor Graphs and the Sum-Product Algorithm”. In:
IEEE Trans Info. Theory (2001).
[KG05] A. Krause and C. Guestrin. “Near-optimal Non￾myopic Value of Information in Graphical Models”. In:
Proc. of the 21st Annual Conf. on Uncertainty in
Artificial Intelligence (UAI 2005). AUAI Press, 2005,
pp. 324–331.
[KG17] A. Kendall and Y. Gal. “What Uncertainties
Do We Need in Bayesian Deep Learning for Com￾puter Vision?” In: NIPS. Curran Associates, Inc.,
2017, pp. 5574–5584.
[KGO12] H. J. Kappen, V. Gómez, and M. Opper. “Op￾timal control as a graphical model inference problem”.
In: Mach. Learn. 87.2 (2012), pp. 159–182.
[KGV22] K. Kreis, R. Gao, and A. Vahdat. Denoising
diffusion-based generative modeling: foundations and
applications. CVPR Tutorial. 2022.
[KH22] L. Kurscheidt and M. Hein. “Lost in Transla￾tion: Modern Image Classifiers still degrade even un￾der simple Translations”. In: ICML 2022 Shift Hap￾pens Workshop. July 2022.
[Kha+10] M. E. Khan, B. Marlin, G. Bouchard, and
K. P. Murphy. “Variational bounds for mixed-data fac￾tor analysis”. In: NIPS. 2010.
[Kha+18] M. E. Khan, D. Nielsen, V. Tangkaratt, W.
Lin, Y. Gal, and A. Srivastava. “Fast and Scalable
Bayesian Deep Learning by Weight-Perturbation in
Adam”. In: ICML. 2018.
[Kha20] M. E. Khan. Deep learning with Bayesian
principles. NeurIPS tutorial. 2020.
[Kha+21] S. Khan, M. Naseer, M. Hayat, S. W. Zamir,
F. S. Khan, and M. Shah. “Transformers in Vision:
A Survey”. In: ACM Computing Surveys December
(2021).
[Khe+20] I. Khemakhem, R. Monti, D. Kingma, and
A. Hyvarinen. “ICE-BeeM: Identifiable Conditional
Energy-Based Deep Models Based on Nonlinear ICA”.
In: NIPS. Vol. 33. 2020, pp. 12768–12778.
[KHH20] A. Kristiadi, M. Hein, and P. Hennig. “Being
Bayesian, Even Just a Bit, Fixes Overconfidence in
ReLU Networks”. In: ICML. 2020.
[KHL20] D. Kaushik, E. Hovy, and Z. C. Lipton.
Learning the Difference that Makes a Difference with
Counterfactually-Augmented Data. 2020. arXiv: 1909.
12434 [cs.CL].
[Kho+20] P. Khosla, P. Teterwak, C. Wang, A. Sarna,
Y. Tian, P. Isola, A. Maschinot, C. Liu, and D. Kr￾ishnan. “Supervised Contrastive Learning”. In: ArXiv
abs/2004.11362 (2020).
[Kil+20] K. Killamsetty, D. Sivasubramanian, G. Ra￾makrishnan, and R. Iyer. “GLISTER: Generalization
based Data Subset Selection for Efficient and Ro￾bust Learning”. In: arXiv preprint arXiv:2012.10630
(2020).
[Kim+18a] B. Kim, M. Wattenberg, J. Gilmer, C. Cai,
J. Wexler, F. Viegas, and R. Sayres. “Interpretabil￾ity Beyond Feature Attribution: Quantitative Testing
with Concept Activation Vectors (TCAV)”. In: ICML.
2018.
[Kim+18b] B. Kim, M. Wattenberg, J. Gilmer, C. Cai,
J. Wexler, F. Viegas, et al. “Interpretability beyond
feature attribution: Quantitative testing with concept
activation vectors (tcav)”. In: International confer￾ence on machine learning. PMLR. 2018, pp. 2668–
2677.
[Kim+18c] Y. Kim, S. Wiseman, A. C. Miller, D. Son￾tag, and A. M. Rush. “Semi-Amortized Variational Au￾toencoders”. In: ICML. 2018.
[Kim+19] S. Kim, S.-G. Lee, J. Song, J. Kim, and S.
Yoon. “FloWaveNet : A Generative Flow for Raw Au￾Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1278
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
dio”. In: Proceedings of the 36th International Con￾ference on Machine Learning. 2019, pp. 3370–3378.
[Kim+22] S. Kim, P. Y. Lu, C. Loh, J. Smith,
J. Snoek, and M. Soljačić. “Deep Learning for
Bayesian Optimization of Scientific Problems with
High-Dimensional Structure”. In: TMLR (2022).
[Kin+14a] D. P. Kingma, D. J. Rezende, S. Mohamed,
and M. Welling. “Semi-Supervised Learning with Deep
Generative Models”. In: NIPS. 2014.
[Kin+14b] D. P. Kingma, D. J. Rezende, S. Mohamed,
and M. Welling. Semi-Supervised Learning with Deep
Generative Models. 2014. arXiv: 1406.5298 [cs.LG].
[Kin+16] D. P. Kingma, T. Salimans, R. Jozefowicz, X.
Chen, I. Sutskever, and M. Welling. “Improved Varia￾tional Inference with Inverse Autoregressive Flow”. In:
NIPS. 2016.
[Kin+19] P.-J. Kindermans, S. Hooker, J. Adebayo, M.
Alber, K. T. Schütt, S. Dähne, D. Erhan, and B.
Kim. “The (un) reliability of saliency methods”. In:
Explainable AI: Interpreting, Explaining and Visu￾alizing Deep Learning. Springer, 2019, pp. 267–280.
[Kin+21] D. P. Kingma, T. Salimans, B. Poole, and
J. Ho. “Variational Diffusion Models”. In: NIPS. July
2021.
[Kir+17] J. Kirkpatrick et al. “Overcoming catas￾trophic forgetting in neural networks”. en. In: PNAS
114.13 (2017), pp. 3521–3526.
[Kir+21] A. Kirsch, J. M. J. van Amersfoort, P. H. S.
Torr, and Y. Gal. “On pitfalls in OoD detection: Pre￾dictive entropy considered harmful”. In: ICML Work￾shop on Uncertainty in Deep Learning. 2021.
[Kit04] G. Kitagawa. “The two-filter formula for
smoothing and an implementation of the Gaussian￾sum smoother”. In: Annals of the Institute of Sta￾tistical Mathematics 46.4 (2004), pp. 605–623.
[Kiv+21] B. Kivva, G. Rajendran, P. Ravikumar, and
B. Aragam. “Learning latent causal graphs via mix￾ture oracles”. In: NIPS. June 2021.
[Kiv+22] B. Kivva, G. Rajendran, P. Ravikumar, and
B. Aragam. “Identifiability of deep generative models
under mixture priors without auxiliary information”.
In: (June 2022). arXiv: 2206.10044 [cs.LG].
[KIW20] P. Kirichenko, P. Izmailov, and A. G. Wil￾son. “Why Normalizing Flows Fail to Detect Out￾of-Distribution Data”. In: (2020). arXiv: 2006 . 08545
[stat.ML].
[KJ12] J. Z. Kolter and T. S. Jaakkola. “Approximate
Inference in Additive Factorial HMMs with Applica￾tion to Energy Disaggregation”. In: AISTATS. 2012.
[Kja90] U. Kjaerulff. Triangulation of graphs – algo￾rithms giving small total state space. Tech. rep. R￾90-09. Dept. of Math. and Comp. Sci., Aalborg Univ.,
Denmark, 1990.
[Kja92] U. Kjaerulff. “Optimal decomposition of prob￾abilistic networks by simulated annealing”. In: Statis￾tics and Computing. Vol. 2. 1992, pp. 7–17.
[KJD18] J. Knoblauch, J. Jewson, and T. Damoulas.
“Doubly Robust Bayesian Inference for Non￾Stationary Streaming Data with β-Divergences”. In:
NIPS. 2018.
[KJD19] J. Knoblauch, J. Jewson, and T. Damoulas.
“Generalized Variational Inference: Three arguments
for deriving new Posteriors”. In: (2019). arXiv: 1904.
02063 [stat.ML].
[KJD21] J. Knoblauch, J. Jewson, and T. Damoulas.
“An Optimization-centric View on Bayes’ Rule: Re￾viewing and Generalizing Variational Inference”. In:
JMLR (2021).
[KJM19] N. M. Kriege, F. D. Johansson, and C. Mor￾ris. “A Survey on Graph Kernels”. In: (2019). arXiv:
1903.11835 [cs.LG].
[KJV83] S. Kirkpatrick, C. G. Jr., and M. Vecchi. “Op￾timization by simulated annealing”. In: Science 220
(1983), pp. 671–680.
[KK11] P. Krähenbühl and V. Koltun. “Efficient Infer￾ence in Fully Connected CRFs with Gaussian Edge
Potentials”. In: NIPS. 2011.
[KKG22] A. Kirsch, J. Kossen, and Y. Gal. “Marginal
and Joint Cross-Entropies & Predictives for Online
Bayesian Inference, Active Learning, and Active Sam￾pling”. In: (May 2022). arXiv: 2205.08766 [cs.LG].
[KKH20] I. Khemakhem, D. P. Kingma, and A. Hyväri￾nen. “Variational Autoencoders and Nonlinear ICA: A
Unifying Framework”. In: AISTATS. 2020.
[KKL20] N. Kitaev, L. Kaiser, and A. Levskaya. “Re￾former: The Efficient Transformer”. In: 8th Inter￾national Conference on Learning Representations,
ICLR 2020, Addis Ababa, Ethiopia, April 26-30,
2020. OpenReview.net, 2020.
[KKR95] K. Kanazawa, D. Koller, and S. Russell.
“Stochastic Simulation Algorithms for Dynamic Prob￾abilistic Networks”. In: UAI. 1995.
[KKS20] F. Kunstner, R. Kumar, and M. Schmidt.
“Homeomorphic-Invariance of EM: Non-Asymptotic
Convergence in KL Divergence for Exponential Fami￾lies via Mirror Descent”. In: (2020). arXiv: 2011.01170
[cs.LG].
[KKT03] D. Kempe, J. Kleinberg, and É. Tardos.
“Maximizing the spread of influence through a social
network”. In: Proceedings of the ninth ACM SIGKDD
international conference on Knowledge discovery
and data mining. 2003, pp. 137–146.
[KL02] S. Kakade and J. Langford. “Approximately
Optimal Approximate Reinforcement Learning”. In:
ICML. ICML ’02. Morgan Kaufmann Publishers Inc.,
2002, pp. 267–274.
[KL09] H. Kawakatsu and A. Largey. “EM algorithms
for ordered probit models with endogenous regressors”.
In: The Econometrics Journal 12.1 (2009), pp. 164–
186.
[KL10] D. P. Kingma and Y. LeCun. “Regularized es￾timation of image statistics by score matching”. In:
Advances in neural information processing systems.
2010, pp. 1126–1134.
[KL17a] M. E. Khan and W. Lin. “Conjugate￾Computation Variational Inference : Converting Vari￾ational Inference in Non-Conjugate Models to Infer￾ences in Conjugate Models”. In: AISTATS. 2017.
[KL17b] P. W. Koh and P. Liang. “Understanding
black-box predictions via influence functions”. In: In￾ternational Conference on Machine Learning. PMLR.
2017, pp. 1885–1894.
[KL17c] J. K. Kruschke and T. M. Liddell. “The
Bayesian New Statistics: Hypothesis testing, esti￾mation, meta-analysis, and power analysis from a
Bayesian perspective”. In: Psychon. Bull. Rev. (2017).
[KL21] W. M. Kouw and M. Loog. “A review of domain
adaptation without target labels”. en. In: IEEE Trans.
Pattern Anal. Mach. Intell. (2021).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Kla+06] M. Klaas, M. Briers, N. de Freitas, A. Doucet,
S. Maskell, and D. Lang. “Fast Particle Smoothing: If
I Had a Million Particles”. In: ICML. 2006.
[KLA19] T. Karras, S. Laine, and T. Aila. “A Style￾Based Generator Architecture for Generative Adver￾sarial Networks”. In: CVPR. 2019.
[KLC98] L. P. Kaelbling, M. Littman, and A. Cas￾sandra. “Planning and acting in Partially Observable
Stochastic Domains”. In: AIJ 101 (1998).
[Kle+11] A. Kleiner, A. Talwalkar, P. Sarkar, and M. I.
Jordan. A scalable bootstrap for massive data. Tech.
rep. UC Berkeley, 2011.
[Kle17] G. A. Klein. Sources of power: How people
make decisions. MIT press, 2017.
[Kle18] J. Kleinberg. “Inherent Trade-Offs in Algorith￾mic Fairness”. In: ACM International Conference on
Measurement and Modeling of Computer Systems.
SIGMETRICS ’18. Irvine, CA, USA: Association for
Computing Machinery, June 2018, p. 40.
[KLM19] A. Kumar, P. Liang, and T. Ma. “Verified Un￾certainty Calibration”. In: NIPS. 2019.
[KM00] J. Kwon and K. Murphy. Modeling Freeway
Traffic with Coupled HMMs. Tech. rep. Univ. Califor￾nia, Berkeley, 2000.
[KM08] U. Kjaerulff and A. Madsen. Bayesian Net￾works and Influence Diagrams: A Guide to Con￾struction and Analysis. Springer, 2008.
[KM22] J. Kuan and J. Mueller. “Back to the Basics:
Revisiting Out-of-Distribution Detection Baselines”.
In: ICML PODS Workshop. July 2022.
[KMB08] N. Kriegeskorte, M. Mur, and P. Bandettini.
“Representational similarity analysis - connecting the
branches of systems neuroscience”. en. In: Front. Syst.
Neurosci. 2 (Nov. 2008), p. 4.
[KML20] A. Kumar, T. Ma, and P. Liang. “Understand￾ing Self-Training for Gradual Domain Adaptation”. In:
ICML. Ed. by H. D. Iii and A. Singh. Vol. 119. Pro￾ceedings of Machine Learning Research. PMLR, 2020,
pp. 5468–5479.
[KMR16] J. Kleinberg, S. Mullainathan, and M. Ragha￾van. “Inherent trade-offs in the fair determination
of risk scores”. In: arXiv preprint arXiv:1609.05807
(2016).
[KMY04] D. Kersten, P. Mamassian, and A. Yuille.
“Object perception as Bayesian inference”. en. In:
Annu. Rev. Psychol. 55 (2004), pp. 271–304.
[KN09] J. Z. Kolter and A. Y. Ng. “Near-Bayesian Ex￾ploration in Polynomial Time”. In: ICML. 2009.
[KN95] R. Kneser and H. Ney. “Improved backing-off
for n-gram language modeling”. In: ICASSP. Vol. 1.
1995, pp. 181–184.
[KN98] C.-J. Kim and C. Nelson. State-Space Mod￾els with Regime-Switching: Classical and Gibbs￾Sampling Approaches with Applications. MIT Press,
1998.
[KNP11] K. Kersting, S. Natarajan, and D. Poole. Sta￾tistical Relational AI: Logic, Probability and Compu￾tation. Tech. rep. UBC, 2011.
[KNT20] I. Kostrikov, O. Nachum, and J. Tompson.
“Imitation Learning via Off-Policy Distribution Match￾ing”. In: ICLR. 2020.
[Koe05] R. Koenker. Quantile Regression. en. Cam￾bridge University Press, 2005.
[Koh+20a] P. W. Koh, T. Nguyen, Y. S. Tang, S. Muss￾mann, E. Pierson, B. Kim, and P. Liang. “Concept
bottleneck models”. In: International Conference on
Machine Learning. PMLR. 2020, pp. 5338–5348.
[Koh+20b] P. W. Koh et al. “WILDS: A Benchmark
of in-the-Wild Distribution Shifts”. In: (Dec. 2020).
arXiv: 2012.07421 [cs.LG].
[Kol+20] A. Kolesnikov, L. Beyer, X. Zhai, J.
Puigcerver, J. Yung, S. Gelly, and N. Houlsby. “Big
transfer (BiT): General visual representation learning”.
In: ECCV. Springer. 2020, pp. 491–507.
[Koo03] G. Koop. Bayesian econometrics. Wiley, 2003.
[Kor+15] A. Korattikara, V. Rathod, K. Murphy, and
M. Welling. “Bayesian Dark Knowledge”. In: NIPS.
2015.
[Kor+19] S. Kornblith, M. Norouzi, H. Lee, and G. Hin￾ton. “Similarity of neural network representations re￾visited”. In: arXiv preprint arXiv:1905.00414 (2019).
[Kor+20] A. Korotin, V. Egiazarian, A. Asadulaev, A.
Safin, and E. Burnaev. “Wasserstein-2 Generative Net￾works”. In: International Conference on Learning
Representations. 2020.
[Kor+21] S. Kornblith, T. Chen, H. Lee, and M.
Norouzi. “Why do better loss functions lead to less
transferable features?” In: Advances in Neural Infor￾mation Processing Systems. Vol. 34. 2021.
[Kot+17] L. Kotthoff, C. Thornton, H. H. Hoos, F. Hut￾ter, and K. Leyton-Brown. “Auto-WEKA 2.0: Auto￾matic model selection and hyperparameter optimiza￾tion in WEKA”. In: JMLR 18.25 (2017), pp. 1–5.
[Kot+22] S. Kothawade, V. Kaushal, G. Ramakrish￾nan, J. Bilmes, and R. Iyer. “PRISM: A Rich Class
of Parameterized Submodular Information Measures
for Guided Subset Selection”. In: Proceedings of the
AAAI Conference on Artificial Intelligence. 2022.
[Koy+10] S. Koyama, L. C. Pérez-Bolde, C. R. Shal￾izi, and R. E. Kass. “Approximate Methods for State￾Space Models”. en. In: JASA 105.489 (2010), pp. 170–
180.
[Koz92] J. R. Koza. Genetic Programming. https : / /
mitpress . mit . edu / books / genetic - programming. Ac￾cessed: 2017-11-26. 1992.
[KP20] A. Kumar and B. Poole. “On Implicit Regular￾ization in β-VAEs”. In: ICML. 2020.
[KPB19] I. Kobyzev, S. Prince, and M. A. Brubaker.
“Normalizing Flows: An Introduction and Review of
Current Methods”. In: (2019). arXiv: 1908 . 09257
[stat.ML].
[KPHL17] M. J. Kusner, B. Paige, and J. M.
Hernández-Lobato. “Grammar Variational Autoen￾coder”. In: ICML. 2017.
[KPS98] J. T. Key, L. R. Pericchi, and A. F. Smith.
“Choosing among models when none of them are true”.
In: Proc. of the Workshop on Model Selection (1998).
[KPS99] J. T. Key, L. R. Pericchi, and A. F. Smith.
“Bayesian model choice: what and why”. In: Bayesian
statistics 6 6 (1999), pp. 343–370.
[KPT21] J. S. Kim, G. Plumb, and A. Talwalkar.
“Sanity Simulations for Saliency Methods”. In: arXiv
preprint arXiv:2105.06506 (2021).
[KR19] M. Kearns and A. Roth. The Ethical Algo￾rithm: The Science of Socially Aware Algorithm De￾sign. en. Oxford University Press, 2019.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1280
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[KR21a] M. Khan and H. Rue. “The Bayesian Learning
Rule”. In: (2021). arXiv: 2107.04562 [stat.ME].
[KR21b] S. Kong and D. Ramanan. “OpenGAN: Open￾Set Recognition via Open Data Generation”. In: ICCV.
2021.
[Kra+08] A. Krause, H Brendan McMahan, C.
Guestrin, and A. Gupta. “Robust Submodular Obser￾vation Selection”. In: JMLR 9 (2008), pp. 2761–2801.
[Kri+05] B. Krishnapuram, L. Carin, M. Figueiredo,
and A. Hartemink. “Learning sparse Bayesian classi￾fiers: multi-class formulation, fast algorithms, and gen￾eralization bounds”. In: IEEE Transaction on Pat￾tern Analysis and Machine Intelligence (2005).
[Kri19] N. Kriegeskorte. What’s the best measure of
representational dissimilarity? 2019.
[KRL08] K. Kavukcuoglu, M. Ranzato, and Y. LeCun.
“Fast Inference in Sparse Coding Algorithms with Ap￾plications to Object Recognition”. In: NIPS workshop
on optimization in machine learning. 2008.
[KRS14] B. Kim, C. Rudin, and J. A. Shah. “The
bayesian case model: A generative approach for case￾based reasoning and prototype classification”. In: Ad￾vances in neural information processing systems.
2014, pp. 1952–1960.
[Kru10] J. Kruschke. An open letter on Bayesian Data
Analysis. Tech. rep. U. Indiana, 2010.
[Kru13] J. K. Kruschke. “Bayesian estimation super￾sedes the t test”. In: J. Experimental Psychology:
General 142.2 (2013), pp. 573–603.
[Kru15] J. Kruschke. Doing Bayesian Data Analysis:
A Tutorial with R, JAGS and STAN. Second edition.
Academic Press, 2015.
[KS06] L. Kocsis and C. Szepesvári. “Bandit Based
Monte-Carlo Planning”. In: ECML. 2006, pp. 282–293.
[KS07] J. D. Y. Kang and J. L. Schafer. “Demystifying
double robustness: a comparison of alternative strate￾gies for estimating a population mean from incomplete
data”. In: Statist. Sci. 22.4 (2007), pp. 523–539.
[KS15] H. Kaya and A. A. Salah. “Adaptive Mixtures
of Factor Analyzers”. In: (2015). arXiv: 1507 . 02801
[stat.ML].
[KSB21] B. Kompa, J. Snoek, and A. Beam. “Empirical
Frequentist Coverage of Deep Learning Uncertainty
Quantification Procedures”. In: Entropy 23.12 (2021).
[KSC98] S. Kim, N. Shephard, and S. Chib. “Stochastic
Volatility: Likelihood Inference and Comparison with
ARCH Models”. In: Review of Economic Studies 65.3
(1998), pp. 361–393.
[KSH12a] A. Krizhevsky, I. Sutskever, and G. Hinton.
“Imagenet classification with deep convolutional neu￾ral networks”. In: NIPS. 2012.
[KSH12b] A. Krizhevsky, I. Sutskever, and G. E. Hin￾ton. “Imagenet classification with deep convolutional
neural networks”. In: Advances in neural information
processing systems. 2012, pp. 1097–1105.
[KSL19] S. Kornblith, J. Shlens, and Q. V. Le. “Do bet￾ter ImageNet models transfer better?” In: Proceedings
of the IEEE/CVF Conference on Computer Vision
and Pattern Recognition. 2019, pp. 2661–2671.
[KSL21] S. Kim, Q. Song, and F. Liang. “Stochastic
gradient Langevin dynamics with adaptive drifts”. In:
J. Stat. Comput. Simul. (2021), pp. 1–19.
[KSN99] N. L. Kleinman, J. C. Spall, and D. Q.
Naiman. “Simulation-Based Optimization with
Stochastic Approximation Using Common Random
Numbers”. In: Manage. Sci. 45.11 (1999), pp. 1570–
1578.
[KSS17] R. G. Krishnan, U. Shalit, and D. Sontag.
“Structured Inference Networks for Nonlinear State
Space Models”. In: AAAI. 2017.
[KSW15] D. P. Kingma, T. Salimans, and M. Welling.
“Variational Dropout and the Local Reparameteriza￾tion Trick”. In: NIPS. 2015.
[KT11] A. Kulesza and B. Taskar. “k-DPPs: Fixed-size
determinantal point processes”. In: ICML. 2011.
[KTB11] D. P. Kroese, T. Taimre, and Z. I. Botev.
Handbook of Monte Carlo Methods. en. 1 edition. Wi￾ley, 2011.
[KTX20] R. Kohavi, D. Tang, and Y. Xu. Trustworthy
Online Controlled Experiments: A Practical Guide to
A/B Testing. en. 1st ed. Cambridge University Press,
2020.
[KU21] S. Khan and J. Ugander. Adaptive normaliza￾tion for IPW estimation. 2021. arXiv: 2106 . 07695
[stat.ME].
[Kua+09] P. Kuan, G. Pan, J. A. Thomson, R. Stewart,
and S. Keles. A hierarchical semi-Markov model for
detecting enrichment with application to ChIP-Seq
experiments. Tech. rep. U. Wisconsin, 2009.
[Kub04] M. Kubale. Graph colorings. Vol. 352. Ameri￾can Mathematical Society, 2004.
[Kuc+16] A. Kucukelbir, D. Tran, R. Ranganath, A.
Gelman, and D. M. Blei. “Automatic Differentiation
Variational Inference”. In: JMLR (2016).
[Kuh55] H. W. Kuhn. “The Hungarian method for the
assignment problem”. In: Naval Research Logistics
Quarterly 2 (1955), pp. 83–97.
[Kul+13] T. Kulesza, S. Stumpf, M. Burnett, S. Yang,
I. Kwan, and W.-K. Wong. “Too much, too little, or
just right? Ways explanations impact end users’ men￾tal models”. In: 2013 IEEE Symposium on visual lan￾guages and human centric computing. IEEE. 2013,
pp. 3–10.
[Kul+19] M. Kull, M. Perello-Nieto, M. Kängsepp,
T. S. Filho, H. Song, and P. Flach. “Beyond tem￾perature scaling: Obtaining well-calibrated multiclass
probabilities with Dirichlet calibration”. In: NIPS.
2019.
[Kum+19a] A. Kumar, J. Fu, M. Soh, G. Tucker,
and S. Levine. “Stabilizing Off-Policy Q-Learning via
Bootstrapping Error Reduction”. In: NeurIPS. 2019,
pp. 11761–11771.
[Kum+19b] M. Kumar, M. Babaeizadeh, D. Erhan, C.
Finn, S. Levine, L. Dinh, and D. P. Kingma. “Vide￾oFlow: A flow-based generative model for video”. In:
ICML Workshop on Invertible Neural Networks and
Normalizing Flows (2019).
[Kum+19c] R. Kumar, S. Ozair, A. Goyal, A.
Courville, and Y. Bengio. “Maximum entropy gener￾ators for energy-based models”. In: arXiv preprint
arXiv:1901.08508 (2019).
[Kün+19] S. R. Künzel, J. S. Sekhon, P. J. Bickel, and
B. Yu. “Metalearners for estimating heterogeneous
treatment effects using machine learning”. In: Pro￾ceedings of the National Academy of Sciences 116.10
(2019), pp. 4156–4165. eprint: https://www.pnas.org/
content/116/10/4156.full.pdf.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Kun20] J. Kuntz. “Markov chains revisited”. In: (Jan.
2020). arXiv: 2001.02183 [math.PR].
[Kur+19] T. Kurutach, I. Clavera, Y. Duan, A. Tamar,
and P. Abbeel. “Model-Ensemble Trust-Region Policy
Optimization”. In: ICLR. 2019.
[Kur+20] R. Kurle, B. Cseke, A. Klushyn, P. van der
Smagt, and S. Günnemann. “Continual Learning with
Bayesian Neural Networks for Non-Stationary Data”.
In: ICLR. 2020.
[Kus+18] M. J. Kusner, J. R. Loftus, C. Russell, and
R. Silva. Counterfactual Fairness. 2018. arXiv: 1703.
06856 [stat.ML].
[Kus64] H. J. Kushner. “A New Method of Locating the
Maximum Point of an Arbitrary Multipeak Curve in
the Presence of Noise”. In: J. Basic Eng 86.1 (1964),
pp. 97–106.
[KVK10] A. Klami, S. Virtanen, and S. Kaski.
“Bayesian exponential family projections for coupled
data sources”. In: UAI. 2010.
[KW14] D. P. Kingma and M. Welling. “Auto-encoding
variational Bayes”. In: ICLR. 2014.
[KW18] A. S. I. Kim and M. P. Wand. “On expectation
propagation for generalised, linear and mixed models”.
In: Aust. N. Z. J. Stat. 60.1 (2018), pp. 75–102.
[KW19a] D. P. Kingma and M. Welling. “An Intro￾duction to Variational Autoencoders”. In: Founda￾tions and Trends in Machine Learning 12.4 (2019),
pp. 307–392.
[KW19b] M. J. Kochenderfer and T. A. Wheeler. Algo￾rithms for Optimization. en. The MIT Press, 2019.
[KW70] G. S. Kimeldorf and G. Wahba. “A Correspon￾dence Between Bayesian Estimation on Stochastic Pro￾cesses and Smoothing by Splines”. en. In: Ann. Math.
Stat. 41.2 (1970), pp. 495–502.
[KW96] R. E. Kass and L. Wasserman. “The Selection
of Prior Distributions by Formal Rules”. In: JASA
91.435 (1996), pp. 1343–1370.
[KWW22] M. J. Kochenderfer, T. A. Wheeler, and K.
Wray. Algorithms for Decision Making. The MIT
Press, 2022.
[KY94] J. J. Kosowsky and A. L. Yuille. “The invisible
hand algorithm: Solving the assignment problem with
statistical physics”. In: Neural networks 7.3 (1994),
pp. 477–490.
[Kyn+19] T. Kynkäänniemi, T. Karras, S. Laine, J.
Lehtinen, and T. Aila. “Improved Precision and Recall
Metric for Assessing Generative Models”. In: NeurIPS.
2019.
[KZ02] V. Kolmogorov and R. Zabih. “What energy
functions can be minimized via graph cuts?” In: Com￾puter Vision—ECCV 2002 (2002), pp. 185–208.
[KZB19] A. Kolesnikov, X. Zhai, and L. Beyer. “Re￾visiting self-supervised visual representation learn￾ing”. In: Proceedings of the IEEE/CVF conference
on computer vision and pattern recognition. 2019,
pp. 1920–1929.
[LA87] P. J. M. Laarhoven and E. H. L. Aarts,
eds. Simulated Annealing: Theory and Applications.
Kluwer Academic Publishers, 1987.
[Lag+19] I. Lage, E. Chen, J. He, M. Narayanan, B.
Kim, S. J. Gershman, and F. Doshi-Velez. “Human
evaluation of models built for interpretability”. In:
Proceedings of the AAAI Conference on Human
Computation and Crowdsourcing. Vol. 7. 1. 2019,
pp. 59–67.
[Lak+17] B. M. Lake, T. D. Ullman, J. B. Tenenbaum,
and S. J. Gershman. “Building Machines That Learn
and Think Like People”. en. In: Behav. Brain Sci.
(2017), pp. 1–101.
[Lal+21] A. Lal, M. W. Lockhart, Y. Xu, and Z. Zu.
“How Much Should We Trust Instrumental Variable
Estimates in Political Science? Practical Advice based
on Over 60 Replicated Studies”. In: (2021).
[Lam18] B. Lambert. A Student’s Guide to Bayesian
Statistics. en. 1st ed. SAGE Publications Ltd, 2018.
[Lam92] D. Lambert. “Zero-Inflated Poisson Regres￾sion, with an Application to Defects in Manufactur￾ing”. In: Technometrics 34.1 (1992), pp. 1–14.
[Lan95a] K. Lange. “A gradient algorithm locally equiv￾alent to the em algorithm”. en. In: J. of Royal Stat.
Soc. Series B 57.2 (July 1995), pp. 425–437.
[Lan95b] K. Lange. “A QUASI-NEWTON ACCELER￾ATION OF THE EM ALGORITHM”. In: Statistica
Sinica 5.1 (1995), pp. 1–18.
[Lao+20] J. Lao, C. Suter, I. Langmore, C. Chimisov,
A. Saxena, P. Sountsov, D. Moore, R. A. Saurous,
M. D. Hoffman, and J. V. Dillon. “tfp.mcmc: Modern
Markov Chain Monte Carlo Tools Built for Modern
Hardware”. In: PROBPROG. 2020.
[Lar+16] A. B. L. Larsen, S. K. Sonderby, H.
Larochelle, and O. Winther. “Autoencoding beyond
pixels using a learned similarity metric”. In: Interna￾tional conference on machine learning. PMLR. 2016,
pp. 1558–1566.
[Lar+22] B. W. Larsen, S. Fort, N. Becker, and S. Gan￾guli. “How many degrees of freedom do we need to
train deep networks: a loss landscape perspective”. In:
ICLR. 2022.
[Las08] K. B. Laskey. “MEBN: A language for first￾order Bayesian knowledge bases”. In: Artif. Intell.
172.2 (2008), pp. 140–178.
[Lau92] S. L. Lauritzen. “Propagation of probabilities,
means and variances in mixed graphical association
models”. In: JASA 87.420 (1992), pp. 1098–1108.
[Lau95] S. L. Lauritzen. “The EM algorithm for graph￾ical association models with missing data”. In: Com￾putational Statistics and Data Analysis 19 (1995),
pp. 191–201.
[Lav00] M. Lavine. What is Bayesian statistics and
why everything else is wrong. Tech. rep. Duke, 2000.
[Law05] N. D. Lawrence. “Probabilistic non-linear prin￾cipal component analysis with Gaussian process latent
variable models”. In: JMLR 6 (2005), pp. 1783–1816.
[Law+22] D. Lawson, A. Raventós, A. Warrington,
and S. Linderman. “SIXO: Smoothing Inference with
Twisted Objectives”. In: (June 2022). arXiv: 2206 .
05952 [cs.LG].
[LB09] H. Lin and J. A. Bilmes. “How to Select a Good
Training-data Subset for Transcription: Submodular
Active Selection for Sequences”. In: Proc. Annual
Conference of the International Speech Communica￾tion Association (INTERSPEECH). Brighton, UK,
2009.
[LB10a] H. Lin and J. Bilmes. “Multi-document Sum￾marization via Budgeted Maximization of Submodular
Functions”. In: North American chapter of the Asso￾ciation for Computational Linguistics/Human Lan￾Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1282
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
guage Technology Conference (NAACL/HLT-2010).
Los Angeles, CA, 2010.
[LB10b] H. Lin and J. A. Bilmes. “An Application
of the Submodular Principal Partition to Training
Data Subset Selection”. In: Neural Information Pro￾cessing Society (NeurIPS, formerly NIPS) Work￾shop. NeurIPS (formerly NIPS) Workshop on Dis￾crete Optimization in Machine Learning: Submodu￾larity, Sparsity & Polyhedra (DISCML). Vancouver,
Canada, 2010.
[LB11] H. Lin and J. Bilmes. “A Class of Submodu￾lar Functions for Document Summarization”. In: The
49th Annual Meeting of the Association for Compu￾tational Linguistics: Human Language Technologies
(ACL/HLT-2011). (long paper). Portland, OR, 2011.
[LB12] H. Lin and J. Bilmes. “Learning Mixtures of
Submodular Shells with Application to Document
Summarization”. In: Uncertainty in Artificial Intel￾ligence (UAI). Catalina Island, USA: AUAI, 2012.
[LB19] A. Levray and V. Belle. “Learning Tractable
Probabilistic Models in Open Worlds”. In: (2019).
arXiv: 1901.05847 [cs.LG].
[LBB20] Y. Liu, P.-L. Bacon, and E. Brunskill. “Un￾derstanding the Curse of Horizon in Off-Policy Evalua￾tion via Conditional Importance Sampling”. In: ICML.
2020.
[LBH15] Y. LeCun, Y. Bengio, and G. Hinton. “Deep
learning”. en. In: Nature 521.7553 (May 2015),
pp. 436–444.
[LBH22] X. Lu, A. Boukouvalas, and J. Hensman. “Ad￾ditive Gaussian Processes Revisited”. In: ICML. June
2022.
[LBL16] H. Lakkaraju, S. H. Bach, and J. Leskovec.
“Interpretable decision sets: A joint framework for de￾scription and prediction”. In: Proceedings of the 22nd
ACM SIGKDD international conference on knowl￾edge discovery and data mining. 2016, pp. 1675–1684.
[LBM06] J. A. Lasserre, C. M. Bishop, and T. P. Minka.
“Principled Hybrids of Generative and Discriminative
Models”. In: CVPR. Vol. 1. June 2006, pp. 87–94.
[LBS01] T. Lefebvre, H. Bruyninckx, and J. D. Schut￾ter. “Comment on “A New Method for the Nonlin￾ear Transformation of Means and Covariances in Fil￾ters and Estimators””. In: IEEE Trans. on Automatic
Control 47.8 (2001), pp. 1406–1409.
[LBS17] C. Lakshminarayanan, S. Bhatnagar, and C.
Szepesvári. “A Linearly Relaxed Approximate Linear
Program for Markov Decision Processes”. In: IEEE
Transactions on Automatic Control 63.4 (2017),
pp. 1185–1191.
[LBW17] T. A. Le, A. G. Baydin, and F. Wood. “In￾ference Compilation and Universal Probabilistic Pro￾gramming”. In: AISTATS. 2017.
[LC02] J. Langford and R. Caruana. “(Not) bounding
the true error”. In: NIPS. 2002.
[LCG12] Y. Lou, R. Caruana, and J. Gehrke. “Intelligi￾ble models for classification and regression”. In: Pro￾ceedings of the 18th ACM SIGKDD international
conference on Knowledge discovery and data mining.
2012, pp. 150–158.
[LCR21] T. Lesort, M. Caccia, and I. Rish. “Under￾standing Continual Learning Settings with Data Dis￾tribution Drift Analysis”. In: (2021). arXiv: 2104.01678
[cs.LG].
[LDZ11] Y Li, H Duan, and C. X. Zhai. “Cloudspeller:
Spelling correction for search queries by using a uni￾fied hidden markov model with web-scale resources”.
In: SIGIR. 2011.
[LDZ12] Y. Li, H. Duan, and C. Zhai. “A General￾ized Hidden Markov Model with Discriminative Train￾ing for Query Spelling Correction”. In: SIGIR. 2012,
pp. 611–620.
[Le+18] T. A. Le, M. Igl, T. Rainforth, T. Jin, and F.
Wood. “Auto-Encoding Sequential Monte Carlo”. In:
ICLR. 2018.
[L’E18] P. L’Ecuyer. “Randomized Quasi-Monte Carlo:
An Introduction for Practitioners”. In: Monte Carlo
and Quasi-Monte Carlo Methods. Springer Interna￾tional Publishing, 2018, pp. 29–52.
[Le+19] T. A. Le, A. R. Kosiorek, N Siddharth, Y. W.
Teh, and F. Wood. “Revisiting Reweighted Wake￾Sleep for Models with Stochastic Control Flow”. In:
UAI. 2019.
[LeC+89] Y. LeCun, B. Boser, J. S. Denker, D. Hen￾derson, R. E. Howard, W. Hubbard, and L. D. Jackel.
“Backpropagation Applied to Handwritten Zip Code
Recognition”. In: Neural Computation 1.4 (1989),
pp. 541–551.
[LeC+98] Y. LeCun, L. Bottou, G. B. Orr, and K.-R.
Müller. “Efficient BackProp”. en. In: Neural Networks:
Tricks of the Trade. Lecture Notes in Computer Sci￾ence. Springer, Berlin, Heidelberg, 1998, pp. 9–50.
[Lee04] M. D. Lee. “Models, parameters and priors in
Bayesian inference”. 2004.
[Lee06] J. de Leeuw. “Principal Component Analysis
of Binary Data by Iterated Singular Value Decom￾position”. In: Comput. Stat. Data Anal. 50.1 (2006),
pp. 21–39.
[Lee+09] H. Lee, R. B. Grosse, R. Ranganath, and A.
Ng. “Convolutional deep belief networks for scalable
unsupervised learning of hierarchical representations”.
In: ICML ’09. 2009.
[Lee+10] J. Lee, V. Mirrokni, V. Nagarajan, and M.
Sviridenko. “Maximizing Nonmonotone Submodular
Functions under Matroid or Knapsack Constraints”.
In: SIAM Journal on Discrete Mathematics 23.4
(2010), pp. 2053–2078.
[Lee+18] J. Lee, Y. Bahri, R. Novak, S. S. Schoenholz,
J. Pennington, and J. Sohl-Dickstein. “Deep Neural
Networks as Gaussian Processes”. In: ICLR. 2018.
[Lei+18] J. Lei, M. G’Sell, A. Rinaldo, R. J. Tibshi￾rani, and L. Wasserman. “Distribution-Free Predictive
Inference For Regression”. In: JASA (2018).
[Lei+20] F. Leibfried, V. Dutordoir, S. T. John, and
N. Durrande. “A Tutorial on Sparse Gaussian Pro￾cesses and Variational Inference”. In: (2020). arXiv:
2012.13962 [cs.LG].
[Lem09] C. Lemieux. Monte Carlo and Quasi-Monte
Carlo Sampling. Springer, New York, NY, 2009.
[Léo14] C. Léonard. “A survey of the Schrödinger prob￾lem and some of its connections with optimal trans￾port”. In: Discrete & Continuous Dynamical Systems
34.4 (2014), p. 1533.
[Let+15a] B. Letham, C. Rudin, T. H. McCormick,
and D. Madigan. “Interpretable classifiers using rules
and Bayesian analysis: Building a better stroke predic￾tion model”. In: The Annals of Applied Statistics 9.3
(2015).
[Let+15b] B. Letham, C. Rudin, T. H. McCormick,
and D. Madigan. “Interpretable classifiers using rules
and bayesian analysis: Building a better stroke predic￾Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
tion model”. In: The Annals of Applied Statistics 9.3
(2015), pp. 1350–1371.
[Lev18] S. Levine. “Reinforcement Learning and Con￾trol as Probabilistic Inference: Tutorial and Review”.
In: (2018). arXiv: 1805.00909 [cs.LG].
[Lev+20] S. Levine, A. Kumar, G. Tucker, and
J. Fu. Offline Reinforcement Learning: Tuto￾rial, Review, and Perspectives on Open Problems.
arXiv:2005.01643. 2020.
[LF+21] L. Le Folgoc, V. Baltatzis, S. Desai, A. De￾varaj, S. Ellis, O. E. Martinez Manzanera, A. Nair,
H. Qiu, J. Schnabel, and B. Glocker. “Is MC Dropout
Bayesian?” In: (2021). arXiv: 2110.04286 [cs.LG].
[LFG21] F. Lin, X. Fang, and Z. Gao. “Distribution￾ally Robust Optimization: A review on theory and ap￾plications”. In: Numer. Algebra Control Optim. 12.1
(2021), pp. 159–212.
[LG94] D. D. Lewis and W. A. Gale. “A sequential
algorithm for training text classifiers”. In: SIGIR94.
Springer. 1994, pp. 3–12.
[LGMT11] F. Le Gland, V. Monbet, and V.-D. Tran.
“Large Sample Asymptotics for the Ensemble Kalman
Filter”. In: Oxford Handbook of Nonlinear Filtering.
Ed. by D Crisan And. 2011.
[LHF17] R. M. Levy, A. Haldane, and W. F. Flynn.
“Potts Hamiltonian models of protein co-variation,
free energy landscapes, and evolutionary fitness”. en.
In: Curr. Opin. Struct. Biol. 43 (2017), pp. 55–62.
[LHF20] J. Liang, D. Hu, and J. Feng. “Do We Re￾ally Need to Access the Source Data? Source Hypothe￾sis Transfer for Unsupervised Domain Adaptation”. In:
ICML. Ed. by H. D. Iii and A. Singh. Vol. 119. Pro￾ceedings of Machine Learning Research. PMLR, 2020,
pp. 6028–6039.
[LHLT15] Y. Li, J. M. Hernandez-Lobato, and R. E.
Turner. “Stochastic Expectation Propagation”. In:
NIPS. 2015.
[LHR20] A. Lucic, H. Haned, and M. de Rijke. “Why
does my model fail? contrastive local explanations
for retail forecasting”. In: Proceedings of the 2020
Conference on Fairness, Accountability, and Trans￾parency. 2020, pp. 90–98.
[Li+10] L. Li, W. Chu, J. Langford, and R. E. Schapire.
“A contextual-bandit approach to personalized news
article recommendation”. In: WWW. 2010.
[Li+16] C. Li, C. Chen, D. Carlson, and L. Carin. “Pre￾conditioned Stochastic Gradient Langevin Dynamics
for Deep Neural Networks”. In: AAAI. 2016.
[Li+17a] A. Li, A. Jabri, A. Joulin, and L. van der
Maaten. “Learning visual n-grams from web data”. In:
Proceedings of the IEEE International Conference
on Computer Vision. 2017, pp. 4183–4192.
[Li+17b] C.-L. Li, W.-C. Chang, Y. Cheng, Y. Yang,
and B. Poczos. “Mmd gan: Towards deeper under￾standing of moment matching network”. In: Advances
in Neural Information Processing Systems. 2017,
pp. 2203–2213.
[Li+17c] L. Li, K. Jamieson, G. De Salvo, A. Ros￾tamizadeh, and A. Talwalkar. “Hyperband: bandit￾based configuration evaluation for hyperparameter op￾timization”. In: ICLR. 2017.
[Li+17d] O. Li, H. Liu, C. Chen, and C. Rudin. Deep
Learning for Case-Based Reasoning through Proto￾types: A Neural Network that Explains Its Predic￾tions. 2017. arXiv: 1710.04806 [cs.AI].
[Li+17e] T.-C. Li, J.-Y. Su, W. Liu, and J. M. Cor￾chado. “Approximate Gaussian conjugacy: parametric
recursive filtering under nonlinearity, multimodality,
uncertainty, and constraint, and beyond”. In: Fron￾tiers of Information Technology & Electronic Engi￾neering 18.12 (2017), pp. 1913–1939.
[Li18] Y. Li. “Deep Reinforcement Learning”. In:
(2018). arXiv: 1810.06339 [cs.LG].
[Li+18a] C. Li, H. Farkhoor, R. Liu, and J. Yosinski.
“Measuring the Intrinsic Dimension of Objective Land￾scapes”. In: ICLR. 2018.
[Li+18b] C. Li, H. Farkhoor, R. Liu, and J. Yosinski.
“Measuring the Intrinsic Dimension of Objective Land￾scapes”. In: ICLR. 2018.
[Li+18c] X. Li, C. Li, J. Chi, J. Ouyang, and W. Wang.
“Black-box Expectation Propagation for Bayesian
Models”. In: ICDM. Proceedings. Society for Indus￾trial and Applied Mathematics, 2018, pp. 603–611.
[Li+19] J. Li, S. Qu, X. Li, J. Szurley, J. Z. Kolter,
and F. Metze. “Adversarial Music: Real world Audio
Adversary against Wake-word Detection System”. In:
NIPS. Curran Associates, Inc., 2019, pp. 11908–11918.
[Li+20] C. Li, X. Gao, Y. Li, B. Peng, X. Li, Y. Zhang,
and J. Gao. “Optimus: Organizing Sentences via Pre￾trained Modeling of a Latent Space”. In: EMNLP.
2020.
[Li+21] Y. Li, R. Pogodin, D. J. Sutherland, and A.
Gretton. “Self-Supervised Learning with Kernel De￾pendence Maximization”. In: NeurIPS. 2021.
[Li+22] R. Li, W. Li, Y. Yang, H. Wei, J. Jiang, and Q.
Bai. “Swinv2-Imagen: Hierarchical Vision Transformer
Diffusion Models for Text-to-Image Generation”. In:
(Oct. 2022). arXiv: 2210.09549 [cs.CV].
[Lia+] P. Liang, R. Bommasani, T. Lee, D. Tsipras, D.
Soylu, M. Yasunaga, Y. Zhang, D. Narayanan, and Y.
Wu. “Helm: Holistic Evaluation of Language Models
(HELM), a framework to increase the transparency of
language models (https://arxiv.org/abs/2211.09110)”.
en.
[Lia+07] L. Liao, D. J. Patterson, D. Fox, and H.
Kautz. “Learning and Inferring Transportation Rou￾tines”. In: Artificial Intelligence 171.5 (2007), pp. 311–
331.
[Lia+08] F. Liang, R. Paulo, G. Molina, M. Clyde, and
J. Berger. “Mixtures of g-priors for Bayesian Variable
Selection”. In: JASA 103.481 (2008), pp. 410–423.
[Lia+19] V. Liao, R. Ballamy, M. Muller, and H. Can￾dello. “Human-AI Collaboration: Towards Socially￾Guided Machine Learning”. In: CHI Workshop on
Human-Centered Machine Learning Perspectives.
2019.
[Lil+16] T. P. Lillicrap, J. J. Hunt, A. Pritzel, N. Heess,
T. Erez, Y. Tassa, D. Silver, and D. Wierstra. “Con￾tinuous control with deep reinforcement learning”. In:
ICLR. 2016.
[Lin13a] W. Lin. “Agnostic notes on regression adjust￾ments to experimental data: Reexamining Freedman’s
critique”. In: The Annals of Applied Statistics 7.1
(2013), pp. 295–318.
[Lin13b] D. A. Linzer. “Dynamic Bayesian Forecast￾ing of Presidential Elections in the States”. In: JASA
108.501 (2013), pp. 124–134.
[Lin+17a] K. Lin, D. Li, X. He, Z. Zhang, and M.-T.
Sun. “Adversarial ranking for language generation”. In:
Advances in Neural Information Processing Systems.
2017, pp. 3155–3165.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1284
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[Lin+17b] T.-Y. Lin, P. Dollár, R. Girshick, K. He,
B. Hariharan, and S. Belongie. “Feature pyramid net￾works for object detection”. In: Proceedings of the
IEEE conference on computer vision and pattern
recognition. 2017, pp. 2117–2125.
[Lin19] J. K. Lindelov. Common statistical tests are
linear models (or: how to teach stats). Blog post.
2019.
[Lin+20] H. Lin, H. Chen, T. Zhang, C. Laroche, and K.
Choromanski. “Demystifying Orthogonal Monte Carlo
and Beyond”. In: (2020). arXiv: 2005.13590 [cs.LG].
[Lin+21a] T. Lin, Y. Wang, X. Liu, and X. Qiu. “A
Survey of Transformers”. In: (2021). arXiv: 2106.04554
[cs.LG].
[Lin+21b] A. Lindholm, N. Wahlström, F. Lindsten,
and T. B. Schön. Machine Learning - A First Course
for Engineers and Scientists. 2021.
[Lin+21c] J. Lindqvist, S. Särkkä, Á. F. García￾Fernández, M. Raitoharju, and L. Svensson. “Poste￾rior linearisation smoothing with robust iterations”. In:
(Dec. 2021). arXiv: 2112.03969 [math.OC].
[Lin56] D. Lindley. “On a measure of the information
provided by an experiment”. In: The Annals of Math.
Stat. (1956), 986–1005.
[Lin88a] B. Lindsay. “Composite Likelihood Methods”.
In: Contemporary Mathematics 80.1 (1988), pp. 221–
239.
[Lin88b] R Linsker. “Self-organization in a perceptual
network”. In: Computer 21.3 (1988), pp. 105–117.
[Lin88c] R. Linsker. “Self-organization in a perceptual
network”. In: Computer 21.3 (1988), pp. 105–117.
[Lin92] L.-J. Lin. “Self-Improving Reactive Agents
Based on Reinforcement Learning, Planning and
Teaching”. In: Mach. Learn. 8.3-4 (1992), pp. 293–321.
[Lip18] Z. C. Lipton. “The Mythos of Model Inter￾pretability: In machine learning, the concept of inter￾pretability is both important and slippery.” In: Queue
16.3 (2018), pp. 31–57.
[LIS20] Z. Lu, E. Ie, and F. Sha. “Mean-Field Ap￾proximation to Gaussian-Softmax Integral with Ap￾plication to Uncertainty Estimation”. In: (June 2020).
arXiv: 2006.07584 [cs.LG].
[Liu01] J. Liu. Monte Carlo Strategies in Scientific
Computation. Springer, 2001.
[Liu+15] Z. Liu, P. Luo, X. Wang, and X. Tang. “Deep
Learning Face Attributes in the Wild”. In: ICCV.
2015.
[Liu+18a] L. Liu, X. Liu, C.-J. Hsieh, and D. Tao.
“Stochastic Second-order Methods for Non-convex Op￾timization with Inexact Hessian and Gradient”. In:
(2018). arXiv: 1809.09853 [math.OC].
[Liu+18b] Q. Liu, L. Li, Z. Tang, and D. Zhou. “Break￾ing the Curse of Horizon: Infinite-horizon Off-policy
Estimation”. In: NeurIPS. Curran Associates Inc.,
2018, pp. 5361–5371.
[Liu+19a] H. Liu, Y.-S. Ong, Z. Yu, J. Cai, and X.
Shen. “Scalable Gaussian Process Classification with
Additive Noise for Various Likelihoods”. In: (2019).
arXiv: 1909.06541 [stat.ML].
[Liu+19b] R. Liu, J. Regier, N. Tripuraneni, M. I. Jor￾dan, and J. McAuliffe. “Rao-Blackwellized Stochastic
Gradients for Discrete Distributions”. In: ICML. 2019.
[Liu+19c] Y. Liu, M. Ott, N. Goyal, J. Du, M. Joshi, D.
Chen, O. Levy, M. Lewis, L. Zettlemoyer, and V. Stoy￾anov. “Roberta: A robustly optimized bert pretrain￾ing approach”. In: arXiv preprint arXiv:1907.11692
(2019).
[Liu+20a] F. Liu, W. Xu, J. Lu, G. Zhang, A. Gretton,
and D. J. Sutherland. “Learning Deep Kernels for Non￾Parametric Two-Sample Tests”. In: ICML. 2020.
[Liu+20b] F. Liu, W. Xu, J. Lu, G. Zhang, A. Gretton,
and D. J. Sutherland. “Learning deep kernels for non￾parametric two-sample tests”. In: International Con￾ference on Machine Learning. PMLR. 2020, pp. 6316–
6326.
[Liu+20c] H. Liu, Y.-S. Ong, X. Shen, and J. Cai.
“When Gaussian Process Meets Big Data: A Review
of Scalable GPs”. In: IEEE Transactions on Neural
Networks and Learning Systems 31.1 (2020).
[Liu+20d] J. Z. Liu, Z. Lin, S. Padhy, D. Tran, T.
Bedrax-Weiss, and B. Lakshminarayanan. “Simple and
Principled Uncertainty Estimation with Determinis￾tic Deep Learning via Distance Awareness”. In: NIPS.
2020.
[Liu+21a] P. Liu, W. Yuan, J. Fu, Z. Jiang, H. Hayashi,
and G. Neubig. “Pre-train, Prompt, and Predict: A
Systematic Survey of Prompting Methods in Natural
Language Processing”. In: (2021). arXiv: 2107 . 13586
[cs.CL].
[Liu+21b] W. Liu, X. Wang, J. D. Owens, and Y.
Li. “Energy-based Out-of-distribution Detection”. In:
NIPS. 2021.
[Liu+22a] J. Z. Liu, S. Padhy, J. Ren, Z. Lin, Y. Wen,
G. Jerfel, Z. Nado, J. Snoek, D. Tran, and B. Laksh￾minarayanan. “A Simple Approach to Improve Single￾Model Deep Uncertainty via Distance-Awareness”. In:
JMLR 23 (May 2022), pp. 1–62.
[Liu+22b] Z. Liu, H. Mao, C.-Y. Wu, C. Feichtenhofer,
T. Darrell, and S. Xie. “A ConvNet for the 2020s”. In:
(2022). arXiv: 2201.03545 [cs.CV].
[LJ08] P. Liang and M. I. Jordan. “An Asymptotic
Analysis of Generative, Discriminative, and Pseudo￾likelihood Estimators”. In: International Conference
on Machine Learning (ICML). 2008.
[Lju87] L. Ljung. System Identificiation: Theory for
the User. Prentice Hall, 1987.
[LJY19] S. Liu, Y. Jiang, and T. Yu. “Modelling RNA￾Seq data with a zero-inflated mixture Poisson lin￾ear model”. en. In: Genet. Epidemiol. 43.7 (2019),
pp. 786–799.
[LK07] P. Liang and D. Klein. Structured Bayesian
Nonparametric Models with Variational Inference.
ACL Tutorial. 2007.
[LK09] P. Liang and D. Klein. “Online EM for Unsu￾pervised Models”. In: NAACL. 2009.
[LKJ09] D. Lewandowski, D. Kurowicka, and H. Joe.
“Generating random correlation matrices based on
vines and extended onion method”. In: J. Multivar.
Anal. 100.9 (2009), pp. 1989–2001.
[LL02] P. Larranaga and J. A. Lozano. Estimation of
Distribution Algorithms: A New Tool for Evolution￾ary Computation. Kluwer Academic Publishers, 2002.
[LL17] S. M. Lundberg and S.-I. Lee. “A unified ap￾proach to interpreting model predictions”. In: NIPS.
2017, pp. 4765–4774.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[LLC20] M. Locher, K. B. Laskey, and P. C. G. Costa.
“Design patterns for modeling first-order expressive
Bayesian networks”. In: Knowl. Eng. Rev. 35 (2020).
[LLJ16] Q. Liu, J. Lee, and M. Jordan. “A kernel￾ized Stein discrepancy for goodness-of-fit tests”. In:
International conference on machine learning. 2016,
pp. 276–284.
[LLN06] B. Lehmann, D. Lehmann, and N. Nisan.
“Combinatorial auctions with decreasing marginal util￾ities”. In: Games and Economic Behavior 55.2 (2006),
pp. 270–296.
[Llo+14] J. R. Lloyd, D. Duvenaud, R. Grosse, J. B.
Tenenbaum, and Z. Ghahramani. “Automatic Con￾struction and Natural-Language Description of Non￾parametric Regression Models”. In: AAAI. 2014.
[LM03] T. S. Lee and D. Mumford. “Hierarchical
Bayesian inference in the visual cortex.” In: Journal
of the Optical Society of America. A, Optics, image
science, and vision 20 7 (2003), pp. 1434–48.
[LM11] H. Larochelle and I. Murray. “The neural au￾toregressive distribution estimator”. In: AISTATS.
Vol. 15. 2011, pp. 29–37.
[LM20] M. L. Leavitt and A. Morcos. “Towards fal￾sifiable interpretability research”. In: arXiv preprint
arXiv:2010.12016 (2020).
[LMP01] J. Lafferty, A. McCallum, and F. Pereira.
“Conditional Random Fields: Probabilistic Models for
Segmenting and Labeling Sequence Data”. In: ICML.
2001.
[LMS16] B. Leimkuhler, C. Matthews, and G. Stoltz.
“The computation of averages from equilibrium and
nonequilibrium Langevin molecular dynamics”. In:
IMA J. Numer. Anal. 36.1 (2016), pp. 13–79.
[LN01] S. Lauritzen and D. Nilsson. “Representing and
solving decision problems with limited information”.
In: Management Science 47 (2001), pp. 1238–1251.
[LN19] H. Lin and V. Ng. “Abstractive summarization:
A survey of the state of the art”. In: Proceedings of the
AAAI Conference on Artificial Intelligence. Vol. 33.
01. 2019, pp. 9815–9822.
[LN96] o. Lee and J. A. Nelder. “Hierarchical General￾ized Linear Models”. In: J. of Royal Stat. Soc. Series
B 58.4 (1996), pp. 619–678.
[Loc+18] F. Locatello, S. Bauer, M. Lucic, G. Rätsch,
S. Gelly, B. Schölkopf, and O. Bachem. “Challenging
Common Assumptions in the Unsupervised Learning
of Disentangled Representations”. In: (2018). arXiv:
1811.12359 [cs.LG].
[Loc+20a] F. Locatello, S. Bauer, M. Lucic, G. Raetsch,
S. Gelly, B. Schölkopf, and O. Bachem. “A Sober Look
at the Unsupervised Learning of Disentangled Repre￾sentations and their Evaluation”. In: Journal of Ma￾chine Learning Research 21.209 (2020), pp. 1–62.
[Loc+20b] F. Locatello, B. Poole, G. Rätsch, B.
Schölkopf, O. Bachem, and M. Tschannen. “Weakly￾supervised disentanglement without compromises”.
In: International Conference on Machine Learning.
PMLR. 2020, pp. 6348–6359.
[Lod+02] H. Lodhi, C. Saunders, J. Shawe-Taylor, N.
Cristianini, and C. Watkins. “Text classification using
string kernels”. en. In: J. Mach. Learn. Res. (2002).
[Loe04] H Loeliger. “An introduction to factor graphs”.
In: IEEE Signal Process. Magazine 21.1 (2004),
pp. 28–41.
[Loe+07] H Loeliger, J Dauwels, J Hu, S Korl, L Ping,
and F. R. Kschischang. “The Factor Graph Approach
to Model-Based Signal Processing”. In: Proc. IEEE
95.6 (2007), pp. 1295–1322.
[Loe+16] H.-A. Loeliger, L. Bruderer, H. Malmberg, F.
Wadehn, and N. Zalmai. “On Sparsity by NUV-EM,
Gaussian Message Passing, and Kalman Smoothing”.
In: ITA Workshop. 2016.
[Loi+21] N. Loizou, S. Vaswani, I. Laradji, and S.
Lacoste-Julien. “Stochastic Polyak step-size for SGD:
An adaptive learning rate for fast convergence”. In:
AISTATS. 2021.
[Lon+18] M. Long, Z. Cao, J. Wang, and M. I. Jordan.
“Conditional adversarial domain adaptation”. In: Neu￾ral Information Processing Systems (2018).
[Lot+22] S. Lotfi, P. Izmailov, G. Benton, M. Gold￾blum, and A. G. Wilson. “Bayesian Model Selec￾tion, the Marginal Likelihood, and Generalization”. In:
ICML. 2022.
[Lov+20] T. Lovett, M. Briers, M. Charalambides, R.
Jersakova, J. Lomax, and C. Holmes. “Inferring prox￾imity from Bluetooth Low Energy RSSI with Un￾scented Kalman Smoothers”. In: (2020). arXiv: 2007.
05057 [eess.SP].
[Lov83] L. Lovász. “Submodular functions and convex￾ity”. In: Mathematical programming the state of the
art. Springer, 1983, pp. 235–257.
[LÖW21] T. van de Laar, A. Özçelikkale, and H.
Wymeersch. “Application of the Free Energy Principle
to Estimation and Control”. In: IEEE Trans. Signal
Process. 69 (2021), pp. 4234–4244.
[LP01] U. Lerner and R. Parr. “Inference in Hybrid Net￾works: Theoretical Limits and Practical Algorithms”.
In: UAI. 2001.
[LP03] M. G. Lagoudakis and R. Parr. “Least-Squares
Policy Iteration”. In: JMLR 4 (2003), pp. 1107–1149.
[LP06] N. Lartillot and H. Philippe. “Computing Bayes
factors using thermodynamic integration”. en. In: Sys￾tematic Biology 55.2 (2006), pp. 195–207.
[LP20] P. Lemberger and I. Panico. “A Primer on Do￾main Adaptation”. In: (Jan. 2020). arXiv: 2001.09994
[cs.LG].
[LPB17] B. Lakshminarayanan, A. Pritzel, and C.
Blundell. “Simple and Scalable Predictive Uncertainty
Estimation using Deep Ensembles”. In: NIPS. 2017.
[LPO17] D. Lopez-Paz and M. Oquab. “Revisiting clas￾sifier two-sample tests”. In: International Conference
on Learning Representations. 2017.
[LPR17] D. Lopez-Paz and M. Ranzato. “Gradient
Episodic Memory for Continual Learning”. In: NIPS.
2017.
[LR19] F. Lattimore and D. Rohde. “Replacing the do￾calculus with Bayes rule”. In: (2019). arXiv: 1906 .
07125 [stat.ML].
[LR85] T. L. Lai and H. Robbins. “Asymptotically ef￾ficient adaptive allocation rules”. en. In: Adv. Appl.
Math. (1985).
[LR87] R. J. Little and D. B. Rubin. Statistical Anal￾ysis with Missing Data. Wiley and Son, 1987.
[LR95] C. Liu and D. Rubin. “ML Estimation of the T
distribution using EM and its extensions, ECM and
ECME”. In: Statistica Sinica 5 (1995), pp. 19–39.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1286
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[LRC19] Y. Li, B. I. P. Rubinstein, and T. Cohn.
“Truth Inference at Scale: A Bayesian Model for Ad￾judicating Highly Redundant Crowd Annotations”. In:
WWW. 2019.
[LS01] D. Lee and S. Seung. “Algorithms for non￾negative matrix factorization”. In: NIPS. 2001.
[LS19] T. Lattimore and C. Szepesvari. Bandit Algo￾rithms. Cambridge, 2019.
[LS99] D. D. Lee and H. S. Seung. “Learning the parts
of objects by non-negative matrix factorization”. In:
Nature 401.6755 (1999), pp. 788–791.
[LST15] B. M. Lake, R. Salakhutdinov, and J. B.
Tenenbaum. “Human-level concept learning through
probabilistic program induction”. In: Science 350
(2015), pp. 1332 –1338.
[LST21] N. Loo, S. Swaroop, and R. E. Turner. “Gen￾eralized Variational Continual Learning”. In: ICLR.
2021.
[LST90] J. K. Lenstra, D. B. Shmoys, and É. Tar￾dos. “Approximation algorithms for scheduling unre￾lated parallel machines”. In: Mathematical program￾ming. 1990.
[LSV09] J. Lee, M. Sviridenko, and J. Vondrák. “Sub￾modular maximization over multiple matroids via
generalized exchange properties”. In: Approximation,
Randomization, and Combinatorial Optimization.
Algorithms and Techniques (2009), pp. 244–257.
[LSW15] Y. T. Lee, A. Sidford, and S. C.-w. Wong.
“A faster cutting plane method and its implications
for combinatorial and convex optimization”. In: 2015
IEEE 56th Annual Symposium on Foundations of
Computer Science. IEEE. 2015, pp. 1049–1065.
[LSZ15] Y. Li, K. Swersky, and R. Zemel. “Generative
Moment Matching Networks”. In: ICML. 2015.
[LT16] M.-Y. Liu and O. Tuzel. “Coupled Generative
Adversarial Networks”. In: NIPS. 2016, pp. 469–477.
[LTW15] Q. Li, C. Tai, and E Weinan. “Stochastic mod￾ified equations and adaptive stochastic gradient algo￾rithms”. In: ICML. 2015.
[Lu+21a] X. Lu, I. Osband, B. Van Roy, and Z. Wen.
“Evaluating Probabilistic Inference in Deep Learning:
Beyond Marginal Predictions”. In: (2021). arXiv: 2107.
09224 [cs.LG].
[Lu+21b] X. Lu, B. Van Roy, V. Dwaracherla, M.
Ibrahimi, I. Osband, and Z. Wen. “Reinforcement
Learning, Bit by Bit”. In: (Mar. 2021). arXiv: 2103 .
04047 [cs.LG].
[Lu+22] X. Lu, I. Osband, B. Van Roy, and Z. Wen.
“From Predictions to Decisions: The Importance of
Joint Predictive Distributions”. In: (2022). arXiv: 2107.
09224 [cs.LG].
[Luc+18] A Lucas, M Iliadis, R Molina, and A. K. Kat￾saggelos. “Using Deep Neural Networks for Inverse
Problems in Imaging: Beyond Analytical Methods”. In:
IEEE Signal Process. Mag. 35.1 (2018), pp. 20–36.
[Luc+19] J. Lucas, G. Tucker, R. Grosse, and M.
Norouzi. “Don’t blame the ELBO! A linear VAE per￾spective on posterior collapse”. In: NIPS. 2019.
[Luh58] H. P. Luhn. “The automatic creation of litera￾ture abstracts”. In: IBM Journal of research and de￾velopment 2.2 (1958), pp. 159–165.
[Lun+20] S. M. Lundberg, G. Erion, H. Chen, A. De￾Grave, J. M. Prutkin, B. Nair, R. Katz, J. Himmelfarb,
N. Bansal, and S.-I. Lee. “From local explanations to
global understanding with explainable AI for trees”. In:
Nature machine intelligence 2.1 (2020), pp. 56–67.
[Luo+19] Y. Luo, H. Xu, Y. Li, Y. Tian, T. Darrell,
and T. Ma. “Algorithmic Framework for Model-based
Deep Reinforcement Learning with Theoretical Guar￾antees”. In: ICLR. 2019.
[Lut16] J Luttinen. “BayesPy: variational Bayesian in￾ference in Python”. In: JMLR (2016).
[LV06] F. Liese and I. Vajda. “On divergences and in￾formations in statistics and information theory”. In:
IEEE Transactions on Information Theory 52.10
(2006), pp. 4394–4412.
[LW04] H. Lopes and M. West. “Bayesian model assess￾ment in factor analysis”. In: Statisica Sinica 14 (2004),
pp. 41–67.
[LW16] C. Louizos and M. Welling. “Structured and
Efficient Variational Deep Learning with Matrix Gaus￾sian Posteriors”. In: ICML. 2016.
[LW17] C. Louizos and M. Welling. “Multiplicative
Normalizing Flows for Variational Bayesian Neural
Networks”. In: Proceedings of the 34th International
Conference on Machine Learning. 2017, pp. 2218–
2227.
[LWS18] Z. C. Lipton, Y.-X. Wang, and A. Smola. “De￾tecting and Correcting for Label Shift with Black Box
Predictors”. In: ICML. 2018.
[LY17] J. H. Lim and J. C. Ye. “Geometric gan”. In:
arXiv preprint arXiv:1705.02894 (2017).
[Ly+20] A. Ly et al. “The Bayesian Methodology of
Sir Harold Jeffreys as a Practical Alternative to the P
Value Hypothesis Test”. In: Computational Brain &
Behavior 3.2 (June 2020), pp. 153–161.
[Lyu11] S. Lyu. “Unifying non-maximum likelihood
learning objectives with minimum KL contraction”. In:
Advances in Neural Information Processing Systems.
2011, pp. 64–72.
[Lyu12] S. Lyu. “Interpretation and generalization of
score matching”. In: arXiv preprint arXiv:1205.2629
(2012).
[Lyu+20] X.-K. Lyu, Y. Xu, X.-F. Zhao, X.-N. Zuo,
and C.-P. Hu. “Beyond psychology: prevalence of p
value and confidence interval misinterpretation across
different fields”. In: Journal of Pacific Rim Psychol￾ogy 14 (2020).
[LZ20] B. Lim and S. Zohren. “Time Series Forecast￾ing With Deep Learning: A Survey”. In: (2020). arXiv:
2004.13408 [stat.ML].
[MA10] I. Murray and R. P. Adams. “Slice sampling co￾variance hyperparameters of latent Gaussian models”.
In: NIPS. 2010, pp. 1732–1740.
[Maa+16] L. Maaløe, C. K. Sønderby, S. K. Sønderby,
and O. Winther. “Auxiliary Deep Generative Models”.
In: ICML. 2016.
[Maa+19] L. Maaløe, M. Fraccaro, V. Liévin, and O.
Winther. “BIVA: A Very Deep Hierarchy of Latent
Variables for Generative Modeling”. In: NIPS. 2019.
[Mac03] D. MacKay. Information Theory, Inference,
and Learning Algorithms. Cambridge University
Press, 2003.
[Mac+11] J. H. Macke, L. Büsing, J. P. Cunningham,
B. M. Y. Ece, K. V. Shenoy, and M. Sahani. “Empiri￾cal models of spiking in neural populations”. In: NIPS.
2011.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Mac+15] D. Maclaurin, D. Duvenaud, M. Johnson,
and R. P. Adams. Autograd: Reverse-mode differen￾tiation of native Python. 2015.
[Mac+19] D. Maclaurin, A. Radul, M. J. Johnson, and
D. Vytiniotis. “Dex: array programming with typed
indices”. In: NeurIPS workshop: Program Transfor￾mations for Machine Learning (2019).
[Mac92a] D. MacKay. “The evidence framework ap￾plied to classification networks”. In: Neural Comptu￾tation 4.5 (1992), pp. 720–736.
[Mac92b] D. J. C. MacKay. “A Practical Bayesian
Framework for Backpropagation Networks”. In: Neu￾ral Comput. 4.3 (1992), pp. 448–472.
[Mac95] D. MacKay. “Probable networks and plausible
predictions — a review of practical Bayesian methods
for supervised neural networks”. In: Network: Compu￾tation in Neural Systems 6.3 (1995), pp. 469–505.
[Mac98] D. MacKay. “Introduction to Gaussian Pro￾cesses”. In: Neural Networks and Machine Learning.
Ed. by C. Bishop. 1998.
[Mac99] D. MacKay. “Comparision of approximate
methods for handling hyperparameters”. In: Neural
Computation 11.5 (1999), pp. 1035–1068.
[Mad+17] C. J. Maddison, D. Lawson, G. Tucker, N.
Heess, M. Norouzi, A. Mnih, A. Doucet, and Y. W.
Teh. “Filtering Variational Objectives”. In: NIPS.
2017.
[Mad+18] A. Madry, A. Makelov, L. Schmidt, D.
Tsipras, and A. Vladu. “Towards Deep Learning Mod￾els Resistant to Adversarial Attacks”. In: ICLR. 2018.
[Mad+19] W. J. Maddox, P. Izmailov, T. Garipov, D. P.
Vetrov, and A. G. Wilson. “A Simple Baseline for
Bayesian Uncertainty in Deep Learning”. In: NIPS.
Curran Associates, Inc., 2019, pp. 13153–13164.
[MAD20] W. R. Morningstar, A. A. Alemi, and J. V.
Dillon. “PACm-Bayes: Narrowing the Empirical Risk
Gap in the Misspecified Bayesian Regime”. In: (2020).
arXiv: 2010.09629 [cs.LG].
[Mah07] R. P. S. Mahler. Statistical Multisource￾Multitarget Information Fusion. Artech House, Inc.,
2007.
[Mah13] R Mahler. “Statistics 102 for Multisource￾Multitarget Detection and Tracking”. In: IEEE J. Sel.
Top. Signal Process. 7.3 (2013), pp. 376–389.
[Mah+18] D. Mahajan, R. Girshick, V. Ramanathan,
K. He, M. Paluri, Y. Li, A. Bharambe, and L. van der
Maaten. “Exploring the limits of weakly supervised
pretraining”. In: Proceedings of the European Con￾ference on Computer Vision (ECCV). 2018, pp. 181–
196.
[Mah+19] N. Maheswaranathan, A. H. Williams, M. D.
Golub, S. Ganguli, and D. Sussillo. “Universality
and individuality in neural dynamics across large
populations of recurrent networks”. In: Advances in
Neural Information Processing Systems 2019 (2019),
p. 15629.
[Mah+23] K. Mahowald, A. A. Ivanova, I. A. Blank, N.
Kanwisher, J. B. Tenenbaum, and E. Fedorenko. “Dis￾sociating language and thought in large language mod￾els: a cognitive perspective”. In: (Jan. 2023). arXiv:
2301.06627 [cs.CL].
[Mai+10] J. Mairal, F. Bach, J. Ponce, and G. Sapiro.
“Online learning for matrix factorization and sparse
coding”. In: JMLR 11 (2010), pp. 19–60.
[Mai13] J. Mairal. “Stochastic Majorization￾minimization Algorithms for Large-scale Optimiza￾tion”. In: NIPS. 2013, pp. 2283–2291.
[Mai15] J Mairal. “Incremental Majorization￾Minimization Optimization with Application to Large￾Scale Machine Learning”. In: SIAM J. Optim. 25.2
(2015), pp. 829–855.
[Mai+22] Z. Mai, R. Li, J. Jeong, D. Quispe, H. Kim,
and S. Sanner. “Online continual learning in image
classification: An empirical survey”. In: Neurocomput￾ing 469 (2022), pp. 28–51.
[Mak+15a] A. Makhzani, J. Shlens, N. Jaitly, I. Good￾fellow, and B. Frey. “Adversarial Autoencoders”. In:
(2015). arXiv: 1511.05644 [cs.LG].
[Mak+15b] A. Makhzani, J. Shlens, N. Jaitly, I. Good￾fellow, and B. Frey. “Adversarial autoencoders”. In:
arXiv preprint arXiv:1511.05644 (2015).
[Mak+20] A. Makkuva, A. Taghvaei, S. Oh, and J. Lee.
“Optimal transport mapping via input convex neural
networks”. In: International Conference on Machine
Learning. PMLR. 2020, pp. 6672–6681.
[Mal+17] D. M. Malioutov, K. R. Varshney, A. Emad,
and S. Dash. “Learning interpretable classification
rules with boolean compressed sensing”. In: Transpar￾ent Data Mining for Big and Small Data. Springer,
2017, pp. 95–121.
[Man] B. Mann. How many times should you shuffle
a deck of cards? Tech. rep. Dartmouth.
[Man+19] D. J. Mankowitz, N. Levine, R. Jeong, Y.
Shi, J. Kay, A. Abdolmaleki, J. T. Springenberg, T.
Mann, T. Hester, and M. Riedmiller. “Robust Re￾inforcement Learning for Continuous Control with
Model Misspecification”. In: (2019). arXiv: 1906.07516
[cs.LG].
[Man22a] V. Manokhin. Awesome Conformal Predic￾tion. Version v1.0.0. Apr. 2022.
[Man22b] V. Manokhin. “Machine Learning for Proba￾bilistic Prediction”. PhD thesis. Royal Holloway, Uni￾versity of London, June 2022.
[Man90] C. F. Manski. “Nonparametric Bounds on
Treatment Effects”. In: The American Economic Re￾view 80.2 (1990), pp. 319–323.
[Mao+17] X. Mao, Q. Li, H. Xie, R. Y. K. Lau, Z.
Wang, and S. P. Smolley. “Least Squares Generative
Adversarial Networks”. In: ICCV. 2017.
[MAP17] H. Martínez Alonso and B. Plank. “When is
multitask learning effective? Semantic sequence pre￾diction under varying data conditions”. In: Proc. Eu￾ropean ACL. Valencia, Spain: Association for Compu￾tational Linguistics, Apr. 2017, pp. 44–53.
[Mar03] B. Marlin. “Modeling User Rating Profiles for
Collaborative Filtering”. In: NIPS. 2003.
[Mar+06] A. Margolin, I. Nemenman, K. Basso, C.
Wiggins, G. Stolovitzky, and R. F. abd A. Califano.
“ARACNE: An Algorithm for the Reconstruction of
Gene Regulatory Networks in a Mammalian Cellular
Context”. In: BMC Bionformatics 7 (2006).
[Mar+10] B. M. Marlin, K. Swersky, B. Chen, and N.
de Freitas. “Inductive Principles for Restricted Boltz￾mann Machine Learning”. In: AISTATS. 2010.
[Mar10a] J Martens. “Deep learning via Hessian-free
optimization”. In: ICML. 2010.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1288
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[Mar10b] J. Martens. “Learning the Linear Dynamical
System with ASOS”. In: ICML. ICML’10. Omnipress,
2010, pp. 743–750.
[Mar16] J. Martens. “Second-order optimization for
neural networks”. PhD thesis. Toronto, 2016.
[Mar18] O. Martin. Bayesian analysis with Python.
Packt, 2018.
[Mar20] J. Martens. “New insights and perspectives on
the natural gradient method”. In: JMLR (2020).
[Mas+20] M. Masana, X. Liu, B. Twardowski, M.
Menta, A. D. Bagdanov, and J. van de Weijer. “Class￾incremental learning: survey and performance evalua￾tion on image classification”. In: (2020). arXiv: 2010.
15277 [cs.LG].
[Mat14] C. Mattfeld. “Implementing spectral methods
for hidden Markov models with real-valued emissions”.
MA thesis. ETH Zurich, 2014.
[Mat+16] A. Matthews, J. Hensman, R. Turner, and Z.
Ghahramani. “On Sparse Variational Methods and the
Kullback-Leibler Divergence between Stochastic Pro￾cesses”. en. In: AISTATS. 2016, pp. 231–239.
[Mav16] Mavrogonatou, L And Vyshemirsky, “Sequen￾tial Importance Sampling for Online Bayesian Change￾point Detection”. In: 22nd International Conference
on Computational Statistics. 2016.
[May+19] A. May, J. Zhang, T. Dao, and C. Ré. “On
the downstream performance of compressed word em￾beddings”. In: Advances in neural information pro￾cessing systems 32 (2019), p. 11782.
[May79] P. Maybeck. Stochastic models, estimation,
and control. Academic Press, 1979.
[Maz+22] P. Mazzaglia, T. Verbelen, O. Çatal, and B.
Dhoedt. “The Free Energy Principle for Perception
and Action: A Deep Learning Perspective”. en. In: En￾tropy 24.2 (2022).
[MAZA18] X. B. P. amd Marcin Andrychowicz, W.
Zaremba, and P. Abbeel. “Sim-to-Real Transfer of
Robotic Control with Dynamics Randomization”. In:
ICRA. 2018, pp. 1–8.
[MB16] Y. Miao and P. Blunsom. “Language as a La￾tent Variable: Discrete Generative Models for Sen￾tence Compression”. In: EMNLP. 2016.
[MB18] A. Mensch and M. Blondel. “Differentiable Dy￾namic Programming for Structured Prediction and At￾tention”. In: ICML. 2018.
[MB21] M. Y. Michelis and Q. Becker. “On Linear In￾terpolation in the Latent Space of Deep Generative
Models”. In: ICLR Workshop on Geometrical and
Topological Representation Learning. 2021.
[MB88] T. Mitchell and J. Beauchamp. “Bayesian Vari￾able Selection in Linear Regression”. In: JASA 83
(1988), pp. 1023–1036.
[MBJ20] T. M. Moerland, J. Broekens, and C. M.
Jonker. “Model-based Reinforcement Learning: A Sur￾vey”. In: (2020). arXiv: 2006.16712 [cs.LG].
[MBL20] B. Mirzasoleiman, J. Bilmes, and J. Leskovec.
“Coresets for data-efficient training of machine learn￾ing models”. In: International Conference on Ma￾chine Learning. PMLR. 2020, pp. 6950–6960.
[MBW20] W. J. Maddox, G. Benton, and A. G. Wilson.
“Rethinking Parameter Counting in Deep Models: Ef￾fective Dimensionality Revisited”. In: arXiv preprint
arXiv:2003.02139 (2020).
[MC03] P. Moscato and C. Cotta. “A Gentle Introduc￾tion to Memetic Algorithms”. en. In: Handbook of
Metaheuristics. International Series in Operations Re￾search & Management Science. Springer, Boston, MA,
2003, pp. 105–144.
[MC19] P. Moreno Comellas. “Vision as inverse graph￾ics for detailed scene understanding”. en. PhD thesis.
2019.
[McA23] D. McAllester. “On the Mathematics of Dif￾fusion Models”. In: (Jan. 2023). arXiv: 2301 . 11108
[cs.LG].
[McA99] D. A. McAllester. “PAC-Bayesian model aver￾aging”. In: Proceedings of the twelfth annual confer￾ence on computational learning theory. 1999.
[McE20] R. McElreath. Statistical Rethinking: A
Bayesian Course with Examples in R and Stan (2nd
edition). en. Chapman and Hall/CRC, 2020.
[McG54] W. McGill. “Multivariate information trans￾mission”. In: Psychometrika 19 (1954), pp. 97–116.
[McM+13] H. B. McMahan, G. Holt, D Sculley, M.
Young, D. Ebner, J. Grady, L. Nie, T. Phillips, E.
Davydov, D. Golovin, et al. “Ad click prediction: a
view from the trenches”. In: KDD. 2013, pp. 1222–
1230.
[Md+19] C. de Masson d’Autume, M. Rosca, J. Rae,
and S. Mohamed. “Training language GANs from
Scratch”. In: (2019). arXiv: 1905.09922 [cs.CL].
[MD97] X. L. Meng and D. van Dyk. “The EM algo￾rithm — an old folk song sung to a fast new tune
(with Discussion)”. In: J. Royal Stat. Soc. B 59 (1997),
pp. 511–567.
[MDA15] D. Maclaurin, D. Duvenaud, and R. P.
Adams. “Gradient-based Hyperparameter Optimiza￾tion through Reversible Learning”. In: ICML. 2015.
[MDM19] S. Mahloujifar, D. I. Diochnos, and M. Mah￾moody. “The curse of concentration in robust learning:
Evasion and poisoning attacks from concentration of
measure”. In: Proceedings of the AAAI Conference on
Artificial Intelligence. Vol. 33. 2019, pp. 4536–4543.
[MDR94] S. Muggleton and L. De Raedt. “Inductive
logic programming: Theory and methods”. In: The
Journal of Logic Programming 19 (1994), pp. 629–
679.
[Med+21] M. A. Medina, J. L. M. Olea, C. Rush, and
A. Velez. “On the Robustness to Misspecification of α￾Posteriors and Their Variational Approximations”. In:
(2021). arXiv: 2104.08324 [stat.ML].
[Mee+18] J.-W. van de Meent, B. Paige, H. Yang, and
F. Wood. An introduction to probabilistic program￾ming. Foundations and Trends in Machine Learning,
2018.
[Meh72] R Mehra. “Approaches to adaptive filtering”.
In: IEEE Trans. Automat. Contr. 17.5 (Oct. 1972),
pp. 693–698.
[Mei18a] N. Meinshausen. “Causality from a distribu￾tional robustness point of view”. In: IEEE Data Sci￾ence Workshop (DSW). 2018, pp. 6–10.
[Mei18b] N. Meinshausen. “CAUSALITY FROM A
DISTRIBUTIONAL ROBUSTNESS POINT OF
VIEW”. In: 2018 IEEE Data Science Workshop
(DSW). 2018, pp. 6–10.
[Men+21] A. K. Menon, S. Jayasumana, A. S. Rawat,
H. Jain, A. Veit, and S. Kumar. “Long-tail learning
via logit adjustment”. In: ICLR. 2021.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Mer] Definition of interpret. 2022. url: https://www.
merriam-webster.com/dictionary/interpret.
[Mer+00] R. van der Merwe, A. Doucet, N. de Fre￾itas, and E. Wan. “The Unscented Particle Filter”. In:
NIPS-13. 2000.
[Met16] C. Metz. In Two Moves, AlphaGo and Lee
Sedol Redefined the Future. 2016. url: https://www.
wired . com/ 2016 / 03 / two - moves - alphago - lee - sedol -
redefined-future/ (visited on 01/07/2022).
[Met+16] L. Metz, B. Poole, D. Pfau, and J. Sohl￾Dickstein. “Unrolled Generative Adversarial Net￾works”. In: (2016).
[Met+17] L. Metz, J. Ibarz, N. Jaitly, and J. Davidson.
“Discrete Sequential Prediction of Continuous Actions
for Deep RL”. In: (2017). arXiv: 1705.05035 [cs.LG].
[Met+53] N. Metropolis, A. Rosenbluth, M. Rosen￾bluth, A. Teller, and E. Teller. “Equation of state
calculations by fast computing machines”. In: J. of
Chemical Physics 21 (1953), pp. 1087–1092.
[Mey+18] F. Meyer, T. Kropfreiter, J. Williams, R.
Lau, F. Hlawatsch, P. Braca, and M. Win. “Message
passing algorithms for scalable multitarget tracking”.
In: Proc. IEEE 106.2 (2018).
[Mey+21] R. A. Meyer, C. Musco, C. Musco, and D. P.
Woodruff. “Hutch++: Optimal Stochastic Trace Esti￾mation”. In: SIAM Symposium on Simplicity in Al￾gorithms (SOSA21). 2021.
[Mey22] S. Meyn. Control Systems and Reinforcement
Learning. Cambridge, 2022.
[MFP00] A. McCallum, D. Freitag, and F. Pereira.
“Maximum Entropy Markov Models for Information
Extraction and Segmentation”. In: ICML. 2000.
[MFR20] G. M. Martin, D. T. Frazier, and C. P. Robert.
“Computing Bayes: Bayesian Computation from 1763
to the 21st Century”. In: (2020). arXiv: 2004 . 06425
[stat.CO].
[MG05] I. Murray and Z. Ghahramani. A note on
the evidence and Bayesian Occam’s razor. Tech. rep.
Gatsby, 2005.
[MG15] J. Martens and R. Grosse. “Optimizing Neural
Networks with Kronecker-factored Approximate Cur￾vature”. In: ICML. 2015.
[MG18] A. Malinin and M. Gales. “Predictive Uncer￾tainty Estimation via Prior Networks”. In: (2018).
arXiv: 1802.10501 [stat.ML].
[MGM06] I. Murray, Z. Ghahramani, and D. J. C.
MacKay. “MCMC for doubly-intractable distribu￾tions”. In: Proceedings of the 22nd Annual Confer￾ence on Uncertainty in Artificial Intelligence (UAI￾06). AUAI Press, 2006, pp. 359–366.
[MGN18a] L. Mescheder, A. Geiger, and S. Nowozin.
“Which Training Methods for GANs do actually Con￾verge?” In: ICML. 2018.
[MGN18b] L. Mescheder, A. Geiger, and S. Nowozin.
“Which training methods for GANs do actually con￾verge?” In: International conference on machine
learning. PMLR. 2018, pp. 3481–3490.
[MGR18] H. Mania, A. Guy, and B. Recht. “Simple
random search of static linear policies is competitive
for reinforcement learning”. In: NIPS. Ed. by S Ben￾gio, H Wallach, H Larochelle, K Grauman, N Cesa￾Bianchi, and R Garnett. Curran Associates, Inc., 2018,
pp. 1800–1809.
[MH12] R. Mazumder and T. Hastie. The Graphi￾cal Lasso: New Insights and Alternatives. Tech. rep.
Stanford Dept. Statistics, 2012.
[MH20] I. Mordatch and J. Hamrick. ICML tu￾torial on model-based methods in reinforcement
learning. https://sites.google.com/corp/view/mbrl￾tutorial. 2020.
[MHB17] S. Mandt, M. D. Hoffman, and D. M.
Blei. “Stochastic Gradient Descent As Approximate
Bayesian Inference”. In: JMLR 18.1 (2017), pp. 4873–
4907.
[MHH14] F. Meyer, O. Hlinka, and F. Hlawatsch.
“Sigma point belief propagation”. In: IEEE Signal
Processing Letters 21.2 (2014), pp. 145–149.
[MHN13] A. L. Maas, A. Y. Hannun, and A. Y.
Ng. “Rectifier Nonlinearities Improve Neural Network
Acoustic Models”. In: ICML. Vol. 28. 2013.
[MI23] M. Magris and A. Iosifidis. “Bayesian learning
for neural networks: an algorithmic survey”. In: Arti￾ficial Intelligence Review (Mar. 2023).
[Mik+13] T. Mikolov, I. Sutskever, K. Chen, G. S.
Corrado, and J. Dean. “Distributed representations
of words and phrases and their compositionality”. In:
NIPS. 2013, pp. 3111–3119.
[Mil+05] B. Milch, B. Marthi, S. Russell, D. Sontag, D.
Ong, and A. Kolobov. “BLOG: Probabilistic Models
with Unknown Objects”. In: IJCAI. 2005.
[Mil19] T. Miller. “Explanation in artificial intelligence:
Insights from the social sciences”. In: Artificial intel￾ligence 267 (2019), pp. 1–38.
[Mil+20] B. Millidge, A. Tschantz, A. K. Seth, and
C. L. Buckley. “On the Relationship Between Active
Inference and Control as Inference”. In: International
Workshop on Active Inference. 2020.
[Mil+21] J. P. Miller, R. Taori, A. Raghunathan, S.
Sagawa, P. W. Koh, V. Shankar, P. Liang, Y. Car￾mon, and L. Schmidt. “Accuracy on the Line: on the
Strong Correlation Between Out-of-Distribution and
In-Distribution Generalization”. In: ICML. Ed. by M.
Meila and T. Zhang. Vol. 139. Proceedings of Machine
Learning Research. PMLR, 2021, pp. 7721–7735.
[Min00a] T. Minka. Bayesian linear regression. Tech.
rep. MIT, 2000.
[Min00b] T. Minka. Bayesian model averaging is not
model combination. Tech. rep. MIT Media Lab, 2000.
[Min00c] T. Minka. Estimating a Dirichlet distribu￾tion. Tech. rep. MIT, 2000.
[Min01a] T. Minka. “A family of algorithms for approx￾imate Bayesian inference”. PhD thesis. MIT, 2001.
[Min01b] T. Minka. “Expectation Propagation for ap￾proximate Bayesian inference”. In: UAI. 2001.
[Min04] T. Minka. Power EP. Tech. rep. MSR-TR￾2004-149. 2004.
[Min05] T. Minka. Divergence measures and message
passing. Tech. rep. MSR Cambridge, 2005.
[Min+18] T. Minka, J. Winn, J. Guiver, Y. Zaykov, D.
Fabian, and J. Bronskill. Infer.NET 0.3. Microsoft Re￾search Cambridge. 2018.
[Min78] M. Minoux. “Accelerated greedy algorithms
for maximizing submodular set functions”. In: Opti￾mization Techniques. Ed. by J. Stoer. Vol. 7. Lec￾ture Notes in Control and Information Sciences.
10.1007/BFb0006528. Springer Berlin / Heidelberg,
1978, pp. 234–243.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1290
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[Min99] T. Minka. Pathologies of Orthodox Statisics.
Tech. rep. MIT Media Lab, 1999.
[Mis+16] I. Misra, A. Shrivastava, A. Gupta, and M.
Hebert. “Cross-stitch Networks for Multi-task Learn￾ing”. In: CVPR. 2016.
[Mis+18] A. Mishkin, F. Kunstner, D. Nielsen, M.
Schmidt, and M. E. Khan. “SLANG: Fast Structured
Covariance Approximations for Bayesian Deep Learn￾ing with Natural Gradient”. In: NIPS. Curran Asso￾ciates, Inc., 2018, pp. 6245–6255.
[Mit+19] M. Mitchell, S. Wu, A. Zaldivar, P. Barnes,
L. Vasserman, B. Hutchinson, E. Spitzer, I. D. Raji,
and T. Gebru. “Model cards for model reporting”. In:
Proceedings of the conference on fairness, account￾ability, and transparency. 2019, pp. 220–229.
[Mit+20] J. Mitrovic, B. McWilliams, J. Walker, L.
Buesing, and C. Blundell. Representation Learning
via Invariant Causal Mechanisms. 2020. arXiv: 2010.
07922 [cs.LG].
[Mit97] T. Mitchell. Machine Learning. McGraw Hill,
1997.
[Miy+18a] T. Miyato, T. Kataoka, M. Koyama, and Y.
Yoshida. “Spectral Normalization for Generative Ad￾versarial Networks”. In: ICLR. 2018.
[Miy+18b] T. Miyato, T. Kataoka, M. Koyama, and Y.
Yoshida. “Spectral Normalization for Generative Ad￾versarial Networks”. In: ICLR. 2018.
[Miy+18c] T. Miyato, T. Kataoka, M. Koyama, and Y.
Yoshida. “Spectral Normalization for Generative Ad￾versarial Networks”. In: International Conference on
Learning Representations. 2018.
[MJ97] M. Meila and M. Jordan. Triangulation by con￾tinuous embedding. Tech. rep. 1605. MIT AI Lab,
1997.
[MK05] J. Mooij and H. Kappen. “Sufficient conditions
for convergence of loopy belief propagation”. In: UAI.
2005.
[MK07] G. J. McLachlan and T. Krishnan. The EM
Algorithm and Extensions (Second Edition). Wiley,
2007.
[MK18] T. Miyato and M. Koyama. “cGANs with Pro￾jection Discriminator”. In: International Conference
on Learning Representations. 2018.
[MK19] J. Menick and N. Kalchbrenner. “Generating
high fidelity images with subscale pixel networks and
multidimensional upscaling”. In: ICLR. 2019.
[MK97] G. J. McLachlan and T. Krishnan. The EM
Algorithm and Extensions. Wiley, 1997.
[MKH19] R. Müller, S. Kornblith, and G. E. Hinton.
“When does label smoothing help?” In: NIPS. 2019,
pp. 4694–4703.
[MKL11] O. Martin, R. Kumar, and J. Lao. Bayesian
Modeling and Computation in Python. CRC Press,
2011.
[MKL21] O. A. Martin, R. Kumar, and J. Lao.
Bayesian Modeling and Computation in Python.
CRC Press, 2021.
[MKS21] K. Murphy, A. Kumar, and S. Serghiou. “Risk
score learning for COVID-19 contact tracing apps”. In:
Machine Learning for Healthcare. 2021.
[ML02] T. Minka and J. Lafferty. “Expectation￾propagation for the Generative Aspect Model”.
In: UAI. Morgan Kaufmann Publishers Inc., 2002,
pp. 352–359.
[ML16] S. Mohamed and B. Lakshminarayanan.
“Learning in Implicit Generative Models”. In: (2016).
arXiv: 1610.03483 [stat.ML].
[MLN19] P. Michel, O. Levy, and G. Neubig. “Are Six￾teen Heads Really Better than One?” In: NIPS. 2019.
[MLW19] V. Masrani, T. A. Le, and F. Wood. “The
Thermodynamic Variational Objective”. In: NIPS.
Curran Associates, Inc., 2019, pp. 11521–11530.
[MM01] T. K. Marks and J. R. Movellan. Diffusion
networks, products of experts, and factor analysis.
Tech. rep. University of California San Diego, 2001.
[MM90] D. Q. Mayne and H Michalska. “Receding hori￾zon control of nonlinear systems”. In: IEEE Trans.
Automat. Contr. 35.7 (1990), pp. 814–824.
[MMC98] R. J. McEliece, D. J. C. MacKay, and J. F.
Cheng. “Turbo decoding as an instance of Pearl’s ’be￾lief propagation’ algorithm”. In: IEEE J. on Selected
Areas in Comm. 16.2 (1998), pp. 140–152.
[MMP87] J. Marroquin, S. Mitter, and T. Poggio.
“Probabilistic solution of ill-posed problems in com￾putational vision”. In: JASA 82.297 (1987), pp. 76–
89.
[MMT17] C. J. Maddison, A. Mnih, and Y. W. Teh.
“The Concrete Distribution: A Continuous Relaxation
of Discrete Random Variables”. In: ICLR. 2017.
[MN89] P. McCullagh and J. Nelder. Generalized lin￾ear models. 2nd edition. Chapman and Hall, 1989.
[MNG17a] L. Mescheder, S. Nowozin, and A. Geiger.
“Adversarial variational bayes: Unifying variational
autoencoders and generative adversarial networks”.
In: International Conference on Machine Learning.
PMLR. 2017, pp. 2391–2400.
[MNG17b] L. Mescheder, S. Nowozin, and A. Geiger.
“The numerics of gans”. In: Advances in Neural In￾formation Processing Systems. 2017, pp. 1825–1835.
[Mni+15] V. Mnih et al. “Human-level control through
deep reinforcement learning”. In: Nature 518.7540
(2015), pp. 529–533.
[Mni+16] V. Mnih, A. P. Badia, M. Mirza, A.
Graves, T. P. Lillicrap, T. Harley, D. Silver, and K.
Kavukcuoglu. “Asynchronous Methods for Deep Rein￾forcement Learning”. In: ICML. 2016.
[MO14] M. Mirza and S. Osindero. “Conditional
generative adversarial nets”. In: arXiv preprint
arXiv:1411.1784 (2014).
[Moc+96] J. Mockus, W. Eddy, A. Mockus, L. Mockus,
and G. Reklaitis. Bayesian Heuristic Approach to
Discrete and Global Optimization: Algorithms, Visu￾alization, Software, and Applications. Kluwer, 1996.
[Moh+20] S. Mohamed, M. Rosca, M. Figurnov, and A.
Mnih. “Monte Carlo Gradient Estimation in Machine
Learning”. In: JMLR 21.132 (2020), pp. 1–62.
[Mon81] G. Monge. “Mémoire sur la théorie des déblais
et des remblais”. In: Histoire de l’Académie Royale
des Sciences (1781), pp. 666–704.
[Mor+11] F. Morcos, A. Pagnani, B. Lunt, A.
Bertolino, D. S. Marks, C. Sander, R. Zecchina, J. N.
Onuchic, T. Hwa, and M. Weigt. “Direct-coupling
analysis of residue coevolution captures native con￾tacts across many protein families”. en. In: Proc. Natl.
Acad. Sci. U. S. A. 108.49 (2011), E1293–301.
[Mor+16] R. D. Morey, R. Hoekstra, J. N. Rouder,
M. D. Lee, and E.-J. Wagenmakers. “The fallacy of
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
placing confidence in confidence intervals”. en. In: Psy￾chon. Bull. Rev. 23.1 (2016), pp. 103–123.
[Mor+21a] W. Morningstar, C. Ham, A. Gallagher, B.
Lakshminarayanan, A. Alemi, and J. Dillon. “Density
of States Estimation for Out of Distribution Detec￾tion”. In: AISTATS. Ed. by A. Banerjee and K. Fuku￾mizu. Vol. 130. Proceedings of Machine Learning Re￾search. PMLR, 2021, pp. 3232–3240.
[Mor+21b] W. Morningstar, S. Vikram, C. Ham, A.
Gallagher, and J. Dillon. “Automatic Differentiation
Variational Inference with Mixtures”. In: AISTATS.
Ed. by A. Banerjee and K. Fukumizu. Vol. 130. Pro￾ceedings of Machine Learning Research. PMLR, 2021,
pp. 3250–3258.
[Mor63] T. Morimoto. “Markov Processes and the H￾Theorem”. In: J. Phys. Soc. Jpn. 18.3 (1963), pp. 328–
331.
[MOT15] A. Mordvintsev, C. Olah, and M. Tyka. In￾ceptionism: Going Deeper into Neural Networks.
https : / / ai . googleblog . com / 2015 / 06 / inceptionism -
going - deeper - into - neural . html. Accessed: NA-NA￾NA. 2015.
[Mov08] J. R. Movellan. “A minimum velocity ap￾proach to learning”. In: unpublished draft, Jan (2008).
[MP01] K. Murphy and M. Paskin. “Linear time infer￾ence in hierarchical HMMs”. In: NIPS. 2001.
[MP21] D. Mazza and M. Pagani. “Automatic Differ￾entiation in PCF”. In: Proc. ACM Program. Lang.
5.POPL (2021).
[MP95] D. MacKay and L. Peto. “A hierarchical dirich￾let language model”. In: Natural Language Engineer￾ing 1.3 (1995), pp. 289–307.
[MPS18] O. Mangoubi, N. S. Pillai, and A. Smith.
“Does Hamiltonian Monte Carlo mix faster than a ran￾dom walk on multimodal densities?” In: (2018). arXiv:
1808.03230 [math.PR].
[MPT13] K. Mohan, J. Pearl, and J. Tian. “Graphi￾cal models for inference with missing data”. In: NIPS.
2013.
[MR09] A. Melkumyan and F. Ramos. “A Sparse Co￾variance Function for Exact Gaussian Process Infer￾ence in Large Datasets”. In: IJCAI. 2009, pp. 1936–
1942.
[MR10] B. Milch and S. Russell. “Extending Bayesian
Networks to the Open-Universe Case”. In: Heuristics,
Probability and Causality. A Tribute to Judea Pearl.
Ed. by R. Dechter, H. Geffner, and J. Y. Halper. Col￾lege Publications, 2010.
[MRB18] A. S. Morcos, M. Raghu, and S. Bengio. “In￾sights on representational similarity in neural net￾works with canonical correlation”. In: Advances in
neural information processing systems (2018).
[MRW19] B. Mittelstadt, C. Russell, and S. Wachter.
“Explaining explanations in AI”. In: Proceedings of
the conference on fairness, accountability, and trans￾parency. 2019, pp. 279–288.
[MS67] J McNamee and F Stenger. “Construction of
fully symmetric numerical integration formulas of fully
symmetric numerical integration formulas”. In: Nu￾mer. Math. 10.4 (Nov. 1967), pp. 327–344.
[MS96] V Matveev V and R Shrock. “Complex￾temperature singularities in Potts models on the
square lattice”. en. In: Phys. Rev. E Stat. Phys. Plas￾mas Fluids Relat. Interdiscip. Topics 54.6 (1996),
pp. 6174–6185.
[MS99] C. Manning and H. Schuetze. Foundations of
statistical natural language processing. MIT Press,
1999.
[MSA18] S. Makridakis, E. Spiliotis, and V. Assi￾makopoulos. “The M4 Competition: Results, findings,
conclusion and way forward”. In: Int. J. Forecast. 34.4
(2018), pp. 802–808.
[MT12] A. Mnih and Y. W. Teh. “A fast and simple
algorithm for training neural probabilistic language
models”. In: ICML. 2012, pp. 419–426.
[MTM14] C. J. Maddison, D. Tarlow, and T. Minka.
“A* Sampling”. In: NIPS. 2014.
[MTS22] Y. Ma, D. Tsao, and H.-Y. Shum. “On the
Principles of Parsimony and Self-Consistency for the
Emergence of Intelligence”. In: (July 2022). arXiv:
2207.04630 [cs.AI].
[Mua+17] K. Muandet, K. Fukumizu, B. Sriperum￾budur, and B. Schölkopf. “Kernel Mean Embedding
of Distributions: A Review and Beyond”. In: Founda￾tions and Trends 10.1-2 (2017), pp. 1–141.
[Mua+20] K. Muandet, A. Mehrjou, S. K. Lee, and A.
Raj. Dual Instrumental Variable Regression. 2020.
[Muk+18] S. Mukherjee, D. Shankar, A. Ghosh, N.
Tathawadekar, P. Kompalli, S. Sarawagi, and K.
Chaudhury. “ARMDN: Associative and Recurrent
Mixture Density Networks for eRetail Demand Fore￾casting”. In: (2018). arXiv: 1803.03800 [cs.LG].
[Mül+19a] T. Müller, B. McWilliams, F. Rousselle, M.
Gross, and J. Novák. “Neural Importance Sampling”.
In: SIGGRAPH. 2019.
[Mül+19b] T. Müller, B. McWilliams, F. Rousselle, M.
Gross, and J. Novák. “Neural importance sampling”.
In: ACM Transactions on Graphics 38.5 (2019),
p. 145.
[Mun14] R. Munos. “From Bandits to Monte-Carlo
Tree Search: The Optimistic Principle Applied to Opti￾mization and Planning”. In: Foundations and Trends
in Machine Learning 7.1 (2014), pp. 1–129.
[Mun+16] R. Munos, T. Stepleton, A. Harutyunyan,
and M. G. Bellemare. “Safe and Efficient Off-Policy
Reinforcement Learning”. In: NIPS. 2016, pp. 1046–
1054.
[Mun57] J. Munkres. “Algorithms for the assignment
and transportation problems”. In: Journal of the soci￾ety for industrial and applied mathematics 5.1 (1957),
pp. 32–38.
[Mur00] K. Murphy. “Bayesian Map Learning in Dy￾namic Environments”. In: NIPS. Vol. 12. 2000.
[Mur02] K. Murphy. “Dynamic Bayesian Networks:
Representation, Inference and Learning”. PhD thesis.
Dept. Computer Science, UC Berkeley, 2002.
[Mur+19] W. J. Murdoch, C. Singh, K. Kumbier, R.
Abbasi-Asl, and B. Yu. “Definitions, methods, and ap￾plications in interpretable machine learning”. In: Pro￾ceedings of the National Academy of Sciences 116.44
(2019), pp. 22071–22080.
[Mur22] K. P. Murphy. Probabilistic Machine Learn￾ing: An introduction. MIT Press, 2022.
[MW15] S. Morgan and C. Winship. Counterfactu￾als and Causal Inference. 2nd. Cambridge University
Press, 2015.
[MWJ99] K. Murphy, Y. Weiss, and M. Jordan. “Loopy
Belief Propagation for Approximate Inference: an Em￾pirical Study”. In: UAI. 1999.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1292
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[MYM18] J. Marino, Y. Yue, and S. Mandt. “Iterative
Amortized Inference”. In: ICML. 2018.
[Nac+17] O. Nachum, M. Norouzi, K. Xu, and D. Schu￾urmans. “Bridging the Gap Between Value and Pol￾icy Based Reinforcement Learning”. In: NIPS. 2017,
pp. 2772–2782.
[Nac+19a] O. Nachum, Y. Chow, B. Dai, and L.
Li. “DualDICE: Behavior-agnostic Estimation of Dis￾counted Stationary Distribution Corrections”. In:
NeurIPS. 2019, pp. 2315–2325.
[Nac+19b] O. Nachum, B. Dai, I. Kostrikov, Y. Chow,
L. Li, and D. Schuurmans. Algae: Policy Gradient
from Arbitrary Experience. CoRR abs/1912.02074.
2019.
[Nad+19] S. Naderi, K. He, R. Aghajani, S. Sclaroff,
and P. Felzenszwalb. “Generalized Majorization￾Minimization”. In: ICML. 2019.
[Nae+18] C. A. Naesseth, S. W. Linderman, R. Ran￾ganath, and D. M. Blei. “Variational Sequential Monte
Carlo”. In: AISTATS. 2018.
[Nal18] E. T. Nalisnick. “On Priors for Bayesian Neural
Networks”. PhD thesis. UC Irvine, 2018.
[Nal+19a] E. Nalisnick, A. Matsukawa, Y. W. Teh, D.
Gorur, and B. Lakshminarayanan. “Do Deep Gener￾ative Models Know What They Don’t Know?” In:
ICLR. 2019.
[Nal+19b] E. Nalisnick, A. Matsukawa, Y. W. Teh, D.
Gorur, and B. Lakshminarayanan. “Hybrid Models
with Deep and Invertible Features”. In: ICML. 2019,
pp. 4723–4732.
[Nau04] J. Naudts. “Estimators, escort probabilities
and φ-exponential families in statistical physics”. In:
J. of Inequalities in Pure and Applied Mathematics
5.4 (2004).
[NB05] M. Narasimhan and J. Bilmes. “A Submodular￾Supermodular Procedure with Applications to Dis￾criminative Structure Learning”. In: Uncertainty in
Artificial Intelligence: Proceedings of the Twentieth
Conference (UAI-2004). Edinburgh, Scotland: Mor￾gan Kaufmann Publishers, 2005.
[NB06] M. Narasimhan and J. Bilmes. Learning
Graphical Models over partial k-trees. Tech. rep.
UWEETR-2006-0001. https://vannevar.ece.uw.edu/
techsite/papers/refer/UWEETR- 2006- 0001.html. Uni￾versity of Washington, Department of Electrical Engi￾neering, 2006.
[NBS18] B. Neyshabur, S. Bhojanapalli, and N. Srebro.
“A PAC-Bayesian Approach to Spectrally-Normalized
Margin Bounds for Neural Networks”. In: ICLR. 2018.
[NCH15] M. Naeini, G. Cooper, and M. Hauskrecht.
“Obtaining well calibrated probabilities using
Bayesian binning”. In: AAAI. 2015.
[NCL20] T. Nguyen, Z. Chen, and J. Lee. “Dataset
Meta-Learning from Kernel Ridge-Regression”. In: In￾ternational Conference on Learning Representations.
2020.
[NCT16a] S. Nowozin, B. Cseke, and R. Tomioka. “ f￾GAN: Training Generative Neural Samplers using
Variational Divergence Minimization”. In: NIPS. Ed.
by D. D. Lee, M Sugiyama, U. V. Luxburg, I Guyon,
and R Garnett. Curran Associates, Inc., 2016, pp. 271–
279.
[NCT16b] S. Nowozin, B. Cseke, and R. Tomioka. “ f￾gan: Training generative neural samplers using vari￾ational divergence minimization”. In: NIPS. 2016,
pp. 271–279.
[NCT16c] S. Nowozin, B. Cseke, and R. Tomioka. “ f￾gan: Training generative neural samplers using varia￾tional divergence minimization”. In: Advances in neu￾ral information processing systems. 2016, pp. 271–
279.
[ND20] O. Nachum and B. Dai. “Reinforcement Learn￾ing via Fenchel-Rockafellar Duality”. In: (2020). arXiv:
2001.01866 [cs.LG].
[ND21] A. Nichol and P. Dhariwal. “Improved denois￾ing diffusion probabilistic models”. In: ICML. 2021.
[NDL20] A. Nishimura, D. Dunson, and J. Lu. “Discon￾tinuous Hamiltonian Monte Carlo for discrete param￾eters and discontinuous likelihoods”. In: Biometrika
(2020).
[Nea01] R. M. Neal. “Annealed Importance Sampling”.
In: Statistics and Computing 11 (2001), pp. 125–139.
[Nea03] R. Neal. “Slice sampling”. In: Annals of Statis￾tics 31.3 (2003), pp. 7–5–767.
[Nea+08] R. Neal et al. “Computing likelihood func￾tions for high-energy physics experiments when distri￾butions are defined by simulators with nuisance pa￾rameters”. In: (2008).
[Nea10] R. Neal. “MCMC using Hamiltonian Dynam￾ics”. In: Handbook of Markov Chain Monte Carlo. Ed.
by S. Brooks, A. Gelman, G. Jones, and X.-L. Meng.
Chapman & Hall, 2010.
[Nea12] R. C. Neath. “On Convergence Properties of
the Monte Carlo EM Algorithm”. In: arXiv [math.ST]
(2012).
[Nea20] B. Neal. Introduction to Causal Inference
from a Machine Learning Perspective. 2020.
[Nea92] R. Neal. “Connectionist learning of belief net￾works”. In: Artificial Intelligence 56 (1992), pp. 71–
113.
[Nea93] R. M. Neal. Probabilistic Inference using
Markov Chain Monte Carlo Methods. Tech. rep.
CRG-TR-93-1. 144pp. Dept. of Computer Science,
University of Toronto, 1993.
[Nea96] R. Neal. Bayesian learning for neural net￾works. Springer, 1996.
[Nef+02] A. Nefian, L. Liang, X. Pi, X. Liu, and
K. Murphy. “Dynamic Bayesian Networks for Audio￾Visual Speech Recognition”. In: J. Applied Signal Pro￾cessing (2002).
[Neg+21] J. Negrea, J. Yang, H. Feng, D. M. Roy, and
J. H. Huggins. “Statistical inference with stochastic
gradient algorithms”. 2021.
[Nei+18] D. Neil, J. Briody, A. Lacoste, A. Sim, P.
Creed, and A. Saffari. “Interpretable graph convolu￾tional neural networks for inference on noisy knowl￾edge graphs”. In: arXiv preprint arXiv:1812.00279
(2018).
[Nel21] Nelson Elhage and Neel Nanda and Catherine
Olsson and Tom Henighan and Nicholas Joseph and
Ben Mann and Amanda Askell and Yuntao Bai and
Anna Chen and Tom Conerly and Nova DasSarma
and Dawn Drain and Deep Ganguli and Zac Hatfield￾Dodds and Danny Hernandez and Andy Jones and
Jackson Kernion and Liane Lovitt and Kamal Ndousse
and Dario Amodei and Tom Brown and Jack Clark
and Jared Kaplan and Sam McCandlish and Chris
Olah. A Mathematical Framework for Transformer
Circuits. Tech. rep. Anthropic, 2021.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Neu11] G. Neumann. “Variational Inference for Pol￾icy Search in Changing Situations”. In: ICML. 2011,
pp. 817–824.
[Ney+17] B. Neyshabur, S. Bhojanapalli, D.
McAllester, and N. Srebro. “Exploring generalization
in deep learning”. In: NIPS. 2017.
[NF16] M. Noroozi and P. Favaro. “Unsupervised learn￾ing of visual representations by solving jigsaw puz￾zles”. In: European conference on computer vision.
Springer. 2016, pp. 69–84.
[NG01] D. Nilsson and J. Goldberger. “Sequentially
finding the N-Best List in Hidden Markov Models”. In:
IJCAI. 2001, pp. 1280–1285.
[Ng+11] A. Ng et al. “Sparse autoencoder”. In: CS294A
Lecture notes 72.2011 (2011), pp. 1–19.
[Ngi+11] J. Ngiam, Z. Chen, P. W. Koh, and A. Y. Ng.
“Learning deep energy models”. In: Proceedings of the
28th international conference on machine learning
(ICML-11). 2011, pp. 1105–1112.
[Ngi+18] J. Ngiam, D. Peng, V. Vasudevan, S. Korn￾blith, Q. V. Le, and R. Pang. “Domain adaptive trans￾fer learning with specialist models”. In: arXiv preprint
arXiv:1811.07056 (2018).
[Ngu+16] A. Nguyen, A. Dosovitskiy, J. Yosinski, T.
Brox, and J. Clune. Synthesizing the preferred inputs
for neurons in neural networks via deep generator
networks. 2016. arXiv: 1605.09304 [cs.NE].
[Ngu+18] C. V. Nguyen, Y. Li, T. D. Bui, and R. E.
Turner. “Variational Continual Learning”. In: ICLR.
2018.
[Ngu+19] T. T. Nguyen, Q. V. H. Nguyen, D. T.
Nguyen, D. T. Nguyen, Thien Huynh-The, S. Naha￾vandi, T. T. Nguyen, Q.-V. Pham, and C. M. Nguyen.
“Deep Learning for Deepfakes Creation and Detection:
A Survey”. In: (2019). arXiv: 1909.11573 [cs.CV].
[Ngu+21] T. Nguyen, R. Novak, L. Xiao, and J. Lee.
“Dataset Distillation with Infinitely Wide Convolu￾tional Networks”. In: Advances in Neural Informa￾tion Processing Systems. Ed. by A. Beygelzimer, Y.
Dauphin, P. Liang, and J. W. Vaughan. 2021.
[NH98a] R. M. Neal and G. E. Hinton. “A new view of
the EM algorithm that justifies incremental and other
variants”. In: Learning in Graphical Models. Ed. by
M. Jordan. MIT Press, 1998.
[NH98b] R. M. Neal and G. E. Hinton. “A View of the
EM Algorithm that Justifies Incremental, Sparse, and
other Variants”. In: Learning in Graphical Models. Ed.
by M. I. Jordan. Springer Netherlands, 1998, pp. 355–
368.
[NHLS19] E. Nalisnick, J. M. Hernández-Lobato, and
P. Smyth. “Dropout as a Structured Shrinkage Prior”.
In: ICML. 2019.
[NHR99] A. Ng, D. Harada, and S. Russell. “Policy in￾variance under reward transformations: Theory and
application to reward shaping”. In: ICML. 1999.
[NI92] H. Nagamochi and T. Ibaraki. “Computing edge￾connectivity of multigraphs and capacitated graphs”.
In: SIAM J. Discrete Math. 5 (1992), pp. 54–66.
[Nig+00] K. Nigam, A. K. Mccallum, S. Thrun, and T.
Mitchell. “Text Classification from Labeled and Un￾labeled Documents using EM”. In: MLJ 39.2 (May
2000), pp. 103–134.
[Nij+19] E. Nijkamp, M. Hill, S.-C. Zhu, and Y. N.
Wu. “Learning non-convergent non-persistent short￾run MCMC toward energy-based model”. In: NIPS.
2019, pp. 5232–5242.
[Nix+19] J. Nixon, M. Dusenberry, L. Zhang, G. Jerfel,
and D. Tran. “Measuring Calibration in Deep Learn￾ing”. In: (2019). arXiv: 1904.01685 [cs.LG].
[NJ00] A. Y. Ng and M. Jordan. “PEGASUS: A pol￾icy search method for large MDPs and POMDPs”. In:
UAI. 2000.
[NJB05] M. Narasimhan, N. Jojic, and J. A. Bilmes.
“Q-clustering”. In: Advances in Neural Information
Processing Systems 18 (2005), pp. 979–986.
[NK17] V. Nagarajan and J. Z. Kolter. “Gradient de￾scent GAN optimization is locally stable”. In: Ad￾vances in neural information processing systems.
2017, pp. 5585–5595.
[NKI10] K. Nagano, Y. Kawahara, and S. Iwata. “Mini￾mum average cost clustering”. In: Advances in Neural
Information Processing Systems 23 (2010), pp. 1759–
1767.
[NLS15] C. A. Naesseth, F. Lindsten, and T. B. Schön.
“Nested Sequential Monte Carlo Methods”. In: ICML.
2015.
[NLS19] C. A. Naesseth, F. Lindsten, and T. B. Schön.
“Elements of Sequential Monte Carlo”. In: Founda￾tions and Trends in Machine Learning (2019).
[NM12] A. Nenkova and K. McKeown. “A survey of
text summarization techniques”. In: Mining text data.
Springer, 2012, pp. 43–76.
[NMC05] A. Niculescu-Mizil and R. Caruana. “Predict￾ing Good Probabilities with Supervised Learning”. In:
ICML. 2005.
[NNP19] W. Nie, N. Narodytska, and A. Patel. “Rel￾GAN: Relational Generative Adversarial Networks for
Text Generation”. In: International Conference on
Learning Representations. 2019.
[Noc+21] L. Noci, K. Roth, G. Bachmann, S. Nowozin,
and T. Hofmann. “Disentangling the Roles of Cura￾tion, Data-Augmentation and the Prior in the Cold
Posterior Effect”. In: NIPS. 2021.
[Noé+19] F. Noé, S. Olsson, J. Köhler, and H. Wu.
“Boltzmann generators: Sampling equilibrium states
of many-body systems with deep learning”. In: Sci￾ence 365 (2019).
[Nou+02] M. N. Nounou, B. R. Bakshi, P. K. Goel, and
X. Shen. “Process modeling by Bayesian latent vari￾able regression”. In: Am. Inst. Chemical Engineers
Journal 48.8 (2002), pp. 1775–1793.
[Nov+19] R. Novak, L. Xiao, J. Lee, Y. Bahri, G.
Yang, J. Hron, D. A. Abolafia, J. Pennington, and
J. Sohl-Dickstein. “Bayesian Deep Convolutional Net￾works with Many Channels are Gaussian Processes”.
In: ICLR. 2019.
[NP03] W. K. Newey and J. L. Powell. “Instrumen￾tal variable estimation of nonparametric models”. In:
Econometrica 71.5 (2003), pp. 1565–1578.
[NR00a] A. Ng and S. Russell. “Algorithms for inverse
reinforcement learning”. In: ICML. 2000.
[NR00b] A. Y. Ng and S. Russell. “Algorithms for
Inverse Reinforcement Learning”. In: in Proc. 17th
International Conf. on Machine Learning. Citeseer.
2000.
[NR94] M. Newton and A. Raftery. “Approximate
Bayesian Inference with the Weighted Likelihood
Bootstrap”. In: J. of Royal Stat. Soc. Series B 56.1
(1994), pp. 3–48.
[NS17] E. Nalisnick and P. Smyth. “Variational Refer￾ence Priors”. In: ICLR Workshop. 2017.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1294
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[NS18] E. Nalisnick and P. Smyth. “Learning Priors for
Invariance”. In: AISTATS. 2018.
[NW06] J. Nocedal and S. Wright. Numerical Opti￾mization. Springer, 2006.
[NW20] X Nie and S Wager. “Quasi-oracle estimation
of heterogeneous treatment effects”. In: Biometrika
108.2 (Sept. 2020), pp. 299–319. eprint: https : / /
academic . oup . com / biomet / article - pdf / 108 / 2 / 299 /
37938939/asaa076.pdf.
[NWF78] G. Nemhauser, L. Wolsey, and M. Fisher.
“An analysis of approximations for maximizing sub￾modular set functions—I”. In: Mathematical Program￾ming 14.1 (1978), pp. 265–294.
[NWJ09] X. Nguyen, M. J. Wainwright, and M. I. Jor￾dan. “On Surrogate Loss Functions and f-Divergences”.
In: Ann. Stat. 37.2 (2009), pp. 876–904.
[NWJ+09] X. Nguyen, M. J. Wainwright, M. I. Jordan,
et al. “On surrogate loss functions and f-divergences”.
In: The Annals of Statistics 37.2 (2009), pp. 876–904.
[NWJ10a] X Nguyen, M. J. Wainwright, and M. I. Jor￾dan. “Estimating Divergence Functionals and the Like￾lihood Ratio by Convex Risk Minimization”. In: IEEE
Trans. Inf. Theory 56.11 (2010), pp. 5847–5861.
[NWJ10b] X. Nguyen, M. J. Wainwright, and M. I. Jor￾dan. “Estimating divergence functionals and the like￾lihood ratio by convex risk minimization”. In: IEEE
Transactions on Information Theory 56.11 (2010),
pp. 5847–5861.
[NYC15] A. Nguyen, J. Yosinski, and J. Clune. “Deep
Neural Networks are Easily Fooled: High Confidence
Predictions for Unrecognizable Images”. In: CVPR.
2015.
[OA09] M. Opper and C. Archambeau. “The varia￾tional Gaussian approximation revisited”. en. In: Neu￾ral Comput. 21.3 (2009), pp. 786–792.
[OAC18] I. Osband, J. Aslanides, and A. Cassirer.
“Randomized prior functions for deep reinforcement
learning”. In: NIPS. 2018.
[Obe+19] F. Obermeyer, E. Bingham, M. Jankowiak, J.
Chiu, N. Pradhan, A. Rush, and N. Goodman. “Ten￾sor Variable Elimination for Plated Factor Graphs”. In:
ICML. 2019.
[OCM21] L. A. Ortega, R. Cabañas, and A. R.
Masegosa. “Diversity and Generalization in Neural
Network Ensembles”. In: (2021). arXiv: 2110 . 13786
[cs.LG].
[ODK96] M. Ostendorf, V. Digalakis, and O. Kimball.
“From HMMs to segment models: a unified view of
stochastic modeling for speech recognition”. In: IEEE
Trans. on Speech and Audio Processing 4.5 (1996),
pp. 360–378.
[OED21] J. Ortiz, T. Evans, and A. J. Davison. “A vi￾sual introduction to Gaussian Belief Propagation”. In:
arXiv preprint arXiv:2107.02308 (2021).
[OF96] B. A. Olshausen and D. J. Field. “Emergence
of simple cell receptive field properties by learning a
sparse code for natural images”. In: Nature 381 (1996),
pp. 607–609.
[O’H78] A. O’Hagan. “Curve Fitting and Optimal De￾sign for Prediction”. In: J. of Royal Stat. Soc. Series
B 40 (1978), pp. 1–42.
[OKK16] A. Van den Oord, N. Kalchbrenner, and K.
Kavukcuoglu. “Pixel Recurrent Neural Networks”. In:
ICML. 2016.
[Oll+17] Y. Ollivier, L. Arnold, A. Auger, and N.
Hansen. “Information-Geometric Optimization Algo￾rithms: A Unifying Picture via Invariance Principles”.
In: JMLR 18 (2017), pp. 1–65.
[Oll18] Y. Ollivier. “Online natural gradient as a
Kalman filter”. en. In: Electron. J. Stat. 12.2 (2018),
pp. 2930–2961.
[OLV18a] A. van den Oord, Y. Li, and O. Vinyals.
“Representation Learning with Contrastive Predictive
Coding”. In: (2018). arXiv: 1807.03748 [cs.LG].
[OLV18b] A. v. d. Oord, Y. Li, and O. Vinyals. “Repre￾sentation learning with contrastive predictive coding”.
In: arXiv preprint arXiv:1807.03748 (2018).
[OM96] P. V. Overschee and B. D. Moor. Subspace
Identification for Linear Systems: Theory, Imple￾mentation, Applications. Kluwer Academic Publish￾ers, 1996.
[OMS17] C. Olah, A. Mordvintsev, and L. Schubert.
“Feature Visualization”. In: Distill 2.11 (2017).
[O’N09] B. O’Neill. “Exchangeability, Correlation, and
Bayes’ Effect”. In: Int. Stat. Rev. 77.2 (2009), pp. 241–
250.
[ONS18] V. M.-H. Ong, D. J. Nott, and M. S. Smith.
“Gaussian Variational Approximation With a Factor
Covariance Structure”. In: J. Comput. Graph. Stat.
27.3 (2018), pp. 465–478.
[oor+16] A. Van den oord, S. Dieleman, H. Zen, K. Si￾monyan, O. Vinyals, A. Graves, N. Kalchbrenner, A.
Senior, and K. Kavukcuoglu. “WaveNet: A Generative
Model for Raw Audio”. In: (2016). arXiv: 1609.03499
[cs.SD].
[Oor+16] A. van den Oord, N. Kalchbrenner, O.
Vinyals, L. Espeholt, A. Graves, and K. Kavukcuoglu.
“Conditional Image Generation with PixelCNN De￾coders”. In: (2016). arXiv: 1606.05328 [cs.CV].
[Oor+18] A. van den Oord et al. “Parallel WaveNet:
Fast High-Fidelity Speech Synthesis”. In: ICML. Ed.
by J. Dy and A. Krause. Vol. 80. Proceedings of Ma￾chine Learning Research. PMLR, 2018, pp. 3918–3926.
[Oor+19] A. van den Oord, B. Poole, O. Vinyals, and A.
Razavi. “Fixing Posterior Collapse with delta-VAEs”.
In: ICLR. 2019.
[OOS17] A. Odena, C. Olah, and J. Shlens. “Condi￾tional image synthesis with auxiliary classifier gans”.
In: International conference on machine learning.
2017, pp. 2642–2651.
[Ope] OpenAI. ChatGPT: Optimizing Language Mod￾els for Dialogue. Blog.
[Oqu+14] M. Oquab, L. Bottou, I. Laptev, and J. Sivic.
“Learning and transferring mid-level image represen￾tations using convolutional neural networks”. In: Pro￾ceedings of the IEEE conference on computer vision
and pattern recognition. 2014, pp. 1717–1724.
[OR20] A. Owen and D. Rudolf. “A strong law of large
numbers for scrambled net integration”. In: (2020).
arXiv: 2002.07859 [math.NA].
[Ora19] F. Orabona. “A Modern Introduction to Online
Learning”. In: (Dec. 2019). arXiv: 1912.13213 [cs.LG].
[Ore+20] B. N. Oreshkin, D. Carpov, N. Chapados,
and Y. Bengio. “N-BEATS: Neural basis expansion
analysis for interpretable time series forecasting”. In:
ICLR. 2020.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[ORW21] S. W. Ober, C. E. Rasmussen, and M. van
der Wilk. “The Promises and Pitfalls of Deep Kernel
Learning”. In: ICML. Feb. 2021.
[Osa+18] T. Osa, J. Pajarinen, G. Neumann, J. A. Bag￾nell, P. Abbeel, and J. Peters. “An Algorithmic Per￾spective on Imitation Learning”. In: Foundations and
Trends in Robotics 7.1–2 (2018), pp. 1–179.
[Osa+19a] K. Osawa, S. Swaroop, A. Jain, R. Eschen￾hagen, R. E. Turner, R. Yokota, and M. E. Khan.
“Practical Deep Learning with Bayesian Principles”.
In: NIPS. 2019.
[Osa+19b] K. Osawa, Y. Tsuji, Y. Ueno, A. Naruse,
R. Yokota, and S. Matsuoka. “Large-Scale Dis￾tributed Second-Order Optimization Using Kronecker￾Factored Approximate Curvature for Deep Convolu￾tional Neural Networks”. In: CVPR. 2019.
[Osb16] I. Osband. “Risk versus Uncertainty in Deep
Learning: Bayes, Bootstrap and the Dangers of
Dropout”. In: NIPS workshop on Bayesian deep
learning. 2016.
[Osb+21] I. Osband, Z. Wen, S. M. Asghari, V.
Dwaracherla, B. Hao, M. Ibrahimi, D. Lawson, X.
Lu, B. O’Donoghue, and B. Van Roy. “The Neu￾ral Testbed: Evaluating Predictive Distributions”. In:
(2021). arXiv: 2110.04629 [cs.LG].
[Ose11] I. V. Oseledets. “Tensor-Train Decomposition”.
In: SIAM J. Sci. Comput. 33.5 (2011), pp. 2295–2317.
[OT05] A. B. Owen and S. D. Tribble. “A quasi-Monte
Carlo Metropolis algorithm”. en. In: PNAS 102.25
(2005), pp. 8844–8849.
[Ouy+22] L. Ouyang et al. “Training language models
to follow instructions with human feedback”. In: (Mar.
2022). arXiv: 2203.02155 [cs.CL].
[Ova+19] Y. Ovadia, E. Fertig, J. Ren, Z. Nado, D Scul￾ley, S. Nowozin, J. V. Dillon, B. Lakshminarayanan,
and J. Snoek. “Can You Trust Your Model’s Un￾certainty? Evaluating Predictive Uncertainty Under
Dataset Shift”. In: NIPS. 2019.
[OVK17] A. van den Oord, O. Vinyals, and K.
Kavukcuoglu. “Neural Discrete Representation Learn￾ing”. In: NIPS. 2017.
[Owe13] A. B. Owen. Monte Carlo theory, methods
and examples. 2013.
[Owe17] A. B. Owen. “A randomized Halton algorithm
in R”. In: arXiv [stat.CO] (2017).
[Oxl11] J. Oxley. Matroid Theory: Second Edition. Ox￾ford University Press, 2011.
[Pac+14] J. Pacheco, S. Zuffi, M. Black, and E. Sud￾derth. “Preserving Modes and Messages via Diverse
Particle Selection”. en. In: ICML. 2014, pp. 1152–
1160.
[Pai] Explainable AI in Practice Falls Short of Trans￾parency Goals. https://partnershiponai.org/xai-in￾practice/. Accessed: 2021-11-23.
[Pai+14] T. L. Paine, P. Khorrami, W. Han, and
T. S. Huang. “An analysis of unsupervised pre-training
in light of recent advances”. In: arXiv preprint
arXiv:1412.6597 (2014).
[Pan+10] L. Paninski, Y. Ahmadian, D. G. Ferreira, S.
Koyama, K. Rahnama Rad, M. Vidne, J. Vogelstein,
and W. Wu. “A new look at state-space models for neu￾ral data”. en. In: J. Comput. Neurosci. 29.1-2 (2010),
pp. 107–126.
[Pan+21] G. Pang, C. Shen, L. Cao, and A. Van Den
Hengel. “Deep Learning for Anomaly Detection: A Re￾view”. In: ACM Comput. Surv. 54.2 (2021), pp. 1–38.
[Pan+22] K. Pandey, A. Mukherjee, P. Rai, and A. Ku￾mar. “DiffuseVAE: Efficient, Controllable and High￾Fidelity Generation from Low-Dimensional Latents”.
In: Transactions on Machine Learning Research
(Jan. 2022).
[Pap+17] N. Papernot, P. McDaniel, I. Goodfellow, S.
Jha, Z Berkay Celik, and A. Swami. “Practical Black￾Box Attacks against Deep Learning Systems using Ad￾versarial Examples”. In: ACM Asia Conference on
Computer and Communications Security. 2017.
[Pap+19] G. Papamakarios, E. Nalisnick, D. J.
Rezende, S. Mohamed, and B. Lakshminarayanan.
“Normalizing Flows for Probabilistic Modeling and In￾ference”. In: (2019). arXiv: 1912.02762 [stat.ML].
[Par+19] S Parameswaran, C Deledalle, L Denis, and
T. Q. Nguyen. “Accelerating GMM-Based Patch Pri￾ors for Image Restoration: Three Ingredients for a
100× Speed-Up”. In: IEEE Trans. Image Process.
28.2 (2019), pp. 687–698.
[Par81] G. Parisi. “Correlation functions and computer
simulations”. In: Nuclear Physics B 180.3 (1981),
pp. 378–384.
[Pas+02] H. Pasula, B. Marthi, B. Milch, S. Russell,
and I. Shpitser. “Identity Uncertainty and Citation
Matching”. In: NIPS. 2002.
[Pas+21a] A. Paszke, D. Johnson, D. Duvenaud, D.
Vytiniotis, A. Radul, M. Johnson, J. Ragan-Kelley,
and D. Maclaurin. “Getting to the Point: Index Sets
and Parallelism-Preserving Autodiff for Pointful Ar￾ray Programming”. In: Proc. ACM Program. Lang.
5.ICFP (2021).
[Pas+21b] A. Paszke, M. J. Johnson, R. Frostig, and
D. Maclaurin. “Parallelism-Preserving Automatic Dif￾ferentiation for Second-Order Array Languages”. In:
Proceedings of the 9th ACM SIGPLAN International
Workshop on Functional High-Performance and Nu￾merical Computing. FHPNC 2021. Association for
Computing Machinery, 2021, 13–23.
[Pat+16] D. Pathak, P. Krahenbuhl, J. Donahue, T.
Darrell, and A. A. Efros. “Context encoders: Feature
learning by inpainting”. In: Proceedings of the IEEE
conference on computer vision and pattern recogni￾tion. 2016, pp. 2536–2544.
[Pat+22] Z. B. Patel, P. Purohit, H. M. Patel, S. Sahni,
and N. Batra. “Accurate and Scalable Gaussian Pro￾cesses for Fine-Grained Air Quality Inference”. en. In:
AAAI 36.11 (June 2022), pp. 12080–12088.
[PB14] R. Pascanu and Y. Bengio. “Revisiting Natural
Gradient for Deep Networks”. In: ICLR. 2014.
[PBM16a] J. Peters, P. Bühlmann, and N. Mein￾shausen. “Causal inference by using invariant predic￾tion: identification and confidence intervals”. In: Jour￾nal of the Royal Statistical Society. Series B (Statis￾tical Methodology) 78.5 (2016), pp. 947–1012.
[PBM16b] J. Peters, P. Bühlmann, and N. Mein￾shausen. “Causal inference using invariant prediction:
identification and confidence intervals”. In: J. of Royal
Stat. Soc. Series B 78.5 (2016), pp. 947–1012.
[PC08] T. Park and G. Casella. “The Bayesian Lasso”.
In: JASA 103.482 (2008), pp. 681–686.
[PC09] J. Paisley and L. Carin. “Nonparametric Factor
Analysis with Beta Process Priors”. In: ICML. 2009.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1296
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[PC12] N. Pinto and D. D. Cox. “High-throughput￾derived biologically-inspired features for uncon￾strained face recognition”. In: Image Vis. Comput.
30.3 (2012), pp. 159–168.
[PD03] J. D. Park and A. Darwiche. “A Differential
Semantics for Jointree Algorithms”. In: NIPS. MIT
Press, 2003, pp. 801–808.
[PD11] H. Poon and P. Domingos. “Sum-Product Net￾works: A New Deep Architecture”. In: UAI. Java code
at http://alchemy.cs.washington.edu/spn/. Short in￾tro at http://lessoned.blogspot.com/2011/10/intro-to￾sum-product-networks.html. 2011.
[PdC20] F.-P. Paty, A. d’Aspremont, and M. Cuturi.
“Regularity as Regularization: Smooth and Strongly
Convex Brenier Potentials in Optimal Transport”. In:
Proceedings of the Twenty Third International Con￾ference on Artificial Intelligence and Statistics. Ed.
by S. Chiappa and R. Calandra. Vol. 108. Proceedings
of Machine Learning Research. PMLR, 2020, pp. 1222–
1232.
[PDL+12] M. Parry, A. P. Dawid, S. Lauritzen, et al.
“Proper local scoring rules”. In: The Annals of Statis￾tics 40.1 (2012), pp. 561–592.
[PE16] V. Papyan and M. Elad. “Multi-Scale Patch￾Based Image Restoration”. en. In: IEEE Trans. Image
Process. 25.1 (2016), pp. 249–261.
[Pea09a] J. Pearl. Causality. 2nd. Cambridge Univer￾sity Press, 2009.
[Pea09b] J. Pearl. Causality: Models, Reasoning and
Inference (Second Edition). Cambridge Univ. Press,
2009.
[Pea09c] J. Pearl. “Causal inference in statistics: An
overview”. In: Stat. Surv. 3.0 (2009), pp. 96–146.
[Pea12] J. Pearl. “The Causal Foundations of Struc￾tural Equation Modeling”. In: Handbook of structural
equation modeling. Ed. by R. H. Hoyle. Vol. 68. 2012.
[Pea19] J. Pearl. “The Seven Tools of Causal Inference,
with Reflections on Machine Learning”. In: Comm. of
the ACM 62.3 (2019), pp. 54–60.
[Pea36] K. Pearson. “Method of moments and method
of maximum likelihood”. In: Biometrika 28.1/2 (1936),
pp. 34–59.
[Pea84] J. Pearl. Heuristics: Intelligent Search Strate￾gies for Computer Problem Solving. Addison-Wesley
Longman Publishing Co., Inc., 1984.
[Pea88] J. Pearl. Probabilistic Reasoning in Intelligent
Systems: Networks of Plausible Inference. Morgan
Kaufmann, 1988.
[Pea94] B. A. Pearlmutter. “Fast Exact Multiplica￾tion by the Hessian”. In: Neural Comput. 6.1 (1994),
pp. 147–160.
[Peh+20] R. Peharz, S. Lang, A. Vergari, K. Stelzner,
A. Molina, M. Trapp, G. Van den Broeck, K. Kerst￾ing, and Z. Ghahramani. “Einsum Networks: Fast and
Scalable Learning of Tractable Probabilistic Circuits”.
In: (2020). arXiv: 2004.06231 [cs.LG].
[Pel05] M. Pelikan. Hierarchical Bayesian Optimiza￾tion Algorithm: Toward a New Generation of Evolu￾tionary Algorithms. en. Softcover reprint of hardcover
1st ed. 2005 edition. Springer, 2005.
[Pen13] J. Pena. “Reading dependencies from covari￾ance graphs”. In: Intl. J. of Approximate Reasoning
54.1 (2013).
[Per+18] E. Perez, F. Strub, H. de Vries, V. Dumoulin,
and A. Courville. “FiLM: Visual Reasoning with a
General Conditioning Layer”. In: AAAI. 2018.
[Pes+21] H. Pesonen et al. “ABC of the Future”. In:
(2021). arXiv: 2112.12841 [stat.AP].
[Pey20] G. Peyre. “Course notes on Optimization for
Machine Learning”. 2020.
[Pez+21] M. Pezeshki, S.-O. Kaba, Y. Bengio, A.
Courville, D. Precup, and G. Lajoie. “Gradient Star￾vation: A Learning Proclivity in Neural Networks”. In:
NIPS. 2021.
[PF03] G. V. Puskorius and L. A. Feldkamp.
“Parameter-based Kalman filter training: Theory and
implementation”. In: Kalman Filtering and Neural
Networks. Ed. by S. Haykin. John Wiley & Sons, Inc.,
2003, pp. 23–67.
[PF91] G. V. Puskorius and L. A. Feldkamp. “Decou￾pled extended Kalman filter training of feedforward
layered networks”. In: International Joint Conference
on Neural Networks. Vol. i. 1991, 771–777 vol.1.
[PFW21] R. Prado, M. Ferreira, and M. West. Time
Series: Modelling, Computation and Inference (2nd
ed). CRC Press, 2021.
[PG98] M. Popescu and P. D. Gader. “Image content
retrieval from image databases using feature integra￾tion by Choquet integral”. In: Storage and Retrieval
for Image and Video Databases VII. Ed. by M. M.
Yeung, B.-L. Yeo, and C. A. Bouman. Vol. 3656. In￾ternational Society for Optics and Photonics. SPIE,
1998, pp. 552 –560.
[PGCP00] M Pelikan, D. E. Goldberg, and E Cantú￾Paz. “Linkage problem, distribution estimation, and
Bayesian networks”. en. In: Evol. Comput. 8.3 (2000),
pp. 311–340.
[PGJ16] J. Pearl, M. Glymour, and N. Jewell. Causal
inference in statistics: a primer. Wiley, 2016.
[PH22] M. Phuong and M. Hutter. “Formal Algorithms
for Transformers”. In: (July 2022). arXiv: 2207.09238
[cs.LG].
[PHL12] M. Pelikan, M. Hausschild, and F. Lobo. In￾troduction to estimation of distribution algorithms.
Tech. rep. U. Missouri, 2012.
[PHR18] E. Petersen, C. Hoffmann, and P. Rostalski.
“On Approximate Nonlinear Gaussian Message Pass￾ing On Factor Graphs”. In: IEEE Statistical Signal
Processing Workshop (SSP). 2018.
[Phu+18] M. Phuong, M. Welling, N. Kushman, R.
Tomioka, and S. Nowozin. “The Mutual Autoencoder:
Controlling Information in Latent Code Representa￾tions”. In: Arxiv (2018).
[Pir+13] M. Pirotta, M. Restelli, A. Pecorino, and D.
Calandriello. “Safe Policy Iteration”. In: ICML. 3.
2013, pp. 307–317.
[PJD21] Y. Petetin, Y. Janati, and F. Desbouvries.
“Structured Variational Bayesian Inference for Gaus￾sian State-Space Models With Regime Switching”. In:
IEEE Signal Process. Lett. 28 (2021), pp. 1953–1957.
[PJS17] J. Peters, D. Janzing, and B. Schölkopf. Ele￾ments of Causal Inference: Foundations and Learn￾ing Algorithms (Adaptive Computation and Machine
Learning series). The MIT Press, 2017.
[PKP21] A. Plaat, W. Kosters, and M. Preuss. “High￾Accuracy Model-Based Reinforcement Learning, a Sur￾vey”. In: (2021). arXiv: 2107.08241 [cs.LG].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[PL03] M. A. Paskin and G. D. Lawrence. Junction
Tree Algorithms for Solving Sparse Linear Systems.
Tech. rep. UCB/CSD-03-1271. UC Berkeley, 2003.
[Pla00] J. Platt. “Probabilities for SV machines”. In:
Advances in Large Margin Classifiers. Ed. by A.
Smola, P. Bartlett, B. Schoelkopf, and D. Schuurmans.
MIT Press, 2000.
[Pla18] E. Plaut. “From Principal Subspaces to Prin￾cipal Components with Linear Autoencoders”. In:
ArXiv abs/1804.10253 (2018).
[Ple+18] G. Pleiss, J. R. Gardner, K. Q. Weinberger,
and A. G. Wilson. “Constant-Time Predictive Dis￾tributions for Gaussian Processes”. In: International
Conference on Machine Learning. 2018.
[Plu+20] G. Plumb, M. Al-Shedivat, Á. A. Cabrera,
A. Perer, E. Xing, and A. Talwalkar. “Regularizing
black-box models for improved interpretability”. In:
Advances in Neural Information Processing Systems
33 (2020).
[PM18a] N. Papernot and P. McDaniel. Deep k￾Nearest Neighbors: Towards Confident, Interpretable
and Robust Deep Learning. 2018. arXiv: 1803.04765
[cs.LG].
[PM18b] J. Pearl and D. Mackenzie. The book of why:
the new science of cause and effect. 2018.
[PMT18] G. Plumb, D. Molitor, and A. Talwalkar.
“Supervised Local Modeling for Interpretability”. In:
CoRR abs/1807.02910 (2018). arXiv: 1807.02910.
[Pol+19] A. A. Pol, V. Berger, G. Cerminara, C. Ger￾main, and M. Pierini. “Anomaly Detection With Con￾ditional Variational Autoencoders”. In: IEEE Interna￾tional Conference on Machine Learning and Applica￾tions. 2019.
[Pom89] D. Pomerleau. “ALVINN: An Autonomous
Land Vehicle in a Neural Network”. In: NIPS. 1989,
pp. 305–313.
[Poo+12] D. Poole, D. Buchman, S. Natarajan, and
K. Kersting. “Aggregation and Population Growth:
The Relational Logistic Regression and Markov Logic
Cases”. In: Statistical Relational AI workshop. 2012.
[Poo+19a] B. Poole, S. Ozair, A. van den Oord, A. A.
Alemi, and G. Tucker. “On Variational Bounds of Mu￾tual Information”. In: ICML. 2019.
[Poo+19b] B. Poole, S. Ozair, A. van den Oord, A. A.
Alemi, and G. Tucker. “On variational lower bounds
of mutual information”. In: ICML. 2019.
[Pou04] M. Pourahmadi. Simultaneous Modelling of
Covariance Matrices: GLM, Bayesian and Nonpara￾metric Perspectives. Tech. rep. Northern Illinois Uni￾versity, 2004.
[Poy+20] R. Poyiadzi, K. Sokol, R. Santos-Rodriguez,
T. De Bie, and P. Flach. “FACE: Feasible and action￾able counterfactual explanations”. In: Proceedings of
the AAAI/ACM Conference on AI, Ethics, and So￾ciety. 2020, pp. 344–350.
[PPC09] G. Petris, S. Petrone, and P. Campagnoli. Dy￾namic linear models with R. Springer, 2009.
[PPG91] C. S. Pomerleau, O. F. Pomerleau, and A. W.
Garcia. “Biobehavioral research on nicotine use in
women”. In: British Journal of Addiction 86.5 (1991),
pp. 527–531.
[PPM17] G. Papamakarios, T. Pavlakou, and I. Murray.
“Masked Autoregressive Flow for Density Estimation”.
In: NIPS. 2017.
[PPR22] B. Paria, B. Pòczos, and P. Ravikumar. “Be
greedy – a simple algorithm for blackbox optimization
using neural networks”. In: ICML Workshop on Adap￾tive Experimental Design and Active Learning in the
Real World. 2022.
[PPS18] T. Pierrot, N. Perrin, and O. Sigaud. “First￾order and second-order variants of the gradient de￾scent in a unified framework”. In: (2018). arXiv: 1810.
08102 [cs.LG].
[PR03] O. Papaspiliopoulos and G. O. Roberts. “Non￾Centered Parameterisations for Hierarchical Models
and Data Augmentation”. In: Bayesian Statistics 7
(2003), pp. 307–326.
[Pra+18] S. Prabhumoye, Y. Tsvetkov, R. Salakhut￾dinov, and A. W. Black. “Style Transfer Through
Back-Translation”. In: Proceedings of the 56th An￾nual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers). 2018, pp. 866–
876.
[Pre05] S. J. Press. Applied multivariate analysis, us￾ing Bayesian and frequentist methods of inference.
Second edition. Dover, 2005.
[Pre+17a] V. Premachandran, D. Tarlow, A. L. Yuille,
and D. Batra. “Empirical Minimum Bayes Risk Predic￾tion”. en. In: IEEE PAMI 39.1 (Jan. 2017), pp. 75–86.
[Pre+17b] O. Press, A. Bar, B. Bogin, J. Berant, and L.
Wolf. “Language generation with recurrent generative
adversarial networks without pre-training”. In: arXiv
preprint arXiv:1706.01399 (2017).
[Pre+88] W. Press, W. Vetterling, S. Teukolosky, and
B. Flannery. Numerical Recipes in C: The Art of
Scientific Computing. Second. Cambridge University
Press, 1988.
[PRG17] M. Probst, F. Rothlauf, and J. Grahl. “Scal￾ability of using Restricted Boltzmann Machines for
combinatorial optimization”. In: Eur. J. Oper. Res.
256.2 (2017), pp. 368–383.
[Pri58] R. Price. “A useful theorem for nonlinear de￾vices having Gaussian inputs”. In: IRE Trans. Info.
Theory 4.2 (1958), pp. 69–72.
[PS07] J. Peters and S. Schaal. “Reinforcement Learn￾ing by Reward-Weighted Regression for Operational
Space Control”. In: ICML. 2007, pp. 745–750.
[PS08a] B. A. Pearlmutter and J. M. Siskind. “Reverse￾Mode AD in a Functional Framework: Lambda the
Ultimate Backpropagator”. In: ACM Trans. Program.
Lang. Syst. 30.2 (2008).
[PS08b] J. Peters and S. Schaal. “Reinforcement Learn￾ing of Motor Skills with Policy Gradients”. In: Neural
Networks 21.4 (2008), pp. 682–697.
[PS12] N. G. Polson and J. G. Scott. “On the Half￾Cauchy Prior for a Global Scale Parameter”. en. In:
Bayesian Anal. 7.4 (2012), pp. 887–902.
[PS17] N. G. Polson and V. Sokolov. “Deep Learning:
A Bayesian Perspective”. en. In: Bayesian Anal. 12.4
(2017), pp. 1275–1304.
[PSCP06] M. Pelikan, K. Sastry, and E. Cantú-Paz.
Scalable Optimization via Probabilistic Modeling:
From Algorithms to Applications (Studies in Compu￾tational Intelligence). Springer-Verlag New York, Inc.,
2006.
[PSD00] J. K. Pritchard, M Stephens, and P Donnelly.
“Inference of population structure using multilocus
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1298
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
genotype data”. In: Genetics 155.2 (2000), pp. 945–
959.
[PSDG14] B. Poole, J. Sohl-Dickstein, and S. Ganguli.
“Analyzing noise in autoencoders and deep networks”.
In: arXiv preprint arXiv:1406.1831 (2014).
[PSM19] G. Papamakarios, D. Sterratt, and I. Mur￾ray. “Sequential Neural Likelihood: Fast Likelihood￾free Inference with Autoregressive Flows”. In: AIS￾TATS. 2019.
[PSS00] D. Precup, R. S. Sutton, and S. P. Singh. “El￾igibility Traces for Off-Policy Policy Evaluation”. In:
ICML. ICML ’00. Morgan Kaufmann Publishers Inc.,
2000, pp. 759–766.
[PT13] S. Patterson and Y. W. Teh. “Stochastic Gradi￾ent Riemannian Langevin Dynamics on the Probabil￾ity Simplex”. In: NIPS. 2013.
[PT87] C. Papadimitriou and J. Tsitsiklis. “The com￾plexity of Markov decision processes”. In: Mathemat￾ics of Operations Research 12.3 (1987), pp. 441–450.
[PT94] P. Paatero and U. Tapper. “Positive Matrix Fac￾torization: A Non-negative Factor Model with Opti￾mal Utilization of Error Estimates of Data Values”. In:
Environmetrics 5 (1994), pp. 111–126.
[PTD20] A. Prabhu, P. H. S. Torr, and P. K. Doka￾nia. “GDumb: A simple approach that questions our
progress in continual learning”. In: ECCV. Lecture
notes in computer science. Springer International Pub￾lishing, 2020, pp. 524–540.
[Put94] M. L. Puterman. Markov Decision Processes:
Discrete Stochastic Dynamic Programming. Wiley,
1994.
[PVC19] R. Prenger, R. Valle, and B. Catanzaro.
“WaveGLOW: A flow-based generative network for
speech synthesis”. In: Proceedings of the 2019 IEEE
International Conference on Acoustics, Speech and
Signal Processing. IEEE. 2019, pp. 3617–3621.
[PW05] S. Parise and M. Welling. “Learning in Markov
Random Fields: An Empirical Study”. In: Joint Sta￾tistical Meeting. 2005.
[PX22] W. Peebles and S. Xie. “Scalable Diffusion Mod￾els with Transformers”. In: (Dec. 2022). arXiv: 2212.
09748 [cs.CV].
[PY10] G. Papandreou and A. L. Yuille. “Gaussian
sampling by local perturbations”. In: NIPS. 2010.
[PY11] G Papandreou and A. L. Yuille. “Perturb-and￾MAP random fields: Using discrete optimization to
learn and sample from energy models”. In: ICCV. Nov.
2011, pp. 193–200.
[PY14] G. Papandreou and A. Yuille. “Perturb-and￾MAP Random Fields: Reducing Random Sampling
to Optimization, with Applications in Computer Vi￾sion”. In: Advanced Structured Prediction. Ed. by S.
Nowozin, P. Gehler, J. Jancsary, C. Lampert. MIT
Press, 2014.
[QC+06] J. Quiñonero-Candela, C. E. Rasmussen, F.
Sinz, O. Bousquet, and B. Schölkopf. “Evaluating Pre￾dictive Uncertainty Challenge”. In: Machine Learn￾ing Challenges. Evaluating Predictive Uncertainty,
Visual Object Classification, and Recognising Tec￾tual Entailment. Lecture Notes in Computer Science.
Springer Berlin Heidelberg, 2006, pp. 1–27.
[QC+08] J. Quinonero-Candela, M. Sugiyama, A.
Schwaighofer, and N. D. Lawrence, eds. Dataset Shift
in Machine Learning. en. The MIT Press, 2008.
[QCR05] J. Quinonero-Candela and C. Rasmussen. “A
unifying view of sparse approximate Gaussian process
regression”. In: JMLR 6.3 (2005), pp. 1939–1959.
[Qin+20] C. Qin, Y. Wu, J. T. Springenberg, A. Brock,
J. Donahue, T. P. Lillicrap, and P. Kohli. “Train￾ing Generative Adversarial Networks by Solving Or￾dinary Differential Equations”. In: arXiv preprint
arXiv:2010.15040 (2020).
[QRJN18] J. Qiu, S Rao Jammalamadaka, and N. Ning.
“Multivariate Bayesian Structural Time Series Model”.
In: JMLR 19.68 (2018), pp. 1–33.
[Qu+21] H. Qu, H. Rahmani, L. Xu, B. Williams, and
J. Liu. “Recent Advances of Continual Learning in
Computer Vision: An Overview”. In: (2021). arXiv:
2109.11369 [cs.CV].
[Qua+07] A. Quattoni, S. Wang, L.-P. Morency, M.
Collins, and T. Darrell. “Hidden conditional random
fields”. In: IEEE PAMI 29.10 (2007), pp. 1848–1852.
[Que98] M. Queyranne. “Minimizing symmetric sub￾modular functions”. In: Math. Programming 82
(1998), pp. 3–12.
[QZW19] Y. Qiu, L. Zhang, and X. Wang. “Unbi￾ased Contrastive Divergence Algorithm for Training
Energy-Based Latent Variable Models”. In: ICLR.
2019.
[RA13] O. Rippel and R. P. Adams. “High-dimensional
probability estimation with deep density models”. In:
ArXiv Preprint arXiv:1302.5125 (2013).
[Rab89] L. R. Rabiner. “A Tutorial on Hidden Markov
Models and Selected Applications in Speech Recogni￾tion”. In: Proc. of the IEEE 77.2 (1989), pp. 257–286.
[Rad+18] A. Radford, K. Narasimhan, T. Salimans,
and I. Sutskever. Improving Language Understand￾ing by Generative Pre-Training. Tech. rep. OpenAI,
2018.
[Rad+19] A. Radford, J. Wu, R. Child, D. Luan, D.
Amodei, and I. Sutskever. Language Models are Un￾supervised Multitask Learners. Tech. rep. OpenAI,
2019.
[Rad+21] A. Radford, J. W. Kim, C. Hallacy, A.
Ramesh, G. Goh, S. Agarwal, G. Sastry, A. Askell, P.
Mishkin, J. Clark, et al. “Learning transferable visual
models from natural language supervision”. In: arXiv
preprint arXiv:2103.00020 (2021).
[Raf+20a] C. Raffel, N. Shazeer, A. Roberts, K. Lee,
S. Narang, M. Matena, Y. Zhou, W. Li, and P. J. Liu.
“Exploring the Limits of Transfer Learning with a Uni￾fied Text-to-Text Transformer”. In: JMLR (2020).
[Raf+20b] C. Raffel, N. M. Shazeer, A. Roberts, K.
Lee, S. Narang, M. Matena, Y. Zhou, W. Li, and
P. J. Liu. “Exploring the Limits of Transfer Learning
with a Unified Text-to-Text Transformer”. In: ArXiv
abs/1910.10683 (2020).
[Raf22] E. Raff. Inside Deep Learning: Math, Algo￾rithms, Models. en. Annotated edition. Manning, May
2022.
[RAG04] B. Ristic, S. Arulampalam, and N. Gor￾don. Beyond the Kalman Filter: Particle Filters for
Tracking Applications. Artech House Radar Library,
2004.
[Rag+17] M. Raghu, J. Gilmer, J. Yosinski, and J. Sohl￾Dickstein. “Svcca: Singular vector canonical correla￾tion analysis for deep learning dynamics and inter￾pretability”. In: Advances in Neural Information Pro￾cessing Systems. 2017, pp. 6076–6085.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Rag+19] M. Raghu, C. Zhang, J. Kleinberg, and S.
Bengio. “Transfusion: Understanding transfer learning
for medical imaging”. In: NIPS. 2019, pp. 3347–3357.
[Rag+21] M. Raghu, T. Unterthiner, S. Kornblith, C.
Zhang, and A. Dosovitskiy. “Do Vision Transformers
See Like Convolutional Neural Networks?” In: NIPS.
2021.
[Rai+18a] T. Rainforth, A. R. Kosiorek, T. A. Le, C. J.
Maddison, M. Igl, F. Wood, and Y. W. Teh. “Tighter
Variational Bounds are Not Necessarily Better”. In:
ICML. 2018.
[Rai+18b] M. Raitoharju, L. Svensson, Á. F. García￾Fernández, and R. Piché. “Damped Posterior Lin￾earization Filter”. In: IEEE Signal Process. Lett. 25.4
(2018).
[Rai+20] T. Rainforth, A. Golinski, F. Wood, and S.
Zaidi. “Target–Aware Bayesian Inference: How to Beat
Optimal Conventional Estimators”. In: JMLR 21.88
(2020), pp. 1–54.
[Rai68] H. Raiffa. Decision Analysis. Addison Wesley,
1968.
[Rak+08] A. Rakotomamonjy, F. Bach, S. Canu, and
Y. Grandvalet. “SimpleMKL”. In: JMLR 9 (2008),
pp. 2491–2521.
[Ram+21a] A. Ramesh, M. Pavlov, G. Goh, S. Gray, C.
Voss, A. Radford, M. Chen, and I. Sutskever. “Zero￾Shot Text-to-Image Generation”. In: (2021). arXiv:
2102.12092 [cs.CV].
[Ram+21b] A. Ramesh, M. Pavlov, G. Goh, S. Gray,
C. Voss, A. Radford, M. Chen, and I. Sutskever. “Zero￾shot text-to-image generation”. In: International Con￾ference on Machine Learning. PMLR. 2021, pp. 8821–
8831.
[Ram+22] A. Ramesh, P. Dhariwal, A. Nichol, C.
Chu, and M. Chen. “Hierarchical Text-Conditional Im￾age Generation with CLIP Latents”. In: (Apr. 2022).
arXiv: 2204.06125 [cs.CV].
[Ran+06] M. Ranzato, C. S. Poultney, S. Chopra, and
Y. LeCun. “Efficient Learning of Sparse Representa￾tions with an Energy-Based Model”. In: NIPS. 2006.
[Ran16] R. Ranganath. “Hierarchical Variational Mod￾els”. In: ICML. 2016.
[Ran+18] S. S. Rangapuram, M. W. Seeger, J.
Gasthaus, L. Stella, Y. Wang, and T. Januschowski.
“Deep State Space Models for Time Series Fore￾casting”. In: NIPS. Curran Associates, Inc., 2018,
pp. 7796–7805.
[Rao10] A. V. Rao. “A Survey of Numerical Methods
for Optimal Control”. In: Adv. Astronaut. Sci. 135.1
(2010).
[Rao99] R. P. Rao. “An optimal estimation approach
to visual perception and learning”. en. In: Vision Res.
39.11 (1999), pp. 1963–1989.
[Ras+15] A. Rasmus, H. Valpola, M. Honkala, M.
Berglund, and T. Raiko. Semi-Supervised Learning
with Ladder Networks. 2015. arXiv: 1507 . 02672
[cs.NE].
[Rat+09] M. Rattray, O. Stegle, K. Sharp, and J. Winn.
“Inference algorithms and learning theory for Bayesian
sparse factor analysis”. In: Proc. Intl. Workshop on
Statistical-Mechanical Informatics. 2009.
[Rav+18] S. Ravuri, S. Mohamed, M. Rosca, and O.
Vinyals. “Learning Implicit Generative Models with
the Method of Learned Moments”. In: International
Conference on Machine Learning. 2018, pp. 4314–
4323.
[RB16] G. P. Rigby BR. “The Efficacy of Equine￾Assisted Activities and Therapies on Improving Physi￾cal Function.” In: J Altern Complement Med. (2016).
[RBB18a] H. Ritter, A. Botev, and D. Barber. “A Scal￾able Laplace Approximation for Neural Networks”. In:
ICLR. 2018.
[RBB18b] H. Ritter, A. Botev, and D. Barber. “On￾line Structured Laplace Approximations for Overcom￾ing Catastrophic Forgetting”. In: NIPS. Curran Asso￾ciates, Inc., 2018, pp. 3738–3748.
[RBS16] L. J. Ratliff, S. A. Burden, and S. S. Sastry.
“On the characterization of local Nash equilibria in
continuous games”. In: IEEE transactions on auto￾matic control 61.8 (2016), pp. 2301–2307.
[RBS84] J. Ramsay, J. ten Berge, and G. Styan.
“Matrix correlation”. In: Psychometrika 49.3 (1984),
pp. 403–423.
[RC04] C. Robert and G. Casella. Monte Carlo Statisi￾cal Methods. 2nd edition. Springer, 2004.
[RC+18] M. Rojas-Carulla, B. Schölkopf, R. Turner,
and J. Peters. “Invariant Models for Causal Transfer
Learning”. In: Journal of Machine Learning Research
19.36 (2018), pp. 1–34.
[RD06] M. Richardson and P. Domingos. “Markov logic
networks”. In: Machine Learning 62 (2006), pp. 107–
136.
[RDV18] A. S. Ross and F. Doshi-Velez. “Improving
the adversarial robustness and interpretability of deep
neural networks by regularizing their input gradients”.
In: Thirty-second AAAI conference on artificial in￾telligence. 2018.
[RE76] P Robert and Y Escoufier. “A unifying tool for
linear multivariate statistical methods: The RV- coef￾ficient”. In: J. R. Stat. Soc. Ser. C Appl. Stat. 25.3
(1976), p. 257.
[Rea+19] E. Real, A. Aggarwal, Y. Huang, and Q. V.
Le. “Regularized Evolution for Image Classifier Archi￾tecture Search”. In: AAAI. 2019.
[Rec19] B. Recht. “A Tour of Reinforcement Learning:
The View from Continuous Control”. In: Annual Re￾view of Control, Robotics, and Autonomous Systems
2 (2019), pp. 253–279.
[Ree+17] S. Reed, A. van den Oord, N. Kalchbrenner,
S. G. Colmenarejo, Z. Wang, D. Belov, and N. de Fre￾itas. “Parallel Multiscale Autoregressive Density Esti￾mation”. In: (2017). arXiv: 1703.03664 [cs.CV].
[Rei+10] J. Reisinger, A. Waters, B. Silverthorn, and
R. Mooney. “Spherical topic models”. In: ICML. 2010.
[Rei13] S. Reich. “A Nonparametric Ensemble Trans￾form Method for Bayesian Inference”. In: SIAM J. Sci.
Comput. 35.4 (2013), A2013–A2024.
[Rei16] P. C. Reiss. “Just How Sensitive are Instrumen￾tal Variable Estimates?” In: Foundations and Trends
in Accounting 10.2-4 (2016).
[Rei+22] P. Reizinger, L. Gresele, J. Brady, J. von
Kügelgen, D. Zietlow, B. Scholkopf, G. Martius, W.
Brendel, and M. Besserve. “Embrace the Gap: VAEs
Perform Independent Mechanism Analysis”. In: 2022.
[Ren+19] J. Ren, P. J. Liu, E. Fertig, J. Snoek, R.
Poplin, M. A. DePristo, J. V. Dillon, and B. Lakshmi￾narayanan. “Likelihood Ratios for Out-of-Distribution
Detection”. In: NIPS. 2019.
[Ren+21] P. Ren, Y. Xiao, X. Chang, P.-Y. Huang, Z.
Li, B. B. Gupta, X. Chen, and X. Wang. “A Survey of
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1300
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Deep Active Learning”. In: ACM Comput. Surv. 54.9
(Oct. 2021), pp. 1–40.
[Rén61] A. Rényi. “On Measures of Entropy and Infor￾mation”. en. In: Proceedings of the Fourth Berkeley
Symposium on Mathematical Statistics and Probabil￾ity, Volume 1: Contributions to the Theory of Statis￾tics. The Regents of the University of California, 1961.
[Ren+94] S Renals, N Morgan, H Bourlard, M Cohen,
and H Franco. “Connectionist probability estimators
in HMM speech recognition”. In: IEEE Trans. Audio
Speech Lang. Processing 2.1 (Jan. 1994), pp. 161–174.
[RFB15] O. Ronneberger, P. Fischer, and T. Brox. “U￾Net: Convolutional Networks for Biomedical Image
Segmentation”. In: MICCAI (Intl. Conf. on Medical
Image Computing and Computer Assisted Interven￾tions). 2015.
[RG17] M Roth and F Gustafsson. “Computation and
visualization of posterior densities in scalar nonlinear
and non-Gaussian Bayesian filtering and smoothing
problems”. In: ICASSP. 2017, pp. 4686–4690.
[RGB11] S. Ross, G. J. Gordon, and D. Bagnell. “A
Reduction of Imitation Learning and Structured Pre￾diction to No-Regret Online Learning”. In: AISTATS.
2011, pp. 627–635.
[RGB14] R. Ranganath, S. Gerrish, and D. M. Blei.
“Black Box Variational Inference”. In: AISTATS.
2014.
[RGL19] S. Rabanser, S. Günnemann, and Z. C. Lip￾ton. “Failing Loudly: An Empirical Study of Methods
for Detecting Dataset Shift”. In: NIPS. 2019.
[RH05] H. Rue and L. Held. Gaussian Markov Ran￾dom Fields: Theory and Applications. Vol. 104. Mono￾graphs on Statistics and Applied Probability. London:
Chapman & Hall, 2005.
[RHDV17] A. S. Ross, M. C. Hughes, and F. Doshi￾Velez. “Right for the right reasons: Training differen￾tiable models by constraining their explanations”. In:
IJCAI (2017).
[RHG16] D. Ritchie, P. Horsfall, and N. D. Good￾man. “Deep Amortized Inference for Probabilistic Pro￾grams”. In: (2016). arXiv: 1610.05735 [cs.AI].
[RHK17] S. Remes, M. Heinonen, and S. Kaski. “Non￾Stationary Spectral Kernels”. In: NIPS. May 2017.
[RHW86a] D. Rumelhart, G. Hinton, and R. Williams.
“Learning internal representations by error propa￾gation”. In: Parallel Distributed Processing: Explo￾rations in the Microstructure of Cognition. Ed. by
D. Rumelhart, J. McClelland, and the PDD Research
Group. MIT Press, 1986.
[RHW86b] D. Rumelhart, G. E. Hinton, and
R. J. Williams. “Learning representations by back￾propagating errors”. In: Nature 323 (1986), pp. 533–
536.
[Ric03] T. Richardson. “Markov properties for acyclic
directed mixed graphs”. In: Scandinavian J. of Statis￾tics 30 (2003), pp. 145–157.
[Ric95] J. Rice. Mathematical statistics and data anal￾ysis. 2nd edition. Duxbury, 1995.
[Rif+11] S. Rifai, P. Vincent, X. Muller, X. Glorot, and
Y. Bengio. “Contractive auto-encoders: Explicit invari￾ance during feature extraction”. In: Icml. 2011.
[Ris+08] I. Rish, G. Grabarnik, G. Cecchi, F. Pereira,
and G. Gordon. “Closed-form supervised dimension￾ality reduction with generalized linear models”. In:
ICML. 2008.
[Riv87] R. L. Rivest. “Learning decision lists”. In: Ma￾chine learning 2.3 (1987), pp. 229–246.
[RK04] R. Rubinstein and D. Kroese. The Cross￾Entropy Method: A Unified Approach to Combinato￾rial Optimization, Monte-Carlo Simulation, and Ma￾chine Learning. Springer-Verlag, 2004.
[RL17] S. Ravi and H. Larochelle. “Optimization as a
Model for Few-Shot Learning”. In: ICLR. 2017.
[RM15] D. J. Rezende and S. Mohamed. “Variational
Inference with Normalizing Flows”. In: ICML. 2015.
[RM22] H. Rahimian and S. Mehrotra. “Distribution￾ally Robust Optimization: A Review”. In: Open Jour￾nal of Mathematical Optimization 3.4 (2022).
[RMB08] N. L. Roux, P.-A. Manzagol, and Y. Bengio.
“Topmoumoute Online Natural Gradient Algorithm”.
In: NIPS. 2008, pp. 849–856.
[RMC09] H. Rue, S. Martino, and N. Chopin. “Approx￾imate Bayesian Inference for Latent Gaussian Models
Using Integrated Nested Laplace Approximations”. In:
J. of Royal Stat. Soc. Series B 71 (2009), pp. 319–
392.
[RMC15] A. Radford, L. Metz, and S. Chintala. “Un￾supervised Representation Learning with Deep Convo￾lutional Generative Adversarial Networks”. In: arXiv
(2015).
[RMC16a] A. Radford, L. Metz, and S. Chintala. “Un￾supervised Representation Learning with Deep Convo￾lutional Generative Adversarial Networks”. In: ICLR.
2016.
[RMC16b] A. Radford, L. Metz, and S. Chintala. “Un￾supervised Representation Learning with Deep Convo￾lutional Generative Adversarial Networks”. In: CoRR
abs/1511.06434 (2016).
[RMK21] G. Roeder, L. Metz, and D. P. Kingma. “On
Linear Identifiability of Learned Representations”. In:
ICML. 2021.
[RMW14a] D. Rezende, S. Mohamed, and D. Wierstra.
“Stochastic backpropagation and approximate infer￾ence in deep generative models”. In: ICML. 2014.
[RMW14b] D. J. Rezende, S. Mohamed, and D. Wier￾stra. “Stochastic Backpropagation and Approximate
Inference in Deep Generative Models”. In: ICML. Ed.
by E. P. Xing and T. Jebara. Vol. 32. Proceedings of
Machine Learning Research. PMLR, 2014, pp. 1278–
1286.
[RN02] S. Russell and P. Norvig. Artificial Intelli￾gence: A Modern Approach. 2nd edition. Prentice
Hall, 2002.
[RN10] S. Russell and P. Norvig. Artificial Intelli￾gence: A Modern Approach. 3rd edition. Prentice Hall,
2010.
[RN19] S. Russell and P. Norvig. Artificial Intelli￾gence: A Modern Approach. 4th edition. Prentice Hall,
2019.
[RN94] G. A. Rummery and M Niranjan. On-Line Q￾Learning Using Connectionist Systems. Tech. rep.
Cambridge Univ. Engineering Dept., 1994.
[RN95] S. Russell and P. Norvig. Artificial Intelli￾gence: A Modern Approach. Prentice Hall, 1995.
[RNA22] L. Regenwetter, A. H. Nobari, and F. Ahmed.
“Deep Generative Models in Engineering Design: A Re￾view”. In: J. Mech. Des. (2022).
[Rob07] C. P. Robert. The Bayesian Choice: From
Decision-Theoretic Foundations to Computational
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
Implementation. en. 2nd edition. Springer Verlag,
New York, 2007.
[Rob+13] S Roberts, M Osborne, M Ebden, S Reece,
N Gibson, and S Aigrain. “Gaussian processes for
time-series modelling”. en. In: Philos. Trans. A Math.
Phys. Eng. Sci. 371.1984 (2013), p. 20110550.
[Rob+18] C. P. Robert, V. Elvira, N. Tawn, and C. Wu.
“Accelerating MCMC Algorithms”. In: (2018). arXiv:
1804.02719 [stat.CO].
[Rob+21] J. Robinson, C.-Y. Chuang, S. Sra, and S.
Jegelka. “Contrastive Learning with Hard Negative
Samples”. In: ArXiv abs/2010.04592 (2021).
[Rob63] L. G. Roberts. “Machine Perception of Three￾Dimensional Solids”. In: Outstanding Dissertations in
the Computer Sciences. 1963.
[Rob86] J. Robins. “A new approach to causal infer￾ence in mortality studies with a sustained exposure pe￾riod—application to control of the healthy worker sur￾vivor effect”. In: Mathematical Modelling 7.9 (1986),
pp. 1393–1512.
[Rob95a] C. Robert. “Simulation of truncated normal
distributions”. In: Statistics and computing 5 (1995),
pp. 121–125.
[Rob95b] A. Robins. “Catastrophic Forgetting, Re￾hearsal and Pseudorehearsal”. In: Conn. Sci. 7.2
(1995), pp. 123–146.
[Rod14] J. Rodu. “Spectral estimation of hidden
Markov models”. PhD thesis. U. Penn, 2014.
[RÖG13] M. Roth, E. Özkan, and F. Gustafsson. “A
Student’s t filter for heavy tailed process and mea￾surement noise”. In: ICASSP. 2013, pp. 5770–5774.
[Roh21] D. Rohde. “Causal Inference, is just Inference:
A beautifully simple idea that not everyone accepts”.
In: I (Still) Can’t Believe It’s Not Better! NeurIPS
2021 Workshop. 2021.
[Rom+22] R. Rombach, A. Blattmann, D. Lorenz, P.
Esser, and B. Ommer. “High-Resolution Image Syn￾thesis with Latent Diffusion Models”. In: CVPR. 2022.
[Ros10] P. Rosenbaum. Design of Observational Stud￾ies. 2010.
[Ros+21] M. Rosca, Y. Wu, B. Dherin, and D. G. Bar￾rett. “Discretization Drift in Two-Player Games”. In:
(2021).
[Ros+22] C. Rosato, L. Devlin, V. Beraud, P. Horridge,
T. B. Schön, and S. Maskell. “Efficient Learning of the
Parameters of Non-Linear Models Using Differentiable
Resampling in Particle Filters”. In: IEEE Trans. Sig￾nal Process. 70 (2022), pp. 3676–3692.
[Ros22] C. Ross. AI gone astray: How subtle shifts in
patient data send popular algorithms reeling, under￾mining patient safety. en. https://www.statnews.com/
2022/02/28/sepsis-hospital-algorithms-data-shift/.
Accessed: 2022-3-2. 2022.
[Rot+17] M. Roth, G. Hendeby, C. Fritsche, and F.
Gustafsson. “The Ensemble Kalman filter: a signal
processing perspective”. In: EURASIP J. Adv. Signal
Processing 2017.1 (2017), p. 56.
[Rot+18] W. Roth, R. Peharz, S. Tschiatschek, and F.
Pernkopf. “Hybrid generative-discriminative training
of Gaussian mixture models”. In: Pattern Recognit.
Lett. 112 (Sept. 2018), pp. 131–137.
[Rot96] D. Roth. “On the hardness of approximate
reasoning”. In: Artificial Intelligence 82.1-2 (1996),
pp. 273–302.
[ROV19] A. Razavi, A. van den Oord, and O. Vinyals.
“Generating diverse high resolution images with VA￾VAE-2”. In: NIPS. 2019.
[Row97] S. Roweis. “EM algorithms for PCA and
SPCA”. In: NIPS. 1997.
[Roy+21] N. Roy et al. “From Machine Learning to
Robotics: Challenges and Opportunities for Embod￾ied Intelligence”. In: (Oct. 2021). arXiv: 2110 . 15245
[cs.RO].
[RPC19] Y. Romano, E. Patterson, and E. J. Candès.
“Conformalized Quantile Regression”. In: NIPS. 2019.
[RPH21] A. Robey, G. J. Pappas, and H. Hassani.
Model-Based Domain Generalization. 2021. arXiv:
2102.11436 [stat.ML].
[RR01a] A. Rao and K. Rose. “Deterministically An￾nealed Design of Hidden Markov Model Speech Recog￾nizers”. In: IEEE Trans. on Speech and Audio Proc.
9.2 (2001), pp. 111–126.
[RR01b] G. Roberts and J. Rosenthal. “Optimal scal￾ing for various Metropolis-Hastings algorithms”. In:
Statistical Science 16 (2001), pp. 351–367.
[RR08] A. Rahimi and B. Recht. “Random Features for
Large-Scale Kernel Machines”. In: NIPS. Curran As￾sociates, Inc., 2008, pp. 1177–1184.
[RR09] A. Rahimi and B. Recht. “Weighted Sums of
Random Kitchen Sinks: Replacing minimization with
randomization in learning”. In: NIPS. Curran Asso￾ciates, Inc., 2009, pp. 1313–1320.
[RR11] T. S. Richardson and J. M. Robins. “Single
World Intervention Graphs: A Primer”. In: Second
UAI workshop on causal structure learning. 2011.
[RR13] T. S. Richardson and J. M. Robins. “Single
World Intervention Graphs (SWIGs): A Unification
of the Counterfactual and Graphical Approaches to
Causality”. 2013.
[RR14] D. Russo and B. V. Roy. “Learning to Opti￾mize via Posterior Sampling”. In: Math. Oper. Res.
39.4 (2014), pp. 1221–1243.
[RR83] P. R. Rosenbaum and D. B. Rubin. “Assess￾ing Sensitivity to an Unobserved Binary Covariate in
an Observational Study with Binary Outcome”. In:
Journal of the Royal Statistical Society. Series B
(Methodological) 45.2 (1983), pp. 212–218.
[RRR21] E. Rosenfeld, P. Ravikumar, and A. Risteski.
“The Risks of Invariant Risk Minimization”. In: ICML.
2021.
[RRS00] J. M. Robins, A. Rotnitzky, and D. O. Scharf￾stein. “Sensitivity analysis for selection bias and un￾measured confounding in missing data and causal in￾ference models”. In: Statistical models in epidemiol￾ogy, the environment, and clinical trials. Springer,
2000, pp. 1–94.
[RS07] M. Raphan and E. P. Simoncelli. “Learning
to be Bayesian without supervision”. In: Advances
in neural information processing systems. 2007,
pp. 1145–1152.
[RS11] M. Raphan and E. P. Simoncelli. “Least squares
estimation without priors or supervision”. In: Neural
computation 23.2 (2011), pp. 374–420.
[RS20] A. Rotnitzky and E. Smucler. “Efficient Adjust￾ment Sets for Population Average Causal Treatment
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1302
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Effect Estimation in Graphical Models.” In: J. Mach.
Learn. Res. 21 (2020), pp. 188–1.
[RS97a] G. O. Roberts and S. K. Sahu. “Updating
Schemes, Correlation Structure, Blocking and Parame￾terization for the Gibbs Sampler”. In: J. of Royal Stat.
Soc. Series B 59.2 (1997), pp. 291–317.
[RS97b] G. O. Roberts and S. K. Sahu. “Updating
schemes, correlation structure, blocking and parame￾terization for the Gibbs sampler”. In: J. of Royal Stat.
Soc. Series B 59.2 (1997), pp. 291–317.
[RSC20] Y. Romano, M. Sesia, and E. J. Candès.
“Classification with Valid and Adaptive Coverage”. In:
NIPS. 2020.
[RSG16a] M. T. Ribeiro, S. Singh, and C. Guestrin. “"
Why should i trust you?" Explaining the predictions
of any classifier”. In: Proceedings of the 22nd ACM
SIGKDD international conference on knowledge dis￾covery and data mining. 2016, pp. 1135–1144.
[RSG16b] M. T. Ribeiro, S. Singh, and C. Guestrin.
“Model-agnostic interpretability of machine learning”.
In: arXiv preprint arXiv:1606.05386 (2016).
[RSG17] S. Rabanser, O. Shchur, and S. Günnemann.
“Introduction to Tensor Decompositions and their Ap￾plications in Machine Learning”. In: (2017). arXiv:
1711.10781 [stat.ML].
[RT16] S. Reid and R. Tibshirani. “Sparse regression
and marginal testing using cluster prototypes”. In:
Biostatistics 17.2 (2016), pp. 364–376.
[RT82] D. B. Rubin and D. T. Thayer. “EM algo￾rithms for ML factor analysis”. In: Psychometrika 47.1
(1982), pp. 69–76.
[RT96] G. O. Roberts and R. L. Tweedie. “Exponen￾tial convergence of Langevin distributions and their
discrete approximations”. en. In: Bernoulli 2.4 (1996),
pp. 341–363.
[RTS18] C. Riquelme, G. Tucker, and J. Snoek. “Deep
Bayesian Bandits Showdown: An Empirical Compar￾ison of Bayesian Deep Networks for Thompson Sam￾pling”. In: ICLR. 2018.
[RTS65] H. E. Rauch, F. Tung, and C. T. Striebel.
“Maximum likelihood estimates of linear dynamic sys￾tems”. In: AIAA Journal 3.8 (1965), pp. 1445–1450.
[Rub+20] Y. Rubanova, D. Dohan, K. Swersky, and K.
Murphy. “Amortized Bayesian Optimization over Dis￾crete Spaces”. In: UAI. 2020.
[Rub74] D. B. Rubin. “Estimating causal effects of
treatments in randomized and nonrandomized stud￾ies”. In: J. Educ. Psychol. 66.5 (1974), pp. 688–701.
[Rub76] D. B. Rubin. “Inference and Missing Data”. In:
Biometrika 63.3 (1976), pp. 581–592.
[Rub84] D. B. Rubin. “Bayesianly Justifiable and Rel￾evant Frequency Calculations for the Applied Statisti￾cian”. In: Ann. Stat. 12.4 (1984), pp. 1151–1172.
[Rub97] R. Y. Rubinstein. “Optimization of computer
simulation models with rare events”. In: Eur. J. Oper.
Res. 99.1 (1997), pp. 89–112.
[Rud19] C. Rudin. Stop Explaining Black Box Ma￾chine Learning Models for High Stakes Decisions
and Use Interpretable Models Instead. 2019. arXiv:
1811.10154 [stat.ML].
[Ruf+21] L. Ruff, J. R. Kauffmann, R. A. Vander￾meulen, G. Montavon, W. Samek, M. Kloft, T. G. Diet￾terich, and K.-R. Müller. “A Unifying Review of Deep
and Shallow Anomaly Detection”. In: Proc. IEEE
109.5 (2021), pp. 756–795.
[Rus15] S. Russell. “Unifying Logic and Probability”.
In: Commun. ACM 58.7 (2015), pp. 88–97.
[Rus+16] A. A. Rusu, N. C. Rabinowitz, G. Desjardins,
H. Soyer, J. Kirkpatrick, K. Kavukcuoglu, R. Pascanu,
and R. Hadsell. “Progressive Neural Networks”. In:
(2016). arXiv: 1606.04671 [cs.LG].
[Rus+18] D. J. Russo, B. Van Roy, A. Kazerouni,
I. Osband, and Z. Wen. “A Tutorial on Thompson
Sampling”. In: Foundations and Trends in Machine
Learning 11.1 (2018), pp. 1–96.
[Rus+95] S. Russell, J. Binder, D. Koller, and K.
Kanazawa. “Local learning in probabilistic networks
with hidden variables”. In: IJCAI. 1995.
[RV19] S. Ravuri and O. Vinyals. “Classification ac￾curacy score for conditional generative models”. In:
Advances in Neural Information Processing Systems.
2019, pp. 12268–12279.
[RW06] C. E. Rasmussen and C. K. I. Williams. Gaus￾sian Processes for Machine Learning. MIT Press,
2006.
[RW11] M. D. Reid and R. C. Williamson. “Informa￾tion, Divergence and Risk for Binary Experiments”. In:
Journal of Machine Learning Research 12.3 (2011).
[RW15] D. Rosenbaum and Y. Weiss. “The Return of
the Gating Network: Combining Generative Models
and Discriminative Training in Natural Image Priors”.
In: NIPS. 2015, pp. 2665–2673.
[RW18] E. Richardson and Y. Weiss. “On GANs and
GMMs”. In: NIPS. 2018.
[RWD17] G. Roeder, Y. Wu, and D. Duvenaud. “Stick￾ing the Landing: An Asymptotically Zero-Variance
Gradient Estimator for Variational Inference”. In:
NIPS. 2017.
[RY21] D. Roberts and S. Yaida. The Principles of
Deep Learning Theory: An Effective Theory Ap￾proach to Understanding Neural Network. 2021.
[Ryc+19] B. Rychalska, D. Basaj, A. Gosiewska, and
P. Biecek. “Models in the Wild: On Corruption
Robustness of Neural NLP Systems”. In: Interna￾tional Conference on Neural Information Processing
(ICONIP). Springer International Publishing, 2019,
pp. 235–247.
[Ryu+20] M. Ryu, Y. Chow, R. Anderson, C. Tjan￾draatmadja, and C. Boutilier. “CAQL: Continuous Ac￾tion Q-Learning”. In: ICLR. 2020.
[RZL17] P. Ramachandran, B. Zoph, and Q. V. Le.
“Searching for Activation Functions”. In: (2017). arXiv:
1710.05941 [cs.NE].
[SA19] F. Schafer and A. Anandkumar. “Competitive
gradient descent”. In: NIPS. 2019, pp. 7625–7635.
[Sac+05] K. Sachs, O. Perez, D. Pe’er, D. Lauffen￾burger, and G. Nolan. “Causal Protein-Signaling Net￾works Derived from Multiparameter Single-Cell Data”.
In: Science 308 (2005).
[SAC17] J. Schulman, P. Abbeel, and X. Chen. Equiva￾lence Between Policy Gradients and Soft Q-Learning.
arXiv:1704.06440. 2017.
[Sag+20] S. Sagawa, P. W. Koh, T. B. Hashimoto, and
P. Liang. “Distributionally Robust Neural Networks
for Group Shifts: On the Importance of Regularization
for Worst-Case Generalization”. In: ICLR. 2020.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Sah+22a] C. Saharia, W. Chan, H. Chang, C. A. Lee,
J. Ho, T. Salimans, D. J. Fleet, and M. Norouzi.
“Palette: Image-to-Image Diffusion Models”. In: SIG￾GRAPH (Nov. 2022). arXiv: 2111.05826 [cs.CV].
[Sah+22b] C. Saharia et al. “Photorealistic Text-to￾Image Diffusion Models with Deep Language Under￾standing”. In: (May 2022). arXiv: 2205.11487 [cs.CV].
[Sai+20] M. Saito, S. Saito, M. Koyama, and
S. Kobayashi. “Train Sparsely, Generate Densely:
Memory-Efficient Unsupervised Training of High￾Resolution Temporal GAN”. In: International Jour￾nal of Computer Vision 128 (2020), pp. 2586–2606.
[Saj+18] M. S. Sajjadi, O. Bachem, M. Lucic, O. Bous￾quet, and S. Gelly. “Assessing generative models via
precision and recall”. In: Proceedings of the 32nd In￾ternational Conference on Neural Information Pro￾cessing Systems. 2018, pp. 5234–5243.
[Sal16] T. Salimans. “A Structured Variational Auto￾encoder for Learning Deep Hierarchies of Sparse Fea￾tures”. In: (2016). arXiv: 1602.08734 [stat.ML].
[Sal+16] T. Salimans, I. Goodfellow, W. Zaremba, V.
Cheung, A. Radford, and X. Chen. “Improved Tech￾niques for Training GANs”. In: (2016). arXiv: 1606 .
03498 [cs.LG].
[Sal+17a] M. Salehi, A. Karbasi, D. Scheinost, and
R. T. Constable. “A Submodular Approach to Create
Individualized Parcellations of the Human Brain”. In:
Medical Image Computing and Computer Assisted
Intervention - MICCAI 2017. Ed. by M. Descoteaux,
L. Maier-Hein, A. Franz, P. Jannin, D. L. Collins, and
S. Duchesne. Cham: Springer International Publishing,
2017, pp. 478–485.
[Sal+17b] T. Salimans, J. Ho, X. Chen, and I.
Sutskever. “Evolution Strategies as a Scalable Alter￾native to Reinforcement Learning”. In: (2017). arXiv:
1703.03864 [stat.ML].
[Sal+17c] T. Salimans, A. Karpathy, X. Chen, and
D. P. Kingma. “PixelCNN++: Improving the Pixel￾CNN with Discretized Logistic Mixture Likelihood
and Other Modifications”. In: ICLR. 2017.
[Sal+19a] D. Salinas, M. Bohlke-Schneider, L. Callot,
R. Medico, and J. Gasthaus. “High-Dimensional Mul￾tivariate Forecasting with Low-Rank Gaussian Copula
Processes”. In: NIPS. 2019.
[Sal+19b] D. Salinas, V. Flunkert, J. Gasthaus, and
T. Januschowski. “DeepAR: Probabilistic forecasting
with autoregressive recurrent networks”. In: Interna￾tional Journal of Forecasting (2019).
[Sal+20] H. Salman, A. Ilyas, L. Engstrom, A. Kapoor,
and A. Madry. “Do Adversarially Robust Ima￾geNet Models Transfer Better?” In: arXiv preprint
arXiv:2007.08489 (2020).
[Sal+21] M. Salehi, H. Mirzaei, D. Hendrycks, Y. Li,
M. H. Rohban, and M. Sabokrou. “A Unified Sur￾vey on Anomaly, Novelty, Open-Set, and Out-of￾Distribution Detection: Solutions and Future Chal￾lenges”. In: (2021). arXiv: 2110.14051 [cs.CV].
[Sam74] P. A. Samuelson. “Complementarity: An essay
on the 40th anniversary of the Hicks-Allen revolution
in demand theory”. In: Journal of Economic litera￾ture 12.4 (1974), pp. 1255–1289.
[San17] R. Santana. “Gray-box optimization and fac￾torized distribution algorithms: where two worlds col￾lide”. In: (2017). arXiv: 1707.03093 [cs.NE].
[San+17] A. Santoro, D. Raposo, D. G. Barrett, M. Ma￾linowski, R. Pascanu, P. Battaglia, and T. Lillicrap.
“A simple neural network module for relational reason￾ing”. In: Advances in neural information processing
systems. 2017, pp. 4967–4976.
[Sar08] S. Sarkka. “Unscented Rauch–Tung–Striebel
Smoother”. In: IEEE Trans. Automat. Contr. 53.3
(Apr. 2008), pp. 845–849.
[Sar13] S. Sarkka. Bayesian Filtering and Smoothing.
Cambridge University Press, 2013.
[Sar18] H. Sarin. “Playing a game of GANstruction”. In:
The Gradient (2018).
[Say+19] R. Sayres, S. Xu, T Saensuksopa, M. Le, and
D. R. Webster. “Assistance from a deep learning sys￾tem improves diabetic retinopathy assessment in op￾tometrists”. In: Investigative Ophthalmology & Vi￾sual Science 60.9 (2019), pp. 1433–1433.
[SB01] A. J. Smola and P. L. Bartlett. “Sparse Greedy
Gaussian Process Regression”. In: NIPS. Ed. by T. K.
Leen, T. G. Dietterich, and V Tresp. MIT Press, 2001,
pp. 619–625.
[SB18] R. Sutton and A. Barto. Reinforcement learn￾ing: an introduction (2nd edn). MIT Press, 2018.
[SBG07] S. Siddiqi, B. Boots, and G. Gordon. “A con￾straint generation approach to learning stable linear
dynamical systems”. In: NIPS. 2007.
[SBP17] Y Sun, P Babu, and D. P. Palomar.
“Majorization-Minimization Algorithms in Signal Pro￾cessing, Communications, and Machine Learning”. In:
IEEE Trans. Signal Process. 65.3 (2017), pp. 794–
816.
[SC13] C. Schäfer and N. Chopin. “Sequential Monte
Carlo on large binary sampling spaces”. In: Stat. Com￾put. 23.2 (2013), pp. 163–184.
[SC86] R. Smith and P. Cheeseman. “On the Represen￾tation and Estimation of Spatial Uncertainty”. In: Intl.
J. Robotics Research 5.4 (1986), pp. 56–68.
[SC90] R. Schwarz and Y. Chow. “The n-best algo￾rithm: an efficient and exact procedure for finding the
n most likely hypotheses”. In: ICASSP. 1990.
[Sca21] S. Scardapane. Lecture 8: Beyond single-task
supervised learning. 2021.
[Sch00] A. Schrijver. “A combinatorial algorithm min￾imizing submodular functions in strongly polynomial
time”. In: Journal of Combinatorial Theory, Series
B 80.2 (2000), pp. 346–355.
[Sch02] N. N. Schraudolph. “Fast Curvature Matrix￾Vector Products for Second-Order Gradient Descent”.
In: Neural Computation 14 (2002).
[Sch04] A. Schrijver. Combinatorial Optimization.
Springer, 2004.
[Sch+12a] B. Schoelkopf, D. Janzing, J. Peters, E.
Sgouritsa, K. Zhang, and J. Mooij. “On Causal and
Anticausal Learning”. In: ICML. 2012.
[Sch+12b] B. Schölkopf, D. Janzing, J. Peters, E.
Sgouritsa, K. Zhang, and J. Mooij. “On causal and
anticausal learning”. In: Proceedings of the 29th In￾ternational Coference on International Conference
on Machine Learning. 2012, pp. 459–466.
[Sch14] J. Schmidhuber. Deep Learning in Neural Net￾works: An Overview. Tech. rep. 2014.
[Sch+15a] J. Schulman, N. Heess, T. Weber, and P.
Abbeel. “Gradient Estimation Using Stochastic Com￾putation Graphs”. In: NIPS. 2015.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1304
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[Sch+15b] J. Schulman, S. Levine, P. Moritz, M. I. Jor￾dan, and P. Abbeel. “Trust Region Policy Optimiza￾tion”. In: ICML. 2015.
[Sch+16a] T. Schaul, J. Quan, I. Antonoglou, and
D. Silver. “Prioritized Experience Replay”. In: ICLR.
2016.
[Sch+16b] J. Schulman, P. Moritz, S. Levine, M. Jor￾dan, and P. Abbeel. “High-Dimensional Continuous
Control Using Generalized Advantage Estimation”. In:
ICLR. 2016.
[Sch+17] J. Schulman, F. Wolski, P. Dhariwal, A. Rad￾ford, and O. Klimov. “Proximal Policy Optimization
Algorithms”. In: (2017). arXiv: 1707.06347 [cs.LG].
[Sch+18] J. Schwarz, J. Luketina, W. M. Czarnecki, A.
Grabska-Barwinska, Y. W. Teh, R. Pascanu, and R.
Hadsell. “Progress & Compress: A scalable framework
for continual learning”. In: ICML. 2018.
[Sch19] B. Schölkopf. “Causality for Machine Learning”.
In: (2019). arXiv: 1911.10500 [cs.LG].
[Sch20] J. Schmidhuber. Planning & Reinforcement
Learning with Recurrent World Models and Artificial
Curiosity. 2020.
[Sch+20] J. Schrittwieser et al. “Mastering Atari, Go,
Chess and Shogi by Planning with a Learned Model”.
In: Nature (2020).
[Sch+21a] D. O. Scharfstein, R. Nabi, E. H. Kennedy,
M.-Y. Huang, M. Bonvini, and M. Smid. Semipara￾metric Sensitivity Analysis: Unmeasured Confound￾ing In Observational Studies. 2021. arXiv: 2104.08300
[stat.ME].
[Sch+21b] B. Schölkopf, F. Locatello, S. Bauer, N. R.
Ke, N. Kalchbrenner, A. Goyal, and Y. Bengio.
“Toward Causal Representation Learning”. In: Proc.
IEEE 109.5 (2021), pp. 612–634.
[Sch+21c] B. Schölkopf, F. Locatello, S. Bauer, N. R.
Ke, N. Kalchbrenner, A. Goyal, and Y. Bengio. “To￾wards Causal Representation Learning”. In: CoRR
abs/2102.11107 (2021). arXiv: 2102.11107.
[Sch78] G. Schwarz. “Estimating the dimension of a
model”. In: Annals of Statistics 6.2 (1978), pp. 461–
464.
[Sco02] S Scott. “Bayesian methods for hidden Markov
models: Recursive computing in the 21st century.” In:
JASA (2002).
[Sco09] S. Scott. “Data augmentation, frequentist esti￾mation, and the Bayesian analysis of multinomial logit
models”. In: Statistical Papers (2009).
[Sco10] S. Scott. “A modern Bayesian look at the multi￾armed bandit”. In: Applied Stochastic Models in Busi￾ness and Industry 26 (2010), pp. 639–658.
[SCPD22] R. Sanchez-Cauce, I. Paris, and F. J. Diez.
“Sum-Product Networks: A Survey”. en. In: IEEE
PAMI 44.7 (July 2022), pp. 3821–3839.
[SCS19] A. Subbaswamy, B. Chen, and S. Saria. A Uni￾versal Hierarchy of Shift-Stable Distributions and
the Tradeoff Between Stability and Performance.
2019. arXiv: 1905.11374 [stat.ML].
[SCS22] A. Subbaswamy, B. Chen, and S. Saria. “A
unifying causal framework for analyzing dataset shift￾stable learning algorithms”. en. In: Journal of Causal
Inference 10.1 (Jan. 2022), pp. 64–89.
[SD12] J. Sohl-Dickstein. “The Natural Gradient by
Analogy to Signal Whitening, and Recipes and Tricks
for its Use”. In: (2012). arXiv: 1205.1828 [cs.LG].
[SD+15a] J. Sohl-Dickstein, E. Weiss, N. Mah￾eswaranathan, and S. Ganguli. “Deep Unsupervised
Learning using Nonequilibrium Thermodynamics”. In:
ICML. 2015, pp. 2256–2265.
[SD+15b] J. Sohl-Dickstein, E. A. Weiss, N. Mah￾eswaranathan, and S. Ganguli. “Deep Unsupervised
Learning using Nonequilibrium Thermodynamics”. In:
ICML. 2015.
[SDBD11] J. Sohl-Dickstein, P. Battaglino, and M. R.
DeWeese. “Minimum probability flow learning”. In:
Proceedings of the 28th International Conference
on International Conference on Machine Learning.
2011, pp. 905–912.
[SE19] Y. Song and S. Ermon. “Generative Modeling
by Estimating Gradients of the Data Distribution”. In:
NIPS. 2019, pp. 11895–11907.
[SE20a] J. Song and S. Ermon. “Multi-label Con￾trastive Predictive Coding”. In: NIPS. 2020.
[SE20b] Y. Song and S. Ermon. “Improved Techniques
for Training Score-Based Generative Models”. In:
NIPS. 2020.
[See+17] M. Seeger, S. Rangapuram, Y. Wang, D. Sali￾nas, J. Gasthaus, T. Januschowski, and V. Flunkert.
“Approximate Bayesian Inference in Linear State
Space Models for Intermittent Demand Forecasting at
Scale”. In: (2017). arXiv: 1709.07638 [stat.ML].
[Sej20] T. J. Sejnowski. “The unreasonable effective￾ness of deep learning in artificial intelligence”. en. In:
PNAS 117.48 (Dec. 2020), pp. 30033–30038.
[Sel+17] R. R. Selvaraju, M. Cogswell, A. Das, R.
Vedantam, D. Parikh, and D. Batra. “Grad-cam: Vi￾sual explanations from deep networks via gradient￾based localization”. In: Proceedings of the IEEE in￾ternational conference on computer vision. 2017,
pp. 618–626.
[Sel+19] A. D. Selbst, D. Boyd, S. A. Friedler, S.
Venkatasubramanian, and J. Vertesi. “Fairness and
Abstraction in Sociotechnical Systems”. In: Proceed￾ings of the Conference on Fairness, Accountability,
and Transparency. FAT* ’19. Atlanta, GA, USA: As￾sociation for Computing Machinery, 2019, 59–68.
[Sen+08] P. Sen, G. Namata, M. Bilgic, L. Getoor,
B. Galligher, and T. Eliassi-Rad. “Collective Classi￾fication in Network Data”. en. In: AI Magazine 29.3
(2008), pp. 93–93.
[Ser+20] J. Serrà, D. Álvarez, V. Gómez, O. Sli￾zovskaia, J. F. Núñez, and J. Luque. “Input complex￾ity and out-of-distribution detection with likelihood￾based generative models”. In: ICLR. 2020.
[Set12] B. Settles. “Active learning”. In: Synthesis Lec￾tures on Artificial Intelligence and Machine Learn￾ing 6 (2012), 1–114.
[SF08] Z. Svitkina and L. Fleischer. “Submodular ap￾proximation: Sampling-based algorithms and lower
bounds”. In: FOCS. 2008.
[SF20] K. Sokol and P. Flach. “Explainability fact
sheets: a framework for systematic assessment of ex￾plainable approaches”. In: Proceedings of the 2020
Conference on Fairness, Accountability, and Trans￾parency. 2020, pp. 56–67.
[SFB18] S. A. Sisson, Y. Fan, and M. A. Beau￾mont. “Overview of ABC”. In: Handbook of approx￾imate Bayesian computation. Chapman and Hal￾l/CRC, 2018, pp. 3–54.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[SG02] J. L. Schafer and J. W. Graham. “Missing data:
our view of the state of the art”. en. In: Psychol. Meth￾ods 7.2 (June 2002), pp. 147–177.
[SG05] E. Snelson and Z. Ghahramani. “Compact Ap￾proximations to Bayesian Predictive Distributions”. In:
ICML. 2005.
[SG06a] E. Snelson and Z. Ghahramani. “Sparse Gaus￾sian processes using pseudo-inputs”. In: NIPS. 2006.
[SG06b] E. Snelson and Z. Ghahramani. “Sparse Gaus￾sian Processes using Pseudo-inputs”. In: Advances in
Neural Information Processing Systems. Ed. by Y.
Weiss, B. Schölkopf, and J. Platt. Vol. 18. MIT Press,
2006.
[SG07] M. Steyvers and T. Griffiths. “Probabilistic
topic models”. In: Latent Semantic Analysis: A Road
to Meaning. Ed. by T. Landauer, D McNamara, S.
Dennis, and W. Kintsch. Laurence Erlbaum, 2007.
[SG09] R. Silva and Z. Ghahramani. “The Hidden Life
of Latent Variables: Bayesian Learning with Mixed
Graph Models”. In: JMLR 10 (2009), pp. 1187–1238.
[SGF21] S. Särkkä and Á. F. García-Fernández.
“Temporal Parallelization of Bayesian Filters and
Smoothers”. In: IEEE Trans. Automat. Contr. 66.1
(2021).
[SGS16] A. Sharghi, B. Gong, and M. Shah. “Query￾focused extractive video summarization”. In: Eu￾ropean Conference on Computer Vision. Springer.
2016, pp. 3–19.
[SH07] R. Salakhutdinov and G. Hinton. “Using Deep
Belief Nets to Learn Covariance Kernels for Gaussian
Processes”. In: NIPS. 2007.
[SH09] R. Salakhutdinov and G. Hinton. “Deep Boltz￾mann Machines”. In: AISTATS. Vol. 5. 2009, pp. 448–
455.
[SH10] R. Salakhutdinov and G. Hinton. “Replicated
Softmax: an Undirected Topic Model”. In: NIPS. 2010.
[SH21] T. Salimans and J. Ho. “Should EBMs model
the energy or the score?” In: ICLR Energy Based
Models Workshop. Apr. 2021.
[SH22] T. Salimans and J. Ho. “Progressive Distillation
for Fast Sampling of Diffusion Models”. In: ICLR. Feb.
2022.
[SHA15] M. A. Skoglund, G. Hendeby, and D. Axe￾hill. “Extended Kalman filter modifications based on
an optimization view point”. In: 2015 18th Interna￾tional Conference on Information Fusion (Fusion).
July 2015, pp. 1856–1861.
[Sha+16] B Shahriari, K Swersky, Z. Wang, R. P.
Adams, and N de Freitas. “Taking the Human Out
of the Loop: A Review of Bayesian Optimization”. In:
Proc. IEEE 104.1 (2016), pp. 148–175.
[Sha16] L. S. Shapley. 17. A value for n-person games.
Princeton University Press, 2016.
[Sha+16] M. Sharif, S. Bhagavatula, L. Bauer, and
M. K. Reiter. “Accessorize to a Crime: Real and
Stealthy Attacks on State-of-the-Art Face Recogni￾tion”. In: Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Se￾curity. ACM, 2016, pp. 1528–1540.
[Sha+19] A. Shaikhha, A. Fitzgibbon, D. Vytiniotis,
and S. Peyton Jones. “Efficient differentiable program￾ming in a functional array-processing language”. In:
Proceedings of the ACM on Programming Languages
3.ICFP (2019), pp. 1–30.
[Sha+20] H. Shah, K. Tamuly, A. Raghunathan, P.
Jain, and P. Netrapalli. “The Pitfalls of Simplicity
Bias in Neural Networks”. In: NIPS. 2020.
[Sha22] C. Shalizi. Advanced Data Analysis from an
Elementary Point of View. Cambridge University
Press, 2022.
[Sha48] C. Shannon. “A mathematical theory of com￾munication”. In: Bell Systems Tech. Journal 27
(1948), pp. 379–423.
[Sha98] R. Shachter. “Bayes-Ball: The Rational Pas￾time (for determining Irrelevance and Requisite Infor￾mation in Belief Networks and Influence Diagrams)”.
In: UAI. 1998.
[She+11] C. Shen, X. Li, L. Li, and M. C. Were. “Sensi￾tivity analysis for causal inference using inverse proba￾bility weighting”. In: Biometrical Journal 53.5 (2011),
pp. 822–837. eprint: https : / / onlinelibrary . wiley .
com/doi/pdf/10.1002/bimj.201100042.
[She+17] T. Shen, T. Lei, R. Barzilay, and T. Jaakkola.
“Style transfer from non-parallel text by cross￾alignment”. In: Advances in neural information pro￾cessing systems 30 (2017), pp. 6830–6841.
[She+20] T. Shen, J. Mueller, R. Barzilay, and T.
Jaakkola. “Educating Text Autoencoders: Latent Rep￾resentation Guidance via Denoising”. In: ICML. 2020.
[She+21] Z. Shen, J. Liu, Y. He, X. Zhang, R. Xu, H.
Yu, and P. Cui. “Towards Out-Of-Distribution Gen￾eralization: A Survey”. In: (2021). arXiv: 2108.13624
[cs.LG].
[SHF15] R. Steorts, R. Hall, and S. Fienberg. “A
Bayesian Approach to Graphical Record Linkage and
De-duplication”. In: JASA (2015).
[Shi00a] H. Shimodaira. “Improving predictive infer￾ence under covariate shift by weighting the log￾likelihood function”. In: J. Stat. Plan. Inference 90.2
(2000), pp. 227–244.
[Shi00b] B. Shipley. Cause and Correlation in Biology:
A User’s Guide to Path Analysis, Structural Equa￾tions and Causal Inference. Cambridge, 2000.
[Shi+21] C. Shi, D. Sridhar, V. Misra, and D. M. Blei.
“On the Assumptions of Synthetic Control Methods”.
In: (2021). arXiv: 2112.05671 [stat.ME].
[SHM14] D. Soudry, I. Hubara, and R. Meir. “Expecta￾tion backpropagation: Parameter-free training of mul￾tilayer neural networks with continuous or discrete
weights”. In: NIPS. 2014.
[Shr+16] A. Shrikumar, P. Greenside, A. Shcherbina,
and A. Kundaje. “Not just a black box: Learning im￾portant features through propagating activation differ￾ences”. In: arXiv preprint arXiv:1605.01713 (2016).
[SHS] D. Stutz, M. Hein, and B. Schiele. “Confidence￾calibrated adversarial training: Generalizing to unseen
attacks”. In: ().
[SHS01] B. Schölkopf, R. Herbrich, and A. J. Smola. “A
Generalized Representer Theorem”. In: COLT. COLT
’01/EuroCOLT ’01. Springer-Verlag, 2001, pp. 416–
426.
[Shu+19a] K. Shu, L. Cui, S. Wang, D. Lee, and H. Liu.
“defend: Explainable fake news detection”. In: Proceed￾ings of the 25th ACM SIGKDD international con￾ference on knowledge discovery & data mining. 2019,
pp. 395–405.
[Shu+19b] R. Shu, Y. Chen, A. Kumar, S. Ermon, and
B. Poole. “Weakly supervised disentanglement with
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1306
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
guarantees”. In: arXiv preprint arXiv:1910.09772
(2019).
[SI00] M. Sato and S. Ishii. “On-line EM algorithm for
the normalized Gaussian network”. In: Neural Com￾putation 12 (2000), pp. 407–432.
[Sil+14] D. Silver, G. Lever, N. Heess, T. Degris,
D. Wierstra, and M. Riedmiller. “Deterministic
Policy Gradient Algorithms”. In: ICML. ICML’14.
JMLR.org, 2014, pp. I–387–I–395.
[Sil+16] D. Silver et al. “Mastering the game of Go with
deep neural networks and tree search”. en. In: Nature
529.7587 (2016), pp. 484–489.
[Sil18] D. Silver. Lecture 9L Exploration and Exploita￾tion. 2018.
[Sil+18] D. Silver et al. “A general reinforcement learn￾ing algorithm that masters chess, shogi, and Go
through self-play”. en. In: Science 362.6419 (2018),
pp. 1140–1144.
[Sil85] B. W. Silverman. “Some Aspects of the Spline
Smoothing Approach to Non-Parametric Regression
Curve Fitting”. In: J. R. Stat. Soc. Series B Stat.
Methodol. 47.1 (1985), pp. 1–52.
[Sim02] D. Simon. “Training radial basis neural net￾works with the extended Kalman Filter”. In: Neuro￾computing (2002).
[Sim06] D. Simon. Optimal State Estimation:
Kalman, H Infinity, and Nonlinear Approaches. Wi￾ley, 2006.
[Sin+00] S. Singh, T. Jaakkola, M. L. Littman, and C.
Szepesvári. “Convergence Results for Single-Step On￾PolicyReinforcement-Learning Algorithms”. In: MLJ
38.3 (2000), pp. 287–308.
[Sin67] R. Sinkhorn. “Diagonal Equivalence to Matri￾ces with Prescribed Row and Column Sums”. In:
The American Mathematical Monthly 74.4 (1967),
pp. 402–405.
[Siv+20] T. Sivula, M. Magnusson, A. A. Matamoros,
and A. Vehtari. “Uncertainty in Bayesian Leave-One￾Out Cross-Validation Based Model Comparison”. In:
(Aug. 2020). arXiv: 2008.10296 [stat.ME].
[SJ08] S. Shirdhonkar and D. W. Jacobs. “Approximate
earth mover’s distance in linear time”. In: 2008 IEEE
Conference on Computer Vision and Pattern Recog￾nition. IEEE. 2008, pp. 1–8.
[SJ15] A. Swaminathan and T. Joachims. “Batch
Learning from Logged Bandit Feedback through Coun￾terfactual Risk Minimization”. In: JMLR 16.1 (2015),
pp. 1731–1755.
[SJ95] L. Saul and M. Jordan. “Exploiting tractable
substructures in intractable networks”. In: NIPS.
Vol. 8. 1995.
[SJ99] L. Saul and M. Jordan. “Mixed memory Markov
models: Decomposing complex stochastic processes as
mixture of simpler ones”. In: Machine Learning 37.1
(1999), pp. 75–87.
[SJJ96] L. Saul, T. Jaakkola, and M. Jordan. “Mean
Field Theory for Sigmoid Belief Networks”. In: JAIR
4 (1996), pp. 61–76.
[SJR04] S. Singh, M. James, and M. Rudary. “Predic￾tive state representations: A new theory for modeling
dynamical systems”. In: UAI. 2004.
[SK19] C. Shorten and T. M. Khoshgoftaar. “A survey
on Image Data Augmentation for Deep Learning”. en.
In: Journal of Big Data 6.1 (2019), pp. 1–48.
[SK20] S. Singh and S. Krishnan. “Filter Response Nor￾malization Layer: Eliminating Batch Dependence in
the Training of Deep Neural Networks”. In: CVPR.
2020.
[SK89] R. Shachter and C. R. Kenley. “Gaussian Influ￾ence Diagrams”. In: Managment Science 35.5 (1989),
pp. 527–550.
[Ski06] J. Skilling. “Nested sampling for general
Bayesian computation”. In: Bayesian Analysis 1.4
(2006), pp. 833–860.
[Ski89] J. Skilling. “The eigenvalues of mega￾dimensional matrices”. In: Maximum Entropy and
Bayesian Methods. Springer, 1989, pp. 455–466.
[SKM07] M. Sugiyama, M. Krauledat, and K.-R.
Müller. “Covariate Shift Adaptation by Importance
Weighted Cross Validation”. In: J. Mach. Learn. Res.
8.35 (2007), pp. 985–1005.
[SKM18] S. Schwöbel, S. Kiebel, and D. Marković. “Ac￾tive Inference, Belief Propagation, and the Bethe Ap￾proximation”. en. In: Neural Comput. 30.9 (2018),
pp. 2530–2567.
[SKM21] M. Shanahan, C. Kaplanis, and J. Mitro￾vić. “Encoders and Ensembles for Task-Free Continual
Learning”. In: (2021). arXiv: 2105.13327 [cs.LG].
[SKP15] F. Schroff, D. Kalenichenko, and J. Philbin.
“Facenet: A unified embedding for face recognition and
clustering”. In: Proceedings of the IEEE conference
on computer vision and pattern recognition. 2015,
pp. 815–823.
[SKTF18] H. Shao, A. Kumar, and P Thomas Fletcher.
“The Riemannian Geometry of Deep Generative Mod￾els”. In: CVPR. 2018, pp. 315–323.
[SKW15] T. Salimans, D. Kingma, and M. Welling.
“Markov Chain Monte Carlo and Variational Inference:
Bridging the Gap”. In: ICML. 2015, pp. 1218–1226.
[SL08] A. L. Strehl and M. L. Littman. “An Analysis of
Model-based Interval Estimation for Markov Decision
Processes”. In: J. of Comp. and Sys. Sci. 74.8 (2008),
pp. 1309–1331.
[SL18] S. L. Smith and Q. V. Le. “A Bayesian Perspec￾tive on Generalization and Stochastic Gradient De￾scent”. In: ICLR. 2018.
[SL90] D. J. Spiegelhalter and S. L. Lauritzen. “Sequen￾tial updating of conditional probabilities on directed
graphical structures”. In: Networks 20 (1990).
[Sla+20] D. Slack, S. Hilgard, E. Jia, S. Singh, and
H. Lakkaraju. “Fooling lime and shap: Adversarial at￾tacks on post hoc explanation methods”. In: Proceed￾ings of the AAAI/ACM Conference on AI, Ethics,
and Society. 2020, pp. 180–186.
[SLG17] A. Sharghi, J. S. Laurel, and B. Gong. “Query￾focused video summarization: Dataset, evaluation,
and a memory network based approach”. In: Proceed￾ings of the IEEE Conference on Computer Vision
and Pattern Recognition. 2017, pp. 4788–4797.
[Sli19] A. Slivkins. “Introduction to Multi-Armed Ban￾dits”. In: Foundations and Trends in Machine Learn￾ing (2019).
[SLL09] A. L. Strehl, L. Li, and M. L. Littman. “Re￾inforcement Learning in Finite MDPs: PAC Analysis”.
In: JMLR 10 (2009), pp. 2413–2444.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[SLM92] B. Selman, H. Levesque, and D. Mitchell. “A
New Method for Solving Hard Satisfiability Problems”.
In: Proceedings of the Tenth National Conference on
Artificial Intelligence. AAAI’92. AAAI Press, 1992,
pp. 440–446.
[SLW19] M. Sadinle, J. Lei, and L. Wasserman. “Least
Ambiguous Set-Valued Classifiers With Bounded Er￾ror Levels”. In: JASA 114.525 (2019), pp. 223–234.
[SM07] C. Sutton and A. McCallum. “Improved Dy￾namic Schedules for Belief Propagation”. In: UAI.
2007.
[SM12] Y Saika and K Morimoto. “Generalized MAP
estimation via parameter scheduling and maximizer of
the posterior marginal estimate for image reconstruc￾tion using multiple halftone images”. In: 12th Interna￾tional Conference on Control, Automation and Sys￾tems. 2012, pp. 1285–1289.
[SMB10] H. Schulz, A. Müller, and S. Behnke. “Inves￾tigating convergence of restricted Boltzmann machine
learning”. In: NIPS 2010 Workshop on Deep Learning
and Unsupervised Feature Learning. Vol. 1. 2. 2010,
pp. 6–1.
[SME21] J. Song, C. Meng, and S. Ermon. “Denoising
Diffusion Implicit Models”. In: ICLR. 2021.
[SMH07] R. R. Salakhutdinov, A. Mnih, and G. E. Hin￾ton. “Restricted Boltzmann machines for collaborative
filtering”. In: ICML. Vol. 24. 2007, pp. 791–798.
[Smi+00] G. Smith, J. F. G. de Freitas, T. Robinson,
and M. Niranjan. “Speech Modelling Using Subspace
and EM Techniques”. In: NIPS. MIT Press, 2000,
pp. 796–802.
[Smi+06] V. Smith, J. Yu, T. Smulders, A. Hartemink,
and E. Jarvis. “Computational Inference of Neural In￾formation Flow Networks”. In: PLOS Computational
Biology 2 (2006), pp. 1436–1439.
[Smi11] N. Smith. Linguistic structure prediction.
Morgan Claypool, 2011.
[Smi+17] D. Smilkov, N. Thorat, B. Kim, F. Viégas,
and M. Wattenberg. SmoothGrad: removing noise by
adding noise. 2017. arXiv: 1706.03825 [cs.LG].
[Smo86] P. Smolensky. “Information processing in dy￾namical systems: foundations of harmony theory”. In:
Parallel Distributed Processing: Explorations in the
Microstructure of Cognition. Volume 1. Ed. by D.
Rumehart and J. McClelland. McGraw-Hill, 1986.
[SMS17] M. Saito, E. Matsumoto, and S. Saito. “Tem￾poral Generative Adversarial Nets with Singular Value
Clipping”. In: ICCV. 2017.
[SMT18] M. R. U. Saputra, A. Markham, and N.
Trigoni. “Visual SLAM and Structure from Motion in
Dynamic Environments: A Survey”. In: ACM Comput￾ing Surveys 51.2 (2018), pp. 1–36.
[Smy20] S. Smyl. “A hybrid method of exponential
smoothing and recurrent neural networks for time
series forecasting”. In: Int. J. Forecast. 36.1 (2020),
pp. 75–85.
[Sn+16] C. K. Sø nderby, T. Raiko, L. Maalø e, S. R. K.
Sø nderby, and O. Winther. “Ladder Variational Au￾toencoders”. In: NIPS. Curran Associates, Inc., 2016,
pp. 3738–3746.
[SNM16] M. Suzuki, K. Nakayama, and Y. Matsuo.
“Joint Multimodal Learning with Deep Generative
Models”. In: (2016). arXiv: 1611.01891 [stat.ML].
[SOB12] R. Snyder, J. K. Ord, and A. Beaumont. “Fore￾casting the intermittent demand for slow-moving in￾ventories: A modelling approach”. In: Int. J. Forecast.
28.2 (2012), pp. 485–496.
[Soh16] K. Sohn. “Improved deep metric learning
with multi-class n-pair loss objective”. In: Advances
in Neural Information Processing Systems. 2016,
pp. 1857–1865.
[Søn+16] C. Sønderby, T. Raiko, L. Maaløe, S. Søn￾derby, and O. Winther. “How to Train Deep Vari￾ational Autoencoders and Probabilistic Ladder Net￾works”. In: ICML. 2016.
[Son+19] Y. Song, S. Garg, J. Shi, and S. Ermon.
“Sliced Score Matching: A Scalable Approach to Den￾sity and Score Estimation”. In: Proceedings of the
Thirty-Fifth Conference on Uncertainty in Artificial
Intelligence, UAI 2019, Tel Aviv, Israel, July 22-25,
2019. 2019, p. 204.
[Son+21a] Y. Song, C. Durkan, I. Murray, and S. Er￾mon. “Maximum Likelihood Training of Score-Based
Diffusion Models”. In: NIPS. 2021.
[Son+21b] Y. Song, J. Sohl-Dickstein, D. P. Kingma, A.
Kumar, S. Ermon, and B. Poole. “Score-Based Gener￾ative Modeling through Stochastic Differential Equa￾tions”. In: ICLR. 2021.
[Son98] E. D. Sontag. Mathematical Control The￾ory: Deterministic Finite Dimensional Systems. 2nd.
Vol. 6. Texts in Applied Mathematics. Springer, 1998.
[SOS92] H. Seung, M. Opper, and H. Sompolinsky.
“Query by committee”. In: 5th Annual Workshop on
Computational Learning Theory. 1992, 287–294.
[SPD92] S. Shah, F. Palmieri, and M. Datum. “Opti￾mal filtering algorithms for fast learning in feedfor￾ward neural networks”. In: Neural Netw. 5.5 (1992),
pp. 779–787.
[Spi71] M. Spivak. Calculus On Manifolds: A Modern
Approach To Classical Theorems Of Advanced Cal￾culus. Westview Press; 5th edition, 1971.
[SPL20] M. B. Sariyildiz, J. Perez, and D. Larlus.
“Learning visual representations with caption annota￾tions”. In: Computer Vision–ECCV 2020: 16th Euro￾pean Conference, Glasgow, UK, August 23–28, 2020,
Proceedings, Part VIII 16. Springer. 2020, pp. 153–
170.
[Spr+14] J. T. Springenberg, A. Dosovitskiy, T.
Brox, and M. Riedmiller. “Striving for simplic￾ity: The all convolutional net”. In: arXiv preprint
arXiv:1412.6806 (2014).
[Spr+16] J. T. Springenberg, A. Klein, S. Falkner,
and F. Hutter. “Bayesian Optimization with Robust
Bayesian Neural Networks”. In: NIPS. 2016, pp. 4141–
4149.
[SPW18] M. H. S. Segler, M. Preuss, and M. P. Waller.
“Planning chemical syntheses with deep neural net￾works and symbolic AI”. en. In: Nature 555.7698
(2018), pp. 604–610.
[SPZ09] P. Schniter, L. C. Potter, and J. Ziniel. “Fast
Bayesian Matching Pursuit: Model Uncertainty and
Parameter Estimation for Sparse Linear Models”. In:
IEEE Trans. on Signal Processing (2009).
[SQ05] V. Smidl and A. Quinn. The Variational Bayes
Method in Signal Processing. Springer, 2005.
[SR+14] A. Sharif Razavian, H. Azizpour, J. Sullivan,
and S. Carlsson. “CNN features off-the-shelf: an as￾tounding baseline for recognition”. In: Proceedings of
the IEEE conference on computer vision and pattern
recognition workshops. 2014, pp. 806–813.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1308
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[SRG03] R. Salakhutdinov, S. T. Roweis, and
Z. Ghahramani. “Optimization with EM and
Expectation-Conjugate-Gradient”. In: ICML. 2003.
[Sri+09] B. K. Sriperumbudur, K. Fukumizu, A. Gret￾ton, B. Schölkopf, and G. R. G. Lanckriet. “On in￾tegral probability metrics, ϕ-divergences and binary
classification”. In: (2009). arXiv: 0901.2698 [cs.IT].
[Sri+10] N. Srinivas, A. Krause, S. Kakade, and M.
Seeger. “Gaussian Process Optimization in the Ban￾dit Setting: No Regret and Experimental Design”. In:
ICML. 2010, pp. 1015–1022.
[Sri+14a] N. Srivastava, G. Hinton, A. Krizhevsky, I.
Sutskever, and R. Salakhutdinov. “Dropout: A Simple
Way to Prevent Neural Networks from Over tting”. In:
JMLR (2014).
[Sri+14b] N. Srivastava, G. E. Hinton, A. Krizhevsky,
I. Sutskever, and R. Salakhutdinov. “Dropout: a sim￾ple way to prevent neural networks from overfitting”.
In: J. Mach. Learn. Res. 15 (2014), pp. 1929–1958.
[Sri+17] A. Srivastava, L. Valkov, C. Russell, M. U.
Gutmann, and C. Sutton. “Veegan: Reducing mode
collapse in gans using implicit variational learning”.
In: Proceedings of the 31st International Conference
on Neural Information Processing Systems. 2017,
pp. 3310–3320.
[SRS10] P. Schnitzspan, S. Roth, and B. Schiele. “Auto￾matic discovery of meaningful object parts with latent
CRFs”. In: CVPR. 2010.
[SS15] D. J. Sutherland and J. Schneider. “On the Er￾ror of Random Fourier Features”. In: UAI. June 2015.
[SS17a] A. Srivastava and C. Sutton. “Autoencoding
Variational Inference For Topic Models”. In: ICLR.
2017.
[SS17b] A. Srivastava and C. Sutton. “Autoencoding
Variational Inference For Topic Models”. In: ICLR.
2017.
[SS18a] O. Sener and S. Savarese. “Active Learning
for Convolutional Neural Networks: A Core-Set Ap￾proach”. In: International Conference on Learning
Representations. 2018.
[SS18b] A. Subbaswamy and S. Saria. “Counterfactual
Normalization: Proactively Addressing Dataset Shift
and Improving Reliability Using Causal Mechanisms”.
In: Proceedings of the 34th Conference on Uncer￾tainty in Artificial Intelligence (UAI), 2018. 2018.
[SS19] S. Sarkka and A. Solin. Applied stochastic dif￾ferential equations. en. Cambridge University Press,
2019.
[SS20a] S. Sarkka and L. Svensson. “Levenberg￾Marquardt and Line-Search Extended Kalman
Smoothers”. In: ICASSP. Barcelona, Spain: IEEE,
May 2020.
[SS20b] K. E. Smith and A. O. Smith. “Conditional
GAN for timeseries generation”. In: arXiv preprint
arXiv:2006.16477 (2020).
[SS21] I. Sucholutsky and M. Schonlau. “Soft-Label
Dataset Distillation and Text Dataset Distillation”. In:
2021 International Joint Conference on Neural Net￾works (IJCNN). 2021, pp. 1–8.
[SS23] S. Sarkka and L. Svensson. Bayesian Filtering
and Smoothing (2nd edition). Cambridge University
Press, 2023.
[SS82] R. H. Shumway and D. S. Stoffer. “An approach
to time series smoothing and forecasting using the em
algorithm”. en. In: J. Time Ser. Anal. 3.4 (July 1982),
pp. 253–264.
[SSA14] K. Swersky, J. Snoek, and R. P. Adams.
“Freeze-Thaw Bayesian Optimization”. In: (2014).
arXiv: 1406.3896 [stat.ML].
[SSA18] K. Shmelkov, C. Schmid, and K. Alahari.
“How good is my GAN?” In: Proceedings of the Euro￾pean Conference on Computer Vision (ECCV). 2018,
pp. 213–229.
[SSB17] S. Semeniuta, A. Severyn, and E. Barth. “A
Hybrid Convolutional Variational Autoencoder for
Text Generation”. In: (2017). arXiv: 1702 . 02390
[cs.CL].
[SSE18] Y. Song, J. Song, and S. Ermon. “Accelerat￾ing Natural Gradient with Higher-Order Invariance”.
In: ICML. 2018.
[SSF16] M. W. Seeger, D. Salinas, and V. Flunkert.
“Bayesian Intermittent Demand Forecasting for Large
Inventories”. In: NIPS. 2016, pp. 4646–4654.
[SSG18a] S. Semeniuta, A. Severyn, and S. Gelly. “On
Accurate Evaluation of GANs for Language Genera￾tion”. In: arXiv preprint arXiv:1806.04936 (2018).
[SSG18b] S. Semeniuta, A. Severyn, and S. Gelly. “On
Accurate Evaluation of GANs for Language Genera￾tion”. In: (2018). arXiv: 1806.04936 [cs.CL].
[SSG19] R. Singh, M. Sahani, and A. Gretton. “Ker￾nel Instrumental Variable Regression”. In: Advances
in Neural Information Processing Systems. 2019,
pp. 4593–4605.
[SSH13] S. Sarkka, A. Solin, and J. Hartikainen.
“Spatio-Temporal Learning via Infinite-Dimensional
Bayesian Filtering and Smoothing: A look at Gaus￾sian process regression through Kalman filtering”. In:
IEEE Signal Processing Magazine (2013).
[SSJ12] R. Sipos, P. Shivaswamy, and T. Joachims.
“Large-margin learning of submodular summarization
models”. In: Proceedings of the 13th Conference of
the European Chapter of the Association for Com￾putational Linguistics. 2012, pp. 224–233.
[SSK12] M. Sugiyama, T. Suzuki, and T. Kanamori.
Density Ratio Estimation in Machine Learning. en.
Cambridge University Press, 2012.
[SSM18] S. Santurkar, L. Schmidt, and A. Madry. “A
classification-based study of covariate shift in gan dis￾tributions”. In: International Conference on Machine
Learning. PMLR. 2018, pp. 4480–4489.
[SSZ17] J. Snell, K. Swersky, and R. Zemel. “Prototyp￾ical networks for few-shot learning”. In: NIPS. 2017,
pp. 4077–4087.
[Sta] Scientific Explanation. https : / / plato .
stanford . edu / entries / scientific - explanation /
#ConcOpenIssuFutuDire. Accessed: 2021-11-23.
[Sta07] K. O. Stanley. “Compositional pattern produc￾ing networks: A novel abstraction of development”. In:
Genet. Program. Evolvable Mach. 8.2 (2007), pp. 131–
162.
[Sta+17] N. Stallard, F. Miller, S. Day, S. W. Hee, J.
Madan, S. Zohar, and M. Posch. “Determination of
the optimal sample size for a clinical trial accounting
for the population size”. en. In: Biom. J. 59.4 (2017),
pp. 609–625.
[Sta+19] K. O. Stanley, J. Clune, J. Lehman, and
R. Miikkulainen. “Designing neural networks through
neuroevolution”. In: Nature Machine Intelligence 1.1
(2019).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Sta+20] T. Standley, A. R. Zamir, D. Chen, L. Guibas,
J. Malik, and S. Savarese. “Which Tasks Should Be
Learned Together in Multi-task Learning?” In: ICML.
2020.
[Ste81] C. M. Stein. “Estimation of the mean of a multi￾variate normal distribution”. In: The annals of Statis￾tics (1981), pp. 1135–1151.
[Sto09] A. J. Storkey. “When Training and Test Sets
are Different: Characterising Learning Transfer”. In:
Dataset Shift in Machine Learning. 2009.
[Sto17] J. Stoehr. “A review on statistical inference
methods for discrete Markov random fields”. In: (2017).
arXiv: 1704.03331 [stat.ME].
[STR10] Y. Saatchi, R. Turner, and C. E. Rasmussen.
“Gaussian Process Change Point Models”. In: ICML.
unknown, 2010, pp. 927–934.
[Str+17] H. Strobelt, S. Gehrmann, H. Pfister, and
A. M. Rush. “Lstmvis: A tool for visual analysis of
hidden state dynamics in recurrent neural networks”.
In: IEEE transactions on visualization and computer
graphics 24.1 (2017), pp. 667–676.
[Str19] M. Streeter. “Bayes Optimal Early Stopping
Policies for Black-Box Optimization”. In: (2019).
arXiv: 1902.08285 [cs.LG].
[Stu+22] D. Stutz, Krishnamurthy, Dvijotham, A. T.
Cemgil, and A. Doucet. “Learning Optimal Conformal
Classifiers”. In: ICLR. 2022.
[STY17] M. Sundararajan, A. Taly, and Q. Yan. Ax￾iomatic Attribution for Deep Networks. 2017. arXiv:
1703.01365 [cs.LG].
[Suc+20] F. P. Such, A. Rawal, J. Lehman, K. Stanley,
and J. Clune. “Generative teaching networks: Accel￾erating neural architecture search by learning to gen￾erate synthetic training data”. In: International Con￾ference on Machine Learning. PMLR. 2020, pp. 9206–
9216.
[Sud+03] E. Sudderth, A. Ihler, W. Freeman, and
A. Willsky. “Nonparametric Belief Propagation”. In:
CVPR. 2003.
[Sud06] E. Sudderth. “Graphical Models for Visual Ob￾ject Recognition and Tracking”. PhD thesis. MIT,
2006.
[Sud+10] E. Sudderth, A. Ihler, M. Isard, W. Freeman,
and A. Willsky. “Nonparametric Belief Propagation”.
In: Comm. of the ACM 53.10 (2010).
[Sug+13] M. Sugiyama, T. Kanamori, T. Suzuki, M. C.
du Plessis, S. Liu, and I. Takeuchi. “Density-difference
estimation”. en. In: Neural Comput. 25.10 (2013),
pp. 2734–2775.
[Sun+09] L. Sun, S. Ji, S. Yu, and J. Ye. “On the Equiv￾alence Between Canonical Correlation Analysis and
Orthonormalized Partial Least Squares”. In: IJCAI.
2009.
[Sun+17] C. Sun, A. Shrivastava, S. Singh, and A.
Gupta. “Revisiting unreasonable effectiveness of data
in deep learning era”. In: Proceedings of the IEEE
international conference on computer vision. 2017,
pp. 843–852.
[Sun+18] S. Sun, G. Zhang, C. Wang, W. Zeng, J. Li,
and R. Grosse. “Differentiable Compositional Kernel
Learning for Gaussian Processes”. In: ICML. 2018.
[Sun+19a] S. Sun, G. Zhang, J. Shi, and R. Grosse.
“Functional variational bayesian neural networks”. In:
arXiv preprint arXiv:1903.05779 (2019).
[Sun+19b] S. Sun, Z. Cao, H. Zhu, and J. Zhao. “A
Survey of Optimization Methods from a Machine
Learning Perspective”. In: (2019). arXiv: 1906 . 06821
[cs.LG].
[Sun+19c] M. Sundararajan, J. Xu, A. Taly, R. Sayres,
and A. Najmi. “Exploring Principled Visualizations
for Deep Network Attributions.” In: IUI Workshops.
Vol. 4. 2019.
[Sun+20] Y. Sun, X. Wang, Z. Liu, J. Miller, A.
Efros, and M. Hardt. “Test-Time Training with Self￾Supervision for Generalization under Distribution
Shifts”. In: ICML. Vol. 119. Proceedings of Machine
Learning Research. PMLR, 2020, pp. 9229–9248.
[Sun+22] T. Sun, M. Segu, J. Postels, Y. Wang, L. Van
Gool, B. Schiele, F. Tombari, and F. Yu. “SHIFT: A
Synthetic Driving Dataset for Continuous Multi-Task
Domain Adaptation”. In: CVPR. June 2022.
[Sut+17] D. J. Sutherland, H.-Y. Tung, H. Strathmann,
S. De, A. Ramdas, A. Smola, and A. Gretton. “Gener￾ative Models and Model Criticism via Optimized Max￾imum Mean Discrepancy”. In: ICLR. 2017.
[Sut19] R. Sutton. The Bitter Lesson. 2019.
[Sut88] R. Sutton. “Learning to predict by the meth￾ods of temporal differences”. In: Machine Learning 3.1
(1988), pp. 9–44.
[Sut90] R. S. Sutton. “Integrated Architectures for
Learning, Planning, and Reacting Based on Approx￾imating Dynamic Programming”. In: ICML. Ed. by
B. Porter and R. Mooney. Morgan Kaufmann, 1990,
pp. 216–224.
[Sut96] R. S. Sutton. “Generalization in Reinforce￾ment Learning: Successful Examples Using Sparse
Coarse Coding”. In: NIPS. Ed. by D. S. Touretzky,
M. C. Mozer, and M. E. Hasselmo. MIT Press, 1996,
pp. 1038–1044.
[Sut+99] R. Sutton, D. McAllester, S. Singh, and Y.
Mansour. “Policy Gradient Methods for Reinforce￾ment Learning with Function Approximation”. In:
NIPS. 1999.
[SV08] G. Shafer and V. Vovk. “A Tutorial on Confor￾mal Prediction”. In: JMLR 9.Mar (2008), pp. 371–421.
[SV14] S. L. Scott and H. R. Varian. “Predicting the
present with Bayesian structural time series”. In: In￾ternational Journal of Mathematical Modelling and
Numerical Optimisation 5.1-2 (2014), pp. 4–23.
[SV98] M. Studenty and J. Vejnarova. “The multi￾information function as a tool for measuring stochastic
dependence”. In: Learning in graphical models. Ed. by
M. Jordan. MIT Press, 1998, pp. 261–297.
[SVE04] A. Smola, S. V. N. Vishwanathan, and E.
Eskin. “Laplace Propagation”. In: NIPS. MIT Press,
2004, pp. 441–448.
[Svi04] M. Sviridenko. “A note on maximizing a sub￾modular set function subject to a knapsack constraint”.
In: Operations Research Letters 32.1 (2004), pp. 41–
43.
[SVK19] J. Su, D. V. Vargas, and S. Kouichi. “One
pixel attack for fooling deep neural networks”. In:
IEEE Trans. Evol. Comput. 23.5 (2019).
[SVZ13] K. Simonyan, A. Vedaldi, and A. Zisserman.
“Deep inside convolutional networks: Visualising im￾age classification models and saliency maps”. In: arXiv
preprint arXiv:1312.6034 (2013).
[SW06] J. E. Smith and R. L. Winkler. “The Opti￾mizer’s Curse: Skepticism and Postdecision Surprise
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1310
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
in Decision Analysis”. In: Manage. Sci. 52.3 (2006),
pp. 311–322.
[SW13] G. J. Sussman and J. Wisdom. Functional Dif￾ferential Geometry. Functional Differential Geometry.
MIT Press, 2013.
[SW20] V. G. Satorras and M. Welling. “Neural En￾hanced Belief Propagation on Factor Graphs”. In:
(2020). arXiv: 2003.01998 [cs.LG].
[SW87a] M. Shewry and H. Wynn. “Maximum en￾tropy sampling”. In: J. Applied Statistics 14 (1987),
165–170.
[SW87b] R. Swendsen and J.-S. Wang. “Nonuniversal
critical dynamics in Monte Carlo simulations”. In:
Physical Review Letters 58 (1987), pp. 86–88.
[SW89] S. Singhal and L. Wu. “Training Multilayer Per￾ceptrons with the Extended Kalman Algorithm”. In:
NIPS. Vol. 1. 1989.
[Swe+10] K. Swersky, B. Chen, B. Marlin, and N. de
Freitas. “A Tutorial on Stochastic Approximation Al￾gorithms for Training Restricted Boltzmann Machines
and Deep Belief Nets”. In: Information Theory and
Applications (ITA) Workshop. 2010.
[Swe+13] K. Swersky, D. Duvenaud, J. Snoek, F. Hut￾ter, and M. A. Osborne. “Raiders of the Lost Archi￾tecture: Kernels for Bayesian Optimization in Condi￾tional Parameter Spaces”. In: NIPS BayesOpt work￾shop. 2013.
[SWL03] M. Seeger, C. K. I. Williams, and N. D.
Lawrence. “Fast Forward Selection to Speed Up Sparse
Gaussian Process Regression”. In: AISTATS. 2003.
[SYD19] R. Sen, H.-F. Yu, and I. Dhillon. “Think Glob￾ally, Act Locally: A Deep Neural Network Approach to
High-Dimensional Time Series Forecasting”. In: NIPS.
2019.
[SZ22] R. Shwartz-Ziv. “Information Flow in Deep Neu￾ral Networks”. PhD thesis. 2022.
[SZ+22] R. Shwartz-Ziv, M. Goldblum, H. Souri, S.
Kapoor, C. Zhu, Y. LeCun, and A. G. Wilson. “Pre￾Train Your Loss: Easy Bayesian Transfer Learning
with Informative Priors”. In: (May 2022). arXiv: 2205.
10279 [cs.LG].
[Sze10] C. Szepesvari. Algorithms for Reinforcement
Learning. Morgan Claypool, 2010.
[Sze+14] C. Szegedy, W. Zaremba, I. Sutskever, J.
Bruna, D. Erhan, I. Goodfellow, and R. Fergus. “In￾triguing properties of neural networks”. In: ICLR.
2014.
[Sze+15a] C. Szegedy, W. Liu, Y. Jia, P. Sermanet,
S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, and
A. Rabinovich. “Going Deeper with Convolutions”. In:
CVPR. 2015.
[Sze+15b] C. Szegedy, V. Vanhoucke, S. Ioffe, J.
Shlens, and Z. Wojna. “Rethinking the Inception Ar￾chitecture for Computer Vision”. In: (2015). arXiv:
1512.00567 [cs.CV].
[TAH20] D. Teney, E. Abbasnejad, and A. van den Hen￾gel. “Learning What Makes a Difference from Coun￾terfactual Examples and Gradient Supervision”. In:
CoRR abs/2004.09034 (2020). arXiv: 2004.09034.
[TB16] P. S. Thomas and E. Brunskill. “Data-Efficient
Off-Policy Policy Evaluation for Reinforcement Learn￾ing”. In: ICML. 2016, pp. 2139–2148.
[TB22] A. Tiulpin and M. B. Blaschko. “Greedy
Bayesian Posterior Approximation with Deep Ensem￾bles”. In: Trans. on Machine Learning Research
(2022).
[TB99] M. Tipping and C. Bishop. “Probabilistic prin￾cipal component analysis”. In: J. of Royal Stat. Soc.
Series B 21.3 (1999), pp. 611–622.
[TBA19] N. Tremblay, S. Barthelmé, and P.-O. Am￾blard. “Determinantal Point Processes for Coresets.”
In: J. Mach. Learn. Res. 20 (2019), pp. 168–1.
[TBB19] J. Townsend, T. Bird, and D. Barber. “Practi￾cal Lossless Compression with Latent Variables using
Bits Back Coding”. In: ICLR. 2019.
[TBF06] S. Thrun, W. Burgard, and D. Fox. Proba￾bilistic Robotics. MIT Press, 2006.
[TBS13] R. Turner, S. Bottone, and C. Stanek. “Online
variational approximations to non-exponential family
change point models: With application to radar track￾ing”. In: NIPS. 2013.
[TCG21] Y. Tian, X. Chen, and S. Ganguli. “Under￾standing self-supervised learning dynamics without
contrastive pairs”. In: International Conference on
Machine Learning. PMLR. 2021, pp. 10268–10278.
[Teh06] Y. W. Teh. “A hierarchical Bayesian language
model based on Pitman-Yor processes”. In: Proc.
of the Assoc. for Computational Linguistics. 2006,
985=992.
[Teh+06] Y.-W. Teh, M. Jordan, M. Beal, and D. Blei.
“Hierarchical Dirichlet processes”. In: JASA 101.476
(2006), pp. 1566–1581.
[Teh+20] N. Tehrani, N. S. Arora, Y. L. Li, K. D.
Shah, D. Noursi, M. Tingley, N. Torabi, S. Masouleh,
E. Lippert, and E. Meijer. “Bean Machine: A Declar￾ative Probabilistic Programming Language For Effi￾cient Programmable Inference”. In: Proceedings of
the 10th International Conference on Probabilistic
Graphical Models. Ed. by M. Jaeger and T. D. Nielsen.
Vol. 138. Proceedings of Machine Learning Research.
PMLR, 2020, pp. 485–496.
[Ten+20] I. Tenney, J. Wexler, J. Bastings, T. Boluk￾basi, A. Coenen, S. Gehrmann, E. Jiang, M.
Pushkarna, C. Radebaugh, E. Reif, et al. “The lan￾guage interpretability tool: Extensible, interactive vi￾sualizations and analysis for NLP models”. In: arXiv
preprint arXiv:2008.05122 (2020).
[TF03] M. Tipping and A. Faul. “Fast marginal like￾lihood maximisation for sparse Bayesian models”. In:
AI/Stats. 2003.
[TG18] L. Tu and K. Gimpel. “Learning Approximate
Inference Networks for Structured Prediction”. In:
ICLR. 2018.
[TGFS18] F. Tronarp, Á. F. García-Fernández, and S.
Särkkä. “Iterative Filtering and Smoothing in Nonlin￾ear and Non-Gaussian Systems Using Conditional Mo￾ments”. In: IEEE Signal Process. Lett. 25.3 (2018),
pp. 408–412.
[TGK03] B. Taskar, C. Guestrin, and D. Koller. “Max￾Margin Markov Networks”. In: NIPS. 2003.
[TH09] T. Tieleman and G. Hinton. “Using Fast
Weights to Improve Persistent Contrastive Diver￾gence”. In: ICML. 2009, pp. 1033–1040.
[Tho+19] V. Thomas, F. Pedregosa, B. van Merriën￾boer, P.-A. Mangazol, Y. Bengio, and N. Le Roux.
“Information matrices and generalization”. In: (2019).
arXiv: 1906.07774 [cs.LG].
[Tho33] W. R. Thompson. “On the Likelihood that
One Unknown Probability Exceeds Another in View of
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
the Evidence of Two Samples”. In: Biometrika 25.3/4
(1933), pp. 285–294.
[Thr+04] S. Thrun, M. Montemerlo, D. Koller, B. Weg￾breit, J. Nieto, and E. Nebot. “FastSLAM: An efficient
solution to the simultaneous localization and mapping
problem with unknown data association”. In: JMLR
2004 (2004).
[Thr98] S. Thrun. “Lifelong learning algorithms”. In:
Learning to learn. Ed. by S. Thrun and L. Pratt.
Kluwer, 1998, pp. 181–209.
[Thu+21] S. Thulasidasan, S. Thapa, S. Dhaubhadel,
G. Chennupati, T. Bhattacharya, and J. Bilmes. “An
Effective Baseline for Robustness to Distributional
Shift”. In: (2021). arXiv: 2105.07107 [cs.LG].
[Tia+20] Y. Tian, C. Sun, B. Poole, D. Krishnan, C.
Schmid, and P. Isola. “What makes for good views
for contrastive learning”. In: ArXiv abs/2005.10243
(2020).
[Tib96] R. Tibshirani. “Regression shrinkage and selec￾tion via the lasso”. In: J. Royal. Statist. Soc B 58.1
(1996), pp. 267–288.
[Tie08] T. Tieleman. “Training restricted Boltzmann
machines using approximations to the likelihood gra￾dient”. In: ICML. ACM New York, NY, USA. 2008,
pp. 1064–1071.
[Tip01] M. Tipping. “Sparse Bayesian learning and
the relevance vector machine”. In: JMLR 1 (2001),
pp. 211–244.
[Tip+03] M. K. Tippett, J. L. Anderson, C. H. Bishop,
T. M. Hamill, and J. S. Whitaker. “Ensemble Square
Root Filters”. en. In: Mon. Weather Rev. 131.7 (July
2003), pp. 1485–1490.
[Tip98] M. Tipping. “Probabilistic visualization of
high-dimensional binary data”. In: NIPS. 1998.
[Tit09] M. K. Titsias. “Variational Learning of Induc￾ing Variables in Sparse Gaussian Processes”. In: AIS￾TATS. 2009.
[TK86] L. Tierney and J. Kadane. “Accurate approx￾imations for posterior moments and marginal densi￾ties”. In: JASA 81.393 (1986).
[TKI20] Y. Tian, D. Krishnan, and P. Isola. “Con￾trastive Multiview Coding”. In: ECCV. 2020.
[TL05] E. Todorov and W. Li. “A Generalized Iterative
LQG Method for Locally-optimal Feedback Control of
Constrained Nonlinear Stochastic Systems”. In: ACC.
2005, pp. 300–306.
[TL18a] S. J. Taylor and B. Letham. “Forecasting at
scale”. en. In: The American Statistician 72.1 (2018),
pp. 37–45.
[TL18b] G. Tucker and D. Lawson. “Doubly Reparam￾eterized Gradient Estimators for Monte Carlo Objec￾tives”. In: 1st Symposium on Advances in Approxi￾mate Bayesian Inference. 2018.
[TL19] M. Tan and Q. Le. “Efficientnet: Rethink￾ing model scaling for convolutional neural networks”.
In: International Conference on Machine Learning.
PMLR. 2019, pp. 6105–6114.
[TLG08] D. G. Tzikas, A. C. Likas, and N. P. Galat￾sanos. “The variational approximation for Bayesian
inference”. In: IEEE Signal Process. Mag. 25.6 (Nov.
2008), pp. 131–146.
[TLG14] M. Titsias and M. Lázaro-Gredilla. “Doubly
Stochastic Variational Bayes for non-Conjugate Infer￾ence”. In: ICML. 2014, pp. 1971–1979.
[TM15] D. Trafimow and M. Marks. “Editorial”. In: Ba￾sic Appl. Soc. Psych. 37.1 (2015), pp. 1–2.
[TMD12] A. Talhouk, K. Murphy, and A. Doucet. “Effi￾cient Bayesian Inference for Multivariate Probit Mod￾els with Sparse Inverse Correlation Matrices”. In: J.
Comp. Graph. Statist. 21.3 (2012), pp. 739–757.
[TMK04] G. Theocharous, K. Murphy, and L. Kael￾bling. “Representing hierarchical POMDPs as DBNs
for multi-scale robot localization”. In: ICRA. 2004.
[TN13] L. S. L. Tan and D. J. Nott. “Variational In￾ference for Generalized Linear Mixed Models Using
Partially Noncentered Parametrizations”. In: Stat. Sci.
(2013).
[TND21] M.-N. Tran, T.-N. Nguyen, and V.-H. Dao.
“A practical tutorial on Variational Bayes”. In: (2021).
arXiv: 2103.01327 [stat.CO].
[TOB16] L. Theis, A. van den Oord, and M. Bethge.
“A note on the evaluation of generative models”. In:
ICLR. 2016.
[Tol22] S. Toledo. “UltimateKalman: Flexible Kalman
Filtering and Smoothing Using Orthogonal Trans￾formations”. In: (July 2022). arXiv: 2207 . 13526
[math.NA].
[Tom+20] R. Tomsett, D. Harborne, S. Chakraborty,
P. Gurram, and A. Preece. “Sanity checks for saliency
metrics”. In: Proceedings of the AAAI conference on
artificial intelligence. Vol. 34. 04. 2020, pp. 6021–
6029.
[Tom22] J. M. Tomczak. Deep Generative Modeling.
en. 1st ed. Springer, 2022.
[Tou09] M. Toussaint. “Robot Rrajectory Optimiza￾tion using Approximate Inference”. In: ICML. 2009,
pp. 1049–1056.
[Tou14] M. Toussaint. Bandits, Global Optimization,
Active Learning, and Bayesian RL – understanding
the common ground. Autonomous Learning Summer
School. 2014.
[Tou+19] J Toubeau, J Bottieau, F Vallée, and Z De
Grève. “Deep Learning-Based Multivariate Probabilis￾tic Forecasting for Short-Term Scheduling in Power
Markets”. In: IEEE Trans. Power Syst. 34.2 (2019),
pp. 1203–1215.
[TOV18] C. Truong, L. Oudre, and N. Vayatis. “Selec￾tive review of offline change point detection methods”.
In: (2018). arXiv: 1801.00718 [cs.CE].
[TP97] S. Thrun and L. Pratt, eds. Learning to learn.
Kluwer, 1997.
[TPB00] N. Tishby, F. C. Pereira, and W. Bialek.
“The information bottleneck method”. In: ArXiv
physics/0004057 (2000).
[TPB99] N. Tishby, F. Pereira, and W. Biale. “The
Information Bottleneck method”. In: The 37th an￾nual Allerton Conf. on Communication, Control,
and Computing. 1999, pp. 368–377.
[TR19] M. K. Titsias and F. Ruiz. “Unbiased Im￾plicit Variational Inference”. In: AISTATS. Ed. by K.
Chaudhuri and M. Sugiyama. Vol. 89. Proceedings of
Machine Learning Research. PMLR, 2019, pp. 167–
176.
[TR97] J. Tsitsiklis and B. V. Roy. “An analysis of
temporal-difference learning with function approxima￾Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1312
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
tion”. In: IEEE Trans. on Automatic Control 42.5
(1997), pp. 674–690.
[Tra+19] D. Tran, K. Vafa, K. K. Agrawal, L. Dinh,
and B. Poole. “Discrete Flows: Invertible Generative
Models of Discrete Data”. In: Advances in Neural In￾formation Processing Systems. 2019.
[Tra+20a] L. Tran, B. S. Veeling, K. Roth, J.
Swiatkowski, J. V. Dillon, J. Snoek, S. Mandt, T.
Salimans, S. Nowozin, and R. Jenatton. “Hydra: Pre￾serving Ensemble Diversity for Model Distillation”. In:
(2020). arXiv: 2001.04694 [cs.LG].
[Tra+20b] M.-N. Tran, N Nguyen, D Nott, and R Kohn.
“Bayesian Deep Net GLM and GLMM”. In: J. Comput.
Graph. Stat. 29.1 (2020), pp. 97–113.
[TRB16] D. Tran, R. Ranganath, and D. M. Blei. “The
Variational Gaussian Process”. In: ICLR. 2016.
[Tri21] K. Triantafyllopoulos. Bayesian Inference of
State Space Models: Kalman Filtering and Beyond.
en. 1st ed. Springer, 2021.
[TS06] M. Toussaint and A. Storkey. “Probabilistic
inference for solving discrete and continuous state
Markov Decision Processes”. In: ICML. 2006, pp. 945–
952.
[Tsa+18] Y.-H. Tsai, W.-C. Hung, S. Schulter, K. Sohn,
M.-H. Yang, and M. Chandraker. “Learning to adapt
structured output space for semantic segmentation”.
In: Proceedings of the IEEE conference on computer
vision and pattern recognition. 2018, pp. 7472–7481.
[Tsa+19] Y.-H. H. Tsai, S. Bai, M. Yamada, L.-P.
Morency, and R. Salakhutdinov. “Transformer Dissec￾tion: An Unified Understanding for Transformer’s At￾tention via the Lens of Kernel”. In: EMNLP. Associ￾ation for Computational Linguistics, 2019, pp. 4344–
4353.
[Tsa+21] Y.-H. H. Tsai, S. Bai, L.-P. Morency, and R.
Salakhutdinov. “A Note on Connecting Barlow Twins
with Negative-Sample-Free Contrastive Learning”. In:
ArXiv abs/2104.13712 (2021).
[Tsa88] C. Tsallis. “Possible generalization of
Boltzmann-Gibbs statistics”. In: J. of Statistical
Physics 52 (1988), pp. 479–487.
[Tsc+14] S. Tschiatschek, R. Iyer, H. Wei, and J.
Bilmes. “Learning Mixtures of Submodular Functions
for Image Collection Summarization”. In: NIPS. Mon￾treal, Canada, 2014.
[Tsc+19] M. Tschannen, J. Djolonga, P. K. Ruben￾stein, S. Gelly, and M. Lucic. “On Mutual Information
Maximization for Representation Learning”. In: arXiv
preprint arXiv:1907.13625 (2019).
[Tsi+17] P. A. Tsividis, T. Pouncy, J. L. Xu, J. B.
Tenenbaum, and S. J. Gershman. “Human Learning in
Atari”. en. In: AAAI Spring Symposium Series. 2017.
[Tso+05] I. Tsochantaridis, T. Joachims, T. Hofmann,
and Y. Altun. “Large Margin Methods for Structured
and Interdependent Output Variables”. In: JMLR 6
(2005), pp. 1453–1484.
[TT13] E. G. Tabak and C. V. Turner. “A family of non￾parametric density estimation algorithms”. In: Com￾munications on Pure and Applied Mathematics 66.2
(2013), pp. 145–164.
[TT17] B. Trippe and R. Turner. “Overpruning in Vari￾ational Bayesian Neural Networks”. In: NIPS Work￾shop on Advances in Approximate Bayesian Infer￾ence. 2017.
[Tuc+19] G. Tucker, D. Lawson, B. Dai, and R. Ran￾ganath. “Revisiting auxiliary latent variables in gener￾ative models”. In: (2019).
[TUI17] T. Taketomi, H. Uchiyama, and S. Ikeda. “Vi￾sual SLAM algorithms: a survey from 2010 to 2016”.
en. In: IPSJ Transactions on Computer Vision and
Applications 9.1 (2017), p. 16.
[Tul+18] S. Tulyakov, M.-Y. Liu, X. Yang, and J.
Kautz. “Mocogan: Decomposing motion and content
for video generation”. In: Proceedings of the IEEE
conference on computer vision and pattern recogni￾tion. 2018, pp. 1526–1535.
[Tur+08] R. Turner, P. Berkes, M. Sahani, and D.
Mackay. Counterexamples to variational free energy
compactness folk theorems. Tech. rep. U. Cambridge,
2008.
[TVE10] E. G. Tabak and E. Vanden-Eijnden. “Den￾sity estimation by dual ascent of the log-likelihood”.
In: Communications in Mathematical Sciences 8.1
(2010), pp. 217–233.
[TW16] J. M. Tomczak and M. Welling. “Improv￾ing variational auto-encoders using Householder flow”.
In: NeurIPS Workshop on Bayesian Deep Learning
(2016).
[TX00] J. B. Tenenbaum and F. Xu. “Word learning as
Bayesian inference”. In: Proc. 22nd Annual Conf.of
the Cognitive Science Society. 2000.
[TZ02] Z. Tu and S. Zhu. “Image Segmentation by
Data-Driven Markov Chain Monte Carlo”. In: IEEE
PAMI 24.5 (2002), pp. 657–673.
[Tze+17] E. Tzeng, J. Hoffman, K. Saenko, and T. Dar￾rell. “Adversarial discriminative domain adaptation”.
In: Proceedings of the IEEE conference on computer
vision and pattern recognition. 2017, pp. 7167–7176.
[UAP22] A. Ulhaq, N. Akhtar, and G. Pogrebna. “Effi￾cient Diffusion Models for Vision: A Survey”. In: (Oct.
2022). arXiv: 2210.09292 [cs.CV].
[UCS17] S. Ubaru, J. Chen, and Y. Saad. “Fast Esti￾mation of tr(f(A)) via Stochastic Lanczos Quadra￾ture”. In: SIAM J. Matrix Anal. Appl. 38.4 (2017),
pp. 1075–1099.
[Ude+16] M. Udell, C. Horn, R. Zadeh, and S. Boyd.
“Generalized Low Rank Models”. In: Foundations and
Trends in Machine Learning 9.1 (2016), pp. 1–118.
[UHJ20] M. Uehara, J. Huang, and N. Jiang. “Minimax
Weight and Q-Function Learning for Off-Policy Eval￾uation”. In: ICML. 2020.
[UML13] B. Uria, I. Murray, and H. Larochelle.
“RNADE: The real-valued neural autoregressive
density-estimator”. In: NIPS. 2013.
[UML14] B. Uria, I. Murray, and H. Larochelle. “A
Deep and Tractable Density Estimator”. In: ICML.
2014.
[UN98] N. Ueda and R. Nakano. “Deterministic anneal￾ing EM algorithm”. In: Neural Networks 11 (1998),
pp. 271–282.
[UR16] B. Ustun and C. Rudin. “Supersparse linear in￾teger models for optimized medical scoring systems”.
In: Machine Learning 102.3 (2016), pp. 349–391.
[Uri+16] B. Uria, M.-A. Côté, K. Gregor, I. Murray,
and H. Larochelle. “Neural Autoregressive Distribu￾tion Estimation”. In: JMLR (2016).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[UTR14] B. Ustun, S. Tracà, and C. Rudin. Super￾sparse Linear Integer Models for Interpretable Clas￾sification. 2014. arXiv: 1306.6677 [stat.ML].
[Uur+17] V. Uurtio, J. M. Monteiro, J. Kandola, J.
Shawe-Taylor, D. Fernandez-Reyes, and J. Rousu. “A
Tutorial on Canonical Correlation Methods”. In: ACM
Computing Surveys (2017).
[UVL16] D. Ulyanov, A. Vedaldi, and V. Lempit￾sky. “Instance Normalization: The Missing Ingredient
for Fast Stylization”. In: (2016). arXiv: 1607 . 08022
[cs.CV].
[UVL18] D. Ulyanov, A. Vedaldi, and V. Lempitsky.
“Deep Image Prior”. In: CVPR. 2018.
[Vaa00] A. W. Van der Vaart. Asymptotic statistics.
Vol. 3. Cambridge university press, 2000.
[Val00] H. Valpola. “Bayesian Ensemble Learning for
Nonlinear Factor Analysis”. PhD thesis. Helsinki Uni￾versity of Technology, 2000.
[Van10] J. Vanhatalo. “Speeding up the inference in
Gaussian process models”. PhD thesis. Helsinki Univ.
Technology, 2010.
[Van14] J. VanderPlas. Frequentism and Bayesianism
III: Confidence, Credibility, and why Frequentism
and Science do not Mix. Blog post. 2014.
[van+18] H. van Hasselt, Y. Doron, F. Strub, M. Hes￾sel, N. Sonnerat, and J. Modayil. Deep Reinforcement
Learning and the Deadly Triad. arXiv:1812.02648.
2018.
[Vas+17a] A. B. Vasudevan, M. Gygli, A. Volokitin,
and L. Van Gool. “Query-adaptive video summariza￾tion via quality-aware relevance estimation”. In: Pro￾ceedings of the 25th ACM international conference
on Multimedia. 2017, pp. 582–590.
[Vas+17b] A. Vaswani, N. Shazeer, N. Parmar, J.
Uszkoreit, L. Jones, A. N. Gomez, Ł. Kaiser, and
I. Polosukhin. “Attention is all you need”. In: NIPS.
2017, pp. 5998–6008.
[Vas+17c] A. Vaswani, N. Shazeer, N. Parmar, J.
Uszkoreit, L. Jones, A. N. Gomez, L. Kaiser, and I.
Polosukhin. “Attention Is All You Need”. In: NIPS.
2017.
[Vaz+22] S. Vaze, K. Han, A. Vedaldi, and A. Zisser￾man. “Open-Set Recognition: A Good Closed-Set Clas￾sifier is All You Need”. In: ICLR. 2022.
[VBW15] S. S. Villar, J. Bowden, and J. Wason. “Multi￾armed Bandit Models for the Optimal Design of Clin￾ical Trials: Benefits and Challenges”. en. In: Stat. Sci.
30.2 (2015), pp. 199–215.
[VCB22] M. J. Vowels, N. C. Camgoz, and R. Bowden.
“D’ya Like DAGs? A Survey on Structure Learning
and Causal Discovery”. In: ACM Comput. Surv. 55.4
(Nov. 2022), pp. 1–36.
[VDMW03] R. Van Der Merwe and E. Wan. “Sigma￾Point Kalman Filters for probabilistic inference in dy￾namic state-space models”. In: Workshop on Advances
in ML. 2003.
[Ved+18] R. Vedantam, I. Fischer, J. Huang, and K.
Murphy. “Generative Models of Visually Grounded
Imagination”. In: ICLR. 2018.
[Veh+15] A. Vehtari, D. Simpson, A. Gelman, Y. Yao,
and J. Gabry. “Pareto Smoothed Importance Sam￾pling”. In: (July 2015). arXiv: 1507.02646 [stat.CO].
[Veh+19] A. Vehtari, A. Gelman, D. Simpson, B. Car￾penter, and P.-C. Bürkner. “Rank-normalization, fold￾ing, and localization: An improved Rb for assessing con￾vergence of MCMC”. In: (2019). arXiv: 1903 . 08008
[stat.CO].
[Vei+21] V. Veitch, A. D’Amour, S. Yadlowsky, and
J. Eisenstein. “Counterfactual Invariance to Spurious
Correlations: Why and How to Pass Stress Tests”. In:
Advances in Neural Information Processing Systems.
2021.
[Vel+17] P. Veličković, G. Cucurull, A. Casanova, A.
Romero, P. Lio, and Y. Bengio. “Graph attention net￾works”. In: arXiv preprint arXiv:1710.10903 (2017).
[Ver18] R. Vershynin. High-Dimensional Probability:
An Introduction with Applications in Data Science.
en. 1 edition. Cambridge University Press, 2018.
[Ver+19] A. Vergari, A. Molina, R. Peharz, Z. Ghahra￾mani, K. Kersting, and I. Valera. “Automatic Bayesian
Density Analysis”. In: AAAI. 2019.
[VF+80] B. C. Van Fraassen et al. The scientific im￾age. Oxford University Press, 1980.
[VGG17] A. Vehtari, A. Gelman, and J. Gabry. “Prac￾tical Bayesian model evaluation using leave-one-out
cross-validation and WAIC”. In: Stat. Comput. 27.5
(2017), pp. 1413–1432.
[VGS05] V. Vovk, A. Gammerman, and G. Shafer. Al￾gorithmic Learning in a Random World. en. Springer,
2005.
[VGS22] V. Vovk, A. Gammerman, and G. Shafer. Al￾gorithmic Learning in a Random World. en. Second.
Springer, 2022.
[Vid99] P. Vidoni. “Exponential Family State Space
Models Based on a Conjugate Latent Process”. In: J.
R. Stat. Soc. Series B Stat. Methodol. 61.1 (1999),
pp. 213–221.
[Vil08] C. Villani. Optimal Transport: Old and New.
Grundlehren der mathematischen Wissenschaften.
Springer Berlin Heidelberg, 2008.
[Vil+19] R. Villegas, A. Pathak, H. Kannan, D. Erhan,
Q. V. Le, and H. Lee. “High Fidelity Video Prediction
with Large Stochastic Recurrent Neural Networks”. In:
NIPS. 2019.
[Vin+08] P. Vincent, H. Larochelle, Y. Bengio, and
P.-A. Manzagol. “Extracting and composing robust
features with denoising autoencoders”. In: Proceed￾ings of the 25th international conference on Machine
learning. 2008, pp. 1096–1103.
[Vin+10a] P. Vincent, H. Larochelle, I. Lajoie, Y. Ben￾gio, and P.-A. Manzagol. “Stacked denoising autoen￾coders: Learning useful representations in a deep net￾work with a local denoising criterion”. In: Journal of
machine learning research 11.Dec (2010), pp. 3371–
3408.
[Vin+10b] M. Vinyals, J. Cerquides, J. Rodriguez￾Aguilar, and A. Farinelli. “Worst-case bounds on the
quality of max-product fixed-points”. In: NIPS. 2010.
[Vin11] P. Vincent. “A connection between score
matching and denoising autoencoders”. In: Neural
computation 23.7 (2011), pp. 1661–1674.
[Vir10] S. Virtanen. “Bayesian exponential family pro￾jections”. MA thesis. Aalto University, 2010.
[Vis+06] S. V. N. Vishwanathan, N. N. Schraudolph,
M. W. Schmidt, and K. P. Murphy. “Accelerated train￾ing of conditional random fields with stochastic gradi￾ent methods”. In: ICML. ACM Press, 2006.
[Vis+10] S. V. N. Vishwanathan, N. N. Schraudolph,
R. Kondor, and K. M. Borgward. “Graph Kernels”. In:
JMLR 11 (2010), pp. 1201–1242.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1314
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[Vit67] A. Viterbi. “Error bounds for convolutional
codes and an asymptotically optimal decoding algo￾rithm”. In: IEEE Trans. on Information Theory 13.2
(1967), pp. 260–269.
[VJV09] J. Vanhatalo, P. Jylänki, and A. Vehtari.
“Gaussian process regression with Student-t likeli￾hood”. In: NIPS. Vol. 22. 2009.
[VK20a] A. Vahdat and J. Kautz. “NVAE: A Deep Hi￾erarchical Variational Autoencoder”. In: NIPS. 2020.
[VK20b] A. Vahdat and J. Kautz. “Nvae: A deep hier￾archical variational autoencoder”. In: arXiv preprint
arXiv:2007.03898 (2020).
[VKK21] A. Vahdat, K. Kreis, and J. Kautz. “Score￾based Generative Modeling in Latent Space”. In: NIPS.
June 2021.
[VLT21] G. M. van de Ven, Z. Li, and A. S. Tolias.
“Class-Incremental Learning with Generative Classi￾fiers”. In: CVPR workshop on Continual Learning in
Computer Vision (CLVision). 2021.
[Vo+15] B.-N. Vo, M. Mallick, Y. Bar-Shalom, S.
Coraluppi, R. Osborne, R. Mahler, B. t Vo, and J.
Webster. Multitarget tracking. John Wiley and Sons,
2015.
[Von13] P. Vontobel. “The Bethe permanent of a non￾negative matrix”. In: IEEE Trans. Info. Theory 59.3
(2013).
[Vov13] V. Vovk. “Kernel Ridge Regression”. In: Em￾pirical Inference: Festschrift in Honor of Vladimir
N. Vapnik. Ed. by B. Schölkopf, Z. Luo, and V. Vovk.
Springer Berlin Heidelberg, 2013, pp. 105–116.
[VPV10] J. Vanhatalo, V. Pietilainen, and A. Vehtari.
“Approximate inference for disease mapping with
sparse Gaussian processes”. In: Statistics in Medicine
29.15 (2010), pp. 1580–1607.
[vR11] M. van der Laan and S. Rose. Targeted Learn￾ing: Causal Inference for Observational and Experi￾mental Data. Jan. 2011.
[VR18] S. Verma and J. Rubin. “Fairness Defini￾tions Explained”. In: 2018 IEEE/ACM International
Workshop on Software Fairness (FairWare). May
2018, pp. 1–7.
[VRF11] C. Varin, N. Reid, and D. Firth. “An overview
of composite likelihood methods”. In: Stat. Sin. 21.1
(2011), pp. 5–42.
[VS11] T. J. VanderWeele and I. Shpitser. “A new crite￾rion for confounder selection”. In: Biometrics (2011).
[VT18] G. M. van de Ven and A. S. Tolias. “Three sce￾narios for continual learning”. In: NeurIPS Continual
Learning workshop. 2018.
[VW21] J. de Vilmarest and O. Wintenberger. “Viking:
Variational Bayesian Variance Tracking”. In: (Apr.
2021). arXiv: 2104.10777 [cs.LG].
[Vyt+19] D. Vytiniotis, D. Belov, R. Wei, G. Plotkin,
and M. Abadi. “The differentiable curry”. In: NeurIPS
2019 Workshop Program Transformations. 2019.
[VZ20] V. Veitch and A. Zaveri. “Sense and Sensitivity
Analysis: Simple Post-Hoc Analysis of Bias Due to Un￾observed Confounding”. In: Advances in Neural Infor￾mation Processing Systems. Ed. by H. Larochelle, M.
Ranzato, R. Hadsell, M. F. Balcan, and H. Lin. Vol. 33.
Curran Associates, Inc., 2020, pp. 10999–11009.
[WA13] A. Wilson and R. Adams. “Gaussian process
kernels for pattern discovery and extrapolation”. In:
International conference on machine learning. 2013,
pp. 1067–1075.
[Wal+09] H. Wallach, I. Murray, R. Salakhutdinov, and
D. Mimno. “Evaluation Methods for Topic Models”. In:
ICML. 2009.
[Wal+20] M. Walmsley et al. “Galaxy Zoo: probabilis￾tic morphology through Bayesian CNNs and active
learning”. In: Monthly Notices Royal Astronomial So￾ciety 491.2 (2020), pp. 1554–1574.
[Wal47] A. Wald. “An Essentially Complete Class of
Admissible Decision Functions”. en. In: Ann. Math.
Stat. 18.4 (1947), pp. 549–555.
[Wan+16] Z. Wang, T. Schaul, M. Hessel, H. van Has￾selt, M. Lanctot, and N. de Freitas. “Dueling Network
Architectures for Deep Reinforcement Learning”. In:
ICML. 2016.
[Wan17] M. P. Wand. “Fast Approximate Inference
for Arbitrarily Large Semiparametric Regression Mod￾els via Message Passing”. In: JASA 112.517 (2017),
pp. 137–168.
[Wan+17a] T. Wang, C. Rudin, F. Doshi-Velez, Y. Liu,
E. Klampfl, and P. MacNeille. “A bayesian framework
for learning rule sets for interpretable classification”.
In: The Journal of Machine Learning Research 18.1
(2017), pp. 2357–2393.
[Wan+17b] X. Wang, T. Li, S. Sun, and J. M. Cor￾chado. “A Survey of Recent Advances in Particle Fil￾ters and Remaining Challenges for Multitarget Track￾ing”. en. In: Sensors 17.12 (2017).
[Wan+17c] Y. Wang et al. “Tacotron: Towards End-to￾End Speech Synthesis”. In: Interspeech. 2017.
[Wan+18] T.-C. Wang, M.-Y. Liu, J.-Y. Zhu, G. Liu,
A. Tao, J. Kautz, and B. Catanzaro. “Video-to-video
synthesis”. In: Proceedings of the 32nd International
Conference on Neural Information Processing Sys￾tems. 2018, pp. 1152–1164.
[Wan+19a] K. Wang, G. Pleiss, J. Gardner, S. Tyree,
K. Q. Weinberger, and A. G. Wilson. “Exact Gaussian
Processes on a Million Data Points”. In: NIPS. 2019,
pp. 14622–14632.
[Wan+19b] S. Wang, W. Bai, C. Lavania, and J.
Bilmes. “Fixing Mini-batch Sequences with Hierar￾chical Robust Partitioning”. In: Proceedings of the
Twenty-Second International Conference on Artifi￾cial Intelligence and Statistics. Ed. by K. Chaudhuri
and M. Sugiyama. Vol. 89. Proceedings of Machine
Learning Research. PMLR, 2019, pp. 3352–3361.
[Wan+19c] Y. Wang, A. Smola, D. C. Maddix, J.
Gasthaus, D. Foster, and T. Januschowski. “Deep Fac￾tors for Forecasting”. In: ICML. 2019.
[Wan+20a] D. Wang, E. Shelhamer, S. Liu, B. Ol￾shausen, and T. Darrell. “Tent: Fully Test-Time Adap￾tation by Entropy Minimization”. In: ICLR. 2020.
[Wan+20b] H. Wang, X. Wu, Z. Huang, and E. P. Xing.
“High-frequency component helps explain the general￾ization of convolutional neural networks”. In: Proceed￾ings of the IEEE/CVF Conference on Computer Vi￾sion and Pattern Recognition. 2020, pp. 8684–8694.
[Wan+20c] T. Wang, J.-Y. Zhu, A. Torralba, and A. A.
Efros. Dataset Distillation. 2020. arXiv: 1811 . 10959
[cs.LG].
[Wan+20d] Z. Wang, S. Cheng, L. Yueru, J. Zhu,
and B. Zhang. “A Wasserstein Minimum Velocity Ap￾proach to Learning Unnormalized Models”. In: Pro￾ceedings of the Twenty Third International Confer￾ence on Artificial Intelligence and Statistics. Ed. by
S. Chiappa and R. Calandra. Vol. 108. Proceedings of
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
Machine Learning Research. PMLR, 2020, pp. 3728–
3738.
[Wan+21] J. Wang, C. Lan, C. Liu, Y. Ouyang, W.
Zeng, and T. Qin. “Generalizing to Unseen Domains:
A Survey on Domain Generalization”. In: IJCAI. 2021.
[Wan+22] H. Wang, Y. Yang, D. Pati, and A.
Bhattacharya. “Structured Variational Inference in
Bayesian State-Space Models”. In: (2022).
[Wan+23] L. Wang, X. Zhang, H. Su, and J. Zhu. “A
Comprehensive Survey of Continual Learning: Theory,
Method and Application”. In: (Jan. 2023). arXiv: 2302.
00487 [cs.LG].
[Was04] L. Wasserman. All of statistics. A concise
course in statistical inference. Springer, 2004.
[Was06] L. Wasserman. All of Nonparametric Statis￾tics. Springer, 2006.
[Wat10] S. Watanabe. “Asymptotic Equivalence of
Bayes Cross Validation and Widely Applicable Infor￾mation Criterion in Singular Learning Theory”. In:
JMLR 11 (2010), pp. 3571–3594.
[Wat13] S. Watanabe. “A Widely Applicable Bayesian
Information Criterion”. In: JMLR 14 (2013), pp. 867–
897.
[Wat60] S. Watanabe. “Information theoretical analy￾sis of multivariate correlation”. In: IBM J. of Research
and Development 4 (1960), pp. 66–82.
[WB05] J. Winn and C. Bishop. “Variational Message
Passing”. In: JMLR 6 (2005), pp. 661–694.
[WB20] T. Wang and J. Ba. “Exploring Model-based
Planning with Policy Networks”. In: ICLR. 2020.
[WBC21] Y. Wang, D. M. Blei, and J. P. Cunning￾ham. “Posterior Collapse and Latent Variable Non￾identifiability”. In: NIPS. 2021.
[WC19] A. Wang and K. Cho. “BERT has a Mouth,
and It Must Speak: BERT as a Markov Random Field
Language Model”. In: Proc. Workshop on Methods for
Optimizing and Evaluating Neural Language Gener￾ation. Minneapolis, Minnesota: Association for Com￾putational Linguistics, June 2019, pp. 30–36.
[WCS08] M. Welling, C. Chemudugunta, and N. Sut￾ter. “Deterministic Latent Variable Models and their
Pitfalls”. In: ICDM. 2008.
[WD92] C. Watkins and P. Dayan. “Q-learning”. In:
Machine Learning 8.3 (1992), pp. 279–292.
[WDN15] A. G. Wilson, C. Dann, and H. Nickisch.
“Thoughts on Massively Scalable Gaussian Processes”.
In: arXiv preprint arXiv:1511.01870 (2015). https :
//arxiv.org/abs/1511.01870.
[Web+17] T. Weber et al. “Imagination-Augmented
Agents for Deep Reinforcement Learning”. In: NIPS.
2017.
[Wei00] Y. Weiss. “Correctness of local probability
propagation in graphical models with loops”. In: Neu￾ral Computation 12 (2000), pp. 1–41.
[Wei+13] K. Wei, Y. Liu, K. Kirchhoff, and J.
Bilmes. “Using Document Summarization Techniques
for Speech Data Subset Selection.” In: HLT-NAACL.
2013, pp. 721–726.
[Wei+14] K. Wei, Y. Liu, K. Kirchhoff, and J.
Bilmes. “Unsupervised Submodular Subset Selection
for Speech Data”. In: Proc. IEEE Intl. Conf. on
Acoustics, Speech, and Signal Processing. Florence,
Italy, 2014.
[Wei+15a] K. Wei, R. Iyer, S. Wang, W. Bai, and
J. Bilmes. “How to Intelligently Distribute Training
Data to Multiple Compute Nodes: Distributed Ma￾chine Learning via Submodular Partitioning”. In: Neu￾ral Information Processing Society (NeurIPS, for￾merly NIPS) Workshop. LearningSys Workshop, http:
//learningsys.org. Montreal, Canada, 2015.
[Wei+15b] K. Wei, R. Iyer, S. Wang, W. Bai, and
J. Bilmes. “Mixed Robust/Average Submodular Par￾titioning: Fast Algorithms, Guarantees, and Appli￾cations”. In: Neural Information Processing Society
(NeurIPS, formerly NIPS). Montreal, Canada, 2015.
[Wei+22] J. Wei et al. “Emergent Abilities of Large
Language Models”. In: TMLR (June 2022).
[Wel11] M. Welling. “Bayesian Learning via Stochastic
Gradient Langevin Dynamics”. In: ICML. 2011.
[Wen+17] R. Wen, K. Torkkola, B. Narayanaswamy,
and D. Madeka. “A Multi-Horizon Quantile Recurrent
Forecaster”. In: NIPS Time Series Workshop. 2017.
[Wen+19a] L. Wenliang, D. Sutherland, H. Strath￾mann, and A. Gretton. “Learning deep kernels for ex￾ponential family densities”. In: International Confer￾ence on Machine Learning. 2019, pp. 6737–6746.
[Wen+19b] F. Wenzel, T. Galy-Fajou, C. Donner, M.
Kloft, and M. Opper. “Efficient Gaussian Process Clas￾sification Using Polya-Gamma Data Augmentation”.
In: AAAI. 2019.
[Wen+20a] C. Wendler, A. Amrollahi, B. Seifert, A.
Krause, and M. Püschel. “Learning set functions that
are sparse in non-orthogonal Fourier bases”. In: arXiv
preprint arXiv:2010.00439 (2020).
[Wen+20b] F. Wenzel, K. Roth, B. S. Veeling, J.
Świątkowski, L. Tran, S. Mandt, J. Snoek, T. Sali￾mans, R. Jenatton, and S. Nowozin. “How Good is
the Bayes Posterior in Deep Neural Networks Really?”
In: ICML. 2020.
[Wen+20c] F. Wenzel, J. Snoek, D. Tran, and R. Jenat￾ton. “Hyperparameter Ensembles for Robustness and
Uncertainty Quantification”. In: NIPS. 2020.
[Wen21] L. Weng. “What are diffusion models?” In:
lilianweng.github.io/lil-log (2021).
[Wes03] M. West. “Bayesian Factor Regression Models
in the "Large p, Small n" Paradigm”. In: Bayesian
Statistics 7 (2003).
[Wes87] M. West. “On scale mixtures of normal distri￾butions”. In: Biometrika 74 (1987), pp. 646–648.
[WF01a] Y. Weiss and W. T. Freeman. “Correctness
of belief propagation in Gaussian graphical models
of arbitrary topology”. In: Neural Computation 13.10
(2001), pp. 2173–2200.
[WF01b] Y. Weiss and W. T. Freeman. “On the opti￾mality of solutions of the max-product belief propaga￾tion algorithm in arbitrary graphs”. In: IEEE Trans.
Information Theory, Special Issue on Codes on
Graphs and Iterative Algorithms 47.2 (2001), pp. 723–
735.
[WF14] Z. Wang and N. de Freitas. “Theoretical Analy￾sis of Bayesian Optimisation with Unknown Gaussian
Process Hyper-Parameters”. In: (2014). arXiv: 1406 .
7758 [stat.ML].
[WF16] Z. Wang and N. de Freitas. “Theoretical Analy￾sis of Bayesian Optimisation with Unknown Gaussian
Process Hyper-Parameters”. In: BayesOpt Workshop.
2016.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1316
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[WG17] P. White and S. Gorard. “Against Inferential
Statistics: How and Why Current Statistics Teaching
Gets It Wrong”. en. In: J. Educ. Behav. Stat. 16.1
(2017), pp. 55–65.
[WG18] M. Wu and N. Goodman. “Multimodal Genera￾tive Models for Scalable Weakly-Supervised Learning”.
In: NIPS. 2018.
[WGY21] G. Weiss, Y. Goldberg, and E. Yahav.
“Thinking Like Transformers”. In: ICML. 2021.
[WH02] M. Welling and G. E. Hinton. “A new learn￾ing algorithm for mean field Boltzmann machines”. In:
International Conference on Artificial Neural Net￾works. Springer. 2002, pp. 351–357.
[WH18] Y. Wu and K. He. “Group Normalization”. In:
ECCV. 2018.
[WH97] M. West and J. Harrison. Bayesian forecast￾ing and dynamic models. Springer, 1997.
[WHD18] J. T. Wilson, F. Hutter, and M. P. Deisen￾roth. “Maximizing acquisition functions for Bayesian
optimization”. In: NIPS. 2018.
[Whi16] T. White. “Sampling Generative Networks”.
In: arXiv (2016).
[Whi88] P Whittle. “Restless bandits: activity alloca￾tion in a changing world”. In: J. Appl. Probab. 25.A
(1988), pp. 287–298.
[WHT19] Y. Wang, H. He, and X. Tan. “Truly Proxi￾mal Policy Optimization”. In: UAI. 2019.
[WI20] A. G. Wilson and P. Izmailov. “Bayesian Deep
Learning and a Probabilistic Perspective of General￾ization”. In: NIPS. 2020.
[WIB15] K. Wei, R. Iyer, and J. Bilmes. “Submodular￾ity in Data Subset Selection and Active Learning”. In:
Proceedings of the 32nd international conference on
Machine learning. Lille, France, 2015.
[Wie+14] D Wierstra, T Schaul, J Peters, and J
Schmidhuber. “Natural Evolution Strategies”. In:
JMLR 15.1 (2014), pp. 949–980.
[Wik21] Wikipedia contributors. CliffsNotes —
Wikipedia, The Free Encyclopedia. [Online; accessed
29-December-2021]. 2021.
[Wil+14] A. G. Wilson, E. Gilboa, A. Nehorai, and J. P.
Cunningham. “Fast kernel learning for multidimen￾sional pattern extrapolation”. In: Advances in Neu￾ral Information Processing Systems. 2014, pp. 3626–
3634.
[Wil14] A. G. Wilson. “Covariance kernels for fast auto￾matic pattern discovery and extrapolation with Gaus￾sian processes”. PhD thesis. University of Cambridge,
2014.
[Wil+16] A. G. Wilson, Z. Hu, R. Salakhutdinov, and
E. P. Xing. “Deep Kernel Learning”. en. In: AISTATS.
2016, pp. 370–378.
[Wil+17] A. G. Wills, J. Hendriks, C. Renton, and B.
Ninness. “A Bayesian Filtering Algorithm for Gaus￾sian Mixture Models”. In: (2017). arXiv: 1705 . 05495
[stat.ML].
[Wil+20] H. Wilde, J. Jewson, S. Vollmer, and C.
Holmes. “Foundations of Bayesian Learning from Syn￾thetic Data”. In: (Nov. 2020). arXiv: 2011 . 08299
[cs.LG].
[Wil20] A. G. Wilson. “The Case for Bayesian Deep
Learning”. In: (2020). arXiv: 2001.10995 [cs.LG].
[Wil+20a] J. T. Wilson, V. Borovitskiy, A. Terenin, P.
Mostowsky, and M. P. Deisenroth. “Efficiently Sam￾pling Functions from Gaussian Process Posteriors”. In:
ICML. 2020.
[Wil+20b] A. B. Wiltschko, B. Sanchez-Lengeling, B.
Lee, E. Reif, J. Wei, K. J. McCloskey, L. Colwell,
W. Qian, and Y. Wang. “Evaluating Attribution for
Graph Neural Networks”. In: (2020).
[Wil69] A. G. Wilson. “The use of entropy maximising
models, in the theory of trip distribution, mode split
and route split”. In: Journal of transport economics
and policy (1969), pp. 108–126.
[Wil92] R. J. Williams. “Simple statistical gradient￾following algorithms for connectionist reinforcement
learning”. In: MLJ 8.3-4 (1992), pp. 229–256.
[Wil98] C. Williams. “Computation with infinite
networks”. In: Neural Computation 10.5 (1998),
pp. 1203–1216.
[Win] J. Winn. VIBES.
[Win+19] J. Winn, C. Bishop, T. Diethe, J. Guiver,
and Y. Zaykov. Model-based Machine Learning. 2019.
[WIP20] J. Watson, A. Imohiosen, and J. Peters. “Ac￾tive Inference or Control as Inference? A Unifying
View”. In: International Workshop on Active Infer￾ence. 2020.
[Wit] DEEPFAKES: PREPARE NOW (PERSPEC￾TIVES FROM BRAZIL). https://lab.witness.org/
brazil - deepfakes - prepare - now/. Accessed: 2021-08-
18.
[Wiy+19] R. R. Wiyatno, A. Xu, O. Dia, and A. de
Berker. “Adversarial Examples in Modern Machine
Learning: A Review”. In: (2019). arXiv: 1911 . 05268
[cs.LG].
[WJ08] M. J. Wainwright and M. I. Jordan. “Graphi￾cal models, exponential families, and variational infer￾ence”. In: Foundations and Trends in Machine Learn￾ing 1–2 (2008), pp. 1–305.
[WJ21] Y. Wang and M. I. Jordan. Desiderata for Rep￾resentation Learning: A Causal Perspective. 2021.
arXiv: 2109.03795 [stat.ML].
[WJW03] M. J. Wainwright, T. S. Jaakkola, and A. S.
Willsky. “Tree-based reparameterization framework
for analysis of sum-product and related algorithms”.
In: IEEE Trans. on Information Theory 49.5 (2003),
pp. 1120–1146.
[WK18] E. Wong and Z. Kolter. “Provable defenses
against adversarial examples via the convex outer ad￾versarial polytope”. In: International Conference on
Machine Learning. PMLR. 2018, pp. 5286–5295.
[WK96] G. Widmer and M. Kubat. “Learning in the
presence of concept drift and hidden contexts”. In:
Mach. Learn. 23.1 (1996), pp. 69–101.
[WKS21] V. Wild, M. Kanagawa, and D. Sejdinovic.
“Connections and Equivalences between the Nyström
Method and Sparse Variational Gaussian Processes”.
In: (2021). arXiv: 2106.01121 [stat.ML].
[WL14a] N. Whiteley and A. Lee. “Twisted particle fil￾ters”. en. In: Annals of Statistics 42.1 (Feb. 2014),
pp. 115–141.
[WL14b] J. L. Williams and R. A. Lau. “Approximate
evaluation of marginal association probabilities with
belief propagation”. In: IEEE Trans. Aerosp. Elec￾tron. Syst. 50.4 (2014).
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[WL19] A. Wehenkel and G. Louppe. “Unconstrained
Monotonic Neural Networks”. In: NIPS. 2019.
[WLL16] W. Wang, H. Lee, and K. Livescu. “Deep
Variational Canonical Correlation Analysis”. In: arXiv
(2016).
[WLZ19] D. Widmann, F. Lindsten, and D. Zachariah.
“Calibration tests in multi-class classification: A uni￾fying framework”. In: NIPS. Curran Associates, Inc.,
2019, pp. 12236–12246.
[WM12] K. Wakabayashi and T. Miura. “Forward￾Backward Activation Algorithm for Hierarchical Hid￾den Markov Models”. In: NIPS. 2012.
[WMR17] S. Wachter, B. Mittelstadt, and C. Rus￾sell. “Counterfactual explanations without opening
the black box: Automated decisions and the GDPR”.
In: Harv. JL & Tech. 31 (2017), p. 841.
[WMR18] S. Wachter, B. Mittelstadt, and C. Rus￾sell. Counterfactual Explanations without Opening
the Black Box: Automated Decisions and the GDPR.
2018. arXiv: 1711.00399 [cs.AI].
[WN01] E. A. Wan and A. T. Nelson. “Dual EKF Meth￾ods”. In: Kalman Filtering and Neural Networks. Ed.
by S. Haykin. Wiley, 2001.
[WN07] D. Wipf and S. Nagarajan. “A new view of au￾tomatic relevancy determination”. In: NIPS. 2007.
[WN10] D. Wipf and S. Nagarajan. “Iterative
Reweighted ℓ1 and ℓ2 Methods for Finding Sparse
Solutions”. In: J. of Selected Topics in Signal Pro￾cessing (Special Issue on Compressive Sensing) 4.2
(2010).
[WN15] A. G. Wilson and H. Nickisch. “Kernel Inter￾polation for Scalable Structured Gaussian Processes
(KISS-GP)”. In: ICML. ICML’15. JMLR.org, 2015,
pp. 1775–1784.
[WN18] C. K. I. Williams and C. Nash. “Autoencoders
and Probabilistic Inference with Missing Data: An Ex￾act Solution for The Factor Analysis Case”. In: (2018).
arXiv: 1801.03851 [cs.LG].
[WO12] M. Wiering and M. van Otterlo, eds. Rein￾forcement learning: State-of-the-art. Springer, 2012.
[Woł+21] M. Wołczyk, M. Zając, R. Pascanu, Ł. Ku￾ciński, and P. Miłoś. “Continual World: A Robotic
Benchmark For Continual Reinforcement Learning”.
In: NIPS. 2021.
[Wol76] P. Wolfe. “Finding the nearest point in a
polytope”. In: Mathematical Programming 11 (1976),
pp. 128–149.
[Wol92] D. Wolpert. “Stacked Generalization”. In: Neu￾ral Networks 5.2 (1992), pp. 241–259.
[Woo+09] F. Wood, C. Archambeau, J. Gasthaus, L.
James, and Y. W. Teh. “A Stochastic Memoizer for
Sequence Data”. In: ICML. 2009.
[Woo+19] B. Woodworth, S. Gunasekar, P. Savarese,
E. Moroshko, I. Golan, J. Lee, D. Soudry, and N. Sre￾bro. “Kernel and Rich Regimes in Overparametrized
Models”. In: (2019). arXiv: 1906.05827 [cs.LG].
[WP18] H. Wang and H. Poon. “Deep Probabilistic
Logic: A Unifying Framework for Indirect Supervi￾sion”. In: EMNLP. 2018.
[WP19] S. Wiegreffe and Y. Pinter. “Attention
is not not explanation”. In: arXiv preprint
arXiv:1908.04626 (2019).
[WR15] F. Wang and C. Rudin. “Falling Rule Lists”.
In: Proceedings of the Eighteenth International Con￾ference on Artificial Intelligence and Statistics. Ed.
by G. Lebanon and S. V. N. Vishwanathan. Vol. 38.
Proceedings of Machine Learning Research. San Diego,
California, USA: PMLR, 2015, pp. 1013–1022.
[WRN10] D. Wipf, B. Rao, and S. Nagarajan. “Latent
Variable Bayesian Models for Promoting Sparsity”. In:
IEEE Transactions on Information Theory (2010).
[WRZH04] M. Welling, M. Rosen-Zvi, and G. Hinton.
“Exponential family harmoniums with an application
to information retrieval”. In: NIPS-14. 2004.
[WS01] C. K. I. Williams and M. Seeger. “Using the
Nyström Method to Speed Up Kernel Machines”. In:
NIPS. Ed. by T. K. Leen, T. G. Dietterich, and V
Tresp. MIT Press, 2001, pp. 682–688.
[WS05] M. Welling and C. Sutton. “Learning in Markov
Random Fields with Contrastive Free Energies”. In:
Tenth International Workshop on Artificial Intelli￾gence and Statistics (AISTATS). 2005.
[WS93] D. Wolpert and C. Strauss. “What Bayes has
to say about the evidence procedure”. In: Proc. Work￾shop on Maximum Entropy and Bayesian methods.
1993.
[WSG21] C. Wang, S. Sun, and R. Grosse. “Beyond
Marginal Uncertainty: How Accurately can Bayesian
Regression Models Estimate Posterior Predictive Cor￾relations?” In: AISTATS. Ed. by A. Banerjee and K.
Fukumizu. Vol. 130. Proceedings of Machine Learning
Research. PMLR, 2021, pp. 2476–2484.
[WSL19] R. L. Wasserstein, A. L. Schirm, and N. A.
Lazar. “Moving to a World Beyond “p < 0.05””. In:
The American Statistician 73.sup1 (2019), pp. 1–19.
[WSN00] B. Williams, T. Santner, and W. Notz. “Se￾quential design of computer experiments to minimize
integrated response functions”. In: Statistica Sinica 10
(2000), pp. 1133–1152.
[WSS21] W. J. Wilkinson, S. Särkkä, and A. Solin.
“Bayes-Newton Methods for Approximate Bayesian In￾ference with PSD Guarantees”. In: (2021). arXiv: 2111.
01721 [stat.ML].
[WT01] M. Welling and Y.-W. Teh. “Belief Optimiza￾tion for Binary Networks: a Stable Alternative to
Loopy Belief Propagation”. In: UAI. 2001.
[WT19] R. Wen and K. Torkkola. “Deep Generative
Quantile-Copula Models for Probabilistic Forecasting”.
In: ICML. 2019.
[WT90] G. Wei and M. Tanner. “A Monte Carlo imple￾mentation of the EM algorithm and the poor man’s
data augmentation algorithms”. In: JASA 85.411
(1990), pp. 699–704.
[WTB20] Y. Wen, D. Tran, and J. Ba. “BatchEnsemble:
an Alternative Approach to Efficient Ensemble and
Lifelong Learning”. In: ICLR. 2020.
[WTN19] Y. Wu, G. Tucker, and O. Nachum. Be￾havior Regularized Offline Reinforcement Learning.
arXiv:1911.11361. 2019.
[Wu+06] Y Wu, D Hu, M Wu, and X Hu. “A Numerical￾Integration Perspective on Gaussian Filters”. In: IEEE
Trans. Signal Process. 54.8 (2006), pp. 2910–2921.
[Wu+17] Y. Wu, E. Mansimov, S. Liao, R. Grosse, and
J. Ba. “Scalable trust-region method for deep rein￾forcement learning using Kronecker-factored approx￾imation”. In: NIPS. 2017.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1318
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
[Wu+19a] A. Wu, S. Nowozin, E. Meeds, R. E. Turner,
J. M. Hernández-Lobato, and A. L. Gaunt. “Fixing
Variational Bayes: Deterministic Variational Inference
for Bayesian Neural Networks”. In: ICLR. 2019.
[Wu+19b] M. Wu, S. Parbhoo, M. Hughes, R. Kindle,
L. Celi, M. Zazzi, V. Roth, and F. Doshi-Velez. “Re￾gional tree regularization for interpretability in black
box models”. In: AAAI (2019).
[Wu+21] T. Wu, M. T. Ribeiro, J. Heer, and D. S.
Weld. “Polyjuice: Generating Counterfactuals for Ex￾plaining, Evaluating, and Improving Models”. In: Pro￾ceedings of the 59th Annual Meeting of the Associ￾ation for Computational Linguistics. Association for
Computational Linguistics, 2021.
[Wüt+16] M. Wüthrich, S. Trimpe, C. Garcia Ci￾fuentes, D. Kappler, and S. Schaal. “A new perspec￾tive and extension of the Gaussian Filter”. en. In: The
International Journal of Robotics Research 35.14
(2016), pp. 1731–1749.
[WW12] Y. Wu and D. P. Wipf. “Dual-Space Analysis
of the Sparse Linear Model”. In: NIPS. 2012.
[WY02] D. Wilkinson and S. Yeung. “Conditional sim￾ulation from highly structured Gaussian systems with
application to blocking-MCMC for the Bayesian anal￾ysis of very large linear models”. In: Statistics and
Computing 12 (2002), pp. 287–300.
[WZ19] J. Wei and K. Zou. “EDA: Easy Data Aug￾mentation Techniques for Boosting Performance on
Text Classification Tasks”. In: Proceedings of the
2019 Conference on Empirical Methods in Natu￾ral Language Processing and the 9th International
Joint Conference on Natural Language Processing
(EMNLP-IJCNLP). Hong Kong, China: Association
for Computational Linguistics, Nov. 2019, pp. 6382–
6388.
[WZR20] S. Wu, H. R. Zhang, and C. Ré. “Understand￾ing and Improving Information Transfer in Multi-Task
Learning”. In: International Conference on Learning
Representations. 2020.
[XC19] Z. Xia and A. Chakrabarti. “Training Image
Estimators without Image Ground-Truth”. In: NIPS.
2019.
[XD18] J. Xu and G. Durrett. “Spherical Latent Spaces
for Stable Variational Autoencoders”. In: EMNLP.
2018.
[Xia+21a] K. Xia, K.-Z. Lee, Y. Bengio, and E. Barein￾boim. “The Causal-Neural Connection: Expressive￾ness, Learnability, and Inference”. In: NIPS. July
2021.
[Xia+21b] K. Xiao, L. Engstrom, A. Ilyas, and A.
Madry. “Noise or Signal: The Role of Image Back￾grounds in Object Recognition”. In: ICLR. 2021.
[Xie+16] J. Xie, Y. Lu, S.-C. Zhu, and Y. N. Wu. “A
Theory of Generative ConvNet”. In: ICML. 2016.
[Xie+18] J. Xie, Y. Lu, R. Gao, and Y. N. Wu. “Co￾operative Learning of Energy-Based Model and La￾tent Variable Model via MCMC Teaching.” In: AAAI.
Vol. 1. 6. 2018, p. 7.
[Xie+22] S. M. Xie, A. Raghunathan, P. Liang, and T.
Ma. “An Explanation of In-context Learning as Im￾plicit Bayesian Inference”. In: ICLR. 2022.
[XJ96] L. Xu and M. I. Jordan. “On Convergence Prop￾erties of the EM Algorithm for Gaussian Mixtures”. In:
Neural Computation 8 (1996), pp. 129–151.
[XKV22] Z. Xiao, K. Kreis, and A. Vahdat. “Tackling
the Generative Learning Trilemma with Denoising Dif￾fusion GANs”. In: ICLR. 2022.
[Xu+15] J. Xu, L. Mukherjee, Y. Li, J. Warner, J. M.
Rehg, and V. Singh. “Gaze-enabled egocentric video
summarization via constrained submodular maximiza￾tion”. In: Proceedings of the IEEE conference on com￾puter vision and pattern recognition. 2015, pp. 2235–
2244.
[Xu18] J. Xu. “Distance-based Protein Folding Pow￾ered by Deep Learning”. In: (2018). arXiv: 1811.03481
[q-bio.BM].
[Yad+18] S. Yadlowsky, H. Namkoong, S. Basu, J.
Duchi, and L. Tian. “Bounds on the conditional and
average treatment effect with unobserved confounding
factors”. In: arXiv e-prints, arXiv:1808.09521 (Aug.
2018), arXiv:1808.09521. arXiv: 1808.09521 [stat.ME].
[Yad+21] S. Yadlowsky, S. Fleming, N. Shah, E. Brun￾skill, and S. Wager. Evaluating Treatment Prioriti￾zation Rules via Rank-Weighted Average Treatment
Effects. 2021. arXiv: 2111.07966 [stat.ME].
[Yan+17] S Yang, L Xie, X Chen, X Lou, X Zhu,
D Huang, and H Li. “Statistical parametric speech
synthesis using generative adversarial networks un￾der a multi-task learning framework”. In: IEEE Auto￾matic Speech Recognition and Understanding Work￾shop (ASRU). 2017, pp. 685–691.
[Yan19] G. Yang. “Scaling Limits of Wide Neural Net￾works with Weight Sharing: Gaussian Process Behav￾ior, Gradient Independence, and Neural Tangent Ker￾nel Derivation”. In: (2019). arXiv: 1902.04760 [cs.NE].
[Yan+21] J. Yang, K. Zhou, Y. Li, and Z. Liu. “Gener￾alized OOD Detection: A Survey”. In: (2021).
[Yan+22] L. Yang, Z. Zhang, Y. Song, S. Hong, R. Xu,
Y. Zhao, Y. Shao, W. Zhang, B. Cui, and M.-H. Yang.
“Diffusion Models: A Comprehensive Survey of Meth￾ods and Applications”. In: (Sept. 2022). arXiv: 2209.
00796 [cs.LG].
[Yan74] H Yanai. “Unification of various techniques of
multivariate analysis by means of generalized coeffi￾cient of determination (GCD)”. In: J. Behaviormet￾rics 1.1 (1974), pp. 45–54.
[Yan81] M. Yannakakis. “Computing the minimum fill￾in is NP-complete”. In: SIAM J. Alg. Discrete Meth￾ods 2 (1981), pp. 77–79.
[Yao+18a] Y. Yao, A. Vehtari, D. Simpson, and A.
Gelman. “Using Stacking to Average Bayesian Predic￾tive Distributions (with Discussion)”. en. In: Bayesian
Analysis 13.3 (2018), pp. 917–1007.
[Yao+18b] Y. Yao, A. Vehtari, D. Simpson, and A. Gel￾man. “Yes, but Did It Work?: Evaluating Variational
Inference”. In: ICML. Vol. 80. Proceedings of Machine
Learning Research. PMLR, 2018, pp. 5581–5590.
[YBM20] Y. Yang, R. Bamler, and S. Mandt. Improv￾ing Inference for Neural Image Compression. 2020.
arXiv: 2006.04240 [eess.IV].
[YBW15] F. Yang, S. Balakrishnan, and M. J. Wain￾wright. “Statistical and Computational Guarantees for
the Baum-Welch Algorithm”. In: (2015). arXiv: 1512.
08269 [stat.ML].
[Yed11] J. S. Yedidia. “Message-Passing Algorithms for
Inference and Optimization”. In: J. Stat. Phys. 145.4
(2011), pp. 860–890.
[Yeh+18] C.-K. Yeh, J. S. Kim, I. E. H. Yen, and P.
Ravikumar. Representer Point Selection for Explain￾ing Deep Neural Networks. 2018. arXiv: 1811.09720
[cs.LG].
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
[Yeh+19a] C.-K. Yeh, C.-Y. Hsieh, A. Suggala, D. I.
Inouye, and P. K. Ravikumar. “On the (in) fidelity
and sensitivity of explanations”. In: Advances in
Neural Information Processing Systems 32 (2019),
pp. 10967–10978.
[Yeh+19b] C.-K. Yeh, B. Kim, S. O. Arik, C.-L. Li, T.
Pfister, and P. Ravikumar. “On completeness-aware
concept-based explanations in deep neural networks”.
In: arXiv preprint arXiv:1910.07969 (2019).
[Yeu+17] S. Yeung, A. Kannan, Y. Dauphin, and L.
Fei-Fei. “Tackling Over-pruning in Variational Au￾toencoders”. In: ICML Workshop on “Principled Ap￾proaches to Deep Learning”. 2017.
[Yeu91a] R. W. Yeung. “A new outlook on Shannon’s
information measures”. In: IEEE Trans. Inf. Theory
37.3 (1991), pp. 466–474.
[Yeu91b] R. W. Yeung. “A new outlook on Shannon’s
information measures”. In: IEEE Trans. on Informa￾tion Theory 37 (1991), pp. 466–474.
[YFW00] J. Yedidia, W. T. Freeman, and Y. Weiss.
“Generalized Belief Propagation”. In: NIPS. 2000.
[YH21] G. Yang and E. J. Hu. “Feature Learning in
Infinite-Width Neural Networks”. In: ICML. 2021.
[Yin+19a] D. Yin, R. G. Lopes, J. Shlens, E. D. Cubuk,
and J. Gilmer. “A Fourier Perspective on Model Ro￾bustness in Computer Vision”. In: NIPS. 2019.
[Yin+19b] P. Yin, J. Lyu, S. Zhang, S. Osher, Y. Qi,
and J. Xin. “Understanding Straight-Through Estima￾tor in Training Activation Quantized Neural Nets”. In:
ICLR. 2019.
[Yin+19c] R. Ying, D. Bourgeois, J. You, M. Zit￾nik, and J. Leskovec. “Gnnexplainer: Generating ex￾planations for graph neural networks”. In: Advances
in neural information processing systems 32 (2019),
p. 9240.
[Yin+20] D. Yin, M. Farajtabar, A. Li, N. Levine,
and A. Mott. “Optimization and Generalization of
Regularization-Based Continual Learning: a Loss Ap￾proximation Viewpoint”. In: (2020). arXiv: 2006.10974
[cs.LG].
[YK06] A. Yuille and D. Kersten. “Vision as Bayesian
inference: analysis by synthesis?” en. In: Trends Cogn.
Sci. 10.7 (2006), pp. 301–308.
[YK19] M. Yang and B. Kim. Benchmarking Attribu￾tion Methods with Relative Feature Importance. 2019.
arXiv: 1907.09701 [cs.LG].
[YMT22] Y. Yang, S. Mandt, and L. Theis. “An In￾troduction to Neural Data Compression”. In: (2022).
arXiv: 2202.06533 [cs.LG].
[Yoo+18] K. Yoon, R. Liao, Y. Xiong, L. Zhang, E. Fe￾taya, R. Urtasun, R. Zemel, and X. Pitkow. “Inference
in Probabilistic Graphical Models by Graph Neural
Networks”. In: ICLR Workshop. 2018.
[You19] A. Young. “Consistency without inference: In￾strumental variables in practical application”. In:
(2019).
[You89] L. Younes. “Parameter estimation for imper￾fectly observed Gibbsian fields”. In: Probab. Theory
and Related Fields 82 (1989), pp. 625–645.
[You99] L. Younes. “On the convergence of Markovian
stochastic algorithms with rapidly decreasing ergodic￾ity rates”. In: Stochastics: An International Journal
of Probability and Stochastic Processes 65.3-4 (1999),
pp. 177–228.
[YS10] G. A. Young and R. L. Smith. Essentials of Sta￾tistical Inference. en. Illustrated edition. Cambridge
University Press, Mar. 2010.
[Yu+06] S. Yu, K. Yu, V. Tresp, K. H-P., and M. Wu.
“Supervised probabilistic principal component analy￾sis”. In: KDD. 2006.
[Yu10] S.-Z. Yu. “Hidden Semi-Markov Models”. In: Ar￾tificial Intelligence J. 174.2 (2010).
[Yu+16] F. X. X. Yu, A. T. Suresh, K. M. Choroman￾ski, D. N. Holtmann-Rice, and S. Kumar. “Orthogonal
Random Features”. In: NIPS. Curran Associates, Inc.,
2016, pp. 1975–1983.
[Yu+17] L. Yu, W. Zhang, J. Wang, and Y. Yu. “Seq￾gan: Sequence generative adversarial nets with policy
gradient”. In: Thirty-first AAAI conference on artifi￾cial intelligence. 2017.
[Yu+18] Y. Yu et al. “Dynamic Control Flow in Large￾Scale Machine Learning”. In: Proceedings of the Thir￾teenth EuroSys Conference. EuroSys ’18. Association
for Computing Machinery, 2018.
[Yu+20] L. Yu, Y. Song, J. Song, and S. Ermon. “Train￾ing Deep Energy-Based Models with f-Divergence
Minimization”. In: arXiv preprint arXiv:2003.03463
(2020).
[Yu+21] J. Yu, X. Li, J. Y. Koh, H. Zhang, R. Pang, J.
Qin, A. Ku, Y. Xu, J. Baldridge, and Y. Wu. “Vector￾quantized Image Modeling with Improved VQGAN”.
In: (2021). arXiv: 2110.04627 [cs.CV].
[Yu+22] J. Yu et al. “Scaling Autoregressive Models for
Content-Rich Text-to-Image Generation”. 2022.
[Yua+19] X. Yuan, P. He, Q. Zhu, and X. Li. “Ad￾versarial Examples: Attacks and Defenses for Deep
Learning”. en. In: IEEE Trans. Neural Networks and
Learning Systems 30.9 (2019), pp. 2805–2824.
[Yui01] A. Yuille. “CCCP algorithms to minimze the
Bethe and Kikuchi free energies: convergent alterna￾tives to belief propagation”. In: Neural Computation
14 (2001), pp. 1691–1722.
[YW04] C. Yanover and Y. Weiss. “Finding the M Most
Probable Configurations in Arbitrary Graphical Mod￾els”. In: NIPS. 2004.
[YWX17] J.-g. Yao, X. Wan, and J. Xiao. “Recent ad￾vances in document summarization”. In: Knowledge
and Information Systems 53.2 (2017), pp. 297–336.
[YZ19] G. Yaroslavtsev and S. Zhou. “Approximate
F2-Sketching of Valuation Functions”. In: Approxi￾mation, Randomization, and Combinatorial Opti￾mization. Algorithms and Techniques (APPROX-
/RANDOM 2019). Ed. by D. Achlioptas and
L. A. Végh. Vol. 145. Leibniz International Pro￾ceedings in Informatics (LIPIcs). Dagstuhl, Germany:
Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik,
2019, 69:1–69:21.
[YZ22] Y. Yang and P. Zhai. “Click-through rate pre￾diction in online advertising: A literature review”. In:
Inf. Process. Manag. 59.2 (2022), p. 102853.
[ZA12] J. Zou and R. Adams. “Priors for Diversity in
Generative Latent Variable Models”. In: NIPS. 2012.
[Zaf+22] M. Zaffran, A. Dieuleveut, O. Féron, Y.
Goude, and J. Josse. “Adaptive Conformal Predic￾tions for Time Series”. In: (2022). arXiv: 2202.07282
[stat.ML].
[Zai+20] S. Zaidi, A. Zela, T. Elsken, C. Holmes, F.
Hutter, and Y. W. Teh. “Neural Ensemble Search for
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1320
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
Performant and Calibrated Predictions”. In: (2020).
arXiv: 2006.08573 [cs.LG].
[Zan21] N. Zanichelli. IAML Distill Blog: Transform￾ers in Vision. 2021.
[ZB18] T. Zhou and J. Bilmes. “Minimax curriculum
learning: Machine teaching with desirable difficulties
and scheduled diversity”. In: International Confer￾ence on Learning Representations. 2018.
[ZB21] B. Zhao and H. Bilen. “Dataset Condensation
with Differentiable Siamese Augmentation”. In: Pro￾ceedings of the 38th International Conference on Ma￾chine Learning, ICML 2021, 18-24 July 2021, Vir￾tual Event. Ed. by M. Meila and T. Z. 0001. Vol. 139.
Proceedings of Machine Learning Research. PMLR,
2021, pp. 12674–12685.
[Zbo+21] J. Zbontar, L. Jing, I. Misra, Y. LeCun,
and S. Deny. “Barlow twins: Self-supervised learn￾ing via redundancy reduction”. In: arXiv preprint
arXiv:2103.03230 (2021).
[ZDK15] J. Zhang, J. Djolonga, and A. Krause.
“Higher-order inference for multi-class log￾supermodular models”. In: Proceedings of the IEEE
International Conference on Computer Vision. 2015,
pp. 1859–1867.
[ZE01a] B. Zadrozny and C. Elkan. “Obtaining cali￾brated probability estimaets from decision trees and
naive Bayesian classifiers”. In: ICML. 2001.
[ZE01b] B. Zadrozny and C. Elkan. “Transforming clas￾sifier scores into accurate multiclass probability esti￾mates”. In: KDD. 2001.
[Zec+18a] J. R. Zech, M. A. Badgeley, M. Liu, A. B.
Costa, J. J. Titano, and E. K. Oermann. “Variable
generalization performance of a deep learning model
to detect pneumonia in chest radiographs: A cross￾sectional study”. en. In: PLoS Med. 15.11 (Nov. 2018),
e1002683.
[Zec+18b] J. R. Zech, M. A. Badgeley, M. Liu, A. B.
Costa, J. J. Titano, and E. K. Oermann. “Variable gen￾eralization performance of a deep learning model to de￾tect pneumonia in chest radiographs: a cross-sectional
study”. In: PLoS medicine 15.11 (2018), e1002683.
[Zel76] A. Zellner. “Bayesian and non-Bayesian analy￾sis of the regression model with multivariate Student-t
error terms”. In: JASA 71.354 (1976), pp. 400–405.
[Zel86] A. Zellner. “On assessing prior distributions
and Bayesian regression analysis with g-prior distri￾butions”. In: Bayesian inference and decision tech￾niques, Studies of Bayesian and Econometrics and
Statistics volume 6. North Holland, 1986.
[Zen+18] C. Zeno, I. Golan, E. Hoffer, and D. Soudry.
“Task Agnostic Continual Learning Using Online
Variational Bayes”. In: (2018). arXiv: 1803 . 10123
[stat.ML].
[Zen+21] C. Zeno, I. Golan, E. Hoffer, and D. Soudry.
“Task-Agnostic Continual Learning Using Online Vari￾ational Bayes With Fixed-Point Updates”. en. In: Neu￾ral Comput. 33.11 (2021), pp. 3139–3177.
[Zer+19] J. Zerilli, A. Knott, J. Maclaurin, and C.
Gavaghan. “Transparency in algorithmic and human
decision-making: is there a double standard?” In: Phi￾losophy & Technology 32.4 (2019), pp. 661–683.
[ZF14] M. D. Zeiler and R. Fergus. “Visualizing and
understanding convolutional networks”. In: Euro￾pean conference on computer vision. Springer. 2014,
pp. 818–833.
[ZFV20] G. Zeni, M. Fontana, and S. Vantini. “Confor￾mal Prediction: a Unified Review of Theory and New
Challenges”. In: (2020). arXiv: 2005.07972 [cs.LG].
[ZG21] D. Zou and Q. Gu. “On the Convergence of
Hamiltonian Monte Carlo with Stochastic Gradients”.
In: ICML. Ed. by M. Meila and T. Zhang. Vol. 139.
Proceedings of Machine Learning Research. PMLR,
2021, pp. 13012–13022.
[ZGR21] L. Zhang, M. Goldstein, and R. Ranganath.
“Understanding Failures in Out-of-Distribution Detec￾tion with Deep Generative Models”. In: ICML. Ed.
by M. Meila and T. Zhang. Vol. 139. Proceedings of
Machine Learning Research. PMLR, 2021, pp. 12427–
12436.
[Zha+13a] K. Zhang, B. Schölkopf, K. Muandet, and
Z. Wang. “Domain Adaptation under Target and
Conditional Shift”. In: Proceedings of the 30th In￾ternational Conference on Machine Learning. 2013,
pp. 819–827.
[Zha+13b] K. Zhang, B. Scholkopf, K. Muandet, and
Z. Wang. “Domain Adaptation under Target and Con￾ditional Shift”. In: ICML. Vol. 28. 2013.
[Zha+16] S. Zhai, Y. Cheng, R. Feris, and Z. Zhang.
“Generative adversarial networks as variational train￾ing of energy based models”. In: arXiv preprint
arXiv:1611.01799 (2016).
[Zha+17] C. Zhang, S. Bengio, M. Hardt, B. Recht, and
O. Vinyals. “Understanding deep learning requires re￾thinking generalization”. In: ICLR. 2017.
[Zha+18] G. Zhang, S. Sun, D. Duvenaud, and R.
Grosse. “Noisy Natural Gradient as Variational Infer￾ence”. In: ICML. 2018.
[Zha+19a] X. Zhai, J. Puigcerver, A. Kolesnikov, P.
Ruyssen, C. Riquelme, M. Lucic, J. Djolonga, A. S.
Pinto, M. Neumann, A. Dosovitskiy, et al. “A large￾scale study of representation learning with the vi￾sual task adaptation benchmark”. In: arXiv preprint
arXiv:1910.04867 (2019).
[Zha+19b] C. Zhang, J. Butepage, H. Kjellstrom, and
S. Mandt. “Advances in Variational Inference”. In:
IEEE PAMI (2019), pp. 2008–2026.
[Zha+19c] H. Zhang, I. Goodfellow, D. Metaxas, and
A. Odena. “Self-attention generative adversarial net￾works”. In: International conference on machine
learning. PMLR. 2019, pp. 7354–7363.
[Zha+19d] L. Zhao, K. Korovina, W. Si, and. M. Che￾ung. “Approximate inference with Graph Neural Net￾works”. 2019.
[Zha+20a] A. Zhang, Z. Lipton, M. Li, and A. Smola.
Dive into deep learning. 2020.
[Zha+20b] H. Zhang, A. Li, J. Guo, and Y. Guo.
“Hybrid models for open set recognition”. In: Eu￾ropean Conference on Computer Vision. Springer.
2020, pp. 102–117.
[Zha+20c] R. Zhang, B. Dai, L. Li, and D. Schuurmans.
“GenDICE: Generalized Offline Estimation of Station￾ary Values”. In: ICLR. 2020.
[Zha+20d] R. Zhang, C. Li, J. Zhang, C. Chen, and
A. G. Wilson. “Cyclical stochastic gradient MCMC for
Bayesian deep learning”. In: ICLR. 2020.
[Zha+20e] X. Zhang, Y. Li, Z. Zhang, and Z.-L. Zhang.
“f-GAIL: Learning f-Divergence for Generative Ad￾versarial Imitation Learning”. In: Neural Information
Processing Systems (2020).
[Zha+20f] Y. Zhang, X. Chen, Y. Yang, A. Rama￾murthy, B. Li, Y. Qi, and L. Song. “Efficient Proba￾Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 20231
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
BIBLIOGRAPHY
bilistic Logic Reasoning with Graph Neural Networks”.
In: ICLR. 2020.
[Zha+21] X. Zhai, A. Kolesnikov, N. Houlsby, and
L. Beyer. “Scaling vision transformers”. In: arXiv
preprint arXiv:2106.04560 (2021).
[Zhe+15] S. Zheng, S. Jayasumana, B. Romera￾Paredes, V. Vineet, Z. Su, D. Du, C. Huang, and P.
Torr. “Conditional Random Fields as Recurrent Neu￾ral Networks”. In: ICCV. 2015.
[Zho+19a] S. Zhou, M. Gordon, R. Krishna, A. Nar￾comey, L. F. Fei-Fei, and M. Bernstein. “HYPE: A
Benchmark for Human eYe Perceptual Evaluation
of Generative Models”. In: NIPS. Curran Associates,
Inc., 2019, pp. 3444–3456.
[Zho+19b] S. Zhou, M. L. Gordon, R. Krishna, A. Nar￾comey, L. Fei-Fei, and M. S. Bernstein. “HYPE: a
benchmark for human eye perceptual evaluation of
generative models”. In: Proceedings of the 33rd In￾ternational Conference on Neural Information Pro￾cessing Systems. 2019, pp. 3449–3461.
[Zho20] G. Zhou. “Mixed Hamiltonian Monte Carlo for
Mixed Discrete and Continuous Variable”. In: (2020).
arXiv: 1909.04852 [stat.CO].
[ZHT06] H. Zou, T. Hastie, and R. Tibshirani. “Sparse
principal component analysis”. In: JCGS 15.2 (2006),
pp. 262–286.
[Zhu+17] J.-Y. Zhu, T. Park, P. Isola, and A. A. Efros.
“Unpaired Image-to-Image Translation using Cycle￾Consistent Adversarial Networks”. In: ICCV. 2017.
[Zhu+18] X. Zhu, A. Singla, S. Zilles, and A. N. Raf￾ferty. “An overview of machine teaching”. In: arXiv
preprint arXiv:1801.05927 (2018).
[Zhu+21] F. Zhuang, Z. Qi, K. Duan, D. Xi, Y. Zhu, H.
Zhu, H. Xiong, and Q. He. “A Comprehensive Survey
on Transfer Learning”. In: Proc. IEEE 109.1 (2021).
[Zie+08] B. D. Ziebart, A. L. Maas, J. A. Bagnell, and
A. K. Dey. “Maximum Entropy Inverse Reinforcement
Learning”. In: AAAI. 2008, pp. 1433–1438.
[ZIE16] R. Zhang, P. Isola, and A. A. Efros. “Colorful
image colorization”. In: European conference on com￾puter vision. Springer. 2016, pp. 649–666.
[ZIE17] R. Zhang, P. Isola, and A. A. Efros. “Split￾brain autoencoders: Unsupervised learning by cross￾channel prediction”. In: Proceedings of the IEEE Con￾ference on Computer Vision and Pattern Recogni￾tion. 2017, pp. 1058–1067.
[Zin+20] L. Zintgraf, K. Shiarlis, M. Igl, S. Schulze, Y.
Gal, K. Hofmann, and S. Whiteson. “VariBAD: A Very
Good Method for Bayes-Adaptive Deep RL via Meta￾Learning”. In: ICLR. 2020.
[Ziy+19] L. Ziyin, Z. Wang, P. P. Liang, R. Salakhut￾dinov, L.-P. Morency, and M. Ueda. “Deep gamblers:
Learning to abstain with portfolio theory”. In: NIPS.
June 2019.
[ZL21] A. Zhou and S. Levine. “Training on Test Data
with Bayesian Adaptation for Covariate Shift”. In:
NIPS. 2021.
[ZLF21] M. Zhang, S. Levine, and C. Finn. “MEMO:
Test Time Robustness via Adaptation and Augmenta￾tion”. In: (2021). arXiv: 2110.09506 [cs.LG].
[ZLG20] R. Zivan, O. Lev, and R. Galiki. “Beyond
Trees: Analysis and Convergence of Belief Propagation
in Graphs with Multiple Cycles”. In: AAAI. 2020.
[ZMB21] B. Zhao, K. R. Mopuri, and H. Bilen.
“Dataset Condensation with Gradient Matching”. In:
International Conference on Learning Representa￾tions. 2021.
[ZMG19] G. Zhang, J. Martens, and R. B. Grosse.
“Fast Convergence of Natural Gradient Descent for
Over-Parameterized Neural Networks”. In: NIPS.
2019, pp. 8082–8093.
[ZML16] J. J. Zhao, M. Mathieu, and Y. LeCun.
“Energy-based Generative Adversarial Network”. In:
(2016).
[Zoe07] O. Zoeter. “Bayesian generalized linear models
in a terabyte world”. In: Proc. 5th International Sym￾posium on image and Signal Processing and Analy￾sis. 2007.
[Zon+18] B. Zong, Q. Song, M. R. Min, W. Cheng, C.
Lumezanu, D. Cho, and H. Chen. “Deep Autoencoding
Gaussian Mixture Model for Unsupervised Anomaly
Detection”. In: ICLR. 2018.
[ZP00] G. Zweig and M. Padmanabhan. “Exact alpha￾beta computation in logarithmic space with applica￾tion to map word graph construction”. In: ICSLP.
2000.
[ZP96] N. Zhang and D. Poole. “Exploiting causal in￾dependence in Bayesian network inference”. In: JAIR
(1996), pp. 301–328.
[ZR19a] Z. Ziegler and A. Rush. “Latent Normalizing
Flows for Discrete Sequences”. In: Proceedings of the
36th International Conference on Machine Learning.
2019, pp. 7673–7682.
[ZR19b] Z. M. Ziegler and A. M. Rush. “Latent Normal￾izing Flows for Discrete Sequences”. In: ICML. 2019.
[ZSB19] Q. Zhao, D. S. Small, and B. B. Bhattacharya.
“Sensitivity analysis for inverse probability weighting
estimators via the percentile bootstrap”. In: Journal
of the Royal Statistical Society: Series B (Statistical
Methodology) 81.4 (2019), pp. 735–761. eprint: https:
//rss.onlinelibrary.wiley.com/doi/pdf/10.1111/rssb.
12327.
[ZSE19] S. Zhao, J. Song, and S. Ermon. “InfoVAE: In￾formation Maximizing Variational Autoencoders”. In:
AAAI. 2019.
[ZSH22] Z. Zhang, E. Strubell, and E. Hovy. “A Survey
of Active Learning for Natural Language Processing”.
In: EMNLP. Oct. 2022.
[ZW11] D Zoran and Y Weiss. “From learning models
of natural image patches to whole image restoration”.
In: ICCV. 2011.
[ZW12] D. Zoran and Y. Weiss. “Natural Images, Gaus￾sian Mixtures and Dead Leaves”. In: NIPS. 2012,
pp. 1736–1744.
[ZWM97] C. S. Zhu, N. Y. Wu, and D. Mumford. “Min￾imax Entropy Principle and Its Application to Texture
Modeling”. In: Neural Computation 9.8 (1997).
[ZY08] J.-H. Zhao and P. L. H. Yu. “Fast ML Estima￾tion for the Mixture of Factor Analyzers via an ECM
Algorithm”. In: IEEE. Trans. on Neural Networks
19.11 (2008).
[ZY21] Y. Zhang and Q. Yang. “A Survey on Multi￾Task Learning”. In: IEEE Trans. Knowl. Data Eng.
(2021).
[ZY97] Z. Zhang and R. W. Yeung. “A non-Shannon￾type conditional inequality of information quantities”.
In: IEEE Transactions on Information Theory 43.6
(1997), pp. 1982–1986.
[ZY98] Z. Zhang and R. W. Yeung. “On characteriza￾tion of entropy function via information inequalities”.
Author: Kevin P. Murphy. (C) MIT Press. CC-BY-NC-ND license1322
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
In: IEEE Transactions on Information Theory 44.4
(1998), pp. 1440–1452.
Draft of “Probabilistic Machine Learning: Advanced Topics”. April 1, 2023

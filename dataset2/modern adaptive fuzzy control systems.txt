Studies in Fuzziness and Soft Computing
Ardashir Mohammadzadeh · 
Mohammad Hosein Sabzalian · 
Chunwei Zhang · Oscar Castillo · 
Rathinasamy Sakthivel · 
Fayez F. M. El-Sousy
Modern 
Adaptive 
Fuzzy Control 
SystemsStudies in Fuzziness and Soft Computing 
Volume 421 
Series Editor 
Janusz Kacprzyk, Systems Research Institute, Polish Academy of Sciences, 
Warsaw, PolandThe series “Studies in Fuzziness and Soft Computing” contains publications on 
various topics in the area of soft computing, which include fuzzy sets, rough sets, 
neural networks, evolutionary computation, probabilistic and evidential reasoning, 
multi-valued logic, and related fields. The publications within “Studies in Fuzziness 
and Soft Computing” are primarily monographs and edited volumes. They cover 
significant recent developments in the field, both of a foundational and applicable 
character. An important feature of the series is its short publication time and 
world-wide distribution. This permits a rapid and broad dissemination of research 
results. 
Indexed by SCOPUS, DBLP, WTI Frankfurt eG, zbMATH, SCImago. 
All books published in the series are submitted for consideration in Web of Science.Ardashir Mohammadzadeh ·
Mohammad Hosein Sabzalian · Chunwei Zhang ·
Oscar Castillo · Rathinasamy Sakthivel ·
Fayez F. M. El-Sousy 
Modern Adaptive Fuzzy 
Control SystemsArdashir Mohammadzadeh 
Multidisciplinary Center for Infrastructure 
Engineering (MCIE) 
Shenyang University of Technology 
Shenyang, Liaoning, China 
Chunwei Zhang 
Multidisciplinary Center for Infrastructure 
Engineering (MCIE) 
Shenyang University of Technology 
Shenyang, Liaoning, China 
Rathinasamy Sakthivel 
Department of Applied Mathematics 
Bharathiar University 
Coimbatore, Tamil Nadu, India 
Mohammad Hosein Sabzalian 
LabREI—Smart Grid Laboratory 
Department of Systems and Energy 
FEEC—School of Electrical and Computer 
Engineering 
University of Campinas (UNICAMP) 
Campinas, Brazil 
Oscar Castillo 
Division of Graduate Studies 
Tijuana Institute of Technology 
Tijuana, Baja California, Mexico 
Fayez F. M. El-Sousy 
Department of Electrical Engineering 
College of Engineering 
Prince Sattam Bin Abdulaziz University 
Al Kharj, Saudi Arabia 
ISSN 1434-9922 ISSN 1860-0808 (electronic) 
Studies in Fuzziness and Soft Computing 
ISBN 978-3-031-17392-9 ISBN 978-3-031-17393-6 (eBook) 
https://doi.org/10.1007/978-3-031-17393-6 
© The Editor(s) (if applicable) and The Author(s), under exclusive license to Springer Nature 
Switzerland AG 2023 
This work is subject to copyright. All rights are solely and exclusively licensed by the Publisher, whether 
the whole or part of the material is concerned, specifically the rights of translation, reprinting, reuse 
of illustrations, recitation, broadcasting, reproduction on microfilms or in any other physical way, and 
transmission or information storage and retrieval, electronic adaptation, computer software, or by similar 
or dissimilar methodology now known or hereafter developed. 
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication 
does not imply, even in the absence of a specific statement, that such names are exempt from the relevant 
protective laws and regulations and therefore free for general use. 
The publisher, the authors, and the editors are safe to assume that the advice and information in this book 
are believed to be true and accurate at the date of publication. Neither the publisher nor the authors or 
the editors give a warranty, expressed or implied, with respect to the material contained herein or for any 
errors or omissions that may have been made. The publisher remains neutral with regard to jurisdictional 
claims in published maps and institutional affiliations. 
This Springer imprint is published by the registered company Springer Nature Switzerland AG 
The registered company address is: Gewerbestrasse 11, 6330 Cham, SwitzerlandPreface 
Fuzzy systems, especially type-2 neuro-fuzzy systems, are now used extensively 
in various engineering fields for different purposes. In plain language, this book 
aims to practically explain fuzzy systems and different methods of training and opti￾mizing these systems. For this purpose, type-2 neuro-fuzzy systems are first analyzed 
along with various methods of training and optimizing these systems through imple￾mentation in MATLAB. These systems are then employed to design adaptive fuzzy 
controllers. The author tries to present all well-known optimization methods clearly 
and code them in MATLAB. Furthermore, all materials are available at http://www. 
simref.org, which can be visited by aficionados for faster in-depth learning. All dear 
readers of this book are kindly asked to share their views about writing flaws and 
scientific problems with us via the above website so that we can refine the book in the 
next editions. In the end, we would like to thank Dr. Sahraneh Ghaemi, the esteemed 
associate professor at University of Tabriz, and Dr. Ali Ahmadian, the esteemed 
assistant professor of University of Bonab, who have helped us scientifically edit 
this book. 
Shenyang, China 
Campinas, Brazil 
Shenyang, China 
Tijuana, Mexico 
Coimbatore, India 
Al Kharj, Saudi Arabia 
Ardashir Mohammadzadeh 
Mohammad Hosein Sabzalian 
Chunwei Zhang 
Oscar Castillo 
Rathinasamy Sakthivel 
Fayez F. M. El-Sousy
vContents 
1 An Introduction to Fuzzy and Fuzzy Control Systems ............ 1 
1.1 Historical Background .................................... 1 
1.2 What is Adaptive Fuzzy Control? ........................... 2 
1.3 Why Adaptive Fuzzy Control? ............................. 2 
1.4 Problems in Adaptive Fuzzy Controller ...................... 3 
References .................................................... 3 
2 Classification of Adaptive Fuzzy Controllers ..................... 5 
2.1 Direct Adaptive Fuzzy Controller ........................... 5 
2.2 Indirect Adaptive Fuzzy Controller ......................... 5 
2.3 Integrating Adaptive Fuzzy Controller with Other 
Controllers .............................................. 6 
2.3.1 Integrating Direct and Indirect Adaptive 
Controllers ....................................... 6 
2.3.2 Integrating Hybrid Fuzzy Controller with Other 
Controllers to Compensate for Estimation Error ....... 6 
2.3.3 Integrating Hybrid Fuzzy Controller with Output 
Feedback Controller ............................... 6 
2.3.4 Integrating Adaptive Fuzzy Controller with H∞
Control .......................................... 7 
2.3.5 Integrating Adaptive Fuzzy Controller 
with Supervised Controller ......................... 7 
2.3.6 Integrating Adaptive Fuzzy Controller with Other 
Control Methods .................................. 7 
2.4 Different Classes of Nonlinear Systems ...................... 8 
2.4.1 Affine Nonlinear Systems .......................... 8 
2.4.2 Non-affine Nonlinear Systems ...................... 9 
2.4.3 Nonlinear Feedback Systems ....................... 9 
2.4.4 Nonlinear Pure-Feedback Systems .................. 10 
2.4.5 Nonlinear Single-Input–Single-Output 
and Multi-Input–Multi-Output Systems .............. 11
viiviii Contents
2.4.6 Nonlinear Output and State Feedback Systems ........ 11 
2.4.7 Discrete and Continuous Systems ................... 12 
2.5 Adaptation Mechanism in Fuzzy Systems .................... 12 
2.5.1 Setting Parameters ................................ 12 
2.5.2 Setting Structure and Parameter ..................... 13 
2.6 Conclusion .............................................. 13 
References .................................................... 14 
3 Type-2 Fuzzy Systems ......................................... 17 
3.1 Introduction ............................................. 17 
3.2 Singleton Fuzzy Systems .................................. 17 
3.3 Non-singleton Fuzzy Systems .............................. 19 
3.4 Features of Type-2 Fuzzy Systems .......................... 20 
3.5 Basic Operations in Type-2 Fuzzy .......................... 21 
3.6 Fuzzification ............................................ 22 
3.7 Rules ................................................... 22 
3.8 Logics .................................................. 23 
3.9 Type Reduction .......................................... 24 
3.10 Implementation in MATLAB .............................. 28 
3.11 Designing a General Type-2 Fuzzy System with an Example ... 36 
3.12 Interval Type-2 Fuzzy System .............................. 44 
3.13 Conclusion .............................................. 46 
References .................................................... 46 
4 Training Interval Type-2 Fuzzy Systems Based on Error 
Backpropagation .............................................. 49 
4.1 Introduction ............................................. 49 
4.2 Training Fuzzy Systems with Nie-Tan Type-Reduction ........ 49 
4.2.1 Implementation in MATLAB ....................... 51 
4.3 Fuzzy System with KM-EKM Type-Reduction ............... 51 
4.4 Training Type-2 Fuzzy System with Extended Kalman Filter ... 52 
4.5 Training Type-2 Fuzzy System Based on Genetic Algorithm .... 56 
4.5.1 Introduction ...................................... 56 
4.6 Calling Genetic Algorithm ................................. 59 
4.7 Jargons of GA Toolkit in MATLAB ......................... 62 
4.7.1 GA-Based Optimization of Neuro-Fuzzy System 
Parameters ....................................... 68 
4.8 Training Neural Networks Based on PSO .................... 71 
4.8.1 Introduction ...................................... 71 
4.9 Formulation of Algorithm ................................. 72 
4.10 Implementation in MATLAB .............................. 74 
4.11 Training Type-2 Fuzzy System Through Second-Order 
Algorithms .............................................. 79 
4.11.1 Introduction ...................................... 79 
4.11.2 Newton’s Method ................................. 79Contents ix
4.11.3 Levenberg–Marquardt Algorithm ................... 80 
4.11.4 Conjugate Gradient Method ........................ 80 
4.11.5 Implementation in MATLAB ....................... 81 
4.12 Conclusion .............................................. 81 
References .................................................... 93 
5 Baseline Indirect Adaptive Control ............................. 95 
5.1 Problem Specifications .................................... 95 
5.2 Designing Fuzzy Controller ................................ 95 
5.3 Designing Moderation Principle ............................ 97 
5.4 Application in Moderation of Inverted Pendulum ............. 99 
5.5 Conclusion .............................................. 101 
References .................................................... 102 
6 Type-2 Indirect Adaptive Control with Estimation Error 
Approximation ................................................ 103 
6.1 Introduction ............................................. 103 
6.2 Literature Review ........................................ 103 
6.3 Resistant Adaptive Fuzzy Control with Estimation Error 
Elimination .............................................. 104 
6.3.1 Problem Specifications ............................ 104 
6.3.2 Estimating Uncertainties ........................... 104 
6.3.3 Designing Controller .............................. 106 
6.3.4 Designing Controller .............................. 110 
6.3.5 Analysis of Stability and Inference of Adaptive 
Rules ........................................... 112 
6.3.6 Switching Mechanism ............................. 115 
6.3.7 Applications ..................................... 116 
6.4 Conclusion .............................................. 117 
References .................................................... 117 
7 Direct Adaptive Fuzzy Control ................................. 119 
7.1 Introduction ............................................. 119 
7.2 Literature Review ........................................ 119 
7.2.1 Adaptive Fuzzy Control with Fewer Limitations ....... 120 
7.2.2 Type-2 Fuzzy System ............................. 121 
7.2.3 Simulation ....................................... 129 
7.3 Conclusion .............................................. 130 
References .................................................... 132 
8 Direct Adaptive Fuzzy Control with a Self-regulated Structure .... 135 
8.1 Introduction ............................................. 135 
8.2 Literature Review ........................................ 135 
8.3 Description of the Self-regulated Structure Algorithm ......... 136 
8.4 Adaptation Rules in Self-regulated Adaptive Fuzzy 
Controller ............................................... 140 
8.5 Application in Inverted Pendulum Control ................... 142x Contents
8.6 Conclusion .............................................. 143 
References .................................................... 143 
9 State Limitation Through Supervised Control ................... 145 
9.1 Introduction ............................................. 145 
9.2 Supervised Control for Indirect Adaptive Fuzzy Control 
Systems ................................................. 145 
9.3 Supervised Control for Fuzzy Control Systems in General ...... 147 
9.4 Conclusion .............................................. 149 
References .................................................... 149 
10 Adaptive Sliding Fuzzy Control ................................ 151 
10.1 Introduction ............................................. 151 
10.2 Designing a Controller .................................... 151 
10.3 Simulation .............................................. 154 
10.4 Conclusion .............................................. 157Chapter 1 
An Introduction to Fuzzy and Fuzzy 
Control Systems 
1.1 Historical Background 
In the early 1990s, successful applications of the fuzzy logic increased in the auto￾mated control. For instance, developments were observed in washing machines, 
advanced cameras, automated transmission, and underground trains [1]. In fact, 
fuzzy logic controllers (FLCs) are used as a method of controlling complicated 
nonlinear systems that cannot be controlled easily through conventional methods. 
They need no system models but can use a competent person’s information regarding 
the system. Nevertheless, it is difficult to analyze the stability and resistance of this 
controller because there are no systematic design methods, a flaw which has limited 
the applications of FLCs. 
Moreover, there is a profound background to adaptive control with respect to 
the proof of stability, resistant design, and performance analysis [2]. In the 1960s, 
major breakthroughs were achieved in the theory of stability and control in adaptive 
controllers. In the middle 1980s, studies of adaptive control were mainly focused 
on the problem of resistance to the non-modeled dynamics and bounded distortions. 
With early achievements in the adaptive control of linear systems, developments 
to nonlinear systems gained in popularity from the late 1980s to the 199s. Hence, 
adaptive control presented powerful mathematical methods for analyzing stability 
and resistance of nonlinear control systems. 
Therefore, it appears logical to integrate fuzzy logic control and adaptive control 
in order to obtain a better control method, which is called the adaptive fuzzy control 
(AFC). This hybrid method can both employ human knowledge and analyze stability 
and resistance.
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
A. Mohammadzaheh et al., Modern Adaptive Fuzzy Control Systems, Studies in Fuzziness 
and Soft Computing 421, https://doi.org/10.1007/978-3-031-17393-6_1 
12 1 An Introduction to Fuzzy and Fuzzy Control Systems
1.2 What is Adaptive Fuzzy Control? 
Wang defined an adaptive fuzzy system through a training algorithm whose parame￾ters (and structure) would be regulated through numerical information. Accordingly, 
the neuro-fuzzy systems, in which fuzzy systems are integrated with neural networks, 
are also adaptive fuzzy systems. 
An adaptive fuzzy controller can be defined as a controller used in adaptive 
fuzzy systems through the adaptive control theory to develop training algorithms 
that guarantee the stability and performance of a closed-loop system. 
Lyapunov stability methods play a major role in designing and analyzing the 
stability of adaptive systems [2]. The stability of adaptive fuzzy systems can be 
monitored by analyzing the behavior of the candidate Lyopunov function. 
In brief, a controller is called an adaptive fuzzy controller if: 
• An adaptive fuzzy system is employed; 
• The Lyopunov stability technique is adopted to develop training algorithms that 
guarantee the stability of the closed-loop system. 
1.3 Why Adaptive Fuzzy Control? 
The advantages of adaptive fuzzy control include the advantages of both fuzzy 
controls and adaptive control: 
• Fuzzy control uses an expert operator’s information. In fact, an expert operator 
can describe the system behavior or presents the control knowledge regarding 
how to control the system. This information can easily be presented as if–then 
rules. 
• Fuzzy systems are good nonlinear general estimators. In the classic linear resis￾tant adaptive control, linear estimators are employed to estimate some unknown 
functions that are assumed to be linear. The linearity assumption of functions is 
rejected when fuzzy systems are used in adaptive control. Therefore, the adaptive 
fuzzy control represents a nonlinear resistant control scheme, in which the system 
does not have to be assumed linear in response to unknown parameters [3]. 
• Fuzzy control is easily interpretable, for it follows a control strategy through 
human knowledge, the principles of which are perceivable to unskilled people. 
The classic control theory uses complicated mathematical methods that are not 
interpretable. Hence, engineers prefer to use simply understandable methods in 
practical applications [3]. 
• Fuzzy control is easy to implement. Developing the ICs of VLSI type facilitated 
and accelerated the implementation of fuzzy controllers. 
• The necessary software and hardware for the implementation of fuzzy controllers 
are inexpensive [3].References 3
• Adaptive fuzzy control does not depend on the system model. Adaptive algorithms 
are used for the online configuration of parameters emerging in the controller 
section. Therefore, the mathematical model of the system is not required [1]. 
• Adaptive control guarantees stability and resistance, which are considered very 
important in the control theory. Stability means that the output of each bounded 
input remains bounded at any time, whereas resistance refers to the ability of a 
control system to keep the system stable while encountering the non-modeled 
dynamics and external distortions. The conventional fuzzy control fails to guar￾antee the stability and resistance of the control system. In adaptive control, the 
Lyopunov stability technique provides a mathematical framework for developing 
adaptive algorithms that guarantee stability and resistance. 
• Adaptive control presents a systematic control method. There are no standard 
methods for systematic design in conventional fuzzy control, and parameters are 
often configured through trial and error. 
1.4 Problems in Adaptive Fuzzy Controller 
According to the aforesaid advantages, an adaptive fuzzy controller is a suitable 
candidate for the control of nonlinear dynamic systems with uncertainty. Never￾theless, there are still some problems that limit the practical application of this 
controller. 
The most important problem is the fixed general structure of fuzzy controllers, 
which are usually determined through trial and error. Inadequate attempts have been 
made to develop adaptive fuzzy controllers with the self-regulated structure, and 
the main topics such as stability, computational efficiency, and implementation have 
not been analyzed completely. In particular, the stability of systems with variable 
structures has not been proven; hence, designing an adaptive fuzzy controller with a 
self-regulated structure can be really useful. 
The other problems include applicability to specific classes of nonlinear systems, 
exponential growth of rules with the increased number of membership functions, 
constraints imposed on design parameters that are hard to determine in practice, and 
complexity of controllers in nonlinear systems in the form of triangular membership 
functions. 
References 
1. L.-X. Wang, Adaptive fuzzy systems and control: design and stability anyalysis (Prentice-Hall: 
Englewood Cliffs, New Jersey, 1994) 
2. S.S. Ge, C.C. Hang, T.H. Lee, T. Zhang, Stable adaptive neural network control (Kluwer 
Academic Publishers, London, 2002) 
3. J.T. Spooner, M. Maggiore, R. Ordonez, K.M. Passino, Stable adaptive control and estimation 
for nonlinear systems: neural and fuzzy approximation techniques (Wiley, New York, 2002)Chapter 2 
Classification of Adaptive Fuzzy 
Controllers 
Since the early 1990s, adaptive fuzzy control has actively been under research. In fact, 
many researchers have analyzed this field, and many policies, methods, schemes, 
and practical applications of control have been published in books, journals, and 
conferences. Therefore, it is impossible to completely describe adaptive control in 
one seminar, and a brief description of the wide range of adaptive fuzzy control will 
be provided in this chapter. 
In the simplest case, adaptive fuzzy controllers are developed only through adap￾tive fuzzy systems that are generally divided into two classes: direct adaptive fuzzy 
controllers and indirect adaptive fuzzy controllers. 
2.1 Direct Adaptive Fuzzy Controller 
Direct adaptive fuzzy controllers use adaptive fuzzy systems as controllers [1]. The 
adaptive mechanism for regulating the parameters of an adaptive fuzzy system is 
designed to stabilize the controlled system and enhance the closed-loop system 
performance. Direct adaptive fuzzy controllers were analyzed in [1–3]. 
2.2 Indirect Adaptive Fuzzy Controller 
Unlike direct adaptive fuzzy controllers, indirect adaptive fuzzy controllers benefit 
from adaptive fuzzy systems for system modeling. In fact, a controller is based on 
the assumption that the fuzzy system describes the controlled system well [2–7].
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
A. Mohammadzaheh et al., Modern Adaptive Fuzzy Control Systems, Studies in Fuzziness 
and Soft Computing 421, https://doi.org/10.1007/978-3-031-17393-6_2 
56 2 Classification of Adaptive Fuzzy Controllers
2.3 Integrating Adaptive Fuzzy Controller with Other 
Controllers 
Direct and indirect adaptive fuzzy controllers are simple; however, they have some 
problems. Therefore, adaptive fuzzy controllers have been integrated with the other 
control methods in recent years. 
2.3.1 Integrating Direct and Indirect Adaptive Controllers 
The hybrid adaptive fuzzy control methods have been analyzed in [8–11]. The control 
output is a weighted hybrid of direct and indirect adaptive fuzzy controllers. This 
hybrid controller provides a framework for combining the system knowledge and 
the control knowledge. 
2.3.2 Integrating Hybrid Fuzzy Controller with Other 
Controllers to Compensate for Estimation Error 
In general, the estimation error emerges when nonlinear functions are estimated 
through fuzzy systems. The estimation error may adversely affect the stability and 
performance of adaptive fuzzy control systems. To solve this problem, previous 
controllers are integrated with the other controllers. In [12], a fuzzy sliding mode 
controller was designed by integrating the adaptive fuzzy controller with the sliding 
mode controller to compensate for the estimation error. In [13–18], an adaptive 
fuzzy controller was described along with a new control term designed through the 
estimation error boundary. This term is added to the control output to compensate 
for the estimation error; however, it is very difficult to determine the estimation error 
boundary in practice. Therefore, some of the adaptive mechanisms were introduced 
in the next step for the online estimation of these boundaries [19, 20]. 
2.3.3 Integrating Hybrid Fuzzy Controller with Output 
Feedback Controller 
In many applications, it is either very difficult or impossible to measure all states of 
the controlled system, a problem which can be solved by the output feedback control. 
The only variable that needs to be measured is the system output, and many adaptive 
fuzzy control methods have been designed on the basis of output feedback [14, 21].2.3 Integrating Adaptive Fuzzy Controller with Other Controllers 7
2.3.4 Integrating Adaptive Fuzzy Controller with H∞ Control 
External distortions play a major role in the practical applications of control by not 
only weakening the control performance but also causing instability. The optimal 
H∞ control is a technique used in the classic control theory to minimize the effects 
of external distortions. In [22–28], an adaptive fuzzy controller was integrated with 
the H∞ control technique to mitigate the effects of external distortions. 
2.3.5 Integrating Adaptive Fuzzy Controller with Supervised 
Controller 
Sometimes, an adaptive fuzzy controller may not be fast enough. In this case, the 
system state variables may exit the desirable range. This problem can be solved by 
adding the adaptive gain, which cannot be very large. At the same time, increasing 
the adaptive gain increases noise sensitivity and results in the output chattering of 
the controller. Therefore, some researchers integrated adaptive fuzzy control with a 
supervised controller to keep the states of the controlled system within a desirable 
range without needing a large adaptive gain [1, 11, 29, 30]. This supervised control 
also has another control term that is designed under the assumption that the upper 
and lower bounds of nonlinear functions are known. When the states move out of a 
desirable range, the supervised controller starts forcing the states to stay within the 
desirable range. 
2.3.6 Integrating Adaptive Fuzzy Controller with Other 
Control Methods 
An adaptive fuzzy control method was proposed in [10] where the controller’s output 
was a combination of direct adaptive fuzzy control, indirect adaptive fuzzy control, 
and another control term to compensate for the estimation error. The boundaries used 
in the control term of the variable structure are estimated online; hence, there is no 
need for the prior knowledge about boundaries. The integration of direct adaptive 
fuzzy control, indirect adaptive fuzzy control, and supervised control was described 
in [11]. The integration of adaptive fuzzy control with the control term of a vari￾able structure and the H∞ control was introduced in [15] to mitigate the effects of 
estimation error and external distortions as much as necessary. 
In general, adaptive fuzzy control is integrated with the other control methods to 
eliminate the flaws of direct adaptive fuzzy control and those of indirect adaptive 
fuzzy control. Nonetheless, they are more complicated in terms of stability analysis 
and implementation. Thus, for a particular application, a designer should decide what 
control technique is appropriate for integration with adaptive fuzzy control.8 2 Classification of Adaptive Fuzzy Controllers
2.4 Different Classes of Nonlinear Systems 
There are different classes of nonlinear systems in the nonlinear control theory. These 
classes have different characteristics; hence, they need various control methods. 
There are a few good techniques for a class of nonlinear systems. For instance, the 
feedback linearization techniques can be employed to control the nonlinear systems 
that can be linearized. The strict-feedback nonlinear systems can be controlled 
through back stepping design. In addition, feedback control can be adopted to control 
the nonlinear systems in which all state variables are not measurable. The results of 
nonlinear control compelled researchers to design the adaptive fuzzy control methods 
for this class of systems based on the existing techniques. 
The following subchapters analyze the nonlinear systems to which adaptive fuzzy 
control methods can be applied. 
2.4.1 Affine Nonlinear Systems 
Under certain conditions, the input–output solution for a class of nonlinear single– 
input–single–output (SISO) systems can be formulated as below:
 x˙i = xi+1 ,i = 1, ··· , n − 1 
x˙n = f (x) + g(x)u + d(t) (2.1) 
where x = [x1, x2,..., xn]
T ∈ Rn, u ∈ R, y ∈ R denote the state variables, the 
input, and the output, respectively. Moreover, f (x), g(x) refer to the unknown flat 
functions, whereas d(t) denotes the bounded external distortions when |d(t)| ≤ d0. 
The nonlinear systems that can be represented as this form are called the affine 
nonlinear systems, the input of which emerges as a line in equations. 
If f (x), g(x) are known, the feedback linearization technique can be employed 
to design controllers. The general structure of this technique is as follows: 
u = 1 
g(x)
[− f (x) + v] (2.2) 
where v is a new control variable which will be explained further in the next chapters. 
If f (x), g(x) are unknown, it is possible to use adaptive fuzzy control. 
In [1–5], the indirect adaptive fuzzy control methods were employed to describe 
affine nonlinear systems, and adaptive fuzzy systems ˆf (x|θ f ), gˆ(x|θ g) were utilized 
to estimate f (x), g(x). The Lyopunov stability analysis was adopted to obtain adap￾tive rules. In this method, cautionary aspects should be taken be taken into account to 
prevent singularity, i.e. when the controller approaches infinity as gˆ(x|θ g) becomes 
zero. For instance, Wang [1] proposed an algorithm to regulate θ g and solve this 
problem.2.4 Different Classes of Nonlinear Systems 9
In [22, 23, 30], direct adaptive fuzzy control methods were proposed for affine 
indirect systems by using only one adaptive fuzzy system uˆ(x, v|θ ) to estimate the 
control rule u = 1 
g(x)[− f (x) + v]. The direct adaptive fuzzy control methods can 
completely solve the singularity problem in the indirect state, which might occur as 
the denominator becomes zero in the control rule. However, further constraints must 
be imposed on the control gain g(x) than the indirect methods. 
2.4.2 Non-affine Nonlinear Systems 
Another extensive class of nonlinear systems includes non-affine nonlinear systems 
in which the input does not emerge as the affine form. In fact, the SISO non-affine 
nonlinear system is defined as below: 
⎧
⎨
⎩
x˙i = xi+1 ,i = 1, ··· , n − 1 
x˙n = f (x, u)
y = x1 
(2.3) 
where x = [x1, x2,..., xn]
T ∈ Rn, u ∈ R, y ∈ R denote the state variables, the 
input, and the output, respectively. Moreover, f (x, u) is a flat unknown function; 
therefore, it is fair to state that affine nonlinear systems are classified as a specific 
category of non-affine nonlinear systems. 
In recent years, researchers have proposed different adaptive fuzzy control 
methods for controlling non-affine nonlinear systems [31, 32]. Since the input does 
not emerge as linear, the feedback linearization technique is not executable. It is very 
difficult and challenging to perform adaptive fuzzy control on non-affine nonlinear 
systems. In general, advanced mathematical techniques should be used. 
2.4.3 Nonlinear Feedback Systems 
Many of the practical nonlinear systems can be defined as a state space called the 
strict-feedback form: 
⎧
⎨
⎩
x˙i = fi (xi ) + gi (xi )xi+1 ,
x˙n = fn(x n) + gn(x n)u 
y = x1 
1 ≤ i ≤ n − 1 
n ≥ 2 (2.4) 
where x = [x1, x2,..., xn]
T ∈ Rn, u ∈ R, y ∈ R denote the state variables, the 
input, and the output, respectively. Furthermore, fi (·), gi (·) i = 1 ... n are the flat 
unknown functions. The purpose is to design the control input in a way that the output 
can approximate to the reference input as much as possible.10 2 Classification of Adaptive Fuzzy Controllers
In the recent decade, the back stepping method has been known as an important 
technique for designing feedback systems because it guarantees general stability, 
traceability, and responsible performance for an extensive class of feedback systems 
with unknown parameters [33]. The main idea of back stepping design is to select 
some of the state variables as the virtual input of control for the subsystems with 
lower dimensions than those of the general system. In fact, each step of the back 
stepping design is a virtual control design based on the control terms obtained from 
the previous steps. A heuristic feedback design of the actual control input is obtained 
from the final Lyopunov function when the design process ends, and the general 
system stability is proven [34]. In [34], the idea of back stepping was used with 
adaptive fuzzy control to control a multi–input–multi–output (MIMO) industrial 
system. Distortion was also taken into account, and stability was analyzed well 
through the Lyopunov method. The proposed controller is a resistant method. 
However, the classic back stepping control is mainly based on the assumption 
that the unknown functions fi (xi ), gi (xi )should be linear in relation to the unknown 
parameters. This assumption can be eliminated through fuzzy systems and adaptive 
neural networks. 
Adaptive neural back stepping control was analyzed in [34, 35]. Neural networks 
were employed in each step to estimate unknown functions, although a main problem 
with the adaptive neural back stepping control method is the increasing complexity. 
In fact, the complexity of controllers increased dramatically as the number of states 
(n) increased. 
The drastic increase in complexity is due to the need to estimate the derivatives 
of nonlinear functions [36]. In each step, partial derivatives should be calculated and 
used as the neural network inputs for this purpose. After each step, the number of 
partial derivatives increases greatly, and so does the complexity of the controller. 
To solve this problem, a dynamic control technique was proposed in [36] by 
introducing a first-order filter to avoid estimating the derivatives of nonlinear 
functions. 
Recently, adaptive intelligence control was also developed for discrete systems. 
In [37], a feedback-state adaptive neural control scheme was proposed through the 
idea of back stepping, whereas MIMO systems were considered in [38, 39]. 
2.4.4 Nonlinear Pure-Feedback Systems 
These systems are defined as below: 
⎧
⎨
⎩
x˙i = fi (xi , xi+1), i = 1,..., n − 1 
x˙n = fn(x n, u)
y = x1 
(2.5)2.4 Different Classes of Nonlinear Systems 11
where x = [x1, x2,..., xn]
T ∈ Rn, u ∈ R, y ∈ R denote the state variables, the 
input, and the output, respectively. Moreover, fi (xi , xi+1) i = 1 ... n refers to the 
flat unknown functions. The literature on the control of such systems is scant [40]. 
In [40], the adaptive neural control of these systems was proposed by integrating 
back stepping with the input–state stability analysis and the small gain theory. 
However, this method is prone to the increased complexity. In [41], adaptive neural 
control was described through the Nussbaum-gain functions and the idea of back 
stepping. The disadvantage of this method is long responsiveness. 
2.4.5 Nonlinear Single-Input–Single-Output 
and Multi-Input–Multi-Output Systems 
Using the results from nonlinear SISO systems, researchers developed adaptive intel￾ligent control to nonlinear MIMO systems with uncertainty. In general, it is more 
difficult to control nonlinear MIMO systems with uncertainty because of dealing 
with the input matrix and transactions between subsystems. 
In [42], an adaptive fuzzy controller was proposed for a class of nonlinear systems 
including affine subsystems under the assumption that the inputs were not interlinked 
and that the internal connections of the system were known. In [43–47], adaptive 
neuro-fuzzy control was proposed for a class of nonlinear systems in which the 
constraints were lifted from their internal connections. Nevertheless, the number of 
inputs must be equal to the number of outputs, and the inputs must be in the affine 
format. In other words, they must emerge as linear. 
In [48, 49], adaptive neural controllers were proposed for a specific class of 
nonlinear robotic MIMO systems which proper features. In [50], adaptive fuzzy 
control was introduced for two classes of nonlinear MIMO block-triangular systems 
with uncertainty in which input constraints were interlinked to properly remove the 
internal connections. 
Most of the relevant studies assumed that the inputs would emerge as affine. The 
control of nonlinear MIMO systems with uncertainty and non-affine inputs is still an 
open-ended problem. 
2.4.6 Nonlinear Output and State Feedback Systems 
The state feedback control is used for the systems in which all state variables are 
assumed to be measurable. In practice, it is sometimes very difficult or impossible to 
measure some states. The output feedback control is applied to the systems in which 
it is only necessary to measure the output. 
For nonlinear SISO systems, the adaptive fuzzy output feedback control was 
proposed in [37, 51] by estimating the necessary output derivatives with high-gain12 2 Classification of Adaptive Fuzzy Controllers
observers. Due to the use of high-gain observers, the phenomenon of mutation might 
be detected in the transient solution. To solve this problem, the saturation methods 
were introduced in [52, 53]. Linear observers were used in [54, 55] to estimate 
error dynamics. In [32], a nonlinear observer was introduced by using the prior 
input–output as the neural network input instead of the system output derivatives. 
The adaptive intelligent output feedback control was also considered for more 
extensive classes of nonlinear systems. The MIMO systems were also used in 
[39, 56, 57]. 
2.4.7 Discrete and Continuous Systems 
Since most of the controllers are implemented on digital computers, control plays a 
key role in a discrete space. The adaptive intelligent control of discrete time systems 
has interested many researchers. Due to the problems with these systems such as non￾causality in back stepping design, the discrete time methods have been less popular 
than the continuous time methods [39]. 
In the SISO discrete time systems, adaptive intelligent control describes a class of 
affine nonlinear systems for discrete time [58, 59]. In [60], output and state feedback 
controllers were analyzed for a class of discrete time nonlinear systems with a general 
relative degree and bounded distortion. Back stepping design was analyzed in [61] 
for discrete time systems of the appropriate format. 
Regarding MIMO discrete time systems, adaptive neural control was analyzed 
in [62]. Moreover, the state feedback neural control method was analyzed in [38] 
for a class of MIMO discrete time nonlinear systems. This paper analyzed output 
feedback control in a similar system with a similar controller only through inputs 
and outputs. 
2.5 Adaptation Mechanism in Fuzzy Systems 
2.5.1 Setting Parameters 
In adaptive intelligent control, smart systems (e.g., neural networks, fuzzy systems, 
and adaptive fuzzy systems) are employed to estimate some unknown functions. The 
parameters of smart systems should be adjusted online to guarantee stability. 
In a smart system, there are usually two types of parameters: linear and nonlinear. 
For instance, the consequent parameters of a fuzzy system are linear, whereas the 
parameters of input membership functions (centers and variance) are nonlinear. In 
a neural network, the middle layer weights are nonlinear, whereas the output layer 
parameters are linear.2.6 Conclusion 13
Most of the studies on the applications of smart systems have focused on the 
settings of linear parameters, and there are few studies on the settings of nonlinear 
parameters. In [33], adaptive control was described through multilayer neural 
networks to train the middle layer weights. Adaptive fuzzy control was described in 
[63–65] in addition to setting the parameters of membership functions. 
The linear parameters of smart systems can easily be set and analyzed; however, 
dimension explosion is a potential problem. In other words, the number of adjustable 
parameters will increase exponentially as the input dimension enlarges. There are 
fewer nonlinear parameters, although they are harder to set. Not only are they set 
slowly, but they are also more difficult to analyze. Hence, given the specific applica￾tion and the necessary accuracy, it is necessary to determine whether to train nonlinear 
parameters. 
2.5.2 Setting Structure and Parameter 
Most of the systems used in adaptive control have fixed structures. There are also 
fixed quantities of membership functions in fuzzy systems and neurons in neuron 
networks. It is important select the right structure, which affects the estimation of a 
smart system. It is difficult to select the right structure for a specific application. In 
fact, a designer should test several structures to find the right one. 
A few attempts have been made to develop smart systems with self-regulating 
structures. Park described adaptive fuzzy control with a self-regulating structure in 
[66, 67] by adding rules based on the input. In [45], adaptive neuro-fuzzy control 
was introduced with a self-regulating structure to add or delete rules. Neural control 
with a self-regulated structure was analyzed in [38] under the conditions in which 
the middle layer neurons were divided into two sections. 
Nevertheless, these methods face certain limitations. For instance, the stability 
analysis was applied only to a fixed structure. No studies addressed the effects of 
structure change on stability. No algorithms were proposed in [66–68] to limit the 
dimensions of smart systems. 
Therefore, if the initial conditions are not appropriate, the dimensions of smart 
systems will exceed the implementation capability. 
Gao employed the error reduction ratio technique in [45] to decrease or increase the 
rules. Adaptive intelligent control with a self-regulating structure is an open-ended 
research avenue. 
2.6 Conclusion 
This chapter classified nonlinear systems in terms of dynamic equation structure and 
described the applications of fuzzy systems in their control briefly to prove dear 
readers with a general insight into the research literature.14 2 Classification of Adaptive Fuzzy Controllers
References 
1. L.-X. Wang, Adaptive fuzzy systems and control: design and stability anyalysis (Prentice-Hall: 
Englewood Cliffs, New Jersey, 1994) 
2. J.T. Spooner, K.M. Passino, Stable adaptive control using fuzzy system and neural networks. 
IEEE Trans. Fuzzy Syst. 4, 339–359 (1996) 
3. K. Fischle, D. Schroder, An improved stable adaptive fuzzy control method. IEEE Trans. Fuzzy 
Syst. 7, 27–40 (1999) 
4. C.G. Moore, C.J. Harris, Indirect adaptive fuzzy control. Int. J. Control 56, 441–468 (1992) 
5. Y.W. Cho, C.W. Park, M. Park, An indirect model reference adaptive fuzzy control for SISO 
Takagi-Sugeno model. Fuzzy Sets Syst. 131, 197–215 (2002) 
6. C.W. Park, Y.W. Cho, T-S model based indirect adaptive fuzzy control using online parameter 
estimation. IEEE Trans. Syst. Man Cybern. Part B-Cybern. 34, 2293–2302 (2004) 
7. C.W. Park, M. Park, Adaptive parameter estimator based on T-S fuzzymodels and its 
applications to indirect adaptive fuzzy control design. Inf. Sci. 159, 125–139 (2004) 
8. L.X. Wang, Combining mathematical model and heuristics into controllers: an adaptive fuzzy 
control approach. Fuzzy Sets Syst. 89, 151–156 (1997) 
9. M. Hojati, S. Gazor, Hybrid adaptive fuzzy identification and control of nonlinear systems. 
IEEE Trans. Fuzzy Syst. 10, 198–210 (2002) 
10. M.J. Er, S.H. Chin, Hybrid adaptive fuzzy controllers of robot manipulators with bounds 
estimation. IEEE Trans. Ind. Electron. 47, 1151–1160 (2000) 
11. C.H. Wang, T.C. Lin, T.T. Lee, H.L. Liu, Adaptive hybrid intelligent control for uncertain 
nonlinear dynamical systems. IEEE Trans. Syst. Man Cybern. Part B-Cybern. 32, 583–597 
(2002) 
12. S.C. Tong, T.Y. Chai, Fuzzy indirect adaptive control for a class of decentralized nonlinear 
systems. Int. J. Syst. Sci. 29, 149–157 (1998) 
13. B. Yoo, W. Ham, Adaptive fuzzy sliding mode control of nonlinear system. IEEE Trans. Fuzzy 
Syst. 6, 315–321 (1998) 
14. S.C. Tong, T. Wang, J.T. Tang, Fuzzy adaptive output tracking control of nonlinear systems. 
Fuzzy Sets Syst. 111, 169–182 (2000) 
15. Y.C. Chang, Adaptive fuzzy-based tracking control for nonlinear SISOsystems via VSS and 
H-infinity approaches. IEEE Trans. Fuzzy Syst. 9, 278–292 (2001) 
16. Y.X. Diao, K.M. Passino, Stable fault-tolerant adaptive fuzzy/neuralcontrol for a turbine engine. 
IEEE Trans. Control Syst. Technol. 9, 494–509 (2001) 
17. C.L. Hwang, C.Y. Kuo, A stable adaptive fuzzy sliding-mode control foraffine nonlinear 
systems with application to four-bar linkage systems. IEEE Trans. Fuzzy Syst. 9, 238–252 
(2001) 
18. W.Y. Wang, Y.G. Leu, C.C. Hsu, Robust adaptive fuzzy-neural control of nonlinear dynamical 
systems using generalized projection update law and variable structure controller. IEEE Trans. 
Syst. Man Cybern. Part B-Cybern. 31, 140–147 (2001) 
19. J.H. Park, S.J. Seo, G.T. Park, Robust adaptive fuzzy controller for nonlinear system using 
estimation of bounds for approximation errors. Fuzzy Sets Syst. 133, 19–36 (2003) 
20. C.M. Lin, C.F. Hsu, Adaptive fuzzy sliding-mode control for induction servomotor systems. 
IEEE Trans. Energy Convers. 19, 362–368 (2004) 
21. Y.G. Leu, T.T. Lee, W.Y. Wang, Observer-based adaptive fuzzy-neural control for unknown 
nonlinear dynamical systems. IEEE Trans. Syst. Man Cybern. Part B-Cybern. 29, 583–591 
(1999) 
22. Rubaai, Direct adaptive fuzzy control design achieving H-infinity trackingfor high performance 
servo drives. IEEE Trans. Energy Convers. 14, pp. 1199–1208 (1999) 
23. T.Y. Chai, S.C. Tong, Fuzzy direct adaptive control for a class of nonlinear systems. Fuzzy Sets 
Syst. 103, 379–387 (1999) 
24. B.S. Chen, C.S. Wu, Y.W. Jan, Adaptive fuzzy mixed H-2/H-infinity, attitude control of 
spacecraft. IEEE Trans. Aerosp. Electron. Syst. 36, 1343–1359 (2000)References 15
25. W.Y. Wang, M.L. Chan, T.T. Lee, C.H. Liu, Adaptive fuzzy control for strict-feedback canonical 
nonlinear systems with H-infinity tracking performance. IEEE Trans. Syst. Man Cybern. Part 
B Cybern. 30, 878–885 (2000) 
26. S.C. Tong, H.X. Li, Direct adaptive fuzzy output tracking control of nonlinear systems. Fuzzy 
Sets Syst. 128, 107–115 (2002) 
27. W.Y. Wang, M.L. Chan, C.C.J. Hsu, T.T. Lee, H-infinity tracking based sliding mode control 
for uncertain nonlinear systems via an adaptive fuzzy-neural approach. IEEE Trans. Syst. Man 
Cybern. Part B-Cybern. 32, 483–492 (2002) 
28. S.C. Tong, H.X. Li, G.R. Chen, Adaptive fuzzy decentralized control for a class of large-scale 
nonlinear systems. IEEE Trans. Syst. Man Cybern. Part B-Cybern. 34, 770–775 (2004) 
29. D.L. Tsay, H.Y. Chung, C.J. Lee, The adaptive control of nonlinear systems using the Sugeno￾type of fuzzy logic. IEEE Trans. Fuzzy Syst. 7, 225–229 (1999) 
30. C.H. Wang, H.L. Liu, T.C. Lin, Direct adaptive fuzzy-neural control with state observer and 
supervisory controller for unknown nonlinear dynamical systems. IEEE Trans. Fuzzy Syst. 10, 
39–49 (2002) 
31. J.H. Park, G.T. Park, Robust adaptive fuzzy controller for non-affine nonlinear systems with 
dynamic rule activation. Int. J. Robust Nonlinear Control 13, 117–139 (2003) 
32. J. Calise, N. Hovakimyan, M. Idan, Adaptive output feedback control of nonlinear systems 
using neural networks. Automatica 37, 1201–1211 (2001) 
33. S.S. Ge, C.C. Hang, T.H. Lee, T. Zhang, Stable adaptive neural network control (Kluwer 
Academic Publishers, London, 2002) 
34. Y.H. Li, S. Qiang, X.Y. Zhuang, O. Kaynak, Robust and adaptive back stepping control for 
nonlinear systems using RBF neural networks. IEEE Trans. Neural Net. 15, 693–701 (2004) 
35. T. Zhang, S.S. Ge, C.C. Hang, Adaptive neural network control for strict-feedback nonlinear 
systems using back stepping design. Automatica 36, 1835–1846 (2000) 
36. D. Wang, J. Huang, Neural network-based adaptive dynamic surface control for a class of 
uncertain nonlinear systems in strict-feedback form. IEEE Trans. Neural Netw. 16, 195–202 
(2005) 
37. S.S. Ge, C.C. Hang, T. Zhang, Adaptive neural network control of nonlinear systems by state 
and output feedback. IEEE Trans. Syst. Man Cybern. Part B-Cybern. 29, 818–828 (1999) 
38. S.S. Ge, J. Zhang, T.H. Lee, Adaptive neural network control for a class of MIMO nonlinear 
systems with disturbances in discrete-time. IEEE Trans. Syst. Man Cybern. Part B-Cybern. 34, 
1630–1645 (2004) 
39. J. Zhang, S.S. Ge, T.H. Lee, Output feedback control of a class of discrete MIMO nonlinear 
systems with triangular form inputs. IEEE Trans. Neural Netw. 16, 1491–1503 (2005) 
40. C. Wang, D.J. Hill, S.S. Ge, G.R. Chen, An ISS-modular approach for adaptive neural control 
of pure-feedback systems. Automatica 42, 723–731 (2006) 
41. H.B. Du, H.H. Shao, P.J. Yao, Adaptive neural network control for a class of low-triangular￾structured nonlinear systems. IEEE Trans. Neural Netw. 17, 509–514 (2006) 
42. T.P. Zhang, Stable direct adaptive fuzzy control for a class of MIMO nonlinear systems. Int. J. 
Syst. Sci. 34, 375–388 (2003) 
43. R. Ordonez, K.M. Passino, Stable multi-input multi-output adaptive fuzzy neural control. IEEE 
Trans. Fuzzy Syst. 7, 345–353 (1999) 
44. N. Golea, A. Golea, K. Benmahammed, Fuzzy model reference adaptive control. IEEE Trans. 
Fuzzy Syst. 10, 436–444 (2002) 
45. Y. Gao, M.J. Er, Online adaptive fuzzy neural identification and control of a class of MIMO 
nonlinear systems. IEEE Trans. Fuzzy Syst. 11, 462–477 (2003) 
46. H.X. Li, S.C. Tong, A hybrid adaptive fuzzy control for a class of nonlinear MIMO systems. 
IEEE Trans. Fuzzy Syst. 11, 24–34 (2003) 
47. S.C. Tong, H.X. Li, Fuzzy adaptive sliding-mode control for MIMO nonlinear systems. IEEE 
Trans. Fuzzy Syst. 11, 354–360 (2003) 
48. F.L. Lewis, S. Jagannathan, A. Yeesildirek, Neural Network Control of Robot Manipulators 
and Nonlinear Systems (Taylor & Francis, London, 1999)16 2 Classification of Adaptive Fuzzy Controllers
49. S.S. Ge, T.H. Lee, C.J. Harris, Adaptive Neural Network Control oRobotic Manipulators (World 
Scientific, London, 1998) 
50. S.S. Ge, C. Wang, Adaptive neural control of uncertain MIMO nonlinear systems. IEEE Trans. 
Neural Netw. 15, 674–692 (2004) 
51. S. Seshagiri, H.K. Khalil, Output feedback control of nonlinear systems using RBF neural 
networks. IEEE Trans. Neural Netw. 11, 69–79 (2000) 
52. F. Esfandiari, H.K. Khalil, Output feedback stabilization of fully linearizable system. Int. J. 
Control 56, (1992) 
53. M. Jankovic, Adaptive output feedback control of nonlinear feedback linearizable system. Int. 
J. Control 10, 1–18 (1996) 
54. N. Hovakimyan, F. Nardi, A.J. Calise, A novel error observer-based adaptive output feedback 
approach for control of uncertain systems. IEEE Trans. Autom. Control 47, 1310–1314 (2002) 
55. Y.G. Leu, W.Y. Wang, T.T. Lee, Observer-based direct adaptive fuzzy-neural control for 
nonaffine nonlinear systems. IEEE Trans. Neural Netw. 16, 853–861 (2005) 
56. N. Hovakimyan, A.J. Calise, N. Kim, Adaptive output feedback control of a class of multi-input 
multi-output systems using neural networks. Int. J. Control 77, 1318–1329 (2004) 
57. Y.C. Chang, H.M. Yen, Adaptive output feedback tracking control for a class of uncertain 
nonlinear systems using neural networks. IEEE Trans. Syst. Man Cybern. Part B-Cybern. 35, 
1311–1316 (2005) 
58. S. Jagannathan, M.W. Vandegrift, F.L. Lewis, Adaptive fuzzy logic control of discrete-time 
dynamical systems. Automatica 36, 229–241 (2000) 
59. H.N. Nounou, K.M. Passino, Stable auto-tuning of adaptive fuzzy/Neural controllers for 
nonlinear discrete-time systems. IEEE Trans. Fuzzy Syst. 12, 70–83 (2004) 
60. S.S. Ge, T.H. Lee, G.Y. Li, J. Zhang, Adaptive NN control for a class of discrete-time non-linear 
systems. Int. J. Control 76, 334–354 (2003) 
61. S.S. Ge, G.Y. Li, T.H. Lee, Adaptive NN control for a class of strict feedback discrete-time 
nonlinear systems. Automatica 39, 807–819 (2003) 
62. S.S. Ge, G.Y. Li, J. Zhang, T.H. Lee, Direct adaptive control for a class of MIMO nonlinear 
systems using neural networks. IEEE Trans. Autom. Control 49, 2001–2006 (2004) 
63. J.T. Spooner, M. Maggiore, R. Ordonez, K.M. Passino, Stable Adaptive Control and Estimation 
for Nonlinear Systems: Neural and Fuzzy Approximation Techniques (Wiley, New York, 2002) 
64. M. Alata, C.Y. Su, K. Demirli, Adaptive control of a class of nonlinear systems with a first-order 
parameterized Sugeno fuzzy approximator. IEEE Trans. Syst. Man Cybern. Part C-Appl. Rev. 
31, 410–419 (2001) 
65. H. Han, C.-Y. Su, Y. Stepanenko, Adaptive control of a class of nonlinear systems with 
nonlinearly parameterized fuzzy approximators. IEEE Trans. Fuzzy Syst. 9, 315–323 (2001) 
66. J.H. Park, G.T. Park, S.H. Kim, C.J. Moon, Direct adaptive self structuring fuzzy controller for 
nonaffine nonlinear system. Fuzzy Sets Syst. 153, 429–445 (2005) 
67. J.H. Park, G.T. Park, S.H. Kim, C.J. Moon, Output-feedback control of uncertain nonlinear 
systems using a self-structuring adaptive fuzzy observer. Fuzzy Sets Syst. 151, 21–42 (2005) 
68. J.H. Park, S.H. Huh, S.H. Kim, S.J. Seo, G.T. Park, Direct adaptive controller for nonaffine 
nonlinear systems using self-structuring neural networks. IEEE Trans. Neural Netw. 16, 414– 
422 (2005)Chapter 3 
Type-2 Fuzzy Systems 
3.1 Introduction 
The fuzzy logic is a successful method for modeling uncertainty, vagueness, and 
imprecision [1]. Since the introduction of the fuzzy logic, great breakthroughs have 
been made in the application of fuzzy systems over more than four decades. Although 
the type-1 fuzzy systems have been used widely in practical applications, many 
researchers have started studying type-2 fuzzy systems in recent years. Based on 
the type of input fuzzification, the fuzzy systems are divided into singleton and 
non-singleton classes. 
3.2 Singleton Fuzzy Systems 
The type-1 singleton fuzzy system was the first type of fuzzy systems proposed. In 
these systems, type-1 membership functions are used in antecedent and consequent 
sections, and the inputs have crisp values. 
There are different sources of uncertainty which fuzzy systems handle in practical 
applications and real-world environments. Some of these sources of uncertainty are 
as follows [2]: 
• Uncertainty in inputs due to noise and conditions of observers and sensors 
• Uncertainty caused by changes in the conditions of operation controllers 
• Use of noise data for training parameters 
• Uncertainty in modeling through verbal variables. 
A flaw of the type-1 fuzzy set is that uncertainties are expressed with membership 
functions, whereas the outputs of these membership functions are crisp values [3]. 
Hence, type-1 fuzzy systems cannot model high levels of uncertainty. To solve this 
problem, type-2 fuzzy systems were introduced by Zadeh in 1975; however, fewer 
studies had been published on these systems by the end of the previous century [4].
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
A. Mohammadzaheh et al., Modern Adaptive Fuzzy Control Systems, Studies in Fuzziness 
and Soft Computing 421, https://doi.org/10.1007/978-3-031-17393-6_3 
1718 3 Type-2 Fuzzy Systems
Type-2 fuzzy systems are the developed version of type-1 fuzzy systems, in which 
the antecedent and consequent membership functions are of type 2 [5]. The output of 
a type-2 membership function is a value between 0 and 1. In fact, unlike the type-1 
fuzzy system, the membership degree is a fuzzy number. This degree of freedom 
helps model further uncertainties. 
A type-2 fuzzy set A ˜ is defined with the membership function 0 ≤ μA˜(x, u) ≤ 1 
in which x ∈ X and u ∈ Jx ⊆ [0, 1]: 
A ˜ = {
(x, u),μA˜(x, u)| ∀x ∈ X, ∀u ∈ Jx ⊆ [0, 1]
} (3.1.3) 
where Jx is the primary membership function of x when Jx ⊆ [0, 1] for ∀x ∈ X. 
Uncertainty in the membership degree of the primary type-2 membership function, 
which includes a range, is called the footprint of uncertainty. In fact, a type-2 member￾ship function can be interpreted as a type-1 set. If the secondary membership degree 
of type-2 membership functions is continuous, it can be equal to a countless number 
of type-1 membership functions [5]. 
The interval type-2 fuzzy systems [6] are a special version of type-2 fuzzy systems 
in which the secondary membership functions are of the interval form. The footprint 
of uncertainty, which was defined earlier, can be introduced as the terms of the 
upper-bound and lower-bound membership functions in the interval form. 
The use of type-2 membership functions in antecedent and consequent sections 
resulted in the following superiorities to type-1 membership functions: 
• The outputs of type-2 membership functions are fuzzy; thus, these functions can 
model further and more complicated uncertainties [7]. 
• Since one type-2 membership function with the fuzzy secondary membership 
degree can be used instead of multiple type-1 membership functions, there will 
be fewer rules [8]. 
• As discussed earlier, a type-2 fuzzy set can be expressed as a large number of 
type-1 fuzzy sets. Hence, using typ-2 membership functions will improve the 
control performance and yield a better control signal [2]. 
In the recent decade, type-2 fuzzy systems have interested many researchers [9]. 
Different papers have reported many practical applications of type-2 fuzzy systems 
such as the induction motor control, biaxial motion control, temperature control in 
a part of a lathe, diesel engines, DC-to-DC convertors, and moving robots. In these 
applications, type-2 fuzzy systems outperformed type-1 fuzzy systems. 
Although many papers have been published on type-2 fuzzy systems, most of 
them have used singleton fuzzy systems, which disregard numerical uncertainty. In 
fact, numerical uncertainty indicates an input with noise as well as the imprecision of 
sensors and input tools. Therefore, non-singleton fuzzy systems should be employed 
while dealing with uncertain inputs.3.3 Non-singleton Fuzzy Systems 19
3.3 Non-singleton Fuzzy Systems 
The major difference between non-singleton and singleton fuzzy systems lies in 
fuzzification. Since 1974, fuzzy systems with singleton fuzzification were used exten￾sively in practical applications due to simplicity and small-scale computations when 
Mamdani employed the first fuzzy controller to control a steam engine. However, 
many of the practical applications were prone to noisy data and uncertainties in 
the outputs of sensors, which could not be ignored. Hence, non-singleton fuzzifica￾tion was proposed to handle uncertain data. At first, the non-singleton type-1 fuzzy 
(NSF1F) system was utilized in some applications. For instance, it was used in [10] 
to analyze time series, in [11] to model nonlinear systems, and in [12] to control a 
DC motor. In [13], a feedback structure (output feedback) was proposed by using the 
gradient descent to train the parameters. In [14], the genetic algorithm was employed 
for optimization, and the proposed system was used in classification problems. 
In [15], non-singleton type-2 fuzzy systems were analyzed by Mendel for the first 
time ever. In this paper, the type-1 fuzzy system was first introduced, and type-2 
operators and definitions were then presented. Most of the studies on type-2 non￾singleton fuzzy systems were conducted by Mendez. These studies mainly include 
training through different methods. The least error squares method was employed to 
train the parameters of a type-2 fuzzy system with type-1 non-singleton fuzzifica￾tion in [12, 16–18] and with type-2 non-singleton fuzzification in [18]. In [19], the 
Kalman filter was utilized to train the parameters of a type-2 fuzzy system with type￾1 non-singleton fuzzification, in which the inputs were modeled on the type-1 fuzzy 
numbers. In [20], a type-2 non-singleton fuzzy system was used for image noise 
elimination through the modified PSO algorithm for parameter setting. In [15], the 
studies of fuzzifiers were first reviewed, and a type-2 fuzzy system with non-singleton 
fuzzification was then proposed without using conventional membership functions 
such as Gaussian and triangular functions. In the proposed method, the membership 
function for the input data is inferred from the stored data and a histogram. In [21], 
the genetic algorithm was employed to train the type-2 non-singleton parameters, 
and the proposed system was used for pattern classification. In [22], a comparison 
was drawn between a type-1 fuzzy system with non-singleton fuzzification and a 
type-2 fuzzy system with singleton fuzzification. According to the results, the non￾singleton type-2 fuzzy system outperformed the non-singleton type-1 fuzzy system 
in a noisy environment. The most recent study by Mendez in 2013 was conducted on 
the proposal of hybrid algorithms to train non-singleton type-2 fuzzy systems [23]. 
In this paper, the recursive square root algorithm and the gradient descent algorithm 
were adopted to set consequent parameters and antecedent parameters, respectively.20 3 Type-2 Fuzzy Systems
3.4 Features of Type-2 Fuzzy Systems 
This subchapter analyzes the important features of type-2 fuzzy systems. At first, 
type-2 membership functions are introduced and compared with type-1 membership 
functions. Figure (3.1) demonstrates a Gaussian type-1 membership function. If this 
function is blurred in Fig. (3.2), a type-2 membership function is obtained.
Assume that x has the value of x’, the membership degree (u'
) has a specific value 
in the type-1 membership function, whereas u' has different values in the type-2 
membership function. Hence, the type-2 membership function is a 3D membership 
function. In other words, the membership degree of a type-2 membership function 
is a type-1 membership function itself. 
The type-2 membership function ( A˜) is defined as below: 
A ˜ = {((x, u), μA˜(x, u)
)
| ∀x ∈ X, ∀u ∈ Jx ⊆ [0, 1]
} (3.1) 
where 0 ≤ μA˜(x, u) ≤ 1. In fact, Jx ⊆ [0, 1] indicates the primary member￾ship of x, whereas μA˜(x, u) is a type-2 membership function that represents the 
secondary membership. If the degree of the secondary membership function is 1, 
i.e., μA˜(x, u), ∀u ∈ Jx ⊆ [0, 1]„ there will then be an interval type-2 membership
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2 2.5 3
 Input 
0 
0.2 
0.4 
0.6 
0.8 
1
 Membership 
Fig. 3.1 Gaussian type-1 membership function
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2 2.5 3
 Input 
0 
0.2 
0.4 
0.6 
0.8 
1
 Membership 
Fig. 3.2 Type-2 membership function 3.5 Basic Operations in Type-2 Fuzzy 21
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2 2.5 3
 Input 
0 
0.2 
0.4 
0.6 
0.8 
1 
Membership 
Fig. 3.3 An interval type-2 membership function 
Fig. 3.4 The structure of a type-2 fuzzy system 
function (refer to Fig. (3.3)). Figure (3.4) depicts the structure of a type-2 fuzzy 
system, each component of which is described here.
3.5 Basic Operations in Type-2 Fuzzy 
Before some of the basic operations are described, a few basic concepts of the interval 
type-2 fuzzy system are analyzed. Consider an interval type-2 membership func￾tion shown in Fig. (3.5). The upper-bound membership function (UMF) and the 
lower-bound membership function (LMF) indicate the highest and lowest degrees 
of primary membership, respectively. In general, a type-2 membership function can 
be considered the combination of type-1 membership functions, each of which is 
called an embedded membership function. If the type-2 membership function is 
sliced horizontally, the lowest level is called the footprint of uncertainty (FOU).
Consider two interval type-2 membership functions of A ˜ and B ˜ in the form shown 
by Fig. (3.5). The operations of their union ( A ˜ ∪ B˜), intersection ( A ˜ ∩ B˜), and 
complement ( A˜) are defined as below:22 3 Type-2 Fuzzy Systems
0 
0.2 
1 
0.4 
0.6 
Secondary membership 0.8 
1 
primary membership 
0.5 
input 
8 10 0 0 2 4 6 -8 -6 -4 -2 -10 
Fig. 3.5 An interval type-2 membership function
A ˜ ∪ B ˜ = 1/
[
μA˜(x) ∨ μB˜(x)
,μA˜(x) ∨ μB˜(x)
]
∀x ∈ X (3.2) 
A ˜ ∩ B ˜ = 1/
[
μA˜(x) ∧ μB˜(x)
,μA˜(x) ∧ μB˜(x)
]
∀x ∈ X (3.3) 
A ˜ = 1/
[
1 − μA˜(x)
, 1 − μA˜(x)
]
∀x ∈ X (3.4) 
where ∨ and ∧ represent t-conorm and t-norm, respectively. 
3.6 Fuzzification 
A fuzzifier maps an input vector x = (
x1,..., x p
)T onto a membership function 
A˜ x . If A˜ x is a type-1 membership function, fuzzification is considered type-1 non￾singleton. If it is a type-2 membership function, fuzzification is considered type-2 
non-singleton. Moreover, if it is a singleton membership function (i.e., μA˜ x 
(x) = 1/1 
for x = x' and μA˜ x 
(x) = 1/0 for x /= x'
), then fuzzification is considered singleton. 
3.7 Rules 
Type-1 and type-2 fuzzy systems share the same structure of rules; however, 
antecedent and consequent membership functions are of type-2. Consider a type￾2 fuzzy system with p inputs (x1,..., x p) and one output (y). The Lth rule is defined 
as below: 
Rl : IFx1 is F˜l 
1 and ··· and x p is F˜l 
p, T H EN y is G˜ l 
, l = 1,..., M (3.2) 
where F ˜ and G ˜ are type-2 membership functions.3.8 Logics 23
3.8 Logics 
In type-2 fuzzy systems, the inference engine combines the rules and maps an input 
type-2 fuzzy set onto an output type-2 fuzzy set. If F˜ 1 
1 × ··· × F˜ 1 
p = A˜l
, Eq. (3.2) 
can be rewritten as below: 
Rl : F˜ 1 
1 × ··· × F˜ 1 
p → G˜ l = A˜l → G˜ l l = 1,..., M (3.3) 
where Rl is described through the membership functions μRl (x, y) =
μRl
(
x1,..., x p, y
)
: 
μRl (x, y) = μA˜l→G˜ l (x, y) (3.4) 
Equation (3.4) can then be rewritten as below: 
μRl (x, y) = μA˜l→G˜ l (x, y)
= μF˜l 
1 
(x1)
⊓···⊓μF˜l 
p
(
x p
)⊓μG˜ l (y)
=
[⊓p 
i=1 
μF˜l 
i 
(xi )
]⊓μG˜ l (y) (3.5) 
In general, the p-dimensional input to Rl is written with a type-2 membership 
function A˜ x : 
A˜ x = μx˜1 (x1)
⊓···⊓μx˜ p
(
x p
)
= ⊓p 
i=1 
μx˜i (xi ) (3.6) 
where x˜i (i = 1,..., p) denotes the fuzzy sets corresponding to the inputs. Each rule 
Rl determines a type-2 fuzzy set B˜l = A˜ x ◦ Rl when: 
μB˜l (y) = μA˜ x ◦Rl = ⊔
x∈X
[
μA˜ x 
(X)
⊓μRl (X, y)
]
(3.7) 
Fig. (3.8) demonstrates this input–output dependency. 
In most of the applications, the interval type-2 fuzzy set is used with t-norm; 
therefore, the degrees of fire are as below: 
F˜l
(
X'
)
=
[
f l
(
X'
)
, f l(
X'
)]
=
[
f l 
, f l
]
(3.8) 
where 
f l
(
X'
)
= μF˜l 
1
(
x'
1
)
∗ ··· ∗ μF˜l 
p
(
x'
p
) (3.9) 
and24 3 Type-2 Fuzzy Systems
f l(
X'
)
= μF˜l 
1
(
x'
1
)
∗ ··· ∗ μF˜l 
p
(
x'
p
)
where * denotes the product operator. 
3.9 Type Reduction 
In this subchapter, a type-1 set is generated in the output. There are different methods 
for type reduction: 
1. Centroid Type Reduction 
In a centroid defuzzifier, the type-1 output sets are combined through t-conorm 
to generate a centroid. If the resultant output fuzzy set is called B, then: 
yc(x) =
ΣN 
i=1 yi μB (yi )
ΣN 
i=1 μB (yi )
(3.10) 
where the number of partitions is B. 
In the centroid type reduction, type-2 output fuzzy sets are combined through 
their union. The membership degree (y ∈ Y ) is defined as below: 
μB ˜(y) = ⊔M 
l=1 
μB˜l (y) (3.11) 
where μB˜l is obtained from Eq. (3.5). 
In fact, the centroid type reduction obtains the centroid of B˜: 
Yc(x) =

θ1 
··· 
θN
[
μD1 (θ1) ∗ ··· ∗ μDN (θN )
]
/ ΣN 
i=1 yi θi
ΣN 
i=1 θi 
(3.12) 
where Di = μB ˜(yi ) and θi ∈ μB ˜(yi ), i = 1,..., N. 
Consider the following definitions: 
a =
ΣN 
i=1 yi θi
ΣN 
i=1 θi 
, b = μD1 (θ1) ∗ ··· ∗ μDN (θN ) (3.13) 
According to Eq. (3.12), a large number of (a, b) calculations should be 
performed to determine Yc(x). Assume that (a, b) is calculated for α times: 
(a1, b1),...,(aα, bα). The necessary and important information for type reduc￾tion includes only the greatest and smallest values of (a, b), i.e., aL = min ai , 
aR = max ai , bL = min bi , and bR = max bi . The next chapters will propose 
simpler method with much lower volumes of calculations. The following operations 
should be implemented step by step to calculate Yc(x):3.9 Type Reduction 25
(1) Obtain the combined output set through Eq. (3.11) (for this purpose, calculate 
μB˜l first through Eq. (3.5)). 
(2) Divide the output space into N sections (y1,..., yN ). 
(3) Divide μB ˜(yi ), i = 1,..., N into Mi points. 
(4) The number of membership set will be ⊓N 
i=1 Mi , and calculate the pairs of 
(ai , bi ),i = 1,..., ⊓N 
i=1 Mi through Eq. (3.13). Finally, obtain Yc(x) from 
Eq. (3.12). Furthermore, the minimum t-norm should be used in this method. 
2. Height Type Reduction 
In a height defuzzifier, the output membership set of each rule is replaced with a 
singleton in a point which as the largest membership degree in the set. The output of 
the defuzzifier is obtained from the following equation: 
yh(x) =
ΣM 
l=1 yl μBl
(
yl
)
ΣM 
l=1 μBl
(
yl
) (3.14) 
where yl is a point that has the highest membership degree in the Lth output set 
(if there number of similar points is more than one, their mean is considered). For 
μBl
(
yl
)
, the following equation is considered: 
μBl
(
yl
)
= μGl
(
yl
)
∗ Tp 
i=1μFl 
i 
(xi ) (3.15) 
where T and * represent the t-norm (product or minimum t-norm). 
In the height type reduction method, the output set is replaced with a type-2 
singleton, the range of which is a point. Its membership degree is a type-1 set within 
[0, 1]. The Lth output set has a singleton at yl with the highest membership degree 
in the principal membership function of the output set Bl
(the principal member￾ship function has the highest secondary membership function). Hence, Eq. (3.12) is 
simplified as below: 
Yh(x) =

θ1 
··· 
θM
[
μD1 (θ1) ∗ ··· ∗ μDM (θM )
]
/ ΣM 
l=1 yl θl
ΣM 
l=1 θl 
(3.16) 
where θl ∈ Dl 
, l = 1,..., M. Perform the following calculations step by step to 
determine Yh(x): 
(1) In each output set l = 1,..., M, select yl and determine μBl
(
yl
)
. 
(2) Like the previous method, divide the range of μBl
(
yl
) into an appropriate 
number of points. However, the number of points on the horizontal axis is 
M in this method. 
(3) If μBl
(
yl
)
is divided into N points, the total number of possible combinations 
in Eq. (3.16) will be ⊓M 
i=1 Ni . 
(4) Determine Yh(x) through Eq. (3.16).26 3 Type-2 Fuzzy Systems
In Eq. (3.16), the number of calculations is ⊓M 
i=1 Ni , which is much smaller than 
that of the previous method. 
3. Center-of-sets (COS) Type Reduction 
In the COS defuzzification method, the consequent set of each rule is replaced 
with a singleton located in its centroid, and the centroid of the type-1 set constructed 
from these singletons will then be obtained. The output is as follows: 
ycos(x) =
ΣM 
l=1 cl
Tp 
i=1μFl 
i 
(xi )
ΣM 
l=1 Tp 
i=1μFl 
i 
(xi )
(3.17) 
where T and cl represent t-norm and the lth consequent set. If the consequent sets 
are symmetric, normal, and convex, there will be cl = yl and μGl
(
yl
) = 1 for 
l = 1,..., M; therefore: ycos(x) = yh(x). 
Similar to defuzzification, each consequent set is replaced with its centroid (if the 
consequent set is type-2, its centroid will be a type-1 set) in the COS type reduction, 
and the weighted mean of these centroids will be determined. The weight of the lth 
centroid of the firing strength corresponds to the lth rule, i.e.,
⊓p 
i=1 μFl 
i 
(xi ). Finally, 
the output of this type reduction method is as follows: 
Ycos(x) =

d1 
··· 
dM

e1 
··· 
eM 
TM 
l=1μcl (dl ) ∗ TM 
l=1μEl (el )
/ ΣM 
l=1 dlel
ΣM 
l=1 el 
(3.18) 
where T and * denote t-norm. Moreover, dl = cl = c G˜ l is the lth centroid of the 
consequent set, whereas el ∈ El = ⊓p 
i=1 μFl 
i 
(xi ) indicates the firing strength corre￾sponding to the lth consequent set. The following calculations should be performed 
step by step to find the output: 
(1) Divide the output space Y into the right number of points, and determine the 
centroid of each consequent set (c G˜ l ). These centroids can be obtained once and 
then used along the process. 
(2) Determine the firing strength El = ⊓p 
i=1 μFl 
i 
(xi ) corresponding to the lth 
consequent set. 
(3) Divide the range of each c G˜ l into the right number Ml . 
(4) Divide the range of each El into the right number Nl . 
(5) Determine the number of possible states {c1,..., cM , e1,..., eM } for el ∈ El 
and dl ∈ c G˜ l . The total number of states will be equal to ⊓M 
j=1 Mj Nj . 
(6) Finally, obtain the output from Eq. (3.18) 
4. Type Reduction for Interval Type-2 Systems 
The general type-2 fuzzy systems are very complicated due to the large amounts of 
type reduction calculations. In general, the most important method of type reduction 
is as follows:3.9 Type Reduction 27
Y (Z1,..., Z M , W1,..., WM )
=

z1 
··· 
zM

w1 
··· 
wM 
TM 
l=1μzl (zl ) ∗ TM 
l=1μWl (wl )
/ ΣM 
l=1 wlzl
ΣM 
l=1 wl 
(3.19) 
where T and * denote t-norm with wl ∈ Wl , zl ∈ Zl . 
If the secondary degrees of membership functions are of the interval type, the 
amounts of calculations will noticeably decrease. For an interval type-2 fuzzy system, 
each of Wl , Zl ,l = 1,..., M in Eq. (3.18) is an interval type-1 set. Hence, the 
following equation can be written due to the fact that μzl (zl ) = μWl (wl ) = 1: 
Y (Z1,..., Z M , W1,..., WM ) =

z1 
··· 
zM

w1 
··· 
wM 
1
/ ΣM 
l=1 wlzl
ΣM 
l=1 wl 
(3.20) 
Since memberships are crisp numbers in an interval type-1 set, an interval set is 
determined with upper and lower bounds. In general interval type-2 fuzzy systems, 
each zl in Eq. (3.20) is an interval type-1 set, the centroid of which is cl . This set 
expands from both sides as much as sl . Moreover, each wl is an interval type-1 set 
with the centroid of hl and the expansion of Δl . Since Y is an interval type-1 set, the 
first and last points of this interval must only be determined (yl and yr ). An iterative 
method is now presented to find yl and yr . 
Consider the following definition: 
S(w1,...,wM ) =
ΣM 
l=1 wlzl
ΣM 
l=1 wl 
(3.21) 
where wl ∈ [hl − Δl , hl + Δl], hl ≥ Δl , and zl ∈ [cl − sl , cl + sl]. 
The maximum values of S and yl are determined through the following steps by 
considering zl = cl + sl and z1 ≤ z2 ≤ ··· ≤ zM : 
(1) Obtain S' = S(h1,..., h M ) from Eq. (3.21) by considering wl = hl . 
(2) Find k(1 ≤ k ≤ M − 1) when zk ≤ S' ≤ zk+1. 
(3) Obtain S'' = S(h1 − Δl ,..., hk − Δk , hk+1 + Δk+1,..., h M + ΔM ) from 
Eq. (3.21) by considering wl = hl − Δl for l ≤ k and wl = hl + Δl for 
l ≥ k + 1. 
(4) If S'' = S'
, the algorithm will stop, and S'' will be the maximum value of S; 
otherwise, go to the next step. 
(5) Go to the second step by considering S'' = S'
. 
Mendel et al. indicated that the algorithm would reach a solution in at most M 
steps.28 3 Type-2 Fuzzy Systems
3.10 Implementation in MATLAB 
Different methods of type reduction are implemented through an example. Consider 
the consequent membership functions in Fig. (3.6). There are two Gaussian member￾ship functions at each point within y ∈ [1, 5]. For instance, there are two Gaussian 
membership functions 0.9∗N (y, 2, 0.4) and 0.8∗N (y, 2, 0.4) at y = 2. The methods 
of rank reduction are applied to these membership functions, and the results are 
compared. 
(1) Centroid 
In this method, the union of membership functions should first be determined as 
below: (Fig. 3.7). 
If y ∈ [1, 5] is divided into 21 points, there will totally be 221 embedded type-2 
membership functions, the centroids of which are shown in Fig. (3.8). Table (3.1) 
presents the right and left bounds of these membership functions. Table (3.2) indicates 
the script of this method in MATLAB.
(2) Height 
In this method, the activated output membership functions are replaced with 
a singleton membership function with the highest primary membership degree.
1 1.5 2 2.5 3 3.5 4 4.5 5 
0 
0.5 
1 
1 
1 
0.5 
0.4 
0.8 
1 
Fig. 3.6 Consequent membership functions 
1 1.5 2 2.5 3 3.5 4 4.5 5 
0 
0.2 
0.4 
0.6 
0.8 
1 
Fig. 3.7 The union of consequent membership functions3.10 Implementation in MATLAB 29
Fig. 3.8 Rank reduction with the centroid method
Table 3.1 The results of rank 
reduction with the centroid 
method 
Right bound point Left bound point 
Centroid method 2.4448 2.2828 
Table 3.2 The script of the centroid method for rank reduction in MATLAB 
MATLAB script for the centroid rank reduction 
clear all 
clc 
x=1:0.01:5; 
y1_u=@(x)0.9*exp(-0.5.*(x-2).^2./0.4.^2); 
y1_l=@(x) 0.8*exp(-0.5.*(x-2).^2./0.4.^2);
 
y2_u=@(x) 0.8*exp(-0.5.*(x-3).^2./0.2.^2); 
y2_l=@(x) 0.6*exp(-0.5.*(x-3).^2./0.2.^2);
 
y3_u=@(x) 0.2*exp(-0.5.*(x-5).^2./0.2.^2); 
y3_l=@(x) 0.1*exp(-0.5.*(x-5).^2./0.2.^2);
 
%union_MF= 
subplot(2,1,1)
 
plot(x,y3_u(x)); 
hold on 
plot(x,y3_l(x)); 
plot(x,y2_u(x)); 
plot(x,y2_l(x)); 
plot(x,y1_u(x)); 
plot(x,y1_l(x)); 
N=21; 
x1=x; 
%% Union 
y1(1,:)=y1_u(x1); 
y1(2,:)=y2_u(x1); 
y1(3,:)=y3_u(x1);
(continued)30 3 Type-2 Fuzzy Systems
Table 3.2 (continued)
a1=find(y1(1,:)<y1(2,:)); 
a2=find(y1(2,:)<y1(3,:)); 
y(1,:)=[y1(1,1:a1) y1(2,a1+1:a2) y1(3,a2+1:end)]; 
second_MF(1,:)=[ones(size(y1(1,1:a1))) ones(size(y1(2,a1+1:a2))) 
ones(size(y1(3,a2+1:end)))]; 
y2(1,:)=y1_l(x1); 
y2(2,:)=y2_l(x1); 
y2(3,:)=y3_l(x1); 
a1=find(y2(1,:)<y2(2,:)); 
a2=find(y2(2,:)<y2(3,:)); 
y(2,:)=[y2(1,1:a1) y2(2,a1+1:a2) y2(3,a2+1:end)]; 
second_MF(2,:)=[0.5*ones(size(y1(1,1:a1))) 
0.8*ones(size(y1(2,a1+1:a2))) 0.4*ones(size(y1(3,a2+1:end)))]; 
%% 
M=2; % discreatize of secondry MF 
N=length(x1); %len 
k=1; 
n=M^N; 
for ii=N:-1:1 
a=[ones(1,k) 2*ones(1,k)]'; 
xx(:,ii)=repmat(a,n/length(a),1); 
k=k*M; 
end 
for ii=1:size(xx,1) 
for jj=1:N 
w(jj)=y(xx(ii,jj),jj); 
s_MF(jj)=second_MF(xx(ii,jj),jj); 
end 
c(ii)=x1*w'/sum(w); 
grad_c(ii)=min(s_MF); 
end 
plot(c,grad_c) 
MATLAB script for rank reduction 
clear all 
clc 
x=1:0.01:5; 
y1_u=@(x)0.9*exp(-0.5.*(x-2).^2./0.4.^2); 
y1_l=@(x) 0.8*exp(-0.5.*(x-2).^2./0.4.^2);
(continued)3.10 Implementation in MATLAB 31
Table 3.2 (continued)
y2_u=@(x) 0.8*exp(-0.5.*(x-3).^2./0.2.^2); 
y2_l=@(x) 0.6*exp(-0.5.*(x-3).^2./0.2.^2);
 
y3_u=@(x) 0.2*exp(-0.5.*(x-5).^2./0.2.^2); 
y3_l=@(x) 0.1*exp(-0.5.*(x-5).^2./0.2.^2); 
N=21; 
x1=x(1:20:end); 
%% Union 
M=2; % discreatize of secondry MF 
N=length(x1); 
k=1; 
n=M^N; 
[a1 b1]=max(y1_u(x1)); 
[a2 b2]=max(y2_u(x1)); 
[a3 b3]=max(y3_u(x1)); 
x1=x1([b1 b2 b3]); 
y(1,:)=[a1 a2 a3]; 
[a1 b1]=max(y1_l(x1)); 
[a2 b2]=max(y2_l(x1)); 
[a3 b3]=max(y3_l(x1)); 
y(2,:)=[a1 a2 a3]; 
 
second_MF=[1 1 1; 0.5 0.8 0.4]; 
 
 
%%
M=2; % discreatize of secondry MF in to point
N=length(x1); %len
k=1; 
n=M^N; 
 
for ii=N:-1:1 
 a=[ones(1,k) 2*ones(1,k)]'; 
 
 xx(:,ii)=repmat(a,n/length(a),1); 
 k=k*M; 
end
%%
for ii=1:size(xx,1) 
 for jj=1:N 
 w(jj)=y(xx(ii,jj),jj); 
 s_MF(jj)=second_MF(xx(ii,jj),jj); 
 
 end
 
 c(ii)=x1*w'/sum(w); 
 grad_c(ii)=min(s_MF); 
end
stem(c,grad_c,'linewidth',2,'markersize',1) 
set(gca,'fontweight','bold','fontsize',13,'ytick',[0:0.2:1]) 
grid on
xlim([1 5]) 
 
disp('----------- left and right most points -------') 
max(c) 
min(c)
(continued)32 3 Type-2 Fuzzy Systems
Table 3.2 (continued)
[a3 b3]=max(y3_u(x1)); 
x1=x1([b1 b2 b3]); 
y(1,:)=[a1 a2 a3]; 
[a1 b1]=max(y1_l(x1)); 
[a2 b2]=max(y2_l(x1)); 
[a3 b3]=max(y3_l(x1)); 
y(2,:)=[a1 a2 a3]; 
 
second_MF=[1 1 1; 0.5 0.8 0.4]; 
 
 
%%
M=2; % discreatize of secondry MF in to point
N=length(x1); %len
k=1; 
n=M^N; 
 
for ii=N:-1:1 
 a=[ones(1,k) 2*ones(1,k)]'; 
 
 xx(:,ii)=repmat(a,n/length(a),1); 
 k=k*M; 
end
%%
for ii=1:size(xx,1) 
 for jj=1:N 
 w(jj)=y(xx(ii,jj),jj); 
 s_MF(jj)=second_MF(xx(ii,jj),jj); 
 
 end
 
 c(ii)=x1*w'/sum(w); 
 grad_c(ii)=min(s_MF); 
end
stem(c,grad_c,'linewidth',2,'markersize',1) 
set(gca,'fontweight','bold','fontsize',13,'ytick',[0:0.2:1]) 
grid on
xlim([1 5]) 
 
disp('----------- left and right most points -------') 
max(c) 
min(c)
Figure (3.9) depicts the resultant diagram, and Table (3.3) reports the right and 
left bounds. The MATLAB script of this method can be seen in –-.
(3) Modified Height Method 
This method resembles the height method but normalizes the membership functions. 
Figure (3.10) demonstrates the output diagram of this method. Table (3.4) presents the 
right and left points, and Table (3.5) delivers the script of this method in MATLAB.3.10 Implementation in MATLAB 33
1 1.5 2 2.5 3 3.5 4 4.5 5 
0 
0.2 
0.4 
0.6 
0.8 
1 
Fig. 3.9 The output of the height rank reduction 
Table 3.3 The results of the 
height type reduction Right bound point Left bound point 
Height method 2.7778 2.5625
1 1.5 2 2.5 3 3.5 4 4.5 5 
0 
0.2 
0.4 
0.6 
0.8 
1 
Fig. 3.10 The output diagram of the modified height rank reduction 
Table 3.4 The results of the 
modified height rank 
reduction 
Right bound point Left bound point 
Modified height method 3.2000 2.9730
(4) Center of Sets 
In this method, the centroids of the output membership functions are first obtained. 
Figure (3.11) demonstrates the results. The range of each resultant type-1 member￾ship functions is then divided into several similar points shown in Table (3.6). Finally, 
right and left bounds are determined as depicted in Table (3.8) and Table (3.7). 
Furthermore, Table (3.8) indicates the script for implementation of this method in 
MATLAB (Fig. 3.12).34 3 Type-2 Fuzzy Systems
Table 3.5 The script of the modified rank reduction method in MATLAB 
MATLAB script for the modified height method 
clear all 
clc 
%% censequent output sets 
x=1:0.01:5; 
m1=2; sigma1=0.4; m2=3; sigma2=0.2; m3=5; sigma3=0.2; 
y1_u=@(x)0.9*exp(-0.5.*(x-m1).^2./sigma1.^2); 
y1_l=@(x) 0.8*exp(-0.5.*(x-m1).^2./sigma1.^2); 
y2_u=@(x) 0.8*exp(-0.5.*(x-m2).^2./sigma2.^2); 
y2_l=@(x) 0.6*exp(-0.5.*(x-m2).^2./sigma2.^2); 
y3_u=@(x) 0.2*exp(-0.5.*(x-m3).^2./sigma3.^2); 
y3_l=@(x) 0.1*exp(-0.5.*(x-m3).^2./sigma3.^2); 
N=21; 
x1=x(1:20:end); 
%% 
M=2; % discreatize of secondry MF in to point 
N=length(x1); %len 
k=1; 
n=M^N; 
[a1 b1]=max(y1_u(x1)); 
[a2 b2]=max(y2_u(x1)); 
[a3 b3]=max(y3_u(x1)); 
x1=x1([b1 b2 b3]); 
y(1,:)=[a1 a2 a3]; 
[a1 b1]=max(y1_l(x1)); 
[a2 b2]=max(y2_l(x1)); 
[a3 b3]=max(y3_l(x1)); 
y(2,:)=[a1 a2 a3]; 
second_MF=[1 1 1; 0.5 0.8 0.4]; 
%% 
M=2; % discreatize of secondry MF in to point 
N=length(x1); %len 
k=1; 
n=M^N;
(continued)3.10 Implementation in MATLAB 35
Table 3.5 (continued)
for ii=N:-1:1 
a=[ones(1,k) 2*ones(1,k)]'; 
xx(:,ii)=repmat(a,n/length(a),1); 
k=k*M; 
end 
%% 
for ii=1:size(xx,1) 
for jj=1:N 
w(jj)=y(xx(ii,jj),jj); 
s_MF(jj)=second_MF(xx(ii,jj),jj); 
end 
w=w./([sigma1 sigma2 sigma3].^2); 
c(ii)=x1*w'/sum(w); 
grad_c(ii)=min(s_MF); 
end 
stem(c,grad_c) 
disp('----------- left and right most points -------') 
max(c) 
min(c) 
stem(c,grad_c,'linewidth',2,'markersize',1) 
set(gca,'fontweight','bold','fontsize',13,'ytick',[0:0.2:1]) 
grid on 
xlim([1 5])
1 1.5 2 2.5 3 3.5 4 4.5 5 
0 
0.2 
0.4 
0.6 
0.8 
1 CG1 
1 1.5 2 2.5 3 3.5 4 4.5 5 
0 
0.2 
0.4 
0.6 
0.8 
1 CG2 
1 1.5 2 2.5 3 3.5 4 4.5 5 
0 
0.2 
0.4 
0.6 
0.8 
1 CG3 
Fig. 3.11 The centroids of the output membership functions36 3 Type-2 Fuzzy Systems
Table 3.6 Discretization C G˜ 1 
/E1 C G˜ 2 
/E2 C G˜ 3 
/E3 
Nl 32 8 4 
Ml 2 2 2 
Table 3.7 The results of the 
center of sets Right bound point Left bound point 
Center of sets 2.7778 2.5625
(5) Center of Sum 
As discussed earlier, this method looks exactly like the first method, i.e., the centroid 
method, but it adds the output membership functions instead of determining their 
union. 
(6) KM and EKM 
As discussed earlier, it is assumed in this method that the secondary membership 
degree is equal to one for all membership functions; thus, calculations become 
simpler. These types of membership functions are called the interval membership 
functions. Table (3.9) presents the script for this method in MATLAB, and Table 
(3.10) reports the final results. Accordingly, the results are very close to general 
cases analyzed in the first to sixth methods.
3.11 Designing a General Type-2 Fuzzy System 
with an Example 
To better perceived what has already been discussed, the design steps of a type-2 fuzzy 
system are now explained with an example. Assume that the fuzzy system of interest 
has two inputs (x and y). According to Fig. (3.13), two membership functions A ˜ and 
C ˜ are considered for x; likewise, two membership functions B ˜ and D ˜ are considered 
for y. The fuzzy rules are defined as below: 
1.I f x is A a ˜ nd y is B then z is ˜ G˜ 1 
2.I f x is C and y is ˜ D then z is ˜ G˜ 2 (3.5)
It should be noted that the rules usually have constant forms. If all possible rules 
are considered, the total number of rules for a fuzzy system with n inputs will be Nn, 
in which N denotes the number of membership functions for each input. 
According to Fig. (3.14), the membership degrees of membership functions are 
first determined for each input to calculate the firing strengths of rules. In this 
example, the firing strengths of rules are as follows:3.11 Designing a General Type-2 Fuzzy System with an Example 37
Table 3.8 The script of the center of sets in MATLAB 
MATLAB script for center of sets 
%% 
% Center of sets type-reduction 
clear all 
clc 
%% consequent MF 
m1=2; sigma1=0.4; m2=3; sigma2=0.2; m3=5; sigma3=0.2; 
y1_u=@(x)0.9*exp(-0.5.*(x-m1).^2./sigma1.^2); 
y1_l=@(x) 0.8*exp(-0.5.*(x-m1).^2./sigma1.^2); 
y2_u=@(x) 0.8*exp(-0.5.*(x-m2).^2./sigma2.^2); 
y2_l=@(x) 0.6*exp(-0.5.*(x-m2).^2./sigma2.^2); 
y3_u=@(x) 0.2*exp(-0.5.*(x-m3).^2./sigma3.^2); 
y3_l=@(x) 0.1*exp(-0.5.*(x-m3).^2./sigma3.^2); 
%% centroid of each consequent MFs 
%----------- MF1----------------
x1=1:0.5:3; 
y(1,:)=y1_u(x1); 
y(2,:)=y1_l(x1); 
second_MF=[ones(size(x1)) ; 0.5*ones(size(x1))]; 
[c1 grad_c1]=centroid_MF(x1,y,second_MF); 
[c1 aa]=sort(c1); 
grad_c1=grad_c1(aa); 
%----------- MF2----------------
clear y 
x1=2.5:0.5:3.5; 
y(1,:)=y2_u(x1); 
y(2,:)=y2_l(x1); 
second_MF=[ones(size(x1)) ; 0.8*ones(size(x1))]; 
[c2 grad_c2]=centroid_MF(x1,y,second_MF); 
[c2 aa]=sort(c2); 
grad_c2=grad_c2(aa); 
%----------- MF3----------------
clear y 
x1=4.5:0.5:5; 
y(1,:)=y3_u(x1); 
y(2,:)=y3_l(x1); 
second_MF=[ones(size(x1)) ; 0.4*ones(size(x1))]; 
[c3 grad_c3]=centroid_MF(x1,y,second_MF); 
[c3 aa]=sort(c3); 
grad_c3=grad_c3(aa); 
%% Discretize 
ce1=[y1_u(c1'); y1_l(c1')]; 
ce2=[y2_u(c2'); y2_l(c2')]; 
ce3=[y3_u(c3'); y3_l(c3')]; 
second_MF1=[ones(size(c1')) ; 0.5*ones(size(c1'))]; 
second_MF2=[ones(size(c2')) ; 0.8*ones(size(c2'))]; 
second_MF3=[ones(size(c3')) ; 0.4*ones(size(c3'))]; 
grad_c1=repmat(grad_c1',2,1); 
grad_c2=repmat(grad_c2',2,1); 
grad_c3=repmat(grad_c3',2,1); 
c1=repmat(c1',2,1); 
c2=repmat(c2',2,1); 
c3=repmat(c3',2,1);
(continued)38 3 Type-2 Fuzzy Systems
Table 3.8 (continued)
%% 
k=1; 
for k1=1:length(c1) 
for k2=1:length(c2) 
for k3=1:length(c3) 
d=[c1(k1) c2(k2) c3(k3)]; 
e=[ce1(k1) ce2(k2) ce3(k3) ]; 
cc(k)=d*e'/sum(e); 
grad_cc(k)=min([grad_c1(k1) grad_c2(k2) grad_c3(k3) 
second_MF1(k1) second_MF2(k2) second_MF3(k3)]); 
k=k+1; 
end 
end 
end 
stem(cc,grad_cc,'linewidth',2,'markersize',1) 
set(gca,'fontweight','bold','fontsize',13,'ytick',[0:0.2:1]) 
grid on 
xlim([1 5]) 
disp('----------- left and right most points -------') 
max(cc) 
min(cc) 
%% plot centroid MFs 
figure 
subplot(3,1,1) 
stem(c1(1:length(c1)/2),grad_c1(1:length(c1)/2),'linewidth',2,'markersize',1) 
set(gca,'fontweight','bold','fontsize',13,'ytick',[0:0.2:1]) 
grid on 
xlim([1 5]) 
legend('\bf \fontsize{13} C_G_1') 
%-------------2 
subplot(3,1,2) 
stem(c2(1:length(c2)/2),grad_c2(1:length(c2)/2),'linewidth',2,'markersize',1) 
set(gca,'fontweight','bold','fontsize',13,'ytick',[0:0.2:1]) 
grid on 
xlim([1 5]) 
legend('\bf \fontsize{13} C_G_2') 
%-------------3 
subplot(3,1,3) 
stem(c2(1:length(c3)/2),grad_c3(1:length(c3)/2),'linewidth',2,'markersize',1) 
ce1=[y1_u(c1'); y1_l(c1')]; 
ce2=[y2_u(c2'); y2_l(c2')]; 
ce3=[y3_u(c3'); y3_l(c3')]; 
second_MF1=[ones(size(c1')) ; 0.5*ones(size(c1'))]; 
second_MF2=[ones(size(c2')) ; 0.8*ones(size(c2'))]; 
second_MF3=[ones(size(c3')) ; 0.4*ones(size(c3'))]; 
grad_c1=repmat(grad_c1',2,1); 
grad_c2=repmat(grad_c2',2,1); 
grad_c3=repmat(grad_c3',2,1); 
c1=repmat(c1',2,1); 
c2=repmat(c2',2,1); 
c3=repmat(c3',2,1); 
%%
(continued)3.11 Designing a General Type-2 Fuzzy System with an Example 39
Table 3.8 (continued)
k=1; 
for k1=1:length(c1) 
for k2=1:length(c2) 
for k3=1:length(c3) 
d=[c1(k1) c2(k2) c3(k3)]; 
e=[ce1(k1) ce2(k2) ce3(k3) ]; 
cc(k)=d*e'/sum(e); 
grad_cc(k)=min([grad_c1(k1) grad_c2(k2) grad_c3(k3) 
second_MF1(k1) second_MF2(k2) second_MF3(k3)]); 
k=k+1; 
end 
end 
end 
stem(cc,grad_cc,'linewidth',2,'markersize',1) 
set(gca,'fontweight','bold','fontsize',13,'ytick',[0:0.2:1]) 
grid on 
xlim([1 5]) 
disp('----------- left and right most points -------') 
max(cc) 
min(cc) 
%% plot centroid MFs 
figure 
subplot(3,1,1) 
stem(c1(1:length(c1)/2),grad_c1(1:length(c1)/2),'linewidth',2,'markersize',1) 
set(gca,'fontweight','bold','fontsize',13,'ytick',[0:0.2:1]) 
grid on 
xlim([1 5]) 
legend('\bf \fontsize{13} C_G_1') 
%-------------2 
subplot(3,1,2) 
stem(c2(1:length(c2)/2),grad_c2(1:length(c2)/2),'linewidth',2,'markersize',1) 
set(gca,'fontweight','bold','fontsize',13,'ytick',[0:0.2:1]) 
grid on 
xlim([1 5]) 
legend('\bf \fontsize{13} C_G_2') 
%-------------3 
subplot(3,1,3) 
stem(c2(1:length(c3)/2),grad_c3(1:length(c3)/2),'linewidth',2,'markersize',1) 
set(gca,'fontweight','bold','fontsize',13,'ytick',[0:0.2:1]) 
grid on 
xlim([1 5]) 
legend('\bf \fontsize{13} C_G_3') 
function [c grad_c]=centroid_MF(x1,y,second_MF) 
M=size(y,1); % discreatize of secondry MF in two point 
N=length(x1); %len 
k=1; 
n=M^N; 
for ii=N:-1:1 
a=[ones(1,k) 2*ones(1,k)]'; 
xx(:,ii)=repmat(a,n/length(a),1); 
k=k*M; 
end 
%% 
for ii=1:size(xx,1) 
for jj=1:N 
w(jj)=y(xx(ii,jj),jj); 
s_MF(jj)=second_MF(xx(ii,jj),jj); 
end 
c(ii)=x1*w'/sum(w); 
grad_c(ii)=min(s_MF); 
end40 3 Type-2 Fuzzy Systems
1 1.5 2 2.5 3 3.5 4 4.5 5 
0 
0.2 
0.4 
0.6 
0.8 
1 
Fig. 3.12 The output diagram of the center of sets
Table 3.9 The script of KM rank reduction in MATLAB 
MATLAB script for KM–EKM rank reduction 
%% KM Iterative algorithm 
%% consequent MF parameters 
clear all 
clc 
%------ height ------------
fu=[0.9000 0.8000 0.2000]'; 
fl=[0.8000 0.6000 0.1000]'; 
wr=[2 3 5]'; 
wl=[2 3 5]'; 
%------------ center of sets ------------
fu=[ 0.9000 0.8000 0.1984]'; 
fl=[ 0.8000 0.6000 0.0992]'; 
wr=[ 2.0000 3.0000 4.9744]'; 
wl=[ 2.0000 3.0000 4.9744]'; 
%------------ Modified height ------------
fu=[ 5.6250 20.0000 5.0000]'; 
fl=[ 5.0000 15.0000 2.5000]'; 
wr=[2 3 5]'; 
wl=[2 3 5]'; 
%% 
yr=wr'*(fu+fl)/2/sum((fu+fl)/2); 
yl=wl'*(fu+fl)/2/sum((fu+fl)/2); 
wr=sort(wr); 
wl=sort(wl); 
M=length(wr); 
%% find yr 
b=round(M/1.7); 
alfa=(wr(1:b)'*fl(1:b)+wr(b+1:end)'*fu(b+1:end)); 
beta=(sum(fl(1:b))+sum(fu(b+1:end))); 
yr_prim=alfa/beta; 
%--------------------------------
while(1)
(continued)3.11 Designing a General Type-2 Fuzzy System with an Example 41
Table 3.9 (continued)
a=find(yr_prim>wr(1:M-1)); 
b_prim=a(1); 
if b_prim==b 
yr=yr_prim; 
break 
else 
ii=min(b,b_prim); 
jj=max(b,b_prim); 
alfa=alfa- sign(b_prim-b)*wr(ii:jj)'*(fu(ii:jj)-
fl(ii:jj)); 
beta=beta- sign(b_prim-b)*sum(fu(ii:jj)-fl(ii:jj)); 
yr_prim=alfa/beta; 
b=b_prim; 
end 
end 
%% find yl 
b=round(M/2.4); 
alfa=(wl(1:b)'*fu(1:b)+wl(b+1:end)'*fl(b+1:end)); 
beta=(sum(fu(1:b))+sum(fl(b+1:end))); 
yl_prim=alfa/beta; 
%--------------------------------
while(1) 
a=find(yl_prim>wl(1:M-1)); 
b_prim=a(1); 
if b_prim==b 
yl=yl_prim; 
break 
else 
ii=min(b,b_prim); 
jj=max(b,b_prim); 
alfa=alfa+ sign(b_prim-b)*wl(ii:jj)'*(fu(ii:jj)-
fl(ii:jj)); 
beta=beta+ sign(b_prim-b)*sum(fu(ii:jj)-fl(ii:jj)); 
yl_prim=alfa/beta; 
b=b_prim; 
end 
end 
str=['yr=' num2str(yr) ' yl=' 
num2str(yl)]; 
disp(str) 
Table 3.10 The results of 
KM–EKM rank reduction Height yr yl 
KM 2.7778 2.5625 
EKM 2.7368 2.5625
Rule 1 : RA1 =
[
µ~A(x) ☆ μ~B(y),μ~A(x) ☆ μ~B(y)
]
Rule 2 : RA2 =
[
μ~C(x) ☆ μ~D(y),μ~C(x) ☆ μ~D(y)
]
(3.6)
where an asterisk denotes t-norm defined as a minimum or a product. If the minimum 
t-norm is used, the firing strengths will be like Fig. (3.15).42 3 Type-2 Fuzzy Systems
Fig. 3.13 Type-2 membership functions for each input
Fig. 3.14 Calculating membership degrees of each input
According to Fig. (3.16), the fired output membership functions should be written 
as below: 
Rule 1 : G'
1 = Σ
i..n
[
µG1 (zi) ☆ RA1,µG1 (zi) ☆ RA1
]
Rule 2 : G'
2 = Σ
i..n
[
µG2 (zi) ☆ RA2,µG2 (zi) ☆ RA1
] (3.7)
where the asterisk indicates t-norm.3.11 Designing a General Type-2 Fuzzy System with an Example 43
Fig. 3.15 Calculating the firing strengths of rules through minimum t-norm
Fig. 3.16 The fired output membership functions
In the next step, the combined output membership functions should be determined 
as below: 
Gc = Σ
i..n
[
µG1 ,
(
gi
)
∨ µG2 ,
(
gi
)
,µG1
(
gi
)
∨ µG2 ,
(
gi
)] (3.8) 
where ∨ indicates t-conorm.44 3 Type-2 Fuzzy Systems
3.12 Interval Type-2 Fuzzy System 
This subchapter explains how to obtain the output from an interval type-2 fuzzy 
system step by step. Consider the membership functions in Fig. (3.17) with fixed 
means and variable widths.
Fig. (3.18) depicts the schematic diagram of the interval type-2 fuzzy system 
structure with two inputs. The output of each layer is explained as below:
• Fuzzifier Layer: In this layer, each node is considered a membership function. For 
each input, N membership functions with fixed centers and variable widths are 
considered. The outputs of upper and lower bounds of this layer are as follows: 
μp 
ui 
(x) = exp 
⎛
⎝−1 
2
(
xi − x p 
i 
σu p 
i
)2 ⎞
⎠ (3.22) 
μp 
li 
(x) = exp 
⎛
⎝−1 
2
(
xi − x p 
i 
σl p 
i
)2 ⎞
⎠ (3.23) 
where μp 
ui and μp 
li denote the outputs of the pth upper-bound and lower-bound 
membership functions for the ith input.
-1.5 -1 -0.5 0 0.5 1 1.5 
0 
0.1 
0.2 
0.3 
0.4 
0.5 
0.6 
0.7 
0.8 
0.9 
1
 Time(s) 
σl 
σu 
m 
Fig. 3.17 Type-2 membership functions with fixed means and variable widths 3.12 Interval Type-2 Fuzzy System 45
1 
1 μ u
1 
2 μ u
1 
N μ u
1 
1 μ l
1 
2 μ l
1 
N μ l
2 
1 μ u
2 
2 μ u
2 
N μ u
2 
1 μ l
2 
2 μ l
2 
N μ l
1 x 
2 x 
1 
u z 
2 
u z 
N 
u z 
N 1
u z + 
N 2
u z + 
2N 
u z 
( 1) 1 NN 
u z −+ 
( 1) 2 NN 
u z −+ 
2 N 
u z 
1 
l z 
2 
l z 
N 
l z 
N 1
l z + 
N 2
l z + 
2N 
l z 
2 N 
l z 
( 1) 1 NN 
l z −+ 
( 1) 2 NN 
u z −+ 
11 
u l zw 
22 
u l zw 
LL 
u l zw 
LL 1 1
l l z w++ 
LL 2 2
l l z w++ 
MM 
l l zw 
RR 1 1
u r z w++ 
MM 
u r zw 
11 
l r zw 
RR 
l r zw 
22 
l r zw 
r y l y y 
Membership Layer Rule Layer Type Reduction Output Layer 
Fig. 3.18 The schematic diagram of an interval type-2 fuzzy system with two inputs
• Rules Layer: The nodes of this layer are called rules. In this layer, there are N2 
upper-bound rules and N2 lower-bound rules. The outputs of this layer are as 
below:46 3 Type-2 Fuzzy Systems
zj 
l (x) = μp 
l1 
(x)μq 
l2 
(x)
zj 
u(x) = μp 
u1 
(x)μq 
u2 
(x) (3.9) 
where zj 
u and zj 
l denote the jth upper-bound and lower-bound rules, respectively. 
• Type Reduction Layer: The output of this layer is as follows: 
yr =
ΣR 
j=1 zj 
l wj 
r + ΣM 
j=R+1 zj 
uwj 
r
ΣR 
j=1 zj 
l + ΣM 
j=R+1 zj 
u 
, yl =
ΣL 
j=1 zj 
uwj 
l + ΣM 
j=L+1 zj 
l wj 
l
ΣL 
j=1 zj 
u + ΣM 
j=L+1 zj 
l 
The iterative procedure for calculating R and L parameters was presented in 
[24]. Moreover, M indicates the total number of rules, whereas wj 
r and wj 
l refer 
to the weights of the jth upper-bound and lower-bound rule. If a simpler rank 
reduction method like Nie-Tan is used, then: 
yr =
ΣM 
j=1 zj 
uwj 
r
ΣM 
j=1 zj 
u 
, yl =
ΣM 
j=1 zj 
l wj 
l
ΣM 
j=1 zj 
l 
(3.10) 
• Output Layer: The output will finally be as follows: 
y = yr + yl 
2 (3.24) 
3.13 Conclusion 
This chapter explained type-2 fuzzy systems theoretically and completely in plain 
language. Their differences from type-1 fuzzy systems were also discussed. In fact, 
this chapter gave an overview of interval type-2 fuzzy systems. In general, type-2 
fuzzy systems have been developed in recent years. Enthusiasts can see the rele￾vant papers. In addition to this chapter, the materials will be presented as tutorial 
videos at our website (http://www.simref.org). Different methods of the fuzzy system 
optimization will then be discussed. 
References 
1. C.G. Moore, C.J. Harris, Indirect adaptive fuzzy control. Int. J. Control 56, 441–468 (1992) 
2. Y.W. Cho, C.W. Park, M. Park, An indirect model reference adaptive fuzzy control for SISO 
Takagi-Sugeno model. Fuzzy Sets Syst. 131, 197–215 (2002) 
3. C.W. Park, Y.W. Cho, T-S model based indirect adaptive fuzzy controlusing online parameter 
estimation. IEEE Trans. Syst. Man Cybern. Part B-Cybern. 34, 2293–2302 (2004)References 47
4. C.W. Park, M. Park, Adaptive parameter estimator based on T-S fuzzymodels and its 
applications to indirect adaptive fuzzy control design. Inf. Sci. 159, 125–139 (2004) 
5. L.X. Wang, Combining mathematical model and heuristics into controllers: An adaptive fuzzy 
control approach. Fuzzy Sets Syst. 89, 151–156 (1997) 
6. M. Hojati, S. Gazor, Hybrid adaptive fuzzy identification and control of nonlinear systems. 
IEEE Trans. Fuzzy Syst. 10, 198–210 (2002) 
7. M.J. Er, S.H. Chin, Hybrid adaptive fuzzy controllers of robot manipulators with bounds 
estimation. IEEE Trans. Ind. Electron. 47, 1151–1160 (2000) 
8. C.H. Wang, T.C. Lin, T.T. Lee, H.L. Liu, Adaptive hybrid intelligent control for uncertain 
nonlinear dynamical systems. IEEE Trans. Syst. Man Cybern. Part B-Cybern. 32, 583–597 
(2002) 
9. S.C. Tong, T.Y. Chai, Fuzzy indirect adaptive control for a class of decentralized nonlinear 
systems. Int. J. Syst. Sci. 29, 149–157 (1998) 
10. B. Yoo, W. Ham, Adaptive fuzzy sliding mode control of nonlinear system. IEEE Trans. Fuzzy 
Syst. 6, 315–321 (1998) 
11. S.C. Tong, T. Wang, J.T. Tang, Fuzzy adaptive output tracking control of nonlinear systems. 
Fuzzy Sets Syst. 111, 169–182 (2000) 
12. Y.C. Chang, Adaptive fuzzy-based tracking control for nonlinear SISO systems via VSS and 
H-infinity approaches. IEEE Trans. Fuzzy Syst. 9, 278–292 (2001) 
13. Y.X. Diao, K.M. Passino, Stable fault-tolerant adaptive fuzzy/neural control for a turbine 
engine. IEEE Trans. Control Syst. Technol. 9, 494–509 (2001) 
14. C.L. Hwang, C.Y. Kuo, A stable adaptive fuzzy sliding-mode control for affine nonlinear 
systems with application to four-bar linkage systems. IEEE Trans. Fuzzy Syst. 9, 238–252 
(2001) 
15. W.Y. Wang, Y.G. Leu, C.C. Hsu, Robust adaptive fuzzy-neural control of nonlinear dynamical 
systems using generalized projection update law and variable structure controller. IEEE Trans. 
Syst. Man Cybern. Part B-Cybern. 31, 140–147 (2001) 
16. J.H. Park, S.J. Seo, G.T. Park, Robust adaptive fuzzy controller for nonlinear system using 
estimation of bounds for approximation errors. Fuzzy Sets Syst. 133, 19–36 (2003) 
17. C.M. Lin, C.F. Hsu, Adaptive fuzzy sliding-mode control for induction servomotor systems. 
IEEE Trans. Energy Convers. 19, 362–368 (2004) 
18. Y.G. Leu, T.T. Lee, W.Y. Wang, Observer-based adaptive fuzzy-neuralcontrol for unknown 
nonlinear dynamical systems. IEEE Trans. Syst. Man Cybern. Part B-Cybern. 29, 583–591 
(1999) 
19. Rubaai, Direct adaptive fuzzy control design achieving H-infinity trackingfor high performance 
servo drives. IEEE Trans. Energ. Convers. 14, 1199–1208 (1999) 
20. T.Y. Chai, S.C. Tong, Fuzzy direct adaptive control for a class of nonlinear systems. Fuzzy Sets 
Syst. 103, 379–387 (1999) 
21. B.S. Chen, C.S. Wu, Y.W. Jan, Adaptive fuzzy mixed H-2/H-infinity, attitude control of 
spacecraft. IEEE Trans. Aerosp. Electron. Syst. 36, 1343–1359 (2000) 
22. W.Y. Wang, M.L. Chan, T.T. Lee, C.H. Liu, Adaptive fuzzy controlfor strict-feedback canonical 
nonlinear systems with H-infinity trackingperformance. IEEE Trans. Syst. Man Cybern. Part 
BCybernetics 30, 878–885 (2000) 
23. S.C. Tong, H.X. Li, Direct adaptive fuzzy output tracking control of nonlinear systems. Fuzzy 
Sets Syst. 128, 107–115 (2002) 
24. N. Hovakimyan, F. Nardi, A.J. Calise, A novel error observer-basedadaptive output feedback 
approach for control of uncertain systems. IEEE Trans. Autom. Control 47, 1310–1314 (2002)Chapter 4 
Training Interval Type-2 Fuzzy Systems 
Based on Error Backpropagation 
4.1 Introduction 
This chapter introduces various methods for optimizing an interval type-2 fuzzy 
system through different examples with real data to evaluate the performance of 
the training method, which will be the error backpropagation method, whereas the 
optimization methods will be gradient descent, Kalman filter, and genetic algorithm. 
In the first subchapter, a fuzzy system is considered with simple rank reduction, and 
a fuzzy system with KM–EMK rank reduction will then be addressed. Based on the 
consequent parameters, the antecedent parameters (i.e., parameters of membership 
functions) will also be trained. 
4.2 Training Fuzzy Systems with Nie-Tan Type-Reduction 
First, consider an interval type-2 fuzzy system with two inputs. The rules of this 
fuzzy system are as follows: 
if x1 is A˜11 and x2 is A˜21 then y ∈ [
w1, w1 ]
if x1 is A˜11 and x2 is A˜22 then y ∈ [
w2, w2 ]
if x1 is A˜12 and x2 is A˜21 then y ∈ [
w3, w3 ]
(4.1) 
where A˜ij , i = j = 1, 2 is the jth Gaussian membership function for the ith input, 
and wi , wi , i = 1, 2, 3 are the consequent parameters corresponding to the rules. 
After the Nie-Tan rank reduction is applied, the output of the fuzzy system will be 
as follows: 
f = f + f 
2 (4.2)
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
A. Mohammadzaheh et al., Modern Adaptive Fuzzy Control Systems, Studies in Fuzziness 
and Soft Computing 421, https://doi.org/10.1007/978-3-031-17393-6_4 
4950 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
where 
f = w1z1 + w2z2 + w3z3 
z1 + z2 + z3 
, f = w1z1 + w2z2 + w3z3 
z1 + z2 + z3 
(4.3) 
z1 = μA˜11 μA˜21 , z1 = μA˜11 
μA˜21 
z2 = μA˜11 μA˜22 , z2 = μA˜11 
μA˜22 
,
z3 = μA˜12 μA˜21 , z3 = μA˜12 
μA˜21 
(4.4) 
μA˜ij 
= exp (x − C A˜ij 
σ A˜ij )2 
μA˜ij = exp (x − C A˜ij 
σ A˜ij )2 
(4.5) 
where C A˜ij denotes the center. In addition, σ A˜ij and σ A˜ij refer to the widths of the 
lower and upper bounds, respectively, in the membership function A˜ij . 
The consequent parameters and the centers of the membership functions in this 
fuzzy system should be adjusted to minimize the cost function: 
E(t) = 1 
2 
e2 = 1 
2 
(yd (t) − f (t))2 (4.6) 
where yd and f refer to the favorable output and the fuzzy system output, respectively. 
Based on the gradient descent optimization, the rule for updating parameters should 
be as follows: 
wi = wi − η
∂E 
∂wi 
wi = wi − η
∂E 
∂wi 
CAij = CAij − η
∂E 
∂CAij 
(4.7) 
where η denotes the training step which is a constant between 0 and 1; therefore: 
wi (t + 1) = wi (t) + ηe z/i Σ
M
i=1 
zi 
wi (t + 1) = wi (t) + ηe zi /
Σ
M
i=1 
zi (4.8)4.3 Fuzzy System with KM-EKM Type-Reduction 51
where M indicates the number of rules. 
To train the centers of the membership functions, it is necessary to determine 
in which rules these centers emerge. For instance, the membership function A11 
emerged in the first and third rules based on the form of rules in (4.4) to find the 
training rule CA11 (i.e., the first membership function for the first input). Hence: 
df 
dc11 
=
(
w1z'
1 + w2z'
2 )
(z1 + z2 + z3) − (
z'
1 + z'
2 )
(w1z1 + w2z2 + w3z3)
(z1 + z2 + z3)
2 
=
(
w1z'
1 + w2z'
2 )
(z1 + z2 + z3) −
(
z'
1 + z'
2 )
(z1 + z2 + z3)
(w1z1 + w2z2 + w3z3)
(z1 + z2 + z3)
=
(
w1z'
1 + w2z'
2 )
(z1 + z2 + z3) −
(
z'
1 + z'
2 )
(z1 + z2 + z3)
f 
=
(x−c11)
σ2 
11 
(w1z1 + w2z2)
(z1 + z2 + z3) −
(x−c11)
σ2 
11 
(z1 + z2)
(z1 + z2 + z3) f (4.9) 
4.2.1 Implementation in MATLAB 
In this subchapter, the interval type-2 fuzzy system is used in a classification example. 
There are data of 10 types of signals that should be classified. Each signal has 32 
features, and there are 1024 data of each signal. Therefore, the total number of data 
is 10240. The data of this example can be downloaded from http://www.simref.org/ 
fs_matlab/ (Session 10). 
The consequent parameters and the centers of the membership functions should 
be adjusted with respect to the abovementioned method. Moreover, 70% and 30% of 
data selected randomly for training and testing, respectively. Table 4.1 presents the 
MATLAB script. 
4.3 Fuzzy System with KM-EKM Type-Reduction 
This subchapter presents a comprehensive script for training all parameters of the 
type-2 fuzzy system with the KM–EKM rank reduction. In comparison with the 
previous subchapter, updating consequent and antecedent parameters would also 
depend on the rank reduction parameters. 
Consider the fuzzy system from the previous subchapter one more time, and 
assume the rank reduction parameters to be R = 2, L = 1. In this case, the output 
of the fuzzy system f is as follows:52 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
f = 1 
2 
(
f + f )
f = w1z1 + w2z2 + w3z3 
z1 + z2 + z3 
, f = w1z1 + w2z2 + w3z3 
z1 + z2 + z3 
(4.10) 
The above equations should be rewritten as below to write the script in a vector 
form: 
f = w [
R'
z + (
1 − R'
)
z ]
sum ([R'
z + (1 − R'
)z ]) ,
f = w
[
L'
z + (
1 − L'
)
z ]
sum ([L'
z + (1 − L'
)z ]) R = 2, L = 1 
R' =
⎡
⎣
100 
0 1 0 
000 
⎤
⎦, L' =
⎡
⎣
100 
000 
000 
⎤
⎦ (4.11) 
where w = [w1, ..., wM ]
T , w = [
w1, ..., wM ]T 
, z = [z1, ...,zM ]
T , and z = [
z1, ...,zM ]T . Moreover, M refers to the number of rules in the above fuzzy system 
(M = 3). 
The previous example is considered again for implementation in MATLAB. Table 
4.2 presents the MATLAP script. 
4.4 Training Type-2 Fuzzy System with Extended Kalman 
Filter 
Consider the following nonlinear system: 
xk = f (xk−1, uk ) + N (0, Q)
zk = h(xk ) + N (0, R) (4.12) 
where N (0, Q) denotes the process noise with a mean of zero and a variance of 
Q. Moreover, N (0, R) is the measurement noise with a variance of R. The Jacobi’s 
formulas of f and h should be determined through the Kalman filter to estimate the 
system states (4.12). The fuzzy system should first be written in the state space form 
to use the developed Kalman filter for training the fuzzy system: 
wk = wk−1 + N (0, Q)
ok = F N N (uk , wk ) + N (0, R) (4.13)4.4 Training Type-2 Fuzzy System with Extended Kalman Filter 53
where FNN denotes a fuzzy system, and wk indicates the parameters of a fuzzy 
system that should be adjusted. Hence: 
Kk = P−
k H T (H P−
k H T + R)
−1 
wˆ k = ˆw−
k + Kk (dk − F N N (wˆ k ))
Pk = (I − Kk H )P−
k (4.14) 
where H is the derivative vector of the fuzzy system output based on the adjustable 
parameters. Consider the previous example one more time for implementation in 
MATLAB: 
%clear all 
clc 
%% Load data 
load data_classification 
%% Input data 
Train_data=reshape(Xtrain,size(Xtrain,1),size(Xtrain,2)*size(Xtrain,3)); 
Target_train=repmat([1:10],size(Xtrain,2),1); 
Target_train=reshape(Target_train,numel(Target_train),1); 
%---------------------------
Test_data=reshape(Xtest,size(Xtest,1),size(Xtest,2)*size(Xtest,3)); 
Target_test=repmat([1:10],size(Xtest,2),1); 
Target_test=reshape(Target_test,numel(Target_test),1); 
%% FS Initial parameters 
cu=reshape(mean(Xtrain,2),23,10); 
cl=cu; 
%c=repmat(0.5,23,1); 
sigmau=1*ones(size(cu)); 
sigmal=0.1*ones(size(cl)); 
rule=[1:10]'*ones(1,23); 
wu=eye(10); 
wl=eye(10); 
eta=0.01; 
%% 
Pu=repmat(1e-3*eye(size(wu,1)),1,1,10); 
Pl=repmat(1e-3*eye(size(wl,1)),1,1,10); 
% rule=generate_rule(23,1); 
% w=rand(size(rule,1),10); 
%% Train =================================================== 
mse_min=100; 
for epoch=1:2054 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
%% Train 
E=0; 
nn=randperm(size(Train_data,2)); 
for ii=nn 
x=Train_data(:,ii); 
o=FS_type_2(x,cu,cl,sigmau,sigmal,wu,wl,rule); 
O_target=zeros(10,1); 
O_target(Target_train(ii))=1; 
e=O_target-o; 
[do_dwu,do_dcu,do_dsigmau,do_dwl,do_dcl,do_dsigmal]=... 
do_param(e,x,cu,cl,sigmau,sigmal,wu,wl,rule); 
[wu33,cu,sigmau,wl33,cl,sigmal]=... 
GD_FS(e,eta,do_dwu,do_dcu,do_dsigmau,wu,cu,sigmau,do_dwl,do_dcl,do_dsigmal,wl,cl,sigmal); 
for ii=1:10 
[wl(:,ii),Pl(:,:,ii)]=EKF(e(ii),wl(:,ii),Pl(:,:,ii),do_dwl); 
[wu(:,ii),Pu(:,:,ii)]=EKF(e(ii),wu(:,ii),Pu(:,:,ii),do_dwu); 
end 
E=E+norm(e)^2; 
end 
epoch 
mse_train=E/size(Train_data,2) 
MSE_Train(epoch)= E/size(Train_data,2); 
if mse_train<mse_min 
mse_min=mse_train; 
cu_best=cu; 
wu_best=wu; 
sigmau_best=sigmau; 
cl_best=cl; 
wl_best=wl; 
sigmal_best=sigmal; 
end 
%% Test 
% E=0; 
% for ii=1:size(Test_data,2) 
% x=Test_data(:,ii); 
% [o1,o2,net1,net2]=FeedForward_NN(x,b1,b2,w1,w2); 
% O_target=zeros(10,1); 
% O_target(Target_test(ii))=1; 
% e=O_target-o2; 
% E=E+norm(e)^2; 
% end 
% mase_test=E/size(Test_data,2) 
% MSE_Test(epoch)=E/size(Test_data,2); 
end 
%% plot MSE 
%% 
plot(MSE_Train(1:end),'--b','linewidth',2) 
% hold on 
% plot( MSE_Test,'--r','linewidth',2) 
%% Test ================================================================= 
C=zeros(10,10); 
for ii=1:size(Test_data,2) 
x=Test_data(:,ii); 
o=FS_type_2(x,cu_best,cl_best,sigmau_best,sigmal_best,wu_best,wl_best,rule); 
O_target=zeros(10,1); 
O_target(Target_test(ii))=1; 
[a,b]=max(abs(o)); 
C(b,Target_test(ii))=C(b,Target_test(ii))+1; 
end 
C 
sum(sum(C.*eye(10)))*100/size(Test_data,2) 
The script for calculating the derivative of the fuzzy system output based on parameters 
function 
[do_dwu,do_dcu,do_dsigmau,do_dwl,do_dcl,do_dsigmal]=do_param(e,u,cu,cl,sigmau,sigmal,wu,wl,rule)4.4 Training Type-2 Fuzzy System with Extended Kalman Filter 55
% u is n*1 where n is number of inputs 
% c is n*n_MF where n_MF is the number of MFs for this input 
% the dimension of sigma is the same as c 
% the variable rule represent the rule database. 
% rule is n_rule*n, where n_rule is the number of rules 
%% 
% clear all 
% clc 
% u=[1 2]'; 
% c=[-1 0 1;-1 0 1]; 
% sigma=ones(size(c)); 
% rule=[1 3; 2 3]; 
% w=rand(2,1); 
%% FS 
%% MF 
n_MF=size(cu,2); 
x=repmat(u,1,n_MF); 
MFu= exp(-(x-cu).^2./sigmau.^2); 
MFl= exp(-(x-cl).^2./sigmal.^2); 
%% Rule fiering 
for ii=1:size(rule,1) 
au(:,ii)=MFu(ii,rule(:,ii)); 
al(:,ii)=MFl(ii,rule(:,ii)); 
end 
zu=prod(au,2);%min 
zl=prod(al,2);%min 
%% Type reduction 
%z=(zu+zl)/2; % Nie-Tan 
szu=(sum(zu)+0.0001); 
do_dwu=zu/szu; 
ou=do_dwu'*wu; 
szl=(sum(zl)+0.0001); 
do_dwl=zl/szl; 
ol=do_dwl'*wl; 
%% do-dparam 
for ii=1:size(rule,2) 
for jj=1:size(cu,2) 
b=rule(:,ii)==jj; 
%------------- upper ------------
zprim=b.*zu; 
do_dcu(ii,jj,:)=(u(ii)-cu(ii,jj))./sigmau(ii,jj)^2*(zprim'*wu)./szu-sum(zprim)*ou/szu; 
do_dsigmau(ii,jj,:)=(u(ii)-cu(ii,jj))^2./sigmau(ii,jj)^3*(zprim'*wu)./szu￾sum(zprim)*ou/szu; 
%------------- lower ----
zprim=b.*zl; 
do_dcl(ii,jj,:)=(u(ii)-cl(ii,jj))./sigmal(ii,jj)^2*(zprim'*wl)./szl-sum(zprim)*ol/szl; 
do_dsigmal(ii,jj,:)=(u(ii)-cl(ii,jj))^2./sigmal(ii,jj)^3*(zprim'*wl)./szl￾sum(zprim)*ol/szl; 
end 
end 
The script for the developed Kalman filter 
%% UKF 
function [w,P]=EKF(e,w,P,H) 
% global sat_up 
%% 
R=0.001; 
Q=1e-8*eye(size(P)); 
k=P*H*((R+H'*P*H)\1); 
P=(eye(length(w))-k*H')*P+Q; 
w=w+k*e;%P*H; 
The interval type-2 fuzzy system 
function y=FS_type_2(u,cu,cl,sigmau,sigmal,wu,wl,rule)56 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
% u is n*1 where n is number of inputs 
% c is n*n_MF where n_MF is the number of MFs for this input 
% the dimension of sigma is the same as c 
% the variable rule represent the rule database. 
% rule is n_rule*n, where n_rule is the number of rules 
%% 
% clear all 
% clc 
% u=[1 2]'; 
% c=[-1 0 1;-1 0 1]; 
% sigma=ones(size(c)); 
% rule=[1 3; 2 3]; 
% w=rand(2,1);-2 2 
%c=[-2 -1 0 1 2;3 4 0 5 6] 
%% MF 
n_MF=size(cu,2); 
x=repmat(u,1,n_MF); 
MFu= exp(-(x-cu).^2./sigmau.^2); 
MFl= exp(-(x-cl).^2./sigmal.^2); 
%% Rule fiering 
for ii=1:size(rule,2) 
au(:,ii)=MFu(ii,rule(:,ii)); 
al(:,ii)=MFl(ii,rule(:,ii)); 
end 
zu=prod(au,2);%min 
zl=prod(al,2);%min 
%% Type reduction 
%z=(zu+zl)/2; % Nie-Tan 
szu=(sum(zu)+0.0001); 
do_dwr=zu/szu; 
ou=do_dwr'*wu; 
szl=(sum(zl)+0.0001); 
do_dwl=zl/szl; 
ol=do_dwl'*wl; 
y=(ou'+ol')/2; 
4.5 Training Type-2 Fuzzy System Based on Genetic 
Algorithm 
4.5.1 Introduction 
4.5.1.1 What Is the Genetic Algorithm? 
The genetic algorithm (GA) is a search technique in the computer science for finding 
an approximate solution to optimization and search problems.1 The GA is a specific 
type of evolutionary algorithms using biological techniques such as heredity and 
mutation. 
Known as a random method of finding optima, the GA was invented by John 
Holland in 1967. It was then improved by Goldberg, who has made it find a good 
position among the other methods. 
The genetic algorithms are usually implemented as a computer simulator in which 
the population of an abstract sample (i.e., chromosomes) of candidate solutions for 
an optimization problem will lead to a better solution. Conventionally, the solutions 
used to be like strings of 0’s and 1’s; however, they are now implemented in different
1 http://www.beytoote.com/scientific/midanid/genetic-algorithms.html. 4.5 Training Type-2 Fuzzy System Based on Genetic Algorithm 57
forms. In this algorithm, a hypothesis begins with a completely random and unique 
population and continues through generations. In each generation, the capacity of the 
entire population is evaluated, and several unique members are selected in a random 
process of the current generation (based on fitness values). They are then modified 
(i.e., subtracted or recombined) and converted into the current generation in the next 
iteration of the algorithm. 
For instance, if it is desired to model the petroleum price fluctuations through 
external factors and the simple linear regression value, the following formula will be 
generated: 
Petroleum price at t—rate of interest multiplied by 1 at t + unemployment rate 
multiplied by 2 at t + 1. 
After that, a criterion will be utilized to find the best set of coefficients and 
constants to model the petroleum price. There are two main points in this method. 
First, this method is linear. Second, the usable parameters are determined instead of 
searching the “space of parameters”. 
The genetic algorithm is employed to develop a super formula or scheme which 
expresses something like “petroleum price at t is a function of four variables at 
most”. Afterwards, data will be collected for different variables—perhaps nearly 20 
variables. The genetic algorithm will then be executed to search for the best functions 
and variables. The GA mechanism is so interestingly simple, very perceivable, and 
considerably clear that we believe that animals have developed in the same way. 
Any formulas following the abovementioned scheme is considered a member in the 
population of possible formulas. 
The variables that determine any given formula is shown as a series of numbers 
constituting the equivalent of that member. 
The GA engine generates an initial population of formulas. Each member is tested 
with a set of data, and the most appropriate member—10% of the best members 
probably—will remain, and the rest of the members are left out. The most appro￾priate members mate (i.e., exchange the DNA elements) and change (i.e., change the 
DNA elements randomly). After many generations, the GA evidently approaches the 
generation of more accurate formulas. However, neural networks are both nonlinear 
and nonparametric. The genetic algorithms are really interesting because their final 
results are more notable than those of the other methods. The final formula will be 
visible to the human user, and common statistical techniques can be applied to these 
formula to present the reliability of results. The technology of genetic algorithms is 
always improving. For instance, the equations of viruses are presented along with 
formulas in addition to violating the weak formulas of production; thus, they make 
the population stronger in general. 
In brief, the GA can be considered a programing technique that uses the genetic 
evolution as a problem-solving model. The problem that should be solved is the input, 
and its solutions are coded in accordance with a pattern called the fitness function 
evaluating each candidate solution. Most of these solutions are selected randomly.58 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
The GA is a search technique in the computer science for finding optimal solu￾tions to search problems. The genetic algorithms are classified as evolutionary algo￾rithms inspired by biological concepts such as heredity, mutation, [sudden selection 
(biology)| sudden selection], natural selection, and crossover. 
Generally, solutions are shown as binary sets consisting of 0’s and 1’s, although 
there are other methods. Evolution begins with a completely random set of entities and 
continues in the next generations. In each generation, the most appropriate solutions 
are selected, not the best ones. 
A solution to a problem of interest is shown with a list of parameters called 
chromosomes or genomes. The chromosomes are generally displayed as a simple 
string of data. However, other data structures can also be used. A few attributes are 
first generated randomly to create the first generation. Along each generation, each 
attribute is evaluated, and the fitness value is measured by the fitness function. 
The next step is to create the second generation of the population. Based on the 
selection processes, the generation is obtained from the attributes selected by genetic 
algorithm: connecting chromosomes head to head and making changes. 
A pair of parents should also be selected for each individual. In fact, the most 
appropriate elements are selected so that the weakest elements can even have the 
chance to be selected. Therefore, it is possible to avoid approaching the local solution. 
There are several selection models such as the roulette wheel and the tournament. 
Genetic algorithms usually have a connection probability value that ranges 
between 0.6 and 1. It indicates the probability that a child is created. Organisms 
are recombined with this probability. The connection of two chromosomes leads 
to the creation of a child, which is added to the next generation. These tasks are 
performed to find appropriate candidate solutions in the next generation. The next 
step is to modify the new offspring. The genetic algorithms have a low constant 
probability of change which is nearly 0.01 or smaller. Accordingly, the offspring 
chromosomes change randomly or are mutated, especially with the mutation of bits 
in the data structure chromosome. 
This process leads to the creation of a new generation of chromosomes different 
from the previous generation. The entire process is iterated for the next generation, 
and the pairs are selected for crossovers in order to create the next generation. This 
process is repeated until the last step is reached. 
4.5.1.2 Operators of a Genetic Algorithm 
In every problem, two elements are required before the genetic algorithm can be 
employed to find a solution. First, there should be a method for offering a solution 
on which the genetic algorithm can operate. Conventionally, a solution is displayed 
as a string of bits, numbers, or characters. Second, there should be a method for 
determining the quality of any proposed solutions through fitness functions. For 
instance, if any possible weights are considered appropriate for a backpack in a 
problem where the backpack does not break (refer to the backpack problem), a method 
of offering a solution can be regarded as a string of bits (i.e., 1 and 0 denoting the4.6 Calling Genetic Algorithm 59
inclusion or exclusion of weights in the backpack). The solution fitness is measured 
by determining the total weight for the proposed solution. 
The procedure for finding optima in the genetic algorithm is based on the random￾directed process. In fact, this method is based on the gradual evolution theory and 
Darwin’s fundamental ideas. In this method, a set of target parameters is first gener￾ated randomly for a fixed number of members called the population. After the simu￾lation program is executed, a number is attributed to that member of the population. 
This number represents the standard deviation or fitness of that set of information. 
This process is iterated for each and every new member. The operators of the genetic 
algorithm (i.e., crossover, mutation, and selection) are then summoned to create the 
next generation. This procedure is iterated until the convergence criterion is met [1]. 
Usually, there are three termination criteria: (1) algorithm runtime; (2) the number 
of generations created; (3) convergence of error criterion. 
4.5.1.3 Applications of the Genetic Algorithm 
• Hydrological trending of the current runoff in an arid river network 
• Helping solve multiple-criteria decision-making (MCDM) problems 
• Multiobjective optimization in the water resources management 
• Optimizing and rearranging power distribution grids. 
The termination conditions of the genetic algorithms: 
(1) A constant number of generations is reached. 
(2) The allocated budget is over (calculation time/money). 
(3) An individual (i.e., offspring) meets the minimum (lowest) criterion. 
(4) The highest degree of offspring fitness is obtained, or no better results are 
obtained. 
(5) Manual inspection. 
4.5.1.4 Genetic Algorithm in MATLAB 
4.6 Calling Genetic Algorithm 
Type the following command in the command prompt to use this algorithm: 
[X fval] = ga(@ fitnessfun, nvars. options). 
Where @fitnessfun denotes the cost function, and the x variables should be 
determined to minimize this function. Moreover, nvars represents the number of 
independent variables in the function. 
Therefore: 
• fval indicates the final value of the function. 
• x represents a point at which the function is optimal. 
– Using the GA Toolkit60 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
Fig. 4.1 The GA toolkit 
This toolkit is a graphical toolbox that enables users to employ the algorithm 
without using the command prompt. Type the following command and press Enter: 
>gatool. 
The following window pops up: (Fig. 4.1). 
– Fitness Function: In this section, you can type the function that needs to be 
optimized. 
– Number of Variables: This section indicates the number of independent variables 
in the function. 
To start solving the problem, click on Start in Run Solver. 
In Current Generation, the number of generations is explained. You can stop the 
solution process temporarily by clicking on Pause. 
The following information is displayed in Status and Result: 
• The final value of the function when the algorithm is over. 
– The reason for ending the algorithm 
– The point at which the function is optimal. 
In Plots, you can see different types of information when the program is running. 
Observing the results and making appropriate changes, you can reach a better solu￾tion. You can also see the best function and the average function of each generation 
by selecting Best Fitness (Figs. 4.2 and 4.3).
Example Consider Rastrigin’s function with two independent variables. 
Ras(x) = 20 + x 2 
1 + x 2 
2 − 10(cos 2πx1 + cos 2πx2)4.6 Calling Genetic Algorithm 61
Fig. 4.2 Configurations of the diagram presentation 
0 20 40 60 80 100 120 140 160 180 200 
0 
50 
100 
150 
200 
250 
300 
350 
400 
450 
500 
Generation 
Fitness value 
Best: 1.10431 Mean: 45.1691 
Best fitness 
Mean fitness 
Fig. 4.3 Changes in the cost function
This function has many local minimums; however, it has an absolute minimum at 
[0.0] where its value is zero. 
– Type gatoal in the command prompt. 
– Enter @rastriginsfcn in Fitness Function. 
– Type 2 in Number Variable.62 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
– The algorithm starts operating as soon as Start is clicked. The above figures depict 
the results. 
4.7 Jargons of GA Toolkit in MATLAB 
• Individuals 
For instance, vector (2, 3, 1) is an individual, and f(2, 3, 1) = 51 is this individual’s 
score. The individuals might be introduced as a gene. 
• Population and Generation 
A population is an array of individuals. For instance, if a function has three variables 
with a population of 100, there will be an array of 100 × 3. 
• Diversity 
The mean distance of individuals is defined, and the population with a large mean 
distance has diversity. 
• Fitness Values and Best Fitness Values 
The fitness value indicates the value of the function for different individuals. Since 
this toolkit is employed to find the lowest fitness value, the best fitness of a population 
is the lowest fitness. 
• Parents and Children 
To create the next generation, the GA selects some individuals called parents from the 
current generation and uses them to create the next generation that includes children. 
This algorithm selects the parents with better fitness values. 
The following steps are taken to minimize this algorithm: 
(1) The algorithm selects the initial population randomly. 
(2) The algorithm creates the next generation from the current generation. For this 
purpose, the following tasks are performed by the algorithm. 
• Scoring each member of the population by determining the fitness value 
• Scaling the scores given to better use the scores and the population 
• Selecting children from parents: reproduction by changing the organs of one 
of the parents—genetic mutation or crossover of parents for reproduction 
• Selecting parents based on fitness 
• Replacing the new generation with the old generation 
(3) This algorithm ends when it reaches the termination criterion. 
• The Algorithm Termination Conditions 
This algorithm uses five conditions for termination:4.7 Jargons of GA Toolkit in MATLAB 63
Fig. 4.4. The termination conditions of the algorithm in the genetic toolkit 
• Generations: when the number of generations reaches a certain quantity. 
• Time limit: when the runtime reaches a certain quantity. 
• Fitness limit: when the fitness value of the function is smaller than a certain 
quantity in the best point of the current generation. 
• Stall generations: when no better variables are created in generations. 
• Stall time limit: when no better variables are created, the algorithm ends between 
two points of time in seconds. 
If each of these conditions occurs first, the algorithm ends (refer to the following 
figure): (Fig. 4.4). 
• Plot Option: 
The process of executing the program can be observed by activating the items in 
Plot. 
The following functions are available in Plot: 
– Plot Interval (PlotInterval): the number of generations used in the plot 
– Best Fitness (@gaplotbestf ): drawing the best value of the function in each 
generation 
– Expectation (@gaplotexpectation): drawing the expected number of children in 
relation to the scores of each generation 
– Score Diversity (@gaplotscorediversity): drawing a histogram of scores for each 
generation 
– Stopping (@plotsopping): drawing the termination condition at each level 
– Best Individual (@gaplotbestindiv): drawing each individual’s vector with the 
best fitness64 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
– Genealogy (@gaplotgenealogy): drawing the production type of the next gener￾ation 
– Scores (@gaplotscores): drawing each individual’s score in its own generation 
– Distance (@gaplotdistance): drawing the mean distance between individuals in 
each generation 
– Range (@gaplotrange): drawing the minimum, maximum, and mean values of 
the function in each generation 
– Selection (@gaplotselection): drawing the histogram of parents. 
• Population Option 
– Population tyme: determining the input information for the fitness function 
– Population sice: determining the number of individuals in each generation— 
With a larger population, the algorithm checks a larger number of fitness values, 
and the chance of finding a relative extremum reduces in comparison with the 
absolute extremum; however, the solution is found more slowly. 
– Create function: determining a function to obtain the initial population 
– Initial population: enabling users to determine the number of individuals of 
the score and the range in the initial population (refer to the following figure): 
(Fig. 4.5) 
• Fitness Scaling Option 
This function converts the score of each fitness value into a specific scale that is 
appropriate for the selection function. The presumption of this section is the rank.
Fig. 4.5 Population toolkit 4.7 Jargons of GA Toolkit in MATLAB 65
Scaling is based on each individual’s layout instead of using the proportional score 
of scaling based on each individual’s score (refer to the following figure): 
• Selection option 
This option determines on what basis the algorithm selects parents to create the next 
generation: (Fig. 4.6). 
Fig. 4.6 Toolkit of selection methods66 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
Fig. 4.7 Iteration toolkit 
• Reproduction: 
This option determines on what basis the algorithm selects children for the next 
generation (refer to the following figure): (Fig. 4.7). 
• Mutation option: 
This option determines how the algorithm makes a random slight change in each 
individual for the genetic mutation, which allows the algorithm to adopt a wider 
space (refer to the following figure) (Fig. 4.8). 
• Crossover:
Fig. 4.8 Different methods of mutation 4.7 Jargons of GA Toolkit in MATLAB 67
Fig. 4.9 Different crossover methods 
This option determines how the algorithm generates two new individuals (refer to 
the following figure) (Fig. 4.9). 
• Migration option: 
This option determines how the individuals migrate across subpopulations. In fact, 
migration occurs when the population vector is larger than 1. In this case, the best 
individuals of a population are replaced with the worst individuals of another subpop￾ulation. This replacement is in the form of a copying process (refer to the following 
figure). 
• Hybrid function option: 
This is another optimization function. If activated, it will be executed once the GA 
ends (refer to the following figure) (Fig. 4.10).68 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
Fig. 4.10 Different methods of hybrid optimization 
Fig. 4.11 The GA output
4.7.1 GA-Based Optimization of Neuro-Fuzzy System 
Parameters 
Let us estimate the following nonlinear function using interval type-2 fuzzy systems: 
y(t) = y(t − 1)/(1 + y(t − 1)
2 ) + u(t − 1)
3 (4.15) 
where u = sin(2πn/100), ts = 100/500, n = 0:ts:100.4.7 Jargons of GA Toolkit in MATLAB 69
0 10 20 30 40 50 60 70 80 90 100
-1.5
-1
-0.5 
0 
0.5 
1 
1.5
 Estimated
 Target 
Fig. 4.12 The real outputs and the fuzzy estimated output
For this purpose, 500 input–output data are generated, and 400 of which are 
selected randomly as the training data, and the rest as the test data. Use the following 
script to generate test and training data. 
The initialization script clear all 
clc 
global cl cu sigmau sigmal rule 
global Test_data Target_test Train_data Target_train 
num_out=1; 
num_in=2; 
%% =================================== 
ts=100/500; 
n=0:ts:100; 
% 
u(:,1)=sin(2.*pi.*n./100); 
% n=1:500; 
% u(:,1)=sin(2.*pi.*n./25); 
% y(1,1)=0; 
y(2,1)=0; 
% y(31,1)=1.2; 
% a=0.1; b=0.2*0.1; tav=30; 
for t=3:length(u);70 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
% y(t,1)=(1-a).*y(t-1,1)+b.*y(t-tav-1,1)./(1+y(t-tav-1,1).^10); 
%y(t,1)=-0.1.*y(t-1,1)+0.2.*y(t-tav-1,1)./(1+y(t-tav-1,1).^10); 
y(t,1) =y(t-1,1)/( 1 + y(t-1,1)^2) + u(t-1)^3; 
%y(t) =y(t-1)*y(t-2)*(y(t-1)-0.5)/(1 + y(t-1)^2 + y(t-2)^2) + u(t-1); 
%y(t) =y(t-1)*y(t-2)*(y(t-1)+2.5)/(1 + y(t-1)^2*y(t-2)^2) + u(t-1); 
end 
%% Input data=== 
data=[[u(1:end)] [0;y(1:end-1)]]; 
nn=randperm(500); 
Train_data=data(nn(1:400),:); 
Target_train=y(nn(1:400)); 
Test_data=data(nn(401:500),:); 
Target_test=y(nn(401:500)); 
%% =========================================================== 
%% FS Initial parameters 
cu=repmat([-1 0 1],num_in,1); 
cl=cu; 
%c=repmat(0.5,num_in,1); 
sigmau=1*ones(size(cu)); 
sigmal=0.1*ones(size(cl)); 
rule=[1 1;2 2; 3 3;1 2; 2 3; 1 3]; 
The main script 
clc 
global cl cu sigmau sigmal rule 
global Test_data Target_test Train_data Target_train 
wu=rand(size(rule,1),num_out); 
wl=rand(size(rule,1),num_out); 
w=[reshape(wl,numel(wl),1);reshape(wu,numel(wu),1);reshape(cu,numel(cu),1)]; 
num_v=numel(w); 
int_pop=[1*rand(100,numel(wu)+numel(wl)) 
repmat(reshape(cu,1,numel(cu)),100,1) ]; 
%% Train 
options = gaoptimset('InitialPopulation',int_pop,... 
'StallGenLimit',100,'PopulationSize',100,... 
'Generations',100,'PopulationType','doubleVector',... 
'CrossoverFcn',@myfun,'PlotFcns',{@gaplotstopping,@gaplotbestf} 
);%{@crossoverintermediate, rand}); 
[w,Fval,exitFlag,Output]=ga(@(w) FitFcn2(w),num_v,... 
[],[],[],[],[],[],[],[],options); 
%% plot 
fprintf('The number of generations was : %d\n', Output.generations); 
fprintf('The number of function evaluations was : %d\n', Output.funccount); 
fprintf('The best function value found was : %g\n', Fval); 
%% Test 
clear wu wl 
M=size(rule,1); 
wl(:,1)=w(1:M); 
wu(:,1)=w(M+1:2*M); 
cu=reshape(w(2*M+1:end),size(sigmau,1),size(sigmau,2)); 
cl=cu; 
for ii=1:size(Test_data,1) 
x=Test_data(ii,:)'; 
yest(ii)=FS_type_2(x,cu,cl,sigmau,sigmal,wu,wl,rule); 
end 
plot(yest,'--r') 
hold on 
plot(Target_test,'--b')4.8 Training Neural Networks Based on PSO 71
The fitness script (crossover) function xoverKids = myfun(parents, options, nvars, FitnessFcn, ... 
unused,thisPopulation) 
R=rand(length(parents)/2,1); 
parents=reshape(parents,length(parents)/2,2); 
xoverKids=thisPopulation(parents(:,1),:).*(R*ones(1,nvars))+... 
((1-R)*ones(1,nvars)).*thisPopulation(parents(:,2),:); 
end 
The script for calculating the cost function or fitness function EE=FitFcn2(w) 
global sigmau sigmal rule Train_data Target_train 
num_out=1; 
M=size(rule,1); 
wl(:,1)=w(1:M); 
wu(:,1)=w(M+1:2*M); 
cu=reshape(w(2*M+1:end),size(sigmau,1),size(sigmau,2)); 
cl=cu; 
EE=0; 
for ii=1:size(Train_data,1) 
x=Train_data(ii,:)'; 
o=FS_type_2(x,cu,cl,sigmau,sigmal,wu,wl,rule); 
e=Target_train(ii)-o; 
%e=(Target_train(ii)-w2'*(w1'*x))^2; 
EE=EE+sum(e.^2); 
end 
EE=EE/size(Train_data,1); 
Figures 4.11 and 4.12 demonstrates the output diagrams of the GA and the esti￾mation results, respectively. Accordingly, the output estimated through the neural 
network matched the real output really well. 
4.8 Training Neural Networks Based on PSO 
4.8.1 Introduction 
In 1995, particle swarm optimization (PSO) was first introduced by Eberhart 
and Kennedy as a nondeterministic search method for optimizing functions. This 
algorithm is inspired by a flock of birds hunting for food [2, 3] (Fig. 4.13).
A flock of birds look for food randomly in the space. There is only one piece of 
food in the search space. None of the birds knows where the food is. A very good 
strategy can be to follow the bird that has the shortest distance to the food. Called a72 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
Fig. 4.13 PSO
particle, each solution in the algorithm is represented by a bird in the flock of birds. 
Each particle has a fitness value calculated through a fitness function. The closer the 
particle in the search space to the target—i.e., the food in the bird flock model –, 
the larger the fitness value. Furthermore, each particle has a velocity that directs it. 
Following the optimal particles in the current state, each particle continues moving 
in the problem space. In other words, a swarm of particles would first be created 
randomly and then try to find the optimal solution by updating the generations. In 
each step, every particle is updated through two values, the first of which is the best 
position which it has reached so far. This position is identified and retained. The 
second value is the best position which has so far been obtained by the swarm. This 
position is shown as gbest [4]. 
4.9 Formulation of Algorithm 
In the formulation of this algorithm, every particle’s behavior can be affected by 
the best local particle (i.e., Personal Best within a specific neighborhood or the best 
position which the particle has had so far) or the best global particle (i.e., Global Best 
or the best particle of all particles). The particles are first initialized randomly across 
the entire search space. These initial positions are identified as the best personal 
experiences of particles (gbest). In the next step, the best particle is selected from the 
existing particles and is identified as the best solution (gbest). The particle swarm 
then moves across the search space until the termination conditions are met. This 
process includes the application of the velocity equation to the participle swarm. 
Every particle’s position changes based on this equation. 
The new fitness value obtained from a particle is compared with gbest. If a 
particle’s new position has a better fitness value, this new position replaces pbest.4.9 Formulation of Algorithm 73
A similar procedure is adopted for gbest. Figure 4.14 demonstrates the motions of 
particles. 
• Xt denotes the old (current) position. 
• Xt+1 denotes the new (future) position of a particle. 
If a small amount of future velocity is added to the current position, the new 
(future) position is reached. 
• Vt+1 denotes the future velocity obtained from the random values of three 
components (old (current) velocity, gbest, and pbest). 
Hence, the motions of particles can be described mathematically through the 
following equations [5]: 
Pnew = Pold + V new
V new =
V old + C1 × R1 × (Plocalbest − Pold)
+ C2 × R2 × (Pglobalbest − Pold) (4.16) 
where C1 and C2 are the positive constants, whereas R1 and R2 are random numbers 
generated normally within [0, 1]. A parameter called the inertia weight is defined 
as below to improve the search process. It is added as a coefficient to the velocity 
parameter of the algorithm: 
V new =
W × V old + C1 × R1 × (Plocalbest − Pold)
+ C2 × R2 × (Pglobalbest − Pold) (4.17) 
The inertial weight determines the effect of velocity in the previous step on 
the current velocity. In other words, the general search capability of the algorithm
Fig. 4.14 The diagram of 
motions of particles in PSO 74 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
improves with large values of the inertia weight; therefore, a wider space is analyzed. 
However, the search space is limited with smaller values of the inertia weight. 
Hence, the algorithm usually starts moving with a large value of the inertia weight, 
which expands the search space in the algorithm execution. This weight decreases 
gradually over time, something which concentrates the search process on a smaller 
space in the final steps. 
The pseudocode for PSO [6] 
4.10 Implementation in MATLAB 
Let us estimate the following nonlinear function using fuzzy systems: 
y(t) = y(t − 1)/(1 + y(t − 1)
2 ) + u(t − 1)
3 (4.18)4.10 Implementation in MATLAB 75
where u = sin(2πn/100), ts = 100/500, n = 0:ts:100. 
For this purpose, 500 input–output data are generated, and 400 of which are 
selected randomly as the training data, and the rest as the test data. The following 
script is used to generate training and test data. 
The initialization script clear all 
clc 
global cl cu sigmau sigmal rule 
global Test_data Target_test Train_data Target_train 
num_out=1; 
num_in=2; 
%% =================================================================== 
ts=100/500; 
n=0:ts:100; 
% 
u(:,1)=sin(2.*pi.*n./100); 
% n=1:500; 
% u(:,1)=sin(2.*pi.*n./25); 
% y(1,1)=0; 
y(2,1)=0; 
% y(31,1)=1.2; 
% a=0.1; b=0.2*0.1; tav=30; 
for t=3:length(u); 
% y(t,1)=(1-a).*y(t-1,1)+b.*y(t-tav-1,1)./(1+y(t-tav-1,1).^10); 
%y(t,1)=-0.1.*y(t-1,1)+0.2.*y(t-tav-1,1)./(1+y(t-tav-1,1).^10); 
y(t,1) =y(t-1,1)/( 1 + y(t-1,1)^2) + u(t-1)^3; 
%y(t) =y(t-1)*y(t-2)*(y(t-1)-0.5)/(1 + y(t-1)^2 + y(t-2)^2) + u(t-1); 
%y(t) =y(t-1)*y(t-2)*(y(t-1)+2.5)/(1 + y(t-1)^2*y(t-2)^2) + u(t-1); 
end 
%% Input data=== 
data=[[u(1:end)] [0;y(1:end-1)]]; 
nn=randperm(500); 
Train_data=data(nn(1:400),:); 
Target_train=y(nn(1:400)); 
Test_data=data(nn(401:500),:); 
Target_test=y(nn(401:500)); 
%% =========================================================== 
%% FS Initial parameters 
cu=repmat([-1 0 1],num_in,1); 
cl=cu; 
%c=repmat(0.5,num_in,1); 
sigmau=1*ones(size(cu)); 
sigmal=0.1*ones(size(cl)); 
rule=[1 1;2 2; 3 3;1 2;1 3;2 3]; 
The main script 
clc 
global cl cu sigmau sigmal rule 
global Test_data Target_test Train_data Target_train 
wu=rand(size(rule,1),num_out); 
wl=rand(size(rule,1),num_out); 
w=[reshape(wl,numel(wl),1);reshape(wu,numel(wu),1)]; 
num_v=numel(w); 
%% Train 76 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
pop=rand(50,num_v); 
max_it=150; 
[Gbest,e_Gbest]=PSO(pop,max_it); 
%% Test 
w=reshape(Gbest,size(rule,1),2*num_out); 
wl=w(:,1:num_out); 
wu=w(:,num_out+1:2*num_out); 
for ii=1:size(Test_data,1) 
x=Test_data(ii,:)'; 
yest(ii)=FS_type_2(x,cu,cl,sigmau,sigmal,wu,wl,rule); 
end 
plot(yest,'--r') 
hold on 
plot(Target_test,'--b') 
The PSO script function [Gbest,e_Gbest]=PSO(pop,max_it) 
%% 
best_EE=0.001; 
w=0.7; 
c1=2; 
c2=2; 
e_Gbest=inf; 
e_Pbest=inf*ones(size(pop,1),1); 
v=zeros(size(pop)); 
for epoch=1:max_it 
%% FitFcn 
for ii=1:size(pop,1) 
EE(ii)=FitFcn(pop(ii,:)); 
%---------- Pbest--------------
if EE(ii)<e_Pbest(ii) 
Pbest(ii,:)=pop(ii,:); 
e_Pbest(ii)=EE(ii); 
end 
end 
%% ---------- Gbest--------------
[a b]=min(EE); 
if a<e_Gbest 
Gbest=pop(b,:); 
e_Gbest=a; 
end 
e_Gbest 
%% 
v=w*(v+c1*rand*(Pbest-pop)+c2*rand*(repmat(Gbest,size(pop,1),1)-pop)); 
pop=pop+v; 
if e_Gbest<best_EE 
break 
end 
%% 
end % epoch 
The cost function script 
function EE=FitFcn(w) 
global cl cu sigmau sigmal rule Train_data Target_train 
num_out=1; 
w=reshape(w,size(rule,1),2*num_out); 
wl=w(:,1:num_out); 
wu=w(:,num_out+1:2*num_out); 
EE=0; 
for ii=1:size(Train_data,1) 
x=Train_data(ii,:)';4.10 Implementation in MATLAB 77
o=FS_type_2(x,cu,cl,sigmau,sigmal,wu,wl,rule); 
e=Target_train(ii)-o; 
%e=(Target_train(ii)-w2'*(w1'*x))^2; 
EE=EE+sum(e.^2); 
end 
EE=EE/size(Train_data,1); 
% w2(:,1)=w(1:num_neuron+1); 
% w1=reshape(w(num_neuron+2:end),num_in,num_neuron); 
% E=0; 
% for ii=1:size(Train_data,1) 
% x=Train_data(ii,:)'; 
% [o1,o2,net1,net2]=FeedForward_NN(x,0,0,w1,w2); 
% e=Target_train(ii)-o2; 
% E=E+e^2; 
% yest(ii)=o2; 
% end 
% E/size(Train_data,1) 
% %% 
% plot(yest,'--b','linewidth',2) 
% hold on 
% plot(Target_train,'--r','linewidth',2) 
% pause 
The type-2 fuzzy system script function y=FS_type_2(u,cu,cl,sigmau,sigmal,wu,wl,rule) 
% u is n*1 where n is number of inputs 
% c is n*n_MF where n_MF is the number of MFs for this input 
% the dimension of sigma is the same as c 
% the variable rule represent the rule database. 
% rule is n_rule*n, where n_rule is the number of rules 
%% 
% clear all 
% clc 
% u=[1 2]'; 
% c=[-1 0 1;-1 0 1]; 
% sigma=ones(size(c)); 
% rule=[1 3; 2 3]; 
% w=rand(2,1);-2 2 
%c=[-2 -1 0 1 2;3 4 0 5 6] 
%% MF 
n_MF=size(cu,2); 
x=repmat(u,1,n_MF); 
MFu= exp(-(x-cu).^2./sigmau.^2); 
MFl= exp(-(x-cl).^2./sigmal.^2); 
%% Rule fiering 
for ii=1:size(rule,2) 
au(:,ii)=MFu(ii,rule(:,ii)); 
al(:,ii)=MFl(ii,rule(:,ii)); 
end 
zu=prod(au,2);%min 
zl=prod(al,2);%min 
%% Type reduction 
%z=(zu+zl)/2; % Nie-Tan 
szu=(sum(zu)+0.0001); 
do_dwr=zu/szu; 
ou=do_dwr'*wu; 
szl=(sum(zl)+0.0001); 
do_dwl=zl/szl; 
ol=do_dwl'*wl; 
y=(ou'+ol')/2;78 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
Figure 4.15 demonstrates the real output diagram and the estimated output diagram 
of this method. According to Fig. 4.16, the final RMSE value decreased greatly in 
the best OSO solution. 
0 10 20 30 40 50 60 70 80 90 100
-1.5
-1
-0.5 
0 
0.5 
1 
1.5 
Fig. 4.15 The real output diagram and the estimated output diagram for the fuzzy system 
Fig. 4.16 The final optimization result through PSO4.11 Training Type-2 Fuzzy System Through Second-Order Algorithms 79
4.11 Training Type-2 Fuzzy System Through 
Second-Order Algorithms 
4.11.1 Introduction 
In previous subchapters, the rule for neural network parameter regulation was deter￾mined by only using the first-order derivative. In other words, only the first-order 
derivative was used for the approximation of the cost function through the Taylor 
series, and the derivatives of higher orders were disregarded. 
Consider the following cost function E(w) based on the weighted vector: 
E(w) = E(w0) + gT Δw +
1 
2 
(Δw)T H Δw (4.19) 
where g and H represent the Jacobian matrix and the Hessian matrix, respectively. 
To obtain the minimum of E(w), its derivative should be calculated and considered 
zero; thus: 
∂E(w)
∂w = g + HΔw = 0 
⇒ Δw = H −1 g 
(4.20) 
Therefore, the inverted Hessian matrix should also be calculated in the second￾order methods. Different methods have been proposed for this purpose. Some of 
them are presented here. 
4.11.2 Newton’s Method 
In Newton’s method, H−1 is estimated as below: 
lim 
k→∞ Q(k) = H−1 (4.21) 
where 
H = ∂g 
∂w ∼= Δg 
Δw
⇒ H−1 = Δw.Δg−1 
(4.22) 
where Δg(k) = g(k) − g(k − 1).80 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
4.11.3 Levenberg–Marquardt Algorithm 
Like Newton’s method, the Hessian matrix is estimated in this method, the advantages 
of which include the high convergence speed and flexibility. In fact, this method 
stands between gradient descent and Newton’s method. For the Hessian matrix, 
there will be [7]: 
H = J T .J (4.23) 
where 
g = J T .e (4.24) 
where J denotes the Jacobian matrix. 
In the Levenberg–Marquardt Algorithm, the Hessian matrix is estimated as below: 
Q(k) = [
J T .J + μI ]−1 (4.25) 
Hence, the weight adjustment rule will be as below through Eq. (4.20): 
W (k + 1) = W (k) −
([
J T .J + μI ]−1 )
.
(
J T .e ) (4.26) 
where μ is a constant. If μ approaches zero, the Levenberg–Marquardt Algorithm 
approaches Newton’s method. If μ is a larger number, this method will become 
gradient descent with a smaller training rate. 
4.11.4 Conjugate Gradient Method 
The conjugate gradient (CG) method is similar to the gradient method. Its rule of 
parameter regulation is defined as below [8]: 
w(k + 1) = w(k) + η(k)Δw(k) (4.27) 
where 
Δw(k) = −g(k) + α(k − 1)Δw(k − 1) (4.28) 
One of the following methods is employed to calculate α: 
α(k) = (g(k + 1))T g(k + 1)
(g(k))T g(k)4.12 Conclusion 81
α(k) = (g(k + 1))T (g(k + 1) − g(k))
(g(k))T g(k)
α(k) = (g(k) − g(k + 1))T g(k)
(w(k) − w(k − 1))T (g(k) − g(k − 1)) (4.29) 
4.11.5 Implementation in MATLAB 
Consider the classification example from the previous subchapter. In this example, 
LM (Levenberg–Marquart) and CG (conjugate gradient) scripts can be used instead 
of the gradient descent method. Table 4.3 presents the MATLAB script, in which the 
LM algorithm approaches Newton’s method if λ is considered a large value. If it is 
considered a small value, it becomes the gradient descent method with a small rate. 
4.12 Conclusion 
This chapter analyzed different widely used methods for optimizing and training 
fuzzy systems theoretically with a simple example coded in MATLAB. The codes 
were written simply and then vectorized. Dear readers can easily use these codes 
in relevant problems. Moreover, all of these codes are available at http://www.sim 
ref.org in plain language through tutorial videos, which can be used by the enthusiasts 
who would like to learn the codes line by line. 
Table 4.1 MATLAB script—use of the fuzzy system in classification 
The main script 
clear all
clc 
 
%% Load data
load data_classification
%% Input data 
Train_data=reshape(Xtrain,size(Xtrain,1),size(Xtrain,2)*size(Xtrain,3)); 
Target_train=repmat([1:10],size(Xtrain,2),1); 
Target_train=reshape(Target_train,numel(Target_train),1); 
 
%---------------------------
Test_data=reshape(Xtest,size(Xtest,1),size(Xtest,2)*size(Xtest,3)); 
Target_test=repmat([1:10],size(Xtest,2),1); 
Target_test=reshape(Target_test,numel(Target_test),1); 
 
 
%% FS Initial parameters
cu=reshape(mean(Xtrain,2),23,10); 
cl=cu; 
 
%c=repmat(0.5,23,1);
sigmau=1*ones(size(cu)); 
sigmal=0.1*ones(size(cl)); 
(continued)82 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
Table 4.1 (continued)
epoch 
mse_train=E/size(Train_data,2) 
MSE_Train(epoch)= E/size(Train_data,2); 
if mse_train<mse_min 
mse_min=mse_train; 
cu_best=cu; 
wu_best=wu; 
sigmau_best=sigmau; 
cl_best=cl; 
wl_best=wl; 
sigmal_best=sigmal; 
end 
%% Test 
E=0; 
for ii=1:size(Test_data,2) 
x=Test_data(:,ii); 
[o1,o2,net1,net2]=FeedForward_NN(x,b1,b2,w1,w2); 
O_target=zeros(10,1); 
O_target(Target_test(ii))=1; 
e=O_target-o2; 
E=E+norm(e)^2; 
end 
mase_test=E/size(Test_data,2) 
MSE_Test(epoch)=E/size(Test_data,2); 
end 
%% plot MSE 
%% 
plot(MSE_Train(1:end),'--b','linewidth',2) 
hold on 
plot( MSE_Test,'--r','linewidth',2) 
%% Test ================================================================= 
C=zeros(10,10); 
for ii=1:size(Test_data,2) 
x=Test_data(:,ii); 
o=FS_type_2(x,cu_best,cl_best,sigmau_best,sigmal_best,wu_best,wl_best,rule); 
O_target=zeros(10,1); 
O_target(Target_test(ii))=1; 
[a,b]=max(abs(o)); 
C(b,Target_test(ii))=C(b,Target_test(ii))+1; 
end 
C 
sum(sum(C.*eye(10)))*100/size(Test_data,2) 
The function for calculating the derivative of the fuzzy system output based on parameters 
function 
[do_dwu,do_dcu,do_dsigmau,do_dwl,do_dcl,do_dsigmal]=do_param(e,u,cu,cl,sigmau,sigmal,wu,wl,rule) 
% u is n*1 where n is number of inputs 
% c is n*n_MF where n_MF is the number of MFs for this input 
% the dimension of sigma is the same as c 
% the variable rule represent the rule database. 
% rule is n_rule*n, where n_rule is the number of rules 
%% 
%% FS 
%% MF 
n_MF=size(cu,2); 
x=repmat(u,1,n_MF); 
MFu= exp(-(x-cu).^2./sigmau.^2); 
MFl= exp(-(x-cl).^2./sigmal.^2); 
%% Rule fiering 
rule=[1:10]'*ones(1,23); 
wu=eye(10); 
wl=eye(10); 
eta=0.01; 
 
%% Train ===================================================
mse_min=100; 
for epoch=1:20 
 
 %% Train 
 E=0; 
 nn=randperm(size(Train_data,2)); 
 
 for ii=nn 
 x=Train_data(:,ii); 
 o=FS_type_2(x,cu,cl,sigmau,sigmal,wu,wl,rule); 
 
 O_target=zeros(10,1); 
 O_target(Target_train(ii))=1; 
 e=O_target-o; 
 [do_dwu,do_dcu,do_dsigmau,do_dwl,do_dcl,do_dsigmal]=...
 do_param(e,x,cu,cl,sigmau,sigmal,wu,wl,rule); 
 
 [wu,cu,sigmau,wl,cl,sigmal]=...
 GD_FS(e,eta,do_dwu,do_dcu,do_dsigmau,wu,cu,sigmau,do_dwl,do_dcl,do_dsigmal,wl,cl,sigmal);
 E=E+norm(e)^2; 
 end
(continued)4.12 Conclusion 83
Table 4.1 (continued)
%% do-dparam 
for ii=1:size(rule,2) 
for jj=1:size(cu,2) 
b=rule(:,ii)==jj; 
%------------- upper ------------
zprim=b.*zu; 
do_dcu(ii,jj,:)=(u(ii)-cu(ii,jj))./sigmau(ii,jj)^2*(zprim'*wu)./szu-sum(zprim)*ou/szu; 
do_dsigmau(ii,jj,:)=(u(ii)-cu(ii,jj))^2./sigmau(ii,jj)^3*(zprim'*wu)./szu-sum(zprim)*ou/szu; 
%------------- lower ----
zprim=b.*zl; 
do_dcl(ii,jj,:)=(u(ii)-cl(ii,jj))./sigmal(ii,jj)^2*(zprim'*wl)./szl-sum(zprim)*ol/szl; 
do_dsigmal(ii,jj,:)=(u(ii)-cl(ii,jj))^2./sigmal(ii,jj)^3*(zprim'*wl)./szl-sum(zprim)*ol/szl; 
end 
end 
The function for calculating the output of the interval type-2 fuzzy system 
function y=FS_type_2(u,cu,cl,sigmau,sigmal,wu,wl,rule) 
% u is n*1 where n is number of inputs 
% c is n*n_MF where n_MF is the number of MFs for this input 
% the dimension of sigma is the same as c 
% the variable rule represent the rule database. 
% rule is n_rule*n, where n_rule is the number of rules 
%% 
% clear all 
% clc 
% u=[1 2]’; 
% c=[-1 0 1;-1 0 1]; 
% sigma=ones(size©); 
% rule=[1 3; 2 3]; 
% w=rand(2,1);-2 2 
%c=[-2 -1 0 1 2;3 4 0 5 6] 
%% MF 
n_MF=size(cu,2); 
x=repmat(u,1,n_MF); 
Mfu= exp(-(x-cu).^2./sigmau.^2); 
MFl= exp(-(x-cl).^2./sigmal.^2); 
%% Rule fiering 
for ii=1:size(rule,1) 
au(:,ii)=Mfu(ii,rule(:,ii)); 
al(:,ii)=MFl(ii,rule(:,ii)); 
end 
zu=prod(au,2);%min 
zl=prod(al,2);%min 
%% Type reduction 
%z=(zu+zl)/2; % Nie-Tan 
szu=(sum(zu)+0.0001); 
do_dwr=zu/szu; 
ou=do_dwr’*wu; 
szl=(sum(zl)+0.0001); 
do_dwl=zl/szl; 
ol=do_dwl’*wl; 
y=(ou’+ol’)/2; 
for ii=1:size(rule,1) 
au(:,ii)=MFu(ii,rule(:,ii)); 
al(:,ii)=MFl(ii,rule(:,ii)); 
end 
zu=prod(au,2);%min 
zl=prod(al,2);%min 
%% Type reduction 
%z=(zu+zl)/2; % Nie-Tan 
szu=(sum(zu)+0.0001); 
do_dwu=zu/szu; 
ou=do_dwu'*wu; 
szl=(sum(zl)+0.0001); 
do_dwl=zl/szl; 
ol=do_dwl'*wl;
(continued)84 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
Table 4.1 (continued)
%delta=e.*df2(net); 
delta=e; 
wu=wu+eta*do_dwu*delta'; 
aa(1,1,:)=e; 
cu=cu+0.1*eta*sum(do_dcu.*repmat(aa,size(do_dcu,1),size(do_dcu,2),1),3); 
sigmau=sigmau+0.1*eta*sum(do_dsigmau.*repmat(aa,size(do_dsigmau,1),size(do_dsigmau,2),1),3); 
%% 
clear aa 
delta=e; 
wl=wl+eta*do_dwl*delta'; 
aa(1,1,:)=e; 
cl=cl+0.01*eta*sum(do_dcl.*repmat(aa,size(do_dcl,1),size(do_dcl,2),1),3); 
sigmal=sigmal+0.01*eta*sum(do_dsigmal.*repmat(aa,size(do_dsigmal,1),size(do_dsigmal,2),1),3); 
%% 
wu(wu>100)=100; 
wl(wl>100)=100; 
sigmau(sigmau>100)=100; 
sigmal(sigmal>100)=100; 
cu(cu>100)=100; 
cl(cl>100)=100; 
wu(wu<-100)=-100; 
wl(wl<-100)=-100; 
sigmau(sigmau<-100)=-100; 
sigmal(sigmal<-100)=-100; 
cu(cu<-100)=-100; 
cl(cl<-100)=-100; 
% delta1=(w2(2:end,:)*delta2).*df1(net1); 
% w1=w1+eta*u*(delta1)'; 
The function for updating parameters based on gradient descent 
function 
[wu,cu,sigmau,wl,cl,sigmal]=GD_FS(e,eta,do_dwu,do_dcu,do_dsigmau,wu,cu,sigmau,do_dwl,do_dcl,do_dsigmal,w 
l,cl,sigmal) 
%% Activation functions 
%f1 =@(x)(1-exp(-x))./(1+exp(-x)); 
%f2 =@(x)(1-exp(-x))./(1+exp(-x)); 
%% Derivative of Activation functions 
% df1 =@(x)2*exp(-x)./(1+exp(-x)).^2; 
% df2 =@(x)2*exp(-x)./(1+exp(-x)).^2; 
% df2 =@(x)1*exp(-x)./(1+exp(-x)).^2; 
%%4.12 Conclusion 85
Table 4.2 The MATLAB script for training the fuzzy system with KM rank reduction 
The main script 
%clear all 
clc 
%% Load data 
%% Input data 
load data 
num_in=4; 
num_out=2; 
%% FS Initial parameters 
%cu=repmat([0 0.25 0.5 0.75 1],num_in,1); 
cu=[mean(Train_data(:,1:100),2) mean(Train_data(:,101:200),2)]; 
cl=cu; 
%c=repmat(0.5,num_in,1); 
sigmau=1*ones(size(cu)); 
sigmal=0.1*ones(size(cl)); 
rule=[1:size(cu,2)]'*ones(1,num_in); 
wu=rand(size(rule,1),num_out); 
wl=rand(size(rule,1),num_out); 
eta=0.005; 
% rule=generate_rule(num_in,1); 
% w=rand(size(rule,1),num_out); 
%% Train =================================================== 
mse_min=100; 
for epoch=1:50 
%% Train 
E=0; 
nn=randperm(size(Train_data,2)); 
for ii=nn 
x=Train_data(:,ii); 
[o,do_dp]=FS_type_2(x,cu,cl,sigmau,sigmal,wu,wl,rule); 
O_target=zeros(num_out,1); 
O_target(Target_train(ii))=1; 
e=O_target-o; 
[wu,cu,sigmau,wl,cl,sigmal]=... 
GD_FS(e,eta,do_dp,wu,cu,sigmau,wl,cl,sigmal); 
E=E+norm(e)^2; 
end 
epoch 
mse_train=E/size(Train_data,2) 
MSE_Train(epoch)= E/size(Train_data,2); 
if mse_train<mse_min 
mse_min=mse_train; 
cu_best=cu; 
wu_best=wu; 
sigmau_best=sigmau; 
cl_best=cl; 
wl_best=wl; 
sigmal_best=sigmal; 
end 
%% Test 
% E=0; 
% for ii=1:size(Test_data,2) 
% x=Test_data(:,ii);
(continued)86 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
Table 4.2 (continued)
% [o1,o2,net1,net2]=FeedForward_NN(x,b1,b2,w1,w2); 
% O_target=zeros(num_out,1); 
% O_target(Target_test(ii))=1; 
% e=O_target-o2; 
% E=E+norm(e)^2; 
% end 
% mase_test=E/size(Test_data,2) 
% MSE_Test(epoch)=E/size(Test_data,2); 
end 
%% plot MSE 
%% 
plot(MSE_Train(1:end),'--b','linewidth',2) 
% hold on 
% plot( MSE_Test,'--r','linewidth',2) 
%% Test ================================================================= 
C=zeros(num_out,num_out); 
for ii=1:size(Test_data,2) 
x=Test_data(:,ii); 
[o,do_dp]=FS_type_2(x,cu_best,cl_best,sigmau_best,sigmal_best,wu_best,wl_best,rule); 
O_target=zeros(num_out,1); 
O_target(Target_test(ii))=1; 
[a,b]=max(abs(o)); 
C(b,Target_test(ii))=C(b,Target_test(ii))+1; 
end 
C 
sum(sum(C.*eye(num_out)))*100/size(Test_data,2) 
function [y,do_dp]=FS_type_2(u,cu,cl,sigmau,sigmal,wu,wl,rule) 
% u is n*1 where n is number of inputs 
% c is n*n_MF where n_MF is the number of MFs for this input 
% the dimension of sigma is the same as c 
% the variable rule represent the rule database. 
% rule is n_rule*n, where n_rule is the number of rules 
%% 
% clear all 
% clc 
% u=[1 2]'; 
% c=[-1 0 1;-1 0 1]; 
% sigma=ones(size(c)); 
% rule=[1 3; 2 3]; 
% w=rand(2,1);-2 2 
%c=[-2 -1 0 1 2;3 4 0 5 6] 
%% MF 
n_MF=size(cu,2); 
x=repmat(u,1,n_MF); 
num_o=size(wu,2); % number of out 
M=size(rule,1); 
MFu= exp(-(x-cu).^2./sigmau.^2); 
MFl= exp(-(x-cl).^2./sigmal.^2); 
%% Rule fiering 
for ii=1:size(rule,2) 
au(:,ii)=MFu(ii,rule(:,ii)); 
al(:,ii)=MFl(ii,rule(:,ii)); 
end 
zu=prod(au,2);%min 
zl=prod(al,2);%min 
%% Type reduction 
%z=(zu+zl)/2; % Nie-Tan 
for ii=1:num_o 
[L,R]=KM([wl(:,ii) wu(:,ii)],[zl zu]); 
%[L,R]=EKM_interval(zu,zl ,wu(:,ii),wl(:,ii) ); 
yr(ii,1)=([zl(1:R);zu(R+1:end)]'*wu(:,ii))/sum([zl(1:R);zu(R+1:end)]); 
yl(ii,1)=([zu(1:L);zl(L+1:end)]'*wl(:,ii))/sum([zu(1:L);zl(L+1:end)]); 
y(ii,1)=(yl(ii,1)+yr(ii,1))/2; 
szu(ii,1)=sum([zl(1:R);zu(R+1:end)])+0.0001; 
szl(ii,1)=sum([zu(1:L);zl(L+1:end)])+0.0001; 
do_dwu(:,ii)=[zl(1:R);zu(R+1:end)]/szu(ii,1);
(continued)4.12 Conclusion 87
Table 4.2 (continued)
do_dwl(:,ii)=[zu(1:L);zl(L+1:end)]/szl(ii,1); 
RR(:,ii)=[ones(R,1);zeros(M-R,1)]; 
LL(:,ii)=[ones(L,1);zeros(M-L,1)]; 
end 
%% ========================================================= 
%% od-dparam 
% wu=wu.*(1-RR)+wl.*LL; 
% wl=wu.*RR+wl.*(1-LL); 
for ii=1:size(rule,2) 
for jj=1:size(cu,2) 
b=rule(:,ii)==jj; 
%------------- upper ------------
zprim1=(1-RR).*repmat((b.*zu),1,num_o); 
zprim2=LL.*repmat((b.*zu),1,num_o); 
do_dcu(ii,jj,:)=(u(ii)-cu(ii,jj))./sigmau(ii,jj)^2*diag(zprim1'*wu)'./szu'-
sum(zprim1,1).*yr'./szu'+... 
(u(ii)-cu(ii,jj))./sigmau(ii,jj)^2*diag(zprim2'*wl)'./szl'-
sum(zprim2,1).*yl'./szl'; 
do_dsigmau(ii,jj,:)=(u(ii)-cu(ii,jj))^2./sigmau(ii,jj)^3*diag(zprim1'*wu)'./szu'-
sum(zprim1,1).*yr'./szu'+... 
(u(ii)-cu(ii,jj))^2./sigmau(ii,jj)^3*diag(zprim2'*wl)'./szl'-
sum(zprim2,1).*yl'./szl'; 
%------------- lower ----
zprim1=RR.*repmat((b.*zl),1,num_o); 
zprim2=(1-LL).*repmat((b.*zl),1,num_o); 
do_dcl(ii,jj,:)=(u(ii)-cl(ii,jj))./sigmal(ii,jj)^2.*diag(zprim1'*wu)'./szu'-
sum(zprim1,1).*yr'./szu'+... 
(u(ii)-cl(ii,jj))./sigmal(ii,jj)^2.*diag(zprim2'*wl)'./szl'-
sum(zprim2,1).*yl'./szl'; 
do_dsigmal(ii,jj,:)=(u(ii)-cl(ii,jj))^2./sigmal(ii,jj)^3.*diag(zprim1'*wu)'./szu'-
sum(zprim1,1).*yr'./szu'+... 
(u(ii)-cl(ii,jj))^2./sigmal(ii,jj)^3.*diag(zprim2'*wl)'./szl'-
sum(zprim2,1).*yl'./szl'; 
end 
end 
do_dp={do_dwu,do_dcu,do_dsigmau,do_dwl,do_dcl,do_dsigmal}; 
The script of gradient descent for optimization of parameters 
function [wu,cu,sigmau,wl,cl,sigmal]=GD_FS(e,eta,do_dp,wu,cu,sigmau,wl,cl,sigmal) 
%% 
do_dwu=do_dp{1}; 
do_dcu=do_dp{2}; 
do_dsigmau=do_dp{3}; 
do_dwl=do_dp{4}; 
do_dcl=do_dp{5}; 
do_dsigmal=do_dp{6}; 
%% 
%delta=e.*df2(net); 
delta=e; 
wu=wu+eta*do_dwu.*repmat(delta',size(wu,1),1); 
aa(1,1,:)=e; 
cu=cu+0.1*eta*sum(do_dcu.*repmat(aa,size(do_dcu,1),size(do_dcu,2),1),3); 
sigmau=sigmau+0.1*eta*sum(do_dsigmau.*repmat(aa,size(do_dsigmau,1),size(do_dsigmau,2),1),3); 
%% 
clear aa 
delta=e; 
wl=wl+eta*do_dwl.*repmat(delta',size(wl,1),1); 
aa(1,1,:)=e; 
cl=cl+0.1*eta*sum(do_dcl.*repmat(aa,size(do_dcl,1),size(do_dcl,2),1),3); 
sigmal=sigmal+0.1*eta*sum(do_dsigmal.*repmat(aa,size(do_dsigmal,1),size(do_dsigmal,2),1),3); 
%% 
wu(wu>100)=100; 
wl(wl>100)=100; 
sigmau(sigmau>100)=100; 
sigmal(sigmal>100)=100;
(continued)88 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
Table 4.2 (continued)
cu(cu>100)=100; 
cl(cl>100)=100; 
wu(wu<-100)=-100; 
wl(wl<-100)=-100; 
sigmau(sigmau<-100)=-100; 
sigmal(sigmal<-100)=-100; 
cu(cu<-100)=-100; 
cl(cl<-100)=-100; 
% delta1=(w2(2:end,:)*delta2).*df1(net1); 
% w1=w1+eta*u*(delta1)'; 
Rank reduction 
function [L,R]=KM(w,F) 
%% consequent MF parameters 
wr=w(:,2); 
wl=w(:,1); 
fu=F(:,2); 
fl=F(:,1); 
%% 
yr=wr'*(fu+fl)/2/(sum((fu+fl)/2)+0.0001); 
yl=wl'*(fu+fl)/2/(sum((fu+fl)/2)+0.0001); 
[wr,br]=sort(wr); 
[wl,bl]=sort(wl); 
fu=fu(br); 
fl=fl(bl); 
M=length(wr); 
%% find yr 
while(1) 
R=find(yr>wr(1:M-1)); 
if ~isempty(R) 
R=R(end); 
else 
R=1; 
end 
yr_prim=(wr(1:R)'*fl(1:R)+wr(R+1:end)'*fu(R+1:end))/(sum(fl(1:R))+sum(fu(R+1:end))); 
if abs(yr_prim-yr)<0.01 
yr=yr_prim; 
break 
end 
yr=yr_prim; 
end 
%% find yl 
while(1) 
L=find(yl>wl(1:M-1)); 
if ~isempty(L) 
L=L(end); 
else 
L=1; 
end 
yl_prim=(wl(1:L)'*fu(1:L)+wl(L+1:end)'*fl(L+1:end))/(sum(fu(1:L))+sum(fl(L+1:end))); 
if abs(yl_prim-yl)<0.01 
yl=yl_prim; 
break 
end 
yl=yl_prim; 
end4.12 Conclusion 89
Table 4.3 The MATLAB script for training the type-2 fuzzy system based on second-order LM 
algorithms 
The main script 
clear all 
clc 
%% Load data 
load data_classification 
Xtrain=Xtrain(:,1:100,:); 
Xtest=Xtest(:,1:40,:); 
%% Input data 
Train_data=reshape(Xtrain,size(Xtrain,1),size(Xtrain,2)*size(Xtrain,3)); 
Target_train=repmat([1:10],size(Xtrain,2),1); 
Target_train=reshape(Target_train,numel(Target_train),1); 
%---------------------------
Test_data=reshape(Xtest,size(Xtest,1),size(Xtest,2)*size(Xtest,3)); 
Target_test=repmat([1:10],size(Xtest,2),1); 
Target_test=reshape(Target_test,numel(Target_test),1); 
%% FS Initial parameters 
cu=reshape(mean(Xtrain,2),23,10); 
cl=cu;
(continued)90 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
Table 4.3 (continued) %c=repmat(0.5,23,1); 
sigmau=1*ones(size(cu)); 
sigmal=0.1*ones(size(cl)); 
rule=[1:10]'*ones(1,23); 
wu=eye(10); 
wl=eye(10); 
eta=0.01; 
Mu=500; 
numel_cu=numel(cu); 
numel_cl=numel(cl); 
numel_sigu=numel(sigmau); 
numel_sigl=numel(sigmal); 
size_cu=size(cu); 
size_sigu=size(sigmau); 
%% Train =================================================== 
mse_min=100; 
for epoch=1:5 
%% Train 
E=0; 
nn=randperm(size(Train_data,2)); 
for ii=nn 
x=Train_data(:,ii); 
o=FS_type_2(x,cu,cl,sigmau,sigmal,wu,wl,rule); 
O_target=zeros(10,1); 
O_target(Target_train(ii))=1; 
e=O_target-o; 
[do_dwu,do_dcu,do_dsigmau,do_dwl,do_dcl,do_dsigmal]=... 
do_param(e,x,cu,cl,sigmau,sigmal,wu,wl,rule); 
for jj=1:10 
wu(:,jj)=LM(e(jj),wu(:,jj),do_dwu,Mu); 
wl(:,jj)=LM(e(jj),wl(:,jj),do_dwl,Mu); 
%-------------------- cu ------------------------
cu1=LM(e(jj),reshape(cu,numel_cu,1),... 
reshape(do_dcu(:,:,jj),numel_cu,1),Mu); 
cu=reshape(cu1,size_cu(1),size_cu(2)); 
%-------------------- cl ------------------------
cl1=LM(e(jj),reshape(cl,numel_cu,1),... 
reshape(do_dcl(:,:,jj),numel_cl,1),Mu); 
cl=reshape(cl1,size_cu(1),size_cu(2)); 
%-------------------- sigmau ------------------------
sigmau1=LM(e(jj),reshape(sigmau,numel_sigu,1),... 
reshape(do_dsigmau(:,:,jj),numel_sigu,1),Mu); 
sigmau=reshape(sigmau1,size_sigu(1),size_sigu(2)); 
%-------------------- sigmal ------------------------
sigmal1=LM(e(jj),reshape(sigmal,numel_sigu,1),... 
reshape(do_dsigmal(:,:,jj),numel_sigu,1),Mu); 
sigmal=reshape(sigmal1,size_sigu(1),size_sigu(2)); 
end 
E=E+norm(e)^2; 
end
(continued)4.12 Conclusion 91
Table 4.3 (continued)
% e=O_target-o2; 
% E=E+norm(e)^2; 
% end 
% mase_test=E/size(Test_data,2) 
% MSE_Test(epoch)=E/size(Test_data,2); 
end 
%% plot MSE 
%% 
plot(MSE_Train(1:end),'--b','linewidth',2) 
% hold on 
% plot( MSE_Test,'--r','linewidth',2) 
%% Test ================================================================= 
C=zeros(10,10); 
for ii=1:size(Test_data,2) 
x=Test_data(:,ii); 
o=FS_type_2(x,cu_best,cl_best,sigmau_best,sigmal_best,wu_best,wl_best,rule); 
O_target=zeros(10,1); 
O_target(Target_test(ii))=1; 
[a,b]=max(abs(o)); 
C(b,Target_test(ii))=C(b,Target_test(ii))+1; 
end 
C 
sum(sum(C.*eye(10)))*100/size(Test_data,2) 
The script for calculating derivatives 
function 
[do_dwu,do_dcu,do_dsigmau,do_dwl,do_dcl,do_dsigmal]=do_param(e,u,cu,cl,sigmau,sigmal,wu,wl,rule) 
% u is n*1 where n is number of inputs 
% c is n*n_MF where n_MF is the number of MFs for this input 
% the dimension of sigma is the same as c 
% the variable rule represent the rule database. 
% rule is n_rule*n, where n_rule is the number of rules 
%% 
% clear all 
% clc 
% u=[1 2]'; 
% c=[-1 0 1;-1 0 1]; 
% sigma=ones(size(c)); 
% rule=[1 3; 2 3]; 
% w=rand(2,1); 
%% FS 
%% MF 
n_MF=size(cu,2); 
x=repmat(u,1,n_MF); 
MFu= exp(-(x-cu).^2./sigmau.^2); 
MFl= exp(-(x-cl).^2./sigmal.^2); 
%% Rule fiering 
for ii=1:size(rule,1) 
au(:,ii)=MFu(ii,rule(:,ii)); 
al(:,ii)=MFl(ii,rule(:,ii)); 
end 
epoch 
mse_train=E/size(Train_data,2) 
MSE_Train(epoch)= E/size(Train_data,2); 
if mse_train<mse_min 
mse_min=mse_train; 
cu_best=cu; 
wu_best=wu; 
sigmau_best=sigmau; 
cl_best=cl; 
wl_best=wl; 
sigmal_best=sigmal; 
end 
%% Test 
% E=0; 
% for ii=1:size(Test_data,2) 
% x=Test_data(:,ii); 
% [o1,o2,net1,net2]=FeedForward_NN(x,b1,b2,w1,w2); 
% O_target=zeros(10,1); 
% O_target(Target_test(ii))=1;
(continued)92 4 Training Interval Type-2 Fuzzy Systems Based on Error Backpropagation
Table 4.3 (continued)
zprim=b.*zu; 
do_dcu(ii,jj,:)=(u(ii)-cu(ii,jj))./sigmau(ii,jj)^2*(zprim'*wu)./szu-sum(zprim)*ou/szu; 
do_dsigmau(ii,jj,:)=(u(ii)-cu(ii,jj))^2./sigmau(ii,jj)^3*(zprim'*wu)./szu￾sum(zprim)*ou/szu; 
%------------- lower ----
zprim=b.*zl; 
do_dcl(ii,jj,:)=(u(ii)-cl(ii,jj))./sigmal(ii,jj)^2*(zprim'*wl)./szl-sum(zprim)*ol/szl; 
do_dsigmal(ii,jj,:)=(u(ii)-cl(ii,jj))^2./sigmal(ii,jj)^3*(zprim'*wl)./szl￾sum(zprim)*ol/szl; 
end 
end 
The fuzzy system script 
function y=FS_type_2(u,cu,cl,sigmau,sigmal,wu,wl,rule) 
% u is n*1 where n is number of inputs 
% c is n*n_MF where n_MF is the number of MFs for this input 
% the dimension of sigma is the same as c 
% the variable rule represent the rule database. 
% rule is n_rule*n, where n_rule is the number of rules 
%% 
% clear all 
% clc 
% u=[1 2]'; 
% c=[-1 0 1;-1 0 1]; 
% sigma=ones(size(c)); 
% rule=[1 3; 2 3]; 
% w=rand(2,1);-2 2 
%c=[-2 -1 0 1 2;3 4 0 5 6] 
%% MF 
n_MF=size(cu,2); 
x=repmat(u,1,n_MF); 
MFu= exp(-(x-cu).^2./sigmau.^2); 
MFl= exp(-(x-cl).^2./sigmal.^2); 
%% Rule fiering 
for ii=1:size(rule,2) 
au(:,ii)=MFu(ii,rule(:,ii)); 
al(:,ii)=MFl(ii,rule(:,ii)); 
end 
zu=prod(au,2);%min 
zl=prod(al,2);%min 
%% Type reduction 
%z=(zu+zl)/2; % Nie-Tan 
szu=(sum(zu)+0.0001); 
do_dwr=zu/szu; 
ou=do_dwr'*wu; 
szl=(sum(zl)+0.0001); 
do_dwl=zl/szl; 
ol=do_dwl'*wl; 
y=(ou'+ol')/2; 
The LM script 
function w=LM(e,w,J,Mu) 
w=w+(Mu*eye(size(w,1))+(J*J'))\J*e;%diag(diag(J(:,ii)*J(:,ii)')) 
zu=prod(au,2);%min 
zl=prod(al,2);%min 
%% Type reduction 
%z=(zu+zl)/2; % Nie-Tan 
szu=(sum(zu)+0.0001); 
do_dwu=zu/szu; 
ou=do_dwu'*wu; 
szl=(sum(zl)+0.0001); 
do_dwl=zl/szl; 
ol=do_dwl'*wl; 
%% do-dparam 
for ii=1:size(rule,2) 
for jj=1:size(cu,2) 
b=rule(:,ii)==jj; 
%------------- upper ------------References 93
References 
1. L.X. Wang, Combining mathematical model and heuristics into controllers: An adaptive fuzzy 
control approach. Fuzzy Sets Syst. 89, 151–156 (1997) 
2. M. Hojati, S. Gazor, Hybrid adaptive fuzzy identification and control ofnonlinear systems. IEEE 
Trans. Fuzzy Syst. 10, 198–210 (2002) 
3. M.J. Er, S.H. Chin, Hybrid adaptive fuzzy controllers of robotmanipulators with bounds 
estimation. IEEE Trans. Ind. Electron. 47, 1151–1160 (2000) 
4. C.H. Wang, T.C. Lin, T.T. Lee, H.L. Liu, Adaptive hybrid intelligentcontrol for uncertain 
nonlinear dynamical systems. IEEE Trans. Syst. Man Cybern. Part B-Cybern. 32, 583–597 
(2002) 
5. S.C. Tong, T.Y. Chai, Fuzzy indirect adaptive control for a class ofdecentralized nonlinear 
systems. Int. J. Syst. Sci. 29, 149–157 (1998) 
6. B. Yoo, W. Ham, Adaptive fuzzy sliding mode control of nonlinearsystem. IEEE Trans. Fuzzy 
Syst. 6, 315–321 (1998) 
7. C.W. Park, Y.W. Cho, T-S model based indirect adaptive fuzzy controlusing online parameter 
estimation. IEEE Trans. Syst. Man Cybern. Part B-Cybern. 34, 2293–2302 (2004) 
8. C.W. Park, M. Park, Adaptive parameter estimator based on T-S fuzzymodels and its applications 
to indirect adaptive fuzzy control design. Inf. Sci. 159, 125–139 (2004)Chapter 5 
Baseline Indirect Adaptive Control 
5.1 Problem Specifications 
Assume an n-order nonlinear system described as the following equations [1]: 
x(n) = f (x, x˙,..., x(n−1)
) + g(x, x˙,..., x(n−1)
)u 
y = x (5.1) 
where f and g are unknown functions, and y ∈ R, u ∈ R indicate the input 
and output of the system, respectively. Furthermore, X = (x1, x2,..., xn)
T = 
x, x˙,..., x(n−1)
T 
∈ Rn is the state vector of this system, which is assumed to be 
measurable. To make Eq. (3.1) controllable, it is necessary that g(x) = 0. Without 
losing generality, it is assumed that g(x) > 0. In the texts about nonlinear control, 
these systems have a normal form with a relative degree of n. 
The purpose of control is to design a feedback controller u = (X|θ ) based on 
fuzzy systems and a moderation rule to regulate the parameter vector θ in a way that 
the system output (y) follows the ideal output ym. 
Since f (X), g(X ) are nonlinear in the system and are assumed unknown, the 
problem is the SISO nonlinear control. 
Hence, the purpose of control does not emphasize that the system output must 
converge on the output ym asymptotically. However, it is only necessary that y 
approaches ym as much as possible. 
5.2 Designing Fuzzy Controller 
If nonlinear functions are known, then it is possible to select the control of u in a 
way that the nonlinear section is eliminated and that the controller is designed on 
the basis of the linear control theory (e.g., for polarity placement). In particular, it is 
assumed that e = ym − x, e = (e, e˙,..., e(n−1)
)T , K = (kn,..., k1) when all roots
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
A. Mohammadzaheh et al., Modern Adaptive Fuzzy Control Systems, Studies in Fuzziness 
and Soft Computing 421, https://doi.org/10.1007/978-3-031-17393-6_5 
9596 5 Baseline Indirect Adaptive Control
of the polynomial sn + k1s + ··· + kn are within the half interval on the left side of 
the mixed plane. The control rule is selected as below: 
u∗ = 1 
g(x)

− f (x) + y(n) m + K T e
 (5.2) 
The closed-loop system will be as below by replacing Eq. (5.2) in Eq. (5.1): 
en + k1e + ··· + kne = 0 (5.3) 
Due to selecting K, there will be e(t) → 0 when t → ∞. In other words, the 
system output converges on the favorable output asymptotically. 
Since f (X ), g(X ) are unknown, the ideal controller (3.2) cannot be used. Hence, a 
reasonable idea is to approximate f (X ), g(X) with fuzzy systems ˆf (X ), gˆ(X ), some 
parameters of which are left free so that they can change online during the operations 
to enhance the approximation accuracy. Assume that θ f ∈ RMf , θg ∈ RMg represent 
free parameters in ˆf (X ), gˆ(X ); therefore, ˆf (X ) = ˆf (X|θ f ), gˆ(X ) = ˆg(X|θg). By 
replacing f (X ), g(X) in Eq. (5.2) with fuzzy systems ˆf (X|θ f ), gˆ(X|θg), the fuzzy 
controller will be as below: 
u = uI = 1 
gˆ(X|θg)

− ˆf (X|θ f ) + y(n) m + K T e

(5.4) 
This fuzzy controller is called the certainty equivalent controller, for if ˆf , g ˆ are 
equal to their corresponding f, g, then the controller uI will be the ideal controller 
u∗ of Eq. (5.2). 
The formulas and details of ˆf (X|θ f ), gˆ(X|θg) should be determine to implement 
Controller (5.4). In particular, ˆf (X|θ f ), gˆ(X|θg) consist of the following two steps: 
Step 1: Define (li = 1, 2,..., Pi )Ali 
i and (li = 1, 2,..., Pi )Bli 
i for variables 
Pi , (i = 1, 2,..., n)xi . 
Step 2: Construct the fuzzy system ˆf (X|θ f ) from Rule (5.5)
n 
i=1 Pi : if x1 is Bl1 
1 
and xn is Aln 
n , then ˆf is E L1...Ln . 
Likewise, construct the fuzzy system gˆ(X|θg) from Rule (5.6)
n 
i=1 qi : if x1 is Al1 
1 
and xn is Bln 
n , then g ˆ is H L1...Ln . In particular, the means of centers will be determined 
by using the product inference engine, a single fuzzifier, and a defuzzifier [1]: 
ˆf (X|θ f ) =
	P1 
l1=1 ···	Pn 
ln=1 y
l1...ln 
f
n 
i=1 μ
li 
Ai 
(xi )

	P1 
l1=1 ···	Pn 
ln=1
n 
i=1 μ
li 
Ai 
(xi )
 (5.5) 
gˆ(X|θ f ) =
	q1 
l1=1 ...	qn 
ln=1 yl1...ln 
g
n 
i=1 μ
li 
Bi 
(xi )

	q1 
l1=1 ···	qn 
ln=1
n 
i=1 μ
li 
Bi 
(xi )
 (5.6)5.3 Designing Moderation Principle 97
where Pi is the fuzzy set Ali 
i with the assumption that y
l1...ln 
f and yl1...ln 
g are free 
parameters collected from θ f ∈ R
n 
i=1 Pi , θg ∈ R
n 
i=1 qi , respectively. Therefore, 
Eqs. (5.7) and (5.8) are rewritten as below: 
ˆf (X|θ f ) = θ T 
f ξ(X) (5.7) 
gˆ(X|θg) = θ T 
g η(X) (5.8) 
where ξ(X ) is a n 
i=1 Pi-dimensional vector with the L1 ... Ln elements. 
ξL1...Ln (X ) =
n 
i=1 μ
li (xi )
Ai
	P1 
l1=1 ···	Pn 
ln=1
n 
i=1 μ
li (xi )
Ai
 (5.9) 
Moreover, η(X ) is a n 
i=1 qi-dimensional vector with the L1 ... Ln elements. 
ηL1...Ln (X ) =
n 
i=1 μ
li (xi )
Bi
	q1 
l1=1 ···	qn 
ln=1
n 
i=1 μ
li (xi )
Bi
 (5.10) 
The next goal is to design a moderation principle for θ f , θg to minimize the 
tracking error. 
5.3 Designing Moderation Principle 
By placing Eq. (5.4) into Eq. (5.1) after a few mathematical operations, the dynamics 
of the closed-loop fuzzy control system will be determined as below: 
e(n) = −K T e +

ˆf (X|θ f ) − f (x)

+ 
gˆ(X|θg) − g(x)

uI (5.11) 
Assume that:
 =
⎡
⎢
⎢
⎢
⎢
⎢
⎣
0 1 0 0 ··· 00 
0 0 1 0 ··· 00 
.
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
.
0 0 0 0 ··· 01 
−kn −kn−1 ··· ··· ··· ··· −k1 
⎤
⎥
⎥
⎥
⎥
⎥
⎦
, b =
⎡
⎢
⎢
⎢
⎣
0 
.
.
.
0 
1 
⎤
⎥
⎥
⎥
⎦
(5.12) 
Then the above dynamic equation can be rewritten in a vectorized form:98 5 Baseline Indirect Adaptive Control
e ˙ = e +
 ˆf (X|θ f ) − f (x)

+ 
gˆ(X|θg) − g(x)

uI

(5.13) 
The optimal parameters are defined as below: 
θ ∗
f = arg 
θ f ∈R 
min
n
i=1 
Pi 
⎡
⎣sup


 ˆf (X|θ f ) − f (x)



X∈Rn 
⎤
⎦ (5.14) 
θ ∗
g = arg 
θg∈R 
min
n
i=1 
qi

sup
gˆ(X|θ f ) − g(x)


X∈Rn

(5.15) 
Therefore, ˆf (X|θ f ), gˆ(X|θg) denote the best (min–max) estimators of 
f (x) , g(x) in all fuzzy systems. The least approximation error is defined as below: 
w =

ˆf (X|θ ∗
f ) − f (X )

+ 
gˆ(X|θ ∗
g ) − g(X )

uI (5.16) 
Equation (5.13) can be rewritten as below by using w: 
e ˙ = e +
 ˆf (X|θ f ) − ˆf (X|θ ∗
f )

+ 
gˆ(X|θg) − ˆg(X|θ ∗
g )

uI

(5.17) 
By replacing Eqs. (5.7) and (5.8) in Eq. (5.17), the dynamic closed-loop equation 
will be obtained as below. It clearly indicates the dependence between tracking error 
and controller parameters θ f , θg: 
e ˙ = e + b

(θ f |θ ∗
f )
T ξ(X) + (θg|θ ∗
g )
T η(X)uI + w
 (5.18) 
The moderation principle is responsible for determining a regulation mechanism 
for θ f , θg to minimize the tracking error and errors of parameters θg−θ ∗
g and θ f −θ ∗
f . 
For this purpose, the following candidate Lyopunov function is considered: 
V = 1 
2 
eT Pe +
1 
2γ1

θ f − θ ∗
f
T 
θ f − θ ∗
f

+
1 
2γ2

θg − θ ∗
g
T 
θg − θ ∗
g
 (5.19) 
where γ1, γ2 are positive constants, and P is a positive certain matrix meeting the 
Lyopunov equation.
T P + P = −Q (5.20) 
where Q is an arbitrary n × n positive certain matrix, and  is obtained from 
Eq. (3.14). 
The temporal derivative of V along the closed-loop path (3.20) is as below:5.4 Application in Moderation of Inverted Pendulum 99
V ˙ = −1 
2 
eT Pe + eT Pbw +
1 
γ1

θ f − θ ∗
f
T 
θ˙f + γ1eT Pbξ(X )

+
1 
γ2

θg − θ ∗
g
T 
θ˙
g + γ2eT Pbη(X )uI
 (5.21) 
The moderation principle should be selected to make V ˙ negative in order to 
minimize the tracking error e and the errors of parameters of θg − θ ∗
g and θ f − θ ∗
f . 
Since −1 
2 eT Pe is negative and it is possible to select the fuzzy systems in a way 
that the approximation error w decreases, a good strategy is to select the moderation 
principle by making the last two expressions zero in Eq. (3.23). In other words, the 
moderation principle will be as below: 
θ˙f = −γ1eT Pbξ(X ) (5.22) 
θ˙
g = −γ2eT Pbη(X)uI (5.23) 
• The above analysis assumes that the estimation error is small and can be ignored. 
However, the estimation error cannot be disregarded in practice; therefore, further 
attempts should be made to eliminate the effects of the estimation error. In [1– 
5], the stability analysis was valid only by assuming that the squared estimation 
error was integrable. Some researchers added another term to the control rule 
to eliminate the effect of the estimation error [6–10]. Some of the researchers 
proposed a method for estimating the upper bound of the estimation error [11–15]. 
• The adaptability rule obtained from Eqs. (5.22) and (5.23) cannot guarantee that 
the fuzzy system parameters remain bounded. To solve this problem, the modified 
adaptability rules were proposed in some papers [1, 9]. 
• When gˆ(X|θg) becomes zero in Control Rule (5.4), the singularity problem may 
arise. In practice, necessary measures should be taken. It was assumed in [16, 
17] that ∂g(x)
∂xn = 0 to design the novel adaptive controllers which could solve the 
singularity problem. 
• There is no guarantee that the state vector x remains within the favorable range 
Ux . Some researchers [1, 4, 18, 19] integrated the adaptive fuzzy control with the 
supervised control to keep the controlled system state variables within the favor￾able range without needing the high adaptive interest. When the state variables are 
within the favorable range, the supervised control is zero. When these variables 
move out of the favorable range, the supervised controller starts operating and 
guides them inside the area of interest. 
5.4 Application in Moderation of Inverted Pendulum 
Consider the inverted pendulum system (Figs. 5.1 and 5.2).100 5 Baseline Indirect Adaptive Control
Fig. 5.1 The inverted 
pendulum system 
Fig. 5.2 Simulink—implementation of indirect adaptive fuzzy control on the inverted pendulum 
system 
x˙1 = x2 
x˙2 =

g sin(x1) − mlx 2 
2 sin(x1) cos(x1)
mc + m

. 1 
l

4 
3 − m cos2(x1)
mc+m

+
cos(x1)
mc + m . 1 
l

4 
3 − m cos2(x1)
mc+m
u (5.24) 
where x1 and x2 denote the angle and velocity of the pendulum, respectively. Further￾more, mc and m represent the mass of the chariot and the mass of the pendulum, 
respectively, whereas l refers to the half of the pendulum’s length. The following5.5 Conclusion 101
Fig. 5.3 The output diagram—the results of implementing indirect adaptive fuzzy control on the 
inverted pendulum 
values are considered in the simulation: 
m = 0.1 kg, mc = 1 kg,l = 0.5m 
Five membership functions are considered for each of the inputs; hence, there will 
be 125 rules in total. 
The control parameters were selected as below: 
k = 
2 1 T 
, Q = −
10 0 
0 10 
, P =

15 5 
5 5 
, γ = 10 
The initial conditions were defined as pi /20, pi /10, and the following results 
were obtained: 
According to Fig. 5.3, the output was within the favorable state in less than 10 s. 
It should be mentioned that if the initial conditions are considered slightly larger, the 
estimation error will be so high that it cannot be disregarded; therefore, the system 
will be unstable. The next chapters introduce some methods for eliminating the effect 
of the estimation error. 
5.5 Conclusion 
There have been noteworthy developments in adaptive fuzzy controllers in the recent 
decade. In fact, various schemes have been published in different papers; however, 
there are still some limitations that require further research.102 5 Baseline Indirect Adaptive Control
The Lyopunov stability technique was used as the most important mathematical 
tool in this chapter to analyze the stability of adaptive fuzzy control. 
This chapter also presented a baseline framework for designing adaptive fuzzy 
control for the systems in which the inputs emerge as linear (i.e., affine systems). The 
basic concepts were introduced as ideal control, ideal parameters, least estimation 
error, and adaptability rules. The major problem with indirect adaptive fuzzy control 
is the effect of estimation error. 
References 
1. L.-X. Wang, Adaptive Fuzzy Systems and Control: Design and Stability Anyalysis. Prentice￾Hall: Englewood Cliffs, New Jersey (1994) 
2. M.F. Alexander Fink, O. Nelles, R. Isermann, Supervision of nonlinear adaptive controllers 
based on fuzzy models (2000) 
3. S.C. Tong, H.X. Li, G.R. Chen, Adaptive fuzzy decentralized controlfor a class of large-scale 
nonlinear systems. IEEE Trans. Syst. Man Cybern. Part B Cybern. 34, 770–775 (2004) 
4. C.H. Wang, T.C. Lin, T.T. Lee, H.L. Liu, Adaptive hybrid intelligent control for uncertain 
nonlinear dynamical systems. IEEE Trans. Syst. Man Cybern. Part B Cybern. 32, 583–597 
(2002) 
5. K. Fischle, D. Schroder, An improved stable adaptive fuzzy control method. IEEE Trans. Fuzzy 
Syst. 7, 27–40 (1999) 
6. E. Kim, Output feedback tracking control of robot manipulators with model uncertainty via 
adaptive fuzzy logic. IEEE Trans. Fuzzy Syst. 12, 368–378 (2004) 
7. Y.G. Leu, W.Y. Wang, T.T. Lee, Observer-based direct adaptive fuzzy-neural control for 
nonaffine nonlinear systems. IEEE Trans. Neural Networks 16, 853–861 (2005) 
8. Y.X. Diao, K.M. Passino, Stable fault-tolerant adaptive fuzzy/neural control for a turbine 
engine. IEEE Trans. Control Syst. Technol. 9, 494–509 (2001) 
9. Y.C. Chang, Adaptive fuzzy-based tracking control for nonlinear SISO systems via VSS and 
H-infinity approaches. IEEE Trans. Fuzzy Syst. 9, 278–292 (2001) 
10. J.T. Spooner, M. Maggiore, R. Ordonez, K.M. Passino, Stable Adaptive Control and Estimation 
for Nonlinear Systems: Neural and Fuzzy Approximation Techniques (John Wiley & Sons, New 
York, 2002) 
11. Y.H. Park, G.T. Park, Design of a robust adaptive fuzzy controller globally stabilizing the 
multi-input nonlinear system with state-dependent uncertainty. Control. Cybern. 27, 613–629 
(1998) 
12. Y.X. Diao, K.M. Passino, Adaptive neural/fuzzy control for interpolated nonlinear systems. 
IEEE Trans. Fuzzy Syst. 10, 583–595 (2002) 
13. J.H. Park, G.T. Park, Robust adaptive fuzzy controller for non-affine nonlinear systems with 
dynamic rule activation. Int. J. Robust Nonlinear Control 13, 117–139 (2003) 
14. M.J. Er, S.H. Chin, Hybrid adaptive fuzzy controllers of robot manipulators with bounds 
estimation. IEEE Trans. Industr. Electron. 47, 1151–1160 (2000) 
15. J.T. Spooner, K.M. Passino, Stable adaptive control using fuzzy system and neural networks. 
IEEE Trans. Fuzzy Syst. 4, 339–359 (1996) 
16. S.S. Ge, T.H. Lee, C.J. Harris, Adaptive Neural Network Control of Robotic Manipulators 
(World Scientific, London, 1998) 
17. S.S. Ge, C.C. Hang, T.H. Lee, T. Zhang, Stable Adaptive Neural Network Control (Kluwer 
Academic Publishers, London, 2002) 
18. C.H. Wang, H.L. Liu, T.C. Lin, Direct adaptive fuzzy-neural control with state observer and 
supervisory controller for unknown nonlinear dynamical systems. IEEE Trans. Fuzzy Syst. 10, 
39–49 (2002) 
19. D.L. Tsay, H.Y. Chung, C.J. Lee, The adaptive control of nonlinear systems using the Sugeno￾type of fuzzy logic. IEEE Trans. Fuzzy Syst. 7, 225–229 (1999)Chapter 6 
Type-2 Indirect Adaptive Control 
with Estimation Error Approximation 
6.1 Introduction 
As mentioned in the previous chapter, the effect of estimation error is a limitation 
of the indirect adaptive fuzzy controller. This chapter presents the type-2 indirect 
adaptive control method with estimation error approximation. The idea of this process 
is to use a switch, for the controller must be able to automatically switch between 
two modes. 
6.2 Literature Review 
In the previous chapter, the estimation error was assumed to be small and negligible. 
In practice, the estimation error cannot be disregarded [1–5]. The stability analysis 
is valid only with the assumption that the squared estimation error is integrable. 
Some researchers added another term to the control rule to eliminate the effect of the 
estimation error [6, 7]. Some other researchers proposed a method for approximating 
the upper bound of the estimation error [3, 8–10]. 
Park [9] solved this problem by approximating the estimation error bound through 
the fuzzy logic, something which would require the manual configuration of fuzzy 
estimators. Sun et al. [10], Park [11], and Ge [12] proposed different solutions by 
using an adaptive rule with the correction of σ to update estimators. This process 
guarantees that the estimation error remains bounded. 
In [13, 14], bounded estimators were proposed by assuming that the fuzzy models 
of systems were available. In an algorithm developed for regulating the fuzzy system 
parameters, a designer would need to design the fuzzy system manually. The advan￾tage of these controllers is that they need fewer adaptive parameters by disregarding 
the controlled system complexity. Thus, they yield higher levels of computational 
efficiency.
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
A. Mohammadzaheh et al., Modern Adaptive Fuzzy Control Systems, Studies in Fuzziness 
and Soft Computing 421, https://doi.org/10.1007/978-3-031-17393-6_6 
103104 6 Type-2 Indirect Adaptive Control with Estimation Error …
To distinguish the above two methods, this chapter focuses on the training of 
controller parameters and switch conditions [15]. 
6.3 Resistant Adaptive Fuzzy Control with Estimation 
Error Elimination 
6.3.1 Problem Specifications 
According to Chap. 5, the control problem is defined as below: 
x(n) = f (x, x˙,..., x(n−1)
) + d + u 
y = x (6.1) 
where f is an uncertain nonlinear function estimated by an interval type-2 fuzzy 
system, and d represents the bounded distortion. The control purpose is that the 
system of interest should track a reference input. 
6.3.2 Estimating Uncertainties 
Consider the fuzzy system structure in (6.1). The fuzzy system output is as follows: 
y = yr + yl 
2 (6.2) 
where 
yr =
ΣR 
j=1 z j 
l wj 
r + ΣM 
j=R+1 z j 
uwj 
r 
ΣR 
j=1 z j 
l + ΣM 
j=R+1 z j 
u 
, yl =
ΣL 
j=1 z j 
uwj 
l + ΣM 
j=L+1 z j 
l wj 
l 
ΣL 
j=1 z j 
u + ΣM 
j=L+1 z j 
l 
(6.3) 
where wj 
r and wj 
l denote the jth weights of the upper bound and lower bound rules: 
wj 
r = α j 
0 + α j 
1 x1 + α j 
2 x2, wj 
l = β j 
0 + β j 
1 x1 + β j 
2 x2 (6.4) 
where (
α j 
0 , α j 
1 , α j 
2 )
and (
β j 
0 , β j 
1 , β j 
2 )
represent the parameters of the first-order 
function in the jth upper bound and lower bound rule. Moreover, x1 and x2 are the 
fuzzy system inputs. 
Chapter 3 presented the definitions of other variables in detail. The upper and 
lower bounds of membership functions are defined as below (Fig. 6.1).6.3 Resistant Adaptive Fuzzy Control with Estimation Error … 105
μp 
ui 
(x) = exp (
−1 
2 )xi − x p 
i 
σ p 
ui 
(2 )
(6.5) 
1 
1 µ u
1 
2 µ u
1 
N µ u
1 
1 µ l
1 
2 µ l
1 
N µ l
2 
1 µ u
2 
2 µ u
2 
N µ u
2 
1 µ l
2 
2 µ l
2 
N µ l
1 x 
2 x 
1 
u z 
2 
u z 
N 
u z 
N 1
u z + 
N 2
u z + 
2N 
u z 
( 1) 1 NN 
u z −+ 
( 1) 2 NN 
u z −+ 
2 N 
u z 
1 
l z 
2 
l z 
N 
l z 
N 1
l z + 
N 2
l z + 
2N 
l z 
2 N 
l z 
( 1) 1 NN 
l z −+ 
( 1) 2 NN 
u z −+ 
11 
u l zw 
22 
u l zw 
LL 
u l zw 
LL 1 1
l l z w++ 
LL 2 2
l l z w++ 
MM 
l l zw 
RR 1 1
u r z w++ 
MM 
u r zw 
11 
l r zw 
RR 
l r zw 
22 
l r zw 
r y l y y 
Membership Layer Rule Layer Type Reduction Output Layer 
Fig. 6.1 The type-2 fuzzy system with two inputs106 6 Type-2 Indirect Adaptive Control with Estimation Error …
μp 
li 
(x) = exp 
⎛
⎝−1 
2 (
xi − x p 
i 
σ p 
li )2 ⎞
⎠ (6.6) 
where μp 
ui and μp 
li denote the outputs of the pth membership functions of upper and 
lower bounds for the ith input. Furthermore, σ p 
ui , σ p 
li denote the widths of upper and 
lower bounds of membership functions, respectively, for the ith input. 
The firing strengths of the rules are as below: 
z j 
l (x) = μp 
l1 
(x)μq 
l2 
(x)
z j 
u(x) = μp 
u1 
(x)μq 
u2 
(x)
(6.7) 
where z j 
u and z j 
l denote the jth upper bound and lower bound rules, respectively. 
6.3.3 Designing Controller 
For the parameter regulation of ˆf (x|θ f ), the derivative of ˆf (x|θ f ) should be deter￾mined with respect to each of the parameters. The ideal parameters are defined as 
below: 
θ ∗
f = arg min [
supx∈Ux 
|
|
| ˆf (x 
|
|θ f ) − f (x)
|
|
|
]
(6.8) 
Based on the Taylor series: 
ˆf (x 
|
|θ f ) − ˆf (x 
|
|θ ∗
f ) = (
θ f − θ ∗
f )T [
δ ˆf (x|θ f )
δθ f ]
+ o (|
|θ f − θ ∗
f 
|
|
2 )
(6.9) 
where o )|
|
|
θ f − θ ∗
f 
|
|
|
2 (
indicates the high-order terms. Therefore: 
ˆf (x 
|
|θ f ) = ζ T θ f (6.10) 
where ζ f (x) = δ ˆf (x|θ f )
δθ f . The parameters of θ f that should be regulated include α, β, 
x, and σ in 
The type-2 fuzzy neural network (T2FNN) system, in which the following 
equations are defined to calculate the derivative of δ ˆf (x|θ f )
δθ f :6.3 Resistant Adaptive Fuzzy Control with Estimation Error … 107
Zu =
⎡
⎢
⎢
⎢
⎣
z11 
u z21 
u ··· zN1 
u 
z12 
u z22 
u ··· zN2 
u 
.
.
. .
.
. ··· .
.
.
z1N 
u z2N 
u ··· zNN 
u 
⎤
⎥
⎥
⎥
⎦
N×N 
(6.11) 
Zl =
⎡
⎢
⎢
⎢
⎣
z11 
l z21 
l ··· zN1 
l 
z12 
l z22 
l ··· zN2 
l 
.
.
. .
.
. ··· .
.
.
z1N 
l z2N 
l ··· zNN 
l 
⎤
⎥
⎥
⎥
⎦
N×N 
(6.12) 
wr = [
w1 
r w2 
r ...wj 
r ...wN 
r ]
N×N 
wl =
[
w1 
l w2 
l ...wj 
l ...wN 
l ]
N×N 
(6.13) 
where N denotes the number of membership functions for each input in the T2FNN. 
Moreover, R and L are the parameters used for type reduction, whereas wl and wu 
are the consequent parameters. In addition, zij is defined as below: 
zij 
u = exp 
⎛
⎝−1 
2 (
x1 − xi 
u1 
σi 
u1 )2 ⎞
⎠ exp 
⎛
⎝−1 
2 (
x2 − x j 
u2 
σ j 
u2 )2 ⎞
⎠
z
ij 
l = exp 
⎛
⎝−1 
2 (
x1 − xi 
l1 
σi 
l1 )2 ⎞
⎠ exp 
⎛
⎝−1 
2 (
x2 − x j 
l2 
σ j 
l2 
)2 ⎞
⎠
(6.14) 
The matrix R is created with the single term R and M–R of term zero as below: 
R =
⎡
⎢
⎢
⎢
⎣
1 ··· 10 ··· 0 
1 ··· 10 ··· 0 
.
.
. ··· .
.
. ··· ··· .
.
.
1 ··· 00 ··· 0 
⎤
⎥
⎥
⎥
⎦
N×N 
(6.15) 
Similarly, L is created with the single term L and M–L of zero. Moreover, R and 
L are defined as the complements of R and L, respectively. With these definitions, 
yr and yl are simplified as below: 
yr =
ΣN 
i=1 
ΣN 
j=1 (
R(i, j )Zl (i, j ) + R(i, j )Zu(i, j )
)
wr (i, j )
ΣN 
i=1 
ΣN 
j=1 (
R(i, j )Zl (i, j ) + R(i, j )Zu(i, j )
) (6.16) 
yl =
ΣN 
i=1 
ΣN 
j=1 (
L(i, j )Zu(i, j ) + L(i, j )Zl (i, j )
)
wl (i, j )
ΣN 
i=1 
ΣN 
j=1 (
L(i, j )Zu(i, j ) + L(i, j)Zl (i, j )
) (6.17)108 6 Type-2 Indirect Adaptive Control with Estimation Error …
To calculate δ ˆf (x|θ f )
δα , the following equations is used: 
δ ˆf (x|θ f )
δα = δ ˆf (x|θ f )
δy 
δy 
δα
where y is the output of T2FNN. 
δy 
δαij 
0 
= δy 
δyr 
δyr 
δwij 
r 
δwij 
r 
δαij 
0 
= 1 
2 
R(i, j )Zl (i, j ) + R(i, j )Zu(i, j )
ΣN 
i=1 
ΣN 
j=1 (
R(i, j )Zl (i, j ) + R(i, j )Zu(i, j )
) (6.18) 
δy 
δαij 
1 
= δy 
δαij 
0 
x1, δy 
δαij 
2 
= δy 
δαij 
2 
x2 (6.19) 
Furthermore, αij 
1 denotes the weights of the ith row and the jth column. 
To calculate δ ˆf (x|θ f )
δβ , the following equations are used: 
δ ˆf (x|θ f )
δβ = δ ˆf (x|θ f )
δy 
δy 
δβ
δy 
δβij 
0 
= δy 
δyl 
δyl 
δwij 
l 
δwij 
l 
δβij 
0 
= 1 
2 
L(i, j)Zu(i, j ) + L(i, j )Zl (i, j )
ΣN 
i=1 
ΣN 
j=1 (
L(i, j )Zu(i, j ) + L(i, j )Zl (i, j )
) (6.20) 
δy 
δβij 
1 
= δy 
δβij 
0 
x1, δy 
δβij 
2 
= δy 
δβij 
0 
x2 (6.21) 
After that, δ ˆf (x|θ f )
δx p 
1 
is obtained. In addition, x p 
1 is the pth center of the membership 
function for the first input. It emerges on the row of 1−N and the column of p in Zk 
u 
and Zk 
l . By defining yr = A 
B , the following equations will be obtained: 
∂yr 
∂x p 
1 
= A'
B − B'
A 
B2 = A' − yk 
r B'
B 
A' = Σ
N
j=1 ⎛
R(j, p)Zl (j, p)
2 (
x1 − x p 
1 )
(
σ p 
l1 
)2 
+R(j, p)Zu(j, p)
2 (
x1 − x p 
1 )
(
σ p 
u1 )2 ⎫
wr (j, p)6.3 Resistant Adaptive Fuzzy Control with Estimation Error … 109
B' = Σ
N
j=1 ⎛
R(j, p)Zl (j, p)
2 (
x1 − x p 
1 )
(
σ p 
l1 
)2 
+R(j, p)Zu(j, p)
2 (
x1 − x p 
1 )
(
σ p 
u1 )2 ⎫
(6.22) 
where ∂yl 
∂x p 
1 
is similar to ∂yr 
∂x p 
1 
, and the replacements of R → L, R → L, Zk 
l ↔ Zk 
u , 
and Zk 
l ↔ Zk 
u , why do some people use wr → wl .The process of calculating ∂yr 
∂σ p 
u1 
is 
as follows wit σ p 
u1 indicating the first arrival at T2FNN: 
∂yr 
∂σ p 
u1 
= A'
B − B'
A 
B2 = A' − yr B'
B 
A' = Σ
N
j=1 ⎛
R(j, p)Zu(j, p)
2 (
x1 − x p 
1 )2 
(
σ p 
u1 )3 ⎫
wr (j, p)
B' = Σ
N
j=1 ⎛
R(j, p)Zu(j, p)
2 (
x1 − x p 
1 )2 
(
σ p 
u1 )3 ⎫
(6.23) 
where ∂yl 
∂σ p 
u1 
resembles ∂yr 
∂σ p 
u1 
. Moreover, R → L and wr → wl should be replaced. 
After that, δ ˆf (x|θ f )
δx p 
2 
is calculated. Moreover, x p 
2 denotes the pth membership functions 
for the second input. It emerges in the columns of 1−N and the row of p in Zu and 
Zl . The calculation of δ ˆf (x|θ f )
δx p 
2 
is similar to that of δ ˆf (x|θ f )
δx p 
1 
as below: 
∂yk 
r 
∂x p 
2 
= A'
B − B'
A 
B2 = A' − yk 
r B'
B 
A' = Σ
N
j=1 ⎛
R k (p, j )Zk 
l (p, j )
2 (
x2 − x p 
2 )
(
σ p 
l2 
)2 
+Rk (p, j )Zk 
u (p, j )
2 (
x2 − x p 
2 )
(
σ p 
u2 )2 ⎫
wk 
r (p, j )
B' = Σ
N
j=1 ⎛
R k (p, j )Zk 
l (j, p)
2 (
x2 − x p 
2 )
(
σ p 
l2 
)2 
+Rk (p, j )Zk 
u (p, j)
2 (
x2 − x p 
2 )
(
σ p 
u2 )2 ⎫
(6.24) 
where ∂yl 
∂x p 
2 
equals ∂yr 
∂x p 
2 
through R → L, R → L, Zl ↔ Zu, and wr → wl . The 
process of calculating ∂yr 
∂σ p 
u2 
is as follows, and σ p 
u2 indicates the width of the upper110 6 Type-2 Indirect Adaptive Control with Estimation Error …
bound of the second input: 
∂yr 
∂σ p 
u2 
= A'
B − B'
A 
B2 = A' − yr B'
B 
A' = Σ
N
j=1 ⎛
R(p, j )Zu (p, j )
2 (
x2 − x p 
2 )2 
(
σ p 
u2 )3 ⎫
wr (p, j )
B' = Σ
N
j=1 ⎛
R(p, j )Zu(p, j )
2 (
x2 − x p 
2 )2 
(
σ p 
u2 )3 ⎫
(6.25) 
where ∂yl 
∂σ p 
u2 
equals ∂yr 
∂σ p 
u2 
through R → L and wr → wl . 
6.3.4 Designing Controller 
Figure 6.2 demonstrates the control block diagram. The control rule is defined as 
below: 
u =
)
− ˆf (x 
|
|θ f ) + K T 
e +
dnr 
dt n (
+ us (6.26) 
where us is utilized to compensate for the estimation error and the noise effect. 
Furthermore, r denotes the baseline system output, and ˆf (x 
|
|
|
θ f ) represents a type-2 
neuro-fuzzy system used for the estimation of f (x). Moreover, e = r − y and e =
Fig. 6.2 The control block diagram6.3 Resistant Adaptive Fuzzy Control with Estimation Error … 111
Fig. 6.3 The MATLAB block diagram—simulating a chaotic system with an indirect two-mode 
adaptive fuzzy controller 
Fig. 6.4 The membership functions considered for each input
(
e, e˙, e¨, ..., e(n−1)
)
. The term K = (k1, k2, ..., kn)
T should be selected in a way that 
sn + knsn−1 + ··· + k1 will become the Hurwitz stable polynomial. The parameters 
of E0 andΔT0 are the designer-determined constants. Further explanations on the 
switching method will be provided in the following.112 6 Type-2 Indirect Adaptive Control with Estimation Error …
Fig. 6.5 The output diagram with the reference input diagram—designing an indirect two-mode 
adaptive fuzzy controller for a chaotic system
6.3.5 Analysis of Stability and Inference of Adaptive Rules 
The control signal is placed into the system equations: 
dn x1 
dt n = f (x) + d +
)
− ˆf (x 
|
|θ f ) + K T 
e +
dn y1 
dt n (
+ us (6.27) 
After simplification: 
dne 
dt n = −K T 
e +
( ˆf (x 
|
|θ f ) − f (x) − d )
− us (6.28) 
In a matrix form: 
˙
e = Δce + bc [
ˆf (x 
|
|θ f ) − f (x) − d − us ]
(6.29) 
where 
Δc =
⎡
⎢
⎢
⎢
⎢
⎢
⎣
0 1 0 0 ··· 00 
0 0 1 0 ··· 00 
.
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
.
0 0 0 0 ··· 01 
−kn −kn−1 ··· ··· ··· ··· −k1 
⎤
⎥
⎥
⎥
⎥
⎥
⎦
, bc =
⎡
⎢
⎢
⎢
⎣
0 
.
.
.
0 
1 
⎤
⎥
⎥
⎥
⎦
(6.30)6.3 Resistant Adaptive Fuzzy Control with Estimation Error … 113
The n × n matrix of P is determined to meet the Lyopounov equation ΔT 
c P +
PΔc = −Q, in which Q is a certain n × n matrix. The Lyopunov design approach 
will be employed to prove stability. The Lyopunov function is defined as below: 
V (t) = 1 
2 
eT Pe +
1 
2γ f 
φT 
f φ f +
1 
2γw
ψ2 
w (6.31) 
where φ f = θ f − θ ∗
f and ψw = w − ˆw. Moreover, θ ∗
f denotes the 
ideal parameters, whereas w refers to the estimation error defined as w =
max 
|
|
|
( ˆf (x|θ ∗
f ) − f (x) − d )|
|
|. Finally, wˆ is a parameter for the estimation of w. 
The derivative of the Lyopunov function is as follows: 
V ˙ = ∂
∂t )1 
2 
eT Pe (
+
1 
2γ f 
φT 
f φ˙ f +
1 
2γw
ψwψ˙w (6.32) 
In addition, (Δe)
T = eT ΔT , eT Pbc = bT 
c Pe and ΔT P + PΔ = −Q; therefore: 
∂
∂t )1 
2 
eT Pe (
= −1 
2 
eT Qe + eT Pbc [( ˆf (x|θ f ) − f (x) − d )
− us ]
(6.33) 
Placing this equation into Eq. (6.32) will give the following result: 
V ˙ = −1 
2 
eT Qe + eT Pbc [( ˆf (x|θ f ) − f (x) − d )
− us ]
+
1 
γ f 
φT 
f φ˙ f +
1 
γw
ψwψ˙w (6.34) 
If ˆf (x|θ ∗
f ) is added or subtracted, then: 
⇒ V ˙ = −1 
2 
eT Qe + eT Pbc [( ˆf (x|θ f ) − ˆf (x|θ ∗
f )
)]
+
1 
γ f 
φT 
f φ˙ f +
1 
γw
ψwψ˙w + eT Pbc [( ˆf (x|θ ∗
f ) − f (x) − d )] − eT Pbcus 
(6.35) 
Consider the following simplification: 
eT Pbc ( ˆf (x|θ f ) − ˆf (x|θ ∗
f )
)
+
1 
2γ f 
φT 
f φ˙ f 
= eT PbcφT 
f ζ f (x) +
1 
2γ f 
φT 
f φ˙ f (6.36)114 6 Type-2 Indirect Adaptive Control with Estimation Error …
Therefore, the adaptability rule θ f can be written as below: 
θ˙f = −γ f eT Pbcζ f (x) (6.37) 
Thus: 
⇒ V ˙ ≤ −
1 
2 
eT Qe +
1 
γw
ψwψ˙w + |
|eT Pbc 
|
|w − eT Pbcus (6.38) 
where w = max (|
|
| ˆf (x|θ ∗
f ) − f (x) − d 
|
|
|
)
through the fact that |a|b −
ab tanh ( 0.2785ab 
ε
)
≤ 0; hence, us can be written as below: 
us = ˆw tanh (
0.2785 · eT Pbc wˆ
ε
)
(6.39) 
where ε is defined by the designer as a small constant, and wˆ is a variable employed 
to estimate w. Therefore: 
⇒ V ˙ ≤ −
1 
2 
eT Qe +
1 
γw
ψwψ˙w + |
|eT Pbc 
|
|w
− eT Pbc wˆ tanh (
0.2785 · eT Pbc wˆ
ε
)
(6.40) 
With the placement of ψw = w − ˆw and ψ˙w = − ˙
wˆ as well as adding and 
subtracting |
|eT Pbc 
|
|wˆ , there will be: 
⇒ V ˙ ≤ −
1 
2 
eT Qe − 1 
γw
(
w − ˆw
) ˙
wˆ + |
|eT Pbc 
|
|
(
w − ˆw
)
+ |
|eT Pbc 
|
|wˆ − eT Pbc wˆ tanh (
0.2785 · eT Pbc wˆ
ε
)
≤ 0 (6.41) 
Therefore, the adaptability rule wˆ can be written as below: 
˙
wˆ = γw
|
|eT Pbc 
|
| (6.41)6.3 Resistant Adaptive Fuzzy Control with Estimation Error … 115
The dead-zone correction method of adaptability rule is employed to prevent the 
parameter drift. Ultimately, the adaptability rules are as below: 
θ˙f =
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎢
⎣
−γ f eT Pbcζi (x) if (
θ L 
f < θ f < θU 
f )
or (
θ f = θ L 
f and γ f eT Pbcζ fi (x) ≤ 0 )
or (
θ f = θU 
f and γ f eT Pbcζ fi (x) ≥ 0 )
0 if (
θ f = θ L 
f and γ f eT Pbcζ fi (x) > 0 )
or (
θ f = θU 
f and γ f eT Pbcζ fi (x) < 0 )
(6.42) 
˙
wˆ =
[
γw
|
|eT Pbc 
|
| if (
w <ˆ wˆ max )
0 if (
w >ˆ wˆ max ) (6.43) 
6.3.6 Switching Mechanism 
Since there are many adaptive parameters, the regulation of fuzzy system parameters 
stops while accelerating the controller when eT Pbc is smaller than a default value. 
Therefore, the compensator parameter is used only. 
The following mechanism is adopted to switch between two modes automatically: 
• Step 1: Initialization of parameters 
The available human knowledge is employed to construct the initial fuzzy 
systems ˆf (x 
|
|θ f (0) )
• Step 2: Training mode 
The system switches to the learning phase when eT Pbc is smaller than a 
predefined value of E0 for a specific interval of ΔT0.
• Step 3: Operating mode 
The algorithm is stopped to update parameters, except for one adaptive 
parameter that estimates the value of wˆ . 
If eT Pbc is larger than E0, go to Step 2. 
• An advantage of the two-mode control method is to reduce the implementation 
cost. In the training mode, if the fuzzy system has S inputs, two membership 
functions will be considered for each input. The total number of parameters that 
should be adjusted online will be (s − 1)
(
6 × 22 + 6 × 2 )
= 36(s − 1). However, 
in the operating mode, the controller needs only one adaptive parameter. In this 
case, the number of inputs is not important. This computational advantage is 
valuable when the controlled system is of high order. 
• Moreover, this switch causes no problem in stability, for the estimation error 
caused by the stopped regulation of fuzzy system parameters will be eliminated 
by the compensator.116 6 Type-2 Indirect Adaptive Control with Estimation Error …
6.3.7 Applications 
A Chua’s chaotic circuit consists of a linear resistance, two capacitators, one self, and 
one piecewise linear resistance. The Chua’s original dynamic equations are not in 
the standard canonical form. However, a linear transform can be employed to change 
them into the standard form. The standardized Equations [3] are as follows: 
x˙1 = x2 
x˙2 = x3 
x˙3 = f (x) + g(x)u 
y = x1 
(6.44) 
where f (x) = 14 
1805 x1 − 168 
9025 x2 + 1 
38 x3 − 2 
45 
( 28 
361 x1 + 1 
95 x2 + x3 )3 and g(x) = 1. 
The initial values are defined as x1(0) = −0.8, x2(0) = 0.2, x3(0) = 0.9. The 
purpose of control is to track the reference signal r (t) = 1.5 sin(t). The controller is 
developed through the following steps: 
Step 1: Ωx = {(x1, x2, x3)| |x1| ≤ 1, |x2| ≤ 1, |x3| ≤ 1}. 
Step 2: Develop ˆf (x 
|
|θ f ), and consider three membership functions for each 
input as shown in Fig. 2.4. Therefore, there are 27 rules. Testing f (x) indicates 
that −2 < f (x) < 2, ∀x ∈ Ωx ; hence, it is advisable to select ˆf (x|θU 
f ) =
2, ˆf (x|θ L 
f ) = −2. All initial values of θ fl ,i = 1... 27 are considered zero. 
Step 3: Construct gˆ(x 
|
|θg). The membership functions of similar to the previous 
state are used. Since g(x) = 1, gˆ(x|θU 
g ) = 1.1, gˆ(x|θ L 
g ) = 0.9. All initial values 
of θgi ,i = 1... 27 are considered zero. 
Step 4: The controlling parameters are selected as below. 
k =
⎛
⎝
1 
2 
3 
⎞
⎠ Q =
⎛
⎝
500 
0 5 0 
005 
⎞
⎠ P =
⎛
⎝
11.5 10.5 2.5 
10.5 23 6.5 
2.5 6.53 
⎞
⎠
γ f = 6 γg = 0.3 
γw = 0.1 σw = 0.3 w0 = 0.01 wmax = 0.2 ε = 0.01 
Step 5: Design the switching mechanism, and select E0 = 0.2 Δt0 = 10s for 
this problem. 
The block diagram of the above steps was simulated in MATLAB (Fig. 6.3). 
The results are reported below (Fig. 6.4). 
The diagram for trending the reference input is as in Fig. 6.5.References 117
6.4 Conclusion 
This chapter presented the indirect adaptive control by approximating the estimation 
error. A mechanism was introduced to enhance the calculation efficiency. In this 
mechanism, the controller automatically switches to the training mode of parameters 
and the operating mode, something which decreases the number of parameters that 
must be adjusted online. It also accelerates the controller. The proposed method 
proved efficient in a simulation on a chaotic system. According to the results, the 
reference input was traced properly. 
References 
1. L.-X. Wang, Adaptive Fuzzy Systems and Control: Design and Stability Anyalysis. Prentice￾Hall: Englewood Cliffs, New Jersey (1994) 
2. K. Fischle, D. Schroder, An improved stable adaptive fuzzy control method. IEEE Trans. Fuzzy 
Syst. 7, 27–40 (1999) 
3. C.H. Wang, T.C. Lin, T.T. Lee, H.L. Liu, Adaptive hybrid intelligent control for uncertain 
nonlinear dynamical systems. IEEE Trans. Syst. Man Cybern. Part B Cybern. 32, 583–597 
(2002) 
4. S.C. Tong, H.X. Li, G.R. Chen, Adaptive fuzzy decentralized control for a class of large-scale 
nonlinear systems. IEEE Trans. Syst. Man Cybern. Part B Cybern. 34, 770–775 (2004) 
5. M.F. Alexander Fink, O. Nelles, R. Isermann, Supervision of nonlinear adaptive controllers 
based on fuzzy models (2000) 
6. Y.G. Leu, W.Y. Wang, T.T. Lee, Observer-based direct adaptive fuzzy-neural control for 
nonaffine nonlinear systems. IEEE Trans. Neural Networks 16, 853–861 (2005) 
7. E. Kim, Output feedback tracking control of robot manipulators with model uncertainty via 
adaptive fuzzy logic. IEEE Trans. Fuzzy Syst. 12, 368–378 (2004) 
8. J.T. Spooner, K.M. Passino, Stable adaptive control using fuzzy system and neural networks. 
IEEE Trans. Fuzzy Syst. 4, 339–359 (1996) 
9. Y.X. Diao, K.M. Passino, Adaptive neural/fuzzy control for interpolated nonlinear systems. 
IEEE Trans. Fuzzy Syst. 10, 583–595 (2002) 
10. Y.H. Park, G.T. Park, Design of a robust adaptive fuzzy controller globally stabilizing the 
multi-input nonlinear system with state-dependent uncertainty. Control Cybern. 27, 613–629 
(1998) 
11. J.H. Park, G.T. Park, Robust adaptive fuzzy controller for non-affine nonlinear systems with 
dynamic rule activation. Int. J. Robust Nonlinear Control 13, 117–139 (2003) 
12. S.S. Ge, C.C. Hang, T.H. Lee, T. Zhang, Stable Adaptive Neural Network Control (Kluwer 
Academic Publishers, London, 2002) 
13. F.C. Chen, C.C. Liu, Adaptively controlling nonlinear continuous-time systems using multi￾layer neural networks. IEEE Trans. Autom. Control 39, 1306–1310 (1994) 
14. Y.S. Yang, J.S. Ren, Adaptive fuzzy robust tracking controller design via small gain approach 
and its application. IEEE Trans. Fuzzy Syst. 11, 783–795 (2003) 
15. P.A. Phan, T.J. Gale, Two-mode adaptive fuzzy control with approximation error estimator. 
IEEE Trans. Fuzzy Syst. 15(5), 943–955 (2007)Chapter 7 
Direct Adaptive Fuzzy Control 
7.1 Introduction 
This chapter analyzes direct adaptive fuzzy control. In the designated systems, 
the inputs emerge as linear in equations (i.e., affine systems). In direct adap￾tive control, only one fuzzy system is required to estimate the control rule u∗ = 1 
g(x)
(
− f (x) + K T e + r n )
. Therefore, the most important advantage of direct adap￾tive control is that it has a simpler structure than indirect adaptive control. However, 
further limitations should be applied to the control gain in direct adaptive fuzzy 
control. 
7.2 Literature Review 
Due to using only one fuzzy system, direct adaptive fuzzy control has a simpler 
structure than indirect adaptive fuzzy control. It can also solve the singularity problem 
in the indirect AFC completely. However, it is necessary to impose further limitations 
on the control gain g(x). 
In addition to controllability conditions, another limitation should be imposed on 
g(x) to guarantee stability and convergence. In [1, 2], g(x) was assumed o be known. 
In [3], g(x) was assumed to be g(x) = 1 
c g(x), where c > 0 and g(x) is an unknown 
positive scaler. In [4–7], the authors assumed that g(x) was an unknown constant. 
In [8, 9], the bounds of g(x) and its first-order derivative were considered known. In 
[10], it was assumed that ∂g(x)
∂xn = 0 and that the control gain did not depend on the 
state xn. 
Recently, some researchers proposed certain methods for simplifying additional 
conditions on g(x). In [11], Wang CH proposed a solution in which the control 
rule needed no additional conditions on g(x). However, g(x) must be known so 
that the control rule can be implemented. In [10], Ge et al. proposed a method in 
which additional conditions were simplified on g(x) through the Lyopunov function
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
A. Mohammadzaheh et al., Modern Adaptive Fuzzy Control Systems, Studies in Fuzziness 
and Soft Computing 421, https://doi.org/10.1007/978-3-031-17393-6_7 
119120 7 Direct Adaptive Fuzzy Control
of the new integral type. However, this method was later described as practically 
complicated and difficult to use in [12] due to the integral operator. Leu et al. [13] 
proposed a method that regarded the nonlinearity of g(x) as a general uncertainty 
component and deleted it by adding a new control term. Therefore, the bound of g(x) 
is still necessary in this method. In [14], Park adopted the virtual function theory 
to solve this problem. The critical step in the proposed method is to determine c in 
a way that c > 1 
2 g(x); therefore, the upper bound of g(x) is also necessary in this 
method. 
These constraints cause some problems in practice. For instance, the constraint 
of a constant g(x) decreases the number of systems to which the direct AFC can be 
applied. In addition, the constraint of a known g(x) necessitates that some experiments 
should be conducted on the system so that it can be estimated. This overshadows the 
most important advantage of AFC, i.e., the lack of need for a mathematical model. 
Another limitation of this method is the need to know the bound of g(x). If the 
necessary bounds are selected very conservatively, it will have adverse effects on 
the control activity. Hence, some tests are required to determine the bound of g(x). 
These additional tests increase the cost, complexity, and time of designing the direct 
AFC. 
7.2.1 Adaptive Fuzzy Control with Fewer Limitations 
Consider the system from the previous subchapter. The purpose is to design a direct 
adaptive fuzzy controller in a way that the closed-loop system remains stable, i.e., all 
variables of the closed-loop system remain bounded, and the system output follows 
the reference signal [15]. 
Consider the following assumptions: 
• g(x) is continuous, and its sign is known for x ∈ Ωx where Ωx indicates the 
controllability area. Since g(x) /= 0 (i.e., the controllability condition of the 
system) with g(x) being continuous and controllable in x ∈ Ωx , it is possible to 
assume that g(x) > 0 for x ∈ Ωx without losing the generalities of the problem. 
• Define r = [
r ˙,r ¨, ... ,r(n−1)
]T and assume that r ≤ r0 and r n ≤ r1 with the 
known constants of r1,r0 > 0. 
The ideal controller can be defined as below: 
u∗ = 1 
g(x)
(
− f (x) + kT e + r(n)
) (7.1) 
By considering v = kT e + r(n)
, there will be: 
u∗ = 1 
g(x)
(− f (x) + v) (7.2)7.2 Literature Review 121
where X = (
x T , v)T 
∈ Ωx , Ωx = {X|x ∈ Ωx , r n ≤ r1, r ≤ r0 }. 
A fuzzy controller is used as below to estimate u∗. 
7.2.2 Type-2 Fuzzy System 
This subchapter introduces the simplified Sugeno interval type-2 fuzzy system. All 
of the fuzzy rules are as follows: 
The ith rule: If X1,..., Xn, correspond to Ai 
1,..., Ai 
n, respectively, then y will be 
like αi 
0 + Σn 
j=1 αi 
j X j , i = 1, ..., M, where X1,..., Xn denote the input variables 
of the fuzzy system, and Ai 
j represents the interval type-2 membership function, 
whereas αi 
j indicates the consequent linear parameters. To estimate the control rule 
u∗, a Sugeno fuzzy system is used with the simplified interval type-2 membership 
functions as below: 
uˆ(X|θ ) = Σ
M
i=1 
(
αi 
0 + αi 
1 X1 + ··· + αi 
n Xn )
(
1 
2 
μu 
i (X )
ΣM 
i=1 μu 
i (X )
+
1 
2 
μl 
i (X )
ΣM 
i=1 μl 
i (X )
)
(7.3) 
where 
μu 
i (x) = ⊓n
j=1 
exp 
⎛
⎝−1 
2 (
x j − x p 
j 
σ p 
u j )2 ⎞
⎠
μl 
i (x) = ⊓n
j=1 
exp 
⎛
⎝−1 
2 (
x j − xq 
j 
σq 
l j )2 ⎞
⎠
where x p 
j , xq 
j and σ p 
u j , σq 
l j denote the qth and pth centers and widths of membership 
functions for the jth input and the ith rule, respectively. Moreover, M refers to the 
total number of fuzzy rules, and θ represents the adaptive (adjustable) rules, whereas 
n indicates the number of input variables in the fuzzy system. 
Furthermore, the designated membership functions have constant centers and 
variables widths. Along the process, the centers and widths of classes are trained. 
The upper and lower bounds are defined as below: 
σu = σ + 0.1 
σl = σ − 0.1 
The optimal parameters of θ ∗ are defined as below: 
θ ∗ = arg min [
supx∈Ux 
|
|uˆ(X 
|
|θ ∗ ) − u∗(X )
|
|
] (7.4)122 7 Direct Adaptive Fuzzy Control
If the adaptive parameters of the fuzzy system (θ) converge on θ ∗, the control signal 
estimation error will be ideal. The Taylor series of θ, i.e., uˆ(X|θ ), is as follows: 
uˆ(X|θ ) − ˆu(X 
|
|θ ∗ ) = (
θ − θ ∗)T [
δuˆ(X|θ )
δθ ]
+ o (|
|θ − θ ∗
|
|
2 )
(7.5) 
The parameters of o (|
|θ − θ ∗
|
|
2 )
are high-order expressions. 
The adaptive parameters are defined as below: 
θ =
⎛
⎜
⎝
α1 
0 , ..., αM 
0 , α1 
1 , ..., αM 
1 , ..., α1 
n , ..., αM 
n ,
x 1 
1, ..., x L 
1 , ... , x 1 
n, ..., x L 
n 
σ1 
1 , ..., σ L 
1 , ... , σ1 
n , ..., σ L 
n 
⎞
⎟
⎠
T 
(7.6) 
where there are (n +1)M +2nL adjustable parameters, (n+1)M of which are conse￾quent parameters, and the other 2nL parameters are the parameters of membership 
functions. Moreover, M and L denote the number of rules and the number of func￾tions for every input, respectively, whereas n refers to the number of system states. 
Furthermore, x p 
j , xq 
j , σ p 
j , and σq 
j represent the qth and pth centers and the widths of 
membership functions for the jth input. 
Consider Zi =
(
1 
2 
μu 
i (X)
ΣM 
i=1 μu 
i (X) + 1 
2 
μl 
i (X)
ΣM 
i=1 μl 
i (X )
)
, then: 
uˆ(X|θ ) = Σ
M
i=1 
(
αi 
0 + αi 
1 X1 + ··· + αi 
n Xn )
Zi (7.7) 
Therefore, the derivative of uˆ(X|θ ) for the consequent parameters (αi 
j , j =
1, ..., n) will be as follows: 
δuˆ(X|θ )
δαi 
0 
= Zi 
δuˆ(X|θ )
δαi 
1 
= Zi X1 
.
.
.
δuˆ(X|θ )
δαi 
n 
= Zi Xn 
(7.8) 
The equations of uˆ(X|θ ) for the parameters of membership functions are now 
obtained.7.2 Literature Review 123
To calculate δuˆ(X|θ )
δx p 
j 
, there is: 
Then uˆ(X|θ ) is rewritten and defined as below: 
uˆ(X|θ ) =
ΣM 
i=1 (
αi 
0 + αi 
1 X1 + ··· + αi 
n Xn )
μu 
i (X )
2 ΣM 
i=1 μu 
i (X )
+
ΣM 
i=1 (
αi 
0 + αi 
1 X1 + ··· + αi 
n Xn )
μl 
i (X )
2 ΣM 
i=1 μl 
i (X )
(7.9) 
where x p 
j is the pth membership function for the jth input. It emerges only in μu 
i (x). If 
L membership functions are considered for every input when there are n inputs, then 
the center of each membership function for every input emerges in Ln−1 expressions 
in ΣM 
i=1 μu 
i (X ). The μu 
i (X ) in which x p 
u j emerges will be shown as μu 
pi 
(X ). By 
defining a = ΣM 
i=1 (
αi 
0 + αi 
1 X1 + ··· + αi 
n Xn )
μu 
i (X ) and b = 2 ΣM 
i=1 μu 
i (X ), the 
following equations are yielded: 
δuˆ(X|θ )
δx p 
j 
= a'
b − b'
b2 = a' − ˆu(X|θ )b'
b 
a' = δa 
δx p 
j 
, b' = δb 
δx p 
j 
(7.10) 
By defining yi = (
αi 
0 + αi 
1 X1 + ··· + αi 
n Xn )
, the following equations are 
yielded: 
a' = δa 
δx p 
j 
=
ΣM 
i=1 yi μu 
i (X )
δx p 
j 
=
L
Σn−1 
i=1 
yi μu 
pi 
(X )
2 (
X j − x p 
j )
(
σ p 
u j )2 
b' =
L
Σn−1 
i=1 
μu 
pi 
(X )
2 (
X j − x p 
j )
(
σ p 
u j )2 (7.11) 
Therefore: 
δuˆ(X|θ )
δx p 
j 
=
ΣLn−1 
i=1 yi μu 
pi 
(x) − ˆu(X|θ ) ΣLn−1 
i=1 μu 
pi 
(x)
2 ΣM 
i=1 μu 
i (x)
2 (
x j − x p 
j )
(
σ p 
u j )2 
+
ΣLn−1 
i=1 yi μl 
pi 
(x) − ˆu(X|θ ) ΣLn−1 
i=1 μl 
pi 
(x)
2 ΣM 
i=1 μl 
i (x)
2 (
x j − x p 
j )
(
σ p 
l j )2 (7.12)124 7 Direct Adaptive Fuzzy Control
The process of calculating δuˆ(X|θ )
δσ p 
u j 
is similar to that of δuˆ(X|θ )
δx p 
j 
; hence: 
δuˆ(X|θ )
δσ p 
u j 
=
ΣLn−1 
i=1 yi μu 
pi 
(x) − ˆu(X|θ ) ΣLn−1 
i=1 μu 
pi 
(x)
ΣM 
i=1 μu 
i (x)
(
x j − x p 
u j )3 
(
σ p 
u j )3 (7.13) 
By changing σ p 
u j → σ p 
l j and x p 
u j → x p 
l j in Eqs. (7.12) and (7.13), the corresponding 
equations of δuˆ(X|θ )
δx p 
l j 
and δuˆ(X|θ )
δσ p 
l j 
will be similar to Eqs. (7.12) and (7.13). Finally, the 
control signal will be as follows: 
u = ˆu(X|θ ) = Σ
M
j=1 
θ j ζ (X ) (7.14) 
where the adaptive parameters are considered the consequent coefficients: θ =
(θ1, θ2, ...θM )
T . 
By adding g(x)u∗(X) to Eqs. (7.1–7.4), the error dynamics equation is yielded 
through simplification: 
e(n) = −kT e + [
g(x)u∗(X ) − g(x)uˆ(X|θ )
] (7.15) 
A lemma is now presented. It was introduced in [16] to prove the features of 
general estimators. 
Lemma 1 For ε∗ > 0, there are ζ (X ) = (ζ1(X ), ζ1(X ), ...ζM (X ))
T and ideal 
parameters θ ∗ = (
θ ∗
1 , θ ∗
2 , ...θ ∗
M )T 
: 
g(x)u∗(X ) − g(x)uˆ(X|θ ) = Σ
M
j=1 
c j
(
θ ∗
j − θ j )
ζ j (X ) + ε (7.16) 
where |ε| ≤ ε∗, c j are positive constants. 
By placing Eq. (4.5) in Eq. (1.5), the result will be e(n) = −kT 
[ e +
ΣM 
j=1 c j (
θ ∗
j − θ j )
ζ j (X ) + ε
]
, which is in the following vector form: 
e(n) = Δe + bc 
⎡
⎣
Σ
M
j=1 
c j
(
θ ∗
j − θ j )
ζ j (X ) + ε
⎤
⎦ (7.17) 
where:7.2 Literature Review 125
Δ =
⎡
⎢
⎢
⎢
⎢
⎢
⎣
0 1 0 0 ··· 00 
0 0 1 0 ··· 00 
.
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
.
0 0 0 0 ··· 01 
−k1 −k2 ··· ··· ··· ··· −kn 
⎤
⎥
⎥
⎥
⎥
⎥
⎦
, bc =
⎡
⎢
⎢
⎢
⎣
0 
.
.
.
0 
1 
⎤
⎥
⎥
⎥
⎦
In fact, Δ is a stable matrix, and there is the positive definite matrix P if: 
ΔT P + PΔ = −Q (7.18) 
where Q is an arbitrary positive definite matrix that should be selected when 
λmin(Q) > 1. 
Assume that it is possible to determine the upper and lower bounds of the control 
signal: 
uL ≤ u∗(X ) ≤ uU , ∀X ∈ ΩX 
This assumption does not impose any constraints on the system. This is a rational 
assumption. In fact, it is a necessary assumption for the selection of actuators. This 
assumption will be employed to keep the adaptive parameters bounded. 
Although the designated system (1.4) meets all assumptions, the adaptability rule 
will be as follows: 
θ˙j =
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎣
γ eT Pbcζi (x) if (
uL < θ j < uU )
or (
θ j = uU and γ eT Pbcζ j (x) < 0 )
or (
θ j = uL and γ eT Pbcζ j (x) > 0 )
0 if (
θ j = uU and γ eT Pbcζ j (x) ≥ 0 )
or (
θ j = uL and γ eT Pbcζ j (x) ≤ 0 )
(7.19) 
where γ is matching coefficient. According to this adaptability rule, there will be: 
• The adaptive parameters remain bounded: uL ≤ θ j ≤ uU , j = 1...M. 
• The tracking error is bounded:
e(t) ≤
[|||
2 max {
V (0), 1 
2α
( c 
γ + Pbc2ε∗2 )}
λmin(P) , ∀t > 0 
where α = (λmin(Q)−1)
λmax(P) , and V (0) is a positive constant depending on the initial 
conditions, whereas c is a bounded positive constant.126 7 Direct Adaptive Fuzzy Control
• The system is uniformly ultimate bounded (UUB), and e(t) converges on Ωe: 
Ωe =
⎧
⎨
⎩e(t)
|
|
|
|
|
|
e(t) ≤
\
Pbc2ε∗2 
λmin(Q) − 1 
⎫
⎬
⎭
Proof 
• According to Eq. (8.5), it is evident that uL ≤ θ j ≤ uU , j = 1...M. 
• Consider the following Lyopunov function: 
V = 1 
2 
eT Pe +
1 
2γ
Σ
M
j=1 
c j
(
θ ∗
j − θ j )2 (7.20) 
By calculating the derivative of V, the following result is yielded: 
V ˙ = −1 
2 
eT Qe − 1 
2γ
Σ
M
j=1 
c j
(
θ ∗
j − θ j )
θ˙j 
+ eT Pbc 
⎡
⎣
Σ
M
j=1 
c j
(
θ ∗
j − θ j )
ζ j (X ) + ε
⎤
⎦
⇒ V ˙ = −1 
2 
eT Qe 
− 1 
γ
Σ
M
j=1 
c j
(
θ ∗
j − θ j )(γ eT Pbcζ j (X ) − θ˙j )
+ eT Pbcε (7.21) 
If the adaptability rule is selected as Eq. (7.19), then: 
• If (
uL < θ j < uU )
, (
θ j = uU and γ eT Pbcζ fi (x) < 0 )
, or
(
θ j = uL and γ eT Pbcζ fi (x) > 0 )
, then: 
Σ
M
j=1 
c j
(
θ ∗
j − θ j )(γ eT Pbcζ j (X ) − θ˙j )
= 0 
• If (
θ j = uU and γ eT Pbcζ fi (x) ≥ 0 )
, then θ˙j = 0 and θ ∗
j ≤ uU =
θ j ,
(
θ ∗
j − θ j )
≤ 0; therefore: 
(
θ ∗
j − θ j )(γ eT Pbcζ j (X ) − θ˙j )
= (
θ ∗
j − θ j )
γ eT Pbcζ j (X ) ≤ 07.2 Literature Review 127
• If θ j = uL and γ eT Pbcζ fi (x) ≤ 0, then similarly: 
(
θ ∗
j − θ j )(γ eT Pbcζ j (X ) − θ˙j )
= (
θ ∗
j − θ j )
γ eT Pbcζ j (X) ≤ 0 
According to the adaptability rule (7.19), there will be: 
(
θ ∗
j − θ j )(γ eT Pbcζ j (X ) − θ˙j )
≤ 0 (7.22) 
By placing Eq. (7.22) in Eq. (7.21), the following result is yielded: 
V ˙ = −1 
2 
eT Qe + γ eT Pbc (7.23) 
Since −1 
2 eT Qe ≤ −1 
2 λmin(Q)e(t)2 where λmin(Q) is the smallest eigenvalue 
of Q and eT Pbcε ≤ 1 
2 e(t)2 + 1 
2 Pbc2ε2 ≤ 1 
2 e(t)2 + 1 
2 Pbc2ε∗2 , there 
will be: 
V ˙ ≤ −
1 
2 
λmin(Q)e(t)2 +
1 
2
e(t)2 +
1 
2
Pbc2
*
*ε∗
*
*
2 
⇔
V ˙ ≤ −
1 
2 
(λmin(Q) − 1)e(t)2 +
1 
2
e(t)2 +
1 
2
Pbc2
*
*ε∗
*
*
2 (7.24) 
Therefore, the error bound can be determined in the following way. Since uU ≤
θ ∗
j ≤ uU , uU ≤ θ j ≤ uU , then: 
1 
2γ
Σ
M
j=1 
c j
(
θ ∗
j − θ j )2 
≤
1 
2γ
Σ
M
j=1 
c j
(
uU − uL )2 
By multiplying the two sides of the above inequality by (λmin(Q)−1)
λmax(P) and placing it 
in Eq. (5.13), the following result will be yielded: 
V ˙ ≤ −
1 
2 
(λmin(Q) − 1)e(t)2 − (λmin(Q) − 1)
λmax(P)
1 
2γ
Σ
M
j=1 
c j
(
θ ∗
j − θ j )2 
+ (λmin(Q) − 1)
λmax(P)
1 
2γ
Σ
M
j=1 
c j
(
uU − uL )2 +
1 
2
Pbc2
*
*ε∗
*
*
2 
≤ −(λmin(Q) − 1)
λmax(P)
⎛
⎝
1 
2 
λmax(P)e(t)2 +
1 
2γ
Σ
M
j=1 
c j
(
θ ∗
j − θ j )2 ⎞
⎠
+ (λmin(Q) − 1)
λmax(P)
1 
2γ
Σ
M
j=1 
c j
(
uU − uL )2 +
1 
2
Pbc2
*
*ε∗
*
*
2128 7 Direct Adaptive Fuzzy Control
By considering (λmin(Q)−1)
λmax(P)
1 
2γ
ΣM 
j=1 c j (
uU − uL )2 = c and (λmin(Q)−1)
λmax(P) = α, the 
following result will be yielded: 
V ˙ ≤ −αV +
1 
2 ( c 
γ
+ Pbc2
*
*ε∗
*
*
2 )
⇒
V (t) ≤ e−αt [
V (0) − 1 
2α
( c 
γ
+ Pbc2
*
*ε∗
*
*
2 )] +
1 
2α
( c 
γ
+ Pbc2
*
*ε∗
*
*
2 )
Therefore, V (t) ≤ max {
V (0), 1 
2α
( c 
γ + Pbc2ε∗2 )}, ∀t > 0. According to 
the definition of V, the error vector is bounded as below:
e(t) =
[|||
2 max {
V (0), 1 
2α
( c 
γ + Pbc2ε∗2 )}
λmin(P) , ∀t > 0 (7.25) 
• Since λmin(Q) > 1, Eq. (5.13) indicates that V ˙ becomes negative when the 
following equation is true: 
1 
2 
(λmin(Q) − 1)e(t)2 ≥
1 
2
Pbc2
*
*ε∗
*
*
2 
Hence, the system is UUB, and e(t) converges on Ωe within a limited interval. 
Ωe =
⎧
⎨
⎩e(t)
|
|
|
|
|
|
e(t) ≤
\
Pbc2ε∗2 
λmin(Q) − 1 
⎫
⎬
⎭
Therefore, the proof is completed. 
To compensate for the estimation error ε∗, some researchers have proposed 
different methods such as using the supervised controller and approximating the 
estimation error bound. 
It should be noted that the modified adaptability rules were proposed in papers to 
guarantee the boundedness of adaptive parameters. An important method of using 
the modified adaptability rule is as follows: 
θ˙j = γ eT Pbcζ j (X ) − σ θ j (7.26) 
However, designing σ does not have a clear physical meaning. Often, a small 
value is considered. There is not a clear relationship between σ and the bounds of 
adaptive parameters. Even if the adaptive parameters remain bounded, there is no 
guarantee that the control signal stays in an appropriate range.7.2 Literature Review 129
In this method, the tracking error can be decreased to a small enough value by 
adjusting k (to adjust Pbc), setting λmin(Q), and selecting the right structure. 
Moreover, Pbc and λmin(Q) lead to the largest tracking error; however, if Pbc
and λmin(Q) become too large, the control signal will experience chattering. 
The brief analysis of direct AFC indicates that there are a few limitations in this 
method. The future studies will analyze better bounds to easily select the design 
parameters from a clear range and keep the system signals within a favorable range. 
7.2.3 Simulation 
The inverted pendulum system was employed to show the capability of this method 
(Fig. 7.1). 
The system equations are as follows: 
x˙1 = x2 
x˙2 =
[
g sin(x1) − mlx 2 
2 sin(x1) cos(x1)
mc + m ]
. 1 
l (
4 
3 − m cos2(x1)
mc+m )
+
cos(x1)
mc + m . 1 
l (
4 
3 − m cos2(x1)
mc+m )u (7.27) 
where x1 and x2 denote the angle and the velocity of the pendulum. Moreover, mc 
and m represent the mass of the chariot and the mass of the pendulum, respec￾tively. Finally, l refers to half of the pendulum’s length. The following values were 
considered in the simulation:
Fig. 7.1 The inverted 
pendulum system [15] 130 7 Direct Adaptive Fuzzy Control
Fig. 7.2 Implementing direct adaptive fuzzy control on the inverted Pendulum in MATLAB 
m = 0.1 kg, mc = 1 kg,l = 0.5m 
Five membership functions were considered for each of the inputs; therefore, 
there are 125 rules in total. The inputs were selected from the following range: 
x1 ∈ [−1, 1], x2 ∈ [−1, 1], v ∈ [−1, 1] 
The control parameters were selected as below: 
k = [
11 ]T 
, Q =
[
20 10 
10 15 ]
, P =
[
25 10 
10 15 ]
, γ = 1 
The reference input was considered 0.5 sin(t). 
The above steps were implemented in MATLAB (Fig. 7.2). 
Moreover, the initial angle of the pendulum was π/6, and the initial values of all 
adaptive parameters were zero. 
The reference input tracking is as in Fig. 7.3.
According to Fig. 7.3, tracking was done properly in less than 10 s. The control 
signal diagram is as in Fig. 7.4.
Accordingly, the control signal domain is suitable, and no chattering was detected 
in the control signal. 
Figure 7.5 demonstrates the status control diagram with an initial value of π/6.
7.3 Conclusion 
This chapter analyzed the direct adaptive fuzzy control method, which had fewer 
constraints. This method has a simpler structure than the indirect mode and solves 
the singularity problem of a control signal properly. In this chapter, the modified 
adaptability rule has no clearer physical concept than the other proposed method; 
however, it guarantees that the control activity remains within a suitable range.7.3 Conclusion 131
Fig. 7.3 The reference input tracking diagram—direct adaptive fuzzy control of the inverted 
pendulum
Fig. 7.4 The control signal diagram—direct adaptive fuzzy control of the inverted pendulum132 7 Direct Adaptive Fuzzy Control
Fig. 7.5 The status control diagram of the inverted pendulum in the direct adaptive fuzzy mode
References 
1. Y.S. Yang, J.S. Ren, Adaptive fuzzy robust tracking controller design via small gain approach 
and its application. IEEE Trans. Fuzzy Syst. 11, 783–795 (2003) 
2. Y. Gao, M.J. Er, Online adaptive fuzzy neural identification and controlof a class of MIMO 
nonlinear systems. IEEE Trans. Fuzzy Syst. 11, 462–477 (2003) 
3. J.T. Spooner, M. Maggiore, R. Ordonez, K.M. Passino, Stable Adaptive Control and Estimation 
for Nonlinear Systems: Neural and Fuzzy Approximation Techniques (John Wiley & Sons, New 
York, 2002) 
4. D.L. Tsay, H.Y. Chung, C.J. Lee, The adaptive control of nonlinear systems using the Sugeno￾type of fuzzy logic. IEEE Trans. Fuzzy Syst. 7, 225–229 (1999) 
5. M.J. Er, S.H. Chin, Hybrid adaptive fuzzy controllers of robot manipulators with bounds 
estimation. IEEE Trans. Industr. Electron. 47, 1151–1160 (2000) 
6. K. Fischle, D. Schroder, An improved stable adaptive fuzzy control method. IEEE Trans. Fuzzy 
Syst. 7, 27–40 (1999) 
7. L.-X. Wang, Adaptive Fuzzy Systems and Control: Design and Stability Anyalysis. Prentice￾Hall: Englewood Cliffs, New Jersey (1994) 
8. H. Han, C.-Y. Su, Y. Stepanenko, Adaptive control of a class of nonlinear systems with 
nonlinearly parameterized fuzzy approximators. IEEE Trans. Fuzzy Syst. 9, 315–323 (2001) 
9. N. Essounbouli, A. Hamzaoui, Direct and indirect robust adaptive fuzzy controllers for a class 
of nonlinear systems. Int. J. Control Autom. Syst. 4, 146–154 (2006) 
10. S.S. Ge, C.C. Hang, T.H. Lee, T. Zhang, Stable Adaptive Neural Network Control (Kluwer 
Academic Publishers, London, 2002) 
11. C.H. Wang, H.L. Liu, T.C. Lin, Direct adaptive fuzzy-neural control with state observer and 
supervisory controller for unknown nonlinear dynamical systems. IEEE Trans. Fuzzy Syst. 10, 
39–49 (2002) 
12. F.P. Da, W.Z. Song, Fuzzy neural networks for direct adaptive control. IEEE Trans. Industr. 
Electron. 50, 507–513 (2003) 
13. Y.G. Leu, W.Y. Wang, T.T. Lee, Observer-based direct adaptive fuzzy-neural control for 
nonaffine nonlinear systems. IEEE Trans. Neural Networks 16, 853–861 (2005)References 133
14. J.H. Park, S.H. Huh, S.H. Kim, S.J. Seo, G.T. Park, Direct adaptive controller for nonaffine 
nonlinear systems using self-structuring neural networks. IEEE Trans. Neural Networks 16, 
414–422 (2005) 
15. P.A. Phan, T.J. Gale, Direct adaptive fuzzy control with less restrictions on the control gain. 
Int. J. Control Autom. Syst. 5(6) (2007) (In press) 
16. S.S. Ge, C. Wang, Direct adaptive NN control of a class of nonlinear systems. IEEE Trans. 
Neural Networks 13, 214–221 (2002)Chapter 8 
Direct Adaptive Fuzzy Control 
with a Self-regulated Structure 
8.1 Introduction 
Fuzzy systems with fixed structures were used in most of the adaptive fuzzy control 
methods proposed by different papers. Thus, a designer should determine the number 
of membership functions through trial and error. In many cases, the designated struc￾ture is larger or smaller than the proper structure. An important area of research is to 
develop adaptive fuzzy control with a self-regulated structure. 
This chapter introduces adaptive fuzzy control with a self-regulated structure 
for a class of nonlinear systems. Subchapter 6–2 presents a brief review of the 
literature, and Subchapter 6–3 analyzes direct adaptive fuzzy control with a self￾regulated structure for a class of nonlinear systems in which the inputs emerge as 
linear. Subchapter 6–4 runs a simulation, and Subchapter 6–5 draws a conclusion. 
8.2 Literature Review 
Fuzzy systems with self-regulated structures need the input space clustering, for 
which different mechanisms have been proposed such as clustering through the output 
error [1, 2] and clustering through distance [3, 4]. Other methods have also been 
developed for fuzzy systems with self-regulated structures, although none of them 
are efficient in online control tasks. 
Insufficient studies have been conducted on adaptive fuzzy control with self￾regulated structures [5–7]. Park et al. [6, 7] proposed a fuzzy system with a self￾regulated structure in which the rules were added with respect to the input. For 
this purpose, they considered triangular membership functions, the widths of which 
were constant and did not change. When an input variable moves out of the area 
covered by membership functions, a new membership function is added. The new 
rules are then created by adding this membership function. This method also deletes 
the unnecessary rules. Since the membership functions cover the input space equally,
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
A. Mohammadzaheh et al., Modern Adaptive Fuzzy Control Systems, Studies in Fuzziness 
and Soft Computing 421, https://doi.org/10.1007/978-3-031-17393-6_8 
135136 8 Direct Adaptive Fuzzy Control with a Self-regulated Structure
there might be too many membership functions in an area where nonlinearity is less 
prevalent. In an area with higher levels of nonlinearity, there might not be enough 
membership functions. Another disadvantage of this method is the growth of the 
number of rules. 
Gao and Er [5] used a self-regulated fuzzy neural system that was able to eliminate 
the rules. In fact, the rules were generated with respect to two principles: system error 
and ε–completeness rule (i.e., for each input in the working area, there is at least one 
fuzzy rule, the fire extent of which is not lower than ε). The rules are then pruned with 
respect to the error reduction ratio (ERR). Due to the use of the output error to produce 
rules, the proposed fuzzy system solves the problem of unfavorable distribution of 
rules in Park’ method. However, the implementation of this idea is complicated in 
online computation due to needing to calculate a large-scale matrix in each step. At 
the same time, there is no clear relationship between the number of rules and the 
ratio of error. Thus, there is no practical guarantee that the dimensions of the fuzzy 
system exceed the limits. Moreover, using the Gaussian membership functions will 
increase the problem complexity due to activating more rules at a moment. 
Stability was proven in [5, 6] only in the case where the fuzzy system structure 
was constant. In these papers, no proof of stability was presented for the case where 
the structure would change. 
8.3 Description of the Self-regulated Structure Algorithm 
The key rules of the self-regulated structure algorithm are as follows [8]: 
• When the structure must be changed. 
• When the new membership functions must be added or replaced. 
• When to determine the values of parameters in membership functions and their 
initial values in the rules section. 
• Method of Producing Rules. 
There are two criteria for this purpose: system error and ε–completeness. 
Regarding the first criterion, eT Pbc denotes the system error. In the adaptability 
rules, the consequent parameters should be adjusted to decrease eT Pbc. When 
eT Pbc = 0, the output error is zero; thus, it is not necessary to change the adap￾tive parameters. Therefore, when eT Pbc is equal to or larger than the predefined 
threshold, a new membership function is considered. 
In [9], Gao defined the ε–completeness of the fuzzy rules (i.e., for all inputs in 
the working area, there is at least one fuzzy rule in which the firing strength is not 
smaller than ε). To guarantee ε–completeness, it is essential to ensure that there is 
at least one membership function with a firing strength of ε for every input in the 
working area. The relationship between ε and ε0 is ε = εn 
0 , and n denotes the number 
of inputs, whereas the value of ε0 is usually selected 0.5. 
If one of the two criteria is not met for producing the new rule, a new membership 
function is added. The algorithm then analyzes whether the number of membership8.3 Description of the Self-regulated Structure Algorithm 137
Fig. 8.1 The membership functions before the new membership function is added 
functions has exceeded the limit. If it has, the new membership function replaces 
one of the existing membership functions. 
• Adding a new membership function when ε–completeness is not met: 
When ε–completeness is not met and the number of membership functions does 
not exceed the limit, a new membership function will be added. Since ε–completeness 
is not met, there is an input which has no membership function with a firing strength 
equal to or greater than ε0. The new membership function belongs to the input. 
The parameters of the triangular membership function are the center, the left 
point, and the right point. When a new membership function is added, its center 
records the moment at which it enters. The left and right points become the centers 
of neighboring membership functions one by one (Fig. 8.1). 
If there are no membership functions in the left and right neighborhoods, the 
left and right points are placed within the predefined distance from the center. To 
prevent the membership functions from approaching each other too closely, the new 
membership function will be added when the distance between its center and the 
center of each neighboring membership function is longer than a predefined limit. 
To ensure that at least two membership functions are activated at a time, the neigh￾boring membership functions are modified in a similar way. The right point of the 
left neighboring membership function changes to the center of the new membership 
function. 
If the new membership function is added, the possible number of member￾ship functions will be 2n−1, and n indicates the number of inputs. All consequent 
parameters of the newly generated rules take the current value of output. 
Figure 8.2 depicts how the new membership function is added in this case.
• Adding a new membership function when ε–completeness is not met. 
If ε–completeness is not met and the number of membership functions exceeds a 
limit, the new membership function will replace one of the membership functions. 
This process is performed by adding the new membership function to the input and 
eliminating all of the rules depending on this membership function. 
Figure 8.3 demonstrates how to perform this process. Accordingly, m f1 is 
the farthest membership function from xi (t). Hence, this membership function is138 8 Direct Adaptive Fuzzy Control with a Self-regulated Structure
Fig. 8.2 The membership functions after the new membership function is added
replaced with a new membership function, the center of which is xi (t). The left point 
of m f1 should be x3. Since there is no membership function on the right side of m f1, 
this side is regarded as a predefined distance from the center. 
• Adding the membership function when eT Pbc is equal to or greater than the 
predefined threshold. 
When eT Pbc ≥ err or_threshold and the number of the membership functions 
does not exceed the limit Brule, a membership function is added. 
To identify the input to which the membership function should be added, the rule 
with the highest firing strength of the moment is selected, and a new membership 
function is added to the input.
Fig. 8.3 Replacing the membership function when ε–completeness is not met and the number of 
membership functions exceeds the limit 8.3 Description of the Self-regulated Structure Algorithm 139
Fig. 8.4 Adding a new membership function when eT Pbc ≥ err or_threshold 
Figure 8.4 demonstrates how to add a new membership function in this case. 
Accordingly, m f4 is added to xi (t). The left point m f4 in x2 and its right point in 
x3 were selected. The neighborhood of the membership functions m f3 and m f4 was 
corrected. The right point m f2 and the left point m f3 changed to the center m f4. 
• Replacing the membership function when the measurement error eT Pbc is equal 
to or greater than err or_threshold.
When eT Pbc ≥ err or_threshold and the number of membership functions 
is larger than Brule, the new membership functions should be replaced with one 
of the available functions. 
• Parameters 
The self-regulated structure algorithm has four design parameters: 
ε0: the completeness of the fuzzy rules 
err or_threshold: the structure change threshold 
min_ mf_ distance: the minimum distance between two neighboring member￾ship functions 
max_ mf_ distance: the maximum distance between two neighboring member￾ship functions. 
Hence, using a large value of ε0 and a small value of err or_threshold, 
min_ mf_ distance, or max_ mf_ distance will result in the production of further 
rules. The number of rules with Brule will remain bounded. 
The specifications of the introduced membership function are as in Fig. 8.5.
The membership degree of this function is obtained from the following equation:140 8 Direct Adaptive Fuzzy Control with a Self-regulated Structure
Fig. 8.5 The type-2 membership function for use in the self-regulated structure
μ˜
(
yj )
=
(
1 −
|
|
|
|
y − yj 
dy 
|
|
|
|
α)1 
α
0 
, if yj − dy < y < yj + dy , j = 1,..., n 
else 
where α, α < α < α denotes uncertainty. 
8.4 Adaptation Rules in Self-regulated Adaptive Fuzzy 
Controller 
Consider a system with the self-regulated structure. The adaptability rules are as 
follows: 
θ˙j =
⎡
⎢
⎢
⎢
⎢
⎢
⎢
⎣
γ eT Pbcζi (x) if (
uL < θ j < uU )
or (
θ j = uU and γ eT Pbcζ j (x) < 0 )
or (
θ j = uL and γ eT Pbcζ j (x) > 0 )
0 if (
θ j = uU and γ eT Pbcζ j (x) ≥ 0 )
or (
θ j = uL and γ eT Pbcζ j (x) ≤ 0 )
(8.1) 
These adaptability rules guarantee that the adaptive parameters are bounded (uL <
θ j < uU j = 1...M). The tracking error remains bounded as below:
e(t) ≤
[|||
2 max {
V (0), 1 
2α
( c 
γ + Pbc2ε∗2 )}
λmin(P) , ∀t > 0 (8.2) 
where α = (λmin(Q)−1)
λmax(P) . Moreover, V (0) and c are bounded positive constants. 
The system is UUB, and e(t) converges on Ωe. 
Ωe =
⎧
⎨
⎩e(t)
|
|
|
|
|
|
e(t) ≤
/
Pbc2ε∗2 
λmin(Q) − 1 
⎫
⎬
⎭
(8.3)8.4 Adaptation Rules in Self-regulated Adaptive Fuzzy Controller 141
Proof The fixed structure stability was proven in the previous chapter. This chapter 
discusses stability with a variable structure. If the Lyopunov function is selected as 
similar to the previous one, it will change as the structure changes. Therefore, it 
is rather difficult to show stability. To solve this problem, a Lyopunov function is 
selected as below [8]: 
V = 1 
2 
eT Pe +
1 
2γ
Σ
M
j=1 
c j
(
θ ∗
j − θ j )2 +
1 
2γ
Σ
N
k=M+1 
ck (
θ ∗
k − θk )2 (8.4) 
where θk , k = M+1, ..., N are the parameters that have not yet been generated, and 
P is a positive definite value. Moreover, c j 
, j = 1...M , ck > 0, k = M +1, ..., N. 
The proof of stability has two steps. First, stability should be proven when the 
structure is fixed. Afterwards, it is necessary to show that the system remains stable 
when the structure changes. 
When the structure is fixed, M is fixed. Since θ˙∗
j = 0, j = 1...M and θ˙∗
k = θ˙
k =
0, k = M + 1, ..., N, then the derivative of V will be as below: 
V ˙ =
− 1 
2 
eT Qe − 1 
γ
Σ
M
j=1 
c j
(
θ ∗
j − θ j )
θ˙j + eT Pbc 
⎡
⎣
Σ
M
j=1 
c j
(
θ ∗
j − θ j )
ζ j (X ) + ε
⎤
⎦
⇒
V ˙ =
− 1 
2 
eT Qe − 1 
γ
Σ
M
j=1 
c j
(
θ ∗
j − θ j )(γ eT Pbcζ j (X) − θ˙j )
+ eT Pbcε
This equation is exactly like the one used in the previous chapter. However, it is 
essential to show that the system remains stable when the structure changes. For this 
purpose, the predefined V (t) remains fixed when the structure changes. It is assumed 
that tc is the time of the structure change, whereas M1 and M2 denote all of the old 
and new rules, respectively (M1 < M2). It is desirable to show that V (t+
c ) = V (t−
c ). 
According to the self-regulated structure algorithm introduced in this chapter, the 
control signal is continuous at tc: 
u(t
+
c ) = u(t
−
c ) (8.5) 
Therefore: 
u(t
+
c ) = u(t
−
c )
x(t
+
c ) = x(t
−
c ) (8.6)142 8 Direct Adaptive Fuzzy Control with a Self-regulated Structure
According to the adaptability rule: 
θ j (t
+
c ) = θ j (t
−
c ), j = 1...M (8.7) 
If the values of inactive adaptive parameters are considered equal to those of the 
active parameters, they do not change at tc: 
θ j (t
+
c ) = θ j (t
−
c ), j = M1 + 1, ..., M2 (8.8) 
Therefore, according to Eqs. (8.6)–(8.8): 
V (
t
−
c )
= 1 
2 
e (
t
−
c )T Pe (
t
−
c )
+
1 
2γ
Σ
M
j=1 
c j
(
θ ∗
j − θ j (
t
−
c ))2 
+
1 
2γ
Σ
N
k=M+1 
ck (
θ ∗
k − θk (
t
−
c ))2 
= 1 
2 
e (
t
+
c )T Pe (
t
+
c )
+
1 
2γ
Σ
M
j=1 
c j
(
θ ∗
j − θ j (
t
+
c ))2 
+
1 
2γ
Σ
N
k=M+1 
ck (
θ ∗
k − θk (
t
+
c ))2 
= V (
t
−
c ) (8.9) 
It should be noted that the self-regulated structure algorithm introduced in this 
chapter is not an optimal algorithm. However, it aims to keep all variables bounded 
in order to follow the reference input. 
The most important limitation mentioned in this chapter is the curse of dimen￾sionality. When the number of inputs increases, complexity grows exponentially. 
Developing the self-regulated structure algorithm to the systems of higher orders 
can be considered an important research avenue in recent years. 
8.5 Application in Inverted Pendulum Control 
The inverted pendulum system is employed to show the performance of the described 
algorithm. The purpose of control is that the output of the angle position y = x1 
should follow the reference signal r (t) = 0.5 sin(t). 
The inputs are selected from the following range: 
x1 ∈ [−1, 1], x2 ∈ [−1, 1], v ∈ [−1, 1]References 143
The control parameters are selected as below: 
k = [
11 ]T 
, Q =
[
20 10 
10 15 ]
, P =
[
25 10 
10 15 ]
, γ = 50 
To test the algorithm, a simulation was run in three steps with different parameters 
summarized in the following table. 
ε0 
err or 
threshold 
min_ mf_ 
distance 
max_ mf_ 
distance 
Brule 
Setup1 0.5 0.5 [
0.2 0.2 0.2 ] [
111 ]
100 
Setup2 0.5 0.5 [
0.4 0.4 0.4 ] [
111 ]
100 
Setup3 0.5 0.5 [
0.4 0.4 0.4 ] [
111 ]
100 
The initial fuzzy system has only one rule, and one membership function was 
considered for each input. 
8.6 Conclusion 
This chapter analyzed the adaptive fuzzy control with a self-regulated structure. The 
described control method has certain advantages. The maximum number of fuzzy 
controller rules in this method can be limited; therefore, the number of rules never 
exceeds a limit. The system stability was fixed when the system structure changed. 
The simulation results for an inverted pendulum system indicated the efficiency of 
this method. 
Moreover, the introduced method is not an optimal algorithm. The most important 
limitation of this method is that it can be applied to the systems where there are fewer 
fuzzy system inputs. In other words, the curse of dimensionality still persists. 
References 
1. J.L. Castro, Fuzzy-logic controllers are universal approximators. IEEE Trans. Syst. Man Cybern. 
25, 629–635 (1995) 
2. M.J. Er, S.Q. Wu, A fast learning algorithm for parsimonious fuzzy neural systems. Fuzzy Sets 
Syst. 126, 337–351 (2002) 
3. F.J. Lin, C.H. Lin, P.H. Shen, Self-constructing fuzzy neural network speed controller for 
permanent-magnet synchronous motor drive. IEEE Trans. Fuzzy Syst. 9, 751–759 (2001) 
4. C.F. Juang, C.T. Lin, An on-line self-constructing neural fuzzy inference network and its 
applications. IEEE Trans. Fuzzy Syst. 6, 12–32 (1998)144 8 Direct Adaptive Fuzzy Control with a Self-regulated Structure
5. Y. Gao, M.J. Er, Online adaptive fuzzy neural identification and control of a class of MIMO 
nonlinear systems. IEEE Trans. Fuzzy Syst. 11, 462–477 (2003) 
6. J.H. Park, G.T. Park, S.H. Kim, C.J. Moon, Output-feedback control of uncertain nonlinear 
systems using a self-structuring adaptive fuzzy observer. Fuzzy Sets Syst. 151, 21–42 (2005) 
7. J.H. Park, G.T. Park, S.H. Kim, C.J. Moon, Direct adaptive self structuring fuzzy controller for 
nonaffine nonlinear system. Fuzzy Sets Syst. 153, 429–445 (2005) 
8. P.A. Phan, T.J. Gale, Direct adaptive fuzzy control with a self-structuring algorithm. Fuzzy Sets 
Syst. 159(8), 871–899 (2008) (In press) 
9. C.W. Park, M. Park, Adaptive parameter estimator based on T–S fuzzy models and its 
applications to indirect adaptive fuzzy control design. Inf. Sci. 159, 125–139 (2004)Chapter 9 
State Limitation Through Supervised 
Control 
9.1 Introduction 
Sometimes, an adaptive fuzzy controller might not be fast enough. In this case, the 
system state variables may fall out of the favorable range. This problem can be 
solved by adding an adaptive gain. However, the adaptive gain cannot be very large. 
At the same time, increasing the adaptive gain will increase noise sensitivity and 
causes volatility in the controller output. Therefore, to help the controlled system 
states remain within the favorable range without needing a large adaptive gain, some 
researchers [1–4] integrated the adaptive fuzzy control with a supervised control 
method. When the states move out of the favorable range, the supervised control 
starts operating and forces the states stay inside that range. 
9.2 Supervised Control for Indirect Adaptive Fuzzy 
Control Systems 
Consider the indirect adaptive fuzzy control system introduced in Chap. 3 [1]. In this 
chapter, a supervised controller us is added above the main controller uI to form the 
controller as below [1]: 
u = uI + us (9.1)
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
A. Mohammadzaheh et al., Modern Adaptive Fuzzy Control Systems, Studies in Fuzziness 
and Soft Computing 421, https://doi.org/10.1007/978-3-031-17393-6_9 
145146 9 State Limitation Through Supervised Control
The controller us should be designed in a way that the state limitation X is guar￾anteed and acts as a supervisor. In other words, us should be equal to zero when the 
state X remains within range completely. It becomes nonzero only when X leaves 
the stability zone. By placing u = uI through u = uI + us, the error equation will 
be as below: 
e ˙ = e + b
 f

(x

θ f ) − f (x)

+ 
g

(x

θg ) − g(x)

uI − g(x)us
	
(9.2) 
The following expression is also defined: 
Ve = 1 
2 
eT pe (9.3) 
where p > 0 meets Eq. (4.21). Since e = 
ym − x1, y˙m − x2, ..., y(n−1) m − xn
T and 
y(n−1) m , ..., y˙m , ym are assumed limited, the limitation of X = (x1, x2, ..., xn)
T will 
work. Hence, the goal is to design us in a way that Ve ≤ V is guaranteed, and V is 
a constant determined through X. 
In (Ve)
1 
2 ≥
 λpmin 
2
1 
2 |e| ≥
 λpmin 
2
1 
2 (|X| − |Ym|), λpmin is the smallest eigenvalue 
of P with Ym = 
y(n−1) m , ..., y˙m , ym
T . Therefore, Ve ≤ V will be equal to |X| ≤
|Ym| +
 2V 
λpmin 1 
2 . Hence, if Mx is a constant when |X| ≤ Mx is desired, V can be 
selected as below: 
V = λpmin 
2


Mx − sup |Ym| t≥0
2 
(9.4) 
Since Ve ≥ 0, a way of guaranteeing Ve ≤ V is to design us in a way that Ve ≤ V 
and V˙
e < 0: 
V˙
e = −1 
2 
eT Qe + eT pb f

− f

+ 
g

− g

uI − gus
	
≤ −
1 
2 
eT Qe + 
eT pb



 f


 + | f | + 
g

uI

 + |guI |
	
− eT pbgus (9.5) 
To design us in a way that the right side of Eq. (9.5) is negative, the bounds of f 
and g must be known. Hence, f U (X ), gU (X ), gL (X) are assumed in a way that 
0 < gL (X ) ≤ g0(X ) ≤ gU (X ), | f (X)| ≤ f U (X ), X ∈ Rn. 
Therefore, the supervised control us is selected as below: 
us = I ∗sgn(eT pb)
1 
gL (X )


 f

(X

θ f )


 + f U (X ) + 
g

(X

θg )uI

 + 
gU (X)uI


	
(9.6)9.3 Supervised Control for Fuzzy Control Systems in General 147
If Ve ≤ V , then I ∗ = 1, and if Ve > V , then I ∗ = 0. By replacing in Eq. (9.5), if 
Ve ≤ V , then: 
V˙
e ≤ −
1 
2 
eT Qe + 
eT pb



 f


 + | f | + 
g

uI

 − g 
gl


 f


 + 
 f U 
 + 
g

uI


+

gU uI


 ≤ −
1 
2 
eT Qe < 0 (9.7) 
Assume that e = 0 because it is natural due to e = 0. As a result, Control (9.1) 
in which us is presented through Eq. (9.6) will guarantee Ve ≤ V . If V is selected 
from Eq. (9.4), |X| ≤ Mx is guaranteed for every given constant Mx . 
If the system becomes unstable (Ve ≥ V ), the supervised controller starts 
operating to force Ve ≤ V to be true. 
9.3 Supervised Control for Fuzzy Control Systems 
in General 
Consider the adaptive fuzzy control system from Chap. 6. The fuzzy system acts as a 
controller. The fuzzy controller u f uzzy is attached to a supervised controller us until 
the state belongs to {x : |x| ≤ Mx }. Moreover, us will be zero. In other words, the 
controller will be defined as below with respect to the previous subchapter [1]: 
u = u f uzzy + I ∗us (9.8) 
where the indicator function is I ∗ = 1 if |X| ≥ Mx ; otherwise, it will be I ∗ = 0. It 
is assumed that the system is like x n = f (X ) + g(X )u, replacing Eq. (9.8) will lead 
to: 
x n = f (X ) + g(X )u f uzzy + g(X )I ∗us (9.9) 
According to the previous subchapter, the upper and lower bounds of functions are 
assumed known. In other words, functions f U (X ), gU (X ), gL (X) are determined in 
a way that | f (X )| ≤ f U (X ) and 0 < gL (X) ≤ g0(X ) ≤ gU (X ) for all X ∈ Rn. The 
following equation is defined: 
u∗ = 1 
g(X )

− f (X ) − K T X
 (9.10) 
where K = (kn, ..., k1)
T ∈ Rn, and all roots of the polynomial sn + k1s + ··· + kn 
are placed on the left half of the mixed plane. According to Eqs. (9.10) and (9.9) is 
rewritten as below: 
x n = −K T X + f (X ) + g

u f uzzy − u∗ + I ∗us
 (9.11)148 9 State Limitation Through Supervised Control
The following matrix is defined:
 =
⎡
⎢
⎢
⎢
⎢
⎢
⎣
0 1 0 0 ··· 00 
0 0 1 0 ··· 00 
.
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
.
0 0 0 0 ··· 01 
−k1 −k2 ··· ··· ··· ··· −kn 
⎤
⎥
⎥
⎥
⎥
⎥
⎦
, b =
⎡
⎢
⎢
⎢
⎣
0 
.
.
.
0 
g 
⎤
⎥
⎥
⎥
⎦
(9.12) 
Equation (9.11) is written as below: 
x n = X + f (X ) + b

u f uzzy − u∗ + I ∗us
 (9.13) 
The candidate Lyopunov function is defined as below to design the supervised 
controller to guarantee |X| ≤ Mx : 
V = 1 
2 
X T P X (9.14) 
where P is a positive definite matrix that meets the Lyopunov equation:
T P + P = −Q (9.15) 
where Q > 0 is determined through a designer. Equations (9.13) and (9.14) are used 
through |X| ≥ Mx : 
V ˙ = −1 
2 
X T QX + X T Pb
u f uzzy − u∗ + us

≤ 
X T Pb


u f uzzy

 + 
u∗



+ X T Pbus (9.16) 
To make V ˙ negative, us is selected as below: 
us = −sgn(X T Pb)
 1 
gl

f u + 
K T X



+ 
u f uzzy



(9.17) 
Therefore, the supervised controller us guarantees that |X| will be downward if 
|X| ≥ Mx . 
Since I ∗ is a step function in Eq. (9.8), it is possible that the system fluctuates 
within |X| = M. To avoid the problem of fluctuation, a method is to allow I ∗ to 
change continuously from 0 to 1. In particular, I ∗ can be selected as below: 
I ∗ =
⎧
⎪⎨
⎪⎩
0 |X| < a |X|−a 
Mx−a a ≤ |X| < Mx 
1 |X| ≥ Mx 
(9.18)References 149
where a ∈ (0, Mx ) is the parameter determined by a designer. 
9.4 Conclusion 
This chapter presented the idea of supervising the fuzzy control. Despite its accept￾able performance, the fuzzy control is not supported in industrial applications. There￾fore, this controller should be combined with the other compensators to guarantee its 
stability. Many methods have been proposed in different papers for the stabilization 
of fuzzy controllers. This chapter focused on a basic idea in general. 
References 
1. L.-X. Wang, Adaptive Fuzzy Systems and Control: Design and Stability Analysis. Prentice-Hall: 
Englewood Cliffs, New Jersey (1994) 
2. C.H. Wang, T.C. Lin, T.T. Lee, H.L. Liu, Adaptive hybrid intelligent control for uncertain 
nonlinear dynamical systems. IEEE Trans. Syst. Man Cybern. Part B Cybern. 32, 583–597 
(2002) 
3. D.L. Tsay, H.Y. Chung, C.J. Lee, The adaptive control of nonlinear systems using the Sugeno￾type of fuzzy logic. IEEE Trans. Fuzzy Syst. 7, 225–229 (1999) 
4. C.H. Wang, H.L. Liu, T.C. Lin, Direct adaptive fuzzy-neural control with state observer and 
supervisory controller for unknown nonlinear dynamical systems. IEEE Trans. Fuzzy Syst. 10, 
39–49 (2002)Chapter 10 
Adaptive Sliding Fuzzy Control 
10.1 Introduction 
In recent years, the sliding mode controller has been known as a popular technique 
for controlling nonlinear systems due to its insensitivity and resistance to external 
distortions and uncertainties. However, this controller has some disadvantages such 
as the unfavorable phenomenon of chattering, which can be dealt with by using the 
continuous approximation. Another method is to employed the high-order sliding 
mode, which is a technique for improving the sliding mode precision and eliminating 
the chattering problem. It is also possible to use hybrid methods for removing these 
disadvantages. In this dissertation, the sliding mode was integrated with adaptive 
control to solve this problem. In this case, the sliding mode method becomes a 
high-precision control method with a simple structure and a high level or resistance. 
10.2 Designing a Controller 
Consider a class of nonlinear systems as below: 
x˙1 = x2 
x˙1 = x2 
.
.
.
x˙n = f (x1, x2, ..., xn) + g(x1, x2, ..., xn)u (10.1)
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
A. Mohammadzaheh et al., Modern Adaptive Fuzzy Control Systems, Studies in Fuzziness 
and Soft Computing 421, https://doi.org/10.1007/978-3-031-17393-6_10 
151152 10 Adaptive Sliding Fuzzy Control
To design the neuro-fuzzy control, the indefinite functions f (x1, x2, ..., xn)
and g(x1, x2, ..., xn) are estimated through the fuzzy systems g(x1, x2, ..., xn) and 
gˆ(x1, x2, ..., xn). 
A sliding level is defined as below to design a controller: 
s = e(n−1) + λn−2e(n−2) + ··· + λ2e ˙ + λ1e (10.2) 
where λi = i = 1, ..., n − 2 is determined in a way that e(n−1) + λn−2e(n−2) +···+
λ2e ˙ + λ1e becomes the Hurwitz stability, and the tracking error might be defined as 
e = y − r. Moreover, r is the favorable signal. 
By calculating the derivative of Eq. (2.10), the following result will be yielded: 
s ˙ = e(n) + λn−2e(n−1) + ··· + λ2e ¨ + λ1e˙ (10.3) 
To perform the tracking process, s ˙ should be made zero. According to Eq. (10.3): 
s ˙ = e(n) + λn−2e(n−1) + ··· + λ2e ¨ + λ1e ˙ = 0 
x(n)
1 − r(n) + λn−2e(n−1) + ··· + λ2e ¨ + λ1e ˙ = 0 
⇒
f (x1, x2, ..., xn) + g(x1, x2, ..., xn)u − r(n)
+ λn−2e(n−1) + ··· + λ2e ¨ + λ1e ˙ = 0 (10.4) 
In Eq. (10.4), f (x1, x2, ..., xn) and g(x1, x2, ..., xn) are replaced with the fuzzy 
systems f

(x1, x2, ..., xn) and g

(x1, x2, ..., xn). According to the idea of the sliding 
mode control: 
u = 1 
gˆ(x1, x2, ..., xn)

r(n) − λn−2e(n−1) − ··· − λ2e ¨ − λ1e ˙ − f

(x1, x2, ..., xn) − K sign(s)

(10.5) 
Equation (10.5) is placed in Eq. (10.4): 
s ˙ = f (x1, x2, ..., xn) − f

(x1, x2, ..., xn)
+ 
g(x1, x2, ..., xn) − g

(x1, x2, ..., xn)

u − K sign(s) (10.6) 
The fuzzy system is defined with optimal parameters as f

∗
(x1, x2, ..., xn) and 
g

∗
(x1, x2, ..., xn). These two functions are added to and subtracted from Eq. (10.6), 
and the result is as follows: 
s ˙ = f − ˆf ∗ + 
g − ˆg∗
u + ˆf ∗ − ˆf + 
gˆ
∗ − ˆg

u − K sign(s) (10.7)10.2 Designing a Controller 153
The fuzzy systems are vectorized as below: 
f

∗
= w∗T 
f ζ f 
f

= wT 
f ζ f 
g

∗ = w∗T 
g ζg 
gg

= wT 
g ζg 
E ≡ f − f

∗
+ 
g − g

∗
u 
(10.8) 
Therefore: 
s ˙ = E + 
w∗
f − w f
T ζ f + 
w∗
g − wg
T ζgu − K sign(s) (10.9) 
To adjust the parameters of fuzzy systems, the Lyopunov function is defined as 
below: 
V = 1 
2 
s2 
+
1 
2γ

w∗
f − w f
T 
w∗
f − w f

+
1 
2γ

w∗
g − wg
T 
w∗
g − wg
 (10.10) 
The derivative of Eq. (10.10) is calculated: 
V ˙ = ss ˙ − 1 
γ

w∗
f − w f
T 
w˙ f − 1 
γ

w∗
g − wg
T 
w˙ g (10.11) 
By placing the equivalent of s˙: 
V ˙ = s

E + 
w∗
f − w f
T ζ f + 
w∗
g − wg
T ζgu − K sign(s)

+
1 
γ

w∗
f − w f
T 
w˙ f +
1 
γ

w∗
g − wg
T 
w˙ g 
= sE − Ks × sign(s)

w∗
f − w f
T
	
sζ f − 1 
γ
w˙ f


+ 
w∗
g − wg
T
	
sζgu − 1 
γ
w˙ g


(10.12) 
The adaptability rules are selected as below through Eq. (10.12): 
w˙ f = γ sζ f 
w˙ g = γ sζgu (10.13)154 10 Adaptive Sliding Fuzzy Control
Equations (10.12) and (10.13) are then employed: 
V ˙ = sE − Ks × sign(s) (10.14) 
Since s × sign(s) = |s|: 
V ˙ ≤ |s||E| − K|s|
V ˙ ≤ |s|[|E| − K ] (10.15) 
Hence, the following inequality should be true for stability: 
|E| < K (10.16) 
10.3 Simulation 
Example 1 Consider the inverted pendulum system first for simulation: 
x˙1 = x2 
x˙2 =
	
g sin(x1) − mlx 2 
2 sin(x1) cos(x1)
mc + m


. 1 
l

4 
3 − m cos2(x1)
mc+m

+
cos(x1)
mc + m . 1 
l

4 
3 − m cos2(x1)
mc+m
u 
where m = 0.1 kg, mc = 1 kg,l = 0.5 m. 
The reference input was considered sin(t). Figure 10.1 reports the tracking results, 
whereas Fig. 10.2 demonstrates the control signal. Accordingly, the results are 
completely suitable. Figure 10.3 depicts the Simulink designed in MATLAB.
Example 2 In this example, the magnetic suspension system is defined as below: 
x˙1 = x2 
x˙2 = −g − β
M x2 +
α
M x1 
u 
y = x1 
where M = 3 kg, α = 15, β = 12, g = 9.8.10.3 Simulation 155
0 5 10 15 20 25 30
-1.5
-1
-0.5 
0 
0.5 
1 
1.5
 Time
 y
 r 
Fig. 10.1 The tracking output diagram 
0 5 10 15 20 25 30
-100
-80
-60
-40
-20 
0 
20 
40 
60 
80 
100 control signal
 Time 
Fig. 10.2 The control signal
The initial values and other parameters of simulation are similar to those of 
Example 1. 
Figure 10.4 demonstrates the results of tracking outputs, whereas Fig. 10.5 depicts 
the control signal. Moreover, Fig. 10.6 indicates the Simulink designed in MATLAB.156 10 Adaptive Sliding Fuzzy Control
Fig. 10.3 Simulation in MATLAB
0 5 10 15 20 25 30 
0 
0.2 
0.4 
0.6 
0.8 
1 
1.2 
1.4
 Time
 y
 r 
Fig. 10.4 The output diagram 
0 5 10 15 20 25 30
-10
-8
-6
-4
-2 
0 
2 
4 
6 
8 
10 control signal
 Time 
Fig. 10.5 The control signal10.4 Conclusion 157
Fig. 10.6 Simulation in MATLAB 
10.4 Conclusion 
This chapter designed and simulation the fuzzy sliding mode controller. According 
to the simulation results, this controller was very efficient, despite its simplicity. It 
was partially resistant to external distortions and uncertainty. The most important 
problem with this controller lies in the switching section, which sometimes causes 
the control signal chattering. Different methods have been proposed to solve this 
problem. The dear readers can see the relevant papers.
